var qn = Object.defineProperty;
var Hn = ($e, Ze, Fe) => Ze in $e ? qn($e, Ze, { enumerable: !0, configurable: !0, writable: !0, value: Fe }) : $e[Ze] = Fe;
var Or = ($e, Ze, Fe) => (Hn($e, typeof Ze != "symbol" ? Ze + "" : Ze, Fe), Fe);
import * as React from "react";
import React__default, { createContext, useMemo, createElement, useContext, useRef, useEffect, useLayoutEffect, useCallback, forwardRef, Children, isValidElement, cloneElement, Fragment, useState, useId as useId$1, useDebugValue, memo, useReducer } from "react";
import * as ReactDOM from "react-dom";
import { flushSync, createPortal } from "react-dom";
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs($e) {
  return $e && $e.__esModule && Object.prototype.hasOwnProperty.call($e, "default") ? $e.default : $e;
}
function getAugmentedNamespace($e) {
  if ($e.__esModule)
    return $e;
  var Ze = $e.default;
  if (typeof Ze == "function") {
    var Fe = function Ke() {
      if (this instanceof Ke) {
        var Ve = [null];
        Ve.push.apply(Ve, arguments);
        var Je = Function.bind.apply(Ze, Ve);
        return new Je();
      }
      return Ze.apply(this, arguments);
    };
    Fe.prototype = Ze.prototype;
  } else
    Fe = {};
  return Object.defineProperty(Fe, "__esModule", { value: !0 }), Object.keys($e).forEach(function(Ke) {
    var Ve = Object.getOwnPropertyDescriptor($e, Ke);
    Object.defineProperty(Fe, Ke, Ve.get ? Ve : {
      enumerable: !0,
      get: function() {
        return $e[Ke];
      }
    });
  }), Fe;
}
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min)
    return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var $e = React__default, Ze = Symbol.for("react.element"), Fe = Symbol.for("react.fragment"), Ke = Object.prototype.hasOwnProperty, Ve = $e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, Je = { key: !0, ref: !0, __self: !0, __source: !0 };
  function Qe(at, ut, lt) {
    var dt, bt = {}, $t = null, vt = null;
    lt !== void 0 && ($t = "" + lt), ut.key !== void 0 && ($t = "" + ut.key), ut.ref !== void 0 && (vt = ut.ref);
    for (dt in ut)
      Ke.call(ut, dt) && !Je.hasOwnProperty(dt) && (bt[dt] = ut[dt]);
    if (at && at.defaultProps)
      for (dt in ut = at.defaultProps, ut)
        bt[dt] === void 0 && (bt[dt] = ut[dt]);
    return { $$typeof: Ze, type: at, key: $t, ref: vt, props: bt, _owner: Ve.current };
  }
  return reactJsxRuntime_production_min.Fragment = Fe, reactJsxRuntime_production_min.jsx = Qe, reactJsxRuntime_production_min.jsxs = Qe, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process.env.NODE_ENV !== "production" && function() {
    var $e = React__default, Ze = Symbol.for("react.element"), Fe = Symbol.for("react.portal"), Ke = Symbol.for("react.fragment"), Ve = Symbol.for("react.strict_mode"), Je = Symbol.for("react.profiler"), Qe = Symbol.for("react.provider"), at = Symbol.for("react.context"), ut = Symbol.for("react.forward_ref"), lt = Symbol.for("react.suspense"), dt = Symbol.for("react.suspense_list"), bt = Symbol.for("react.memo"), $t = Symbol.for("react.lazy"), vt = Symbol.for("react.offscreen"), wt = Symbol.iterator, xt = "@@iterator";
    function Et(tr) {
      if (tr === null || typeof tr != "object")
        return null;
      var Dr = wt && tr[wt] || tr[xt];
      return typeof Dr == "function" ? Dr : null;
    }
    var Tt = $e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function Rt(tr) {
      {
        for (var Dr = arguments.length, fr = new Array(Dr > 1 ? Dr - 1 : 0), Mr = 1; Mr < Dr; Mr++)
          fr[Mr - 1] = arguments[Mr];
        Ct("error", tr, fr);
      }
    }
    function Ct(tr, Dr, fr) {
      {
        var Mr = Tt.ReactDebugCurrentFrame, Fr = Mr.getStackAddendum();
        Fr !== "" && (Dr += "%s", fr = fr.concat([Fr]));
        var qr = fr.map(function(tn) {
          return String(tn);
        });
        qr.unshift("Warning: " + Dr), Function.prototype.apply.call(console[tr], console, qr);
      }
    }
    var Zt = !1, Lt = !1, Ut = !1, Pt = !1, Ot = !1, Ft;
    Ft = Symbol.for("react.module.reference");
    function gt(tr) {
      return !!(typeof tr == "string" || typeof tr == "function" || tr === Ke || tr === Je || Ot || tr === Ve || tr === lt || tr === dt || Pt || tr === vt || Zt || Lt || Ut || typeof tr == "object" && tr !== null && (tr.$$typeof === $t || tr.$$typeof === bt || tr.$$typeof === Qe || tr.$$typeof === at || tr.$$typeof === ut || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      tr.$$typeof === Ft || tr.getModuleId !== void 0));
    }
    function We(tr, Dr, fr) {
      var Mr = tr.displayName;
      if (Mr)
        return Mr;
      var Fr = Dr.displayName || Dr.name || "";
      return Fr !== "" ? fr + "(" + Fr + ")" : fr;
    }
    function Xe(tr) {
      return tr.displayName || "Context";
    }
    function rt(tr) {
      if (tr == null)
        return null;
      if (typeof tr.tag == "number" && Rt("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof tr == "function")
        return tr.displayName || tr.name || null;
      if (typeof tr == "string")
        return tr;
      switch (tr) {
        case Ke:
          return "Fragment";
        case Fe:
          return "Portal";
        case Je:
          return "Profiler";
        case Ve:
          return "StrictMode";
        case lt:
          return "Suspense";
        case dt:
          return "SuspenseList";
      }
      if (typeof tr == "object")
        switch (tr.$$typeof) {
          case at:
            var Dr = tr;
            return Xe(Dr) + ".Consumer";
          case Qe:
            var fr = tr;
            return Xe(fr._context) + ".Provider";
          case ut:
            return We(tr, tr.render, "ForwardRef");
          case bt:
            var Mr = tr.displayName || null;
            return Mr !== null ? Mr : rt(tr.type) || "Memo";
          case $t: {
            var Fr = tr, qr = Fr._payload, tn = Fr._init;
            try {
              return rt(tn(qr));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ot = Object.assign, ft = 0, mt, yt, pt, Ge, ct, Mt, St;
    function At() {
    }
    At.__reactDisabledLog = !0;
    function Nt() {
      {
        if (ft === 0) {
          mt = console.log, yt = console.info, pt = console.warn, Ge = console.error, ct = console.group, Mt = console.groupCollapsed, St = console.groupEnd;
          var tr = {
            configurable: !0,
            enumerable: !0,
            value: At,
            writable: !0
          };
          Object.defineProperties(console, {
            info: tr,
            log: tr,
            warn: tr,
            error: tr,
            group: tr,
            groupCollapsed: tr,
            groupEnd: tr
          });
        }
        ft++;
      }
    }
    function qt() {
      {
        if (ft--, ft === 0) {
          var tr = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: ot({}, tr, {
              value: mt
            }),
            info: ot({}, tr, {
              value: yt
            }),
            warn: ot({}, tr, {
              value: pt
            }),
            error: ot({}, tr, {
              value: Ge
            }),
            group: ot({}, tr, {
              value: ct
            }),
            groupCollapsed: ot({}, tr, {
              value: Mt
            }),
            groupEnd: ot({}, tr, {
              value: St
            })
          });
        }
        ft < 0 && Rt("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Qt = Tt.ReactCurrentDispatcher, Xt;
    function zt(tr, Dr, fr) {
      {
        if (Xt === void 0)
          try {
            throw Error();
          } catch (Fr) {
            var Mr = Fr.stack.trim().match(/\n( *(at )?)/);
            Xt = Mr && Mr[1] || "";
          }
        return `
` + Xt + tr;
      }
    }
    var Kt = !1, ur;
    {
      var er = typeof WeakMap == "function" ? WeakMap : Map;
      ur = new er();
    }
    function Dt(tr, Dr) {
      if (!tr || Kt)
        return "";
      {
        var fr = ur.get(tr);
        if (fr !== void 0)
          return fr;
      }
      var Mr;
      Kt = !0;
      var Fr = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var qr;
      qr = Qt.current, Qt.current = null, Nt();
      try {
        if (Dr) {
          var tn = function() {
            throw Error();
          };
          if (Object.defineProperty(tn.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(tn, []);
            } catch (Sr) {
              Mr = Sr;
            }
            Reflect.construct(tr, [], tn);
          } else {
            try {
              tn.call();
            } catch (Sr) {
              Mr = Sr;
            }
            tr.call(tn.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Sr) {
            Mr = Sr;
          }
          tr();
        }
      } catch (Sr) {
        if (Sr && Mr && typeof Sr.stack == "string") {
          for (var Qr = Sr.stack.split(`
`), nn = Mr.stack.split(`
`), Er = Qr.length - 1, Wt = nn.length - 1; Er >= 1 && Wt >= 0 && Qr[Er] !== nn[Wt]; )
            Wt--;
          for (; Er >= 1 && Wt >= 0; Er--, Wt--)
            if (Qr[Er] !== nn[Wt]) {
              if (Er !== 1 || Wt !== 1)
                do
                  if (Er--, Wt--, Wt < 0 || Qr[Er] !== nn[Wt]) {
                    var nr = `
` + Qr[Er].replace(" at new ", " at ");
                    return tr.displayName && nr.includes("<anonymous>") && (nr = nr.replace("<anonymous>", tr.displayName)), typeof tr == "function" && ur.set(tr, nr), nr;
                  }
                while (Er >= 1 && Wt >= 0);
              break;
            }
        }
      } finally {
        Kt = !1, Qt.current = qr, qt(), Error.prepareStackTrace = Fr;
      }
      var pr = tr ? tr.displayName || tr.name : "", Pr = pr ? zt(pr) : "";
      return typeof tr == "function" && ur.set(tr, Pr), Pr;
    }
    function Ht(tr, Dr, fr) {
      return Dt(tr, !1);
    }
    function Gt(tr) {
      var Dr = tr.prototype;
      return !!(Dr && Dr.isReactComponent);
    }
    function rr(tr, Dr, fr) {
      if (tr == null)
        return "";
      if (typeof tr == "function")
        return Dt(tr, Gt(tr));
      if (typeof tr == "string")
        return zt(tr);
      switch (tr) {
        case lt:
          return zt("Suspense");
        case dt:
          return zt("SuspenseList");
      }
      if (typeof tr == "object")
        switch (tr.$$typeof) {
          case ut:
            return Ht(tr.render);
          case bt:
            return rr(tr.type, Dr, fr);
          case $t: {
            var Mr = tr, Fr = Mr._payload, qr = Mr._init;
            try {
              return rr(qr(Fr), Dr, fr);
            } catch {
            }
          }
        }
      return "";
    }
    var sr = Object.prototype.hasOwnProperty, Jt = {}, ir = Tt.ReactDebugCurrentFrame;
    function Br(tr) {
      if (tr) {
        var Dr = tr._owner, fr = rr(tr.type, tr._source, Dr ? Dr.type : null);
        ir.setExtraStackFrame(fr);
      } else
        ir.setExtraStackFrame(null);
    }
    function or(tr, Dr, fr, Mr, Fr) {
      {
        var qr = Function.call.bind(sr);
        for (var tn in tr)
          if (qr(tr, tn)) {
            var Qr = void 0;
            try {
              if (typeof tr[tn] != "function") {
                var nn = Error((Mr || "React class") + ": " + fr + " type `" + tn + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof tr[tn] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw nn.name = "Invariant Violation", nn;
              }
              Qr = tr[tn](Dr, tn, Mr, fr, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Er) {
              Qr = Er;
            }
            Qr && !(Qr instanceof Error) && (Br(Fr), Rt("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Mr || "React class", fr, tn, typeof Qr), Br(null)), Qr instanceof Error && !(Qr.message in Jt) && (Jt[Qr.message] = !0, Br(Fr), Rt("Failed %s type: %s", fr, Qr.message), Br(null));
          }
      }
    }
    var lr = Array.isArray;
    function Nr(tr) {
      return lr(tr);
    }
    function dr(tr) {
      {
        var Dr = typeof Symbol == "function" && Symbol.toStringTag, fr = Dr && tr[Symbol.toStringTag] || tr.constructor.name || "Object";
        return fr;
      }
    }
    function gr(tr) {
      try {
        return Zr(tr), !1;
      } catch {
        return !0;
      }
    }
    function Zr(tr) {
      return "" + tr;
    }
    function Bt(tr) {
      if (gr(tr))
        return Rt("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", dr(tr)), Zr(tr);
    }
    var kt = Tt.ReactCurrentOwner, It = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, jt, Vt, ar;
    ar = {};
    function Yt(tr) {
      if (sr.call(tr, "ref")) {
        var Dr = Object.getOwnPropertyDescriptor(tr, "ref").get;
        if (Dr && Dr.isReactWarning)
          return !1;
      }
      return tr.ref !== void 0;
    }
    function hr(tr) {
      if (sr.call(tr, "key")) {
        var Dr = Object.getOwnPropertyDescriptor(tr, "key").get;
        if (Dr && Dr.isReactWarning)
          return !1;
      }
      return tr.key !== void 0;
    }
    function zr(tr, Dr) {
      if (typeof tr.ref == "string" && kt.current && Dr && kt.current.stateNode !== Dr) {
        var fr = rt(kt.current.type);
        ar[fr] || (Rt('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', rt(kt.current.type), tr.ref), ar[fr] = !0);
      }
    }
    function cr(tr, Dr) {
      {
        var fr = function() {
          jt || (jt = !0, Rt("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Dr));
        };
        fr.isReactWarning = !0, Object.defineProperty(tr, "key", {
          get: fr,
          configurable: !0
        });
      }
    }
    function _r(tr, Dr) {
      {
        var fr = function() {
          Vt || (Vt = !0, Rt("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Dr));
        };
        fr.isReactWarning = !0, Object.defineProperty(tr, "ref", {
          get: fr,
          configurable: !0
        });
      }
    }
    var Lr = function(tr, Dr, fr, Mr, Fr, qr, tn) {
      var Qr = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: Ze,
        // Built-in properties that belong on the element
        type: tr,
        key: Dr,
        ref: fr,
        props: tn,
        // Record the component responsible for creating this element.
        _owner: qr
      };
      return Qr._store = {}, Object.defineProperty(Qr._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Qr, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Mr
      }), Object.defineProperty(Qr, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Fr
      }), Object.freeze && (Object.freeze(Qr.props), Object.freeze(Qr)), Qr;
    };
    function br(tr, Dr, fr, Mr, Fr) {
      {
        var qr, tn = {}, Qr = null, nn = null;
        fr !== void 0 && (Bt(fr), Qr = "" + fr), hr(Dr) && (Bt(Dr.key), Qr = "" + Dr.key), Yt(Dr) && (nn = Dr.ref, zr(Dr, Fr));
        for (qr in Dr)
          sr.call(Dr, qr) && !It.hasOwnProperty(qr) && (tn[qr] = Dr[qr]);
        if (tr && tr.defaultProps) {
          var Er = tr.defaultProps;
          for (qr in Er)
            tn[qr] === void 0 && (tn[qr] = Er[qr]);
        }
        if (Qr || nn) {
          var Wt = typeof tr == "function" ? tr.displayName || tr.name || "Unknown" : tr;
          Qr && cr(tn, Wt), nn && _r(tn, Wt);
        }
        return Lr(tr, Qr, nn, Fr, Mr, kt.current, tn);
      }
    }
    var kr = Tt.ReactCurrentOwner, Xr = Tt.ReactDebugCurrentFrame;
    function yr(tr) {
      if (tr) {
        var Dr = tr._owner, fr = rr(tr.type, tr._source, Dr ? Dr.type : null);
        Xr.setExtraStackFrame(fr);
      } else
        Xr.setExtraStackFrame(null);
    }
    var Ir;
    Ir = !1;
    function Yr(tr) {
      return typeof tr == "object" && tr !== null && tr.$$typeof === Ze;
    }
    function wr() {
      {
        if (kr.current) {
          var tr = rt(kr.current.type);
          if (tr)
            return `

Check the render method of \`` + tr + "`.";
        }
        return "";
      }
    }
    function Cr(tr) {
      {
        if (tr !== void 0) {
          var Dr = tr.fileName.replace(/^.*[\\\/]/, ""), fr = tr.lineNumber;
          return `

Check your code at ` + Dr + ":" + fr + ".";
        }
        return "";
      }
    }
    var Hr = {};
    function $r(tr) {
      {
        var Dr = wr();
        if (!Dr) {
          var fr = typeof tr == "string" ? tr : tr.displayName || tr.name;
          fr && (Dr = `

Check the top-level render call using <` + fr + ">.");
        }
        return Dr;
      }
    }
    function Ar(tr, Dr) {
      {
        if (!tr._store || tr._store.validated || tr.key != null)
          return;
        tr._store.validated = !0;
        var fr = $r(Dr);
        if (Hr[fr])
          return;
        Hr[fr] = !0;
        var Mr = "";
        tr && tr._owner && tr._owner !== kr.current && (Mr = " It was passed a child from " + rt(tr._owner.type) + "."), yr(tr), Rt('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', fr, Mr), yr(null);
      }
    }
    function Wr(tr, Dr) {
      {
        if (typeof tr != "object")
          return;
        if (Nr(tr))
          for (var fr = 0; fr < tr.length; fr++) {
            var Mr = tr[fr];
            Yr(Mr) && Ar(Mr, Dr);
          }
        else if (Yr(tr))
          tr._store && (tr._store.validated = !0);
        else if (tr) {
          var Fr = Et(tr);
          if (typeof Fr == "function" && Fr !== tr.entries)
            for (var qr = Fr.call(tr), tn; !(tn = qr.next()).done; )
              Yr(tn.value) && Ar(tn.value, Dr);
        }
      }
    }
    function mr(tr) {
      {
        var Dr = tr.type;
        if (Dr == null || typeof Dr == "string")
          return;
        var fr;
        if (typeof Dr == "function")
          fr = Dr.propTypes;
        else if (typeof Dr == "object" && (Dr.$$typeof === ut || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Dr.$$typeof === bt))
          fr = Dr.propTypes;
        else
          return;
        if (fr) {
          var Mr = rt(Dr);
          or(fr, tr.props, "prop", Mr, tr);
        } else if (Dr.PropTypes !== void 0 && !Ir) {
          Ir = !0;
          var Fr = rt(Dr);
          Rt("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Fr || "Unknown");
        }
        typeof Dr.getDefaultProps == "function" && !Dr.getDefaultProps.isReactClassApproved && Rt("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Tr(tr) {
      {
        for (var Dr = Object.keys(tr.props), fr = 0; fr < Dr.length; fr++) {
          var Mr = Dr[fr];
          if (Mr !== "children" && Mr !== "key") {
            yr(tr), Rt("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Mr), yr(null);
            break;
          }
        }
        tr.ref !== null && (yr(tr), Rt("Invalid attribute `ref` supplied to `React.Fragment`."), yr(null));
      }
    }
    function Kr(tr, Dr, fr, Mr, Fr, qr) {
      {
        var tn = gt(tr);
        if (!tn) {
          var Qr = "";
          (tr === void 0 || typeof tr == "object" && tr !== null && Object.keys(tr).length === 0) && (Qr += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var nn = Cr(Fr);
          nn ? Qr += nn : Qr += wr();
          var Er;
          tr === null ? Er = "null" : Nr(tr) ? Er = "array" : tr !== void 0 && tr.$$typeof === Ze ? (Er = "<" + (rt(tr.type) || "Unknown") + " />", Qr = " Did you accidentally export a JSX literal instead of a component?") : Er = typeof tr, Rt("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Er, Qr);
        }
        var Wt = br(tr, Dr, fr, Fr, qr);
        if (Wt == null)
          return Wt;
        if (tn) {
          var nr = Dr.children;
          if (nr !== void 0)
            if (Mr)
              if (Nr(nr)) {
                for (var pr = 0; pr < nr.length; pr++)
                  Wr(nr[pr], tr);
                Object.freeze && Object.freeze(nr);
              } else
                Rt("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Wr(nr, tr);
        }
        return tr === Ke ? Tr(Wt) : mr(Wt), Wt;
      }
    }
    function vr(tr, Dr, fr) {
      return Kr(tr, Dr, fr, !0);
    }
    function Rr(tr, Dr, fr) {
      return Kr(tr, Dr, fr, !1);
    }
    var Jr = Rr, xr = vr;
    reactJsxRuntime_development.Fragment = Ke, reactJsxRuntime_development.jsx = Jr, reactJsxRuntime_development.jsxs = xr;
  }()), reactJsxRuntime_development;
}
process.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function($e) {
    for (var Ze = 1; Ze < arguments.length; Ze++) {
      var Fe = arguments[Ze];
      for (var Ke in Fe)
        Object.prototype.hasOwnProperty.call(Fe, Ke) && ($e[Ke] = Fe[Ke]);
    }
    return $e;
  }, _extends$1.apply(this, arguments);
}
function $c512c27ab02ef895$export$50c7b4e9d9f19c1($e, Ze = []) {
  let Fe = [];
  function Ke(Je, Qe) {
    const at = /* @__PURE__ */ createContext(Qe), ut = Fe.length;
    Fe = [
      ...Fe,
      Qe
    ];
    function lt(bt) {
      const { scope: $t, children: vt, ...wt } = bt, xt = ($t == null ? void 0 : $t[$e][ut]) || at, Et = useMemo(
        () => wt,
        Object.values(wt)
      );
      return /* @__PURE__ */ createElement(xt.Provider, {
        value: Et
      }, vt);
    }
    function dt(bt, $t) {
      const vt = ($t == null ? void 0 : $t[$e][ut]) || at, wt = useContext(vt);
      if (wt)
        return wt;
      if (Qe !== void 0)
        return Qe;
      throw new Error(`\`${bt}\` must be used within \`${Je}\``);
    }
    return lt.displayName = Je + "Provider", [
      lt,
      dt
    ];
  }
  const Ve = () => {
    const Je = Fe.map((Qe) => /* @__PURE__ */ createContext(Qe));
    return function(at) {
      const ut = (at == null ? void 0 : at[$e]) || Je;
      return useMemo(
        () => ({
          [`__scope${$e}`]: {
            ...at,
            [$e]: ut
          }
        }),
        [
          at,
          ut
        ]
      );
    };
  };
  return Ve.scopeName = $e, [
    Ke,
    $c512c27ab02ef895$var$composeContextScopes(Ve, ...Ze)
  ];
}
function $c512c27ab02ef895$var$composeContextScopes(...$e) {
  const Ze = $e[0];
  if ($e.length === 1)
    return Ze;
  const Fe = () => {
    const Ke = $e.map(
      (Ve) => ({
        useScope: Ve(),
        scopeName: Ve.scopeName
      })
    );
    return function(Je) {
      const Qe = Ke.reduce((at, { useScope: ut, scopeName: lt }) => {
        const bt = ut(Je)[`__scope${lt}`];
        return {
          ...at,
          ...bt
        };
      }, {});
      return useMemo(
        () => ({
          [`__scope${Ze.scopeName}`]: Qe
        }),
        [
          Qe
        ]
      );
    };
  };
  return Fe.scopeName = Ze.scopeName, Fe;
}
function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a($e) {
  const Ze = useRef($e);
  return useEffect(() => {
    Ze.current = $e;
  }), useMemo(
    () => (...Fe) => {
      var Ke;
      return (Ke = Ze.current) === null || Ke === void 0 ? void 0 : Ke.call(Ze, ...Fe);
    },
    []
  );
}
const $9f79659886946c16$export$e5c5a5f917a5871c = globalThis != null && globalThis.document ? useLayoutEffect : () => {
};
function $6ed0406888f73fc4$var$setRef($e, Ze) {
  typeof $e == "function" ? $e(Ze) : $e != null && ($e.current = Ze);
}
function $6ed0406888f73fc4$export$43e446d32b3d21af(...$e) {
  return (Ze) => $e.forEach(
    (Fe) => $6ed0406888f73fc4$var$setRef(Fe, Ze)
  );
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...$e) {
  return useCallback($6ed0406888f73fc4$export$43e446d32b3d21af(...$e), $e);
}
const $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const { children: Fe, ...Ke } = $e, Ve = Children.toArray(Fe), Je = Ve.find($5e63c961fc1ce211$var$isSlottable);
  if (Je) {
    const Qe = Je.props.children, at = Ve.map((ut) => ut === Je ? Children.count(Qe) > 1 ? Children.only(null) : /* @__PURE__ */ isValidElement(Qe) ? Qe.props.children : null : ut);
    return /* @__PURE__ */ createElement($5e63c961fc1ce211$var$SlotClone, _extends$1({}, Ke, {
      ref: Ze
    }), /* @__PURE__ */ isValidElement(Qe) ? /* @__PURE__ */ cloneElement(Qe, void 0, at) : null);
  }
  return /* @__PURE__ */ createElement($5e63c961fc1ce211$var$SlotClone, _extends$1({}, Ke, {
    ref: Ze
  }), Fe);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
const $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const { children: Fe, ...Ke } = $e;
  return /* @__PURE__ */ isValidElement(Fe) ? /* @__PURE__ */ cloneElement(Fe, {
    ...$5e63c961fc1ce211$var$mergeProps(Ke, Fe.props),
    ref: Ze ? $6ed0406888f73fc4$export$43e446d32b3d21af(Ze, Fe.ref) : Fe.ref
  }) : Children.count(Fe) > 1 ? Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
const $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children: $e }) => /* @__PURE__ */ createElement(Fragment, null, $e);
function $5e63c961fc1ce211$var$isSlottable($e) {
  return /* @__PURE__ */ isValidElement($e) && $e.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
}
function $5e63c961fc1ce211$var$mergeProps($e, Ze) {
  const Fe = {
    ...Ze
  };
  for (const Ke in Ze) {
    const Ve = $e[Ke], Je = Ze[Ke];
    /^on[A-Z]/.test(Ke) ? Ve && Je ? Fe[Ke] = (...at) => {
      Je(...at), Ve(...at);
    } : Ve && (Fe[Ke] = Ve) : Ke === "style" ? Fe[Ke] = {
      ...Ve,
      ...Je
    } : Ke === "className" && (Fe[Ke] = [
      Ve,
      Je
    ].filter(Boolean).join(" "));
  }
  return {
    ...$e,
    ...Fe
  };
}
const $8927f6f2acc4f386$var$NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce(($e, Ze) => {
  const Fe = /* @__PURE__ */ forwardRef((Ke, Ve) => {
    const { asChild: Je, ...Qe } = Ke, at = Je ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : Ze;
    return useEffect(() => {
      window[Symbol.for("radix-ui")] = !0;
    }, []), /* @__PURE__ */ createElement(at, _extends$1({}, Qe, {
      ref: Ve
    }));
  });
  return Fe.displayName = `Primitive.${Ze}`, {
    ...$e,
    [Ze]: Fe
  };
}, {});
function $8927f6f2acc4f386$export$6d1a0317bde7de7f($e, Ze) {
  $e && flushSync(
    () => $e.dispatchEvent(Ze)
  );
}
const $cddcb0b647441e34$var$AVATAR_NAME = "Avatar", [$cddcb0b647441e34$var$createAvatarContext, $cddcb0b647441e34$export$90370d16b488820f] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cddcb0b647441e34$var$AVATAR_NAME), [$cddcb0b647441e34$var$AvatarProvider, $cddcb0b647441e34$var$useAvatarContext] = $cddcb0b647441e34$var$createAvatarContext($cddcb0b647441e34$var$AVATAR_NAME), $cddcb0b647441e34$export$e2255cf6045e8d47 = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const { __scopeAvatar: Fe, ...Ke } = $e, [Ve, Je] = useState("idle");
  return /* @__PURE__ */ createElement($cddcb0b647441e34$var$AvatarProvider, {
    scope: Fe,
    imageLoadingStatus: Ve,
    onImageLoadingStatusChange: Je
  }, /* @__PURE__ */ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends$1({}, Ke, {
    ref: Ze
  })));
}), $cddcb0b647441e34$var$IMAGE_NAME = "AvatarImage", $cddcb0b647441e34$export$2cd8ae1985206fe8 = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const { __scopeAvatar: Fe, src: Ke, onLoadingStatusChange: Ve = () => {
  }, ...Je } = $e, Qe = $cddcb0b647441e34$var$useAvatarContext($cddcb0b647441e34$var$IMAGE_NAME, Fe), at = $cddcb0b647441e34$var$useImageLoadingStatus(Ke), ut = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a((lt) => {
    Ve(lt), Qe.onImageLoadingStatusChange(lt);
  });
  return $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    at !== "idle" && ut(at);
  }, [
    at,
    ut
  ]), at === "loaded" ? /* @__PURE__ */ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.img, _extends$1({}, Je, {
    ref: Ze,
    src: Ke
  })) : null;
}), $cddcb0b647441e34$var$FALLBACK_NAME = "AvatarFallback", $cddcb0b647441e34$export$69fffb6a9571fbfe = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const { __scopeAvatar: Fe, delayMs: Ke, ...Ve } = $e, Je = $cddcb0b647441e34$var$useAvatarContext($cddcb0b647441e34$var$FALLBACK_NAME, Fe), [Qe, at] = useState(Ke === void 0);
  return useEffect(() => {
    if (Ke !== void 0) {
      const ut = window.setTimeout(
        () => at(!0),
        Ke
      );
      return () => window.clearTimeout(ut);
    }
  }, [
    Ke
  ]), Qe && Je.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends$1({}, Ve, {
    ref: Ze
  })) : null;
});
function $cddcb0b647441e34$var$useImageLoadingStatus($e) {
  const [Ze, Fe] = useState("idle");
  return useEffect(() => {
    if (!$e) {
      Fe("error");
      return;
    }
    let Ke = !0;
    const Ve = new window.Image(), Je = (Qe) => () => {
      Ke && Fe(Qe);
    };
    return Fe("loading"), Ve.onload = Je("loaded"), Ve.onerror = Je("error"), Ve.src = $e, () => {
      Ke = !1;
    };
  }, [
    $e
  ]), Ze;
}
let EventEmitter$1 = class {
  constructor() {
    Or(this, "eventMap");
    this.eventMap = {};
  }
  on(Ze, Fe) {
    var Ke;
    return this.eventMap[Ze] || (this.eventMap[Ze] = /* @__PURE__ */ new Set()), (Ke = this.eventMap[Ze]) == null || Ke.add(Fe), () => {
      var Ve;
      (Ve = this.eventMap[Ze]) == null || Ve.delete(Fe);
    };
  }
  emit(Ze, Fe) {
    var Ke;
    (Ke = this.eventMap[Ze]) == null || Ke.forEach((Ve) => {
      Ve(Fe);
    });
  }
};
const eventEmitter = new EventEmitter$1();
function hashStringToInt($e, Ze) {
  let Fe = 0;
  if ($e.length == 0)
    return Fe;
  for (let Ke = 0; Ke < $e.length; Ke++) {
    const Ve = $e.charCodeAt(Ke);
    Fe = (Fe << 5) - Fe + Ve, Fe = Fe & Fe;
  }
  return Math.abs(Fe) % Ze;
}
function twJoin() {
  for (var $e = 0, Ze, Fe, Ke = ""; $e < arguments.length; )
    (Ze = arguments[$e++]) && (Fe = toValue(Ze)) && (Ke && (Ke += " "), Ke += Fe);
  return Ke;
}
function toValue($e) {
  if (typeof $e == "string")
    return $e;
  for (var Ze, Fe = "", Ke = 0; Ke < $e.length; Ke++)
    $e[Ke] && (Ze = toValue($e[Ke])) && (Fe && (Fe += " "), Fe += Ze);
  return Fe;
}
var CLASS_PART_SEPARATOR = "-";
function createClassUtils($e) {
  var Ze = createClassMap($e), Fe = $e.conflictingClassGroups, Ke = $e.conflictingClassGroupModifiers, Ve = Ke === void 0 ? {} : Ke;
  function Je(at) {
    var ut = at.split(CLASS_PART_SEPARATOR);
    return ut[0] === "" && ut.length !== 1 && ut.shift(), getGroupRecursive(ut, Ze) || getGroupIdForArbitraryProperty(at);
  }
  function Qe(at, ut) {
    var lt = Fe[at] || [];
    return ut && Ve[at] ? [].concat(lt, Ve[at]) : lt;
  }
  return {
    getClassGroupId: Je,
    getConflictingClassGroupIds: Qe
  };
}
function getGroupRecursive($e, Ze) {
  var Qe;
  if ($e.length === 0)
    return Ze.classGroupId;
  var Fe = $e[0], Ke = Ze.nextPart.get(Fe), Ve = Ke ? getGroupRecursive($e.slice(1), Ke) : void 0;
  if (Ve)
    return Ve;
  if (Ze.validators.length !== 0) {
    var Je = $e.join(CLASS_PART_SEPARATOR);
    return (Qe = Ze.validators.find(function(at) {
      var ut = at.validator;
      return ut(Je);
    })) == null ? void 0 : Qe.classGroupId;
  }
}
var arbitraryPropertyRegex = /^\[(.+)\]$/;
function getGroupIdForArbitraryProperty($e) {
  if (arbitraryPropertyRegex.test($e)) {
    var Ze = arbitraryPropertyRegex.exec($e)[1], Fe = Ze == null ? void 0 : Ze.substring(0, Ze.indexOf(":"));
    if (Fe)
      return "arbitrary.." + Fe;
  }
}
function createClassMap($e) {
  var Ze = $e.theme, Fe = $e.prefix, Ke = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  }, Ve = getPrefixedClassGroupEntries(Object.entries($e.classGroups), Fe);
  return Ve.forEach(function(Je) {
    var Qe = Je[0], at = Je[1];
    processClassesRecursively(at, Ke, Qe, Ze);
  }), Ke;
}
function processClassesRecursively($e, Ze, Fe, Ke) {
  $e.forEach(function(Ve) {
    if (typeof Ve == "string") {
      var Je = Ve === "" ? Ze : getPart(Ze, Ve);
      Je.classGroupId = Fe;
      return;
    }
    if (typeof Ve == "function") {
      if (isThemeGetter(Ve)) {
        processClassesRecursively(Ve(Ke), Ze, Fe, Ke);
        return;
      }
      Ze.validators.push({
        validator: Ve,
        classGroupId: Fe
      });
      return;
    }
    Object.entries(Ve).forEach(function(Qe) {
      var at = Qe[0], ut = Qe[1];
      processClassesRecursively(ut, getPart(Ze, at), Fe, Ke);
    });
  });
}
function getPart($e, Ze) {
  var Fe = $e;
  return Ze.split(CLASS_PART_SEPARATOR).forEach(function(Ke) {
    Fe.nextPart.has(Ke) || Fe.nextPart.set(Ke, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), Fe = Fe.nextPart.get(Ke);
  }), Fe;
}
function isThemeGetter($e) {
  return $e.isThemeGetter;
}
function getPrefixedClassGroupEntries($e, Ze) {
  return Ze ? $e.map(function(Fe) {
    var Ke = Fe[0], Ve = Fe[1], Je = Ve.map(function(Qe) {
      return typeof Qe == "string" ? Ze + Qe : typeof Qe == "object" ? Object.fromEntries(Object.entries(Qe).map(function(at) {
        var ut = at[0], lt = at[1];
        return [Ze + ut, lt];
      })) : Qe;
    });
    return [Ke, Je];
  }) : $e;
}
function createLruCache($e) {
  if ($e < 1)
    return {
      get: function() {
      },
      set: function() {
      }
    };
  var Ze = 0, Fe = /* @__PURE__ */ new Map(), Ke = /* @__PURE__ */ new Map();
  function Ve(Je, Qe) {
    Fe.set(Je, Qe), Ze++, Ze > $e && (Ze = 0, Ke = Fe, Fe = /* @__PURE__ */ new Map());
  }
  return {
    get: function(Qe) {
      var at = Fe.get(Qe);
      if (at !== void 0)
        return at;
      if ((at = Ke.get(Qe)) !== void 0)
        return Ve(Qe, at), at;
    },
    set: function(Qe, at) {
      Fe.has(Qe) ? Fe.set(Qe, at) : Ve(Qe, at);
    }
  };
}
var IMPORTANT_MODIFIER = "!";
function createSplitModifiers($e) {
  var Ze = $e.separator || ":", Fe = Ze.length === 1, Ke = Ze[0], Ve = Ze.length;
  return function(Qe) {
    for (var at = [], ut = 0, lt = 0, dt, bt = 0; bt < Qe.length; bt++) {
      var $t = Qe[bt];
      if (ut === 0) {
        if ($t === Ke && (Fe || Qe.slice(bt, bt + Ve) === Ze)) {
          at.push(Qe.slice(lt, bt)), lt = bt + Ve;
          continue;
        }
        if ($t === "/") {
          dt = bt;
          continue;
        }
      }
      $t === "[" ? ut++ : $t === "]" && ut--;
    }
    var vt = at.length === 0 ? Qe : Qe.substring(lt), wt = vt.startsWith(IMPORTANT_MODIFIER), xt = wt ? vt.substring(1) : vt, Et = dt && dt > lt ? dt - lt : void 0;
    return {
      modifiers: at,
      hasImportantModifier: wt,
      baseClassName: xt,
      maybePostfixModifierPosition: Et
    };
  };
}
function sortModifiers($e) {
  if ($e.length <= 1)
    return $e;
  var Ze = [], Fe = [];
  return $e.forEach(function(Ke) {
    var Ve = Ke[0] === "[";
    Ve ? (Ze.push.apply(Ze, Fe.sort().concat([Ke])), Fe = []) : Fe.push(Ke);
  }), Ze.push.apply(Ze, Fe.sort()), Ze;
}
function createConfigUtils($e) {
  return {
    cache: createLruCache($e.cacheSize),
    splitModifiers: createSplitModifiers($e),
    ...createClassUtils($e)
  };
}
var SPLIT_CLASSES_REGEX = /\s+/;
function mergeClassList($e, Ze) {
  var Fe = Ze.splitModifiers, Ke = Ze.getClassGroupId, Ve = Ze.getConflictingClassGroupIds, Je = /* @__PURE__ */ new Set();
  return $e.trim().split(SPLIT_CLASSES_REGEX).map(function(Qe) {
    var at = Fe(Qe), ut = at.modifiers, lt = at.hasImportantModifier, dt = at.baseClassName, bt = at.maybePostfixModifierPosition, $t = Ke(bt ? dt.substring(0, bt) : dt), vt = !!bt;
    if (!$t) {
      if (!bt)
        return {
          isTailwindClass: !1,
          originalClassName: Qe
        };
      if ($t = Ke(dt), !$t)
        return {
          isTailwindClass: !1,
          originalClassName: Qe
        };
      vt = !1;
    }
    var wt = sortModifiers(ut).join(":"), xt = lt ? wt + IMPORTANT_MODIFIER : wt;
    return {
      isTailwindClass: !0,
      modifierId: xt,
      classGroupId: $t,
      originalClassName: Qe,
      hasPostfixModifier: vt
    };
  }).reverse().filter(function(Qe) {
    if (!Qe.isTailwindClass)
      return !0;
    var at = Qe.modifierId, ut = Qe.classGroupId, lt = Qe.hasPostfixModifier, dt = at + ut;
    return Je.has(dt) ? !1 : (Je.add(dt), Ve(ut, lt).forEach(function(bt) {
      return Je.add(at + bt);
    }), !0);
  }).reverse().map(function(Qe) {
    return Qe.originalClassName;
  }).join(" ");
}
function createTailwindMerge() {
  for (var $e = arguments.length, Ze = new Array($e), Fe = 0; Fe < $e; Fe++)
    Ze[Fe] = arguments[Fe];
  var Ke, Ve, Je, Qe = at;
  function at(lt) {
    var dt = Ze[0], bt = Ze.slice(1), $t = bt.reduce(function(vt, wt) {
      return wt(vt);
    }, dt());
    return Ke = createConfigUtils($t), Ve = Ke.cache.get, Je = Ke.cache.set, Qe = ut, ut(lt);
  }
  function ut(lt) {
    var dt = Ve(lt);
    if (dt)
      return dt;
    var bt = mergeClassList(lt, Ke);
    return Je(lt, bt), bt;
  }
  return function() {
    return Qe(twJoin.apply(null, arguments));
  };
}
function fromTheme$1($e) {
  var Ze = function(Ke) {
    return Ke[$e] || [];
  };
  return Ze.isThemeGetter = !0, Ze;
}
var arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i, fractionRegex = /^\d+\/\d+$/, stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]), tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, shadowRegex = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
function isLength$3($e) {
  return isNumber$3($e) || stringLengths.has($e) || fractionRegex.test($e) || isArbitraryLength($e);
}
function isArbitraryLength($e) {
  return getIsArbitraryValue($e, "length", isLengthOnly);
}
function isArbitrarySize($e) {
  return getIsArbitraryValue($e, "size", isNever);
}
function isArbitraryPosition($e) {
  return getIsArbitraryValue($e, "position", isNever);
}
function isArbitraryUrl($e) {
  return getIsArbitraryValue($e, "url", isUrl$1);
}
function isArbitraryNumber($e) {
  return getIsArbitraryValue($e, "number", isNumber$3);
}
function isNumber$3($e) {
  return !Number.isNaN(Number($e));
}
function isPercent($e) {
  return $e.endsWith("%") && isNumber$3($e.slice(0, -1));
}
function isInteger($e) {
  return isIntegerOnly($e) || getIsArbitraryValue($e, "number", isIntegerOnly);
}
function isArbitraryValue($e) {
  return arbitraryValueRegex.test($e);
}
function isAny() {
  return !0;
}
function isTshirtSize($e) {
  return tshirtUnitRegex.test($e);
}
function isArbitraryShadow($e) {
  return getIsArbitraryValue($e, "", isShadow);
}
function getIsArbitraryValue($e, Ze, Fe) {
  var Ke = arbitraryValueRegex.exec($e);
  return Ke ? Ke[1] ? Ke[1] === Ze : Fe(Ke[2]) : !1;
}
function isLengthOnly($e) {
  return lengthUnitRegex.test($e);
}
function isNever() {
  return !1;
}
function isUrl$1($e) {
  return $e.startsWith("url(");
}
function isIntegerOnly($e) {
  return Number.isInteger(Number($e));
}
function isShadow($e) {
  return shadowRegex.test($e);
}
function getDefaultConfig() {
  var $e = fromTheme$1("colors"), Ze = fromTheme$1("spacing"), Fe = fromTheme$1("blur"), Ke = fromTheme$1("brightness"), Ve = fromTheme$1("borderColor"), Je = fromTheme$1("borderRadius"), Qe = fromTheme$1("borderSpacing"), at = fromTheme$1("borderWidth"), ut = fromTheme$1("contrast"), lt = fromTheme$1("grayscale"), dt = fromTheme$1("hueRotate"), bt = fromTheme$1("invert"), $t = fromTheme$1("gap"), vt = fromTheme$1("gradientColorStops"), wt = fromTheme$1("gradientColorStopPositions"), xt = fromTheme$1("inset"), Et = fromTheme$1("margin"), Tt = fromTheme$1("opacity"), Rt = fromTheme$1("padding"), Ct = fromTheme$1("saturate"), Zt = fromTheme$1("scale"), Lt = fromTheme$1("sepia"), Ut = fromTheme$1("skew"), Pt = fromTheme$1("space"), Ot = fromTheme$1("translate"), Ft = function() {
    return ["auto", "contain", "none"];
  }, gt = function() {
    return ["auto", "hidden", "clip", "visible", "scroll"];
  }, We = function() {
    return ["auto", isArbitraryValue, Ze];
  }, Xe = function() {
    return [isArbitraryValue, Ze];
  }, rt = function() {
    return ["", isLength$3];
  }, ot = function() {
    return ["auto", isNumber$3, isArbitraryValue];
  }, ft = function() {
    return ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  }, mt = function() {
    return ["solid", "dashed", "dotted", "double", "none"];
  }, yt = function() {
    return ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
  }, pt = function() {
    return ["start", "end", "center", "between", "around", "evenly", "stretch"];
  }, Ge = function() {
    return ["", "0", isArbitraryValue];
  }, ct = function() {
    return ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  }, Mt = function() {
    return [isNumber$3, isArbitraryNumber];
  }, St = function() {
    return [isNumber$3, isArbitraryValue];
  };
  return {
    cacheSize: 500,
    theme: {
      colors: [isAny],
      spacing: [isLength$3],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: Mt(),
      borderColor: [$e],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: Xe(),
      borderWidth: rt(),
      contrast: Mt(),
      grayscale: Ge(),
      hueRotate: St(),
      invert: Ge(),
      gap: Xe(),
      gradientColorStops: [$e],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: We(),
      margin: We(),
      opacity: Mt(),
      padding: Xe(),
      saturate: Mt(),
      scale: Mt(),
      sepia: Ge(),
      skew: St(),
      space: Xe(),
      translate: Xe()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": ct()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": ct()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [].concat(ft(), [isArbitraryValue])
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: gt()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": gt()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": gt()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: Ft()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": Ft()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": Ft()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [xt]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [xt]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [xt]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [xt]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [xt]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [xt]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [xt]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [xt]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [xt]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: We()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: Ge()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: Ge()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": ot()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": ot()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": ot()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": ot()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [$t]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [$t]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [$t]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal"].concat(pt())
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal"].concat(pt(), ["baseline"])
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [].concat(pt(), ["baseline"])
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [Rt]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [Rt]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [Rt]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [Rt]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [Rt]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [Rt]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [Rt]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [Rt]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [Rt]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [Et]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [Et]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [Et]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [Et]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [Et]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [Et]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [Et]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [Et]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [Et]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [Pt]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [Pt]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", isArbitraryValue, Ze]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": ["min", "max", "fit", isArbitraryValue, isLength$3]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": ["0", "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize, isArbitraryValue]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, Ze, "auto", "min", "max", "fit"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["min", "max", "fit", isArbitraryValue, isLength$3]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, Ze, "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber$3, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isArbitraryValue, isLength$3]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [$e]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [Tt]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [$e]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [Tt]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [].concat(mt(), ["wavy"])
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength$3]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isArbitraryValue, isLength$3]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [$e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: Xe()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [Tt]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [].concat(ft(), [isArbitraryPosition])
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryUrl]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [$e]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [wt]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [wt]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [wt]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [vt]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [vt]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [vt]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [Je]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [Je]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [Je]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [Je]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [Je]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [Je]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [Je]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [Je]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [Je]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [Je]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [Je]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [Je]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [Je]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [Je]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [Je]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [at]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [at]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [at]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [at]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [at]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [at]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [at]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [at]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [at]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [Tt]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [].concat(mt(), ["hidden"])
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [at]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [at]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [Tt]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: mt()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [Ve]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [Ve]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [Ve]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [Ve]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [Ve]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [Ve]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [Ve]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [Ve]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [""].concat(mt())
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isArbitraryValue, isLength$3]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength$3]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [$e]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: rt()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [$e]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [Tt]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength$3]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [$e]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [Tt]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": yt()
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": yt()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [Fe]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [Ke]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [ut]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [lt]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [dt]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [bt]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [Ct]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [Lt]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [Fe]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [Ke]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [ut]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [lt]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [dt]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [bt]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [Tt]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [Ct]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [Lt]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [Qe]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [Qe]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [Qe]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: St()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: St()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [Zt]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [Zt]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [Zt]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [Ot]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [Ot]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [Ut]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [Ut]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", $e]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: ["appearance-none"],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [$e]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": Xe()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": Xe()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": Xe()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": Xe()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": Xe()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": Xe()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": Xe()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": Xe()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": Xe()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": Xe()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": Xe()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": Xe()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": Xe()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": Xe()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": Xe()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": Xe()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": Xe()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": Xe()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "pinch-zoom", "manipulation", {
          pan: ["x", "left", "right", "y", "up", "down"]
        }]
      }],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [$e, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength$3, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [$e, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
var twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
function listCacheClear$1() {
  this.__data__ = [], this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$4($e, Ze) {
  return $e === Ze || $e !== $e && Ze !== Ze;
}
var eq_1 = eq$4, eq$3 = eq_1;
function assocIndexOf$4($e, Ze) {
  for (var Fe = $e.length; Fe--; )
    if (eq$3($e[Fe][0], Ze))
      return Fe;
  return -1;
}
var _assocIndexOf = assocIndexOf$4, assocIndexOf$3 = _assocIndexOf, arrayProto = Array.prototype, splice$1 = arrayProto.splice;
function listCacheDelete$1($e) {
  var Ze = this.__data__, Fe = assocIndexOf$3(Ze, $e);
  if (Fe < 0)
    return !1;
  var Ke = Ze.length - 1;
  return Fe == Ke ? Ze.pop() : splice$1.call(Ze, Fe, 1), --this.size, !0;
}
var _listCacheDelete = listCacheDelete$1, assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1($e) {
  var Ze = this.__data__, Fe = assocIndexOf$2(Ze, $e);
  return Fe < 0 ? void 0 : Ze[Fe][1];
}
var _listCacheGet = listCacheGet$1, assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1($e) {
  return assocIndexOf$1(this.__data__, $e) > -1;
}
var _listCacheHas = listCacheHas$1, assocIndexOf = _assocIndexOf;
function listCacheSet$1($e, Ze) {
  var Fe = this.__data__, Ke = assocIndexOf(Fe, $e);
  return Ke < 0 ? (++this.size, Fe.push([$e, Ze])) : Fe[Ke][1] = Ze, this;
}
var _listCacheSet = listCacheSet$1, listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4($e) {
  var Ze = -1, Fe = $e == null ? 0 : $e.length;
  for (this.clear(); ++Ze < Fe; ) {
    var Ke = $e[Ze];
    this.set(Ke[0], Ke[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype.delete = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4, ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3(), this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1($e) {
  var Ze = this.__data__, Fe = Ze.delete($e);
  return this.size = Ze.size, Fe;
}
var _stackDelete = stackDelete$1;
function stackGet$1($e) {
  return this.__data__.get($e);
}
var _stackGet = stackGet$1;
function stackHas$1($e) {
  return this.__data__.has($e);
}
var _stackHas = stackHas$1, freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, _freeGlobal = freeGlobal$1, freeGlobal = _freeGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root$5 = freeGlobal || freeSelf || Function("return this")(), _root = root$5, root$4 = _root, Symbol$3 = root$4.Symbol, _Symbol = Symbol$3, Symbol$2 = _Symbol, objectProto$a = Object.prototype, hasOwnProperty$b = objectProto$a.hasOwnProperty, nativeObjectToString$1 = objectProto$a.toString, symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag$1($e) {
  var Ze = hasOwnProperty$b.call($e, symToStringTag$1), Fe = $e[symToStringTag$1];
  try {
    $e[symToStringTag$1] = void 0;
    var Ke = !0;
  } catch {
  }
  var Ve = nativeObjectToString$1.call($e);
  return Ke && (Ze ? $e[symToStringTag$1] = Fe : delete $e[symToStringTag$1]), Ve;
}
var _getRawTag = getRawTag$1, objectProto$9 = Object.prototype, nativeObjectToString = objectProto$9.toString;
function objectToString$1($e) {
  return nativeObjectToString.call($e);
}
var _objectToString = objectToString$1, Symbol$1 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString, nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag$4($e) {
  return $e == null ? $e === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object($e) ? getRawTag($e) : objectToString($e);
}
var _baseGetTag = baseGetTag$4;
function isObject$b($e) {
  var Ze = typeof $e;
  return $e != null && (Ze == "object" || Ze == "function");
}
var isObject_1 = isObject$b, baseGetTag$3 = _baseGetTag, isObject$a = isObject_1, asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$5($e) {
  if (!isObject$a($e))
    return !1;
  var Ze = baseGetTag$3($e);
  return Ze == funcTag$1 || Ze == genTag || Ze == asyncTag || Ze == proxyTag;
}
var isFunction_1 = isFunction$5, root$3 = _root, coreJsData$1 = root$3["__core-js_shared__"], _coreJsData = coreJsData$1, coreJsData = _coreJsData, maskSrcKey = function() {
  var $e = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return $e ? "Symbol(src)_1." + $e : "";
}();
function isMasked$1($e) {
  return !!maskSrcKey && maskSrcKey in $e;
}
var _isMasked = isMasked$1, funcProto$2 = Function.prototype, funcToString$2 = funcProto$2.toString;
function toSource$1($e) {
  if ($e != null) {
    try {
      return funcToString$2.call($e);
    } catch {
    }
    try {
      return $e + "";
    } catch {
    }
  }
  return "";
}
var _toSource = toSource$1, isFunction$4 = isFunction_1, isMasked = _isMasked, isObject$9 = isObject_1, toSource = _toSource, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto$1 = Function.prototype, objectProto$8 = Object.prototype, funcToString$1 = funcProto$1.toString, hasOwnProperty$a = objectProto$8.hasOwnProperty, reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1($e) {
  if (!isObject$9($e) || isMasked($e))
    return !1;
  var Ze = isFunction$4($e) ? reIsNative : reIsHostCtor;
  return Ze.test(toSource($e));
}
var _baseIsNative = baseIsNative$1;
function getValue$1($e, Ze) {
  return $e == null ? void 0 : $e[Ze];
}
var _getValue = getValue$1, baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$3($e, Ze) {
  var Fe = getValue($e, Ze);
  return baseIsNative(Fe) ? Fe : void 0;
}
var _getNative = getNative$3, getNative$2 = _getNative, root$2 = _root, Map$3 = getNative$2(root$2, "Map"), _Map = Map$3, getNative$1 = _getNative, nativeCreate$4 = getNative$1(Object, "create"), _nativeCreate = nativeCreate$4, nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {}, this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1($e) {
  var Ze = this.has($e) && delete this.__data__[$e];
  return this.size -= Ze ? 1 : 0, Ze;
}
var _hashDelete = hashDelete$1, nativeCreate$2 = _nativeCreate, HASH_UNDEFINED$1 = "__lodash_hash_undefined__", objectProto$7 = Object.prototype, hasOwnProperty$9 = objectProto$7.hasOwnProperty;
function hashGet$1($e) {
  var Ze = this.__data__;
  if (nativeCreate$2) {
    var Fe = Ze[$e];
    return Fe === HASH_UNDEFINED$1 ? void 0 : Fe;
  }
  return hasOwnProperty$9.call(Ze, $e) ? Ze[$e] : void 0;
}
var _hashGet = hashGet$1, nativeCreate$1 = _nativeCreate, objectProto$6 = Object.prototype, hasOwnProperty$8 = objectProto$6.hasOwnProperty;
function hashHas$1($e) {
  var Ze = this.__data__;
  return nativeCreate$1 ? Ze[$e] !== void 0 : hasOwnProperty$8.call(Ze, $e);
}
var _hashHas = hashHas$1, nativeCreate = _nativeCreate, HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1($e, Ze) {
  var Fe = this.__data__;
  return this.size += this.has($e) ? 0 : 1, Fe[$e] = nativeCreate && Ze === void 0 ? HASH_UNDEFINED : Ze, this;
}
var _hashSet = hashSet$1, hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1($e) {
  var Ze = -1, Fe = $e == null ? 0 : $e.length;
  for (this.clear(); ++Ze < Fe; ) {
    var Ke = $e[Ze];
    this.set(Ke[0], Ke[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype.delete = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1, Hash = _Hash, ListCache$2 = _ListCache, Map$2 = _Map;
function mapCacheClear$1() {
  this.size = 0, this.__data__ = {
    hash: new Hash(),
    map: new (Map$2 || ListCache$2)(),
    string: new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1($e) {
  var Ze = typeof $e;
  return Ze == "string" || Ze == "number" || Ze == "symbol" || Ze == "boolean" ? $e !== "__proto__" : $e === null;
}
var _isKeyable = isKeyable$1, isKeyable = _isKeyable;
function getMapData$4($e, Ze) {
  var Fe = $e.__data__;
  return isKeyable(Ze) ? Fe[typeof Ze == "string" ? "string" : "hash"] : Fe.map;
}
var _getMapData = getMapData$4, getMapData$3 = _getMapData;
function mapCacheDelete$1($e) {
  var Ze = getMapData$3(this, $e).delete($e);
  return this.size -= Ze ? 1 : 0, Ze;
}
var _mapCacheDelete = mapCacheDelete$1, getMapData$2 = _getMapData;
function mapCacheGet$1($e) {
  return getMapData$2(this, $e).get($e);
}
var _mapCacheGet = mapCacheGet$1, getMapData$1 = _getMapData;
function mapCacheHas$1($e) {
  return getMapData$1(this, $e).has($e);
}
var _mapCacheHas = mapCacheHas$1, getMapData = _getMapData;
function mapCacheSet$1($e, Ze) {
  var Fe = getMapData(this, $e), Ke = Fe.size;
  return Fe.set($e, Ze), this.size += Fe.size == Ke ? 0 : 1, this;
}
var _mapCacheSet = mapCacheSet$1, mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$1($e) {
  var Ze = -1, Fe = $e == null ? 0 : $e.length;
  for (this.clear(); ++Ze < Fe; ) {
    var Ke = $e[Ze];
    this.set(Ke[0], Ke[1]);
  }
}
MapCache$1.prototype.clear = mapCacheClear;
MapCache$1.prototype.delete = mapCacheDelete;
MapCache$1.prototype.get = mapCacheGet;
MapCache$1.prototype.has = mapCacheHas;
MapCache$1.prototype.set = mapCacheSet;
var _MapCache = MapCache$1, ListCache$1 = _ListCache, Map$1 = _Map, MapCache = _MapCache, LARGE_ARRAY_SIZE = 200;
function stackSet$1($e, Ze) {
  var Fe = this.__data__;
  if (Fe instanceof ListCache$1) {
    var Ke = Fe.__data__;
    if (!Map$1 || Ke.length < LARGE_ARRAY_SIZE - 1)
      return Ke.push([$e, Ze]), this.size = ++Fe.size, this;
    Fe = this.__data__ = new MapCache(Ke);
  }
  return Fe.set($e, Ze), this.size = Fe.size, this;
}
var _stackSet = stackSet$1, ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$1($e) {
  var Ze = this.__data__ = new ListCache($e);
  this.size = Ze.size;
}
Stack$1.prototype.clear = stackClear;
Stack$1.prototype.delete = stackDelete;
Stack$1.prototype.get = stackGet;
Stack$1.prototype.has = stackHas;
Stack$1.prototype.set = stackSet;
var _Stack = Stack$1, getNative = _getNative, defineProperty$3 = function() {
  try {
    var $e = getNative(Object, "defineProperty");
    return $e({}, "", {}), $e;
  } catch {
  }
}(), _defineProperty = defineProperty$3, defineProperty$2 = _defineProperty;
function baseAssignValue$3($e, Ze, Fe) {
  Ze == "__proto__" && defineProperty$2 ? defineProperty$2($e, Ze, {
    configurable: !0,
    enumerable: !0,
    value: Fe,
    writable: !0
  }) : $e[Ze] = Fe;
}
var _baseAssignValue = baseAssignValue$3, baseAssignValue$2 = _baseAssignValue, eq$2 = eq_1;
function assignMergeValue$2($e, Ze, Fe) {
  (Fe !== void 0 && !eq$2($e[Ze], Fe) || Fe === void 0 && !(Ze in $e)) && baseAssignValue$2($e, Ze, Fe);
}
var _assignMergeValue = assignMergeValue$2;
function createBaseFor$1($e) {
  return function(Ze, Fe, Ke) {
    for (var Ve = -1, Je = Object(Ze), Qe = Ke(Ze), at = Qe.length; at--; ) {
      var ut = Qe[$e ? at : ++Ve];
      if (Fe(Je[ut], ut, Je) === !1)
        break;
    }
    return Ze;
  };
}
var _createBaseFor = createBaseFor$1, createBaseFor = _createBaseFor, baseFor$1 = createBaseFor(), _baseFor = baseFor$1, _cloneBuffer = { exports: {} };
_cloneBuffer.exports;
(function($e, Ze) {
  var Fe = _root, Ke = Ze && !Ze.nodeType && Ze, Ve = Ke && !0 && $e && !$e.nodeType && $e, Je = Ve && Ve.exports === Ke, Qe = Je ? Fe.Buffer : void 0, at = Qe ? Qe.allocUnsafe : void 0;
  function ut(lt, dt) {
    if (dt)
      return lt.slice();
    var bt = lt.length, $t = at ? at(bt) : new lt.constructor(bt);
    return lt.copy($t), $t;
  }
  $e.exports = ut;
})(_cloneBuffer, _cloneBuffer.exports);
var _cloneBufferExports = _cloneBuffer.exports, root$1 = _root, Uint8Array$2 = root$1.Uint8Array, _Uint8Array = Uint8Array$2, Uint8Array$1 = _Uint8Array;
function cloneArrayBuffer$1($e) {
  var Ze = new $e.constructor($e.byteLength);
  return new Uint8Array$1(Ze).set(new Uint8Array$1($e)), Ze;
}
var _cloneArrayBuffer = cloneArrayBuffer$1, cloneArrayBuffer = _cloneArrayBuffer;
function cloneTypedArray$1($e, Ze) {
  var Fe = Ze ? cloneArrayBuffer($e.buffer) : $e.buffer;
  return new $e.constructor(Fe, $e.byteOffset, $e.length);
}
var _cloneTypedArray = cloneTypedArray$1;
function copyArray$1($e, Ze) {
  var Fe = -1, Ke = $e.length;
  for (Ze || (Ze = Array(Ke)); ++Fe < Ke; )
    Ze[Fe] = $e[Fe];
  return Ze;
}
var _copyArray = copyArray$1, isObject$8 = isObject_1, objectCreate = Object.create, baseCreate$1 = function() {
  function $e() {
  }
  return function(Ze) {
    if (!isObject$8(Ze))
      return {};
    if (objectCreate)
      return objectCreate(Ze);
    $e.prototype = Ze;
    var Fe = new $e();
    return $e.prototype = void 0, Fe;
  };
}(), _baseCreate = baseCreate$1;
function overArg$1($e, Ze) {
  return function(Fe) {
    return $e(Ze(Fe));
  };
}
var _overArg = overArg$1, overArg = _overArg, getPrototype$2 = overArg(Object.getPrototypeOf, Object), _getPrototype = getPrototype$2, objectProto$5 = Object.prototype;
function isPrototype$2($e) {
  var Ze = $e && $e.constructor, Fe = typeof Ze == "function" && Ze.prototype || objectProto$5;
  return $e === Fe;
}
var _isPrototype = isPrototype$2, baseCreate = _baseCreate, getPrototype$1 = _getPrototype, isPrototype$1 = _isPrototype;
function initCloneObject$1($e) {
  return typeof $e.constructor == "function" && !isPrototype$1($e) ? baseCreate(getPrototype$1($e)) : {};
}
var _initCloneObject = initCloneObject$1;
function isObjectLike$5($e) {
  return $e != null && typeof $e == "object";
}
var isObjectLike_1 = isObjectLike$5, baseGetTag$2 = _baseGetTag, isObjectLike$4 = isObjectLike_1, argsTag$1 = "[object Arguments]";
function baseIsArguments$1($e) {
  return isObjectLike$4($e) && baseGetTag$2($e) == argsTag$1;
}
var _baseIsArguments = baseIsArguments$1, baseIsArguments = _baseIsArguments, isObjectLike$3 = isObjectLike_1, objectProto$4 = Object.prototype, hasOwnProperty$7 = objectProto$4.hasOwnProperty, propertyIsEnumerable = objectProto$4.propertyIsEnumerable, isArguments$2 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function($e) {
  return isObjectLike$3($e) && hasOwnProperty$7.call($e, "callee") && !propertyIsEnumerable.call($e, "callee");
}, isArguments_1 = isArguments$2, isArray$5 = Array.isArray, isArray_1 = isArray$5, MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$2($e) {
  return typeof $e == "number" && $e > -1 && $e % 1 == 0 && $e <= MAX_SAFE_INTEGER$1;
}
var isLength_1 = isLength$2, isFunction$3 = isFunction_1, isLength$1 = isLength_1;
function isArrayLike$3($e) {
  return $e != null && isLength$1($e.length) && !isFunction$3($e);
}
var isArrayLike_1 = isArrayLike$3, isArrayLike$2 = isArrayLike_1, isObjectLike$2 = isObjectLike_1;
function isArrayLikeObject$1($e) {
  return isObjectLike$2($e) && isArrayLike$2($e);
}
var isArrayLikeObject_1 = isArrayLikeObject$1, isBuffer$6 = { exports: {} };
function stubFalse() {
  return !1;
}
var stubFalse_1 = stubFalse;
isBuffer$6.exports;
(function($e, Ze) {
  var Fe = _root, Ke = stubFalse_1, Ve = Ze && !Ze.nodeType && Ze, Je = Ve && !0 && $e && !$e.nodeType && $e, Qe = Je && Je.exports === Ve, at = Qe ? Fe.Buffer : void 0, ut = at ? at.isBuffer : void 0, lt = ut || Ke;
  $e.exports = lt;
})(isBuffer$6, isBuffer$6.exports);
var isBufferExports = isBuffer$6.exports, baseGetTag$1 = _baseGetTag, getPrototype = _getPrototype, isObjectLike$1 = isObjectLike_1, objectTag$1 = "[object Object]", funcProto = Function.prototype, objectProto$3 = Object.prototype, funcToString = funcProto.toString, hasOwnProperty$6 = objectProto$3.hasOwnProperty, objectCtorString = funcToString.call(Object);
function isPlainObject$5($e) {
  if (!isObjectLike$1($e) || baseGetTag$1($e) != objectTag$1)
    return !1;
  var Ze = getPrototype($e);
  if (Ze === null)
    return !0;
  var Fe = hasOwnProperty$6.call(Ze, "constructor") && Ze.constructor;
  return typeof Fe == "function" && Fe instanceof Fe && funcToString.call(Fe) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$5, baseGetTag = _baseGetTag, isLength = isLength_1, isObjectLike = isObjectLike_1, argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
function baseIsTypedArray$1($e) {
  return isObjectLike($e) && isLength($e.length) && !!typedArrayTags[baseGetTag($e)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$1($e) {
  return function(Ze) {
    return $e(Ze);
  };
}
var _baseUnary = baseUnary$1, _nodeUtil = { exports: {} };
_nodeUtil.exports;
(function($e, Ze) {
  var Fe = _freeGlobal, Ke = Ze && !Ze.nodeType && Ze, Ve = Ke && !0 && $e && !$e.nodeType && $e, Je = Ve && Ve.exports === Ke, Qe = Je && Fe.process, at = function() {
    try {
      var ut = Ve && Ve.require && Ve.require("util").types;
      return ut || Qe && Qe.binding && Qe.binding("util");
    } catch {
    }
  }();
  $e.exports = at;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports, baseIsTypedArray = _baseIsTypedArray, baseUnary = _baseUnary, nodeUtil = _nodeUtilExports, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray$4 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray, isTypedArray_1 = isTypedArray$4;
function safeGet$2($e, Ze) {
  if (!(Ze === "constructor" && typeof $e[Ze] == "function") && Ze != "__proto__")
    return $e[Ze];
}
var _safeGet = safeGet$2, baseAssignValue$1 = _baseAssignValue, eq$1 = eq_1, objectProto$2 = Object.prototype, hasOwnProperty$5 = objectProto$2.hasOwnProperty;
function assignValue$1($e, Ze, Fe) {
  var Ke = $e[Ze];
  (!(hasOwnProperty$5.call($e, Ze) && eq$1(Ke, Fe)) || Fe === void 0 && !(Ze in $e)) && baseAssignValue$1($e, Ze, Fe);
}
var _assignValue = assignValue$1, assignValue = _assignValue, baseAssignValue = _baseAssignValue;
function copyObject$1($e, Ze, Fe, Ke) {
  var Ve = !Fe;
  Fe || (Fe = {});
  for (var Je = -1, Qe = Ze.length; ++Je < Qe; ) {
    var at = Ze[Je], ut = Ke ? Ke(Fe[at], $e[at], at, Fe, $e) : void 0;
    ut === void 0 && (ut = $e[at]), Ve ? baseAssignValue(Fe, at, ut) : assignValue(Fe, at, ut);
  }
  return Fe;
}
var _copyObject = copyObject$1;
function baseTimes$1($e, Ze) {
  for (var Fe = -1, Ke = Array($e); ++Fe < $e; )
    Ke[Fe] = Ze(Fe);
  return Ke;
}
var _baseTimes = baseTimes$1, MAX_SAFE_INTEGER = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$2($e, Ze) {
  var Fe = typeof $e;
  return Ze = Ze ?? MAX_SAFE_INTEGER, !!Ze && (Fe == "number" || Fe != "symbol" && reIsUint.test($e)) && $e > -1 && $e % 1 == 0 && $e < Ze;
}
var _isIndex = isIndex$2, baseTimes = _baseTimes, isArguments$1 = isArguments_1, isArray$4 = isArray_1, isBuffer$5 = isBufferExports, isIndex$1 = _isIndex, isTypedArray$3 = isTypedArray_1, objectProto$1 = Object.prototype, hasOwnProperty$4 = objectProto$1.hasOwnProperty;
function arrayLikeKeys$1($e, Ze) {
  var Fe = isArray$4($e), Ke = !Fe && isArguments$1($e), Ve = !Fe && !Ke && isBuffer$5($e), Je = !Fe && !Ke && !Ve && isTypedArray$3($e), Qe = Fe || Ke || Ve || Je, at = Qe ? baseTimes($e.length, String) : [], ut = at.length;
  for (var lt in $e)
    (Ze || hasOwnProperty$4.call($e, lt)) && !(Qe && // Safari 9 has enumerable `arguments.length` in strict mode.
    (lt == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    Ve && (lt == "offset" || lt == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    Je && (lt == "buffer" || lt == "byteLength" || lt == "byteOffset") || // Skip index properties.
    isIndex$1(lt, ut))) && at.push(lt);
  return at;
}
var _arrayLikeKeys = arrayLikeKeys$1;
function nativeKeysIn$1($e) {
  var Ze = [];
  if ($e != null)
    for (var Fe in Object($e))
      Ze.push(Fe);
  return Ze;
}
var _nativeKeysIn = nativeKeysIn$1, isObject$7 = isObject_1, isPrototype = _isPrototype, nativeKeysIn = _nativeKeysIn, objectProto = Object.prototype, hasOwnProperty$3 = objectProto.hasOwnProperty;
function baseKeysIn$1($e) {
  if (!isObject$7($e))
    return nativeKeysIn($e);
  var Ze = isPrototype($e), Fe = [];
  for (var Ke in $e)
    Ke == "constructor" && (Ze || !hasOwnProperty$3.call($e, Ke)) || Fe.push(Ke);
  return Fe;
}
var _baseKeysIn = baseKeysIn$1, arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike$1 = isArrayLike_1;
function keysIn$2($e) {
  return isArrayLike$1($e) ? arrayLikeKeys($e, !0) : baseKeysIn($e);
}
var keysIn_1 = keysIn$2, copyObject = _copyObject, keysIn$1 = keysIn_1;
function toPlainObject$1($e) {
  return copyObject($e, keysIn$1($e));
}
var toPlainObject_1 = toPlainObject$1, assignMergeValue$1 = _assignMergeValue, cloneBuffer = _cloneBufferExports, cloneTypedArray = _cloneTypedArray, copyArray = _copyArray, initCloneObject = _initCloneObject, isArguments = isArguments_1, isArray$3 = isArray_1, isArrayLikeObject = isArrayLikeObject_1, isBuffer$4 = isBufferExports, isFunction$2 = isFunction_1, isObject$6 = isObject_1, isPlainObject$4 = isPlainObject_1, isTypedArray$2 = isTypedArray_1, safeGet$1 = _safeGet, toPlainObject = toPlainObject_1;
function baseMergeDeep$1($e, Ze, Fe, Ke, Ve, Je, Qe) {
  var at = safeGet$1($e, Fe), ut = safeGet$1(Ze, Fe), lt = Qe.get(ut);
  if (lt) {
    assignMergeValue$1($e, Fe, lt);
    return;
  }
  var dt = Je ? Je(at, ut, Fe + "", $e, Ze, Qe) : void 0, bt = dt === void 0;
  if (bt) {
    var $t = isArray$3(ut), vt = !$t && isBuffer$4(ut), wt = !$t && !vt && isTypedArray$2(ut);
    dt = ut, $t || vt || wt ? isArray$3(at) ? dt = at : isArrayLikeObject(at) ? dt = copyArray(at) : vt ? (bt = !1, dt = cloneBuffer(ut, !0)) : wt ? (bt = !1, dt = cloneTypedArray(ut, !0)) : dt = [] : isPlainObject$4(ut) || isArguments(ut) ? (dt = at, isArguments(at) ? dt = toPlainObject(at) : (!isObject$6(at) || isFunction$2(at)) && (dt = initCloneObject(ut))) : bt = !1;
  }
  bt && (Qe.set(ut, dt), Ve(dt, ut, Ke, Je, Qe), Qe.delete(ut)), assignMergeValue$1($e, Fe, dt);
}
var _baseMergeDeep = baseMergeDeep$1, Stack = _Stack, assignMergeValue = _assignMergeValue, baseFor = _baseFor, baseMergeDeep = _baseMergeDeep, isObject$5 = isObject_1, keysIn = keysIn_1, safeGet = _safeGet;
function baseMerge$1($e, Ze, Fe, Ke, Ve) {
  $e !== Ze && baseFor(Ze, function(Je, Qe) {
    if (Ve || (Ve = new Stack()), isObject$5(Je))
      baseMergeDeep($e, Ze, Qe, Fe, baseMerge$1, Ke, Ve);
    else {
      var at = Ke ? Ke(safeGet($e, Qe), Je, Qe + "", $e, Ze, Ve) : void 0;
      at === void 0 && (at = Je), assignMergeValue($e, Qe, at);
    }
  }, keysIn);
}
var _baseMerge = baseMerge$1;
function identity$4($e) {
  return $e;
}
var identity_1 = identity$4;
function apply$1($e, Ze, Fe) {
  switch (Fe.length) {
    case 0:
      return $e.call(Ze);
    case 1:
      return $e.call(Ze, Fe[0]);
    case 2:
      return $e.call(Ze, Fe[0], Fe[1]);
    case 3:
      return $e.call(Ze, Fe[0], Fe[1], Fe[2]);
  }
  return $e.apply(Ze, Fe);
}
var _apply = apply$1, apply = _apply, nativeMax = Math.max;
function overRest$1($e, Ze, Fe) {
  return Ze = nativeMax(Ze === void 0 ? $e.length - 1 : Ze, 0), function() {
    for (var Ke = arguments, Ve = -1, Je = nativeMax(Ke.length - Ze, 0), Qe = Array(Je); ++Ve < Je; )
      Qe[Ve] = Ke[Ze + Ve];
    Ve = -1;
    for (var at = Array(Ze + 1); ++Ve < Ze; )
      at[Ve] = Ke[Ve];
    return at[Ze] = Fe(Qe), apply($e, this, at);
  };
}
var _overRest = overRest$1;
function constant$1($e) {
  return function() {
    return $e;
  };
}
var constant_1 = constant$1, constant = constant_1, defineProperty$1 = _defineProperty, identity$3 = identity_1, baseSetToString$1 = defineProperty$1 ? function($e, Ze) {
  return defineProperty$1($e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: constant(Ze),
    writable: !0
  });
} : identity$3, _baseSetToString = baseSetToString$1, HOT_COUNT = 800, HOT_SPAN = 16, nativeNow = Date.now;
function shortOut$1($e) {
  var Ze = 0, Fe = 0;
  return function() {
    var Ke = nativeNow(), Ve = HOT_SPAN - (Ke - Fe);
    if (Fe = Ke, Ve > 0) {
      if (++Ze >= HOT_COUNT)
        return arguments[0];
    } else
      Ze = 0;
    return $e.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1, baseSetToString = _baseSetToString, shortOut = _shortOut, setToString$1 = shortOut(baseSetToString), _setToString = setToString$1, identity$2 = identity_1, overRest = _overRest, setToString = _setToString;
function baseRest$1($e, Ze) {
  return setToString(overRest($e, Ze, identity$2), $e + "");
}
var _baseRest = baseRest$1, eq = eq_1, isArrayLike = isArrayLike_1, isIndex = _isIndex, isObject$4 = isObject_1;
function isIterateeCall$1($e, Ze, Fe) {
  if (!isObject$4(Fe))
    return !1;
  var Ke = typeof Ze;
  return (Ke == "number" ? isArrayLike(Fe) && isIndex(Ze, Fe.length) : Ke == "string" && Ze in Fe) ? eq(Fe[Ze], $e) : !1;
}
var _isIterateeCall = isIterateeCall$1, baseRest = _baseRest, isIterateeCall = _isIterateeCall;
function createAssigner$1($e) {
  return baseRest(function(Ze, Fe) {
    var Ke = -1, Ve = Fe.length, Je = Ve > 1 ? Fe[Ve - 1] : void 0, Qe = Ve > 2 ? Fe[2] : void 0;
    for (Je = $e.length > 3 && typeof Je == "function" ? (Ve--, Je) : void 0, Qe && isIterateeCall(Fe[0], Fe[1], Qe) && (Je = Ve < 3 ? void 0 : Je, Ve = 1), Ze = Object(Ze); ++Ke < Ve; ) {
      var at = Fe[Ke];
      at && $e(Ze, at, Ke, Je);
    }
    return Ze;
  });
}
var _createAssigner = createAssigner$1, baseMerge = _baseMerge, createAssigner = _createAssigner, mergeWith = createAssigner(function($e, Ze, Fe, Ke) {
  baseMerge($e, Ze, Fe, Ke);
}), mergeWith_1 = mergeWith;
const mergeWith$1 = /* @__PURE__ */ getDefaultExportFromCjs(mergeWith_1);
function mergeThemes($e, Ze) {
  const Fe = mergeWith$1({}, $e, customizer);
  return mergeWith$1(Fe, Ze, customizer);
}
function customizer($e, Ze, Fe) {
  if (Fe === "className")
    return twMerge($e ?? "", Ze ?? "");
  if (Fe === "style")
    return { ...$e ?? {}, ...Ze ?? {} };
}
function r$j($e) {
  var Ze, Fe, Ke = "";
  if (typeof $e == "string" || typeof $e == "number")
    Ke += $e;
  else if (typeof $e == "object")
    if (Array.isArray($e))
      for (Ze = 0; Ze < $e.length; Ze++)
        $e[Ze] && (Fe = r$j($e[Ze])) && (Ke && (Ke += " "), Ke += Fe);
    else
      for (Ze in $e)
        $e[Ze] && (Ke && (Ke += " "), Ke += Ze);
  return Ke;
}
function clsx() {
  for (var $e, Ze, Fe = 0, Ke = ""; Fe < arguments.length; )
    ($e = arguments[Fe++]) && (Ze = r$j($e)) && (Ke && (Ke += " "), Ke += Ze);
  return Ke;
}
const fabIcon = ($e = "#FFFFFF") => `bg-[url("data:image/svg+xml,%3Csvg width='24' height='24' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M4.583 14.894l-3.256 3.78c-.7.813-1.26.598-1.25-.46a10689.413 10689.413 0 0 1 .035-4.775V4.816a3.89 3.89 0 0 1 3.88-3.89h12.064a3.885 3.885 0 0 1 3.882 3.89v6.185a3.89 3.89 0 0 1-3.882 3.89H4.583z' fill='%23${$e.replace(
  "#",
  ""
)}' fill-rule='evenodd'%3E%3C/path%3E%3C/svg%3E")]`, baseTheme = {
  container: {
    className: "w-full h-full border rounded-lg flex flex-col @container relative overflow-hidden"
  },
  modal: {
    container: {
      className: "absolute inset-0 z-30 flex p-2 pointer-events-none"
    },
    overlay: {
      className: "absolute inset-0 z-30 bg-black/30 backdrop-blur-[1px]"
    },
    dialog: {
      container: {
        className: "mx-auto mt-auto rounded-md p-6 w-full @md:w-auto @md:mb-auto pointer-events-auto"
      },
      title: {
        container: {
          className: "flex items-center justify-between mb-2"
        },
        text: {
          className: "text-base"
        },
        closeIcon: {
          className: "h-5 cursor-pointer"
        }
      },
      content: {
        className: "text-sm flex flex-col"
      }
    }
  },
  fab: {
    container: {
      className: "rounded-full h-16 w-16 cursor-pointer"
    },
    icon: {
      className: "h-full w-full bg-center bg-no-repeat "
    }
  },
  notification: {
    container: {
      className: "group/toast grid w-full grid-cols-[auto_1fr_auto] items-center gap-x-2 rounded-md p-4"
    },
    title: {
      className: "col-start-2 text-sm font-medium"
    },
    description: {
      className: "col-start-2 mt-1 text-sm"
    },
    icon: {
      className: "aspect-square h-5 "
    },
    closeIcon: {
      className: "col-start-3 row-start-1 aspect-square h-5 hover:cursor-pointer"
    }
  },
  header: {
    container: {
      className: "rounded-t-md p-1 mb-auto group/header flex flex-col"
    },
    content: {
      container: {
        className: "grid grow cursor-pointer grid-cols-[auto_1fr_auto] items-center gap-x-2 rounded-md p-1 px-3 text-left"
      },
      title: { className: "text-base font-medium" },
      description: {
        className: "text-sm"
      },
      avatar: {
        container: {
          className: clsx("p-px rounded-full overflow-hidden", "group-data-[state=closed]/header:mr-2")
        },
        image: {
          className: "aspect-square h-8 rounded-full object-cover"
        },
        fallback: {
          className: "flex h-8 aspect-square text-lg items-center justify-center rounded-full"
        }
      },
      actions: {
        container: {
          className: "flex group-data-[state=open]/header:hidden"
        },
        icons: {
          className: "h-9 w-9 cursor-pointer rounded-md p-2"
        }
      }
    },
    expandedContent: {
      container: {
        className: "items-center px-2"
      },
      descriptionItems: {
        container: {
          className: "flex group/item text-xs hover:cursor-pointer"
        }
      }
    },
    newConversationIcon: {
      className: "h-9 w-9 p-2 cursor-pointer ml-auto"
    }
  },
  composer: {
    container: {
      className: "group/composer flex gap-2 items-center"
    },
    input: {
      className: "flex-grow outline-none px-2 rounded-md text-sm resize-none"
    },
    button: {
      container: {
        className: "group-data-[disabled=true]/composer:hidden disabled:hidden flex items-center justify-center"
      },
      icon: {
        className: "h-full w-full"
      }
    }
  },
  messageList: {
    scrollDownButton: {
      container: { className: "absolute bottom-[64px] left-0 z-10 w-full flex justify-center" },
      button: {
        className: "data-[is-at-bottom=true]:opacity-0 data-[is-at-bottom=true]:pointer-events-none gap-1 flex items-center text-xs pl-3 pr-2 py-1"
      }
    },
    container: { className: "flex flex-col gap-2 p-4 overflow-y-auto overflow-x-hidden scroll-smooth" },
    marquee: {
      container: {
        className: "flex items-center justify-center gap-2 flex-2 pb-12 flex-col"
      },
      content: { className: "flex flex-col max-w-[60ch]" },
      title: { className: "text-lg font-medium text-center" },
      description: { className: "text-sm text-center mt-1" },
      avatar: {
        container: {
          className: "p-px rounded-full overflow-hidden mb-3"
        },
        image: {
          className: "aspect-square h-20 rounded-full object-cover"
        },
        fallback: {
          className: "flex h-20 aspect-square text-3xl items-center justify-center rounded-full"
        }
      }
    }
  },
  message: {
    container: {
      className: clsx(
        "flex group gap-2 text-sm",
        "data-[direction=incoming]:justify-start data-[direction=outgoing]:justify-end data-[loaded=false]:hidden",
        "data-[direction=system]:justify-center data-[direction=system]:text-xs data-[direction=system]:mt-4"
      )
    },
    avatar: {
      container: {
        className: "relative h-7 w-7 shrink-0 overflow-hidden rounded-full hidden self-end group-data-[direction=incoming]:flex"
      },
      image: {
        className: "aspect-square h-full w-full"
      },
      fallback: {
        className: "flex h-7 w-7 items-center justify-center rounded-full"
      }
    },
    blocks: {
      text: {
        heading1: {
          className: "text-xl font-medium"
        },
        heading2: {
          className: "text-lg"
        },
        heading3: {
          className: "text-base"
        },
        unorderedList: {
          className: "list-disc list-inside"
        },
        orderedList: {
          className: "list-decimal list-inside"
        }
      },
      image: {
        image: {
          className: clsx(
            "rounded-2xl object-cover w-[95%]",
            "data-[orientation=landscape]:aspect-[4/3]",
            "data-[orientation=portrait]:aspect-[3/4]",
            "data-[orientation=square]:aspect-square",
            "@xs:w-56",
            "data-[loaded=false]:hidden"
          )
        },
        placeholder: {
          className: clsx(
            "rounded-2xl animate-pulse",
            "data-[orientation=landscape]:aspect-[4/3]",
            "data-[orientation=portrait]:aspect-[3/4]",
            "data-[orientation=square]:aspect-square",
            "@xs:w-56"
          )
        }
      },
      video: {
        className: "rounded-2xl"
      },
      location: {
        container: {
          className: "flex gap-2 group items-center p-1"
        },
        title: {
          className: "group-hover:underline"
        },
        icon: {
          className: "h-5 w-5"
        }
      },
      file: {
        container: {
          className: "flex gap-2 group items-center py-2 px-4 rounded-3xl truncate"
        },
        title: {
          className: "truncate"
        },
        icon: {
          className: "h-5 w-5 flex-none"
        }
      },
      row: {
        className: clsx(
          "flex gap-2 flex-wrap",
          "data-[horizontal=center]:justify-center",
          "data-[horizontal=right]:justify-end",
          "data-[horizontal=stretch]:justify-between",
          "data-[vertical=center]:items-center",
          "data-[vertical=bottom]:items-end"
        )
      },
      column: {
        className: clsx(
          "flex flex-col gap-2 w-fit group/container",
          "data-[horizontal=center]:items-center",
          "data-[horizontal=right]:items-end",
          "data-[vertical=center]:justify-center",
          "data-[vertical=bottom]:justify-end",
          "data-[vertical=stretch]:justify-between"
        )
      },
      bubble: {
        className: "p-2 px-4 max-w-[85%]"
      },
      carousel: {
        container: {
          className: "group relative overflow-hidden"
        },
        slidesContainer: {
          className: "grid auto-cols-[90%] grid-flow-col gap-x-2 object-cover px-2 @md:auto-cols-max [&>*]:max-w-[26rem]"
        },
        backButton: {
          className: clsx(
            "absolute left-1 top-1/2 h-7 -translate-y-1/2 rounded-full  p-0.5",
            "hover:scale-110 hover:cursor-pointer data-[disabled]:hidden"
          )
        },
        nextButton: {
          className: clsx(
            "absolute right-1 top-1/2 h-7 -translate-y-1/2 rounded-full  p-0.5",
            "hover:scale-110 hover:cursor-pointer data-[disabled]:hidden"
          )
        }
      },
      dropdown: {
        button: {
          container: {
            className: "group/dropdown flex max-w-[80%] cursor-pointer items-center justify-between rounded-md p-2 truncate data-[disabled]:cursor-not-allowed data-[disabled]:outline-none"
          },
          text: {
            className: "truncate"
          },
          icon: {
            className: "ml-2 inline-block h-4 w-4 group-data-[disabled]/dropdown:hidden"
          }
        },
        content: {
          container: {
            className: "min-w-[100px] overflow-y-auto rounded-md text-sm outline-none"
          },
          item: {
            className: "cursor-pointer p-2 outline-none"
          }
        }
      }
    }
  },
  loadingIndicator: {
    container: {
      className: clsx(
        "flex items-end gap-1.5 rounded-lg p-2",
        "before:animate-jump before:h-1.5 before:w-1.5 before:rounded-full",
        "after:animate-jump after:h-1.5 after:w-1.5 after:rounded-full after:[animation-delay:0.2s]"
      )
    },
    loader: {
      className: "animate-jump h-1.5 w-1.5 rounded-full [animation-delay:0.1s]"
    }
  }
};
function withBaseTheme($e) {
  return mergeThemes(baseTheme, $e);
}
const Avatar = forwardRef(
  ({ userId: $e, src: Ze, container: Fe, image: Ke, fallback: Ve, ...Je }, Qe) => {
    const at = hashStringToInt($e ?? "", 15);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs($cddcb0b647441e34$export$e2255cf6045e8d47, { ref: Qe, "data-color": at, ...Fe, ...Je, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx($cddcb0b647441e34$export$2cd8ae1985206fe8, { src: Ze, ...Ke }),
      /* @__PURE__ */ jsxRuntimeExports.jsx($cddcb0b647441e34$export$69fffb6a9571fbfe, { ...Ve, children: typeof Je.children == "string" ? Je.children[0] : Je.children })
    ] });
  }
), protocols = ["http", "https", "mailto", "tel"];
function uriTransformer($e) {
  const Ze = ($e || "").trim(), Fe = Ze.charAt(0);
  if (Fe === "#" || Fe === "/")
    return Ze;
  const Ke = Ze.indexOf(":");
  if (Ke === -1)
    return Ze;
  let Ve = -1;
  for (; ++Ve < protocols.length; ) {
    const Je = protocols[Ve];
    if (Ke === Je.length && Ze.slice(0, Je.length).toLowerCase() === Je)
      return Ze;
  }
  return Ve = Ze.indexOf("?"), Ve !== -1 && Ke > Ve || (Ve = Ze.indexOf("#"), Ve !== -1 && Ke > Ve) ? Ze : "javascript:void(0)";
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var isBuffer$2 = function(Ze) {
  return Ze != null && Ze.constructor != null && typeof Ze.constructor.isBuffer == "function" && Ze.constructor.isBuffer(Ze);
};
const isBuffer$3 = /* @__PURE__ */ getDefaultExportFromCjs(isBuffer$2);
function stringifyPosition($e) {
  return !$e || typeof $e != "object" ? "" : "position" in $e || "type" in $e ? position$2($e.position) : "start" in $e || "end" in $e ? position$2($e) : "line" in $e || "column" in $e ? point$2($e) : "";
}
function point$2($e) {
  return index$3($e && $e.line) + ":" + index$3($e && $e.column);
}
function position$2($e) {
  return point$2($e && $e.start) + "-" + point$2($e && $e.end);
}
function index$3($e) {
  return $e && typeof $e == "number" ? $e : 1;
}
class VFileMessage extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   *
   *   > 👉 **Note**: you should use markdown.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // To do: next major: expose `undefined` everywhere instead of `null`.
  constructor(Ze, Fe, Ke) {
    const Ve = [null, null];
    let Je = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: { line: null, column: null },
      // @ts-expect-error: "
      end: { line: null, column: null }
    };
    if (super(), typeof Fe == "string" && (Ke = Fe, Fe = void 0), typeof Ke == "string") {
      const Qe = Ke.indexOf(":");
      Qe === -1 ? Ve[1] = Ke : (Ve[0] = Ke.slice(0, Qe), Ve[1] = Ke.slice(Qe + 1));
    }
    Fe && ("type" in Fe || "position" in Fe ? Fe.position && (Je = Fe.position) : "start" in Fe || "end" in Fe ? Je = Fe : ("line" in Fe || "column" in Fe) && (Je.start = Fe)), this.name = stringifyPosition(Fe) || "1:1", this.message = typeof Ze == "object" ? Ze.message : Ze, this.stack = "", typeof Ze == "object" && Ze.stack && (this.stack = Ze.stack), this.reason = this.message, this.fatal, this.line = Je.start.line, this.column = Je.start.column, this.position = Je, this.source = Ve[0], this.ruleId = Ve[1], this.file, this.actual, this.expected, this.url, this.note;
  }
}
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.fatal = null;
VFileMessage.prototype.column = null;
VFileMessage.prototype.line = null;
VFileMessage.prototype.source = null;
VFileMessage.prototype.ruleId = null;
VFileMessage.prototype.position = null;
const path$1 = { basename, dirname, extname, join: join$1, sep: "/" };
function basename($e, Ze) {
  if (Ze !== void 0 && typeof Ze != "string")
    throw new TypeError('"ext" argument must be a string');
  assertPath$1($e);
  let Fe = 0, Ke = -1, Ve = $e.length, Je;
  if (Ze === void 0 || Ze.length === 0 || Ze.length > $e.length) {
    for (; Ve--; )
      if ($e.charCodeAt(Ve) === 47) {
        if (Je) {
          Fe = Ve + 1;
          break;
        }
      } else
        Ke < 0 && (Je = !0, Ke = Ve + 1);
    return Ke < 0 ? "" : $e.slice(Fe, Ke);
  }
  if (Ze === $e)
    return "";
  let Qe = -1, at = Ze.length - 1;
  for (; Ve--; )
    if ($e.charCodeAt(Ve) === 47) {
      if (Je) {
        Fe = Ve + 1;
        break;
      }
    } else
      Qe < 0 && (Je = !0, Qe = Ve + 1), at > -1 && ($e.charCodeAt(Ve) === Ze.charCodeAt(at--) ? at < 0 && (Ke = Ve) : (at = -1, Ke = Qe));
  return Fe === Ke ? Ke = Qe : Ke < 0 && (Ke = $e.length), $e.slice(Fe, Ke);
}
function dirname($e) {
  if (assertPath$1($e), $e.length === 0)
    return ".";
  let Ze = -1, Fe = $e.length, Ke;
  for (; --Fe; )
    if ($e.charCodeAt(Fe) === 47) {
      if (Ke) {
        Ze = Fe;
        break;
      }
    } else
      Ke || (Ke = !0);
  return Ze < 0 ? $e.charCodeAt(0) === 47 ? "/" : "." : Ze === 1 && $e.charCodeAt(0) === 47 ? "//" : $e.slice(0, Ze);
}
function extname($e) {
  assertPath$1($e);
  let Ze = $e.length, Fe = -1, Ke = 0, Ve = -1, Je = 0, Qe;
  for (; Ze--; ) {
    const at = $e.charCodeAt(Ze);
    if (at === 47) {
      if (Qe) {
        Ke = Ze + 1;
        break;
      }
      continue;
    }
    Fe < 0 && (Qe = !0, Fe = Ze + 1), at === 46 ? Ve < 0 ? Ve = Ze : Je !== 1 && (Je = 1) : Ve > -1 && (Je = -1);
  }
  return Ve < 0 || Fe < 0 || // We saw a non-dot character immediately before the dot.
  Je === 0 || // The (right-most) trimmed path component is exactly `..`.
  Je === 1 && Ve === Fe - 1 && Ve === Ke + 1 ? "" : $e.slice(Ve, Fe);
}
function join$1(...$e) {
  let Ze = -1, Fe;
  for (; ++Ze < $e.length; )
    assertPath$1($e[Ze]), $e[Ze] && (Fe = Fe === void 0 ? $e[Ze] : Fe + "/" + $e[Ze]);
  return Fe === void 0 ? "." : normalize$2(Fe);
}
function normalize$2($e) {
  assertPath$1($e);
  const Ze = $e.charCodeAt(0) === 47;
  let Fe = normalizeString($e, !Ze);
  return Fe.length === 0 && !Ze && (Fe = "."), Fe.length > 0 && $e.charCodeAt($e.length - 1) === 47 && (Fe += "/"), Ze ? "/" + Fe : Fe;
}
function normalizeString($e, Ze) {
  let Fe = "", Ke = 0, Ve = -1, Je = 0, Qe = -1, at, ut;
  for (; ++Qe <= $e.length; ) {
    if (Qe < $e.length)
      at = $e.charCodeAt(Qe);
    else {
      if (at === 47)
        break;
      at = 47;
    }
    if (at === 47) {
      if (!(Ve === Qe - 1 || Je === 1))
        if (Ve !== Qe - 1 && Je === 2) {
          if (Fe.length < 2 || Ke !== 2 || Fe.charCodeAt(Fe.length - 1) !== 46 || Fe.charCodeAt(Fe.length - 2) !== 46) {
            if (Fe.length > 2) {
              if (ut = Fe.lastIndexOf("/"), ut !== Fe.length - 1) {
                ut < 0 ? (Fe = "", Ke = 0) : (Fe = Fe.slice(0, ut), Ke = Fe.length - 1 - Fe.lastIndexOf("/")), Ve = Qe, Je = 0;
                continue;
              }
            } else if (Fe.length > 0) {
              Fe = "", Ke = 0, Ve = Qe, Je = 0;
              continue;
            }
          }
          Ze && (Fe = Fe.length > 0 ? Fe + "/.." : "..", Ke = 2);
        } else
          Fe.length > 0 ? Fe += "/" + $e.slice(Ve + 1, Qe) : Fe = $e.slice(Ve + 1, Qe), Ke = Qe - Ve - 1;
      Ve = Qe, Je = 0;
    } else
      at === 46 && Je > -1 ? Je++ : Je = -1;
  }
  return Fe;
}
function assertPath$1($e) {
  if (typeof $e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify($e)
    );
}
const proc = { cwd: cwd$1 };
function cwd$1() {
  return "/";
}
function isUrl($e) {
  return $e !== null && typeof $e == "object" && // @ts-expect-error: indexable.
  $e.href && // @ts-expect-error: indexable.
  $e.origin;
}
function urlToPath($e) {
  if (typeof $e == "string")
    $e = new URL($e);
  else if (!isUrl($e)) {
    const Ze = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + $e + "`"
    );
    throw Ze.code = "ERR_INVALID_ARG_TYPE", Ze;
  }
  if ($e.protocol !== "file:") {
    const Ze = new TypeError("The URL must be of scheme file");
    throw Ze.code = "ERR_INVALID_URL_SCHEME", Ze;
  }
  return getPathFromURLPosix$2($e);
}
function getPathFromURLPosix$2($e) {
  if ($e.hostname !== "") {
    const Ke = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw Ke.code = "ERR_INVALID_FILE_URL_HOST", Ke;
  }
  const Ze = $e.pathname;
  let Fe = -1;
  for (; ++Fe < Ze.length; )
    if (Ze.charCodeAt(Fe) === 37 && Ze.charCodeAt(Fe + 1) === 50) {
      const Ke = Ze.charCodeAt(Fe + 2);
      if (Ke === 70 || Ke === 102) {
        const Ve = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw Ve.code = "ERR_INVALID_FILE_URL_PATH", Ve;
      }
    }
  return decodeURIComponent(Ze);
}
const order = ["history", "path", "basename", "stem", "extname", "dirname"];
class VFile {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Buffer` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(Ze) {
    let Fe;
    Ze ? typeof Ze == "string" || buffer$1(Ze) ? Fe = { value: Ze } : isUrl(Ze) ? Fe = { path: Ze } : Fe = Ze : Fe = {}, this.data = {}, this.messages = [], this.history = [], this.cwd = proc.cwd(), this.value, this.stored, this.result, this.map;
    let Ke = -1;
    for (; ++Ke < order.length; ) {
      const Je = order[Ke];
      Je in Fe && Fe[Je] !== void 0 && Fe[Je] !== null && (this[Je] = Je === "history" ? [...Fe[Je]] : Fe[Je]);
    }
    let Ve;
    for (Ve in Fe)
      order.includes(Ve) || (this[Ve] = Fe[Ve]);
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {string | URL} path
   */
  set path(Ze) {
    isUrl(Ze) && (Ze = urlToPath(Ze)), assertNonEmpty(Ze, "path"), this.path !== Ze && this.history.push(Ze);
  }
  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path == "string" ? path$1.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   */
  set dirname(Ze) {
    assertPath(this.basename, "dirname"), this.path = path$1.join(Ze || "", this.basename);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path == "string" ? path$1.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(Ze) {
    assertNonEmpty(Ze, "basename"), assertPart(Ze, "basename"), this.path = path$1.join(this.dirname || "", Ze);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path == "string" ? path$1.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   */
  set extname(Ze) {
    if (assertPart(Ze, "extname"), assertPath(this.dirname, "extname"), Ze) {
      if (Ze.charCodeAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (Ze.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = path$1.join(this.dirname, this.stem + (Ze || ""));
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path == "string" ? path$1.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(Ze) {
    assertNonEmpty(Ze, "stem"), assertPart(Ze, "stem"), this.path = path$1.join(this.dirname || "", Ze + (this.extname || ""));
  }
  /**
   * Serialize the file.
   *
   * @param {BufferEncoding | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Buffer`
   *   (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(Ze) {
    return (this.value || "").toString(Ze || void 0);
  }
  /**
   * Create a warning message associated with the file.
   *
   * Its `fatal` is set to `false` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(Ze, Fe, Ke) {
    const Ve = new VFileMessage(Ze, Fe, Ke);
    return this.path && (Ve.name = this.path + ":" + Ve.name, Ve.file = this.path), Ve.fatal = !1, this.messages.push(Ve), Ve;
  }
  /**
   * Create an info message associated with the file.
   *
   * Its `fatal` is set to `null` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(Ze, Fe, Ke) {
    const Ve = this.message(Ze, Fe, Ke);
    return Ve.fatal = null, Ve;
  }
  /**
   * Create a fatal error associated with the file.
   *
   * Its `fatal` is set to `true` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * > 👉 **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Message.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(Ze, Fe, Ke) {
    const Ve = this.message(Ze, Fe, Ke);
    throw Ve.fatal = !0, Ve;
  }
}
function assertPart($e, Ze) {
  if ($e && $e.includes(path$1.sep))
    throw new Error(
      "`" + Ze + "` cannot be a path: did not expect `" + path$1.sep + "`"
    );
}
function assertNonEmpty($e, Ze) {
  if (!$e)
    throw new Error("`" + Ze + "` cannot be empty");
}
function assertPath($e, Ze) {
  if (!$e)
    throw new Error("Setting `" + Ze + "` requires `path` to be set too");
}
function buffer$1($e) {
  return isBuffer$3($e);
}
function bail($e) {
  if ($e)
    throw $e;
}
var hasOwn = Object.prototype.hasOwnProperty, toStr = Object.prototype.toString, defineProperty = Object.defineProperty, gOPD = Object.getOwnPropertyDescriptor, isArray$2 = function(Ze) {
  return typeof Array.isArray == "function" ? Array.isArray(Ze) : toStr.call(Ze) === "[object Array]";
}, isPlainObject$3 = function(Ze) {
  if (!Ze || toStr.call(Ze) !== "[object Object]")
    return !1;
  var Fe = hasOwn.call(Ze, "constructor"), Ke = Ze.constructor && Ze.constructor.prototype && hasOwn.call(Ze.constructor.prototype, "isPrototypeOf");
  if (Ze.constructor && !Fe && !Ke)
    return !1;
  var Ve;
  for (Ve in Ze)
    ;
  return typeof Ve > "u" || hasOwn.call(Ze, Ve);
}, setProperty = function(Ze, Fe) {
  defineProperty && Fe.name === "__proto__" ? defineProperty(Ze, Fe.name, {
    enumerable: !0,
    configurable: !0,
    value: Fe.newValue,
    writable: !0
  }) : Ze[Fe.name] = Fe.newValue;
}, getProperty = function(Ze, Fe) {
  if (Fe === "__proto__")
    if (hasOwn.call(Ze, Fe)) {
      if (gOPD)
        return gOPD(Ze, Fe).value;
    } else
      return;
  return Ze[Fe];
}, extend$2 = function $e() {
  var Ze, Fe, Ke, Ve, Je, Qe, at = arguments[0], ut = 1, lt = arguments.length, dt = !1;
  for (typeof at == "boolean" && (dt = at, at = arguments[1] || {}, ut = 2), (at == null || typeof at != "object" && typeof at != "function") && (at = {}); ut < lt; ++ut)
    if (Ze = arguments[ut], Ze != null)
      for (Fe in Ze)
        Ke = getProperty(at, Fe), Ve = getProperty(Ze, Fe), at !== Ve && (dt && Ve && (isPlainObject$3(Ve) || (Je = isArray$2(Ve))) ? (Je ? (Je = !1, Qe = Ke && isArray$2(Ke) ? Ke : []) : Qe = Ke && isPlainObject$3(Ke) ? Ke : {}, setProperty(at, { name: Fe, newValue: $e(dt, Qe, Ve) })) : typeof Ve < "u" && setProperty(at, { name: Fe, newValue: Ve }));
  return at;
};
const extend$3 = /* @__PURE__ */ getDefaultExportFromCjs(extend$2);
function isPlainObject$2($e) {
  if (typeof $e != "object" || $e === null)
    return !1;
  const Ze = Object.getPrototypeOf($e);
  return (Ze === null || Ze === Object.prototype || Object.getPrototypeOf(Ze) === null) && !(Symbol.toStringTag in $e) && !(Symbol.iterator in $e);
}
function trough() {
  const $e = [], Ze = { run: Fe, use: Ke };
  return Ze;
  function Fe(...Ve) {
    let Je = -1;
    const Qe = Ve.pop();
    if (typeof Qe != "function")
      throw new TypeError("Expected function as last argument, not " + Qe);
    at(null, ...Ve);
    function at(ut, ...lt) {
      const dt = $e[++Je];
      let bt = -1;
      if (ut) {
        Qe(ut);
        return;
      }
      for (; ++bt < Ve.length; )
        (lt[bt] === null || lt[bt] === void 0) && (lt[bt] = Ve[bt]);
      Ve = lt, dt ? wrap$1(dt, at)(...lt) : Qe(null, ...lt);
    }
  }
  function Ke(Ve) {
    if (typeof Ve != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + Ve
      );
    return $e.push(Ve), Ze;
  }
}
function wrap$1($e, Ze) {
  let Fe;
  return Ke;
  function Ke(...Qe) {
    const at = $e.length > Qe.length;
    let ut;
    at && Qe.push(Ve);
    try {
      ut = $e.apply(this, Qe);
    } catch (lt) {
      const dt = (
        /** @type {Error} */
        lt
      );
      if (at && Fe)
        throw dt;
      return Ve(dt);
    }
    at || (ut instanceof Promise ? ut.then(Je, Ve) : ut instanceof Error ? Ve(ut) : Je(ut));
  }
  function Ve(Qe, ...at) {
    Fe || (Fe = !0, Ze(Qe, ...at));
  }
  function Je(Qe) {
    Ve(null, Qe);
  }
}
const unified = base().freeze(), own$6 = {}.hasOwnProperty;
function base() {
  const $e = trough(), Ze = [];
  let Fe = {}, Ke, Ve = -1;
  return Je.data = Qe, Je.Parser = void 0, Je.Compiler = void 0, Je.freeze = at, Je.attachers = Ze, Je.use = ut, Je.parse = lt, Je.stringify = dt, Je.run = bt, Je.runSync = $t, Je.process = vt, Je.processSync = wt, Je;
  function Je() {
    const xt = base();
    let Et = -1;
    for (; ++Et < Ze.length; )
      xt.use(...Ze[Et]);
    return xt.data(extend$3(!0, {}, Fe)), xt;
  }
  function Qe(xt, Et) {
    return typeof xt == "string" ? arguments.length === 2 ? (assertUnfrozen("data", Ke), Fe[xt] = Et, Je) : own$6.call(Fe, xt) && Fe[xt] || null : xt ? (assertUnfrozen("data", Ke), Fe = xt, Je) : Fe;
  }
  function at() {
    if (Ke)
      return Je;
    for (; ++Ve < Ze.length; ) {
      const [xt, ...Et] = Ze[Ve];
      if (Et[0] === !1)
        continue;
      Et[0] === !0 && (Et[0] = void 0);
      const Tt = xt.call(Je, ...Et);
      typeof Tt == "function" && $e.use(Tt);
    }
    return Ke = !0, Ve = Number.POSITIVE_INFINITY, Je;
  }
  function ut(xt, ...Et) {
    let Tt;
    if (assertUnfrozen("use", Ke), xt != null)
      if (typeof xt == "function")
        Lt(xt, ...Et);
      else if (typeof xt == "object")
        Array.isArray(xt) ? Zt(xt) : Ct(xt);
      else
        throw new TypeError("Expected usable value, not `" + xt + "`");
    return Tt && (Fe.settings = Object.assign(Fe.settings || {}, Tt)), Je;
    function Rt(Ut) {
      if (typeof Ut == "function")
        Lt(Ut);
      else if (typeof Ut == "object")
        if (Array.isArray(Ut)) {
          const [Pt, ...Ot] = Ut;
          Lt(Pt, ...Ot);
        } else
          Ct(Ut);
      else
        throw new TypeError("Expected usable value, not `" + Ut + "`");
    }
    function Ct(Ut) {
      Zt(Ut.plugins), Ut.settings && (Tt = Object.assign(Tt || {}, Ut.settings));
    }
    function Zt(Ut) {
      let Pt = -1;
      if (Ut != null)
        if (Array.isArray(Ut))
          for (; ++Pt < Ut.length; ) {
            const Ot = Ut[Pt];
            Rt(Ot);
          }
        else
          throw new TypeError("Expected a list of plugins, not `" + Ut + "`");
    }
    function Lt(Ut, Pt) {
      let Ot = -1, Ft;
      for (; ++Ot < Ze.length; )
        if (Ze[Ot][0] === Ut) {
          Ft = Ze[Ot];
          break;
        }
      Ft ? (isPlainObject$2(Ft[1]) && isPlainObject$2(Pt) && (Pt = extend$3(!0, Ft[1], Pt)), Ft[1] = Pt) : Ze.push([...arguments]);
    }
  }
  function lt(xt) {
    Je.freeze();
    const Et = vfile(xt), Tt = Je.Parser;
    return assertParser("parse", Tt), newable(Tt, "parse") ? new Tt(String(Et), Et).parse() : Tt(String(Et), Et);
  }
  function dt(xt, Et) {
    Je.freeze();
    const Tt = vfile(Et), Rt = Je.Compiler;
    return assertCompiler("stringify", Rt), assertNode(xt), newable(Rt, "compile") ? new Rt(xt, Tt).compile() : Rt(xt, Tt);
  }
  function bt(xt, Et, Tt) {
    if (assertNode(xt), Je.freeze(), !Tt && typeof Et == "function" && (Tt = Et, Et = void 0), !Tt)
      return new Promise(Rt);
    Rt(null, Tt);
    function Rt(Ct, Zt) {
      $e.run(xt, vfile(Et), Lt);
      function Lt(Ut, Pt, Ot) {
        Pt = Pt || xt, Ut ? Zt(Ut) : Ct ? Ct(Pt) : Tt(null, Pt, Ot);
      }
    }
  }
  function $t(xt, Et) {
    let Tt, Rt;
    return Je.run(xt, Et, Ct), assertDone("runSync", "run", Rt), Tt;
    function Ct(Zt, Lt) {
      bail(Zt), Tt = Lt, Rt = !0;
    }
  }
  function vt(xt, Et) {
    if (Je.freeze(), assertParser("process", Je.Parser), assertCompiler("process", Je.Compiler), !Et)
      return new Promise(Tt);
    Tt(null, Et);
    function Tt(Rt, Ct) {
      const Zt = vfile(xt);
      Je.run(Je.parse(Zt), Zt, (Ut, Pt, Ot) => {
        if (Ut || !Pt || !Ot)
          Lt(Ut);
        else {
          const Ft = Je.stringify(Pt, Ot);
          Ft == null || (looksLikeAVFileValue(Ft) ? Ot.value = Ft : Ot.result = Ft), Lt(Ut, Ot);
        }
      });
      function Lt(Ut, Pt) {
        Ut || !Pt ? Ct(Ut) : Rt ? Rt(Pt) : Et(null, Pt);
      }
    }
  }
  function wt(xt) {
    let Et;
    Je.freeze(), assertParser("processSync", Je.Parser), assertCompiler("processSync", Je.Compiler);
    const Tt = vfile(xt);
    return Je.process(Tt, Rt), assertDone("processSync", "process", Et), Tt;
    function Rt(Ct) {
      Et = !0, bail(Ct);
    }
  }
}
function newable($e, Ze) {
  return typeof $e == "function" && // Prototypes do exist.
  // type-coverage:ignore-next-line
  $e.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes’ prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  // type-coverage:ignore-next-line
  (keys($e.prototype) || Ze in $e.prototype);
}
function keys($e) {
  let Ze;
  for (Ze in $e)
    if (own$6.call($e, Ze))
      return !0;
  return !1;
}
function assertParser($e, Ze) {
  if (typeof Ze != "function")
    throw new TypeError("Cannot `" + $e + "` without `Parser`");
}
function assertCompiler($e, Ze) {
  if (typeof Ze != "function")
    throw new TypeError("Cannot `" + $e + "` without `Compiler`");
}
function assertUnfrozen($e, Ze) {
  if (Ze)
    throw new Error(
      "Cannot call `" + $e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function assertNode($e) {
  if (!isPlainObject$2($e) || typeof $e.type != "string")
    throw new TypeError("Expected node, got `" + $e + "`");
}
function assertDone($e, Ze, Fe) {
  if (!Fe)
    throw new Error(
      "`" + $e + "` finished async. Use `" + Ze + "` instead"
    );
}
function vfile($e) {
  return looksLikeAVFile($e) ? $e : new VFile($e);
}
function looksLikeAVFile($e) {
  return !!($e && typeof $e == "object" && "message" in $e && "messages" in $e);
}
function looksLikeAVFileValue($e) {
  return typeof $e == "string" || isBuffer$3($e);
}
const emptyOptions = {};
function toString$4($e, Ze) {
  const Fe = Ze || emptyOptions, Ke = typeof Fe.includeImageAlt == "boolean" ? Fe.includeImageAlt : !0, Ve = typeof Fe.includeHtml == "boolean" ? Fe.includeHtml : !0;
  return one$1($e, Ke, Ve);
}
function one$1($e, Ze, Fe) {
  if (node($e)) {
    if ("value" in $e)
      return $e.type === "html" && !Fe ? "" : $e.value;
    if (Ze && "alt" in $e && $e.alt)
      return $e.alt;
    if ("children" in $e)
      return all$2($e.children, Ze, Fe);
  }
  return Array.isArray($e) ? all$2($e, Ze, Fe) : "";
}
function all$2($e, Ze, Fe) {
  const Ke = [];
  let Ve = -1;
  for (; ++Ve < $e.length; )
    Ke[Ve] = one$1($e[Ve], Ze, Fe);
  return Ke.join("");
}
function node($e) {
  return !!($e && typeof $e == "object");
}
function splice($e, Ze, Fe, Ke) {
  const Ve = $e.length;
  let Je = 0, Qe;
  if (Ze < 0 ? Ze = -Ze > Ve ? 0 : Ve + Ze : Ze = Ze > Ve ? Ve : Ze, Fe = Fe > 0 ? Fe : 0, Ke.length < 1e4)
    Qe = Array.from(Ke), Qe.unshift(Ze, Fe), $e.splice(...Qe);
  else
    for (Fe && $e.splice(Ze, Fe); Je < Ke.length; )
      Qe = Ke.slice(Je, Je + 1e4), Qe.unshift(Ze, 0), $e.splice(...Qe), Je += 1e4, Ze += 1e4;
}
function push($e, Ze) {
  return $e.length > 0 ? (splice($e, $e.length, 0, Ze), $e) : Ze;
}
const hasOwnProperty$2 = {}.hasOwnProperty;
function combineExtensions($e) {
  const Ze = {};
  let Fe = -1;
  for (; ++Fe < $e.length; )
    syntaxExtension(Ze, $e[Fe]);
  return Ze;
}
function syntaxExtension($e, Ze) {
  let Fe;
  for (Fe in Ze) {
    const Ve = (hasOwnProperty$2.call($e, Fe) ? $e[Fe] : void 0) || ($e[Fe] = {}), Je = Ze[Fe];
    let Qe;
    if (Je)
      for (Qe in Je) {
        hasOwnProperty$2.call(Ve, Qe) || (Ve[Qe] = []);
        const at = Je[Qe];
        constructs(
          // @ts-expect-error Looks like a list.
          Ve[Qe],
          Array.isArray(at) ? at : at ? [at] : []
        );
      }
  }
}
function constructs($e, Ze) {
  let Fe = -1;
  const Ke = [];
  for (; ++Fe < Ze.length; )
    (Ze[Fe].add === "after" ? $e : Ke).push(Ze[Fe]);
  splice($e, 0, 0, Ke);
}
const unicodePunctuationRegex = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, asciiAlpha = regexCheck(/[A-Za-z]/), asciiAlphanumeric = regexCheck(/[\dA-Za-z]/), asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl($e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    $e !== null && ($e < 32 || $e === 127)
  );
}
const asciiDigit = regexCheck(/\d/), asciiHexDigit = regexCheck(/[\dA-Fa-f]/), asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding($e) {
  return $e !== null && $e < -2;
}
function markdownLineEndingOrSpace($e) {
  return $e !== null && ($e < 0 || $e === 32);
}
function markdownSpace($e) {
  return $e === -2 || $e === -1 || $e === 32;
}
const unicodePunctuation = regexCheck(unicodePunctuationRegex), unicodeWhitespace = regexCheck(/\s/);
function regexCheck($e) {
  return Ze;
  function Ze(Fe) {
    return Fe !== null && $e.test(String.fromCharCode(Fe));
  }
}
function factorySpace($e, Ze, Fe, Ke) {
  const Ve = Ke ? Ke - 1 : Number.POSITIVE_INFINITY;
  let Je = 0;
  return Qe;
  function Qe(ut) {
    return markdownSpace(ut) ? ($e.enter(Fe), at(ut)) : Ze(ut);
  }
  function at(ut) {
    return markdownSpace(ut) && Je++ < Ve ? ($e.consume(ut), at) : ($e.exit(Fe), Ze(ut));
  }
}
const content$1 = {
  tokenize: initializeContent
};
function initializeContent($e) {
  const Ze = $e.attempt(
    this.parser.constructs.contentInitial,
    Ke,
    Ve
  );
  let Fe;
  return Ze;
  function Ke(at) {
    if (at === null) {
      $e.consume(at);
      return;
    }
    return $e.enter("lineEnding"), $e.consume(at), $e.exit("lineEnding"), factorySpace($e, Ze, "linePrefix");
  }
  function Ve(at) {
    return $e.enter("paragraph"), Je(at);
  }
  function Je(at) {
    const ut = $e.enter("chunkText", {
      contentType: "text",
      previous: Fe
    });
    return Fe && (Fe.next = ut), Fe = ut, Qe(at);
  }
  function Qe(at) {
    if (at === null) {
      $e.exit("chunkText"), $e.exit("paragraph"), $e.consume(at);
      return;
    }
    return markdownLineEnding(at) ? ($e.consume(at), $e.exit("chunkText"), Je) : ($e.consume(at), Qe);
  }
}
const document$2 = {
  tokenize: initializeDocument
}, containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument($e) {
  const Ze = this, Fe = [];
  let Ke = 0, Ve, Je, Qe;
  return at;
  function at(Ct) {
    if (Ke < Fe.length) {
      const Zt = Fe[Ke];
      return Ze.containerState = Zt[1], $e.attempt(
        Zt[0].continuation,
        ut,
        lt
      )(Ct);
    }
    return lt(Ct);
  }
  function ut(Ct) {
    if (Ke++, Ze.containerState._closeFlow) {
      Ze.containerState._closeFlow = void 0, Ve && Rt();
      const Zt = Ze.events.length;
      let Lt = Zt, Ut;
      for (; Lt--; )
        if (Ze.events[Lt][0] === "exit" && Ze.events[Lt][1].type === "chunkFlow") {
          Ut = Ze.events[Lt][1].end;
          break;
        }
      Tt(Ke);
      let Pt = Zt;
      for (; Pt < Ze.events.length; )
        Ze.events[Pt][1].end = Object.assign({}, Ut), Pt++;
      return splice(
        Ze.events,
        Lt + 1,
        0,
        Ze.events.slice(Zt)
      ), Ze.events.length = Pt, lt(Ct);
    }
    return at(Ct);
  }
  function lt(Ct) {
    if (Ke === Fe.length) {
      if (!Ve)
        return $t(Ct);
      if (Ve.currentConstruct && Ve.currentConstruct.concrete)
        return wt(Ct);
      Ze.interrupt = !!(Ve.currentConstruct && !Ve._gfmTableDynamicInterruptHack);
    }
    return Ze.containerState = {}, $e.check(
      containerConstruct,
      dt,
      bt
    )(Ct);
  }
  function dt(Ct) {
    return Ve && Rt(), Tt(Ke), $t(Ct);
  }
  function bt(Ct) {
    return Ze.parser.lazy[Ze.now().line] = Ke !== Fe.length, Qe = Ze.now().offset, wt(Ct);
  }
  function $t(Ct) {
    return Ze.containerState = {}, $e.attempt(
      containerConstruct,
      vt,
      wt
    )(Ct);
  }
  function vt(Ct) {
    return Ke++, Fe.push([Ze.currentConstruct, Ze.containerState]), $t(Ct);
  }
  function wt(Ct) {
    if (Ct === null) {
      Ve && Rt(), Tt(0), $e.consume(Ct);
      return;
    }
    return Ve = Ve || Ze.parser.flow(Ze.now()), $e.enter("chunkFlow", {
      contentType: "flow",
      previous: Je,
      _tokenizer: Ve
    }), xt(Ct);
  }
  function xt(Ct) {
    if (Ct === null) {
      Et($e.exit("chunkFlow"), !0), Tt(0), $e.consume(Ct);
      return;
    }
    return markdownLineEnding(Ct) ? ($e.consume(Ct), Et($e.exit("chunkFlow")), Ke = 0, Ze.interrupt = void 0, at) : ($e.consume(Ct), xt);
  }
  function Et(Ct, Zt) {
    const Lt = Ze.sliceStream(Ct);
    if (Zt && Lt.push(null), Ct.previous = Je, Je && (Je.next = Ct), Je = Ct, Ve.defineSkip(Ct.start), Ve.write(Lt), Ze.parser.lazy[Ct.start.line]) {
      let Ut = Ve.events.length;
      for (; Ut--; )
        if (
          // The token starts before the line ending…
          Ve.events[Ut][1].start.offset < Qe && // …and either is not ended yet…
          (!Ve.events[Ut][1].end || // …or ends after it.
          Ve.events[Ut][1].end.offset > Qe)
        )
          return;
      const Pt = Ze.events.length;
      let Ot = Pt, Ft, gt;
      for (; Ot--; )
        if (Ze.events[Ot][0] === "exit" && Ze.events[Ot][1].type === "chunkFlow") {
          if (Ft) {
            gt = Ze.events[Ot][1].end;
            break;
          }
          Ft = !0;
        }
      for (Tt(Ke), Ut = Pt; Ut < Ze.events.length; )
        Ze.events[Ut][1].end = Object.assign({}, gt), Ut++;
      splice(
        Ze.events,
        Ot + 1,
        0,
        Ze.events.slice(Pt)
      ), Ze.events.length = Ut;
    }
  }
  function Tt(Ct) {
    let Zt = Fe.length;
    for (; Zt-- > Ct; ) {
      const Lt = Fe[Zt];
      Ze.containerState = Lt[1], Lt[0].exit.call(Ze, $e);
    }
    Fe.length = Ct;
  }
  function Rt() {
    Ve.write([null]), Je = void 0, Ve = void 0, Ze.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer($e, Ze, Fe) {
  return factorySpace(
    $e,
    $e.attempt(this.parser.constructs.document, Ze, Fe),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function classifyCharacter($e) {
  if ($e === null || markdownLineEndingOrSpace($e) || unicodeWhitespace($e))
    return 1;
  if (unicodePunctuation($e))
    return 2;
}
function resolveAll($e, Ze, Fe) {
  const Ke = [];
  let Ve = -1;
  for (; ++Ve < $e.length; ) {
    const Je = $e[Ve].resolveAll;
    Je && !Ke.includes(Je) && (Ze = Je(Ze, Fe), Ke.push(Je));
  }
  return Ze;
}
const attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention($e, Ze) {
  let Fe = -1, Ke, Ve, Je, Qe, at, ut, lt, dt;
  for (; ++Fe < $e.length; )
    if ($e[Fe][0] === "enter" && $e[Fe][1].type === "attentionSequence" && $e[Fe][1]._close) {
      for (Ke = Fe; Ke--; )
        if ($e[Ke][0] === "exit" && $e[Ke][1].type === "attentionSequence" && $e[Ke][1]._open && // If the markers are the same:
        Ze.sliceSerialize($e[Ke][1]).charCodeAt(0) === Ze.sliceSerialize($e[Fe][1]).charCodeAt(0)) {
          if (($e[Ke][1]._close || $e[Fe][1]._open) && ($e[Fe][1].end.offset - $e[Fe][1].start.offset) % 3 && !(($e[Ke][1].end.offset - $e[Ke][1].start.offset + $e[Fe][1].end.offset - $e[Fe][1].start.offset) % 3))
            continue;
          ut = $e[Ke][1].end.offset - $e[Ke][1].start.offset > 1 && $e[Fe][1].end.offset - $e[Fe][1].start.offset > 1 ? 2 : 1;
          const bt = Object.assign({}, $e[Ke][1].end), $t = Object.assign({}, $e[Fe][1].start);
          movePoint(bt, -ut), movePoint($t, ut), Qe = {
            type: ut > 1 ? "strongSequence" : "emphasisSequence",
            start: bt,
            end: Object.assign({}, $e[Ke][1].end)
          }, at = {
            type: ut > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, $e[Fe][1].start),
            end: $t
          }, Je = {
            type: ut > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, $e[Ke][1].end),
            end: Object.assign({}, $e[Fe][1].start)
          }, Ve = {
            type: ut > 1 ? "strong" : "emphasis",
            start: Object.assign({}, Qe.start),
            end: Object.assign({}, at.end)
          }, $e[Ke][1].end = Object.assign({}, Qe.start), $e[Fe][1].start = Object.assign({}, at.end), lt = [], $e[Ke][1].end.offset - $e[Ke][1].start.offset && (lt = push(lt, [
            ["enter", $e[Ke][1], Ze],
            ["exit", $e[Ke][1], Ze]
          ])), lt = push(lt, [
            ["enter", Ve, Ze],
            ["enter", Qe, Ze],
            ["exit", Qe, Ze],
            ["enter", Je, Ze]
          ]), lt = push(
            lt,
            resolveAll(
              Ze.parser.constructs.insideSpan.null,
              $e.slice(Ke + 1, Fe),
              Ze
            )
          ), lt = push(lt, [
            ["exit", Je, Ze],
            ["enter", at, Ze],
            ["exit", at, Ze],
            ["exit", Ve, Ze]
          ]), $e[Fe][1].end.offset - $e[Fe][1].start.offset ? (dt = 2, lt = push(lt, [
            ["enter", $e[Fe][1], Ze],
            ["exit", $e[Fe][1], Ze]
          ])) : dt = 0, splice($e, Ke - 1, Fe - Ke + 3, lt), Fe = Ke + lt.length - dt - 2;
          break;
        }
    }
  for (Fe = -1; ++Fe < $e.length; )
    $e[Fe][1].type === "attentionSequence" && ($e[Fe][1].type = "data");
  return $e;
}
function tokenizeAttention($e, Ze) {
  const Fe = this.parser.constructs.attentionMarkers.null, Ke = this.previous, Ve = classifyCharacter(Ke);
  let Je;
  return Qe;
  function Qe(ut) {
    return Je = ut, $e.enter("attentionSequence"), at(ut);
  }
  function at(ut) {
    if (ut === Je)
      return $e.consume(ut), at;
    const lt = $e.exit("attentionSequence"), dt = classifyCharacter(ut), bt = !dt || dt === 2 && Ve || Fe.includes(ut), $t = !Ve || Ve === 2 && dt || Fe.includes(Ke);
    return lt._open = !!(Je === 42 ? bt : bt && (Ve || !$t)), lt._close = !!(Je === 42 ? $t : $t && (dt || !bt)), Ze(ut);
  }
}
function movePoint($e, Ze) {
  $e.column += Ze, $e.offset += Ze, $e._bufferIndex += Ze;
}
const autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink($e, Ze, Fe) {
  let Ke = 0;
  return Ve;
  function Ve(vt) {
    return $e.enter("autolink"), $e.enter("autolinkMarker"), $e.consume(vt), $e.exit("autolinkMarker"), $e.enter("autolinkProtocol"), Je;
  }
  function Je(vt) {
    return asciiAlpha(vt) ? ($e.consume(vt), Qe) : lt(vt);
  }
  function Qe(vt) {
    return vt === 43 || vt === 45 || vt === 46 || asciiAlphanumeric(vt) ? (Ke = 1, at(vt)) : lt(vt);
  }
  function at(vt) {
    return vt === 58 ? ($e.consume(vt), Ke = 0, ut) : (vt === 43 || vt === 45 || vt === 46 || asciiAlphanumeric(vt)) && Ke++ < 32 ? ($e.consume(vt), at) : (Ke = 0, lt(vt));
  }
  function ut(vt) {
    return vt === 62 ? ($e.exit("autolinkProtocol"), $e.enter("autolinkMarker"), $e.consume(vt), $e.exit("autolinkMarker"), $e.exit("autolink"), Ze) : vt === null || vt === 32 || vt === 60 || asciiControl(vt) ? Fe(vt) : ($e.consume(vt), ut);
  }
  function lt(vt) {
    return vt === 64 ? ($e.consume(vt), dt) : asciiAtext(vt) ? ($e.consume(vt), lt) : Fe(vt);
  }
  function dt(vt) {
    return asciiAlphanumeric(vt) ? bt(vt) : Fe(vt);
  }
  function bt(vt) {
    return vt === 46 ? ($e.consume(vt), Ke = 0, dt) : vt === 62 ? ($e.exit("autolinkProtocol").type = "autolinkEmail", $e.enter("autolinkMarker"), $e.consume(vt), $e.exit("autolinkMarker"), $e.exit("autolink"), Ze) : $t(vt);
  }
  function $t(vt) {
    if ((vt === 45 || asciiAlphanumeric(vt)) && Ke++ < 63) {
      const wt = vt === 45 ? $t : bt;
      return $e.consume(vt), wt;
    }
    return Fe(vt);
  }
}
const blankLine = {
  tokenize: tokenizeBlankLine,
  partial: !0
};
function tokenizeBlankLine($e, Ze, Fe) {
  return Ke;
  function Ke(Je) {
    return markdownSpace(Je) ? factorySpace($e, Ve, "linePrefix")(Je) : Ve(Je);
  }
  function Ve(Je) {
    return Je === null || markdownLineEnding(Je) ? Ze(Je) : Fe(Je);
  }
}
const blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit: exit$1
};
function tokenizeBlockQuoteStart($e, Ze, Fe) {
  const Ke = this;
  return Ve;
  function Ve(Qe) {
    if (Qe === 62) {
      const at = Ke.containerState;
      return at.open || ($e.enter("blockQuote", {
        _container: !0
      }), at.open = !0), $e.enter("blockQuotePrefix"), $e.enter("blockQuoteMarker"), $e.consume(Qe), $e.exit("blockQuoteMarker"), Je;
    }
    return Fe(Qe);
  }
  function Je(Qe) {
    return markdownSpace(Qe) ? ($e.enter("blockQuotePrefixWhitespace"), $e.consume(Qe), $e.exit("blockQuotePrefixWhitespace"), $e.exit("blockQuotePrefix"), Ze) : ($e.exit("blockQuotePrefix"), Ze(Qe));
  }
}
function tokenizeBlockQuoteContinuation($e, Ze, Fe) {
  const Ke = this;
  return Ve;
  function Ve(Qe) {
    return markdownSpace(Qe) ? factorySpace(
      $e,
      Je,
      "linePrefix",
      Ke.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(Qe) : Je(Qe);
  }
  function Je(Qe) {
    return $e.attempt(blockQuote, Ze, Fe)(Qe);
  }
}
function exit$1($e) {
  $e.exit("blockQuote");
}
const characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape($e, Ze, Fe) {
  return Ke;
  function Ke(Je) {
    return $e.enter("characterEscape"), $e.enter("escapeMarker"), $e.consume(Je), $e.exit("escapeMarker"), Ve;
  }
  function Ve(Je) {
    return asciiPunctuation(Je) ? ($e.enter("characterEscapeValue"), $e.consume(Je), $e.exit("characterEscapeValue"), $e.exit("characterEscape"), Ze) : Fe(Je);
  }
}
const element = document.createElement("i");
function decodeNamedCharacterReference($e) {
  const Ze = "&" + $e + ";";
  element.innerHTML = Ze;
  const Fe = element.textContent;
  return Fe.charCodeAt(Fe.length - 1) === 59 && $e !== "semi" || Fe === Ze ? !1 : Fe;
}
const characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference($e, Ze, Fe) {
  const Ke = this;
  let Ve = 0, Je, Qe;
  return at;
  function at(bt) {
    return $e.enter("characterReference"), $e.enter("characterReferenceMarker"), $e.consume(bt), $e.exit("characterReferenceMarker"), ut;
  }
  function ut(bt) {
    return bt === 35 ? ($e.enter("characterReferenceMarkerNumeric"), $e.consume(bt), $e.exit("characterReferenceMarkerNumeric"), lt) : ($e.enter("characterReferenceValue"), Je = 31, Qe = asciiAlphanumeric, dt(bt));
  }
  function lt(bt) {
    return bt === 88 || bt === 120 ? ($e.enter("characterReferenceMarkerHexadecimal"), $e.consume(bt), $e.exit("characterReferenceMarkerHexadecimal"), $e.enter("characterReferenceValue"), Je = 6, Qe = asciiHexDigit, dt) : ($e.enter("characterReferenceValue"), Je = 7, Qe = asciiDigit, dt(bt));
  }
  function dt(bt) {
    if (bt === 59 && Ve) {
      const $t = $e.exit("characterReferenceValue");
      return Qe === asciiAlphanumeric && !decodeNamedCharacterReference(Ke.sliceSerialize($t)) ? Fe(bt) : ($e.enter("characterReferenceMarker"), $e.consume(bt), $e.exit("characterReferenceMarker"), $e.exit("characterReference"), Ze);
    }
    return Qe(bt) && Ve++ < Je ? ($e.consume(bt), dt) : Fe(bt);
  }
}
const nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: !0
}, codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: !0
};
function tokenizeCodeFenced($e, Ze, Fe) {
  const Ke = this, Ve = {
    tokenize: Lt,
    partial: !0
  };
  let Je = 0, Qe = 0, at;
  return ut;
  function ut(Ut) {
    return lt(Ut);
  }
  function lt(Ut) {
    const Pt = Ke.events[Ke.events.length - 1];
    return Je = Pt && Pt[1].type === "linePrefix" ? Pt[2].sliceSerialize(Pt[1], !0).length : 0, at = Ut, $e.enter("codeFenced"), $e.enter("codeFencedFence"), $e.enter("codeFencedFenceSequence"), dt(Ut);
  }
  function dt(Ut) {
    return Ut === at ? (Qe++, $e.consume(Ut), dt) : Qe < 3 ? Fe(Ut) : ($e.exit("codeFencedFenceSequence"), markdownSpace(Ut) ? factorySpace($e, bt, "whitespace")(Ut) : bt(Ut));
  }
  function bt(Ut) {
    return Ut === null || markdownLineEnding(Ut) ? ($e.exit("codeFencedFence"), Ke.interrupt ? Ze(Ut) : $e.check(nonLazyContinuation, xt, Zt)(Ut)) : ($e.enter("codeFencedFenceInfo"), $e.enter("chunkString", {
      contentType: "string"
    }), $t(Ut));
  }
  function $t(Ut) {
    return Ut === null || markdownLineEnding(Ut) ? ($e.exit("chunkString"), $e.exit("codeFencedFenceInfo"), bt(Ut)) : markdownSpace(Ut) ? ($e.exit("chunkString"), $e.exit("codeFencedFenceInfo"), factorySpace($e, vt, "whitespace")(Ut)) : Ut === 96 && Ut === at ? Fe(Ut) : ($e.consume(Ut), $t);
  }
  function vt(Ut) {
    return Ut === null || markdownLineEnding(Ut) ? bt(Ut) : ($e.enter("codeFencedFenceMeta"), $e.enter("chunkString", {
      contentType: "string"
    }), wt(Ut));
  }
  function wt(Ut) {
    return Ut === null || markdownLineEnding(Ut) ? ($e.exit("chunkString"), $e.exit("codeFencedFenceMeta"), bt(Ut)) : Ut === 96 && Ut === at ? Fe(Ut) : ($e.consume(Ut), wt);
  }
  function xt(Ut) {
    return $e.attempt(Ve, Zt, Et)(Ut);
  }
  function Et(Ut) {
    return $e.enter("lineEnding"), $e.consume(Ut), $e.exit("lineEnding"), Tt;
  }
  function Tt(Ut) {
    return Je > 0 && markdownSpace(Ut) ? factorySpace(
      $e,
      Rt,
      "linePrefix",
      Je + 1
    )(Ut) : Rt(Ut);
  }
  function Rt(Ut) {
    return Ut === null || markdownLineEnding(Ut) ? $e.check(nonLazyContinuation, xt, Zt)(Ut) : ($e.enter("codeFlowValue"), Ct(Ut));
  }
  function Ct(Ut) {
    return Ut === null || markdownLineEnding(Ut) ? ($e.exit("codeFlowValue"), Rt(Ut)) : ($e.consume(Ut), Ct);
  }
  function Zt(Ut) {
    return $e.exit("codeFenced"), Ze(Ut);
  }
  function Lt(Ut, Pt, Ot) {
    let Ft = 0;
    return gt;
    function gt(ft) {
      return Ut.enter("lineEnding"), Ut.consume(ft), Ut.exit("lineEnding"), We;
    }
    function We(ft) {
      return Ut.enter("codeFencedFence"), markdownSpace(ft) ? factorySpace(
        Ut,
        Xe,
        "linePrefix",
        Ke.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(ft) : Xe(ft);
    }
    function Xe(ft) {
      return ft === at ? (Ut.enter("codeFencedFenceSequence"), rt(ft)) : Ot(ft);
    }
    function rt(ft) {
      return ft === at ? (Ft++, Ut.consume(ft), rt) : Ft >= Qe ? (Ut.exit("codeFencedFenceSequence"), markdownSpace(ft) ? factorySpace(Ut, ot, "whitespace")(ft) : ot(ft)) : Ot(ft);
    }
    function ot(ft) {
      return ft === null || markdownLineEnding(ft) ? (Ut.exit("codeFencedFence"), Pt(ft)) : Ot(ft);
    }
  }
}
function tokenizeNonLazyContinuation($e, Ze, Fe) {
  const Ke = this;
  return Ve;
  function Ve(Qe) {
    return Qe === null ? Fe(Qe) : ($e.enter("lineEnding"), $e.consume(Qe), $e.exit("lineEnding"), Je);
  }
  function Je(Qe) {
    return Ke.parser.lazy[Ke.now().line] ? Fe(Qe) : Ze(Qe);
  }
}
const codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
}, furtherStart = {
  tokenize: tokenizeFurtherStart,
  partial: !0
};
function tokenizeCodeIndented($e, Ze, Fe) {
  const Ke = this;
  return Ve;
  function Ve(lt) {
    return $e.enter("codeIndented"), factorySpace($e, Je, "linePrefix", 4 + 1)(lt);
  }
  function Je(lt) {
    const dt = Ke.events[Ke.events.length - 1];
    return dt && dt[1].type === "linePrefix" && dt[2].sliceSerialize(dt[1], !0).length >= 4 ? Qe(lt) : Fe(lt);
  }
  function Qe(lt) {
    return lt === null ? ut(lt) : markdownLineEnding(lt) ? $e.attempt(furtherStart, Qe, ut)(lt) : ($e.enter("codeFlowValue"), at(lt));
  }
  function at(lt) {
    return lt === null || markdownLineEnding(lt) ? ($e.exit("codeFlowValue"), Qe(lt)) : ($e.consume(lt), at);
  }
  function ut(lt) {
    return $e.exit("codeIndented"), Ze(lt);
  }
}
function tokenizeFurtherStart($e, Ze, Fe) {
  const Ke = this;
  return Ve;
  function Ve(Qe) {
    return Ke.parser.lazy[Ke.now().line] ? Fe(Qe) : markdownLineEnding(Qe) ? ($e.enter("lineEnding"), $e.consume(Qe), $e.exit("lineEnding"), Ve) : factorySpace($e, Je, "linePrefix", 4 + 1)(Qe);
  }
  function Je(Qe) {
    const at = Ke.events[Ke.events.length - 1];
    return at && at[1].type === "linePrefix" && at[2].sliceSerialize(at[1], !0).length >= 4 ? Ze(Qe) : markdownLineEnding(Qe) ? Ve(Qe) : Fe(Qe);
  }
}
const codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText($e) {
  let Ze = $e.length - 4, Fe = 3, Ke, Ve;
  if (($e[Fe][1].type === "lineEnding" || $e[Fe][1].type === "space") && ($e[Ze][1].type === "lineEnding" || $e[Ze][1].type === "space")) {
    for (Ke = Fe; ++Ke < Ze; )
      if ($e[Ke][1].type === "codeTextData") {
        $e[Fe][1].type = "codeTextPadding", $e[Ze][1].type = "codeTextPadding", Fe += 2, Ze -= 2;
        break;
      }
  }
  for (Ke = Fe - 1, Ze++; ++Ke <= Ze; )
    Ve === void 0 ? Ke !== Ze && $e[Ke][1].type !== "lineEnding" && (Ve = Ke) : (Ke === Ze || $e[Ke][1].type === "lineEnding") && ($e[Ve][1].type = "codeTextData", Ke !== Ve + 2 && ($e[Ve][1].end = $e[Ke - 1][1].end, $e.splice(Ve + 2, Ke - Ve - 2), Ze -= Ke - Ve - 2, Ke = Ve + 2), Ve = void 0);
  return $e;
}
function previous($e) {
  return $e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText($e, Ze, Fe) {
  let Ke = 0, Ve, Je;
  return Qe;
  function Qe(bt) {
    return $e.enter("codeText"), $e.enter("codeTextSequence"), at(bt);
  }
  function at(bt) {
    return bt === 96 ? ($e.consume(bt), Ke++, at) : ($e.exit("codeTextSequence"), ut(bt));
  }
  function ut(bt) {
    return bt === null ? Fe(bt) : bt === 32 ? ($e.enter("space"), $e.consume(bt), $e.exit("space"), ut) : bt === 96 ? (Je = $e.enter("codeTextSequence"), Ve = 0, dt(bt)) : markdownLineEnding(bt) ? ($e.enter("lineEnding"), $e.consume(bt), $e.exit("lineEnding"), ut) : ($e.enter("codeTextData"), lt(bt));
  }
  function lt(bt) {
    return bt === null || bt === 32 || bt === 96 || markdownLineEnding(bt) ? ($e.exit("codeTextData"), ut(bt)) : ($e.consume(bt), lt);
  }
  function dt(bt) {
    return bt === 96 ? ($e.consume(bt), Ve++, dt) : Ve === Ke ? ($e.exit("codeTextSequence"), $e.exit("codeText"), Ze(bt)) : (Je.type = "codeTextData", lt(bt));
  }
}
function subtokenize($e) {
  const Ze = {};
  let Fe = -1, Ke, Ve, Je, Qe, at, ut, lt;
  for (; ++Fe < $e.length; ) {
    for (; Fe in Ze; )
      Fe = Ze[Fe];
    if (Ke = $e[Fe], Fe && Ke[1].type === "chunkFlow" && $e[Fe - 1][1].type === "listItemPrefix" && (ut = Ke[1]._tokenizer.events, Je = 0, Je < ut.length && ut[Je][1].type === "lineEndingBlank" && (Je += 2), Je < ut.length && ut[Je][1].type === "content"))
      for (; ++Je < ut.length && ut[Je][1].type !== "content"; )
        ut[Je][1].type === "chunkText" && (ut[Je][1]._isInFirstContentOfListItem = !0, Je++);
    if (Ke[0] === "enter")
      Ke[1].contentType && (Object.assign(Ze, subcontent($e, Fe)), Fe = Ze[Fe], lt = !0);
    else if (Ke[1]._container) {
      for (Je = Fe, Ve = void 0; Je-- && (Qe = $e[Je], Qe[1].type === "lineEnding" || Qe[1].type === "lineEndingBlank"); )
        Qe[0] === "enter" && (Ve && ($e[Ve][1].type = "lineEndingBlank"), Qe[1].type = "lineEnding", Ve = Je);
      Ve && (Ke[1].end = Object.assign({}, $e[Ve][1].start), at = $e.slice(Ve, Fe), at.unshift(Ke), splice($e, Ve, Fe - Ve + 1, at));
    }
  }
  return !lt;
}
function subcontent($e, Ze) {
  const Fe = $e[Ze][1], Ke = $e[Ze][2];
  let Ve = Ze - 1;
  const Je = [], Qe = Fe._tokenizer || Ke.parser[Fe.contentType](Fe.start), at = Qe.events, ut = [], lt = {};
  let dt, bt, $t = -1, vt = Fe, wt = 0, xt = 0;
  const Et = [xt];
  for (; vt; ) {
    for (; $e[++Ve][1] !== vt; )
      ;
    Je.push(Ve), vt._tokenizer || (dt = Ke.sliceStream(vt), vt.next || dt.push(null), bt && Qe.defineSkip(vt.start), vt._isInFirstContentOfListItem && (Qe._gfmTasklistFirstContentOfListItem = !0), Qe.write(dt), vt._isInFirstContentOfListItem && (Qe._gfmTasklistFirstContentOfListItem = void 0)), bt = vt, vt = vt.next;
  }
  for (vt = Fe; ++$t < at.length; )
    // Find a void token that includes a break.
    at[$t][0] === "exit" && at[$t - 1][0] === "enter" && at[$t][1].type === at[$t - 1][1].type && at[$t][1].start.line !== at[$t][1].end.line && (xt = $t + 1, Et.push(xt), vt._tokenizer = void 0, vt.previous = void 0, vt = vt.next);
  for (Qe.events = [], vt ? (vt._tokenizer = void 0, vt.previous = void 0) : Et.pop(), $t = Et.length; $t--; ) {
    const Tt = at.slice(Et[$t], Et[$t + 1]), Rt = Je.pop();
    ut.unshift([Rt, Rt + Tt.length - 1]), splice($e, Rt, 2, Tt);
  }
  for ($t = -1; ++$t < ut.length; )
    lt[wt + ut[$t][0]] = wt + ut[$t][1], wt += ut[$t][1] - ut[$t][0] - 1;
  return lt;
}
const content = {
  tokenize: tokenizeContent,
  resolve: resolveContent
}, continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: !0
};
function resolveContent($e) {
  return subtokenize($e), $e;
}
function tokenizeContent($e, Ze) {
  let Fe;
  return Ke;
  function Ke(at) {
    return $e.enter("content"), Fe = $e.enter("chunkContent", {
      contentType: "content"
    }), Ve(at);
  }
  function Ve(at) {
    return at === null ? Je(at) : markdownLineEnding(at) ? $e.check(
      continuationConstruct,
      Qe,
      Je
    )(at) : ($e.consume(at), Ve);
  }
  function Je(at) {
    return $e.exit("chunkContent"), $e.exit("content"), Ze(at);
  }
  function Qe(at) {
    return $e.consume(at), $e.exit("chunkContent"), Fe.next = $e.enter("chunkContent", {
      contentType: "content",
      previous: Fe
    }), Fe = Fe.next, Ve;
  }
}
function tokenizeContinuation($e, Ze, Fe) {
  const Ke = this;
  return Ve;
  function Ve(Qe) {
    return $e.exit("chunkContent"), $e.enter("lineEnding"), $e.consume(Qe), $e.exit("lineEnding"), factorySpace($e, Je, "linePrefix");
  }
  function Je(Qe) {
    if (Qe === null || markdownLineEnding(Qe))
      return Fe(Qe);
    const at = Ke.events[Ke.events.length - 1];
    return !Ke.parser.constructs.disable.null.includes("codeIndented") && at && at[1].type === "linePrefix" && at[2].sliceSerialize(at[1], !0).length >= 4 ? Ze(Qe) : $e.interrupt(Ke.parser.constructs.flow, Fe, Ze)(Qe);
  }
}
function factoryDestination($e, Ze, Fe, Ke, Ve, Je, Qe, at, ut) {
  const lt = ut || Number.POSITIVE_INFINITY;
  let dt = 0;
  return bt;
  function bt(Tt) {
    return Tt === 60 ? ($e.enter(Ke), $e.enter(Ve), $e.enter(Je), $e.consume(Tt), $e.exit(Je), $t) : Tt === null || Tt === 32 || Tt === 41 || asciiControl(Tt) ? Fe(Tt) : ($e.enter(Ke), $e.enter(Qe), $e.enter(at), $e.enter("chunkString", {
      contentType: "string"
    }), xt(Tt));
  }
  function $t(Tt) {
    return Tt === 62 ? ($e.enter(Je), $e.consume(Tt), $e.exit(Je), $e.exit(Ve), $e.exit(Ke), Ze) : ($e.enter(at), $e.enter("chunkString", {
      contentType: "string"
    }), vt(Tt));
  }
  function vt(Tt) {
    return Tt === 62 ? ($e.exit("chunkString"), $e.exit(at), $t(Tt)) : Tt === null || Tt === 60 || markdownLineEnding(Tt) ? Fe(Tt) : ($e.consume(Tt), Tt === 92 ? wt : vt);
  }
  function wt(Tt) {
    return Tt === 60 || Tt === 62 || Tt === 92 ? ($e.consume(Tt), vt) : vt(Tt);
  }
  function xt(Tt) {
    return !dt && (Tt === null || Tt === 41 || markdownLineEndingOrSpace(Tt)) ? ($e.exit("chunkString"), $e.exit(at), $e.exit(Qe), $e.exit(Ke), Ze(Tt)) : dt < lt && Tt === 40 ? ($e.consume(Tt), dt++, xt) : Tt === 41 ? ($e.consume(Tt), dt--, xt) : Tt === null || Tt === 32 || Tt === 40 || asciiControl(Tt) ? Fe(Tt) : ($e.consume(Tt), Tt === 92 ? Et : xt);
  }
  function Et(Tt) {
    return Tt === 40 || Tt === 41 || Tt === 92 ? ($e.consume(Tt), xt) : xt(Tt);
  }
}
function factoryLabel($e, Ze, Fe, Ke, Ve, Je) {
  const Qe = this;
  let at = 0, ut;
  return lt;
  function lt(vt) {
    return $e.enter(Ke), $e.enter(Ve), $e.consume(vt), $e.exit(Ve), $e.enter(Je), dt;
  }
  function dt(vt) {
    return at > 999 || vt === null || vt === 91 || vt === 93 && !ut || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    vt === 94 && !at && "_hiddenFootnoteSupport" in Qe.parser.constructs ? Fe(vt) : vt === 93 ? ($e.exit(Je), $e.enter(Ve), $e.consume(vt), $e.exit(Ve), $e.exit(Ke), Ze) : markdownLineEnding(vt) ? ($e.enter("lineEnding"), $e.consume(vt), $e.exit("lineEnding"), dt) : ($e.enter("chunkString", {
      contentType: "string"
    }), bt(vt));
  }
  function bt(vt) {
    return vt === null || vt === 91 || vt === 93 || markdownLineEnding(vt) || at++ > 999 ? ($e.exit("chunkString"), dt(vt)) : ($e.consume(vt), ut || (ut = !markdownSpace(vt)), vt === 92 ? $t : bt);
  }
  function $t(vt) {
    return vt === 91 || vt === 92 || vt === 93 ? ($e.consume(vt), at++, bt) : bt(vt);
  }
}
function factoryTitle($e, Ze, Fe, Ke, Ve, Je) {
  let Qe;
  return at;
  function at($t) {
    return $t === 34 || $t === 39 || $t === 40 ? ($e.enter(Ke), $e.enter(Ve), $e.consume($t), $e.exit(Ve), Qe = $t === 40 ? 41 : $t, ut) : Fe($t);
  }
  function ut($t) {
    return $t === Qe ? ($e.enter(Ve), $e.consume($t), $e.exit(Ve), $e.exit(Ke), Ze) : ($e.enter(Je), lt($t));
  }
  function lt($t) {
    return $t === Qe ? ($e.exit(Je), ut(Qe)) : $t === null ? Fe($t) : markdownLineEnding($t) ? ($e.enter("lineEnding"), $e.consume($t), $e.exit("lineEnding"), factorySpace($e, lt, "linePrefix")) : ($e.enter("chunkString", {
      contentType: "string"
    }), dt($t));
  }
  function dt($t) {
    return $t === Qe || $t === null || markdownLineEnding($t) ? ($e.exit("chunkString"), lt($t)) : ($e.consume($t), $t === 92 ? bt : dt);
  }
  function bt($t) {
    return $t === Qe || $t === 92 ? ($e.consume($t), dt) : dt($t);
  }
}
function factoryWhitespace($e, Ze) {
  let Fe;
  return Ke;
  function Ke(Ve) {
    return markdownLineEnding(Ve) ? ($e.enter("lineEnding"), $e.consume(Ve), $e.exit("lineEnding"), Fe = !0, Ke) : markdownSpace(Ve) ? factorySpace(
      $e,
      Ke,
      Fe ? "linePrefix" : "lineSuffix"
    )(Ve) : Ze(Ve);
  }
}
function normalizeIdentifier($e) {
  return $e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const definition$r = {
  name: "definition",
  tokenize: tokenizeDefinition
}, titleBefore = {
  tokenize: tokenizeTitleBefore,
  partial: !0
};
function tokenizeDefinition($e, Ze, Fe) {
  const Ke = this;
  let Ve;
  return Je;
  function Je(vt) {
    return $e.enter("definition"), Qe(vt);
  }
  function Qe(vt) {
    return factoryLabel.call(
      Ke,
      $e,
      at,
      // Note: we don’t need to reset the way `markdown-rs` does.
      Fe,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(vt);
  }
  function at(vt) {
    return Ve = normalizeIdentifier(
      Ke.sliceSerialize(Ke.events[Ke.events.length - 1][1]).slice(1, -1)
    ), vt === 58 ? ($e.enter("definitionMarker"), $e.consume(vt), $e.exit("definitionMarker"), ut) : Fe(vt);
  }
  function ut(vt) {
    return markdownLineEndingOrSpace(vt) ? factoryWhitespace($e, lt)(vt) : lt(vt);
  }
  function lt(vt) {
    return factoryDestination(
      $e,
      dt,
      // Note: we don’t need to reset the way `markdown-rs` does.
      Fe,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(vt);
  }
  function dt(vt) {
    return $e.attempt(titleBefore, bt, bt)(vt);
  }
  function bt(vt) {
    return markdownSpace(vt) ? factorySpace($e, $t, "whitespace")(vt) : $t(vt);
  }
  function $t(vt) {
    return vt === null || markdownLineEnding(vt) ? ($e.exit("definition"), Ke.parser.defined.push(Ve), Ze(vt)) : Fe(vt);
  }
}
function tokenizeTitleBefore($e, Ze, Fe) {
  return Ke;
  function Ke(at) {
    return markdownLineEndingOrSpace(at) ? factoryWhitespace($e, Ve)(at) : Fe(at);
  }
  function Ve(at) {
    return factoryTitle(
      $e,
      Je,
      Fe,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(at);
  }
  function Je(at) {
    return markdownSpace(at) ? factorySpace($e, Qe, "whitespace")(at) : Qe(at);
  }
  function Qe(at) {
    return at === null || markdownLineEnding(at) ? Ze(at) : Fe(at);
  }
}
const hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape($e, Ze, Fe) {
  return Ke;
  function Ke(Je) {
    return $e.enter("hardBreakEscape"), $e.consume(Je), Ve;
  }
  function Ve(Je) {
    return markdownLineEnding(Je) ? ($e.exit("hardBreakEscape"), Ze(Je)) : Fe(Je);
  }
}
const headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx($e, Ze) {
  let Fe = $e.length - 2, Ke = 3, Ve, Je;
  return $e[Ke][1].type === "whitespace" && (Ke += 2), Fe - 2 > Ke && $e[Fe][1].type === "whitespace" && (Fe -= 2), $e[Fe][1].type === "atxHeadingSequence" && (Ke === Fe - 1 || Fe - 4 > Ke && $e[Fe - 2][1].type === "whitespace") && (Fe -= Ke + 1 === Fe ? 2 : 4), Fe > Ke && (Ve = {
    type: "atxHeadingText",
    start: $e[Ke][1].start,
    end: $e[Fe][1].end
  }, Je = {
    type: "chunkText",
    start: $e[Ke][1].start,
    end: $e[Fe][1].end,
    contentType: "text"
  }, splice($e, Ke, Fe - Ke + 1, [
    ["enter", Ve, Ze],
    ["enter", Je, Ze],
    ["exit", Je, Ze],
    ["exit", Ve, Ze]
  ])), $e;
}
function tokenizeHeadingAtx($e, Ze, Fe) {
  let Ke = 0;
  return Ve;
  function Ve(dt) {
    return $e.enter("atxHeading"), Je(dt);
  }
  function Je(dt) {
    return $e.enter("atxHeadingSequence"), Qe(dt);
  }
  function Qe(dt) {
    return dt === 35 && Ke++ < 6 ? ($e.consume(dt), Qe) : dt === null || markdownLineEndingOrSpace(dt) ? ($e.exit("atxHeadingSequence"), at(dt)) : Fe(dt);
  }
  function at(dt) {
    return dt === 35 ? ($e.enter("atxHeadingSequence"), ut(dt)) : dt === null || markdownLineEnding(dt) ? ($e.exit("atxHeading"), Ze(dt)) : markdownSpace(dt) ? factorySpace($e, at, "whitespace")(dt) : ($e.enter("atxHeadingText"), lt(dt));
  }
  function ut(dt) {
    return dt === 35 ? ($e.consume(dt), ut) : ($e.exit("atxHeadingSequence"), at(dt));
  }
  function lt(dt) {
    return dt === null || dt === 35 || markdownLineEndingOrSpace(dt) ? ($e.exit("atxHeadingText"), at(dt)) : ($e.consume(dt), lt);
  }
}
const htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], htmlRawNames = ["pre", "script", "style", "textarea"], htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: !0
}, blankLineBefore = {
  tokenize: tokenizeBlankLineBefore,
  partial: !0
}, nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: !0
};
function resolveToHtmlFlow($e) {
  let Ze = $e.length;
  for (; Ze-- && !($e[Ze][0] === "enter" && $e[Ze][1].type === "htmlFlow"); )
    ;
  return Ze > 1 && $e[Ze - 2][1].type === "linePrefix" && ($e[Ze][1].start = $e[Ze - 2][1].start, $e[Ze + 1][1].start = $e[Ze - 2][1].start, $e.splice(Ze - 2, 2)), $e;
}
function tokenizeHtmlFlow($e, Ze, Fe) {
  const Ke = this;
  let Ve, Je, Qe, at, ut;
  return lt;
  function lt(At) {
    return dt(At);
  }
  function dt(At) {
    return $e.enter("htmlFlow"), $e.enter("htmlFlowData"), $e.consume(At), bt;
  }
  function bt(At) {
    return At === 33 ? ($e.consume(At), $t) : At === 47 ? ($e.consume(At), Je = !0, xt) : At === 63 ? ($e.consume(At), Ve = 3, Ke.interrupt ? Ze : ct) : asciiAlpha(At) ? ($e.consume(At), Qe = String.fromCharCode(At), Et) : Fe(At);
  }
  function $t(At) {
    return At === 45 ? ($e.consume(At), Ve = 2, vt) : At === 91 ? ($e.consume(At), Ve = 5, at = 0, wt) : asciiAlpha(At) ? ($e.consume(At), Ve = 4, Ke.interrupt ? Ze : ct) : Fe(At);
  }
  function vt(At) {
    return At === 45 ? ($e.consume(At), Ke.interrupt ? Ze : ct) : Fe(At);
  }
  function wt(At) {
    const Nt = "CDATA[";
    return At === Nt.charCodeAt(at++) ? ($e.consume(At), at === Nt.length ? Ke.interrupt ? Ze : Xe : wt) : Fe(At);
  }
  function xt(At) {
    return asciiAlpha(At) ? ($e.consume(At), Qe = String.fromCharCode(At), Et) : Fe(At);
  }
  function Et(At) {
    if (At === null || At === 47 || At === 62 || markdownLineEndingOrSpace(At)) {
      const Nt = At === 47, qt = Qe.toLowerCase();
      return !Nt && !Je && htmlRawNames.includes(qt) ? (Ve = 1, Ke.interrupt ? Ze(At) : Xe(At)) : htmlBlockNames.includes(Qe.toLowerCase()) ? (Ve = 6, Nt ? ($e.consume(At), Tt) : Ke.interrupt ? Ze(At) : Xe(At)) : (Ve = 7, Ke.interrupt && !Ke.parser.lazy[Ke.now().line] ? Fe(At) : Je ? Rt(At) : Ct(At));
    }
    return At === 45 || asciiAlphanumeric(At) ? ($e.consume(At), Qe += String.fromCharCode(At), Et) : Fe(At);
  }
  function Tt(At) {
    return At === 62 ? ($e.consume(At), Ke.interrupt ? Ze : Xe) : Fe(At);
  }
  function Rt(At) {
    return markdownSpace(At) ? ($e.consume(At), Rt) : gt(At);
  }
  function Ct(At) {
    return At === 47 ? ($e.consume(At), gt) : At === 58 || At === 95 || asciiAlpha(At) ? ($e.consume(At), Zt) : markdownSpace(At) ? ($e.consume(At), Ct) : gt(At);
  }
  function Zt(At) {
    return At === 45 || At === 46 || At === 58 || At === 95 || asciiAlphanumeric(At) ? ($e.consume(At), Zt) : Lt(At);
  }
  function Lt(At) {
    return At === 61 ? ($e.consume(At), Ut) : markdownSpace(At) ? ($e.consume(At), Lt) : Ct(At);
  }
  function Ut(At) {
    return At === null || At === 60 || At === 61 || At === 62 || At === 96 ? Fe(At) : At === 34 || At === 39 ? ($e.consume(At), ut = At, Pt) : markdownSpace(At) ? ($e.consume(At), Ut) : Ot(At);
  }
  function Pt(At) {
    return At === ut ? ($e.consume(At), ut = null, Ft) : At === null || markdownLineEnding(At) ? Fe(At) : ($e.consume(At), Pt);
  }
  function Ot(At) {
    return At === null || At === 34 || At === 39 || At === 47 || At === 60 || At === 61 || At === 62 || At === 96 || markdownLineEndingOrSpace(At) ? Lt(At) : ($e.consume(At), Ot);
  }
  function Ft(At) {
    return At === 47 || At === 62 || markdownSpace(At) ? Ct(At) : Fe(At);
  }
  function gt(At) {
    return At === 62 ? ($e.consume(At), We) : Fe(At);
  }
  function We(At) {
    return At === null || markdownLineEnding(At) ? Xe(At) : markdownSpace(At) ? ($e.consume(At), We) : Fe(At);
  }
  function Xe(At) {
    return At === 45 && Ve === 2 ? ($e.consume(At), mt) : At === 60 && Ve === 1 ? ($e.consume(At), yt) : At === 62 && Ve === 4 ? ($e.consume(At), Mt) : At === 63 && Ve === 3 ? ($e.consume(At), ct) : At === 93 && Ve === 5 ? ($e.consume(At), Ge) : markdownLineEnding(At) && (Ve === 6 || Ve === 7) ? ($e.exit("htmlFlowData"), $e.check(
      blankLineBefore,
      St,
      rt
    )(At)) : At === null || markdownLineEnding(At) ? ($e.exit("htmlFlowData"), rt(At)) : ($e.consume(At), Xe);
  }
  function rt(At) {
    return $e.check(
      nonLazyContinuationStart,
      ot,
      St
    )(At);
  }
  function ot(At) {
    return $e.enter("lineEnding"), $e.consume(At), $e.exit("lineEnding"), ft;
  }
  function ft(At) {
    return At === null || markdownLineEnding(At) ? rt(At) : ($e.enter("htmlFlowData"), Xe(At));
  }
  function mt(At) {
    return At === 45 ? ($e.consume(At), ct) : Xe(At);
  }
  function yt(At) {
    return At === 47 ? ($e.consume(At), Qe = "", pt) : Xe(At);
  }
  function pt(At) {
    if (At === 62) {
      const Nt = Qe.toLowerCase();
      return htmlRawNames.includes(Nt) ? ($e.consume(At), Mt) : Xe(At);
    }
    return asciiAlpha(At) && Qe.length < 8 ? ($e.consume(At), Qe += String.fromCharCode(At), pt) : Xe(At);
  }
  function Ge(At) {
    return At === 93 ? ($e.consume(At), ct) : Xe(At);
  }
  function ct(At) {
    return At === 62 ? ($e.consume(At), Mt) : At === 45 && Ve === 2 ? ($e.consume(At), ct) : Xe(At);
  }
  function Mt(At) {
    return At === null || markdownLineEnding(At) ? ($e.exit("htmlFlowData"), St(At)) : ($e.consume(At), Mt);
  }
  function St(At) {
    return $e.exit("htmlFlow"), Ze(At);
  }
}
function tokenizeNonLazyContinuationStart($e, Ze, Fe) {
  const Ke = this;
  return Ve;
  function Ve(Qe) {
    return markdownLineEnding(Qe) ? ($e.enter("lineEnding"), $e.consume(Qe), $e.exit("lineEnding"), Je) : Fe(Qe);
  }
  function Je(Qe) {
    return Ke.parser.lazy[Ke.now().line] ? Fe(Qe) : Ze(Qe);
  }
}
function tokenizeBlankLineBefore($e, Ze, Fe) {
  return Ke;
  function Ke(Ve) {
    return $e.enter("lineEnding"), $e.consume(Ve), $e.exit("lineEnding"), $e.attempt(blankLine, Ze, Fe);
  }
}
const htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText($e, Ze, Fe) {
  const Ke = this;
  let Ve, Je, Qe;
  return at;
  function at(ct) {
    return $e.enter("htmlText"), $e.enter("htmlTextData"), $e.consume(ct), ut;
  }
  function ut(ct) {
    return ct === 33 ? ($e.consume(ct), lt) : ct === 47 ? ($e.consume(ct), Lt) : ct === 63 ? ($e.consume(ct), Ct) : asciiAlpha(ct) ? ($e.consume(ct), Ot) : Fe(ct);
  }
  function lt(ct) {
    return ct === 45 ? ($e.consume(ct), dt) : ct === 91 ? ($e.consume(ct), Je = 0, wt) : asciiAlpha(ct) ? ($e.consume(ct), Rt) : Fe(ct);
  }
  function dt(ct) {
    return ct === 45 ? ($e.consume(ct), vt) : Fe(ct);
  }
  function bt(ct) {
    return ct === null ? Fe(ct) : ct === 45 ? ($e.consume(ct), $t) : markdownLineEnding(ct) ? (Qe = bt, yt(ct)) : ($e.consume(ct), bt);
  }
  function $t(ct) {
    return ct === 45 ? ($e.consume(ct), vt) : bt(ct);
  }
  function vt(ct) {
    return ct === 62 ? mt(ct) : ct === 45 ? $t(ct) : bt(ct);
  }
  function wt(ct) {
    const Mt = "CDATA[";
    return ct === Mt.charCodeAt(Je++) ? ($e.consume(ct), Je === Mt.length ? xt : wt) : Fe(ct);
  }
  function xt(ct) {
    return ct === null ? Fe(ct) : ct === 93 ? ($e.consume(ct), Et) : markdownLineEnding(ct) ? (Qe = xt, yt(ct)) : ($e.consume(ct), xt);
  }
  function Et(ct) {
    return ct === 93 ? ($e.consume(ct), Tt) : xt(ct);
  }
  function Tt(ct) {
    return ct === 62 ? mt(ct) : ct === 93 ? ($e.consume(ct), Tt) : xt(ct);
  }
  function Rt(ct) {
    return ct === null || ct === 62 ? mt(ct) : markdownLineEnding(ct) ? (Qe = Rt, yt(ct)) : ($e.consume(ct), Rt);
  }
  function Ct(ct) {
    return ct === null ? Fe(ct) : ct === 63 ? ($e.consume(ct), Zt) : markdownLineEnding(ct) ? (Qe = Ct, yt(ct)) : ($e.consume(ct), Ct);
  }
  function Zt(ct) {
    return ct === 62 ? mt(ct) : Ct(ct);
  }
  function Lt(ct) {
    return asciiAlpha(ct) ? ($e.consume(ct), Ut) : Fe(ct);
  }
  function Ut(ct) {
    return ct === 45 || asciiAlphanumeric(ct) ? ($e.consume(ct), Ut) : Pt(ct);
  }
  function Pt(ct) {
    return markdownLineEnding(ct) ? (Qe = Pt, yt(ct)) : markdownSpace(ct) ? ($e.consume(ct), Pt) : mt(ct);
  }
  function Ot(ct) {
    return ct === 45 || asciiAlphanumeric(ct) ? ($e.consume(ct), Ot) : ct === 47 || ct === 62 || markdownLineEndingOrSpace(ct) ? Ft(ct) : Fe(ct);
  }
  function Ft(ct) {
    return ct === 47 ? ($e.consume(ct), mt) : ct === 58 || ct === 95 || asciiAlpha(ct) ? ($e.consume(ct), gt) : markdownLineEnding(ct) ? (Qe = Ft, yt(ct)) : markdownSpace(ct) ? ($e.consume(ct), Ft) : mt(ct);
  }
  function gt(ct) {
    return ct === 45 || ct === 46 || ct === 58 || ct === 95 || asciiAlphanumeric(ct) ? ($e.consume(ct), gt) : We(ct);
  }
  function We(ct) {
    return ct === 61 ? ($e.consume(ct), Xe) : markdownLineEnding(ct) ? (Qe = We, yt(ct)) : markdownSpace(ct) ? ($e.consume(ct), We) : Ft(ct);
  }
  function Xe(ct) {
    return ct === null || ct === 60 || ct === 61 || ct === 62 || ct === 96 ? Fe(ct) : ct === 34 || ct === 39 ? ($e.consume(ct), Ve = ct, rt) : markdownLineEnding(ct) ? (Qe = Xe, yt(ct)) : markdownSpace(ct) ? ($e.consume(ct), Xe) : ($e.consume(ct), ot);
  }
  function rt(ct) {
    return ct === Ve ? ($e.consume(ct), Ve = void 0, ft) : ct === null ? Fe(ct) : markdownLineEnding(ct) ? (Qe = rt, yt(ct)) : ($e.consume(ct), rt);
  }
  function ot(ct) {
    return ct === null || ct === 34 || ct === 39 || ct === 60 || ct === 61 || ct === 96 ? Fe(ct) : ct === 47 || ct === 62 || markdownLineEndingOrSpace(ct) ? Ft(ct) : ($e.consume(ct), ot);
  }
  function ft(ct) {
    return ct === 47 || ct === 62 || markdownLineEndingOrSpace(ct) ? Ft(ct) : Fe(ct);
  }
  function mt(ct) {
    return ct === 62 ? ($e.consume(ct), $e.exit("htmlTextData"), $e.exit("htmlText"), Ze) : Fe(ct);
  }
  function yt(ct) {
    return $e.exit("htmlTextData"), $e.enter("lineEnding"), $e.consume(ct), $e.exit("lineEnding"), pt;
  }
  function pt(ct) {
    return markdownSpace(ct) ? factorySpace(
      $e,
      Ge,
      "linePrefix",
      Ke.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(ct) : Ge(ct);
  }
  function Ge(ct) {
    return $e.enter("htmlTextData"), Qe(ct);
  }
}
const labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
}, resourceConstruct = {
  tokenize: tokenizeResource
}, referenceFullConstruct = {
  tokenize: tokenizeReferenceFull
}, referenceCollapsedConstruct = {
  tokenize: tokenizeReferenceCollapsed
};
function resolveAllLabelEnd($e) {
  let Ze = -1;
  for (; ++Ze < $e.length; ) {
    const Fe = $e[Ze][1];
    (Fe.type === "labelImage" || Fe.type === "labelLink" || Fe.type === "labelEnd") && ($e.splice(Ze + 1, Fe.type === "labelImage" ? 4 : 2), Fe.type = "data", Ze++);
  }
  return $e;
}
function resolveToLabelEnd($e, Ze) {
  let Fe = $e.length, Ke = 0, Ve, Je, Qe, at;
  for (; Fe--; )
    if (Ve = $e[Fe][1], Je) {
      if (Ve.type === "link" || Ve.type === "labelLink" && Ve._inactive)
        break;
      $e[Fe][0] === "enter" && Ve.type === "labelLink" && (Ve._inactive = !0);
    } else if (Qe) {
      if ($e[Fe][0] === "enter" && (Ve.type === "labelImage" || Ve.type === "labelLink") && !Ve._balanced && (Je = Fe, Ve.type !== "labelLink")) {
        Ke = 2;
        break;
      }
    } else
      Ve.type === "labelEnd" && (Qe = Fe);
  const ut = {
    type: $e[Je][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, $e[Je][1].start),
    end: Object.assign({}, $e[$e.length - 1][1].end)
  }, lt = {
    type: "label",
    start: Object.assign({}, $e[Je][1].start),
    end: Object.assign({}, $e[Qe][1].end)
  }, dt = {
    type: "labelText",
    start: Object.assign({}, $e[Je + Ke + 2][1].end),
    end: Object.assign({}, $e[Qe - 2][1].start)
  };
  return at = [
    ["enter", ut, Ze],
    ["enter", lt, Ze]
  ], at = push(at, $e.slice(Je + 1, Je + Ke + 3)), at = push(at, [["enter", dt, Ze]]), at = push(
    at,
    resolveAll(
      Ze.parser.constructs.insideSpan.null,
      $e.slice(Je + Ke + 4, Qe - 3),
      Ze
    )
  ), at = push(at, [
    ["exit", dt, Ze],
    $e[Qe - 2],
    $e[Qe - 1],
    ["exit", lt, Ze]
  ]), at = push(at, $e.slice(Qe + 1)), at = push(at, [["exit", ut, Ze]]), splice($e, Je, $e.length, at), $e;
}
function tokenizeLabelEnd($e, Ze, Fe) {
  const Ke = this;
  let Ve = Ke.events.length, Je, Qe;
  for (; Ve--; )
    if ((Ke.events[Ve][1].type === "labelImage" || Ke.events[Ve][1].type === "labelLink") && !Ke.events[Ve][1]._balanced) {
      Je = Ke.events[Ve][1];
      break;
    }
  return at;
  function at($t) {
    return Je ? Je._inactive ? bt($t) : (Qe = Ke.parser.defined.includes(
      normalizeIdentifier(
        Ke.sliceSerialize({
          start: Je.end,
          end: Ke.now()
        })
      )
    ), $e.enter("labelEnd"), $e.enter("labelMarker"), $e.consume($t), $e.exit("labelMarker"), $e.exit("labelEnd"), ut) : Fe($t);
  }
  function ut($t) {
    return $t === 40 ? $e.attempt(
      resourceConstruct,
      dt,
      Qe ? dt : bt
    )($t) : $t === 91 ? $e.attempt(
      referenceFullConstruct,
      dt,
      Qe ? lt : bt
    )($t) : Qe ? dt($t) : bt($t);
  }
  function lt($t) {
    return $e.attempt(
      referenceCollapsedConstruct,
      dt,
      bt
    )($t);
  }
  function dt($t) {
    return Ze($t);
  }
  function bt($t) {
    return Je._balanced = !0, Fe($t);
  }
}
function tokenizeResource($e, Ze, Fe) {
  return Ke;
  function Ke(bt) {
    return $e.enter("resource"), $e.enter("resourceMarker"), $e.consume(bt), $e.exit("resourceMarker"), Ve;
  }
  function Ve(bt) {
    return markdownLineEndingOrSpace(bt) ? factoryWhitespace($e, Je)(bt) : Je(bt);
  }
  function Je(bt) {
    return bt === 41 ? dt(bt) : factoryDestination(
      $e,
      Qe,
      at,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(bt);
  }
  function Qe(bt) {
    return markdownLineEndingOrSpace(bt) ? factoryWhitespace($e, ut)(bt) : dt(bt);
  }
  function at(bt) {
    return Fe(bt);
  }
  function ut(bt) {
    return bt === 34 || bt === 39 || bt === 40 ? factoryTitle(
      $e,
      lt,
      Fe,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(bt) : dt(bt);
  }
  function lt(bt) {
    return markdownLineEndingOrSpace(bt) ? factoryWhitespace($e, dt)(bt) : dt(bt);
  }
  function dt(bt) {
    return bt === 41 ? ($e.enter("resourceMarker"), $e.consume(bt), $e.exit("resourceMarker"), $e.exit("resource"), Ze) : Fe(bt);
  }
}
function tokenizeReferenceFull($e, Ze, Fe) {
  const Ke = this;
  return Ve;
  function Ve(at) {
    return factoryLabel.call(
      Ke,
      $e,
      Je,
      Qe,
      "reference",
      "referenceMarker",
      "referenceString"
    )(at);
  }
  function Je(at) {
    return Ke.parser.defined.includes(
      normalizeIdentifier(
        Ke.sliceSerialize(Ke.events[Ke.events.length - 1][1]).slice(1, -1)
      )
    ) ? Ze(at) : Fe(at);
  }
  function Qe(at) {
    return Fe(at);
  }
}
function tokenizeReferenceCollapsed($e, Ze, Fe) {
  return Ke;
  function Ke(Je) {
    return $e.enter("reference"), $e.enter("referenceMarker"), $e.consume(Je), $e.exit("referenceMarker"), Ve;
  }
  function Ve(Je) {
    return Je === 93 ? ($e.enter("referenceMarker"), $e.consume(Je), $e.exit("referenceMarker"), $e.exit("reference"), Ze) : Fe(Je);
  }
}
const labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage($e, Ze, Fe) {
  const Ke = this;
  return Ve;
  function Ve(at) {
    return $e.enter("labelImage"), $e.enter("labelImageMarker"), $e.consume(at), $e.exit("labelImageMarker"), Je;
  }
  function Je(at) {
    return at === 91 ? ($e.enter("labelMarker"), $e.consume(at), $e.exit("labelMarker"), $e.exit("labelImage"), Qe) : Fe(at);
  }
  function Qe(at) {
    return at === 94 && "_hiddenFootnoteSupport" in Ke.parser.constructs ? Fe(at) : Ze(at);
  }
}
const labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink($e, Ze, Fe) {
  const Ke = this;
  return Ve;
  function Ve(Qe) {
    return $e.enter("labelLink"), $e.enter("labelMarker"), $e.consume(Qe), $e.exit("labelMarker"), $e.exit("labelLink"), Je;
  }
  function Je(Qe) {
    return Qe === 94 && "_hiddenFootnoteSupport" in Ke.parser.constructs ? Fe(Qe) : Ze(Qe);
  }
}
const lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding($e, Ze) {
  return Fe;
  function Fe(Ke) {
    return $e.enter("lineEnding"), $e.consume(Ke), $e.exit("lineEnding"), factorySpace($e, Ze, "linePrefix");
  }
}
const thematicBreak$1 = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak($e, Ze, Fe) {
  let Ke = 0, Ve;
  return Je;
  function Je(lt) {
    return $e.enter("thematicBreak"), Qe(lt);
  }
  function Qe(lt) {
    return Ve = lt, at(lt);
  }
  function at(lt) {
    return lt === Ve ? ($e.enter("thematicBreakSequence"), ut(lt)) : Ke >= 3 && (lt === null || markdownLineEnding(lt)) ? ($e.exit("thematicBreak"), Ze(lt)) : Fe(lt);
  }
  function ut(lt) {
    return lt === Ve ? ($e.consume(lt), Ke++, ut) : ($e.exit("thematicBreakSequence"), markdownSpace(lt) ? factorySpace($e, at, "whitespace")(lt) : at(lt));
  }
}
const list$1 = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
}, listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: !0
}, indentConstruct = {
  tokenize: tokenizeIndent,
  partial: !0
};
function tokenizeListStart($e, Ze, Fe) {
  const Ke = this, Ve = Ke.events[Ke.events.length - 1];
  let Je = Ve && Ve[1].type === "linePrefix" ? Ve[2].sliceSerialize(Ve[1], !0).length : 0, Qe = 0;
  return at;
  function at(vt) {
    const wt = Ke.containerState.type || (vt === 42 || vt === 43 || vt === 45 ? "listUnordered" : "listOrdered");
    if (wt === "listUnordered" ? !Ke.containerState.marker || vt === Ke.containerState.marker : asciiDigit(vt)) {
      if (Ke.containerState.type || (Ke.containerState.type = wt, $e.enter(wt, {
        _container: !0
      })), wt === "listUnordered")
        return $e.enter("listItemPrefix"), vt === 42 || vt === 45 ? $e.check(thematicBreak$1, Fe, lt)(vt) : lt(vt);
      if (!Ke.interrupt || vt === 49)
        return $e.enter("listItemPrefix"), $e.enter("listItemValue"), ut(vt);
    }
    return Fe(vt);
  }
  function ut(vt) {
    return asciiDigit(vt) && ++Qe < 10 ? ($e.consume(vt), ut) : (!Ke.interrupt || Qe < 2) && (Ke.containerState.marker ? vt === Ke.containerState.marker : vt === 41 || vt === 46) ? ($e.exit("listItemValue"), lt(vt)) : Fe(vt);
  }
  function lt(vt) {
    return $e.enter("listItemMarker"), $e.consume(vt), $e.exit("listItemMarker"), Ke.containerState.marker = Ke.containerState.marker || vt, $e.check(
      blankLine,
      // Can’t be empty when interrupting.
      Ke.interrupt ? Fe : dt,
      $e.attempt(
        listItemPrefixWhitespaceConstruct,
        $t,
        bt
      )
    );
  }
  function dt(vt) {
    return Ke.containerState.initialBlankLine = !0, Je++, $t(vt);
  }
  function bt(vt) {
    return markdownSpace(vt) ? ($e.enter("listItemPrefixWhitespace"), $e.consume(vt), $e.exit("listItemPrefixWhitespace"), $t) : Fe(vt);
  }
  function $t(vt) {
    return Ke.containerState.size = Je + Ke.sliceSerialize($e.exit("listItemPrefix"), !0).length, Ze(vt);
  }
}
function tokenizeListContinuation($e, Ze, Fe) {
  const Ke = this;
  return Ke.containerState._closeFlow = void 0, $e.check(blankLine, Ve, Je);
  function Ve(at) {
    return Ke.containerState.furtherBlankLines = Ke.containerState.furtherBlankLines || Ke.containerState.initialBlankLine, factorySpace(
      $e,
      Ze,
      "listItemIndent",
      Ke.containerState.size + 1
    )(at);
  }
  function Je(at) {
    return Ke.containerState.furtherBlankLines || !markdownSpace(at) ? (Ke.containerState.furtherBlankLines = void 0, Ke.containerState.initialBlankLine = void 0, Qe(at)) : (Ke.containerState.furtherBlankLines = void 0, Ke.containerState.initialBlankLine = void 0, $e.attempt(indentConstruct, Ze, Qe)(at));
  }
  function Qe(at) {
    return Ke.containerState._closeFlow = !0, Ke.interrupt = void 0, factorySpace(
      $e,
      $e.attempt(list$1, Ze, Fe),
      "linePrefix",
      Ke.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(at);
  }
}
function tokenizeIndent($e, Ze, Fe) {
  const Ke = this;
  return factorySpace(
    $e,
    Ve,
    "listItemIndent",
    Ke.containerState.size + 1
  );
  function Ve(Je) {
    const Qe = Ke.events[Ke.events.length - 1];
    return Qe && Qe[1].type === "listItemIndent" && Qe[2].sliceSerialize(Qe[1], !0).length === Ke.containerState.size ? Ze(Je) : Fe(Je);
  }
}
function tokenizeListEnd($e) {
  $e.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace($e, Ze, Fe) {
  const Ke = this;
  return factorySpace(
    $e,
    Ve,
    "listItemPrefixWhitespace",
    Ke.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
  );
  function Ve(Je) {
    const Qe = Ke.events[Ke.events.length - 1];
    return !markdownSpace(Je) && Qe && Qe[1].type === "listItemPrefixWhitespace" ? Ze(Je) : Fe(Je);
  }
}
const setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline($e, Ze) {
  let Fe = $e.length, Ke, Ve, Je;
  for (; Fe--; )
    if ($e[Fe][0] === "enter") {
      if ($e[Fe][1].type === "content") {
        Ke = Fe;
        break;
      }
      $e[Fe][1].type === "paragraph" && (Ve = Fe);
    } else
      $e[Fe][1].type === "content" && $e.splice(Fe, 1), !Je && $e[Fe][1].type === "definition" && (Je = Fe);
  const Qe = {
    type: "setextHeading",
    start: Object.assign({}, $e[Ve][1].start),
    end: Object.assign({}, $e[$e.length - 1][1].end)
  };
  return $e[Ve][1].type = "setextHeadingText", Je ? ($e.splice(Ve, 0, ["enter", Qe, Ze]), $e.splice(Je + 1, 0, ["exit", $e[Ke][1], Ze]), $e[Ke][1].end = Object.assign({}, $e[Je][1].end)) : $e[Ke][1] = Qe, $e.push(["exit", Qe, Ze]), $e;
}
function tokenizeSetextUnderline($e, Ze, Fe) {
  const Ke = this;
  let Ve;
  return Je;
  function Je(lt) {
    let dt = Ke.events.length, bt;
    for (; dt--; )
      if (Ke.events[dt][1].type !== "lineEnding" && Ke.events[dt][1].type !== "linePrefix" && Ke.events[dt][1].type !== "content") {
        bt = Ke.events[dt][1].type === "paragraph";
        break;
      }
    return !Ke.parser.lazy[Ke.now().line] && (Ke.interrupt || bt) ? ($e.enter("setextHeadingLine"), Ve = lt, Qe(lt)) : Fe(lt);
  }
  function Qe(lt) {
    return $e.enter("setextHeadingLineSequence"), at(lt);
  }
  function at(lt) {
    return lt === Ve ? ($e.consume(lt), at) : ($e.exit("setextHeadingLineSequence"), markdownSpace(lt) ? factorySpace($e, ut, "lineSuffix")(lt) : ut(lt));
  }
  function ut(lt) {
    return lt === null || markdownLineEnding(lt) ? ($e.exit("setextHeadingLine"), Ze(lt)) : Fe(lt);
  }
}
const flow$1 = {
  tokenize: initializeFlow
};
function initializeFlow($e) {
  const Ze = this, Fe = $e.attempt(
    // Try to parse a blank line.
    blankLine,
    Ke,
    // Try to parse initial flow (essentially, only code).
    $e.attempt(
      this.parser.constructs.flowInitial,
      Ve,
      factorySpace(
        $e,
        $e.attempt(
          this.parser.constructs.flow,
          Ve,
          $e.attempt(content, Ve)
        ),
        "linePrefix"
      )
    )
  );
  return Fe;
  function Ke(Je) {
    if (Je === null) {
      $e.consume(Je);
      return;
    }
    return $e.enter("lineEndingBlank"), $e.consume(Je), $e.exit("lineEndingBlank"), Ze.currentConstruct = void 0, Fe;
  }
  function Ve(Je) {
    if (Je === null) {
      $e.consume(Je);
      return;
    }
    return $e.enter("lineEnding"), $e.consume(Je), $e.exit("lineEnding"), Ze.currentConstruct = void 0, Fe;
  }
}
const resolver = {
  resolveAll: createResolver()
}, string$1 = initializeFactory("string"), text$2 = initializeFactory("text");
function initializeFactory($e) {
  return {
    tokenize: Ze,
    resolveAll: createResolver(
      $e === "text" ? resolveAllLineSuffixes : void 0
    )
  };
  function Ze(Fe) {
    const Ke = this, Ve = this.parser.constructs[$e], Je = Fe.attempt(Ve, Qe, at);
    return Qe;
    function Qe(dt) {
      return lt(dt) ? Je(dt) : at(dt);
    }
    function at(dt) {
      if (dt === null) {
        Fe.consume(dt);
        return;
      }
      return Fe.enter("data"), Fe.consume(dt), ut;
    }
    function ut(dt) {
      return lt(dt) ? (Fe.exit("data"), Je(dt)) : (Fe.consume(dt), ut);
    }
    function lt(dt) {
      if (dt === null)
        return !0;
      const bt = Ve[dt];
      let $t = -1;
      if (bt)
        for (; ++$t < bt.length; ) {
          const vt = bt[$t];
          if (!vt.previous || vt.previous.call(Ke, Ke.previous))
            return !0;
        }
      return !1;
    }
  }
}
function createResolver($e) {
  return Ze;
  function Ze(Fe, Ke) {
    let Ve = -1, Je;
    for (; ++Ve <= Fe.length; )
      Je === void 0 ? Fe[Ve] && Fe[Ve][1].type === "data" && (Je = Ve, Ve++) : (!Fe[Ve] || Fe[Ve][1].type !== "data") && (Ve !== Je + 2 && (Fe[Je][1].end = Fe[Ve - 1][1].end, Fe.splice(Je + 2, Ve - Je - 2), Ve = Je + 2), Je = void 0);
    return $e ? $e(Fe, Ke) : Fe;
  }
}
function resolveAllLineSuffixes($e, Ze) {
  let Fe = 0;
  for (; ++Fe <= $e.length; )
    if ((Fe === $e.length || $e[Fe][1].type === "lineEnding") && $e[Fe - 1][1].type === "data") {
      const Ke = $e[Fe - 1][1], Ve = Ze.sliceStream(Ke);
      let Je = Ve.length, Qe = -1, at = 0, ut;
      for (; Je--; ) {
        const lt = Ve[Je];
        if (typeof lt == "string") {
          for (Qe = lt.length; lt.charCodeAt(Qe - 1) === 32; )
            at++, Qe--;
          if (Qe)
            break;
          Qe = -1;
        } else if (lt === -2)
          ut = !0, at++;
        else if (lt !== -1) {
          Je++;
          break;
        }
      }
      if (at) {
        const lt = {
          type: Fe === $e.length || ut || at < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: Ke.end.line,
            column: Ke.end.column - at,
            offset: Ke.end.offset - at,
            _index: Ke.start._index + Je,
            _bufferIndex: Je ? Qe : Ke.start._bufferIndex + Qe
          },
          end: Object.assign({}, Ke.end)
        };
        Ke.end = Object.assign({}, lt.start), Ke.start.offset === Ke.end.offset ? Object.assign(Ke, lt) : ($e.splice(
          Fe,
          0,
          ["enter", lt, Ze],
          ["exit", lt, Ze]
        ), Fe += 2);
      }
      Fe++;
    }
  return $e;
}
function createTokenizer($e, Ze, Fe) {
  let Ke = Object.assign(
    Fe ? Object.assign({}, Fe) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const Ve = {}, Je = [];
  let Qe = [], at = [];
  const ut = {
    consume: Rt,
    enter: Ct,
    exit: Zt,
    attempt: Pt(Lt),
    check: Pt(Ut),
    interrupt: Pt(Ut, {
      interrupt: !0
    })
  }, lt = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: $e,
    sliceStream: vt,
    sliceSerialize: $t,
    now: wt,
    defineSkip: xt,
    write: bt
  };
  let dt = Ze.tokenize.call(lt, ut);
  return Ze.resolveAll && Je.push(Ze), lt;
  function bt(We) {
    return Qe = push(Qe, We), Et(), Qe[Qe.length - 1] !== null ? [] : (Ot(Ze, 0), lt.events = resolveAll(Je, lt.events, lt), lt.events);
  }
  function $t(We, Xe) {
    return serializeChunks(vt(We), Xe);
  }
  function vt(We) {
    return sliceChunks(Qe, We);
  }
  function wt() {
    const { line: We, column: Xe, offset: rt, _index: ot, _bufferIndex: ft } = Ke;
    return {
      line: We,
      column: Xe,
      offset: rt,
      _index: ot,
      _bufferIndex: ft
    };
  }
  function xt(We) {
    Ve[We.line] = We.column, gt();
  }
  function Et() {
    let We;
    for (; Ke._index < Qe.length; ) {
      const Xe = Qe[Ke._index];
      if (typeof Xe == "string")
        for (We = Ke._index, Ke._bufferIndex < 0 && (Ke._bufferIndex = 0); Ke._index === We && Ke._bufferIndex < Xe.length; )
          Tt(Xe.charCodeAt(Ke._bufferIndex));
      else
        Tt(Xe);
    }
  }
  function Tt(We) {
    dt = dt(We);
  }
  function Rt(We) {
    markdownLineEnding(We) ? (Ke.line++, Ke.column = 1, Ke.offset += We === -3 ? 2 : 1, gt()) : We !== -1 && (Ke.column++, Ke.offset++), Ke._bufferIndex < 0 ? Ke._index++ : (Ke._bufferIndex++, Ke._bufferIndex === Qe[Ke._index].length && (Ke._bufferIndex = -1, Ke._index++)), lt.previous = We;
  }
  function Ct(We, Xe) {
    const rt = Xe || {};
    return rt.type = We, rt.start = wt(), lt.events.push(["enter", rt, lt]), at.push(rt), rt;
  }
  function Zt(We) {
    const Xe = at.pop();
    return Xe.end = wt(), lt.events.push(["exit", Xe, lt]), Xe;
  }
  function Lt(We, Xe) {
    Ot(We, Xe.from);
  }
  function Ut(We, Xe) {
    Xe.restore();
  }
  function Pt(We, Xe) {
    return rt;
    function rt(ot, ft, mt) {
      let yt, pt, Ge, ct;
      return Array.isArray(ot) ? St(ot) : "tokenize" in ot ? (
        // @ts-expect-error Looks like a construct.
        St([ot])
      ) : Mt(ot);
      function Mt(Qt) {
        return Xt;
        function Xt(zt) {
          const Kt = zt !== null && Qt[zt], ur = zt !== null && Qt.null, er = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Kt) ? Kt : Kt ? [Kt] : [],
            ...Array.isArray(ur) ? ur : ur ? [ur] : []
          ];
          return St(er)(zt);
        }
      }
      function St(Qt) {
        return yt = Qt, pt = 0, Qt.length === 0 ? mt : At(Qt[pt]);
      }
      function At(Qt) {
        return Xt;
        function Xt(zt) {
          return ct = Ft(), Ge = Qt, Qt.partial || (lt.currentConstruct = Qt), Qt.name && lt.parser.constructs.disable.null.includes(Qt.name) ? qt() : Qt.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            Xe ? Object.assign(Object.create(lt), Xe) : lt,
            ut,
            Nt,
            qt
          )(zt);
        }
      }
      function Nt(Qt) {
        return We(Ge, ct), ft;
      }
      function qt(Qt) {
        return ct.restore(), ++pt < yt.length ? At(yt[pt]) : mt;
      }
    }
  }
  function Ot(We, Xe) {
    We.resolveAll && !Je.includes(We) && Je.push(We), We.resolve && splice(
      lt.events,
      Xe,
      lt.events.length - Xe,
      We.resolve(lt.events.slice(Xe), lt)
    ), We.resolveTo && (lt.events = We.resolveTo(lt.events, lt));
  }
  function Ft() {
    const We = wt(), Xe = lt.previous, rt = lt.currentConstruct, ot = lt.events.length, ft = Array.from(at);
    return {
      restore: mt,
      from: ot
    };
    function mt() {
      Ke = We, lt.previous = Xe, lt.currentConstruct = rt, lt.events.length = ot, at = ft, gt();
    }
  }
  function gt() {
    Ke.line in Ve && Ke.column < 2 && (Ke.column = Ve[Ke.line], Ke.offset += Ve[Ke.line] - 1);
  }
}
function sliceChunks($e, Ze) {
  const Fe = Ze.start._index, Ke = Ze.start._bufferIndex, Ve = Ze.end._index, Je = Ze.end._bufferIndex;
  let Qe;
  if (Fe === Ve)
    Qe = [$e[Fe].slice(Ke, Je)];
  else {
    if (Qe = $e.slice(Fe, Ve), Ke > -1) {
      const at = Qe[0];
      typeof at == "string" ? Qe[0] = at.slice(Ke) : Qe.shift();
    }
    Je > 0 && Qe.push($e[Ve].slice(0, Je));
  }
  return Qe;
}
function serializeChunks($e, Ze) {
  let Fe = -1;
  const Ke = [];
  let Ve;
  for (; ++Fe < $e.length; ) {
    const Je = $e[Fe];
    let Qe;
    if (typeof Je == "string")
      Qe = Je;
    else
      switch (Je) {
        case -5: {
          Qe = "\r";
          break;
        }
        case -4: {
          Qe = `
`;
          break;
        }
        case -3: {
          Qe = `\r
`;
          break;
        }
        case -2: {
          Qe = Ze ? " " : "	";
          break;
        }
        case -1: {
          if (!Ze && Ve)
            continue;
          Qe = " ";
          break;
        }
        default:
          Qe = String.fromCharCode(Je);
      }
    Ve = Je === -2, Ke.push(Qe);
  }
  return Ke.join("");
}
const document$1 = {
  [42]: list$1,
  [43]: list$1,
  [45]: list$1,
  [48]: list$1,
  [49]: list$1,
  [50]: list$1,
  [51]: list$1,
  [52]: list$1,
  [53]: list$1,
  [54]: list$1,
  [55]: list$1,
  [56]: list$1,
  [57]: list$1,
  [62]: blockQuote
}, contentInitial = {
  [91]: definition$r
}, flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
}, flow = {
  [35]: headingAtx,
  [42]: thematicBreak$1,
  [45]: [setextUnderline, thematicBreak$1],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak$1,
  [96]: codeFenced,
  [126]: codeFenced
}, string = {
  [38]: characterReference,
  [92]: characterEscape
}, text$1 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
}, insideSpan = {
  null: [attention, resolver]
}, attentionMarkers = {
  null: [42, 95]
}, disable = {
  null: []
}, defaultConstructs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers,
  contentInitial,
  disable,
  document: document$1,
  flow,
  flowInitial,
  insideSpan,
  string,
  text: text$1
}, Symbol.toStringTag, { value: "Module" }));
function parse$7($e) {
  const Fe = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([defaultConstructs, ...($e || {}).extensions || []])
  ), Ke = {
    defined: [],
    lazy: {},
    constructs: Fe,
    content: Ve(content$1),
    document: Ve(document$2),
    flow: Ve(flow$1),
    string: Ve(string$1),
    text: Ve(text$2)
  };
  return Ke;
  function Ve(Je) {
    return Qe;
    function Qe(at) {
      return createTokenizer(Ke, Je, at);
    }
  }
}
const search = /[\0\t\n\r]/g;
function preprocess() {
  let $e = 1, Ze = "", Fe = !0, Ke;
  return Ve;
  function Ve(Je, Qe, at) {
    const ut = [];
    let lt, dt, bt, $t, vt;
    for (Je = Ze + Je.toString(Qe), bt = 0, Ze = "", Fe && (Je.charCodeAt(0) === 65279 && bt++, Fe = void 0); bt < Je.length; ) {
      if (search.lastIndex = bt, lt = search.exec(Je), $t = lt && lt.index !== void 0 ? lt.index : Je.length, vt = Je.charCodeAt($t), !lt) {
        Ze = Je.slice(bt);
        break;
      }
      if (vt === 10 && bt === $t && Ke)
        ut.push(-3), Ke = void 0;
      else
        switch (Ke && (ut.push(-5), Ke = void 0), bt < $t && (ut.push(Je.slice(bt, $t)), $e += $t - bt), vt) {
          case 0: {
            ut.push(65533), $e++;
            break;
          }
          case 9: {
            for (dt = Math.ceil($e / 4) * 4, ut.push(-2); $e++ < dt; )
              ut.push(-1);
            break;
          }
          case 10: {
            ut.push(-4), $e = 1;
            break;
          }
          default:
            Ke = !0, $e = 1;
        }
      bt = $t + 1;
    }
    return at && (Ke && ut.push(-5), Ze && ut.push(Ze), ut.push(null)), ut;
  }
}
function postprocess($e) {
  for (; !subtokenize($e); )
    ;
  return $e;
}
function decodeNumericCharacterReference($e, Ze) {
  const Fe = Number.parseInt($e, Ze);
  return (
    // C0 except for HT, LF, FF, CR, space.
    Fe < 9 || Fe === 11 || Fe > 13 && Fe < 32 || // Control character (DEL) of C0, and C1 controls.
    Fe > 126 && Fe < 160 || // Lone high surrogates and low surrogates.
    Fe > 55295 && Fe < 57344 || // Noncharacters.
    Fe > 64975 && Fe < 65008 || (Fe & 65535) === 65535 || (Fe & 65535) === 65534 || // Out of range
    Fe > 1114111 ? "�" : String.fromCharCode(Fe)
  );
}
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString($e) {
  return $e.replace(characterEscapeOrReference, decode$3);
}
function decode$3($e, Ze, Fe) {
  if (Ze)
    return Ze;
  if (Fe.charCodeAt(0) === 35) {
    const Ve = Fe.charCodeAt(1), Je = Ve === 120 || Ve === 88;
    return decodeNumericCharacterReference(Fe.slice(Je ? 2 : 1), Je ? 16 : 10);
  }
  return decodeNamedCharacterReference(Fe) || $e;
}
const own$5 = {}.hasOwnProperty, fromMarkdown = (
  /**
   * @type {(
   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &
   *   ((value: Value, options?: Options | null | undefined) => Root)
   * )}
   */
  /**
   * @param {Value} value
   * @param {Encoding | Options | null | undefined} [encoding]
   * @param {Options | null | undefined} [options]
   * @returns {Root}
   */
  function($e, Ze, Fe) {
    return typeof Ze != "string" && (Fe = Ze, Ze = void 0), compiler(Fe)(
      postprocess(
        parse$7(Fe).document().write(preprocess()($e, Ze, !0))
      )
    );
  }
);
function compiler($e) {
  const Ze = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: at(or),
      autolinkProtocol: We,
      autolinkEmail: We,
      atxHeading: at(sr),
      blockQuote: at(er),
      characterEscape: We,
      characterReference: We,
      codeFenced: at(Dt),
      codeFencedFenceInfo: ut,
      codeFencedFenceMeta: ut,
      codeIndented: at(Dt, ut),
      codeText: at(Ht, ut),
      codeTextData: We,
      data: We,
      codeFlowValue: We,
      definition: at(Gt),
      definitionDestinationString: ut,
      definitionLabelString: ut,
      definitionTitleString: ut,
      emphasis: at(rr),
      hardBreakEscape: at(Jt),
      hardBreakTrailing: at(Jt),
      htmlFlow: at(ir, ut),
      htmlFlowData: We,
      htmlText: at(ir, ut),
      htmlTextData: We,
      image: at(Br),
      label: ut,
      link: at(or),
      listItem: at(Nr),
      listItemValue: wt,
      listOrdered: at(lr, vt),
      listUnordered: at(lr),
      paragraph: at(dr),
      reference: qt,
      referenceString: ut,
      resourceDestinationString: ut,
      resourceTitleString: ut,
      setextHeading: at(sr),
      strong: at(gr),
      thematicBreak: at(Bt)
    },
    exit: {
      atxHeading: dt(),
      atxHeadingSequence: Pt,
      autolink: dt(),
      autolinkEmail: ur,
      autolinkProtocol: Kt,
      blockQuote: dt(),
      characterEscapeValue: Xe,
      characterReferenceMarkerHexadecimal: Xt,
      characterReferenceMarkerNumeric: Xt,
      characterReferenceValue: zt,
      codeFenced: dt(Rt),
      codeFencedFence: Tt,
      codeFencedFenceInfo: xt,
      codeFencedFenceMeta: Et,
      codeFlowValue: Xe,
      codeIndented: dt(Ct),
      codeText: dt(yt),
      codeTextData: Xe,
      data: Xe,
      definition: dt(),
      definitionDestinationString: Ut,
      definitionLabelString: Zt,
      definitionTitleString: Lt,
      emphasis: dt(),
      hardBreakEscape: dt(ot),
      hardBreakTrailing: dt(ot),
      htmlFlow: dt(ft),
      htmlFlowData: Xe,
      htmlText: dt(mt),
      htmlTextData: Xe,
      image: dt(Ge),
      label: Mt,
      labelText: ct,
      lineEnding: rt,
      link: dt(pt),
      listItem: dt(),
      listOrdered: dt(),
      listUnordered: dt(),
      paragraph: dt(),
      referenceString: Qt,
      resourceDestinationString: St,
      resourceTitleString: At,
      resource: Nt,
      setextHeading: dt(gt),
      setextHeadingLineSequence: Ft,
      setextHeadingText: Ot,
      strong: dt(),
      thematicBreak: dt()
    }
  };
  configure(Ze, ($e || {}).mdastExtensions || []);
  const Fe = {};
  return Ke;
  function Ke(kt) {
    let It = {
      type: "root",
      children: []
    };
    const jt = {
      stack: [It],
      tokenStack: [],
      config: Ze,
      enter: lt,
      exit: bt,
      buffer: ut,
      resume: $t,
      setData: Je,
      getData: Qe
    }, Vt = [];
    let ar = -1;
    for (; ++ar < kt.length; )
      if (kt[ar][1].type === "listOrdered" || kt[ar][1].type === "listUnordered")
        if (kt[ar][0] === "enter")
          Vt.push(ar);
        else {
          const Yt = Vt.pop();
          ar = Ve(kt, Yt, ar);
        }
    for (ar = -1; ++ar < kt.length; ) {
      const Yt = Ze[kt[ar][0]];
      own$5.call(Yt, kt[ar][1].type) && Yt[kt[ar][1].type].call(
        Object.assign(
          {
            sliceSerialize: kt[ar][2].sliceSerialize
          },
          jt
        ),
        kt[ar][1]
      );
    }
    if (jt.tokenStack.length > 0) {
      const Yt = jt.tokenStack[jt.tokenStack.length - 1];
      (Yt[1] || defaultOnError).call(jt, void 0, Yt[0]);
    }
    for (It.position = {
      start: point$1(
        kt.length > 0 ? kt[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: point$1(
        kt.length > 0 ? kt[kt.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, ar = -1; ++ar < Ze.transforms.length; )
      It = Ze.transforms[ar](It) || It;
    return It;
  }
  function Ve(kt, It, jt) {
    let Vt = It - 1, ar = -1, Yt = !1, hr, zr, cr, _r;
    for (; ++Vt <= jt; ) {
      const Lr = kt[Vt];
      if (Lr[1].type === "listUnordered" || Lr[1].type === "listOrdered" || Lr[1].type === "blockQuote" ? (Lr[0] === "enter" ? ar++ : ar--, _r = void 0) : Lr[1].type === "lineEndingBlank" ? Lr[0] === "enter" && (hr && !_r && !ar && !cr && (cr = Vt), _r = void 0) : Lr[1].type === "linePrefix" || Lr[1].type === "listItemValue" || Lr[1].type === "listItemMarker" || Lr[1].type === "listItemPrefix" || Lr[1].type === "listItemPrefixWhitespace" || (_r = void 0), !ar && Lr[0] === "enter" && Lr[1].type === "listItemPrefix" || ar === -1 && Lr[0] === "exit" && (Lr[1].type === "listUnordered" || Lr[1].type === "listOrdered")) {
        if (hr) {
          let br = Vt;
          for (zr = void 0; br--; ) {
            const kr = kt[br];
            if (kr[1].type === "lineEnding" || kr[1].type === "lineEndingBlank") {
              if (kr[0] === "exit")
                continue;
              zr && (kt[zr][1].type = "lineEndingBlank", Yt = !0), kr[1].type = "lineEnding", zr = br;
            } else if (!(kr[1].type === "linePrefix" || kr[1].type === "blockQuotePrefix" || kr[1].type === "blockQuotePrefixWhitespace" || kr[1].type === "blockQuoteMarker" || kr[1].type === "listItemIndent"))
              break;
          }
          cr && (!zr || cr < zr) && (hr._spread = !0), hr.end = Object.assign(
            {},
            zr ? kt[zr][1].start : Lr[1].end
          ), kt.splice(zr || Vt, 0, ["exit", hr, Lr[2]]), Vt++, jt++;
        }
        Lr[1].type === "listItemPrefix" && (hr = {
          type: "listItem",
          _spread: !1,
          start: Object.assign({}, Lr[1].start),
          // @ts-expect-error: we’ll add `end` in a second.
          end: void 0
        }, kt.splice(Vt, 0, ["enter", hr, Lr[2]]), Vt++, jt++, cr = void 0, _r = !0);
      }
    }
    return kt[It][1]._spread = Yt, jt;
  }
  function Je(kt, It) {
    Fe[kt] = It;
  }
  function Qe(kt) {
    return Fe[kt];
  }
  function at(kt, It) {
    return jt;
    function jt(Vt) {
      lt.call(this, kt(Vt), Vt), It && It.call(this, Vt);
    }
  }
  function ut() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function lt(kt, It, jt) {
    return this.stack[this.stack.length - 1].children.push(kt), this.stack.push(kt), this.tokenStack.push([It, jt]), kt.position = {
      start: point$1(It.start)
    }, kt;
  }
  function dt(kt) {
    return It;
    function It(jt) {
      kt && kt.call(this, jt), bt.call(this, jt);
    }
  }
  function bt(kt, It) {
    const jt = this.stack.pop(), Vt = this.tokenStack.pop();
    if (Vt)
      Vt[0].type !== kt.type && (It ? It.call(this, kt, Vt[0]) : (Vt[1] || defaultOnError).call(this, kt, Vt[0]));
    else
      throw new Error(
        "Cannot close `" + kt.type + "` (" + stringifyPosition({
          start: kt.start,
          end: kt.end
        }) + "): it’s not open"
      );
    return jt.position.end = point$1(kt.end), jt;
  }
  function $t() {
    return toString$4(this.stack.pop());
  }
  function vt() {
    Je("expectingFirstListItemValue", !0);
  }
  function wt(kt) {
    if (Qe("expectingFirstListItemValue")) {
      const It = this.stack[this.stack.length - 2];
      It.start = Number.parseInt(this.sliceSerialize(kt), 10), Je("expectingFirstListItemValue");
    }
  }
  function xt() {
    const kt = this.resume(), It = this.stack[this.stack.length - 1];
    It.lang = kt;
  }
  function Et() {
    const kt = this.resume(), It = this.stack[this.stack.length - 1];
    It.meta = kt;
  }
  function Tt() {
    Qe("flowCodeInside") || (this.buffer(), Je("flowCodeInside", !0));
  }
  function Rt() {
    const kt = this.resume(), It = this.stack[this.stack.length - 1];
    It.value = kt.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), Je("flowCodeInside");
  }
  function Ct() {
    const kt = this.resume(), It = this.stack[this.stack.length - 1];
    It.value = kt.replace(/(\r?\n|\r)$/g, "");
  }
  function Zt(kt) {
    const It = this.resume(), jt = this.stack[this.stack.length - 1];
    jt.label = It, jt.identifier = normalizeIdentifier(
      this.sliceSerialize(kt)
    ).toLowerCase();
  }
  function Lt() {
    const kt = this.resume(), It = this.stack[this.stack.length - 1];
    It.title = kt;
  }
  function Ut() {
    const kt = this.resume(), It = this.stack[this.stack.length - 1];
    It.url = kt;
  }
  function Pt(kt) {
    const It = this.stack[this.stack.length - 1];
    if (!It.depth) {
      const jt = this.sliceSerialize(kt).length;
      It.depth = jt;
    }
  }
  function Ot() {
    Je("setextHeadingSlurpLineEnding", !0);
  }
  function Ft(kt) {
    const It = this.stack[this.stack.length - 1];
    It.depth = this.sliceSerialize(kt).charCodeAt(0) === 61 ? 1 : 2;
  }
  function gt() {
    Je("setextHeadingSlurpLineEnding");
  }
  function We(kt) {
    const It = this.stack[this.stack.length - 1];
    let jt = It.children[It.children.length - 1];
    (!jt || jt.type !== "text") && (jt = Zr(), jt.position = {
      start: point$1(kt.start)
    }, It.children.push(jt)), this.stack.push(jt);
  }
  function Xe(kt) {
    const It = this.stack.pop();
    It.value += this.sliceSerialize(kt), It.position.end = point$1(kt.end);
  }
  function rt(kt) {
    const It = this.stack[this.stack.length - 1];
    if (Qe("atHardBreak")) {
      const jt = It.children[It.children.length - 1];
      jt.position.end = point$1(kt.end), Je("atHardBreak");
      return;
    }
    !Qe("setextHeadingSlurpLineEnding") && Ze.canContainEols.includes(It.type) && (We.call(this, kt), Xe.call(this, kt));
  }
  function ot() {
    Je("atHardBreak", !0);
  }
  function ft() {
    const kt = this.resume(), It = this.stack[this.stack.length - 1];
    It.value = kt;
  }
  function mt() {
    const kt = this.resume(), It = this.stack[this.stack.length - 1];
    It.value = kt;
  }
  function yt() {
    const kt = this.resume(), It = this.stack[this.stack.length - 1];
    It.value = kt;
  }
  function pt() {
    const kt = this.stack[this.stack.length - 1];
    if (Qe("inReference")) {
      const It = Qe("referenceType") || "shortcut";
      kt.type += "Reference", kt.referenceType = It, delete kt.url, delete kt.title;
    } else
      delete kt.identifier, delete kt.label;
    Je("referenceType");
  }
  function Ge() {
    const kt = this.stack[this.stack.length - 1];
    if (Qe("inReference")) {
      const It = Qe("referenceType") || "shortcut";
      kt.type += "Reference", kt.referenceType = It, delete kt.url, delete kt.title;
    } else
      delete kt.identifier, delete kt.label;
    Je("referenceType");
  }
  function ct(kt) {
    const It = this.sliceSerialize(kt), jt = this.stack[this.stack.length - 2];
    jt.label = decodeString(It), jt.identifier = normalizeIdentifier(It).toLowerCase();
  }
  function Mt() {
    const kt = this.stack[this.stack.length - 1], It = this.resume(), jt = this.stack[this.stack.length - 1];
    if (Je("inReference", !0), jt.type === "link") {
      const Vt = kt.children;
      jt.children = Vt;
    } else
      jt.alt = It;
  }
  function St() {
    const kt = this.resume(), It = this.stack[this.stack.length - 1];
    It.url = kt;
  }
  function At() {
    const kt = this.resume(), It = this.stack[this.stack.length - 1];
    It.title = kt;
  }
  function Nt() {
    Je("inReference");
  }
  function qt() {
    Je("referenceType", "collapsed");
  }
  function Qt(kt) {
    const It = this.resume(), jt = this.stack[this.stack.length - 1];
    jt.label = It, jt.identifier = normalizeIdentifier(
      this.sliceSerialize(kt)
    ).toLowerCase(), Je("referenceType", "full");
  }
  function Xt(kt) {
    Je("characterReferenceType", kt.type);
  }
  function zt(kt) {
    const It = this.sliceSerialize(kt), jt = Qe("characterReferenceType");
    let Vt;
    jt ? (Vt = decodeNumericCharacterReference(
      It,
      jt === "characterReferenceMarkerNumeric" ? 10 : 16
    ), Je("characterReferenceType")) : Vt = decodeNamedCharacterReference(It);
    const ar = this.stack.pop();
    ar.value += Vt, ar.position.end = point$1(kt.end);
  }
  function Kt(kt) {
    Xe.call(this, kt);
    const It = this.stack[this.stack.length - 1];
    It.url = this.sliceSerialize(kt);
  }
  function ur(kt) {
    Xe.call(this, kt);
    const It = this.stack[this.stack.length - 1];
    It.url = "mailto:" + this.sliceSerialize(kt);
  }
  function er() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function Dt() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Ht() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Gt() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function rr() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function sr() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function Jt() {
    return {
      type: "break"
    };
  }
  function ir() {
    return {
      type: "html",
      value: ""
    };
  }
  function Br() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function or() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function lr(kt) {
    return {
      type: "list",
      ordered: kt.type === "listOrdered",
      start: null,
      spread: kt._spread,
      children: []
    };
  }
  function Nr(kt) {
    return {
      type: "listItem",
      spread: kt._spread,
      checked: null,
      children: []
    };
  }
  function dr() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function gr() {
    return {
      type: "strong",
      children: []
    };
  }
  function Zr() {
    return {
      type: "text",
      value: ""
    };
  }
  function Bt() {
    return {
      type: "thematicBreak"
    };
  }
}
function point$1($e) {
  return {
    line: $e.line,
    column: $e.column,
    offset: $e.offset
  };
}
function configure($e, Ze) {
  let Fe = -1;
  for (; ++Fe < Ze.length; ) {
    const Ke = Ze[Fe];
    Array.isArray(Ke) ? configure($e, Ke) : extension($e, Ke);
  }
}
function extension($e, Ze) {
  let Fe;
  for (Fe in Ze)
    if (own$5.call(Ze, Fe)) {
      if (Fe === "canContainEols") {
        const Ke = Ze[Fe];
        Ke && $e[Fe].push(...Ke);
      } else if (Fe === "transforms") {
        const Ke = Ze[Fe];
        Ke && $e[Fe].push(...Ke);
      } else if (Fe === "enter" || Fe === "exit") {
        const Ke = Ze[Fe];
        Ke && Object.assign($e[Fe], Ke);
      }
    }
}
function defaultOnError($e, Ze) {
  throw $e ? new Error(
    "Cannot close `" + $e.type + "` (" + stringifyPosition({
      start: $e.start,
      end: $e.end
    }) + "): a different token (`" + Ze.type + "`, " + stringifyPosition({
      start: Ze.start,
      end: Ze.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + Ze.type + "`, " + stringifyPosition({
      start: Ze.start,
      end: Ze.end
    }) + ") is still open"
  );
}
function remarkParse($e) {
  Object.assign(this, { Parser: (Fe) => {
    const Ke = (
      /** @type {Options} */
      this.data("settings")
    );
    return fromMarkdown(
      Fe,
      Object.assign({}, Ke, $e, {
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: this.data("micromarkExtensions") || [],
        mdastExtensions: this.data("fromMarkdownExtensions") || []
      })
    );
  } });
}
function blockquote($e, Ze) {
  const Fe = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: $e.wrap($e.all(Ze), !0)
  };
  return $e.patch(Ze, Fe), $e.applyData(Ze, Fe);
}
function hardBreak($e, Ze) {
  const Fe = { type: "element", tagName: "br", properties: {}, children: [] };
  return $e.patch(Ze, Fe), [$e.applyData(Ze, Fe), { type: "text", value: `
` }];
}
function code($e, Ze) {
  const Fe = Ze.value ? Ze.value + `
` : "", Ke = Ze.lang ? Ze.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null, Ve = {};
  Ke && (Ve.className = ["language-" + Ke]);
  let Je = {
    type: "element",
    tagName: "code",
    properties: Ve,
    children: [{ type: "text", value: Fe }]
  };
  return Ze.meta && (Je.data = { meta: Ze.meta }), $e.patch(Ze, Je), Je = $e.applyData(Ze, Je), Je = { type: "element", tagName: "pre", properties: {}, children: [Je] }, $e.patch(Ze, Je), Je;
}
function strikethrough($e, Ze) {
  const Fe = {
    type: "element",
    tagName: "del",
    properties: {},
    children: $e.all(Ze)
  };
  return $e.patch(Ze, Fe), $e.applyData(Ze, Fe);
}
function emphasis($e, Ze) {
  const Fe = {
    type: "element",
    tagName: "em",
    properties: {},
    children: $e.all(Ze)
  };
  return $e.patch(Ze, Fe), $e.applyData(Ze, Fe);
}
function normalizeUri($e) {
  const Ze = [];
  let Fe = -1, Ke = 0, Ve = 0;
  for (; ++Fe < $e.length; ) {
    const Je = $e.charCodeAt(Fe);
    let Qe = "";
    if (Je === 37 && asciiAlphanumeric($e.charCodeAt(Fe + 1)) && asciiAlphanumeric($e.charCodeAt(Fe + 2)))
      Ve = 2;
    else if (Je < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(Je)) || (Qe = String.fromCharCode(Je));
    else if (Je > 55295 && Je < 57344) {
      const at = $e.charCodeAt(Fe + 1);
      Je < 56320 && at > 56319 && at < 57344 ? (Qe = String.fromCharCode(Je, at), Ve = 1) : Qe = "�";
    } else
      Qe = String.fromCharCode(Je);
    Qe && (Ze.push($e.slice(Ke, Fe), encodeURIComponent(Qe)), Ke = Fe + Ve + 1, Qe = ""), Ve && (Fe += Ve, Ve = 0);
  }
  return Ze.join("") + $e.slice(Ke);
}
function footnoteReference($e, Ze) {
  const Fe = String(Ze.identifier).toUpperCase(), Ke = normalizeUri(Fe.toLowerCase()), Ve = $e.footnoteOrder.indexOf(Fe);
  let Je;
  Ve === -1 ? ($e.footnoteOrder.push(Fe), $e.footnoteCounts[Fe] = 1, Je = $e.footnoteOrder.length) : ($e.footnoteCounts[Fe]++, Je = Ve + 1);
  const Qe = $e.footnoteCounts[Fe], at = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + $e.clobberPrefix + "fn-" + Ke,
      id: $e.clobberPrefix + "fnref-" + Ke + (Qe > 1 ? "-" + Qe : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(Je) }]
  };
  $e.patch(Ze, at);
  const ut = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [at]
  };
  return $e.patch(Ze, ut), $e.applyData(Ze, ut);
}
function footnote($e, Ze) {
  const Fe = $e.footnoteById;
  let Ke = 1;
  for (; Ke in Fe; )
    Ke++;
  const Ve = String(Ke);
  return Fe[Ve] = {
    type: "footnoteDefinition",
    identifier: Ve,
    children: [{ type: "paragraph", children: Ze.children }],
    position: Ze.position
  }, footnoteReference($e, {
    type: "footnoteReference",
    identifier: Ve,
    position: Ze.position
  });
}
function heading($e, Ze) {
  const Fe = {
    type: "element",
    tagName: "h" + Ze.depth,
    properties: {},
    children: $e.all(Ze)
  };
  return $e.patch(Ze, Fe), $e.applyData(Ze, Fe);
}
function html$2($e, Ze) {
  if ($e.dangerous) {
    const Fe = { type: "raw", value: Ze.value };
    return $e.patch(Ze, Fe), $e.applyData(Ze, Fe);
  }
  return null;
}
function revert($e, Ze) {
  const Fe = Ze.referenceType;
  let Ke = "]";
  if (Fe === "collapsed" ? Ke += "[]" : Fe === "full" && (Ke += "[" + (Ze.label || Ze.identifier) + "]"), Ze.type === "imageReference")
    return { type: "text", value: "![" + Ze.alt + Ke };
  const Ve = $e.all(Ze), Je = Ve[0];
  Je && Je.type === "text" ? Je.value = "[" + Je.value : Ve.unshift({ type: "text", value: "[" });
  const Qe = Ve[Ve.length - 1];
  return Qe && Qe.type === "text" ? Qe.value += Ke : Ve.push({ type: "text", value: Ke }), Ve;
}
function imageReference($e, Ze) {
  const Fe = $e.definition(Ze.identifier);
  if (!Fe)
    return revert($e, Ze);
  const Ke = { src: normalizeUri(Fe.url || ""), alt: Ze.alt };
  Fe.title !== null && Fe.title !== void 0 && (Ke.title = Fe.title);
  const Ve = { type: "element", tagName: "img", properties: Ke, children: [] };
  return $e.patch(Ze, Ve), $e.applyData(Ze, Ve);
}
function image($e, Ze) {
  const Fe = { src: normalizeUri(Ze.url) };
  Ze.alt !== null && Ze.alt !== void 0 && (Fe.alt = Ze.alt), Ze.title !== null && Ze.title !== void 0 && (Fe.title = Ze.title);
  const Ke = { type: "element", tagName: "img", properties: Fe, children: [] };
  return $e.patch(Ze, Ke), $e.applyData(Ze, Ke);
}
function inlineCode($e, Ze) {
  const Fe = { type: "text", value: Ze.value.replace(/\r?\n|\r/g, " ") };
  $e.patch(Ze, Fe);
  const Ke = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [Fe]
  };
  return $e.patch(Ze, Ke), $e.applyData(Ze, Ke);
}
function linkReference($e, Ze) {
  const Fe = $e.definition(Ze.identifier);
  if (!Fe)
    return revert($e, Ze);
  const Ke = { href: normalizeUri(Fe.url || "") };
  Fe.title !== null && Fe.title !== void 0 && (Ke.title = Fe.title);
  const Ve = {
    type: "element",
    tagName: "a",
    properties: Ke,
    children: $e.all(Ze)
  };
  return $e.patch(Ze, Ve), $e.applyData(Ze, Ve);
}
function link($e, Ze) {
  const Fe = { href: normalizeUri(Ze.url) };
  Ze.title !== null && Ze.title !== void 0 && (Fe.title = Ze.title);
  const Ke = {
    type: "element",
    tagName: "a",
    properties: Fe,
    children: $e.all(Ze)
  };
  return $e.patch(Ze, Ke), $e.applyData(Ze, Ke);
}
function listItem($e, Ze, Fe) {
  const Ke = $e.all(Ze), Ve = Fe ? listLoose(Fe) : listItemLoose(Ze), Je = {}, Qe = [];
  if (typeof Ze.checked == "boolean") {
    const dt = Ke[0];
    let bt;
    dt && dt.type === "element" && dt.tagName === "p" ? bt = dt : (bt = { type: "element", tagName: "p", properties: {}, children: [] }, Ke.unshift(bt)), bt.children.length > 0 && bt.children.unshift({ type: "text", value: " " }), bt.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: Ze.checked, disabled: !0 },
      children: []
    }), Je.className = ["task-list-item"];
  }
  let at = -1;
  for (; ++at < Ke.length; ) {
    const dt = Ke[at];
    (Ve || at !== 0 || dt.type !== "element" || dt.tagName !== "p") && Qe.push({ type: "text", value: `
` }), dt.type === "element" && dt.tagName === "p" && !Ve ? Qe.push(...dt.children) : Qe.push(dt);
  }
  const ut = Ke[Ke.length - 1];
  ut && (Ve || ut.type !== "element" || ut.tagName !== "p") && Qe.push({ type: "text", value: `
` });
  const lt = { type: "element", tagName: "li", properties: Je, children: Qe };
  return $e.patch(Ze, lt), $e.applyData(Ze, lt);
}
function listLoose($e) {
  let Ze = !1;
  if ($e.type === "list") {
    Ze = $e.spread || !1;
    const Fe = $e.children;
    let Ke = -1;
    for (; !Ze && ++Ke < Fe.length; )
      Ze = listItemLoose(Fe[Ke]);
  }
  return Ze;
}
function listItemLoose($e) {
  const Ze = $e.spread;
  return Ze ?? $e.children.length > 1;
}
function list($e, Ze) {
  const Fe = {}, Ke = $e.all(Ze);
  let Ve = -1;
  for (typeof Ze.start == "number" && Ze.start !== 1 && (Fe.start = Ze.start); ++Ve < Ke.length; ) {
    const Qe = Ke[Ve];
    if (Qe.type === "element" && Qe.tagName === "li" && Qe.properties && Array.isArray(Qe.properties.className) && Qe.properties.className.includes("task-list-item")) {
      Fe.className = ["contains-task-list"];
      break;
    }
  }
  const Je = {
    type: "element",
    tagName: Ze.ordered ? "ol" : "ul",
    properties: Fe,
    children: $e.wrap(Ke, !0)
  };
  return $e.patch(Ze, Je), $e.applyData(Ze, Je);
}
function paragraph($e, Ze) {
  const Fe = {
    type: "element",
    tagName: "p",
    properties: {},
    children: $e.all(Ze)
  };
  return $e.patch(Ze, Fe), $e.applyData(Ze, Fe);
}
function root($e, Ze) {
  const Fe = { type: "root", children: $e.wrap($e.all(Ze)) };
  return $e.patch(Ze, Fe), $e.applyData(Ze, Fe);
}
function strong($e, Ze) {
  const Fe = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: $e.all(Ze)
  };
  return $e.patch(Ze, Fe), $e.applyData(Ze, Fe);
}
const pointStart = point("start"), pointEnd = point("end");
function position$1($e) {
  return { start: pointStart($e), end: pointEnd($e) };
}
function point($e) {
  return Ze;
  function Ze(Fe) {
    const Ke = Fe && Fe.position && Fe.position[$e] || {};
    return {
      // @ts-expect-error: in practice, null is allowed.
      line: Ke.line || null,
      // @ts-expect-error: in practice, null is allowed.
      column: Ke.column || null,
      // @ts-expect-error: in practice, null is allowed.
      offset: Ke.offset > -1 ? Ke.offset : null
    };
  }
}
function table($e, Ze) {
  const Fe = $e.all(Ze), Ke = Fe.shift(), Ve = [];
  if (Ke) {
    const Qe = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: $e.wrap([Ke], !0)
    };
    $e.patch(Ze.children[0], Qe), Ve.push(Qe);
  }
  if (Fe.length > 0) {
    const Qe = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: $e.wrap(Fe, !0)
    }, at = pointStart(Ze.children[1]), ut = pointEnd(Ze.children[Ze.children.length - 1]);
    at.line && ut.line && (Qe.position = { start: at, end: ut }), Ve.push(Qe);
  }
  const Je = {
    type: "element",
    tagName: "table",
    properties: {},
    children: $e.wrap(Ve, !0)
  };
  return $e.patch(Ze, Je), $e.applyData(Ze, Je);
}
function tableRow($e, Ze, Fe) {
  const Ke = Fe ? Fe.children : void 0, Je = (Ke ? Ke.indexOf(Ze) : 1) === 0 ? "th" : "td", Qe = Fe && Fe.type === "table" ? Fe.align : void 0, at = Qe ? Qe.length : Ze.children.length;
  let ut = -1;
  const lt = [];
  for (; ++ut < at; ) {
    const bt = Ze.children[ut], $t = {}, vt = Qe ? Qe[ut] : void 0;
    vt && ($t.align = vt);
    let wt = { type: "element", tagName: Je, properties: $t, children: [] };
    bt && (wt.children = $e.all(bt), $e.patch(bt, wt), wt = $e.applyData(Ze, wt)), lt.push(wt);
  }
  const dt = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: $e.wrap(lt, !0)
  };
  return $e.patch(Ze, dt), $e.applyData(Ze, dt);
}
function tableCell($e, Ze) {
  const Fe = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: $e.all(Ze)
  };
  return $e.patch(Ze, Fe), $e.applyData(Ze, Fe);
}
const tab = 9, space = 32;
function trimLines($e) {
  const Ze = String($e), Fe = /\r?\n|\r/g;
  let Ke = Fe.exec(Ze), Ve = 0;
  const Je = [];
  for (; Ke; )
    Je.push(
      trimLine(Ze.slice(Ve, Ke.index), Ve > 0, !0),
      Ke[0]
    ), Ve = Ke.index + Ke[0].length, Ke = Fe.exec(Ze);
  return Je.push(trimLine(Ze.slice(Ve), Ve > 0, !1)), Je.join("");
}
function trimLine($e, Ze, Fe) {
  let Ke = 0, Ve = $e.length;
  if (Ze) {
    let Je = $e.codePointAt(Ke);
    for (; Je === tab || Je === space; )
      Ke++, Je = $e.codePointAt(Ke);
  }
  if (Fe) {
    let Je = $e.codePointAt(Ve - 1);
    for (; Je === tab || Je === space; )
      Ve--, Je = $e.codePointAt(Ve - 1);
  }
  return Ve > Ke ? $e.slice(Ke, Ve) : "";
}
function text($e, Ze) {
  const Fe = { type: "text", value: trimLines(String(Ze.value)) };
  return $e.patch(Ze, Fe), $e.applyData(Ze, Fe);
}
function thematicBreak($e, Ze) {
  const Fe = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return $e.patch(Ze, Fe), $e.applyData(Ze, Fe);
}
const handlers = {
  blockquote,
  break: hardBreak,
  code,
  delete: strikethrough,
  emphasis,
  footnoteReference,
  footnote,
  heading,
  html: html$2,
  imageReference,
  image,
  inlineCode,
  linkReference,
  link,
  listItem,
  list,
  paragraph,
  root,
  strong,
  table,
  tableCell,
  tableRow,
  text,
  thematicBreak,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return null;
}
const convert$1 = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function($e) {
    if ($e == null)
      return ok;
    if (typeof $e == "string")
      return typeFactory($e);
    if (typeof $e == "object")
      return Array.isArray($e) ? anyFactory($e) : propsFactory($e);
    if (typeof $e == "function")
      return castFactory($e);
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory($e) {
  const Ze = [];
  let Fe = -1;
  for (; ++Fe < $e.length; )
    Ze[Fe] = convert$1($e[Fe]);
  return castFactory(Ke);
  function Ke(...Ve) {
    let Je = -1;
    for (; ++Je < Ze.length; )
      if (Ze[Je].call(this, ...Ve))
        return !0;
    return !1;
  }
}
function propsFactory($e) {
  return castFactory(Ze);
  function Ze(Fe) {
    let Ke;
    for (Ke in $e)
      if (Fe[Ke] !== $e[Ke])
        return !1;
    return !0;
  }
}
function typeFactory($e) {
  return castFactory(Ze);
  function Ze(Fe) {
    return Fe && Fe.type === $e;
  }
}
function castFactory($e) {
  return Ze;
  function Ze(Fe, ...Ke) {
    return !!(Fe && typeof Fe == "object" && "type" in Fe && $e.call(this, Fe, ...Ke));
  }
}
function ok() {
  return !0;
}
function color($e) {
  return $e;
}
const CONTINUE = !0, EXIT = !1, SKIP = "skip", visitParents = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor<Node>} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function($e, Ze, Fe, Ke) {
    typeof Ze == "function" && typeof Fe != "function" && (Ke = Fe, Fe = Ze, Ze = null);
    const Ve = convert$1(Ze), Je = Ke ? -1 : 1;
    Qe($e, void 0, [])();
    function Qe(at, ut, lt) {
      const dt = at && typeof at == "object" ? at : {};
      if (typeof dt.type == "string") {
        const $t = (
          // `hast`
          typeof dt.tagName == "string" ? dt.tagName : (
            // `xast`
            typeof dt.name == "string" ? dt.name : void 0
          )
        );
        Object.defineProperty(bt, "name", {
          value: "node (" + (at.type + ($t ? "<" + $t + ">" : "")) + ")"
        });
      }
      return bt;
      function bt() {
        let $t = [], vt, wt, xt;
        if ((!Ze || Ve(at, ut, lt[lt.length - 1] || null)) && ($t = toResult(Fe(at, lt)), $t[0] === EXIT))
          return $t;
        if (at.children && $t[0] !== SKIP)
          for (wt = (Ke ? at.children.length : -1) + Je, xt = lt.concat(at); wt > -1 && wt < at.children.length; ) {
            if (vt = Qe(at.children[wt], wt, xt)(), vt[0] === EXIT)
              return vt;
            wt = typeof vt[1] == "number" ? vt[1] : wt + Je;
          }
        return $t;
      }
    }
  }
);
function toResult($e) {
  return Array.isArray($e) ? $e : typeof $e == "number" ? [CONTINUE, $e] : [$e];
}
const visit = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function($e, Ze, Fe, Ke) {
    typeof Ze == "function" && typeof Fe != "function" && (Ke = Fe, Fe = Ze, Ze = null), visitParents($e, Ze, Ve, Ke);
    function Ve(Je, Qe) {
      const at = Qe[Qe.length - 1];
      return Fe(
        Je,
        at ? at.children.indexOf(Je) : null,
        at
      );
    }
  }
);
function generated($e) {
  return !$e || !$e.position || !$e.position.start || !$e.position.start.line || !$e.position.start.column || !$e.position.end || !$e.position.end.line || !$e.position.end.column;
}
const own$4 = {}.hasOwnProperty;
function definitions($e) {
  const Ze = /* @__PURE__ */ Object.create(null);
  if (!$e || !$e.type)
    throw new Error("mdast-util-definitions expected node");
  return visit($e, "definition", (Ke) => {
    const Ve = clean(Ke.identifier);
    Ve && !own$4.call(Ze, Ve) && (Ze[Ve] = Ke);
  }), Fe;
  function Fe(Ke) {
    const Ve = clean(Ke);
    return Ve && own$4.call(Ze, Ve) ? Ze[Ve] : null;
  }
}
function clean($e) {
  return String($e || "").toUpperCase();
}
const own$3 = {}.hasOwnProperty;
function createState($e, Ze) {
  const Fe = Ze || {}, Ke = Fe.allowDangerousHtml || !1, Ve = {};
  return Qe.dangerous = Ke, Qe.clobberPrefix = Fe.clobberPrefix === void 0 || Fe.clobberPrefix === null ? "user-content-" : Fe.clobberPrefix, Qe.footnoteLabel = Fe.footnoteLabel || "Footnotes", Qe.footnoteLabelTagName = Fe.footnoteLabelTagName || "h2", Qe.footnoteLabelProperties = Fe.footnoteLabelProperties || {
    className: ["sr-only"]
  }, Qe.footnoteBackLabel = Fe.footnoteBackLabel || "Back to content", Qe.unknownHandler = Fe.unknownHandler, Qe.passThrough = Fe.passThrough, Qe.handlers = { ...handlers, ...Fe.handlers }, Qe.definition = definitions($e), Qe.footnoteById = Ve, Qe.footnoteOrder = [], Qe.footnoteCounts = {}, Qe.patch = patch, Qe.applyData = applyData, Qe.one = at, Qe.all = ut, Qe.wrap = wrap, Qe.augment = Je, visit($e, "footnoteDefinition", (lt) => {
    const dt = String(lt.identifier).toUpperCase();
    own$3.call(Ve, dt) || (Ve[dt] = lt);
  }), Qe;
  function Je(lt, dt) {
    if (lt && "data" in lt && lt.data) {
      const bt = lt.data;
      bt.hName && (dt.type !== "element" && (dt = {
        type: "element",
        tagName: "",
        properties: {},
        children: []
      }), dt.tagName = bt.hName), dt.type === "element" && bt.hProperties && (dt.properties = { ...dt.properties, ...bt.hProperties }), "children" in dt && dt.children && bt.hChildren && (dt.children = bt.hChildren);
    }
    if (lt) {
      const bt = "type" in lt ? lt : { position: lt };
      generated(bt) || (dt.position = { start: pointStart(bt), end: pointEnd(bt) });
    }
    return dt;
  }
  function Qe(lt, dt, bt, $t) {
    return Array.isArray(bt) && ($t = bt, bt = {}), Je(lt, {
      type: "element",
      tagName: dt,
      properties: bt || {},
      children: $t || []
    });
  }
  function at(lt, dt) {
    return one(Qe, lt, dt);
  }
  function ut(lt) {
    return all$1(Qe, lt);
  }
}
function patch($e, Ze) {
  $e.position && (Ze.position = position$1($e));
}
function applyData($e, Ze) {
  let Fe = Ze;
  if ($e && $e.data) {
    const Ke = $e.data.hName, Ve = $e.data.hChildren, Je = $e.data.hProperties;
    typeof Ke == "string" && (Fe.type === "element" ? Fe.tagName = Ke : Fe = {
      type: "element",
      tagName: Ke,
      properties: {},
      children: []
    }), Fe.type === "element" && Je && (Fe.properties = { ...Fe.properties, ...Je }), "children" in Fe && Fe.children && Ve !== null && Ve !== void 0 && (Fe.children = Ve);
  }
  return Fe;
}
function one($e, Ze, Fe) {
  const Ke = Ze && Ze.type;
  if (!Ke)
    throw new Error("Expected node, got `" + Ze + "`");
  return own$3.call($e.handlers, Ke) ? $e.handlers[Ke]($e, Ze, Fe) : $e.passThrough && $e.passThrough.includes(Ke) ? "children" in Ze ? { ...Ze, children: all$1($e, Ze) } : Ze : $e.unknownHandler ? $e.unknownHandler($e, Ze, Fe) : defaultUnknownHandler($e, Ze);
}
function all$1($e, Ze) {
  const Fe = [];
  if ("children" in Ze) {
    const Ke = Ze.children;
    let Ve = -1;
    for (; ++Ve < Ke.length; ) {
      const Je = one($e, Ke[Ve], Ze);
      if (Je) {
        if (Ve && Ke[Ve - 1].type === "break" && (!Array.isArray(Je) && Je.type === "text" && (Je.value = Je.value.replace(/^\s+/, "")), !Array.isArray(Je) && Je.type === "element")) {
          const Qe = Je.children[0];
          Qe && Qe.type === "text" && (Qe.value = Qe.value.replace(/^\s+/, ""));
        }
        Array.isArray(Je) ? Fe.push(...Je) : Fe.push(Je);
      }
    }
  }
  return Fe;
}
function defaultUnknownHandler($e, Ze) {
  const Fe = Ze.data || {}, Ke = "value" in Ze && !(own$3.call(Fe, "hProperties") || own$3.call(Fe, "hChildren")) ? { type: "text", value: Ze.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: all$1($e, Ze)
  };
  return $e.patch(Ze, Ke), $e.applyData(Ze, Ke);
}
function wrap($e, Ze) {
  const Fe = [];
  let Ke = -1;
  for (Ze && Fe.push({ type: "text", value: `
` }); ++Ke < $e.length; )
    Ke && Fe.push({ type: "text", value: `
` }), Fe.push($e[Ke]);
  return Ze && $e.length > 0 && Fe.push({ type: "text", value: `
` }), Fe;
}
function footer($e) {
  const Ze = [];
  let Fe = -1;
  for (; ++Fe < $e.footnoteOrder.length; ) {
    const Ke = $e.footnoteById[$e.footnoteOrder[Fe]];
    if (!Ke)
      continue;
    const Ve = $e.all(Ke), Je = String(Ke.identifier).toUpperCase(), Qe = normalizeUri(Je.toLowerCase());
    let at = 0;
    const ut = [];
    for (; ++at <= $e.footnoteCounts[Je]; ) {
      const bt = {
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + $e.clobberPrefix + "fnref-" + Qe + (at > 1 ? "-" + at : ""),
          dataFootnoteBackref: !0,
          className: ["data-footnote-backref"],
          ariaLabel: $e.footnoteBackLabel
        },
        children: [{ type: "text", value: "↩" }]
      };
      at > 1 && bt.children.push({
        type: "element",
        tagName: "sup",
        children: [{ type: "text", value: String(at) }]
      }), ut.length > 0 && ut.push({ type: "text", value: " " }), ut.push(bt);
    }
    const lt = Ve[Ve.length - 1];
    if (lt && lt.type === "element" && lt.tagName === "p") {
      const bt = lt.children[lt.children.length - 1];
      bt && bt.type === "text" ? bt.value += " " : lt.children.push({ type: "text", value: " " }), lt.children.push(...ut);
    } else
      Ve.push(...ut);
    const dt = {
      type: "element",
      tagName: "li",
      properties: { id: $e.clobberPrefix + "fn-" + Qe },
      children: $e.wrap(Ve, !0)
    };
    $e.patch(Ke, dt), Ze.push(dt);
  }
  if (Ze.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: $e.footnoteLabelTagName,
          properties: {
            // To do: use structured clone.
            ...JSON.parse(JSON.stringify($e.footnoteLabelProperties)),
            id: "footnote-label"
          },
          children: [{ type: "text", value: $e.footnoteLabel }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: $e.wrap(Ze, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
function toHast($e, Ze) {
  const Fe = createState($e, Ze), Ke = Fe.one($e, null), Ve = footer(Fe);
  return Ve && Ke.children.push({ type: "text", value: `
` }, Ve), Array.isArray(Ke) ? { type: "root", children: Ke } : Ke;
}
const remarkRehype = (
  /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */
  function($e, Ze) {
    return $e && "run" in $e ? bridge($e, Ze) : mutate($e || Ze);
  }
), remarkRehype$1 = remarkRehype;
function bridge($e, Ze) {
  return (Fe, Ke, Ve) => {
    $e.run(toHast(Fe, Ze), Ke, (Je) => {
      Ve(Je);
    });
  };
}
function mutate($e) {
  return (Ze) => toHast(Ze, $e);
}
var propTypes = { exports: {} }, reactIs$1 = { exports: {} }, reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min$1;
function requireReactIs_production_min$1() {
  if (hasRequiredReactIs_production_min$1)
    return reactIs_production_min$1;
  hasRequiredReactIs_production_min$1 = 1;
  var $e = typeof Symbol == "function" && Symbol.for, Ze = $e ? Symbol.for("react.element") : 60103, Fe = $e ? Symbol.for("react.portal") : 60106, Ke = $e ? Symbol.for("react.fragment") : 60107, Ve = $e ? Symbol.for("react.strict_mode") : 60108, Je = $e ? Symbol.for("react.profiler") : 60114, Qe = $e ? Symbol.for("react.provider") : 60109, at = $e ? Symbol.for("react.context") : 60110, ut = $e ? Symbol.for("react.async_mode") : 60111, lt = $e ? Symbol.for("react.concurrent_mode") : 60111, dt = $e ? Symbol.for("react.forward_ref") : 60112, bt = $e ? Symbol.for("react.suspense") : 60113, $t = $e ? Symbol.for("react.suspense_list") : 60120, vt = $e ? Symbol.for("react.memo") : 60115, wt = $e ? Symbol.for("react.lazy") : 60116, xt = $e ? Symbol.for("react.block") : 60121, Et = $e ? Symbol.for("react.fundamental") : 60117, Tt = $e ? Symbol.for("react.responder") : 60118, Rt = $e ? Symbol.for("react.scope") : 60119;
  function Ct(Lt) {
    if (typeof Lt == "object" && Lt !== null) {
      var Ut = Lt.$$typeof;
      switch (Ut) {
        case Ze:
          switch (Lt = Lt.type, Lt) {
            case ut:
            case lt:
            case Ke:
            case Je:
            case Ve:
            case bt:
              return Lt;
            default:
              switch (Lt = Lt && Lt.$$typeof, Lt) {
                case at:
                case dt:
                case wt:
                case vt:
                case Qe:
                  return Lt;
                default:
                  return Ut;
              }
          }
        case Fe:
          return Ut;
      }
    }
  }
  function Zt(Lt) {
    return Ct(Lt) === lt;
  }
  return reactIs_production_min$1.AsyncMode = ut, reactIs_production_min$1.ConcurrentMode = lt, reactIs_production_min$1.ContextConsumer = at, reactIs_production_min$1.ContextProvider = Qe, reactIs_production_min$1.Element = Ze, reactIs_production_min$1.ForwardRef = dt, reactIs_production_min$1.Fragment = Ke, reactIs_production_min$1.Lazy = wt, reactIs_production_min$1.Memo = vt, reactIs_production_min$1.Portal = Fe, reactIs_production_min$1.Profiler = Je, reactIs_production_min$1.StrictMode = Ve, reactIs_production_min$1.Suspense = bt, reactIs_production_min$1.isAsyncMode = function(Lt) {
    return Zt(Lt) || Ct(Lt) === ut;
  }, reactIs_production_min$1.isConcurrentMode = Zt, reactIs_production_min$1.isContextConsumer = function(Lt) {
    return Ct(Lt) === at;
  }, reactIs_production_min$1.isContextProvider = function(Lt) {
    return Ct(Lt) === Qe;
  }, reactIs_production_min$1.isElement = function(Lt) {
    return typeof Lt == "object" && Lt !== null && Lt.$$typeof === Ze;
  }, reactIs_production_min$1.isForwardRef = function(Lt) {
    return Ct(Lt) === dt;
  }, reactIs_production_min$1.isFragment = function(Lt) {
    return Ct(Lt) === Ke;
  }, reactIs_production_min$1.isLazy = function(Lt) {
    return Ct(Lt) === wt;
  }, reactIs_production_min$1.isMemo = function(Lt) {
    return Ct(Lt) === vt;
  }, reactIs_production_min$1.isPortal = function(Lt) {
    return Ct(Lt) === Fe;
  }, reactIs_production_min$1.isProfiler = function(Lt) {
    return Ct(Lt) === Je;
  }, reactIs_production_min$1.isStrictMode = function(Lt) {
    return Ct(Lt) === Ve;
  }, reactIs_production_min$1.isSuspense = function(Lt) {
    return Ct(Lt) === bt;
  }, reactIs_production_min$1.isValidElementType = function(Lt) {
    return typeof Lt == "string" || typeof Lt == "function" || Lt === Ke || Lt === lt || Lt === Je || Lt === Ve || Lt === bt || Lt === $t || typeof Lt == "object" && Lt !== null && (Lt.$$typeof === wt || Lt.$$typeof === vt || Lt.$$typeof === Qe || Lt.$$typeof === at || Lt.$$typeof === dt || Lt.$$typeof === Et || Lt.$$typeof === Tt || Lt.$$typeof === Rt || Lt.$$typeof === xt);
  }, reactIs_production_min$1.typeOf = Ct, reactIs_production_min$1;
}
var reactIs_development$1 = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development$1;
function requireReactIs_development$1() {
  return hasRequiredReactIs_development$1 || (hasRequiredReactIs_development$1 = 1, process.env.NODE_ENV !== "production" && function() {
    var $e = typeof Symbol == "function" && Symbol.for, Ze = $e ? Symbol.for("react.element") : 60103, Fe = $e ? Symbol.for("react.portal") : 60106, Ke = $e ? Symbol.for("react.fragment") : 60107, Ve = $e ? Symbol.for("react.strict_mode") : 60108, Je = $e ? Symbol.for("react.profiler") : 60114, Qe = $e ? Symbol.for("react.provider") : 60109, at = $e ? Symbol.for("react.context") : 60110, ut = $e ? Symbol.for("react.async_mode") : 60111, lt = $e ? Symbol.for("react.concurrent_mode") : 60111, dt = $e ? Symbol.for("react.forward_ref") : 60112, bt = $e ? Symbol.for("react.suspense") : 60113, $t = $e ? Symbol.for("react.suspense_list") : 60120, vt = $e ? Symbol.for("react.memo") : 60115, wt = $e ? Symbol.for("react.lazy") : 60116, xt = $e ? Symbol.for("react.block") : 60121, Et = $e ? Symbol.for("react.fundamental") : 60117, Tt = $e ? Symbol.for("react.responder") : 60118, Rt = $e ? Symbol.for("react.scope") : 60119;
    function Ct(Dt) {
      return typeof Dt == "string" || typeof Dt == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      Dt === Ke || Dt === lt || Dt === Je || Dt === Ve || Dt === bt || Dt === $t || typeof Dt == "object" && Dt !== null && (Dt.$$typeof === wt || Dt.$$typeof === vt || Dt.$$typeof === Qe || Dt.$$typeof === at || Dt.$$typeof === dt || Dt.$$typeof === Et || Dt.$$typeof === Tt || Dt.$$typeof === Rt || Dt.$$typeof === xt);
    }
    function Zt(Dt) {
      if (typeof Dt == "object" && Dt !== null) {
        var Ht = Dt.$$typeof;
        switch (Ht) {
          case Ze:
            var Gt = Dt.type;
            switch (Gt) {
              case ut:
              case lt:
              case Ke:
              case Je:
              case Ve:
              case bt:
                return Gt;
              default:
                var rr = Gt && Gt.$$typeof;
                switch (rr) {
                  case at:
                  case dt:
                  case wt:
                  case vt:
                  case Qe:
                    return rr;
                  default:
                    return Ht;
                }
            }
          case Fe:
            return Ht;
        }
      }
    }
    var Lt = ut, Ut = lt, Pt = at, Ot = Qe, Ft = Ze, gt = dt, We = Ke, Xe = wt, rt = vt, ot = Fe, ft = Je, mt = Ve, yt = bt, pt = !1;
    function Ge(Dt) {
      return pt || (pt = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), ct(Dt) || Zt(Dt) === ut;
    }
    function ct(Dt) {
      return Zt(Dt) === lt;
    }
    function Mt(Dt) {
      return Zt(Dt) === at;
    }
    function St(Dt) {
      return Zt(Dt) === Qe;
    }
    function At(Dt) {
      return typeof Dt == "object" && Dt !== null && Dt.$$typeof === Ze;
    }
    function Nt(Dt) {
      return Zt(Dt) === dt;
    }
    function qt(Dt) {
      return Zt(Dt) === Ke;
    }
    function Qt(Dt) {
      return Zt(Dt) === wt;
    }
    function Xt(Dt) {
      return Zt(Dt) === vt;
    }
    function zt(Dt) {
      return Zt(Dt) === Fe;
    }
    function Kt(Dt) {
      return Zt(Dt) === Je;
    }
    function ur(Dt) {
      return Zt(Dt) === Ve;
    }
    function er(Dt) {
      return Zt(Dt) === bt;
    }
    reactIs_development$1.AsyncMode = Lt, reactIs_development$1.ConcurrentMode = Ut, reactIs_development$1.ContextConsumer = Pt, reactIs_development$1.ContextProvider = Ot, reactIs_development$1.Element = Ft, reactIs_development$1.ForwardRef = gt, reactIs_development$1.Fragment = We, reactIs_development$1.Lazy = Xe, reactIs_development$1.Memo = rt, reactIs_development$1.Portal = ot, reactIs_development$1.Profiler = ft, reactIs_development$1.StrictMode = mt, reactIs_development$1.Suspense = yt, reactIs_development$1.isAsyncMode = Ge, reactIs_development$1.isConcurrentMode = ct, reactIs_development$1.isContextConsumer = Mt, reactIs_development$1.isContextProvider = St, reactIs_development$1.isElement = At, reactIs_development$1.isForwardRef = Nt, reactIs_development$1.isFragment = qt, reactIs_development$1.isLazy = Qt, reactIs_development$1.isMemo = Xt, reactIs_development$1.isPortal = zt, reactIs_development$1.isProfiler = Kt, reactIs_development$1.isStrictMode = ur, reactIs_development$1.isSuspense = er, reactIs_development$1.isValidElementType = Ct, reactIs_development$1.typeOf = Zt;
  }()), reactIs_development$1;
}
var hasRequiredReactIs;
function requireReactIs() {
  return hasRequiredReactIs || (hasRequiredReactIs = 1, process.env.NODE_ENV === "production" ? reactIs$1.exports = requireReactIs_production_min$1() : reactIs$1.exports = requireReactIs_development$1()), reactIs$1.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign, hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign)
    return objectAssign;
  hasRequiredObjectAssign = 1;
  var $e = Object.getOwnPropertySymbols, Ze = Object.prototype.hasOwnProperty, Fe = Object.prototype.propertyIsEnumerable;
  function Ke(Je) {
    if (Je == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(Je);
  }
  function Ve() {
    try {
      if (!Object.assign)
        return !1;
      var Je = new String("abc");
      if (Je[5] = "de", Object.getOwnPropertyNames(Je)[0] === "5")
        return !1;
      for (var Qe = {}, at = 0; at < 10; at++)
        Qe["_" + String.fromCharCode(at)] = at;
      var ut = Object.getOwnPropertyNames(Qe).map(function(dt) {
        return Qe[dt];
      });
      if (ut.join("") !== "0123456789")
        return !1;
      var lt = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(dt) {
        lt[dt] = dt;
      }), Object.keys(Object.assign({}, lt)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return objectAssign = Ve() ? Object.assign : function(Je, Qe) {
    for (var at, ut = Ke(Je), lt, dt = 1; dt < arguments.length; dt++) {
      at = Object(arguments[dt]);
      for (var bt in at)
        Ze.call(at, bt) && (ut[bt] = at[bt]);
      if ($e) {
        lt = $e(at);
        for (var $t = 0; $t < lt.length; $t++)
          Fe.call(at, lt[$t]) && (ut[lt[$t]] = at[lt[$t]]);
      }
    }
    return ut;
  }, objectAssign;
}
var ReactPropTypesSecret_1, hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret)
    return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var $e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ReactPropTypesSecret_1 = $e, ReactPropTypesSecret_1;
}
var has, hasRequiredHas;
function requireHas() {
  return hasRequiredHas || (hasRequiredHas = 1, has = Function.call.bind(Object.prototype.hasOwnProperty)), has;
}
var checkPropTypes_1, hasRequiredCheckPropTypes;
function requireCheckPropTypes() {
  if (hasRequiredCheckPropTypes)
    return checkPropTypes_1;
  hasRequiredCheckPropTypes = 1;
  var $e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var Ze = requireReactPropTypesSecret(), Fe = {}, Ke = requireHas();
    $e = function(Je) {
      var Qe = "Warning: " + Je;
      typeof console < "u" && console.error(Qe);
      try {
        throw new Error(Qe);
      } catch {
      }
    };
  }
  function Ve(Je, Qe, at, ut, lt) {
    if (process.env.NODE_ENV !== "production") {
      for (var dt in Je)
        if (Ke(Je, dt)) {
          var bt;
          try {
            if (typeof Je[dt] != "function") {
              var $t = Error(
                (ut || "React class") + ": " + at + " type `" + dt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Je[dt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw $t.name = "Invariant Violation", $t;
            }
            bt = Je[dt](Qe, dt, ut, at, null, Ze);
          } catch (wt) {
            bt = wt;
          }
          if (bt && !(bt instanceof Error) && $e(
            (ut || "React class") + ": type specification of " + at + " `" + dt + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof bt + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), bt instanceof Error && !(bt.message in Fe)) {
            Fe[bt.message] = !0;
            var vt = lt ? lt() : "";
            $e(
              "Failed " + at + " type: " + bt.message + (vt ?? "")
            );
          }
        }
    }
  }
  return Ve.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (Fe = {});
  }, checkPropTypes_1 = Ve, checkPropTypes_1;
}
var factoryWithTypeCheckers, hasRequiredFactoryWithTypeCheckers;
function requireFactoryWithTypeCheckers() {
  if (hasRequiredFactoryWithTypeCheckers)
    return factoryWithTypeCheckers;
  hasRequiredFactoryWithTypeCheckers = 1;
  var $e = requireReactIs(), Ze = requireObjectAssign(), Fe = requireReactPropTypesSecret(), Ke = requireHas(), Ve = requireCheckPropTypes(), Je = function() {
  };
  process.env.NODE_ENV !== "production" && (Je = function(at) {
    var ut = "Warning: " + at;
    typeof console < "u" && console.error(ut);
    try {
      throw new Error(ut);
    } catch {
    }
  });
  function Qe() {
    return null;
  }
  return factoryWithTypeCheckers = function(at, ut) {
    var lt = typeof Symbol == "function" && Symbol.iterator, dt = "@@iterator";
    function bt(ct) {
      var Mt = ct && (lt && ct[lt] || ct[dt]);
      if (typeof Mt == "function")
        return Mt;
    }
    var $t = "<<anonymous>>", vt = {
      array: Tt("array"),
      bigint: Tt("bigint"),
      bool: Tt("boolean"),
      func: Tt("function"),
      number: Tt("number"),
      object: Tt("object"),
      string: Tt("string"),
      symbol: Tt("symbol"),
      any: Rt(),
      arrayOf: Ct,
      element: Zt(),
      elementType: Lt(),
      instanceOf: Ut,
      node: gt(),
      objectOf: Ot,
      oneOf: Pt,
      oneOfType: Ft,
      shape: Xe,
      exact: rt
    };
    function wt(ct, Mt) {
      return ct === Mt ? ct !== 0 || 1 / ct === 1 / Mt : ct !== ct && Mt !== Mt;
    }
    function xt(ct, Mt) {
      this.message = ct, this.data = Mt && typeof Mt == "object" ? Mt : {}, this.stack = "";
    }
    xt.prototype = Error.prototype;
    function Et(ct) {
      if (process.env.NODE_ENV !== "production")
        var Mt = {}, St = 0;
      function At(qt, Qt, Xt, zt, Kt, ur, er) {
        if (zt = zt || $t, ur = ur || Xt, er !== Fe) {
          if (ut) {
            var Dt = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw Dt.name = "Invariant Violation", Dt;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var Ht = zt + ":" + Xt;
            !Mt[Ht] && // Avoid spamming the console because they are often not actionable except for lib authors
            St < 3 && (Je(
              "You are manually calling a React.PropTypes validation function for the `" + ur + "` prop on `" + zt + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), Mt[Ht] = !0, St++);
          }
        }
        return Qt[Xt] == null ? qt ? Qt[Xt] === null ? new xt("The " + Kt + " `" + ur + "` is marked as required " + ("in `" + zt + "`, but its value is `null`.")) : new xt("The " + Kt + " `" + ur + "` is marked as required in " + ("`" + zt + "`, but its value is `undefined`.")) : null : ct(Qt, Xt, zt, Kt, ur);
      }
      var Nt = At.bind(null, !1);
      return Nt.isRequired = At.bind(null, !0), Nt;
    }
    function Tt(ct) {
      function Mt(St, At, Nt, qt, Qt, Xt) {
        var zt = St[At], Kt = mt(zt);
        if (Kt !== ct) {
          var ur = yt(zt);
          return new xt(
            "Invalid " + qt + " `" + Qt + "` of type " + ("`" + ur + "` supplied to `" + Nt + "`, expected ") + ("`" + ct + "`."),
            { expectedType: ct }
          );
        }
        return null;
      }
      return Et(Mt);
    }
    function Rt() {
      return Et(Qe);
    }
    function Ct(ct) {
      function Mt(St, At, Nt, qt, Qt) {
        if (typeof ct != "function")
          return new xt("Property `" + Qt + "` of component `" + Nt + "` has invalid PropType notation inside arrayOf.");
        var Xt = St[At];
        if (!Array.isArray(Xt)) {
          var zt = mt(Xt);
          return new xt("Invalid " + qt + " `" + Qt + "` of type " + ("`" + zt + "` supplied to `" + Nt + "`, expected an array."));
        }
        for (var Kt = 0; Kt < Xt.length; Kt++) {
          var ur = ct(Xt, Kt, Nt, qt, Qt + "[" + Kt + "]", Fe);
          if (ur instanceof Error)
            return ur;
        }
        return null;
      }
      return Et(Mt);
    }
    function Zt() {
      function ct(Mt, St, At, Nt, qt) {
        var Qt = Mt[St];
        if (!at(Qt)) {
          var Xt = mt(Qt);
          return new xt("Invalid " + Nt + " `" + qt + "` of type " + ("`" + Xt + "` supplied to `" + At + "`, expected a single ReactElement."));
        }
        return null;
      }
      return Et(ct);
    }
    function Lt() {
      function ct(Mt, St, At, Nt, qt) {
        var Qt = Mt[St];
        if (!$e.isValidElementType(Qt)) {
          var Xt = mt(Qt);
          return new xt("Invalid " + Nt + " `" + qt + "` of type " + ("`" + Xt + "` supplied to `" + At + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return Et(ct);
    }
    function Ut(ct) {
      function Mt(St, At, Nt, qt, Qt) {
        if (!(St[At] instanceof ct)) {
          var Xt = ct.name || $t, zt = Ge(St[At]);
          return new xt("Invalid " + qt + " `" + Qt + "` of type " + ("`" + zt + "` supplied to `" + Nt + "`, expected ") + ("instance of `" + Xt + "`."));
        }
        return null;
      }
      return Et(Mt);
    }
    function Pt(ct) {
      if (!Array.isArray(ct))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? Je(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : Je("Invalid argument supplied to oneOf, expected an array.")), Qe;
      function Mt(St, At, Nt, qt, Qt) {
        for (var Xt = St[At], zt = 0; zt < ct.length; zt++)
          if (wt(Xt, ct[zt]))
            return null;
        var Kt = JSON.stringify(ct, function(er, Dt) {
          var Ht = yt(Dt);
          return Ht === "symbol" ? String(Dt) : Dt;
        });
        return new xt("Invalid " + qt + " `" + Qt + "` of value `" + String(Xt) + "` " + ("supplied to `" + Nt + "`, expected one of " + Kt + "."));
      }
      return Et(Mt);
    }
    function Ot(ct) {
      function Mt(St, At, Nt, qt, Qt) {
        if (typeof ct != "function")
          return new xt("Property `" + Qt + "` of component `" + Nt + "` has invalid PropType notation inside objectOf.");
        var Xt = St[At], zt = mt(Xt);
        if (zt !== "object")
          return new xt("Invalid " + qt + " `" + Qt + "` of type " + ("`" + zt + "` supplied to `" + Nt + "`, expected an object."));
        for (var Kt in Xt)
          if (Ke(Xt, Kt)) {
            var ur = ct(Xt, Kt, Nt, qt, Qt + "." + Kt, Fe);
            if (ur instanceof Error)
              return ur;
          }
        return null;
      }
      return Et(Mt);
    }
    function Ft(ct) {
      if (!Array.isArray(ct))
        return process.env.NODE_ENV !== "production" && Je("Invalid argument supplied to oneOfType, expected an instance of array."), Qe;
      for (var Mt = 0; Mt < ct.length; Mt++) {
        var St = ct[Mt];
        if (typeof St != "function")
          return Je(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + pt(St) + " at index " + Mt + "."
          ), Qe;
      }
      function At(Nt, qt, Qt, Xt, zt) {
        for (var Kt = [], ur = 0; ur < ct.length; ur++) {
          var er = ct[ur], Dt = er(Nt, qt, Qt, Xt, zt, Fe);
          if (Dt == null)
            return null;
          Dt.data && Ke(Dt.data, "expectedType") && Kt.push(Dt.data.expectedType);
        }
        var Ht = Kt.length > 0 ? ", expected one of type [" + Kt.join(", ") + "]" : "";
        return new xt("Invalid " + Xt + " `" + zt + "` supplied to " + ("`" + Qt + "`" + Ht + "."));
      }
      return Et(At);
    }
    function gt() {
      function ct(Mt, St, At, Nt, qt) {
        return ot(Mt[St]) ? null : new xt("Invalid " + Nt + " `" + qt + "` supplied to " + ("`" + At + "`, expected a ReactNode."));
      }
      return Et(ct);
    }
    function We(ct, Mt, St, At, Nt) {
      return new xt(
        (ct || "React class") + ": " + Mt + " type `" + St + "." + At + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Nt + "`."
      );
    }
    function Xe(ct) {
      function Mt(St, At, Nt, qt, Qt) {
        var Xt = St[At], zt = mt(Xt);
        if (zt !== "object")
          return new xt("Invalid " + qt + " `" + Qt + "` of type `" + zt + "` " + ("supplied to `" + Nt + "`, expected `object`."));
        for (var Kt in ct) {
          var ur = ct[Kt];
          if (typeof ur != "function")
            return We(Nt, qt, Qt, Kt, yt(ur));
          var er = ur(Xt, Kt, Nt, qt, Qt + "." + Kt, Fe);
          if (er)
            return er;
        }
        return null;
      }
      return Et(Mt);
    }
    function rt(ct) {
      function Mt(St, At, Nt, qt, Qt) {
        var Xt = St[At], zt = mt(Xt);
        if (zt !== "object")
          return new xt("Invalid " + qt + " `" + Qt + "` of type `" + zt + "` " + ("supplied to `" + Nt + "`, expected `object`."));
        var Kt = Ze({}, St[At], ct);
        for (var ur in Kt) {
          var er = ct[ur];
          if (Ke(ct, ur) && typeof er != "function")
            return We(Nt, qt, Qt, ur, yt(er));
          if (!er)
            return new xt(
              "Invalid " + qt + " `" + Qt + "` key `" + ur + "` supplied to `" + Nt + "`.\nBad object: " + JSON.stringify(St[At], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(ct), null, "  ")
            );
          var Dt = er(Xt, ur, Nt, qt, Qt + "." + ur, Fe);
          if (Dt)
            return Dt;
        }
        return null;
      }
      return Et(Mt);
    }
    function ot(ct) {
      switch (typeof ct) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !ct;
        case "object":
          if (Array.isArray(ct))
            return ct.every(ot);
          if (ct === null || at(ct))
            return !0;
          var Mt = bt(ct);
          if (Mt) {
            var St = Mt.call(ct), At;
            if (Mt !== ct.entries) {
              for (; !(At = St.next()).done; )
                if (!ot(At.value))
                  return !1;
            } else
              for (; !(At = St.next()).done; ) {
                var Nt = At.value;
                if (Nt && !ot(Nt[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function ft(ct, Mt) {
      return ct === "symbol" ? !0 : Mt ? Mt["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && Mt instanceof Symbol : !1;
    }
    function mt(ct) {
      var Mt = typeof ct;
      return Array.isArray(ct) ? "array" : ct instanceof RegExp ? "object" : ft(Mt, ct) ? "symbol" : Mt;
    }
    function yt(ct) {
      if (typeof ct > "u" || ct === null)
        return "" + ct;
      var Mt = mt(ct);
      if (Mt === "object") {
        if (ct instanceof Date)
          return "date";
        if (ct instanceof RegExp)
          return "regexp";
      }
      return Mt;
    }
    function pt(ct) {
      var Mt = yt(ct);
      switch (Mt) {
        case "array":
        case "object":
          return "an " + Mt;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + Mt;
        default:
          return Mt;
      }
    }
    function Ge(ct) {
      return !ct.constructor || !ct.constructor.name ? $t : ct.constructor.name;
    }
    return vt.checkPropTypes = Ve, vt.resetWarningCache = Ve.resetWarningCache, vt.PropTypes = vt, vt;
  }, factoryWithTypeCheckers;
}
var factoryWithThrowingShims, hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims)
    return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var $e = requireReactPropTypesSecret();
  function Ze() {
  }
  function Fe() {
  }
  return Fe.resetWarningCache = Ze, factoryWithThrowingShims = function() {
    function Ke(Qe, at, ut, lt, dt, bt) {
      if (bt !== $e) {
        var $t = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw $t.name = "Invariant Violation", $t;
      }
    }
    Ke.isRequired = Ke;
    function Ve() {
      return Ke;
    }
    var Je = {
      array: Ke,
      bigint: Ke,
      bool: Ke,
      func: Ke,
      number: Ke,
      object: Ke,
      string: Ke,
      symbol: Ke,
      any: Ke,
      arrayOf: Ve,
      element: Ke,
      elementType: Ke,
      instanceOf: Ve,
      node: Ke,
      objectOf: Ve,
      oneOf: Ve,
      oneOfType: Ve,
      shape: Ve,
      exact: Ve,
      checkPropTypes: Fe,
      resetWarningCache: Ze
    };
    return Je.PropTypes = Je, Je;
  }, factoryWithThrowingShims;
}
if (process.env.NODE_ENV !== "production") {
  var ReactIs$1 = requireReactIs(), throwOnDirectAccess = !0;
  propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs$1.isElement, throwOnDirectAccess);
} else
  propTypes.exports = requireFactoryWithThrowingShims()();
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
class Schema {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(Ze, Fe, Ke) {
    this.property = Ze, this.normal = Fe, Ke && (this.space = Ke);
  }
}
Schema.prototype.property = {};
Schema.prototype.normal = {};
Schema.prototype.space = null;
function merge$3($e, Ze) {
  const Fe = {}, Ke = {};
  let Ve = -1;
  for (; ++Ve < $e.length; )
    Object.assign(Fe, $e[Ve].property), Object.assign(Ke, $e[Ve].normal);
  return new Schema(Fe, Ke, Ze);
}
function normalize$1($e) {
  return $e.toLowerCase();
}
class Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(Ze, Fe) {
    this.property = Ze, this.attribute = Fe;
  }
}
Info.prototype.space = null;
Info.prototype.boolean = !1;
Info.prototype.booleanish = !1;
Info.prototype.overloadedBoolean = !1;
Info.prototype.number = !1;
Info.prototype.commaSeparated = !1;
Info.prototype.spaceSeparated = !1;
Info.prototype.commaOrSpaceSeparated = !1;
Info.prototype.mustUseProperty = !1;
Info.prototype.defined = !1;
let powers = 0;
const boolean = increment(), booleanish = increment(), overloadedBoolean = increment(), number = increment(), spaceSeparated = increment(), commaSeparated = increment(), commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}
const types$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean,
  booleanish,
  commaOrSpaceSeparated,
  commaSeparated,
  number,
  overloadedBoolean,
  spaceSeparated
}, Symbol.toStringTag, { value: "Module" })), checks = Object.keys(types$1);
class DefinedInfo extends Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(Ze, Fe, Ke, Ve) {
    let Je = -1;
    if (super(Ze, Fe), mark(this, "space", Ve), typeof Ke == "number")
      for (; ++Je < checks.length; ) {
        const Qe = checks[Je];
        mark(this, checks[Je], (Ke & types$1[Qe]) === types$1[Qe]);
      }
  }
}
DefinedInfo.prototype.defined = !0;
function mark($e, Ze, Fe) {
  Fe && ($e[Ze] = Fe);
}
const own$2 = {}.hasOwnProperty;
function create$1($e) {
  const Ze = {}, Fe = {};
  let Ke;
  for (Ke in $e.properties)
    if (own$2.call($e.properties, Ke)) {
      const Ve = $e.properties[Ke], Je = new DefinedInfo(
        Ke,
        $e.transform($e.attributes || {}, Ke),
        Ve,
        $e.space
      );
      $e.mustUseProperty && $e.mustUseProperty.includes(Ke) && (Je.mustUseProperty = !0), Ze[Ke] = Je, Fe[normalize$1(Ke)] = Ke, Fe[normalize$1(Je.attribute)] = Ke;
    }
  return new Schema(Ze, Fe, $e.space);
}
const xlink = create$1({
  space: "xlink",
  transform($e, Ze) {
    return "xlink:" + Ze.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), xml = create$1({
  space: "xml",
  transform($e, Ze) {
    return "xml:" + Ze.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function caseSensitiveTransform($e, Ze) {
  return Ze in $e ? $e[Ze] : Ze;
}
function caseInsensitiveTransform($e, Ze) {
  return caseSensitiveTransform($e, Ze.toLowerCase());
}
const xmlns = create$1({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: caseInsensitiveTransform,
  properties: { xmlns: null, xmlnsXLink: null }
}), aria = create$1({
  transform($e, Ze) {
    return Ze === "role" ? Ze : "aria-" + Ze.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  }
}), html$1 = create$1({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    capture: boolean,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  }
}), svg$1 = create$1({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), valid = /^data[-\w.:]+$/i, dash = /-[a-z]/g, cap = /[A-Z]/g;
function find$1($e, Ze) {
  const Fe = normalize$1(Ze);
  let Ke = Ze, Ve = Info;
  if (Fe in $e.normal)
    return $e.property[$e.normal[Fe]];
  if (Fe.length > 4 && Fe.slice(0, 4) === "data" && valid.test(Ze)) {
    if (Ze.charAt(4) === "-") {
      const Je = Ze.slice(5).replace(dash, camelcase);
      Ke = "data" + Je.charAt(0).toUpperCase() + Je.slice(1);
    } else {
      const Je = Ze.slice(4);
      if (!dash.test(Je)) {
        let Qe = Je.replace(cap, kebab);
        Qe.charAt(0) !== "-" && (Qe = "-" + Qe), Ze = "data" + Qe;
      }
    }
    Ve = DefinedInfo;
  }
  return new Ve(Ke, Ze);
}
function kebab($e) {
  return "-" + $e.toLowerCase();
}
function camelcase($e) {
  return $e.charAt(1).toUpperCase();
}
const hastToReact = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, html = merge$3([xml, xlink, xmlns, aria, html$1], "html"), svg = merge$3([xml, xlink, xmlns, aria, svg$1], "svg");
function rehypeFilter($e) {
  if ($e.allowedElements && $e.disallowedElements)
    throw new TypeError(
      "Only one of `allowedElements` and `disallowedElements` should be defined"
    );
  if ($e.allowedElements || $e.disallowedElements || $e.allowElement)
    return (Ze) => {
      visit(Ze, "element", (Fe, Ke, Ve) => {
        const Je = (
          /** @type {Element|Root} */
          Ve
        );
        let Qe;
        if ($e.allowedElements ? Qe = !$e.allowedElements.includes(Fe.tagName) : $e.disallowedElements && (Qe = $e.disallowedElements.includes(Fe.tagName)), !Qe && $e.allowElement && typeof Ke == "number" && (Qe = !$e.allowElement(Fe, Ke, Je)), Qe && typeof Ke == "number")
          return $e.unwrapDisallowed && Fe.children ? Je.children.splice(Ke, 1, ...Fe.children) : Je.children.splice(Ke, 1), Ke;
      });
    };
}
var reactIs = { exports: {} }, reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min)
    return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var $e = Symbol.for("react.element"), Ze = Symbol.for("react.portal"), Fe = Symbol.for("react.fragment"), Ke = Symbol.for("react.strict_mode"), Ve = Symbol.for("react.profiler"), Je = Symbol.for("react.provider"), Qe = Symbol.for("react.context"), at = Symbol.for("react.server_context"), ut = Symbol.for("react.forward_ref"), lt = Symbol.for("react.suspense"), dt = Symbol.for("react.suspense_list"), bt = Symbol.for("react.memo"), $t = Symbol.for("react.lazy"), vt = Symbol.for("react.offscreen"), wt;
  wt = Symbol.for("react.module.reference");
  function xt(Et) {
    if (typeof Et == "object" && Et !== null) {
      var Tt = Et.$$typeof;
      switch (Tt) {
        case $e:
          switch (Et = Et.type, Et) {
            case Fe:
            case Ve:
            case Ke:
            case lt:
            case dt:
              return Et;
            default:
              switch (Et = Et && Et.$$typeof, Et) {
                case at:
                case Qe:
                case ut:
                case $t:
                case bt:
                case Je:
                  return Et;
                default:
                  return Tt;
              }
          }
        case Ze:
          return Tt;
      }
    }
  }
  return reactIs_production_min.ContextConsumer = Qe, reactIs_production_min.ContextProvider = Je, reactIs_production_min.Element = $e, reactIs_production_min.ForwardRef = ut, reactIs_production_min.Fragment = Fe, reactIs_production_min.Lazy = $t, reactIs_production_min.Memo = bt, reactIs_production_min.Portal = Ze, reactIs_production_min.Profiler = Ve, reactIs_production_min.StrictMode = Ke, reactIs_production_min.Suspense = lt, reactIs_production_min.SuspenseList = dt, reactIs_production_min.isAsyncMode = function() {
    return !1;
  }, reactIs_production_min.isConcurrentMode = function() {
    return !1;
  }, reactIs_production_min.isContextConsumer = function(Et) {
    return xt(Et) === Qe;
  }, reactIs_production_min.isContextProvider = function(Et) {
    return xt(Et) === Je;
  }, reactIs_production_min.isElement = function(Et) {
    return typeof Et == "object" && Et !== null && Et.$$typeof === $e;
  }, reactIs_production_min.isForwardRef = function(Et) {
    return xt(Et) === ut;
  }, reactIs_production_min.isFragment = function(Et) {
    return xt(Et) === Fe;
  }, reactIs_production_min.isLazy = function(Et) {
    return xt(Et) === $t;
  }, reactIs_production_min.isMemo = function(Et) {
    return xt(Et) === bt;
  }, reactIs_production_min.isPortal = function(Et) {
    return xt(Et) === Ze;
  }, reactIs_production_min.isProfiler = function(Et) {
    return xt(Et) === Ve;
  }, reactIs_production_min.isStrictMode = function(Et) {
    return xt(Et) === Ke;
  }, reactIs_production_min.isSuspense = function(Et) {
    return xt(Et) === lt;
  }, reactIs_production_min.isSuspenseList = function(Et) {
    return xt(Et) === dt;
  }, reactIs_production_min.isValidElementType = function(Et) {
    return typeof Et == "string" || typeof Et == "function" || Et === Fe || Et === Ve || Et === Ke || Et === lt || Et === dt || Et === vt || typeof Et == "object" && Et !== null && (Et.$$typeof === $t || Et.$$typeof === bt || Et.$$typeof === Je || Et.$$typeof === Qe || Et.$$typeof === ut || Et.$$typeof === wt || Et.getModuleId !== void 0);
  }, reactIs_production_min.typeOf = xt, reactIs_production_min;
}
var reactIs_development = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development;
function requireReactIs_development() {
  return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, process.env.NODE_ENV !== "production" && function() {
    var $e = Symbol.for("react.element"), Ze = Symbol.for("react.portal"), Fe = Symbol.for("react.fragment"), Ke = Symbol.for("react.strict_mode"), Ve = Symbol.for("react.profiler"), Je = Symbol.for("react.provider"), Qe = Symbol.for("react.context"), at = Symbol.for("react.server_context"), ut = Symbol.for("react.forward_ref"), lt = Symbol.for("react.suspense"), dt = Symbol.for("react.suspense_list"), bt = Symbol.for("react.memo"), $t = Symbol.for("react.lazy"), vt = Symbol.for("react.offscreen"), wt = !1, xt = !1, Et = !1, Tt = !1, Rt = !1, Ct;
    Ct = Symbol.for("react.module.reference");
    function Zt(Gt) {
      return !!(typeof Gt == "string" || typeof Gt == "function" || Gt === Fe || Gt === Ve || Rt || Gt === Ke || Gt === lt || Gt === dt || Tt || Gt === vt || wt || xt || Et || typeof Gt == "object" && Gt !== null && (Gt.$$typeof === $t || Gt.$$typeof === bt || Gt.$$typeof === Je || Gt.$$typeof === Qe || Gt.$$typeof === ut || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Gt.$$typeof === Ct || Gt.getModuleId !== void 0));
    }
    function Lt(Gt) {
      if (typeof Gt == "object" && Gt !== null) {
        var rr = Gt.$$typeof;
        switch (rr) {
          case $e:
            var sr = Gt.type;
            switch (sr) {
              case Fe:
              case Ve:
              case Ke:
              case lt:
              case dt:
                return sr;
              default:
                var Jt = sr && sr.$$typeof;
                switch (Jt) {
                  case at:
                  case Qe:
                  case ut:
                  case $t:
                  case bt:
                  case Je:
                    return Jt;
                  default:
                    return rr;
                }
            }
          case Ze:
            return rr;
        }
      }
    }
    var Ut = Qe, Pt = Je, Ot = $e, Ft = ut, gt = Fe, We = $t, Xe = bt, rt = Ze, ot = Ve, ft = Ke, mt = lt, yt = dt, pt = !1, Ge = !1;
    function ct(Gt) {
      return pt || (pt = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function Mt(Gt) {
      return Ge || (Ge = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function St(Gt) {
      return Lt(Gt) === Qe;
    }
    function At(Gt) {
      return Lt(Gt) === Je;
    }
    function Nt(Gt) {
      return typeof Gt == "object" && Gt !== null && Gt.$$typeof === $e;
    }
    function qt(Gt) {
      return Lt(Gt) === ut;
    }
    function Qt(Gt) {
      return Lt(Gt) === Fe;
    }
    function Xt(Gt) {
      return Lt(Gt) === $t;
    }
    function zt(Gt) {
      return Lt(Gt) === bt;
    }
    function Kt(Gt) {
      return Lt(Gt) === Ze;
    }
    function ur(Gt) {
      return Lt(Gt) === Ve;
    }
    function er(Gt) {
      return Lt(Gt) === Ke;
    }
    function Dt(Gt) {
      return Lt(Gt) === lt;
    }
    function Ht(Gt) {
      return Lt(Gt) === dt;
    }
    reactIs_development.ContextConsumer = Ut, reactIs_development.ContextProvider = Pt, reactIs_development.Element = Ot, reactIs_development.ForwardRef = Ft, reactIs_development.Fragment = gt, reactIs_development.Lazy = We, reactIs_development.Memo = Xe, reactIs_development.Portal = rt, reactIs_development.Profiler = ot, reactIs_development.StrictMode = ft, reactIs_development.Suspense = mt, reactIs_development.SuspenseList = yt, reactIs_development.isAsyncMode = ct, reactIs_development.isConcurrentMode = Mt, reactIs_development.isContextConsumer = St, reactIs_development.isContextProvider = At, reactIs_development.isElement = Nt, reactIs_development.isForwardRef = qt, reactIs_development.isFragment = Qt, reactIs_development.isLazy = Xt, reactIs_development.isMemo = zt, reactIs_development.isPortal = Kt, reactIs_development.isProfiler = ur, reactIs_development.isStrictMode = er, reactIs_development.isSuspense = Dt, reactIs_development.isSuspenseList = Ht, reactIs_development.isValidElementType = Zt, reactIs_development.typeOf = Lt;
  }()), reactIs_development;
}
process.env.NODE_ENV === "production" ? reactIs.exports = requireReactIs_production_min() : reactIs.exports = requireReactIs_development();
var reactIsExports = reactIs.exports;
const ReactIs = /* @__PURE__ */ getDefaultExportFromCjs(reactIsExports);
function whitespace($e) {
  const Ze = (
    // @ts-expect-error looks like a node.
    $e && typeof $e == "object" && $e.type === "text" ? (
      // @ts-expect-error looks like a text.
      $e.value || ""
    ) : $e
  );
  return typeof Ze == "string" && Ze.replace(/[ \t\n\f\r]/g, "") === "";
}
function stringify$2($e) {
  return $e.join(" ").trim();
}
function stringify($e, Ze) {
  const Fe = Ze || {};
  return ($e[$e.length - 1] === "" ? [...$e, ""] : $e).join(
    (Fe.padRight ? " " : "") + "," + (Fe.padLeft === !1 ? "" : " ")
  ).trim();
}
var styleToObject = { exports: {} }, COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, NEWLINE_REGEX = /\n/g, WHITESPACE_REGEX = /^\s*/, PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, COLON_REGEX = /^:\s*/, VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, SEMICOLON_REGEX = /^[;\s]*/, TRIM_REGEX = /^\s+|\s+$/g, NEWLINE = `
`, FORWARD_SLASH = "/", ASTERISK = "*", EMPTY_STRING = "", TYPE_COMMENT = "comment", TYPE_DECLARATION = "declaration", inlineStyleParser = function($e, Ze) {
  if (typeof $e != "string")
    throw new TypeError("First argument must be a string");
  if (!$e)
    return [];
  Ze = Ze || {};
  var Fe = 1, Ke = 1;
  function Ve(wt) {
    var xt = wt.match(NEWLINE_REGEX);
    xt && (Fe += xt.length);
    var Et = wt.lastIndexOf(NEWLINE);
    Ke = ~Et ? wt.length - Et : Ke + wt.length;
  }
  function Je() {
    var wt = { line: Fe, column: Ke };
    return function(xt) {
      return xt.position = new Qe(wt), lt(), xt;
    };
  }
  function Qe(wt) {
    this.start = wt, this.end = { line: Fe, column: Ke }, this.source = Ze.source;
  }
  Qe.prototype.content = $e;
  function at(wt) {
    var xt = new Error(
      Ze.source + ":" + Fe + ":" + Ke + ": " + wt
    );
    if (xt.reason = wt, xt.filename = Ze.source, xt.line = Fe, xt.column = Ke, xt.source = $e, !Ze.silent)
      throw xt;
  }
  function ut(wt) {
    var xt = wt.exec($e);
    if (xt) {
      var Et = xt[0];
      return Ve(Et), $e = $e.slice(Et.length), xt;
    }
  }
  function lt() {
    ut(WHITESPACE_REGEX);
  }
  function dt(wt) {
    var xt;
    for (wt = wt || []; xt = bt(); )
      xt !== !1 && wt.push(xt);
    return wt;
  }
  function bt() {
    var wt = Je();
    if (!(FORWARD_SLASH != $e.charAt(0) || ASTERISK != $e.charAt(1))) {
      for (var xt = 2; EMPTY_STRING != $e.charAt(xt) && (ASTERISK != $e.charAt(xt) || FORWARD_SLASH != $e.charAt(xt + 1)); )
        ++xt;
      if (xt += 2, EMPTY_STRING === $e.charAt(xt - 1))
        return at("End of comment missing");
      var Et = $e.slice(2, xt - 2);
      return Ke += 2, Ve(Et), $e = $e.slice(xt), Ke += 2, wt({
        type: TYPE_COMMENT,
        comment: Et
      });
    }
  }
  function $t() {
    var wt = Je(), xt = ut(PROPERTY_REGEX);
    if (xt) {
      if (bt(), !ut(COLON_REGEX))
        return at("property missing ':'");
      var Et = ut(VALUE_REGEX), Tt = wt({
        type: TYPE_DECLARATION,
        property: trim$2(xt[0].replace(COMMENT_REGEX, EMPTY_STRING)),
        value: Et ? trim$2(Et[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
      });
      return ut(SEMICOLON_REGEX), Tt;
    }
  }
  function vt() {
    var wt = [];
    dt(wt);
    for (var xt; xt = $t(); )
      xt !== !1 && (wt.push(xt), dt(wt));
    return wt;
  }
  return lt(), vt();
};
function trim$2($e) {
  return $e ? $e.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
}
var parse$6 = inlineStyleParser;
function StyleToObject($e, Ze) {
  var Fe = null;
  if (!$e || typeof $e != "string")
    return Fe;
  for (var Ke, Ve = parse$6($e), Je = typeof Ze == "function", Qe, at, ut = 0, lt = Ve.length; ut < lt; ut++)
    Ke = Ve[ut], Qe = Ke.property, at = Ke.value, Je ? Ze(Qe, at, Ke) : at && (Fe || (Fe = {}), Fe[Qe] = at);
  return Fe;
}
styleToObject.exports = StyleToObject;
styleToObject.exports.default = StyleToObject;
var styleToObjectExports = styleToObject.exports;
const StyleToObject$1 = /* @__PURE__ */ getDefaultExportFromCjs(styleToObjectExports), own$1 = {}.hasOwnProperty, tableElements = /* @__PURE__ */ new Set(["table", "thead", "tbody", "tfoot", "tr"]);
function childrenToReact($e, Ze) {
  const Fe = [];
  let Ke = -1, Ve;
  for (; ++Ke < Ze.children.length; )
    Ve = Ze.children[Ke], Ve.type === "element" ? Fe.push(toReact($e, Ve, Ke, Ze)) : Ve.type === "text" ? (Ze.type !== "element" || !tableElements.has(Ze.tagName) || !whitespace(Ve)) && Fe.push(Ve.value) : Ve.type === "raw" && !$e.options.skipHtml && Fe.push(Ve.value);
  return Fe;
}
function toReact($e, Ze, Fe, Ke) {
  const Ve = $e.options, Je = Ve.transformLinkUri === void 0 ? uriTransformer : Ve.transformLinkUri, Qe = $e.schema, at = Ze.tagName, ut = {};
  let lt = Qe, dt;
  if (Qe.space === "html" && at === "svg" && (lt = svg, $e.schema = lt), Ze.properties)
    for (dt in Ze.properties)
      own$1.call(Ze.properties, dt) && addProperty(ut, dt, Ze.properties[dt], $e);
  (at === "ol" || at === "ul") && $e.listDepth++;
  const bt = childrenToReact($e, Ze);
  (at === "ol" || at === "ul") && $e.listDepth--, $e.schema = Qe;
  const $t = Ze.position || {
    start: { line: null, column: null, offset: null },
    end: { line: null, column: null, offset: null }
  }, vt = Ve.components && own$1.call(Ve.components, at) ? Ve.components[at] : at, wt = typeof vt == "string" || vt === React__default.Fragment;
  if (!ReactIs.isValidElementType(vt))
    throw new TypeError(
      `Component for name \`${at}\` not defined or is not renderable`
    );
  if (ut.key = Fe, at === "a" && Ve.linkTarget && (ut.target = typeof Ve.linkTarget == "function" ? Ve.linkTarget(
    String(ut.href || ""),
    Ze.children,
    typeof ut.title == "string" ? ut.title : null
  ) : Ve.linkTarget), at === "a" && Je && (ut.href = Je(
    String(ut.href || ""),
    Ze.children,
    typeof ut.title == "string" ? ut.title : null
  )), !wt && at === "code" && Ke.type === "element" && Ke.tagName !== "pre" && (ut.inline = !0), !wt && (at === "h1" || at === "h2" || at === "h3" || at === "h4" || at === "h5" || at === "h6") && (ut.level = Number.parseInt(at.charAt(1), 10)), at === "img" && Ve.transformImageUri && (ut.src = Ve.transformImageUri(
    String(ut.src || ""),
    String(ut.alt || ""),
    typeof ut.title == "string" ? ut.title : null
  )), !wt && at === "li" && Ke.type === "element") {
    const xt = getInputElement(Ze);
    ut.checked = xt && xt.properties ? !!xt.properties.checked : null, ut.index = getElementsBeforeCount(Ke, Ze), ut.ordered = Ke.tagName === "ol";
  }
  return !wt && (at === "ol" || at === "ul") && (ut.ordered = at === "ol", ut.depth = $e.listDepth), (at === "td" || at === "th") && (ut.align && (ut.style || (ut.style = {}), ut.style.textAlign = ut.align, delete ut.align), wt || (ut.isHeader = at === "th")), !wt && at === "tr" && Ke.type === "element" && (ut.isHeader = Ke.tagName === "thead"), Ve.sourcePos && (ut["data-sourcepos"] = flattenPosition($t)), !wt && Ve.rawSourcePos && (ut.sourcePosition = Ze.position), !wt && Ve.includeElementIndex && (ut.index = getElementsBeforeCount(Ke, Ze), ut.siblingCount = getElementsBeforeCount(Ke)), wt || (ut.node = Ze), bt.length > 0 ? React__default.createElement(vt, ut, bt) : React__default.createElement(vt, ut);
}
function getInputElement($e) {
  let Ze = -1;
  for (; ++Ze < $e.children.length; ) {
    const Fe = $e.children[Ze];
    if (Fe.type === "element" && Fe.tagName === "input")
      return Fe;
  }
  return null;
}
function getElementsBeforeCount($e, Ze) {
  let Fe = -1, Ke = 0;
  for (; ++Fe < $e.children.length && $e.children[Fe] !== Ze; )
    $e.children[Fe].type === "element" && Ke++;
  return Ke;
}
function addProperty($e, Ze, Fe, Ke) {
  const Ve = find$1(Ke.schema, Ze);
  let Je = Fe;
  Je == null || Je !== Je || (Array.isArray(Je) && (Je = Ve.commaSeparated ? stringify(Je) : stringify$2(Je)), Ve.property === "style" && typeof Je == "string" && (Je = parseStyle(Je)), Ve.space && Ve.property ? $e[own$1.call(hastToReact, Ve.property) ? hastToReact[Ve.property] : Ve.property] = Je : Ve.attribute && ($e[Ve.attribute] = Je));
}
function parseStyle($e) {
  const Ze = {};
  try {
    StyleToObject$1($e, Fe);
  } catch {
  }
  return Ze;
  function Fe(Ke, Ve) {
    const Je = Ke.slice(0, 4) === "-ms-" ? `ms-${Ke.slice(4)}` : Ke;
    Ze[Je.replace(/-([a-z])/g, styleReplacer)] = Ve;
  }
}
function styleReplacer($e, Ze) {
  return Ze.toUpperCase();
}
function flattenPosition($e) {
  return [
    $e.start.line,
    ":",
    $e.start.column,
    "-",
    $e.end.line,
    ":",
    $e.end.column
  ].map(String).join("");
}
const own = {}.hasOwnProperty, changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", deprecated = {
  plugins: { to: "remarkPlugins", id: "change-plugins-to-remarkplugins" },
  renderers: { to: "components", id: "change-renderers-to-components" },
  astPlugins: { id: "remove-buggy-html-in-markdown-parser" },
  allowDangerousHtml: { id: "remove-buggy-html-in-markdown-parser" },
  escapeHtml: { id: "remove-buggy-html-in-markdown-parser" },
  source: { to: "children", id: "change-source-to-children" },
  allowNode: {
    to: "allowElement",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  allowedTypes: {
    to: "allowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  disallowedTypes: {
    to: "disallowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  includeNodeIndex: {
    to: "includeElementIndex",
    id: "change-includenodeindex-to-includeelementindex"
  }
};
function ReactMarkdown($e) {
  for (const Je in deprecated)
    if (own.call(deprecated, Je) && own.call($e, Je)) {
      const Qe = deprecated[Je];
      console.warn(
        `[react-markdown] Warning: please ${Qe.to ? `use \`${Qe.to}\` instead of` : "remove"} \`${Je}\` (see <${changelog}#${Qe.id}> for more info)`
      ), delete deprecated[Je];
    }
  const Ze = unified().use(remarkParse).use($e.remarkPlugins || []).use(remarkRehype$1, {
    ...$e.remarkRehypeOptions,
    allowDangerousHtml: !0
  }).use($e.rehypePlugins || []).use(rehypeFilter, $e), Fe = new VFile();
  typeof $e.children == "string" ? Fe.value = $e.children : $e.children !== void 0 && $e.children !== null && console.warn(
    `[react-markdown] Warning: please pass a string as \`children\` (not: \`${$e.children}\`)`
  );
  const Ke = Ze.runSync(Ze.parse(Fe), Fe);
  if (Ke.type !== "root")
    throw new TypeError("Expected a `root` node");
  let Ve = React__default.createElement(
    React__default.Fragment,
    {},
    childrenToReact({ options: $e, schema: html, listDepth: 0 }, Ke)
  );
  return $e.className && (Ve = React__default.createElement("div", { className: $e.className }, Ve)), Ve;
}
ReactMarkdown.propTypes = {
  // Core options:
  children: PropTypes.string,
  // Layout options:
  className: PropTypes.string,
  // Filter options:
  allowElement: PropTypes.func,
  allowedElements: PropTypes.arrayOf(PropTypes.string),
  disallowedElements: PropTypes.arrayOf(PropTypes.string),
  unwrapDisallowed: PropTypes.bool,
  // Plugin options:
  remarkPlugins: PropTypes.arrayOf(
    PropTypes.oneOfType([
      PropTypes.object,
      PropTypes.func,
      PropTypes.arrayOf(
        PropTypes.oneOfType([
          PropTypes.bool,
          PropTypes.string,
          PropTypes.object,
          PropTypes.func,
          PropTypes.arrayOf(
            // prettier-ignore
            // type-coverage:ignore-next-line
            PropTypes.any
          )
        ])
      )
    ])
  ),
  rehypePlugins: PropTypes.arrayOf(
    PropTypes.oneOfType([
      PropTypes.object,
      PropTypes.func,
      PropTypes.arrayOf(
        PropTypes.oneOfType([
          PropTypes.bool,
          PropTypes.string,
          PropTypes.object,
          PropTypes.func,
          PropTypes.arrayOf(
            // prettier-ignore
            // type-coverage:ignore-next-line
            PropTypes.any
          )
        ])
      )
    ])
  ),
  // Transform options:
  sourcePos: PropTypes.bool,
  rawSourcePos: PropTypes.bool,
  skipHtml: PropTypes.bool,
  includeElementIndex: PropTypes.bool,
  transformLinkUri: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
  linkTarget: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
  transformImageUri: PropTypes.func,
  components: PropTypes.object
};
const Text = ({ text: $e, type: Ze, styles: Fe }) => {
  const Ke = Fe == null ? void 0 : Fe[Ze], Ve = {
    h1: ({ node: Je, ...Qe }) => /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { ...Qe, ...Ke == null ? void 0 : Ke.heading1 }),
    h2: ({ node: Je, ...Qe }) => /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { ...Qe, ...Ke == null ? void 0 : Ke.heading2 }),
    h3: ({ node: Je, ...Qe }) => /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { ...Qe, ...Ke == null ? void 0 : Ke.heading3 }),
    h4: "h3",
    h5: "h3",
    h6: "h3",
    em: ({ node: Je, ...Qe }) => /* @__PURE__ */ jsxRuntimeExports.jsx("em", { ...Qe, ...Ke == null ? void 0 : Ke.italic }),
    strong: ({ node: Je, ...Qe }) => /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { ...Qe, ...Ke == null ? void 0 : Ke.bold }),
    p: ({ node: Je, ...Qe }) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { ...Qe, ...Ke == null ? void 0 : Ke.text }),
    hr: ({ node: Je, ...Qe }) => /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { ...Qe, ...Ke == null ? void 0 : Ke.horizontalRule }),
    a: ({ node: Je, ...Qe }) => /* @__PURE__ */ jsxRuntimeExports.jsx("a", { ...Qe, ...Ke == null ? void 0 : Ke.link }),
    ol: ({ node: Je, ordered: Qe, ...at }) => /* @__PURE__ */ jsxRuntimeExports.jsx("ol", { ...at, ...Ke == null ? void 0 : Ke.orderedList }),
    ul: ({ node: Je, ordered: Qe, ...at }) => /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { ...at, ...Ke == null ? void 0 : Ke.unorderedList }),
    li: ({ node: Je, ordered: Qe, ...at }) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { ...at, ...Ke == null ? void 0 : Ke.listItem }),
    br: ({ node: Je, ...Qe }) => /* @__PURE__ */ jsxRuntimeExports.jsx("br", { ...Qe, ...Ke == null ? void 0 : Ke.lineBreak }),
    img: () => null,
    pre: () => null
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ReactMarkdown, { components: Ve, children: $e });
}, ComposerContext = createContext(null);
function useComposerContext() {
  const $e = useContext(ComposerContext);
  if (!$e)
    throw new Error("useComposerContext must be used within a Message");
  return $e;
}
const MessageContext = createContext(null);
function useMessageContext() {
  const $e = useContext(MessageContext);
  if (!$e)
    throw new Error("useMessageContext must be used within a Message");
  return $e;
}
const ModalContext = createContext(null);
function useModalContext() {
  const $e = useContext(ModalContext);
  if (!$e)
    throw new Error("useModalContext must be used within a ModalProvider");
  return $e;
}
const WebchatContext = createContext(null);
function useWebchatContext() {
  const $e = useContext(WebchatContext);
  if (!$e)
    throw new Error("useWebchatContext must be used within a WebchatProvider");
  return $e;
}
const Button = ({ text: $e, buttonValue: Ze, type: Fe, styles: Ke, variant: Ve, groupId: Je, reusable: Qe, ...at }) => {
  const { eventEmitter: ut, client: lt } = useWebchatContext(), [dt, bt] = useState(!1), [$t, vt] = useState(!1), [wt, xt] = useState(!1), { state: Et } = useWebchatContext();
  useEffect(() => {
    if (Je)
      return ut.on(`button-group-${Je}-click`, () => {
        vt(!0), Qe || xt(!0);
      });
  }, [ut, Je, Qe]);
  function Tt() {
    Je && ut.emit(`button-group-${Je}-click`), bt(!0), Qe || xt(!0), Ve !== "link" && (lt == null || lt.sendMessage(Ze));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ButtonOrAnchor,
    {
      ...at,
      variant: Ve,
      onClick: Tt,
      disabled: wt || Et.isReadOnly,
      "data-activated": dt ? "" : void 0,
      "data-group-activated": $t ? "" : void 0,
      "data-type": Ve,
      value: Ze,
      ...Ke == null ? void 0 : Ke[Fe],
      children: $e
    }
  );
}, ButtonOrAnchor = ($e) => {
  if ($e.variant === "link") {
    const { value: Ke, variant: Ve, ...Je } = $e;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("a", { ...Je, href: Ke, target: "_blank", rel: "noopener noreferrer" });
  }
  const { variant: Ze, ...Fe } = $e;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("button", { ...Fe });
}, Bubble = forwardRef(({ block: $e, styles: Ze, type: Fe, ...Ke }, Ve) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...Ke, ...Ze == null ? void 0 : Ze[Fe], ref: Ve, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Block, { styles: Ze, block: $e }) }));
function copyToClipboard($e, Ze) {
  const Fe = Ze ? `The ${Ze} has been copied to your clipboard.` : "Copied to clipboard.";
  return navigator.clipboard.writeText($e).then(() => showToast({ title: Fe, type: "success" }));
}
const getImageSize = ($e, Ze = {}) => new Promise((Fe, Ke) => {
  if (typeof window > "u")
    return Ke("Window is not defined");
  if (!$e)
    return Ke("Url is not defined");
  let Ve = null;
  const Je = new Image();
  Je.addEventListener("load", () => {
    Ve && clearTimeout(Ve), Fe({ width: Je.naturalWidth, height: Je.naturalHeight });
  }), Je.addEventListener("error", (Qe) => {
    Ve && clearTimeout(Ve), Ke(`${Qe.type}: ${Qe.message}`);
  }), Je.src = $e, Ze.timeout && (Ve = setTimeout(() => Ke("Timeout"), Ze.timeout));
});
let e$i = { data: "" }, t$e = ($e) => typeof window == "object" ? (($e ? $e.querySelector("#_goober") : window._goober) || Object.assign(($e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : $e || e$i, l$w = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, a$q = /\/\*[^]*?\*\/|  +/g, n$t = /\n+/g, o$v = ($e, Ze) => {
  let Fe = "", Ke = "", Ve = "";
  for (let Je in $e) {
    let Qe = $e[Je];
    Je[0] == "@" ? Je[1] == "i" ? Fe = Je + " " + Qe + ";" : Ke += Je[1] == "f" ? o$v(Qe, Je) : Je + "{" + o$v(Qe, Je[1] == "k" ? "" : Ze) + "}" : typeof Qe == "object" ? Ke += o$v(Qe, Ze ? Ze.replace(/([^,])+/g, (at) => Je.replace(/(^:.*)|([^,])+/g, (ut) => /&/.test(ut) ? ut.replace(/&/g, at) : at ? at + " " + ut : ut)) : Je) : Qe != null && (Je = /^--/.test(Je) ? Je : Je.replace(/[A-Z]/g, "-$&").toLowerCase(), Ve += o$v.p ? o$v.p(Je, Qe) : Je + ":" + Qe + ";");
  }
  return Fe + (Ze && Ve ? Ze + "{" + Ve + "}" : Ve) + Ke;
}, c$p = {}, s$t = ($e) => {
  if (typeof $e == "object") {
    let Ze = "";
    for (let Fe in $e)
      Ze += Fe + s$t($e[Fe]);
    return Ze;
  }
  return $e;
}, i$i = ($e, Ze, Fe, Ke, Ve) => {
  let Je = s$t($e), Qe = c$p[Je] || (c$p[Je] = ((ut) => {
    let lt = 0, dt = 11;
    for (; lt < ut.length; )
      dt = 101 * dt + ut.charCodeAt(lt++) >>> 0;
    return "go" + dt;
  })(Je));
  if (!c$p[Qe]) {
    let ut = Je !== $e ? $e : ((lt) => {
      let dt, bt, $t = [{}];
      for (; dt = l$w.exec(lt.replace(a$q, "")); )
        dt[4] ? $t.shift() : dt[3] ? (bt = dt[3].replace(n$t, " ").trim(), $t.unshift($t[0][bt] = $t[0][bt] || {})) : $t[0][dt[1]] = dt[2].replace(n$t, " ").trim();
      return $t[0];
    })($e);
    c$p[Qe] = o$v(Ve ? { ["@keyframes " + Qe]: ut } : ut, Fe ? "" : "." + Qe);
  }
  let at = Fe && c$p.g ? c$p.g : null;
  return Fe && (c$p.g = c$p[Qe]), ((ut, lt, dt, bt) => {
    bt ? lt.data = lt.data.replace(bt, ut) : lt.data.indexOf(ut) === -1 && (lt.data = dt ? ut + lt.data : lt.data + ut);
  })(c$p[Qe], Ze, Ke, at), Qe;
}, p$v = ($e, Ze, Fe) => $e.reduce((Ke, Ve, Je) => {
  let Qe = Ze[Je];
  if (Qe && Qe.call) {
    let at = Qe(Fe), ut = at && at.props && at.props.className || /^go/.test(at) && at;
    Qe = ut ? "." + ut : at && typeof at == "object" ? at.props ? "" : o$v(at, "") : at === !1 ? "" : at;
  }
  return Ke + Ve + (Qe ?? "");
}, "");
function u$v($e) {
  let Ze = this || {}, Fe = $e.call ? $e(Ze.p) : $e;
  return i$i(Fe.unshift ? Fe.raw ? p$v(Fe, [].slice.call(arguments, 1), Ze.p) : Fe.reduce((Ke, Ve) => Object.assign(Ke, Ve && Ve.call ? Ve(Ze.p) : Ve), {}) : Fe, t$e(Ze.target), Ze.g, Ze.o, Ze.k);
}
let d$r, f$A, g$j;
u$v.bind({ g: 1 });
let h$q = u$v.bind({ k: 1 });
function m$r($e, Ze, Fe, Ke) {
  o$v.p = Ze, d$r = $e, f$A = Fe, g$j = Ke;
}
function j$e($e, Ze) {
  let Fe = this || {};
  return function() {
    let Ke = arguments;
    function Ve(Je, Qe) {
      let at = Object.assign({}, Je), ut = at.className || Ve.className;
      Fe.p = Object.assign({ theme: f$A && f$A() }, at), Fe.o = / *go\d+/.test(ut), at.className = u$v.apply(Fe, Ke) + (ut ? " " + ut : ""), Ze && (at.ref = Qe);
      let lt = $e;
      return $e[0] && (lt = at.as || $e, delete at.as), g$j && lt[0] && g$j(at), d$r(lt, at);
    }
    return Ze ? Ze(Ve) : Ve;
  };
}
var W$8 = ($e) => typeof $e == "function", T$c = ($e, Ze) => W$8($e) ? $e(Ze) : $e, U$d = (() => {
  let $e = 0;
  return () => (++$e).toString();
})(), b$n = (() => {
  let $e;
  return () => {
    if ($e === void 0 && typeof window < "u") {
      let Ze = matchMedia("(prefers-reduced-motion: reduce)");
      $e = !Ze || Ze.matches;
    }
    return $e;
  };
})(), Q$6 = 20, S$h = /* @__PURE__ */ new Map(), X$8 = 1e3, $$6 = ($e) => {
  if (S$h.has($e))
    return;
  let Ze = setTimeout(() => {
    S$h.delete($e), u$u({ type: 4, toastId: $e });
  }, X$8);
  S$h.set($e, Ze);
}, J$8 = ($e) => {
  let Ze = S$h.get($e);
  Ze && clearTimeout(Ze);
}, v$n = ($e, Ze) => {
  switch (Ze.type) {
    case 0:
      return { ...$e, toasts: [Ze.toast, ...$e.toasts].slice(0, Q$6) };
    case 1:
      return Ze.toast.id && J$8(Ze.toast.id), { ...$e, toasts: $e.toasts.map((Je) => Je.id === Ze.toast.id ? { ...Je, ...Ze.toast } : Je) };
    case 2:
      let { toast: Fe } = Ze;
      return $e.toasts.find((Je) => Je.id === Fe.id) ? v$n($e, { type: 1, toast: Fe }) : v$n($e, { type: 0, toast: Fe });
    case 3:
      let { toastId: Ke } = Ze;
      return Ke ? $$6(Ke) : $e.toasts.forEach((Je) => {
        $$6(Je.id);
      }), { ...$e, toasts: $e.toasts.map((Je) => Je.id === Ke || Ke === void 0 ? { ...Je, visible: !1 } : Je) };
    case 4:
      return Ze.toastId === void 0 ? { ...$e, toasts: [] } : { ...$e, toasts: $e.toasts.filter((Je) => Je.id !== Ze.toastId) };
    case 5:
      return { ...$e, pausedAt: Ze.time };
    case 6:
      let Ve = Ze.time - ($e.pausedAt || 0);
      return { ...$e, pausedAt: void 0, toasts: $e.toasts.map((Je) => ({ ...Je, pauseDuration: Je.pauseDuration + Ve })) };
  }
}, A$e = [], P$c = { toasts: [], pausedAt: void 0 }, u$u = ($e) => {
  P$c = v$n(P$c, $e), A$e.forEach((Ze) => {
    Ze(P$c);
  });
}, Y$7 = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, I$f = ($e = {}) => {
  let [Ze, Fe] = useState(P$c);
  useEffect(() => (A$e.push(Fe), () => {
    let Ve = A$e.indexOf(Fe);
    Ve > -1 && A$e.splice(Ve, 1);
  }), [Ze]);
  let Ke = Ze.toasts.map((Ve) => {
    var Je, Qe;
    return { ...$e, ...$e[Ve.type], ...Ve, duration: Ve.duration || ((Je = $e[Ve.type]) == null ? void 0 : Je.duration) || ($e == null ? void 0 : $e.duration) || Y$7[Ve.type], style: { ...$e.style, ...(Qe = $e[Ve.type]) == null ? void 0 : Qe.style, ...Ve.style } };
  });
  return { ...Ze, toasts: Ke };
}, G$8 = ($e, Ze = "blank", Fe) => ({ createdAt: Date.now(), visible: !0, type: Ze, ariaProps: { role: "status", "aria-live": "polite" }, message: $e, pauseDuration: 0, ...Fe, id: (Fe == null ? void 0 : Fe.id) || U$d() }), h$p = ($e) => (Ze, Fe) => {
  let Ke = G$8(Ze, $e, Fe);
  return u$u({ type: 2, toast: Ke }), Ke.id;
}, n$s = ($e, Ze) => h$p("blank")($e, Ze);
n$s.error = h$p("error");
n$s.success = h$p("success");
n$s.loading = h$p("loading");
n$s.custom = h$p("custom");
n$s.dismiss = ($e) => {
  u$u({ type: 3, toastId: $e });
};
n$s.remove = ($e) => u$u({ type: 4, toastId: $e });
n$s.promise = ($e, Ze, Fe) => {
  let Ke = n$s.loading(Ze.loading, { ...Fe, ...Fe == null ? void 0 : Fe.loading });
  return $e.then((Ve) => (n$s.success(T$c(Ze.success, Ve), { id: Ke, ...Fe, ...Fe == null ? void 0 : Fe.success }), Ve)).catch((Ve) => {
    n$s.error(T$c(Ze.error, Ve), { id: Ke, ...Fe, ...Fe == null ? void 0 : Fe.error });
  }), $e;
};
var Z$5 = ($e, Ze) => {
  u$u({ type: 1, toast: { id: $e, height: Ze } });
}, ee$4 = () => {
  u$u({ type: 5, time: Date.now() });
}, D$d = ($e) => {
  let { toasts: Ze, pausedAt: Fe } = I$f($e);
  useEffect(() => {
    if (Fe)
      return;
    let Je = Date.now(), Qe = Ze.map((at) => {
      if (at.duration === 1 / 0)
        return;
      let ut = (at.duration || 0) + at.pauseDuration - (Je - at.createdAt);
      if (ut < 0) {
        at.visible && n$s.dismiss(at.id);
        return;
      }
      return setTimeout(() => n$s.dismiss(at.id), ut);
    });
    return () => {
      Qe.forEach((at) => at && clearTimeout(at));
    };
  }, [Ze, Fe]);
  let Ke = useCallback(() => {
    Fe && u$u({ type: 6, time: Date.now() });
  }, [Fe]), Ve = useCallback((Je, Qe) => {
    let { reverseOrder: at = !1, gutter: ut = 8, defaultPosition: lt } = Qe || {}, dt = Ze.filter((vt) => (vt.position || lt) === (Je.position || lt) && vt.height), bt = dt.findIndex((vt) => vt.id === Je.id), $t = dt.filter((vt, wt) => wt < bt && vt.visible).length;
    return dt.filter((vt) => vt.visible).slice(...at ? [$t + 1] : [0, $t]).reduce((vt, wt) => vt + (wt.height || 0) + ut, 0);
  }, [Ze]);
  return { toasts: Ze, handlers: { updateHeight: Z$5, startPause: ee$4, endPause: Ke, calculateOffset: Ve } };
}, oe$4 = h$q`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, re$5 = h$q`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, se$3 = h$q`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, _$l = j$e("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${($e) => $e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${oe$4} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${re$5} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${($e) => $e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${se$3} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, ne$3 = h$q`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, V$9 = j$e("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${($e) => $e.secondary || "#e0e0e0"};
  border-right-color: ${($e) => $e.primary || "#616161"};
  animation: ${ne$3} 1s linear infinite;
`, pe$3 = h$q`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, de$3 = h$q`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, w$n = j$e("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${($e) => $e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${pe$3} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${de$3} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${($e) => $e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, ue$3 = j$e("div")`
  position: absolute;
`, le$3 = j$e("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Te$1 = h$q`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, fe$3 = j$e("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Te$1} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, M$e = ({ toast: $e }) => {
  let { icon: Ze, type: Fe, iconTheme: Ke } = $e;
  return Ze !== void 0 ? typeof Ze == "string" ? React.createElement(fe$3, null, Ze) : Ze : Fe === "blank" ? null : React.createElement(le$3, null, React.createElement(V$9, { ...Ke }), Fe !== "loading" && React.createElement(ue$3, null, Fe === "error" ? React.createElement(_$l, { ...Ke }) : React.createElement(w$n, { ...Ke })));
}, ye$4 = ($e) => `
0% {transform: translate3d(0,${$e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, ge$2 = ($e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${$e * -150}%,-1px) scale(.6); opacity:0;}
`, he$3 = "0%{opacity:0;} 100%{opacity:1;}", xe$4 = "0%{opacity:1;} 100%{opacity:0;}", be$3 = j$e("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Se$3 = j$e("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Ae$3 = ($e, Ze) => {
  let Fe = $e.includes("top") ? 1 : -1, [Ke, Ve] = b$n() ? [he$3, xe$4] : [ye$4(Fe), ge$2(Fe)];
  return { animation: Ze ? `${h$q(Ke)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${h$q(Ve)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, F$c = React.memo(({ toast: $e, position: Ze, style: Fe, children: Ke }) => {
  let Ve = $e.height ? Ae$3($e.position || Ze || "top-center", $e.visible) : { opacity: 0 }, Je = React.createElement(M$e, { toast: $e }), Qe = React.createElement(Se$3, { ...$e.ariaProps }, T$c($e.message, $e));
  return React.createElement(be$3, { className: $e.className, style: { ...Ve, ...Fe, ...$e.style } }, typeof Ke == "function" ? Ke({ icon: Je, message: Qe }) : React.createElement(React.Fragment, null, Je, Qe));
});
m$r(React.createElement);
var Ee$3 = ({ id: $e, className: Ze, style: Fe, onHeightUpdate: Ke, children: Ve }) => {
  let Je = React.useCallback((Qe) => {
    if (Qe) {
      let at = () => {
        let ut = Qe.getBoundingClientRect().height;
        Ke($e, ut);
      };
      at(), new MutationObserver(at).observe(Qe, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [$e, Ke]);
  return React.createElement("div", { ref: Je, className: Ze, style: Fe }, Ve);
}, Re$3 = ($e, Ze) => {
  let Fe = $e.includes("top"), Ke = Fe ? { top: 0 } : { bottom: 0 }, Ve = $e.includes("center") ? { justifyContent: "center" } : $e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: b$n() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${Ze * (Fe ? 1 : -1)}px)`, ...Ke, ...Ve };
}, ve$2 = u$v`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, O$c = 16, Ie$2 = ({ reverseOrder: $e, position: Ze = "top-center", toastOptions: Fe, gutter: Ke, children: Ve, containerStyle: Je, containerClassName: Qe }) => {
  let { toasts: at, handlers: ut } = D$d(Fe);
  return React.createElement("div", { style: { position: "fixed", zIndex: 9999, top: O$c, left: O$c, right: O$c, bottom: O$c, pointerEvents: "none", ...Je }, className: Qe, onMouseEnter: ut.startPause, onMouseLeave: ut.endPause }, at.map((lt) => {
    let dt = lt.position || Ze, bt = ut.calculateOffset(lt, { reverseOrder: $e, gutter: Ke, defaultPosition: Ze }), $t = Re$3(dt, bt);
    return React.createElement(Ee$3, { id: lt.id, key: lt.id, onHeightUpdate: ut.updateHeight, className: lt.visible ? ve$2 : "", style: $t }, lt.type === "custom" ? T$c(lt.message, lt) : Ve ? Ve(lt) : React.createElement(F$c, { toast: lt, position: dt }));
  }));
}, i$h = Object.defineProperty, d$q = ($e, Ze, Fe) => Ze in $e ? i$h($e, Ze, { enumerable: !0, configurable: !0, writable: !0, value: Fe }) : $e[Ze] = Fe, r$i = ($e, Ze, Fe) => (d$q($e, typeof Ze != "symbol" ? Ze + "" : Ze, Fe), Fe);
let o$u = class {
  constructor() {
    r$i(this, "current", this.detect()), r$i(this, "handoffState", "pending"), r$i(this, "currentId", 0);
  }
  set(Ze) {
    this.current !== Ze && (this.handoffState = "pending", this.currentId = 0, this.current = Ze);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$s = new o$u(), l$v = ($e, Ze) => {
  s$s.isServer ? useEffect($e, Ze) : useLayoutEffect($e, Ze);
};
function s$r($e) {
  let Ze = useRef($e);
  return l$v(() => {
    Ze.current = $e;
  }, [$e]), Ze;
}
function t$d($e) {
  typeof queueMicrotask == "function" ? queueMicrotask($e) : Promise.resolve().then($e).catch((Ze) => setTimeout(() => {
    throw Ze;
  }));
}
function m$q() {
  let $e = [], Ze = [], Fe = { enqueue(Ke) {
    Ze.push(Ke);
  }, addEventListener(Ke, Ve, Je, Qe) {
    return Ke.addEventListener(Ve, Je, Qe), Fe.add(() => Ke.removeEventListener(Ve, Je, Qe));
  }, requestAnimationFrame(...Ke) {
    let Ve = requestAnimationFrame(...Ke);
    return Fe.add(() => cancelAnimationFrame(Ve));
  }, nextFrame(...Ke) {
    return Fe.requestAnimationFrame(() => Fe.requestAnimationFrame(...Ke));
  }, setTimeout(...Ke) {
    let Ve = setTimeout(...Ke);
    return Fe.add(() => clearTimeout(Ve));
  }, microTask(...Ke) {
    let Ve = { current: !0 };
    return t$d(() => {
      Ve.current && Ke[0]();
    }), Fe.add(() => {
      Ve.current = !1;
    });
  }, add(Ke) {
    return $e.push(Ke), () => {
      let Ve = $e.indexOf(Ke);
      if (Ve >= 0) {
        let [Je] = $e.splice(Ve, 1);
        Je();
      }
    };
  }, dispose() {
    for (let Ke of $e.splice(0))
      Ke();
  }, async workQueue() {
    for (let Ke of Ze.splice(0))
      await Ke();
  }, style(Ke, Ve, Je) {
    let Qe = Ke.style.getPropertyValue(Ve);
    return Object.assign(Ke.style, { [Ve]: Je }), this.add(() => {
      Object.assign(Ke.style, { [Ve]: Qe });
    });
  } };
  return Fe;
}
function p$u() {
  let [$e] = useState(m$q);
  return useEffect(() => () => $e.dispose(), [$e]), $e;
}
let o$t = function($e) {
  let Ze = s$r($e);
  return React__default.useCallback((...Fe) => Ze.current(...Fe), [Ze]);
};
function l$u() {
  let [$e, Ze] = useState(s$s.isHandoffComplete);
  return $e && s$s.isHandoffComplete === !1 && Ze(!1), useEffect(() => {
    $e !== !0 && Ze(!0);
  }, [$e]), useEffect(() => s$s.handoff(), []), $e;
}
function u$t($e, Ze, ...Fe) {
  if ($e in Ze) {
    let Ve = Ze[$e];
    return typeof Ve == "function" ? Ve(...Fe) : Ve;
  }
  let Ke = new Error(`Tried to handle "${$e}" but there is no handler defined. Only defined handlers are: ${Object.keys(Ze).map((Ve) => `"${Ve}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(Ke, u$t), Ke;
}
let u$s = Symbol();
function y$q(...$e) {
  let Ze = useRef($e);
  useEffect(() => {
    Ze.current = $e;
  }, [$e]);
  let Fe = o$t((Ke) => {
    for (let Ve of Ze.current)
      Ve != null && (typeof Ve == "function" ? Ve(Ke) : Ve.current = Ke);
  });
  return $e.every((Ke) => Ke == null || (Ke == null ? void 0 : Ke[u$s])) ? void 0 : Fe;
}
function e$h(...$e) {
  return $e.filter(Boolean).join(" ");
}
var j$d = (($e) => ($e[$e.None = 0] = "None", $e[$e.RenderStrategy = 1] = "RenderStrategy", $e[$e.Static = 2] = "Static", $e))(j$d || {}), w$m = (($e) => ($e[$e.Unmount = 0] = "Unmount", $e[$e.Hidden = 1] = "Hidden", $e))(w$m || {});
function X$7({ ourProps: $e, theirProps: Ze, slot: Fe, defaultTag: Ke, features: Ve, visible: Je = !0, name: Qe }) {
  let at = h$o(Ze, $e);
  if (Je)
    return m$p(at, Fe, Ke, Qe);
  let ut = Ve ?? 0;
  if (ut & 2) {
    let { static: lt = !1, ...dt } = at;
    if (lt)
      return m$p(dt, Fe, Ke, Qe);
  }
  if (ut & 1) {
    let { unmount: lt = !0, ...dt } = at;
    return u$t(lt ? 0 : 1, { [0]() {
      return null;
    }, [1]() {
      return m$p({ ...dt, hidden: !0, style: { display: "none" } }, Fe, Ke, Qe);
    } });
  }
  return m$p(at, Fe, Ke, Qe);
}
function m$p($e, Ze = {}, Fe, Ke) {
  var Ve;
  let { as: Je = Fe, children: Qe, refName: at = "ref", ...ut } = T$b($e, ["unmount", "static"]), lt = $e.ref !== void 0 ? { [at]: $e.ref } : {}, dt = typeof Qe == "function" ? Qe(Ze) : Qe;
  ut.className && typeof ut.className == "function" && (ut.className = ut.className(Ze));
  let bt = {};
  if (Ze) {
    let $t = !1, vt = [];
    for (let [wt, xt] of Object.entries(Ze))
      typeof xt == "boolean" && ($t = !0), xt === !0 && vt.push(wt);
    $t && (bt["data-headlessui-state"] = vt.join(" "));
  }
  if (Je === Fragment && Object.keys(P$b(ut)).length > 0) {
    if (!isValidElement(dt) || Array.isArray(dt) && dt.length > 1)
      throw new Error(['Passing props on "Fragment"!', "", `The current component <${Ke} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(ut).map((wt) => `  - ${wt}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((wt) => `  - ${wt}`).join(`
`)].join(`
`));
    let $t = e$h((Ve = dt.props) == null ? void 0 : Ve.className, ut.className), vt = $t ? { className: $t } : {};
    return cloneElement(dt, Object.assign({}, h$o(dt.props, P$b(T$b(ut, ["ref"]))), bt, lt, O$b(dt.ref, lt.ref), vt));
  }
  return createElement(Je, Object.assign({}, T$b(ut, ["ref"]), Je !== Fragment && lt, Je !== Fragment && bt), dt);
}
function O$b(...$e) {
  return { ref: $e.every((Ze) => Ze == null) ? void 0 : (Ze) => {
    for (let Fe of $e)
      Fe != null && (typeof Fe == "function" ? Fe(Ze) : Fe.current = Ze);
  } };
}
function h$o(...$e) {
  if ($e.length === 0)
    return {};
  if ($e.length === 1)
    return $e[0];
  let Ze = {}, Fe = {};
  for (let Ke of $e)
    for (let Ve in Ke)
      Ve.startsWith("on") && typeof Ke[Ve] == "function" ? (Fe[Ve] != null || (Fe[Ve] = []), Fe[Ve].push(Ke[Ve])) : Ze[Ve] = Ke[Ve];
  if (Ze.disabled || Ze["aria-disabled"])
    return Object.assign(Ze, Object.fromEntries(Object.keys(Fe).map((Ke) => [Ke, void 0])));
  for (let Ke in Fe)
    Object.assign(Ze, { [Ke](Ve, ...Je) {
      let Qe = Fe[Ke];
      for (let at of Qe) {
        if ((Ve instanceof Event || (Ve == null ? void 0 : Ve.nativeEvent) instanceof Event) && Ve.defaultPrevented)
          return;
        at(Ve, ...Je);
      }
    } });
  return Ze;
}
function V$8($e) {
  var Ze;
  return Object.assign(forwardRef($e), { displayName: (Ze = $e.displayName) != null ? Ze : $e.name });
}
function P$b($e) {
  let Ze = Object.assign({}, $e);
  for (let Fe in Ze)
    Ze[Fe] === void 0 && delete Ze[Fe];
  return Ze;
}
function T$b($e, Ze = []) {
  let Fe = Object.assign({}, $e);
  for (let Ke of Ze)
    Ke in Fe && delete Fe[Ke];
  return Fe;
}
let n$r = createContext(null);
n$r.displayName = "OpenClosedContext";
var d$p = (($e) => ($e[$e.Open = 1] = "Open", $e[$e.Closed = 2] = "Closed", $e[$e.Closing = 4] = "Closing", $e[$e.Opening = 8] = "Opening", $e))(d$p || {});
function C$b() {
  return useContext(n$r);
}
function c$o({ value: $e, children: Ze }) {
  return React__default.createElement(n$r.Provider, { value: $e }, Ze);
}
function f$z() {
  let $e = useRef(!1);
  return l$v(() => ($e.current = !0, () => {
    $e.current = !1;
  }), []), $e;
}
function b$m($e = 0) {
  let [Ze, Fe] = useState($e), Ke = useCallback((at) => Fe((ut) => ut | at), [Ze]), Ve = useCallback((at) => !!(Ze & at), [Ze]), Je = useCallback((at) => Fe((ut) => ut & ~at), [Fe]), Qe = useCallback((at) => Fe((ut) => ut ^ at), [Fe]);
  return { flags: Ze, addFlag: Ke, hasFlag: Ve, removeFlag: Je, toggleFlag: Qe };
}
function l$t($e) {
  let Ze = { called: !1 };
  return (...Fe) => {
    if (!Ze.called)
      return Ze.called = !0, $e(...Fe);
  };
}
function v$m($e, ...Ze) {
  $e && Ze.length > 0 && $e.classList.add(...Ze);
}
function f$y($e, ...Ze) {
  $e && Ze.length > 0 && $e.classList.remove(...Ze);
}
function F$b($e, Ze) {
  let Fe = m$q();
  if (!$e)
    return Fe.dispose;
  let { transitionDuration: Ke, transitionDelay: Ve } = getComputedStyle($e), [Je, Qe] = [Ke, Ve].map((at) => {
    let [ut = 0] = at.split(",").filter(Boolean).map((lt) => lt.includes("ms") ? parseFloat(lt) : parseFloat(lt) * 1e3).sort((lt, dt) => dt - lt);
    return ut;
  });
  if (Je + Qe !== 0) {
    let at = Fe.addEventListener($e, "transitionend", (ut) => {
      ut.target === ut.currentTarget && (Ze(), at());
    });
  } else
    Ze();
  return Fe.add(() => Ze()), Fe.dispose;
}
function M$d($e, Ze, Fe, Ke) {
  let Ve = Fe ? "enter" : "leave", Je = m$q(), Qe = Ke !== void 0 ? l$t(Ke) : () => {
  };
  Ve === "enter" && ($e.removeAttribute("hidden"), $e.style.display = "");
  let at = u$t(Ve, { enter: () => Ze.enter, leave: () => Ze.leave }), ut = u$t(Ve, { enter: () => Ze.enterTo, leave: () => Ze.leaveTo }), lt = u$t(Ve, { enter: () => Ze.enterFrom, leave: () => Ze.leaveFrom });
  return f$y($e, ...Ze.enter, ...Ze.enterTo, ...Ze.enterFrom, ...Ze.leave, ...Ze.leaveFrom, ...Ze.leaveTo, ...Ze.entered), v$m($e, ...at, ...lt), Je.nextFrame(() => {
    f$y($e, ...lt), v$m($e, ...ut), F$b($e, () => (f$y($e, ...at), v$m($e, ...Ze.entered), Qe()));
  }), Je.dispose;
}
function D$c({ container: $e, direction: Ze, classes: Fe, onStart: Ke, onStop: Ve }) {
  let Je = f$z(), Qe = p$u(), at = s$r(Ze);
  l$v(() => {
    let ut = m$q();
    Qe.add(ut.dispose);
    let lt = $e.current;
    if (lt && at.current !== "idle" && Je.current)
      return ut.dispose(), Ke.current(at.current), ut.add(M$d(lt, Fe.current, at.current === "enter", () => {
        ut.dispose(), Ve.current(at.current);
      })), ut.dispose;
  }, [Ze]);
}
function H$a($e = "") {
  return $e.split(" ").filter((Ze) => Ze.trim().length > 1);
}
let M$c = createContext(null);
M$c.displayName = "TransitionContext";
var Ee$2 = (($e) => ($e.Visible = "visible", $e.Hidden = "hidden", $e))(Ee$2 || {});
function Se$2() {
  let $e = useContext(M$c);
  if ($e === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return $e;
}
function xe$3() {
  let $e = useContext(I$e);
  if ($e === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return $e;
}
let I$e = createContext(null);
I$e.displayName = "NestingContext";
function _$k($e) {
  return "children" in $e ? _$k($e.children) : $e.current.filter(({ el: Ze }) => Ze.current !== null).filter(({ state: Ze }) => Ze === "visible").length > 0;
}
function re$4($e, Ze) {
  let Fe = s$r($e), Ke = useRef([]), Ve = f$z(), Je = p$u(), Qe = o$t((vt, wt = w$m.Hidden) => {
    let xt = Ke.current.findIndex(({ el: Et }) => Et === vt);
    xt !== -1 && (u$t(wt, { [w$m.Unmount]() {
      Ke.current.splice(xt, 1);
    }, [w$m.Hidden]() {
      Ke.current[xt].state = "hidden";
    } }), Je.microTask(() => {
      var Et;
      !_$k(Ke) && Ve.current && ((Et = Fe.current) == null || Et.call(Fe));
    }));
  }), at = o$t((vt) => {
    let wt = Ke.current.find(({ el: xt }) => xt === vt);
    return wt ? wt.state !== "visible" && (wt.state = "visible") : Ke.current.push({ el: vt, state: "visible" }), () => Qe(vt, w$m.Unmount);
  }), ut = useRef([]), lt = useRef(Promise.resolve()), dt = useRef({ enter: [], leave: [], idle: [] }), bt = o$t((vt, wt, xt) => {
    ut.current.splice(0), Ze && (Ze.chains.current[wt] = Ze.chains.current[wt].filter(([Et]) => Et !== vt)), Ze == null || Ze.chains.current[wt].push([vt, new Promise((Et) => {
      ut.current.push(Et);
    })]), Ze == null || Ze.chains.current[wt].push([vt, new Promise((Et) => {
      Promise.all(dt.current[wt].map(([Tt, Rt]) => Rt)).then(() => Et());
    })]), wt === "enter" ? lt.current = lt.current.then(() => Ze == null ? void 0 : Ze.wait.current).then(() => xt(wt)) : xt(wt);
  }), $t = o$t((vt, wt, xt) => {
    Promise.all(dt.current[wt].splice(0).map(([Et, Tt]) => Tt)).then(() => {
      var Et;
      (Et = ut.current.shift()) == null || Et();
    }).then(() => xt(wt));
  });
  return useMemo(() => ({ children: Ke, register: at, unregister: Qe, onStart: bt, onStop: $t, wait: lt, chains: dt }), [at, Qe, Ke, bt, $t, dt, lt]);
}
function Pe$3() {
}
let He = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function ie$3($e) {
  var Ze;
  let Fe = {};
  for (let Ke of He)
    Fe[Ke] = (Ze = $e[Ke]) != null ? Ze : Pe$3;
  return Fe;
}
function Ne$1($e) {
  let Ze = useRef(ie$3($e));
  return useEffect(() => {
    Ze.current = ie$3($e);
  }, [$e]), Ze;
}
let Re$2 = "div", oe$3 = j$d.RenderStrategy, se$2 = V$8(function($e, Ze) {
  let { beforeEnter: Fe, afterEnter: Ke, beforeLeave: Ve, afterLeave: Je, enter: Qe, enterFrom: at, enterTo: ut, entered: lt, leave: dt, leaveFrom: bt, leaveTo: $t, ...vt } = $e, wt = useRef(null), xt = y$q(wt, Ze), Et = vt.unmount ? w$m.Unmount : w$m.Hidden, { show: Tt, appear: Rt, initial: Ct } = Se$2(), [Zt, Lt] = useState(Tt ? "visible" : "hidden"), Ut = xe$3(), { register: Pt, unregister: Ot } = Ut, Ft = useRef(null);
  useEffect(() => Pt(wt), [Pt, wt]), useEffect(() => {
    if (Et === w$m.Hidden && wt.current) {
      if (Tt && Zt !== "visible") {
        Lt("visible");
        return;
      }
      return u$t(Zt, { hidden: () => Ot(wt), visible: () => Pt(wt) });
    }
  }, [Zt, wt, Pt, Ot, Tt, Et]);
  let gt = s$r({ enter: H$a(Qe), enterFrom: H$a(at), enterTo: H$a(ut), entered: H$a(lt), leave: H$a(dt), leaveFrom: H$a(bt), leaveTo: H$a($t) }), We = Ne$1({ beforeEnter: Fe, afterEnter: Ke, beforeLeave: Ve, afterLeave: Je }), Xe = l$u();
  useEffect(() => {
    if (Xe && Zt === "visible" && wt.current === null)
      throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [wt, Zt, Xe]);
  let rt = Ct && !Rt, ot = (() => !Xe || rt || Ft.current === Tt ? "idle" : Tt ? "enter" : "leave")(), ft = b$m(0), mt = o$t((Mt) => u$t(Mt, { enter: () => {
    ft.addFlag(d$p.Opening), We.current.beforeEnter();
  }, leave: () => {
    ft.addFlag(d$p.Closing), We.current.beforeLeave();
  }, idle: () => {
  } })), yt = o$t((Mt) => u$t(Mt, { enter: () => {
    ft.removeFlag(d$p.Opening), We.current.afterEnter();
  }, leave: () => {
    ft.removeFlag(d$p.Closing), We.current.afterLeave();
  }, idle: () => {
  } })), pt = re$4(() => {
    Lt("hidden"), Ot(wt);
  }, Ut);
  D$c({ container: wt, classes: gt, direction: ot, onStart: s$r((Mt) => {
    pt.onStart(wt, Mt, mt);
  }), onStop: s$r((Mt) => {
    pt.onStop(wt, Mt, yt), Mt === "leave" && !_$k(pt) && (Lt("hidden"), Ot(wt));
  }) }), useEffect(() => {
    !rt || (Et === w$m.Hidden ? Ft.current = null : Ft.current = Tt);
  }, [Tt, rt, Zt]);
  let Ge = vt, ct = { ref: xt };
  return Rt && Tt && s$s.isServer && (Ge = { ...Ge, className: e$h(vt.className, ...gt.current.enter, ...gt.current.enterFrom) }), React__default.createElement(I$e.Provider, { value: pt }, React__default.createElement(c$o, { value: u$t(Zt, { visible: d$p.Open, hidden: d$p.Closed }) | ft.flags }, X$7({ ourProps: ct, theirProps: Ge, defaultTag: Re$2, features: oe$3, visible: Zt === "visible", name: "Transition.Child" })));
}), K$b = V$8(function($e, Ze) {
  let { show: Fe, appear: Ke = !1, unmount: Ve, ...Je } = $e, Qe = useRef(null), at = y$q(Qe, Ze);
  l$u();
  let ut = C$b();
  if (Fe === void 0 && ut !== null && (Fe = (ut & d$p.Open) === d$p.Open), ![!0, !1].includes(Fe))
    throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [lt, dt] = useState(Fe ? "visible" : "hidden"), bt = re$4(() => {
    dt("hidden");
  }), [$t, vt] = useState(!0), wt = useRef([Fe]);
  l$v(() => {
    $t !== !1 && wt.current[wt.current.length - 1] !== Fe && (wt.current.push(Fe), vt(!1));
  }, [wt, Fe]);
  let xt = useMemo(() => ({ show: Fe, appear: Ke, initial: $t }), [Fe, Ke, $t]);
  useEffect(() => {
    if (Fe)
      dt("visible");
    else if (!_$k(bt))
      dt("hidden");
    else {
      let Tt = Qe.current;
      if (!Tt)
        return;
      let Rt = Tt.getBoundingClientRect();
      Rt.x === 0 && Rt.y === 0 && Rt.width === 0 && Rt.height === 0 && dt("hidden");
    }
  }, [Fe, bt]);
  let Et = { unmount: Ve };
  return React__default.createElement(I$e.Provider, { value: bt }, React__default.createElement(M$c.Provider, { value: xt }, X$7({ ourProps: { ...Et, as: Fragment, children: React__default.createElement(se$2, { ref: at, ...Et, ...Je }) }, theirProps: {}, defaultTag: Fragment, features: oe$3, visible: lt === "visible", name: "Transition" })));
}), ye$3 = V$8(function($e, Ze) {
  let Fe = useContext(M$c) !== null, Ke = C$b() !== null;
  return React__default.createElement(React__default.Fragment, null, !Fe && Ke ? React__default.createElement(K$b, { ref: Ze, ...$e }) : React__default.createElement(se$2, { ref: Ze, ...$e }));
}), Ye = Object.assign(K$b, { Child: ye$3, Root: K$b });
const SvgCheckCircleBold = ($e) => /* @__PURE__ */ React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, ...$e }, /* @__PURE__ */ React.createElement("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", d: "m7.5 12 3 3 6-6m5.5 3c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2s10 4.477 10 10Z" })), SvgXClose = ($e) => /* @__PURE__ */ React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, fill: "none", viewBox: "0 0 24 24", ...$e }, /* @__PURE__ */ React.createElement("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", d: "M18 6 6 18M6 6l12 12" })), SvgXCircleBold = ($e) => /* @__PURE__ */ React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, ...$e }, /* @__PURE__ */ React.createElement("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", d: "m15 9-6 6m0-6 6 6m7-3c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2s10 4.477 10 10Z" }));
function showToast($e) {
  return n$s.custom((Ze) => /* @__PURE__ */ jsxRuntimeExports.jsx(ToastContainer, { type: $e.type, show: Ze.visible, children: $e.type === "custom" ? $e.content : /* @__PURE__ */ jsxRuntimeExports.jsx(ToastContent, { ...$e, toastId: Ze.id }) }));
}
const ToastContent = ({ icon: $e, type: Ze, title: Fe, description: Ke, toastId: Ve }) => {
  const {
    theme: { notification: Je }
  } = useWebchatContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    $e ? /* @__PURE__ */ jsxRuntimeExports.jsx($e, { ...Je == null ? void 0 : Je.icon }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ToastIcon, { ...Je == null ? void 0 : Je.icon, type: Ze }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { ...Je == null ? void 0 : Je.title, children: Fe }),
    Ke ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { ...Je == null ? void 0 : Je.description, children: Ke }) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx(SvgXClose, { ...Je == null ? void 0 : Je.closeIcon, onClick: () => n$s.dismiss(Ve) })
  ] });
}, ToastContainer = ({ type: $e, ...Ze }) => {
  const {
    theme: { notification: Fe }
  } = useWebchatContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Ye, { ...Ze, ...Fe == null ? void 0 : Fe.container, appear: !0, "data-type": $e ?? "neutral" });
}, ToastIcon = ({ type: $e, className: Ze }) => {
  switch ($e) {
    case "success":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgCheckCircleBold, { className: Ze });
    case "error":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgXCircleBold, { className: Ze });
    default:
      return null;
  }
}, Image$1 = forwardRef(
  ({ url: $e, type: Ze, styles: Fe, orientation: Ke = "auto", ...Ve }, Je) => {
    var $t, vt;
    const Qe = useId$1(), { setIsLoading: at } = useMessageContext(), [ut, lt] = useState(Ke), [dt, bt] = useState(!1);
    return useLayoutEffect(() => {
      at((wt) => [...wt, Qe]);
    }, []), useEffect(() => {
      $e && ut === "auto" && getImageSize($e).then(({ width: wt, height: xt }) => {
        lt(getClosestAspectRatio(wt, xt)), at((Et) => Et.filter((Tt) => Tt !== Qe));
      });
    }, [$e]), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      dt ? null : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-orientation": ut, ...($t = Fe == null ? void 0 : Fe[Ze]) == null ? void 0 : $t.placeholder }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          "data-orientation": ut,
          "data-loaded": dt,
          ...Ve,
          ...(vt = Fe == null ? void 0 : Fe[Ze]) == null ? void 0 : vt.image,
          src: $e,
          alt: "",
          ref: Je,
          loading: "lazy",
          onLoad: () => {
            bt(!0);
          }
        }
      )
    ] });
  }
);
function getClosestAspectRatio($e, Ze) {
  const Fe = {
    square: 1,
    portrait: 0.75,
    landscape: 1.3333333333333333
  }, Ke = $e / Ze;
  return Object.keys(Fe).reduce((Je, Qe) => Math.abs(Fe[Qe] - Ke) < Math.abs(Fe[Je] - Ke) ? Qe : Je);
}
const Video = forwardRef(({ url: $e, type: Ze, styles: Fe, ...Ke }, Ve) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("video", { ...Ke, controls: !0, src: $e, ...Fe == null ? void 0 : Fe[Ze], ref: Ve }) })), Audio = forwardRef(({ url: $e, type: Ze, styles: Fe, ...Ke }, Ve) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("audio", { ...Ke, controls: !0, src: $e, ...Fe == null ? void 0 : Fe[Ze], ref: Ve }) }));
function ArrowDownIcon({
  title: $e,
  titleId: Ze,
  ...Fe
}, Ke) {
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: Ke,
    "aria-labelledby": Ze
  }, Fe), $e ? /* @__PURE__ */ React.createElement("title", {
    id: Ze
  }, $e) : null, /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    d: "M10 3a.75.75 0 01.75.75v10.638l3.96-4.158a.75.75 0 111.08 1.04l-5.25 5.5a.75.75 0 01-1.08 0l-5.25-5.5a.75.75 0 111.08-1.04l3.96 4.158V3.75A.75.75 0 0110 3z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$d = React.forwardRef(ArrowDownIcon), ArrowDownIcon$1 = ForwardRef$d;
function ArrowPathIcon({
  title: $e,
  titleId: Ze,
  ...Fe
}, Ke) {
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: Ke,
    "aria-labelledby": Ze
  }, Fe), $e ? /* @__PURE__ */ React.createElement("title", {
    id: Ze
  }, $e) : null, /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    d: "M15.312 11.424a5.5 5.5 0 01-9.201 2.466l-.312-.311h2.433a.75.75 0 000-1.5H3.989a.75.75 0 00-.75.75v4.242a.75.75 0 001.5 0v-2.43l.31.31a7 7 0 0011.712-3.138.75.75 0 00-1.449-.39zm1.23-3.723a.75.75 0 00.219-.53V2.929a.75.75 0 00-1.5 0V5.36l-.31-.31A7 7 0 003.239 8.188a.75.75 0 101.448.389A5.5 5.5 0 0113.89 6.11l.311.31h-2.432a.75.75 0 000 1.5h4.243a.75.75 0 00.53-.219z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$c = React.forwardRef(ArrowPathIcon), ArrowPathIcon$1 = ForwardRef$c;
function ArrowUpCircleIcon({
  title: $e,
  titleId: Ze,
  ...Fe
}, Ke) {
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: Ke,
    "aria-labelledby": Ze
  }, Fe), $e ? /* @__PURE__ */ React.createElement("title", {
    id: Ze
  }, $e) : null, /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm-.75-4.75a.75.75 0 001.5 0V8.66l1.95 2.1a.75.75 0 101.1-1.02l-3.25-3.5a.75.75 0 00-1.1 0L6.2 9.74a.75.75 0 101.1 1.02l1.95-2.1v4.59z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$b = React.forwardRef(ArrowUpCircleIcon), ArrowUpCircleIcon$1 = ForwardRef$b;
function ChevronDownIcon({
  title: $e,
  titleId: Ze,
  ...Fe
}, Ke) {
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: Ke,
    "aria-labelledby": Ze
  }, Fe), $e ? /* @__PURE__ */ React.createElement("title", {
    id: Ze
  }, $e) : null, /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    d: "M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$a = React.forwardRef(ChevronDownIcon), ChevronDownIcon$1 = ForwardRef$a;
function DocumentArrowDownIcon({
  title: $e,
  titleId: Ze,
  ...Fe
}, Ke) {
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: Ke,
    "aria-labelledby": Ze
  }, Fe), $e ? /* @__PURE__ */ React.createElement("title", {
    id: Ze
  }, $e) : null, /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    d: "M4.5 2A1.5 1.5 0 003 3.5v13A1.5 1.5 0 004.5 18h11a1.5 1.5 0 001.5-1.5V7.621a1.5 1.5 0 00-.44-1.06l-4.12-4.122A1.5 1.5 0 0011.378 2H4.5zm4.75 6.75a.75.75 0 011.5 0v2.546l.943-1.048a.75.75 0 011.114 1.004l-2.25 2.5a.75.75 0 01-1.114 0l-2.25-2.5a.75.75 0 111.114-1.004l.943 1.048V8.75z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$9 = React.forwardRef(DocumentArrowDownIcon), DocumentArrowDownIcon$1 = ForwardRef$9;
function MapPinIcon({
  title: $e,
  titleId: Ze,
  ...Fe
}, Ke) {
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: Ke,
    "aria-labelledby": Ze
  }, Fe), $e ? /* @__PURE__ */ React.createElement("title", {
    id: Ze
  }, $e) : null, /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    d: "M9.69 18.933l.003.001C9.89 19.02 10 19 10 19s.11.02.308-.066l.002-.001.006-.003.018-.008a5.741 5.741 0 00.281-.14c.186-.096.446-.24.757-.433.62-.384 1.445-.966 2.274-1.765C15.302 14.988 17 12.493 17 9A7 7 0 103 9c0 3.492 1.698 5.988 3.355 7.584a13.731 13.731 0 002.273 1.765 11.842 11.842 0 00.976.544l.062.029.018.008.006.003zM10 11.25a2.25 2.25 0 100-4.5 2.25 2.25 0 000 4.5z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$8 = React.forwardRef(MapPinIcon), MapPinIcon$1 = ForwardRef$8, Location = forwardRef(
  ({ type: $e, latitude: Ze, longitude: Fe, title: Ke, styles: Ve, ...Je }, Qe) => {
    var ut, lt, dt;
    const at = `https://www.google.com/maps/search/?api=1&query=${Ze},${Fe}`;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { ...Je, ...(ut = Ve == null ? void 0 : Ve[$e]) == null ? void 0 : ut.container, href: at, type: "_blank", rel: "noopener", ref: Qe, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { ...(lt = Ve == null ? void 0 : Ve[$e]) == null ? void 0 : lt.title, children: Ke }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(MapPinIcon$1, { ...(dt = Ve == null ? void 0 : Ve[$e]) == null ? void 0 : dt.icon })
    ] });
  }
), Column = forwardRef(
  ({ blocks: $e, styles: Ze, type: Fe, horizontalAlignment: Ke, verticalAlignment: Ve, ...Je }, Qe) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      "data-horizontal": Ke,
      "data-vertical": Ve,
      ...Je,
      ...Ze == null ? void 0 : Ze[Fe],
      ref: Qe,
      children: $e.map((at, ut) => /* @__PURE__ */ jsxRuntimeExports.jsx(Block, { styles: Ze, block: at }, ut))
    }
  )
), Row = forwardRef(
  ({ blocks: $e, styles: Ze, type: Fe, horizontalAlignment: Ke, verticalAlignment: Ve, ...Je }, Qe) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      "data-horizontal": Ke,
      "data-vertical": Ve,
      ...Je,
      ...Ze == null ? void 0 : Ze[Fe],
      ref: Qe,
      children: $e.map((at, ut) => /* @__PURE__ */ jsxRuntimeExports.jsx(Block, { styles: Ze, block: at }, ut))
    }
  )
);
function isObject$3($e) {
  return Object.prototype.toString.call($e) === "[object Object]";
}
function isRecord($e) {
  return isObject$3($e) || Array.isArray($e);
}
function canUseDOM() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function areOptionsEqual($e, Ze) {
  const Fe = Object.keys($e), Ke = Object.keys(Ze);
  if (Fe.length !== Ke.length)
    return !1;
  const Ve = JSON.stringify(Object.keys($e.breakpoints || {})), Je = JSON.stringify(Object.keys(Ze.breakpoints || {}));
  return Ve !== Je ? !1 : Fe.every((Qe) => {
    const at = $e[Qe], ut = Ze[Qe];
    return typeof at == "function" ? `${at}` == `${ut}` : !isRecord(at) || !isRecord(ut) ? at === ut : areOptionsEqual(at, ut);
  });
}
function sortAndMapPluginToOptions($e) {
  return $e.concat().sort((Ze, Fe) => Ze.name > Fe.name ? 1 : -1).map((Ze) => Ze.options);
}
function arePluginsEqual($e, Ze) {
  if ($e.length !== Ze.length)
    return !1;
  const Fe = sortAndMapPluginToOptions($e), Ke = sortAndMapPluginToOptions(Ze);
  return Fe.every((Ve, Je) => {
    const Qe = Ke[Je];
    return areOptionsEqual(Ve, Qe);
  });
}
function isNumber$2($e) {
  return typeof $e == "number";
}
function isString$2($e) {
  return typeof $e == "string";
}
function isBoolean$2($e) {
  return typeof $e == "boolean";
}
function isObject$2($e) {
  return Object.prototype.toString.call($e) === "[object Object]";
}
function mathAbs($e) {
  return Math.abs($e);
}
function mathSign($e) {
  return Math.sign($e);
}
function deltaAbs($e, Ze) {
  return mathAbs($e - Ze);
}
function factorAbs($e, Ze) {
  if ($e === 0 || Ze === 0 || mathAbs($e) <= mathAbs(Ze))
    return 0;
  const Fe = deltaAbs(mathAbs($e), mathAbs(Ze));
  return mathAbs(Fe / $e);
}
function arrayKeys($e) {
  return objectKeys($e).map(Number);
}
function arrayLast($e) {
  return $e[arrayLastIndex($e)];
}
function arrayLastIndex($e) {
  return Math.max(0, $e.length - 1);
}
function objectKeys($e) {
  return Object.keys($e);
}
function objectsMergeDeep($e, Ze) {
  return [$e, Ze].reduce((Fe, Ke) => (objectKeys(Ke).forEach((Ve) => {
    const Je = Fe[Ve], Qe = Ke[Ve], at = isObject$2(Je) && isObject$2(Qe);
    Fe[Ve] = at ? objectsMergeDeep(Je, Qe) : Qe;
  }), Fe), {});
}
function isMouseEvent($e, Ze) {
  return typeof Ze.MouseEvent < "u" && $e instanceof Ze.MouseEvent;
}
function Alignment($e, Ze) {
  const Fe = {
    start: Ke,
    center: Ve,
    end: Je
  };
  function Ke() {
    return 0;
  }
  function Ve(lt) {
    return Je(lt) / 2;
  }
  function Je(lt) {
    return Ze - lt;
  }
  function Qe() {
    return Ze * Number($e);
  }
  function at(lt) {
    return isNumber$2($e) ? Qe() : Fe[$e](lt);
  }
  return {
    measure: at
  };
}
function Axis($e, Ze) {
  const Fe = $e === "y" ? "y" : "x", Ke = $e === "y" ? "x" : "y", Ve = at(), Je = ut();
  function Qe(dt) {
    const {
      width: bt,
      height: $t
    } = dt;
    return Fe === "x" ? bt : $t;
  }
  function at() {
    return Fe === "y" ? "top" : Ze === "rtl" ? "right" : "left";
  }
  function ut() {
    return Fe === "y" ? "bottom" : Ze === "rtl" ? "left" : "right";
  }
  return {
    scroll: Fe,
    cross: Ke,
    startEdge: Ve,
    endEdge: Je,
    measureSize: Qe
  };
}
function Limit($e, Ze) {
  const Fe = mathAbs($e - Ze);
  function Ke(lt) {
    return lt < $e;
  }
  function Ve(lt) {
    return lt > Ze;
  }
  function Je(lt) {
    return Ke(lt) || Ve(lt);
  }
  function Qe(lt) {
    return Je(lt) ? Ke(lt) ? $e : Ze : lt;
  }
  function at(lt) {
    return Fe ? lt - Fe * Math.ceil((lt - Ze) / Fe) : lt;
  }
  return {
    length: Fe,
    max: Ze,
    min: $e,
    constrain: Qe,
    reachedAny: Je,
    reachedMax: Ve,
    reachedMin: Ke,
    removeOffset: at
  };
}
function Counter($e, Ze, Fe) {
  const {
    constrain: Ke
  } = Limit(0, $e), Ve = $e + 1;
  let Je = Qe(Ze);
  function Qe($t) {
    return Fe ? mathAbs((Ve + $t) % Ve) : Ke($t);
  }
  function at() {
    return Je;
  }
  function ut($t) {
    return Je = Qe($t), bt;
  }
  function lt($t) {
    return dt().set(at() + $t);
  }
  function dt() {
    return Counter($e, at(), Fe);
  }
  const bt = {
    get: at,
    set: ut,
    add: lt,
    clone: dt
  };
  return bt;
}
function Direction($e) {
  const Ze = $e === "rtl" ? -1 : 1;
  function Fe(Ve) {
    return Ve * Ze;
  }
  return {
    apply: Fe
  };
}
function EventStore() {
  let $e = [];
  function Ze(Ve, Je, Qe, at = {
    passive: !0
  }) {
    return Ve.addEventListener(Je, Qe, at), $e.push(() => Ve.removeEventListener(Je, Qe, at)), Ke;
  }
  function Fe() {
    $e = $e.filter((Ve) => Ve());
  }
  const Ke = {
    add: Ze,
    clear: Fe
  };
  return Ke;
}
function DragHandler($e, Ze, Fe, Ke, Ve, Je, Qe, at, ut, lt, dt, bt, $t, vt, wt, xt, Et, Tt, Rt) {
  const {
    cross: Ct
  } = $e, Zt = ["INPUT", "SELECT", "TEXTAREA"], Lt = {
    passive: !1
  }, Ut = EventStore(), Pt = EventStore(), Ot = Limit(50, 225).constrain(wt.measure(20)), Ft = {
    mouse: 300,
    touch: 400
  }, gt = {
    mouse: 500,
    touch: 600
  }, We = xt ? 43 : 25;
  let Xe = !1, rt = 0, ot = 0, ft = !1, mt = !1, yt = !1, pt = !1;
  function Ge(er, Dt) {
    if (!Dt)
      return;
    function Ht(rr) {
      (isBoolean$2(Dt) || Dt(er, rr)) && qt(rr);
    }
    const Gt = Fe;
    Ut.add(Gt, "dragstart", (rr) => rr.preventDefault(), Lt).add(Gt, "touchmove", () => {
    }, Lt).add(Gt, "touchend", () => {
    }).add(Gt, "touchstart", Ht).add(Gt, "mousedown", Ht).add(Gt, "touchcancel", Xt).add(Gt, "contextmenu", Xt).add(Gt, "click", zt, !0);
  }
  function ct() {
    Ut.clear(), Pt.clear();
  }
  function Mt() {
    const er = pt ? Ke : Fe;
    Pt.add(er, "touchmove", Qt, Lt).add(er, "touchend", Xt).add(er, "mousemove", Qt, Lt).add(er, "mouseup", Xt);
  }
  function St(er) {
    const Dt = er.nodeName || "";
    return Zt.includes(Dt);
  }
  function At() {
    return (xt ? gt : Ft)[pt ? "mouse" : "touch"];
  }
  function Nt(er, Dt) {
    const Ht = $t.add(mathSign(er) * -1), Gt = bt.byDistance(er, !xt).distance;
    return xt || mathAbs(er) < Ot ? Gt : Tt && Dt ? Gt * 0.5 : bt.byIndex(Ht.get(), 0).distance;
  }
  function qt(er) {
    const Dt = isMouseEvent(er, Ve);
    pt = Dt, !(Dt && er.button !== 0) && (St(er.target) || (yt = xt && Dt && !er.buttons && Xe, Xe = deltaAbs(Je.get(), at.get()) >= 2, ft = !0, Qe.pointerDown(er), dt.useFriction(0).useDuration(0), Je.set(at), Mt(), rt = Qe.readPoint(er), ot = Qe.readPoint(er, Ct), vt.emit("pointerDown")));
  }
  function Qt(er) {
    const Dt = Qe.readPoint(er), Ht = Qe.readPoint(er, Ct), Gt = deltaAbs(Dt, rt), rr = deltaAbs(Ht, ot);
    if (!mt && !pt && (!er.cancelable || (mt = Gt > rr, !mt)))
      return Xt(er);
    const sr = Qe.pointerMove(er);
    Gt > Et && (yt = !0), dt.useFriction(0.3).useDuration(1), ut.start(), Je.add(Ze.apply(sr)), er.preventDefault();
  }
  function Xt(er) {
    const Ht = bt.byDistance(0, !1).index !== $t.get(), Gt = Qe.pointerUp(er) * At(), rr = Nt(Ze.apply(Gt), Ht), sr = factorAbs(Gt, rr), Jt = We - 10 * sr, ir = Rt + sr / 50;
    mt = !1, ft = !1, Pt.clear(), dt.useDuration(Jt).useFriction(ir), lt.distance(rr, !xt), pt = !1, vt.emit("pointerUp");
  }
  function zt(er) {
    yt && (er.stopPropagation(), er.preventDefault());
  }
  function Kt() {
    return ft;
  }
  return {
    init: Ge,
    pointerDown: Kt,
    destroy: ct
  };
}
function DragTracker($e, Ze) {
  let Ke, Ve;
  function Je(bt) {
    return bt.timeStamp;
  }
  function Qe(bt, $t) {
    const wt = `client${($t || $e.scroll) === "x" ? "X" : "Y"}`;
    return (isMouseEvent(bt, Ze) ? bt : bt.touches[0])[wt];
  }
  function at(bt) {
    return Ke = bt, Ve = bt, Qe(bt);
  }
  function ut(bt) {
    const $t = Qe(bt) - Qe(Ve), vt = Je(bt) - Je(Ke) > 170;
    return Ve = bt, vt && (Ke = bt), $t;
  }
  function lt(bt) {
    if (!Ke || !Ve)
      return 0;
    const $t = Qe(Ve) - Qe(Ke), vt = Je(bt) - Je(Ke), wt = Je(bt) - Je(Ve) > 170, xt = $t / vt;
    return vt && !wt && mathAbs(xt) > 0.1 ? xt : 0;
  }
  return {
    pointerDown: at,
    pointerMove: ut,
    pointerUp: lt,
    readPoint: Qe
  };
}
function PercentOfView($e) {
  function Ze(Ke) {
    return $e * (Ke / 100);
  }
  return {
    measure: Ze
  };
}
function ResizeHandler($e, Ze, Fe, Ke, Ve) {
  let Je, Qe, at = [], ut = !1;
  function lt(vt) {
    return Ve.measureSize(vt.getBoundingClientRect());
  }
  function dt(vt, wt) {
    if (!wt)
      return;
    Qe = lt($e), at = Ke.map(lt);
    function xt(Tt) {
      for (const Rt of Tt) {
        const Ct = Rt.target === $e, Zt = Ke.indexOf(Rt.target), Lt = Ct ? Qe : at[Zt], Ut = lt(Ct ? $e : Ke[Zt]);
        if (Lt !== Ut) {
          Fe.requestAnimationFrame(() => {
            vt.reInit(), Ze.emit("resize");
          });
          break;
        }
      }
    }
    Je = new ResizeObserver((Tt) => {
      ut || (isBoolean$2(wt) || wt(vt, Tt)) && xt(Tt);
    }), [$e].concat(Ke).forEach((Tt) => Je.observe(Tt));
  }
  function bt() {
    Je && Je.disconnect(), ut = !0;
  }
  return {
    init: dt,
    destroy: bt
  };
}
function ScrollBody($e, Ze, Fe, Ke) {
  let Ve = !0, Je = 0, Qe = 0, at = Fe, ut = Ke, lt = $e.get(), dt = 0;
  function bt() {
    const Lt = Ze.get() - $e.get(), Ut = !at;
    let Pt = 0;
    return Ut ? (Je = 0, $e.set(Ze), Pt = Lt) : (Je += Lt / at, Je *= ut, lt += Je, $e.add(Je), Pt = lt - dt), Qe = mathSign(Pt), dt = lt, Ve = mathAbs(Lt) < 1e-3, Zt;
  }
  function $t() {
    return Ve;
  }
  function vt() {
    return at;
  }
  function wt() {
    return Qe;
  }
  function xt() {
    return Je;
  }
  function Et() {
    return Rt(Fe);
  }
  function Tt() {
    return Ct(Ke);
  }
  function Rt(Lt) {
    return at = Lt, Zt;
  }
  function Ct(Lt) {
    return ut = Lt, Zt;
  }
  const Zt = {
    direction: wt,
    duration: vt,
    velocity: xt,
    seek: bt,
    settled: $t,
    useBaseFriction: Tt,
    useBaseDuration: Et,
    useFriction: Ct,
    useDuration: Rt
  };
  return Zt;
}
function ScrollBounds($e, Ze, Fe, Ke, Ve) {
  const Je = Ve.measure(10), Qe = Ve.measure(50), at = Limit(0.1, 0.99);
  let ut = !1;
  function lt() {
    return !(ut || !$e.reachedAny(Fe.get()) || !$e.reachedAny(Ze.get()));
  }
  function dt(vt) {
    if (!lt())
      return;
    const wt = $e.reachedMin(Ze.get()) ? "min" : "max", xt = mathAbs($e[wt] - Ze.get()), Et = Fe.get() - Ze.get(), Tt = at.constrain(xt / Qe);
    Fe.subtract(Et * Tt), !vt && mathAbs(Et) < Je && (Fe.set($e.constrain(Fe.get())), Ke.useDuration(25).useBaseFriction());
  }
  function bt(vt) {
    ut = !vt;
  }
  return {
    constrain: dt,
    toggleActive: bt
  };
}
function ScrollContain($e, Ze, Fe, Ke) {
  const Ve = Limit(-Ze + $e, Fe[0]), Je = ut(), Qe = lt();
  function at() {
    const bt = Je[0], $t = arrayLast(Je), vt = Je.lastIndexOf(bt), wt = Je.indexOf($t) + 1;
    return Limit(vt, wt);
  }
  function ut() {
    return Fe.map(Ve.constrain).map((bt) => parseFloat(bt.toFixed(3)));
  }
  function lt() {
    if (Ze <= $e)
      return [Ve.max];
    if (Ke === "keepSnaps")
      return Je;
    const {
      min: bt,
      max: $t
    } = at();
    return Je.slice(bt, $t);
  }
  return {
    snapsContained: Qe
  };
}
function ScrollLimit($e, Ze, Fe) {
  const Ke = Ze[0], Ve = Fe ? Ke - $e : arrayLast(Ze);
  return {
    limit: Limit(Ve, Ke)
  };
}
function ScrollLooper($e, Ze, Fe, Ke) {
  const Je = Ze.min + 0.1, Qe = Ze.max + 0.1, {
    reachedMin: at,
    reachedMax: ut
  } = Limit(Je, Qe);
  function lt($t) {
    return $t === 1 ? ut(Fe.get()) : $t === -1 ? at(Fe.get()) : !1;
  }
  function dt($t) {
    if (!lt($t))
      return;
    const vt = $e * ($t * -1);
    Ke.forEach((wt) => wt.add(vt));
  }
  return {
    loop: dt
  };
}
function ScrollProgress($e) {
  const {
    max: Ze,
    length: Fe
  } = $e;
  function Ke(Je) {
    return (Je - Ze) / -Fe;
  }
  return {
    get: Ke
  };
}
function ScrollSnaps($e, Ze, Fe, Ke, Ve, Je, Qe) {
  const {
    startEdge: at,
    endEdge: ut
  } = $e, {
    groupSlides: lt
  } = Je, dt = vt().map(Ze.measure), bt = wt(), $t = xt();
  function vt() {
    return lt(Ke).map((Tt) => arrayLast(Tt)[ut] - Tt[0][at]).map(mathAbs);
  }
  function wt() {
    return Ke.map((Tt) => Fe[at] - Tt[at]).map((Tt) => -mathAbs(Tt));
  }
  function xt() {
    const Rt = arrayLast(bt) - arrayLast(Ve);
    return lt(bt).map((Ct) => Ct[0]).map((Ct, Zt, Lt) => {
      const Ut = !Zt, Pt = Zt === arrayLastIndex(Lt);
      return Qe && Ut ? 0 : Qe && Pt ? Rt : Ct + dt[Zt];
    });
  }
  return {
    snaps: bt,
    snapsAligned: $t
  };
}
function ScrollTarget($e, Ze, Fe, Ke, Ve) {
  const {
    reachedAny: Je,
    removeOffset: Qe,
    constrain: at
  } = Ke;
  function ut(wt) {
    return wt.concat().sort((xt, Et) => mathAbs(xt) - mathAbs(Et))[0];
  }
  function lt(wt) {
    const xt = $e ? Qe(wt) : at(wt), Et = Ze.map((Rt) => Rt - xt).map((Rt) => dt(Rt, 0)).map((Rt, Ct) => ({
      diff: Rt,
      index: Ct
    })).sort((Rt, Ct) => mathAbs(Rt.diff) - mathAbs(Ct.diff)), {
      index: Tt
    } = Et[0];
    return {
      index: Tt,
      distance: xt
    };
  }
  function dt(wt, xt) {
    const Et = [wt, wt + Fe, wt - Fe];
    if (!$e)
      return Et[0];
    if (!xt)
      return ut(Et);
    const Tt = Et.filter((Rt) => mathSign(Rt) === xt);
    return ut(Tt);
  }
  function bt(wt, xt) {
    const Et = Ze[wt] - Ve.get(), Tt = dt(Et, xt);
    return {
      index: wt,
      distance: Tt
    };
  }
  function $t(wt, xt) {
    const Et = Ve.get() + wt, {
      index: Tt,
      distance: Rt
    } = lt(Et), Ct = !$e && Je(Et);
    if (!xt || Ct)
      return {
        index: Tt,
        distance: wt
      };
    const Zt = Ze[Tt] - Rt, Lt = wt + dt(Zt, 0);
    return {
      index: Tt,
      distance: Lt
    };
  }
  return {
    byDistance: $t,
    byIndex: bt,
    shortcut: dt
  };
}
function ScrollTo($e, Ze, Fe, Ke, Ve, Je, Qe) {
  function at(bt) {
    const $t = bt.distance, vt = bt.index !== Ze.get();
    Je.add($t), $t && (Ve.duration() ? $e.start() : ($e.update(), $e.render(1), $e.update())), vt && (Fe.set(Ze.get()), Ze.set(bt.index), Qe.emit("select"));
  }
  function ut(bt, $t) {
    const vt = Ke.byDistance(bt, $t);
    at(vt);
  }
  function lt(bt, $t) {
    const vt = Ze.clone().set(bt), wt = Ke.byIndex(vt.get(), $t);
    at(wt);
  }
  return {
    distance: ut,
    index: lt
  };
}
function Vector1D($e) {
  let Ze = $e;
  function Fe() {
    return Ze;
  }
  function Ke(ut) {
    Ze = Qe(ut);
  }
  function Ve(ut) {
    Ze += Qe(ut);
  }
  function Je(ut) {
    Ze -= Qe(ut);
  }
  function Qe(ut) {
    return isNumber$2(ut) ? ut : ut.get();
  }
  return {
    get: Fe,
    set: Ke,
    add: Ve,
    subtract: Je
  };
}
function Translate($e, Ze, Fe) {
  const Ke = $e.scroll === "x" ? Qe : at, Ve = Fe.style;
  let Je = !1;
  function Qe($t) {
    return `translate3d(${$t}px,0px,0px)`;
  }
  function at($t) {
    return `translate3d(0px,${$t}px,0px)`;
  }
  function ut($t) {
    Je || (Ve.transform = Ke(Ze.apply($t)));
  }
  function lt($t) {
    Je = !$t;
  }
  function dt() {
    Je || (Ve.transform = "", Fe.getAttribute("style") || Fe.removeAttribute("style"));
  }
  return {
    clear: dt,
    to: ut,
    toggleActive: lt
  };
}
function SlideLooper($e, Ze, Fe, Ke, Ve, Je, Qe, at, ut) {
  const lt = arrayKeys(Ve), dt = arrayKeys(Ve).reverse(), bt = xt().concat(Et());
  function $t(Lt, Ut) {
    return Lt.reduce((Pt, Ot) => Pt - Ve[Ot], Ut);
  }
  function vt(Lt, Ut) {
    return Lt.reduce((Pt, Ot) => $t(Pt, Ut) > 0 ? Pt.concat([Ot]) : Pt, []);
  }
  function wt(Lt, Ut) {
    const Pt = Ut === "start", Ot = Pt ? -Ke : Ke, Ft = Qe.findSlideBounds([Ot]);
    return Lt.map((gt) => {
      const We = Pt ? 0 : -Ke, Xe = Pt ? Ke : 0, ot = Ft.filter((ft) => ft.index === gt)[0][Pt ? "end" : "start"];
      return {
        index: gt,
        slideLocation: Vector1D(-1),
        translate: Translate($e, Ze, ut[gt]),
        target: () => at.get() > ot ? We : Xe
      };
    });
  }
  function xt() {
    const Lt = Je[0] - 1, Ut = vt(dt, Lt);
    return wt(Ut, "end");
  }
  function Et() {
    const Lt = Fe - Je[0] - 1, Ut = vt(lt, Lt);
    return wt(Ut, "start");
  }
  function Tt() {
    return bt.every(({
      index: Lt
    }) => {
      const Ut = lt.filter((Pt) => Pt !== Lt);
      return $t(Ut, Fe) <= 0.1;
    });
  }
  function Rt() {
    bt.forEach((Lt) => {
      const {
        target: Ut,
        translate: Pt,
        slideLocation: Ot
      } = Lt, Ft = Ut();
      Ft !== Ot.get() && (Pt.to(Ft), Ot.set(Ft));
    });
  }
  function Ct() {
    bt.forEach((Lt) => Lt.translate.clear());
  }
  return {
    canLoop: Tt,
    clear: Ct,
    loop: Rt,
    loopPoints: bt
  };
}
function SlidesHandler($e, Ze) {
  let Fe, Ke = !1;
  function Ve(at, ut) {
    if (!ut)
      return;
    function lt(dt) {
      for (const bt of dt)
        if (bt.type === "childList") {
          at.reInit(), Ze.emit("slidesChanged");
          break;
        }
    }
    Fe = new MutationObserver((dt) => {
      Ke || (isBoolean$2(ut) || ut(at, dt)) && lt(dt);
    }), Fe.observe($e, {
      childList: !0
    });
  }
  function Je() {
    Fe && Fe.disconnect(), Ke = !0;
  }
  return {
    init: Ve,
    destroy: Je
  };
}
function SlidesInView($e, Ze, Fe, Ke, Ve, Je, Qe) {
  const {
    removeOffset: at,
    constrain: ut
  } = Ve, lt = 0.5, dt = Je ? [0, Ze, -Ze] : [0], bt = vt(dt, Qe);
  function $t(Et) {
    const Tt = Et || 0;
    return Fe.map((Rt) => Limit(lt, Rt - lt).constrain(Rt * Tt));
  }
  function vt(Et, Tt) {
    const Rt = Et || dt, Ct = $t(Tt);
    return Rt.reduce((Zt, Lt) => {
      const Ut = Ke.map((Pt, Ot) => ({
        start: Pt - Fe[Ot] + Ct[Ot] + Lt,
        end: Pt + $e - Ct[Ot] + Lt,
        index: Ot
      }));
      return Zt.concat(Ut);
    }, []);
  }
  function wt(Et, Tt) {
    const Rt = Je ? at(Et) : ut(Et);
    return (Tt || bt).reduce((Zt, Lt) => {
      const {
        index: Ut,
        start: Pt,
        end: Ot
      } = Lt, Ft = Zt.includes(Ut), gt = Pt < Rt && Ot > Rt;
      return !Ft && gt ? Zt.concat([Ut]) : Zt;
    }, []);
  }
  return {
    check: wt,
    findSlideBounds: vt
  };
}
function SlideSizes($e, Ze, Fe, Ke, Ve, Je) {
  const {
    measureSize: Qe,
    startEdge: at,
    endEdge: ut
  } = $e, lt = Fe[0] && Ve, dt = wt(), bt = xt(), $t = Fe.map(Qe), vt = Et();
  function wt() {
    if (!lt)
      return 0;
    const Rt = Fe[0];
    return mathAbs(Ze[at] - Rt[at]);
  }
  function xt() {
    if (!lt)
      return 0;
    const Rt = Je.getComputedStyle(arrayLast(Ke));
    return parseFloat(Rt.getPropertyValue(`margin-${ut}`));
  }
  function Et() {
    return Fe.map((Rt, Ct, Zt) => {
      const Lt = !Ct, Ut = Ct === arrayLastIndex(Zt);
      return Lt ? $t[Ct] + dt : Ut ? $t[Ct] + bt : Zt[Ct + 1][at] - Rt[at];
    }).map(mathAbs);
  }
  return {
    slideSizes: $t,
    slideSizesWithGaps: vt
  };
}
function SlidesToScroll($e, Ze, Fe) {
  const Ke = isNumber$2(Fe);
  function Ve(ut, lt) {
    return arrayKeys(ut).filter((dt) => dt % lt === 0).map((dt) => ut.slice(dt, dt + lt));
  }
  function Je(ut) {
    return arrayKeys(ut).reduce((lt, dt) => {
      const $t = Ze.slice(arrayLast(lt), dt + 1).reduce((vt, wt) => vt + wt, 0);
      return !dt || $t > $e ? lt.concat(dt) : lt;
    }, []).map((lt, dt, bt) => ut.slice(lt, bt[dt + 1]));
  }
  function Qe(ut) {
    return Ke ? Ve(ut, Fe) : Je(ut);
  }
  return {
    groupSlides: Qe
  };
}
function Engine($e, Ze, Fe, Ke, Ve, Je, Qe, at) {
  const {
    align: ut,
    axis: lt,
    direction: dt,
    startIndex: bt,
    inViewThreshold: $t,
    loop: vt,
    duration: wt,
    dragFree: xt,
    dragThreshold: Et,
    slidesToScroll: Tt,
    skipSnaps: Rt,
    containScroll: Ct
  } = Je, Zt = Ze.getBoundingClientRect(), Lt = Fe.map((ir) => ir.getBoundingClientRect()), Ut = Direction(dt), Pt = Axis(lt, dt), Ot = Pt.measureSize(Zt), Ft = PercentOfView(Ot), gt = Alignment(ut, Ot), We = !vt && !!Ct, Xe = vt || !!Ct, {
    slideSizes: rt,
    slideSizesWithGaps: ot
  } = SlideSizes(Pt, Zt, Lt, Fe, Xe, Ve), ft = SlidesToScroll(Ot, ot, Tt), {
    snaps: mt,
    snapsAligned: yt
  } = ScrollSnaps(Pt, gt, Zt, Lt, ot, ft, We), pt = -arrayLast(mt) + arrayLast(ot), {
    snapsContained: Ge
  } = ScrollContain(Ot, pt, yt, Ct), ct = We ? Ge : yt, {
    limit: Mt
  } = ScrollLimit(pt, ct, vt), St = Counter(arrayLastIndex(ct), bt, vt), At = St.clone(), Nt = arrayKeys(Fe), qt = ({
    dragHandler: ir,
    scrollBody: Br,
    scrollBounds: or,
    eventHandler: lr,
    animation: Nr,
    options: {
      loop: dr
    }
  }) => {
    const gr = ir.pointerDown();
    dr || or.constrain(gr);
    const Zr = Br.seek().settled();
    Zr && !gr && (Nr.stop(), lr.emit("settle")), Zr || lr.emit("scroll");
  }, Qt = ({
    scrollBody: ir,
    translate: Br,
    location: or,
    offsetLocation: lr,
    scrollLooper: Nr,
    slideLooper: dr,
    options: {
      loop: gr
    }
  }, Zr) => {
    const Bt = ir.velocity();
    lr.set(or.get() - Bt + Bt * Zr), gr && (Nr.loop(ir.direction()), dr.loop()), Br.to(lr.get());
  }, Xt = {
    start: () => at.start(Jt),
    stop: () => at.stop(Jt),
    update: () => qt(Jt),
    render: (ir) => Qt(Jt, ir)
  }, zt = 0.68, Kt = ct[St.get()], ur = Vector1D(Kt), er = Vector1D(Kt), Dt = Vector1D(Kt), Ht = ScrollBody(ur, Dt, wt, zt), Gt = ScrollTarget(vt, ct, pt, Mt, Dt), rr = ScrollTo(Xt, St, At, Gt, Ht, Dt, Qe), sr = SlidesInView(Ot, pt, rt, mt, Mt, vt, $t), Jt = {
    ownerDocument: Ke,
    ownerWindow: Ve,
    eventHandler: Qe,
    containerRect: Zt,
    slideRects: Lt,
    animation: Xt,
    axis: Pt,
    direction: Ut,
    dragHandler: DragHandler(Pt, Ut, $e, Ke, Ve, Dt, DragTracker(Pt, Ve), ur, Xt, rr, Ht, Gt, St, Qe, Ft, xt, Et, Rt, zt),
    eventStore: EventStore(),
    percentOfView: Ft,
    index: St,
    indexPrevious: At,
    limit: Mt,
    location: ur,
    offsetLocation: er,
    options: Je,
    resizeHandler: ResizeHandler(Ze, Qe, Ve, Fe, Pt),
    scrollBody: Ht,
    scrollBounds: ScrollBounds(Mt, ur, Dt, Ht, Ft),
    scrollLooper: ScrollLooper(pt, Mt, er, [ur, er, Dt]),
    scrollProgress: ScrollProgress(Mt),
    scrollSnaps: ct,
    scrollTarget: Gt,
    scrollTo: rr,
    slideLooper: SlideLooper(Pt, Ut, Ot, pt, ot, ct, sr, er, Fe),
    slidesHandler: SlidesHandler(Ze, Qe),
    slidesInView: sr,
    slideIndexes: Nt,
    slidesToScroll: ft,
    target: Dt,
    translate: Translate(Pt, Ut, Ze)
  };
  return Jt;
}
function Animations($e) {
  const Ze = 16.666666666666668;
  let Fe = [], Ke = null, Ve = 0, Je = 0;
  function Qe(bt) {
    Ke || (Ke = bt);
    const $t = bt - Ke;
    for (Ke = bt, Ve += $t; Ve >= Ze; )
      Fe.forEach(({
        animation: wt
      }) => wt.update()), Ve -= Ze;
    const vt = mathAbs(Ve / Ze);
    Fe.forEach(({
      animation: wt
    }) => wt.render(vt)), Je && $e.requestAnimationFrame(Qe);
  }
  function at(bt) {
    Fe.includes(bt) || Fe.push(bt), !Je && (Je = $e.requestAnimationFrame(Qe));
  }
  function ut(bt) {
    Fe = Fe.filter(($t) => $t !== bt), !Fe.length && ($e.cancelAnimationFrame(Je), Ke = null, Ve = 0, Je = 0);
  }
  function lt() {
    Ke = null, Ve = 0;
  }
  return {
    start: at,
    stop: ut,
    reset: lt,
    window: $e
  };
}
function EventHandler() {
  const $e = {};
  let Ze;
  function Fe(ut) {
    Ze = ut;
  }
  function Ke(ut) {
    return $e[ut] || [];
  }
  function Ve(ut) {
    return Ke(ut).forEach((lt) => lt(Ze, ut)), at;
  }
  function Je(ut, lt) {
    return $e[ut] = Ke(ut).concat([lt]), at;
  }
  function Qe(ut, lt) {
    return $e[ut] = Ke(ut).filter((dt) => dt !== lt), at;
  }
  const at = {
    init: Fe,
    emit: Ve,
    off: Qe,
    on: Je
  };
  return at;
}
const defaultOptions = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  inViewThreshold: 0,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0
};
function OptionsHandler($e) {
  function Ze(Je, Qe) {
    return objectsMergeDeep(Je, Qe || {});
  }
  function Fe(Je) {
    const Qe = Je.breakpoints || {}, at = objectKeys(Qe).filter((ut) => $e.matchMedia(ut).matches).map((ut) => Qe[ut]).reduce((ut, lt) => Ze(ut, lt), {});
    return Ze(Je, at);
  }
  function Ke(Je) {
    return Je.map((Qe) => objectKeys(Qe.breakpoints || {})).reduce((Qe, at) => Qe.concat(at), []).map($e.matchMedia);
  }
  return {
    mergeOptions: Ze,
    optionsAtMedia: Fe,
    optionsMediaQueries: Ke
  };
}
function PluginsHandler($e) {
  let Ze = [];
  function Fe(Je, Qe) {
    return Ze = Je.filter(({
      options: at
    }) => $e.optionsAtMedia(at).active !== !1), Ze.forEach((at) => at.init(Qe, $e)), Je.reduce((at, ut) => Object.assign(at, {
      [ut.name]: ut
    }), {});
  }
  function Ke() {
    Ze = Ze.filter((Je) => Je.destroy());
  }
  return {
    init: Fe,
    destroy: Ke
  };
}
function EmblaCarousel($e, Ze, Fe) {
  const Ke = $e.ownerDocument, Ve = Ke.defaultView, Je = OptionsHandler(Ve), Qe = PluginsHandler(Je), at = EventStore(), ut = EventStore(), lt = EventHandler(), {
    animationRealms: dt
  } = EmblaCarousel, {
    mergeOptions: bt,
    optionsAtMedia: $t,
    optionsMediaQueries: vt
  } = Je, {
    on: wt,
    off: xt,
    emit: Et
  } = lt, Tt = rt;
  let Rt = !1, Ct, Zt = bt(defaultOptions, EmblaCarousel.globalOptions), Lt = bt(Zt), Ut = [], Pt, Ot, Ft;
  function gt() {
    const {
      container: Ht,
      slides: Gt
    } = Lt;
    Ot = (isString$2(Ht) ? $e.querySelector(Ht) : Ht) || $e.children[0];
    const sr = isString$2(Gt) ? Ot.querySelectorAll(Gt) : Gt;
    Ft = [].slice.call(sr || Ot.children);
  }
  function We(Ht, Gt) {
    const rr = Engine($e, Ot, Ft, Ke, Ve, Ht, lt, Gt);
    if (Ht.loop && !rr.slideLooper.canLoop()) {
      const sr = Object.assign({}, Ht, {
        loop: !1
      });
      return We(sr, Gt);
    }
    return rr;
  }
  function Xe(Ht, Gt) {
    if (Rt)
      return;
    const rr = dt.find((Jt) => Jt.window === Ve), sr = rr || Animations(Ve);
    rr || dt.push(sr), Zt = bt(Zt, Ht), Lt = $t(Zt), Ut = Gt || Ut, gt(), Ct = We(Lt, sr), vt([Zt, ...Ut.map(({
      options: Jt
    }) => Jt)]).forEach((Jt) => at.add(Jt, "change", rt)), Lt.active && (Ct.translate.to(Ct.location.get()), Ct.eventHandler.init(Dt), Ct.resizeHandler.init(Dt, Lt.watchResize), Ct.slidesHandler.init(Dt, Lt.watchSlides), ut.add(Ke, "visibilitychange", () => {
      Ke.hidden && sr.reset();
    }), Ct.options.loop && Ct.slideLooper.loop(), Ot.offsetParent && Ft.length && Ct.dragHandler.init(Dt, Lt.watchDrag), Pt = Qe.init(Ut, Dt));
  }
  function rt(Ht, Gt) {
    const rr = qt();
    ot(), Xe(bt({
      startIndex: rr
    }, Ht), Gt), lt.emit("reInit");
  }
  function ot() {
    Ct.dragHandler.destroy(), Ct.animation.stop(), Ct.eventStore.clear(), Ct.translate.clear(), Ct.slideLooper.clear(), Ct.resizeHandler.destroy(), Ct.slidesHandler.destroy(), Qe.destroy(), at.clear(), ut.clear();
  }
  function ft() {
    Rt || (Rt = !0, at.clear(), ot(), lt.emit("destroy"));
  }
  function mt(Ht) {
    const Gt = Ct[Ht ? "target" : "location"].get(), rr = Lt.loop ? "removeOffset" : "constrain";
    return Ct.slidesInView.check(Ct.limit[rr](Gt));
  }
  function yt(Ht) {
    const Gt = mt(Ht);
    return Ct.slideIndexes.filter((rr) => !Gt.includes(rr));
  }
  function pt(Ht, Gt, rr) {
    !Lt.active || Rt || (Ct.scrollBody.useBaseFriction().useDuration(Gt ? 0 : Lt.duration), Ct.scrollTo.index(Ht, rr || 0));
  }
  function Ge(Ht) {
    const Gt = Ct.index.add(1).get();
    pt(Gt, Ht === !0, -1);
  }
  function ct(Ht) {
    const Gt = Ct.index.add(-1).get();
    pt(Gt, Ht === !0, 1);
  }
  function Mt() {
    return Ct.index.add(1).get() !== qt();
  }
  function St() {
    return Ct.index.add(-1).get() !== qt();
  }
  function At() {
    return Ct.scrollSnaps.map(Ct.scrollProgress.get);
  }
  function Nt() {
    return Ct.scrollProgress.get(Ct.location.get());
  }
  function qt() {
    return Ct.index.get();
  }
  function Qt() {
    return Ct.indexPrevious.get();
  }
  function Xt() {
    return Pt;
  }
  function zt() {
    return Ct;
  }
  function Kt() {
    return $e;
  }
  function ur() {
    return Ot;
  }
  function er() {
    return Ft;
  }
  const Dt = {
    canScrollNext: Mt,
    canScrollPrev: St,
    containerNode: ur,
    internalEngine: zt,
    destroy: ft,
    off: xt,
    on: wt,
    emit: Et,
    plugins: Xt,
    previousScrollSnap: Qt,
    reInit: Tt,
    rootNode: Kt,
    scrollNext: Ge,
    scrollPrev: ct,
    scrollProgress: Nt,
    scrollSnapList: At,
    scrollTo: pt,
    selectedScrollSnap: qt,
    slideNodes: er,
    slidesInView: mt,
    slidesNotInView: yt
  };
  return Xe(Ze, Fe), setTimeout(() => lt.emit("init"), 0), Dt;
}
EmblaCarousel.animationRealms = [];
EmblaCarousel.globalOptions = void 0;
function useEmblaCarousel($e = {}, Ze = []) {
  const Fe = useRef($e), Ke = useRef(Ze), [Ve, Je] = useState(), [Qe, at] = useState(), ut = useCallback(() => {
    Ve && Ve.reInit(Fe.current, Ke.current);
  }, [Ve]);
  return useEffect(() => {
    if (canUseDOM() && Qe) {
      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions;
      const lt = EmblaCarousel(Qe, Fe.current, Ke.current);
      return Je(lt), () => lt.destroy();
    } else
      Je(void 0);
  }, [Qe, Je]), useEffect(() => {
    areOptionsEqual(Fe.current, $e) || (Fe.current = $e, ut());
  }, [$e, ut]), useEffect(() => {
    arePluginsEqual(Ke.current, Ze) || (Ke.current = Ze, ut());
  }, [Ze, ut]), [at, Ve];
}
useEmblaCarousel.globalOptions = void 0;
function ChevronLeftIcon({
  title: $e,
  titleId: Ze,
  ...Fe
}, Ke) {
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: Ke,
    "aria-labelledby": Ze
  }, Fe), $e ? /* @__PURE__ */ React.createElement("title", {
    id: Ze
  }, $e) : null, /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    d: "M7.72 12.53a.75.75 0 010-1.06l7.5-7.5a.75.75 0 111.06 1.06L9.31 12l6.97 6.97a.75.75 0 11-1.06 1.06l-7.5-7.5z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$7 = React.forwardRef(ChevronLeftIcon), ChevronLeftIcon$1 = ForwardRef$7;
function ChevronRightIcon({
  title: $e,
  titleId: Ze,
  ...Fe
}, Ke) {
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: Ke,
    "aria-labelledby": Ze
  }, Fe), $e ? /* @__PURE__ */ React.createElement("title", {
    id: Ze
  }, $e) : null, /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    d: "M16.28 11.47a.75.75 0 010 1.06l-7.5 7.5a.75.75 0 01-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 011.06-1.06l7.5 7.5z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$6 = React.forwardRef(ChevronRightIcon), ChevronRightIcon$1 = ForwardRef$6;
function DocumentTextIcon({
  title: $e,
  titleId: Ze,
  ...Fe
}, Ke) {
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: Ke,
    "aria-labelledby": Ze
  }, Fe), $e ? /* @__PURE__ */ React.createElement("title", {
    id: Ze
  }, $e) : null, /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    d: "M5.625 1.5c-1.036 0-1.875.84-1.875 1.875v17.25c0 1.035.84 1.875 1.875 1.875h12.75c1.035 0 1.875-.84 1.875-1.875V12.75A3.75 3.75 0 0016.5 9h-1.875a1.875 1.875 0 01-1.875-1.875V5.25A3.75 3.75 0 009 1.5H5.625zM7.5 15a.75.75 0 01.75-.75h7.5a.75.75 0 010 1.5h-7.5A.75.75 0 017.5 15zm.75 2.25a.75.75 0 000 1.5H12a.75.75 0 000-1.5H8.25z",
    clipRule: "evenodd"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M12.971 1.816A5.23 5.23 0 0114.25 5.25v1.875c0 .207.168.375.375.375H16.5a5.23 5.23 0 013.434 1.279 9.768 9.768 0 00-6.963-6.963z"
  }));
}
const ForwardRef$5 = React.forwardRef(DocumentTextIcon), DocumentTextIcon$1 = ForwardRef$5;
function EnvelopeIcon({
  title: $e,
  titleId: Ze,
  ...Fe
}, Ke) {
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: Ke,
    "aria-labelledby": Ze
  }, Fe), $e ? /* @__PURE__ */ React.createElement("title", {
    id: Ze
  }, $e) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M1.5 8.67v8.58a3 3 0 003 3h15a3 3 0 003-3V8.67l-8.928 5.493a3 3 0 01-3.144 0L1.5 8.67z"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M22.5 6.908V6.75a3 3 0 00-3-3h-15a3 3 0 00-3 3v.158l9.714 5.978a1.5 1.5 0 001.572 0L22.5 6.908z"
  }));
}
const ForwardRef$4 = React.forwardRef(EnvelopeIcon), EnvelopeIcon$1 = ForwardRef$4;
function GlobeAltIcon({
  title: $e,
  titleId: Ze,
  ...Fe
}, Ke) {
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: Ke,
    "aria-labelledby": Ze
  }, Fe), $e ? /* @__PURE__ */ React.createElement("title", {
    id: Ze
  }, $e) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M21.721 12.752a9.711 9.711 0 00-.945-5.003 12.754 12.754 0 01-4.339 2.708 18.991 18.991 0 01-.214 4.772 17.165 17.165 0 005.498-2.477zM14.634 15.55a17.324 17.324 0 00.332-4.647c-.952.227-1.945.347-2.966.347-1.021 0-2.014-.12-2.966-.347a17.515 17.515 0 00.332 4.647 17.385 17.385 0 005.268 0zM9.772 17.119a18.963 18.963 0 004.456 0A17.182 17.182 0 0112 21.724a17.18 17.18 0 01-2.228-4.605zM7.777 15.23a18.87 18.87 0 01-.214-4.774 12.753 12.753 0 01-4.34-2.708 9.711 9.711 0 00-.944 5.004 17.165 17.165 0 005.498 2.477zM21.356 14.752a9.765 9.765 0 01-7.478 6.817 18.64 18.64 0 001.988-4.718 18.627 18.627 0 005.49-2.098zM2.644 14.752c1.682.971 3.53 1.688 5.49 2.099a18.64 18.64 0 001.988 4.718 9.765 9.765 0 01-7.478-6.816zM13.878 2.43a9.755 9.755 0 016.116 3.986 11.267 11.267 0 01-3.746 2.504 18.63 18.63 0 00-2.37-6.49zM12 2.276a17.152 17.152 0 012.805 7.121c-.897.23-1.837.353-2.805.353-.968 0-1.908-.122-2.805-.353A17.151 17.151 0 0112 2.276zM10.122 2.43a18.629 18.629 0 00-2.37 6.49 11.266 11.266 0 01-3.746-2.504 9.754 9.754 0 016.116-3.985z"
  }));
}
const ForwardRef$3 = React.forwardRef(GlobeAltIcon), GlobeAltIcon$1 = ForwardRef$3;
function LockClosedIcon({
  title: $e,
  titleId: Ze,
  ...Fe
}, Ke) {
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: Ke,
    "aria-labelledby": Ze
  }, Fe), $e ? /* @__PURE__ */ React.createElement("title", {
    id: Ze
  }, $e) : null, /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    d: "M12 1.5a5.25 5.25 0 00-5.25 5.25v3a3 3 0 00-3 3v6.75a3 3 0 003 3h10.5a3 3 0 003-3v-6.75a3 3 0 00-3-3v-3c0-2.9-2.35-5.25-5.25-5.25zm3.75 8.25v-3a3.75 3.75 0 10-7.5 0v3h7.5z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$2 = React.forwardRef(LockClosedIcon), LockClosedIcon$1 = ForwardRef$2;
function PhoneIcon({
  title: $e,
  titleId: Ze,
  ...Fe
}, Ke) {
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: Ke,
    "aria-labelledby": Ze
  }, Fe), $e ? /* @__PURE__ */ React.createElement("title", {
    id: Ze
  }, $e) : null, /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    d: "M1.5 4.5a3 3 0 013-3h1.372c.86 0 1.61.586 1.819 1.42l1.105 4.423a1.875 1.875 0 01-.694 1.955l-1.293.97c-.135.101-.164.249-.126.352a11.285 11.285 0 006.697 6.697c.103.038.25.009.352-.126l.97-1.293a1.875 1.875 0 011.955-.694l4.423 1.105c.834.209 1.42.959 1.42 1.82V19.5a3 3 0 01-3 3h-2.25C8.552 22.5 1.5 15.448 1.5 6.75V4.5z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$1 = React.forwardRef(PhoneIcon), PhoneIcon$1 = ForwardRef$1, Carousel = forwardRef(({ type: $e, styles: Ze, blocks: Fe }, Ke) => {
  const [Ve, Je] = useEmblaCarousel({ skipSnaps: !0 }), [Qe, at] = useState(!0), [ut, lt] = useState(!0), dt = useCallback(() => Je && Je.scrollPrev(), [Je]), bt = useCallback(() => Je && Je.scrollNext(), [Je]), $t = Ze == null ? void 0 : Ze[$e], vt = useCallback((wt) => {
    at(!wt.canScrollPrev()), lt(!wt.canScrollNext());
  }, []);
  return useEffect(() => {
    Je && (vt(Je), Je.on("reInit", vt), Je.on("select", vt));
  }, [Je, vt]), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ...$t == null ? void 0 : $t.container, "data-container": "carousel", ref: Ve, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: Ke, ...$t == null ? void 0 : $t.slidesContainer, children: Fe.map((wt, xt) => /* @__PURE__ */ jsxRuntimeExports.jsx(Block, { styles: Ze, block: wt }, xt)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ChevronLeftIcon$1,
      {
        ...$t == null ? void 0 : $t.backButton,
        "data-disabled": Qe ? "" : void 0,
        onClick: dt
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ChevronRightIcon$1,
      {
        ...$t == null ? void 0 : $t.nextButton,
        "data-disabled": ut ? "" : void 0,
        onClick: bt
      }
    )
  ] });
}), min = Math.min, max = Math.max, round$2 = Math.round, floor = Math.floor, createCoords = ($e) => ({
  x: $e,
  y: $e
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function evaluate($e, Ze) {
  return typeof $e == "function" ? $e(Ze) : $e;
}
function getSide($e) {
  return $e.split("-")[0];
}
function getAlignment($e) {
  return $e.split("-")[1];
}
function getOppositeAxis($e) {
  return $e === "x" ? "y" : "x";
}
function getAxisLength($e) {
  return $e === "y" ? "height" : "width";
}
function getSideAxis($e) {
  return ["top", "bottom"].includes(getSide($e)) ? "y" : "x";
}
function getAlignmentAxis($e) {
  return getOppositeAxis(getSideAxis($e));
}
function getAlignmentSides($e, Ze, Fe) {
  Fe === void 0 && (Fe = !1);
  const Ke = getAlignment($e), Ve = getAlignmentAxis($e), Je = getAxisLength(Ve);
  let Qe = Ve === "x" ? Ke === (Fe ? "end" : "start") ? "right" : "left" : Ke === "start" ? "bottom" : "top";
  return Ze.reference[Je] > Ze.floating[Je] && (Qe = getOppositePlacement(Qe)), [Qe, getOppositePlacement(Qe)];
}
function getExpandedPlacements($e) {
  const Ze = getOppositePlacement($e);
  return [getOppositeAlignmentPlacement($e), Ze, getOppositeAlignmentPlacement(Ze)];
}
function getOppositeAlignmentPlacement($e) {
  return $e.replace(/start|end/g, (Ze) => oppositeAlignmentMap[Ze]);
}
function getSideList($e, Ze, Fe) {
  const Ke = ["left", "right"], Ve = ["right", "left"], Je = ["top", "bottom"], Qe = ["bottom", "top"];
  switch ($e) {
    case "top":
    case "bottom":
      return Fe ? Ze ? Ve : Ke : Ze ? Ke : Ve;
    case "left":
    case "right":
      return Ze ? Je : Qe;
    default:
      return [];
  }
}
function getOppositeAxisPlacements($e, Ze, Fe, Ke) {
  const Ve = getAlignment($e);
  let Je = getSideList(getSide($e), Fe === "start", Ke);
  return Ve && (Je = Je.map((Qe) => Qe + "-" + Ve), Ze && (Je = Je.concat(Je.map(getOppositeAlignmentPlacement)))), Je;
}
function getOppositePlacement($e) {
  return $e.replace(/left|right|bottom|top/g, (Ze) => oppositeSideMap[Ze]);
}
function expandPaddingObject($e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...$e
  };
}
function getPaddingObject($e) {
  return typeof $e != "number" ? expandPaddingObject($e) : {
    top: $e,
    right: $e,
    bottom: $e,
    left: $e
  };
}
function rectToClientRect($e) {
  return {
    ...$e,
    top: $e.y,
    left: $e.x,
    right: $e.x + $e.width,
    bottom: $e.y + $e.height
  };
}
function getNodeName($e) {
  return isNode$1($e) ? ($e.nodeName || "").toLowerCase() : "#document";
}
function getWindow($e) {
  var Ze;
  return ($e == null || (Ze = $e.ownerDocument) == null ? void 0 : Ze.defaultView) || window;
}
function getDocumentElement($e) {
  var Ze;
  return (Ze = (isNode$1($e) ? $e.ownerDocument : $e.document) || window.document) == null ? void 0 : Ze.documentElement;
}
function isNode$1($e) {
  return $e instanceof Node || $e instanceof getWindow($e).Node;
}
function isElement($e) {
  return $e instanceof Element || $e instanceof getWindow($e).Element;
}
function isHTMLElement($e) {
  return $e instanceof HTMLElement || $e instanceof getWindow($e).HTMLElement;
}
function isShadowRoot($e) {
  return typeof ShadowRoot > "u" ? !1 : $e instanceof ShadowRoot || $e instanceof getWindow($e).ShadowRoot;
}
function isOverflowElement($e) {
  const {
    overflow: Ze,
    overflowX: Fe,
    overflowY: Ke,
    display: Ve
  } = getComputedStyle$1($e);
  return /auto|scroll|overlay|hidden|clip/.test(Ze + Ke + Fe) && !["inline", "contents"].includes(Ve);
}
function isTableElement($e) {
  return ["table", "td", "th"].includes(getNodeName($e));
}
function isContainingBlock($e) {
  const Ze = isWebKit(), Fe = getComputedStyle$1($e);
  return Fe.transform !== "none" || Fe.perspective !== "none" || (Fe.containerType ? Fe.containerType !== "normal" : !1) || !Ze && (Fe.backdropFilter ? Fe.backdropFilter !== "none" : !1) || !Ze && (Fe.filter ? Fe.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((Ke) => (Fe.willChange || "").includes(Ke)) || ["paint", "layout", "strict", "content"].some((Ke) => (Fe.contain || "").includes(Ke));
}
function getContainingBlock($e) {
  let Ze = getParentNode($e);
  for (; isHTMLElement(Ze) && !isLastTraversableNode(Ze); ) {
    if (isContainingBlock(Ze))
      return Ze;
    Ze = getParentNode(Ze);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode($e) {
  return ["html", "body", "#document"].includes(getNodeName($e));
}
function getComputedStyle$1($e) {
  return getWindow($e).getComputedStyle($e);
}
function getNodeScroll($e) {
  return isElement($e) ? {
    scrollLeft: $e.scrollLeft,
    scrollTop: $e.scrollTop
  } : {
    scrollLeft: $e.pageXOffset,
    scrollTop: $e.pageYOffset
  };
}
function getParentNode($e) {
  if (getNodeName($e) === "html")
    return $e;
  const Ze = (
    // Step into the shadow DOM of the parent of a slotted node.
    $e.assignedSlot || // DOM Element detected.
    $e.parentNode || // ShadowRoot detected.
    isShadowRoot($e) && $e.host || // Fallback.
    getDocumentElement($e)
  );
  return isShadowRoot(Ze) ? Ze.host : Ze;
}
function getNearestOverflowAncestor($e) {
  const Ze = getParentNode($e);
  return isLastTraversableNode(Ze) ? $e.ownerDocument ? $e.ownerDocument.body : $e.body : isHTMLElement(Ze) && isOverflowElement(Ze) ? Ze : getNearestOverflowAncestor(Ze);
}
function getOverflowAncestors($e, Ze, Fe) {
  var Ke;
  Ze === void 0 && (Ze = []), Fe === void 0 && (Fe = !0);
  const Ve = getNearestOverflowAncestor($e), Je = Ve === ((Ke = $e.ownerDocument) == null ? void 0 : Ke.body), Qe = getWindow(Ve);
  return Je ? Ze.concat(Qe, Qe.visualViewport || [], isOverflowElement(Ve) ? Ve : [], Qe.frameElement && Fe ? getOverflowAncestors(Qe.frameElement) : []) : Ze.concat(Ve, getOverflowAncestors(Ve, [], Fe));
}
function activeElement($e) {
  let Ze = $e.activeElement;
  for (; ((Fe = Ze) == null || (Ke = Fe.shadowRoot) == null ? void 0 : Ke.activeElement) != null; ) {
    var Fe, Ke;
    Ze = Ze.shadowRoot.activeElement;
  }
  return Ze;
}
function contains($e, Ze) {
  if (!$e || !Ze)
    return !1;
  const Fe = Ze.getRootNode && Ze.getRootNode();
  if ($e.contains(Ze))
    return !0;
  if (Fe && isShadowRoot(Fe)) {
    let Ke = Ze;
    for (; Ke; ) {
      if ($e === Ke)
        return !0;
      Ke = Ke.parentNode || Ke.host;
    }
  }
  return !1;
}
function getPlatform() {
  const $e = navigator.userAgentData;
  return $e != null && $e.platform ? $e.platform : navigator.platform;
}
function getUserAgent() {
  const $e = navigator.userAgentData;
  return $e && Array.isArray($e.brands) ? $e.brands.map((Ze) => {
    let {
      brand: Fe,
      version: Ke
    } = Ze;
    return Fe + "/" + Ke;
  }).join(" ") : navigator.userAgent;
}
function isVirtualClick($e) {
  if ($e.mozInputSource === 0 && $e.isTrusted)
    return !0;
  const Ze = /Android/i;
  return (Ze.test(getPlatform()) || Ze.test(getUserAgent())) && $e.pointerType ? $e.type === "click" && $e.buttons === 1 : $e.detail === 0 && !$e.pointerType;
}
function isVirtualPointerEvent($e) {
  return $e.width === 0 && $e.height === 0 || $e.width === 1 && $e.height === 1 && $e.pressure === 0 && $e.detail === 0 && $e.pointerType !== "mouse" || // iOS VoiceOver returns 0.333• for width/height.
  $e.width < 1 && $e.height < 1 && $e.pressure === 0 && $e.detail === 0;
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isMac() {
  return getPlatform().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function isMouseLikePointerType($e, Ze) {
  const Fe = ["mouse", "pen"];
  return Ze || Fe.push("", void 0), Fe.includes($e);
}
function isReactEvent($e) {
  return "nativeEvent" in $e;
}
function isRootElement($e) {
  return $e.matches("html,body");
}
function getDocument($e) {
  return ($e == null ? void 0 : $e.ownerDocument) || document;
}
function isEventTargetWithin($e, Ze) {
  if (Ze == null)
    return !1;
  if ("composedPath" in $e)
    return $e.composedPath().includes(Ze);
  const Fe = $e;
  return Fe.target != null && Ze.contains(Fe.target);
}
function getTarget($e) {
  return "composedPath" in $e ? $e.composedPath()[0] : $e.target;
}
const TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function isTypeableElement($e) {
  return isHTMLElement($e) && $e.matches(TYPEABLE_SELECTOR);
}
function stopEvent($e) {
  $e.preventDefault(), $e.stopPropagation();
}
function computeCoordsFromPlacement($e, Ze, Fe) {
  let {
    reference: Ke,
    floating: Ve
  } = $e;
  const Je = getSideAxis(Ze), Qe = getAlignmentAxis(Ze), at = getAxisLength(Qe), ut = getSide(Ze), lt = Je === "y", dt = Ke.x + Ke.width / 2 - Ve.width / 2, bt = Ke.y + Ke.height / 2 - Ve.height / 2, $t = Ke[at] / 2 - Ve[at] / 2;
  let vt;
  switch (ut) {
    case "top":
      vt = {
        x: dt,
        y: Ke.y - Ve.height
      };
      break;
    case "bottom":
      vt = {
        x: dt,
        y: Ke.y + Ke.height
      };
      break;
    case "right":
      vt = {
        x: Ke.x + Ke.width,
        y: bt
      };
      break;
    case "left":
      vt = {
        x: Ke.x - Ve.width,
        y: bt
      };
      break;
    default:
      vt = {
        x: Ke.x,
        y: Ke.y
      };
  }
  switch (getAlignment(Ze)) {
    case "start":
      vt[Qe] -= $t * (Fe && lt ? -1 : 1);
      break;
    case "end":
      vt[Qe] += $t * (Fe && lt ? -1 : 1);
      break;
  }
  return vt;
}
const computePosition$1 = async ($e, Ze, Fe) => {
  const {
    placement: Ke = "bottom",
    strategy: Ve = "absolute",
    middleware: Je = [],
    platform: Qe
  } = Fe, at = Je.filter(Boolean), ut = await (Qe.isRTL == null ? void 0 : Qe.isRTL(Ze));
  let lt = await Qe.getElementRects({
    reference: $e,
    floating: Ze,
    strategy: Ve
  }), {
    x: dt,
    y: bt
  } = computeCoordsFromPlacement(lt, Ke, ut), $t = Ke, vt = {}, wt = 0;
  for (let xt = 0; xt < at.length; xt++) {
    const {
      name: Et,
      fn: Tt
    } = at[xt], {
      x: Rt,
      y: Ct,
      data: Zt,
      reset: Lt
    } = await Tt({
      x: dt,
      y: bt,
      initialPlacement: Ke,
      placement: $t,
      strategy: Ve,
      middlewareData: vt,
      rects: lt,
      platform: Qe,
      elements: {
        reference: $e,
        floating: Ze
      }
    });
    if (dt = Rt ?? dt, bt = Ct ?? bt, vt = {
      ...vt,
      [Et]: {
        ...vt[Et],
        ...Zt
      }
    }, Lt && wt <= 50) {
      wt++, typeof Lt == "object" && (Lt.placement && ($t = Lt.placement), Lt.rects && (lt = Lt.rects === !0 ? await Qe.getElementRects({
        reference: $e,
        floating: Ze,
        strategy: Ve
      }) : Lt.rects), {
        x: dt,
        y: bt
      } = computeCoordsFromPlacement(lt, $t, ut)), xt = -1;
      continue;
    }
  }
  return {
    x: dt,
    y: bt,
    placement: $t,
    strategy: Ve,
    middlewareData: vt
  };
};
async function detectOverflow($e, Ze) {
  var Fe;
  Ze === void 0 && (Ze = {});
  const {
    x: Ke,
    y: Ve,
    platform: Je,
    rects: Qe,
    elements: at,
    strategy: ut
  } = $e, {
    boundary: lt = "clippingAncestors",
    rootBoundary: dt = "viewport",
    elementContext: bt = "floating",
    altBoundary: $t = !1,
    padding: vt = 0
  } = evaluate(Ze, $e), wt = getPaddingObject(vt), Et = at[$t ? bt === "floating" ? "reference" : "floating" : bt], Tt = rectToClientRect(await Je.getClippingRect({
    element: (Fe = await (Je.isElement == null ? void 0 : Je.isElement(Et))) == null || Fe ? Et : Et.contextElement || await (Je.getDocumentElement == null ? void 0 : Je.getDocumentElement(at.floating)),
    boundary: lt,
    rootBoundary: dt,
    strategy: ut
  })), Rt = bt === "floating" ? {
    ...Qe.floating,
    x: Ke,
    y: Ve
  } : Qe.reference, Ct = await (Je.getOffsetParent == null ? void 0 : Je.getOffsetParent(at.floating)), Zt = await (Je.isElement == null ? void 0 : Je.isElement(Ct)) ? await (Je.getScale == null ? void 0 : Je.getScale(Ct)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, Lt = rectToClientRect(Je.convertOffsetParentRelativeRectToViewportRelativeRect ? await Je.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: Rt,
    offsetParent: Ct,
    strategy: ut
  }) : Rt);
  return {
    top: (Tt.top - Lt.top + wt.top) / Zt.y,
    bottom: (Lt.bottom - Tt.bottom + wt.bottom) / Zt.y,
    left: (Tt.left - Lt.left + wt.left) / Zt.x,
    right: (Lt.right - Tt.right + wt.right) / Zt.x
  };
}
const flip = function($e) {
  return $e === void 0 && ($e = {}), {
    name: "flip",
    options: $e,
    async fn(Ze) {
      var Fe, Ke;
      const {
        placement: Ve,
        middlewareData: Je,
        rects: Qe,
        initialPlacement: at,
        platform: ut,
        elements: lt
      } = Ze, {
        mainAxis: dt = !0,
        crossAxis: bt = !0,
        fallbackPlacements: $t,
        fallbackStrategy: vt = "bestFit",
        fallbackAxisSideDirection: wt = "none",
        flipAlignment: xt = !0,
        ...Et
      } = evaluate($e, Ze);
      if ((Fe = Je.arrow) != null && Fe.alignmentOffset)
        return {};
      const Tt = getSide(Ve), Rt = getSide(at) === at, Ct = await (ut.isRTL == null ? void 0 : ut.isRTL(lt.floating)), Zt = $t || (Rt || !xt ? [getOppositePlacement(at)] : getExpandedPlacements(at));
      !$t && wt !== "none" && Zt.push(...getOppositeAxisPlacements(at, xt, wt, Ct));
      const Lt = [at, ...Zt], Ut = await detectOverflow(Ze, Et), Pt = [];
      let Ot = ((Ke = Je.flip) == null ? void 0 : Ke.overflows) || [];
      if (dt && Pt.push(Ut[Tt]), bt) {
        const Xe = getAlignmentSides(Ve, Qe, Ct);
        Pt.push(Ut[Xe[0]], Ut[Xe[1]]);
      }
      if (Ot = [...Ot, {
        placement: Ve,
        overflows: Pt
      }], !Pt.every((Xe) => Xe <= 0)) {
        var Ft, gt;
        const Xe = (((Ft = Je.flip) == null ? void 0 : Ft.index) || 0) + 1, rt = Lt[Xe];
        if (rt)
          return {
            data: {
              index: Xe,
              overflows: Ot
            },
            reset: {
              placement: rt
            }
          };
        let ot = (gt = Ot.filter((ft) => ft.overflows[0] <= 0).sort((ft, mt) => ft.overflows[1] - mt.overflows[1])[0]) == null ? void 0 : gt.placement;
        if (!ot)
          switch (vt) {
            case "bestFit": {
              var We;
              const ft = (We = Ot.map((mt) => [mt.placement, mt.overflows.filter((yt) => yt > 0).reduce((yt, pt) => yt + pt, 0)]).sort((mt, yt) => mt[1] - yt[1])[0]) == null ? void 0 : We[0];
              ft && (ot = ft);
              break;
            }
            case "initialPlacement":
              ot = at;
              break;
          }
        if (Ve !== ot)
          return {
            reset: {
              placement: ot
            }
          };
      }
      return {};
    }
  };
};
async function convertValueToCoords($e, Ze) {
  const {
    placement: Fe,
    platform: Ke,
    elements: Ve
  } = $e, Je = await (Ke.isRTL == null ? void 0 : Ke.isRTL(Ve.floating)), Qe = getSide(Fe), at = getAlignment(Fe), ut = getSideAxis(Fe) === "y", lt = ["left", "top"].includes(Qe) ? -1 : 1, dt = Je && ut ? -1 : 1, bt = evaluate(Ze, $e);
  let {
    mainAxis: $t,
    crossAxis: vt,
    alignmentAxis: wt
  } = typeof bt == "number" ? {
    mainAxis: bt,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...bt
  };
  return at && typeof wt == "number" && (vt = at === "end" ? wt * -1 : wt), ut ? {
    x: vt * dt,
    y: $t * lt
  } : {
    x: $t * lt,
    y: vt * dt
  };
}
const offset = function($e) {
  return $e === void 0 && ($e = 0), {
    name: "offset",
    options: $e,
    async fn(Ze) {
      const {
        x: Fe,
        y: Ke
      } = Ze, Ve = await convertValueToCoords(Ze, $e);
      return {
        x: Fe + Ve.x,
        y: Ke + Ve.y,
        data: Ve
      };
    }
  };
}, size = function($e) {
  return $e === void 0 && ($e = {}), {
    name: "size",
    options: $e,
    async fn(Ze) {
      const {
        placement: Fe,
        rects: Ke,
        platform: Ve,
        elements: Je
      } = Ze, {
        apply: Qe = () => {
        },
        ...at
      } = evaluate($e, Ze), ut = await detectOverflow(Ze, at), lt = getSide(Fe), dt = getAlignment(Fe), bt = getSideAxis(Fe) === "y", {
        width: $t,
        height: vt
      } = Ke.floating;
      let wt, xt;
      lt === "top" || lt === "bottom" ? (wt = lt, xt = dt === (await (Ve.isRTL == null ? void 0 : Ve.isRTL(Je.floating)) ? "start" : "end") ? "left" : "right") : (xt = lt, wt = dt === "end" ? "top" : "bottom");
      const Et = vt - ut[wt], Tt = $t - ut[xt], Rt = !Ze.middlewareData.shift;
      let Ct = Et, Zt = Tt;
      if (bt) {
        const Ut = $t - ut.left - ut.right;
        Zt = dt || Rt ? min(Tt, Ut) : Ut;
      } else {
        const Ut = vt - ut.top - ut.bottom;
        Ct = dt || Rt ? min(Et, Ut) : Ut;
      }
      if (Rt && !dt) {
        const Ut = max(ut.left, 0), Pt = max(ut.right, 0), Ot = max(ut.top, 0), Ft = max(ut.bottom, 0);
        bt ? Zt = $t - 2 * (Ut !== 0 || Pt !== 0 ? Ut + Pt : max(ut.left, ut.right)) : Ct = vt - 2 * (Ot !== 0 || Ft !== 0 ? Ot + Ft : max(ut.top, ut.bottom));
      }
      await Qe({
        ...Ze,
        availableWidth: Zt,
        availableHeight: Ct
      });
      const Lt = await Ve.getDimensions(Je.floating);
      return $t !== Lt.width || vt !== Lt.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function getCssDimensions($e) {
  const Ze = getComputedStyle$1($e);
  let Fe = parseFloat(Ze.width) || 0, Ke = parseFloat(Ze.height) || 0;
  const Ve = isHTMLElement($e), Je = Ve ? $e.offsetWidth : Fe, Qe = Ve ? $e.offsetHeight : Ke, at = round$2(Fe) !== Je || round$2(Ke) !== Qe;
  return at && (Fe = Je, Ke = Qe), {
    width: Fe,
    height: Ke,
    $: at
  };
}
function unwrapElement($e) {
  return isElement($e) ? $e : $e.contextElement;
}
function getScale($e) {
  const Ze = unwrapElement($e);
  if (!isHTMLElement(Ze))
    return createCoords(1);
  const Fe = Ze.getBoundingClientRect(), {
    width: Ke,
    height: Ve,
    $: Je
  } = getCssDimensions(Ze);
  let Qe = (Je ? round$2(Fe.width) : Fe.width) / Ke, at = (Je ? round$2(Fe.height) : Fe.height) / Ve;
  return (!Qe || !Number.isFinite(Qe)) && (Qe = 1), (!at || !Number.isFinite(at)) && (at = 1), {
    x: Qe,
    y: at
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets($e) {
  const Ze = getWindow($e);
  return !isWebKit() || !Ze.visualViewport ? noOffsets : {
    x: Ze.visualViewport.offsetLeft,
    y: Ze.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets($e, Ze, Fe) {
  return Ze === void 0 && (Ze = !1), !Fe || Ze && Fe !== getWindow($e) ? !1 : Ze;
}
function getBoundingClientRect($e, Ze, Fe, Ke) {
  Ze === void 0 && (Ze = !1), Fe === void 0 && (Fe = !1);
  const Ve = $e.getBoundingClientRect(), Je = unwrapElement($e);
  let Qe = createCoords(1);
  Ze && (Ke ? isElement(Ke) && (Qe = getScale(Ke)) : Qe = getScale($e));
  const at = shouldAddVisualOffsets(Je, Fe, Ke) ? getVisualOffsets(Je) : createCoords(0);
  let ut = (Ve.left + at.x) / Qe.x, lt = (Ve.top + at.y) / Qe.y, dt = Ve.width / Qe.x, bt = Ve.height / Qe.y;
  if (Je) {
    const $t = getWindow(Je), vt = Ke && isElement(Ke) ? getWindow(Ke) : Ke;
    let wt = $t.frameElement;
    for (; wt && Ke && vt !== $t; ) {
      const xt = getScale(wt), Et = wt.getBoundingClientRect(), Tt = getComputedStyle$1(wt), Rt = Et.left + (wt.clientLeft + parseFloat(Tt.paddingLeft)) * xt.x, Ct = Et.top + (wt.clientTop + parseFloat(Tt.paddingTop)) * xt.y;
      ut *= xt.x, lt *= xt.y, dt *= xt.x, bt *= xt.y, ut += Rt, lt += Ct, wt = getWindow(wt).frameElement;
    }
  }
  return rectToClientRect({
    width: dt,
    height: bt,
    x: ut,
    y: lt
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect($e) {
  let {
    rect: Ze,
    offsetParent: Fe,
    strategy: Ke
  } = $e;
  const Ve = isHTMLElement(Fe), Je = getDocumentElement(Fe);
  if (Fe === Je)
    return Ze;
  let Qe = {
    scrollLeft: 0,
    scrollTop: 0
  }, at = createCoords(1);
  const ut = createCoords(0);
  if ((Ve || !Ve && Ke !== "fixed") && ((getNodeName(Fe) !== "body" || isOverflowElement(Je)) && (Qe = getNodeScroll(Fe)), isHTMLElement(Fe))) {
    const lt = getBoundingClientRect(Fe);
    at = getScale(Fe), ut.x = lt.x + Fe.clientLeft, ut.y = lt.y + Fe.clientTop;
  }
  return {
    width: Ze.width * at.x,
    height: Ze.height * at.y,
    x: Ze.x * at.x - Qe.scrollLeft * at.x + ut.x,
    y: Ze.y * at.y - Qe.scrollTop * at.y + ut.y
  };
}
function getClientRects($e) {
  return Array.from($e.getClientRects());
}
function getWindowScrollBarX($e) {
  return getBoundingClientRect(getDocumentElement($e)).left + getNodeScroll($e).scrollLeft;
}
function getDocumentRect($e) {
  const Ze = getDocumentElement($e), Fe = getNodeScroll($e), Ke = $e.ownerDocument.body, Ve = max(Ze.scrollWidth, Ze.clientWidth, Ke.scrollWidth, Ke.clientWidth), Je = max(Ze.scrollHeight, Ze.clientHeight, Ke.scrollHeight, Ke.clientHeight);
  let Qe = -Fe.scrollLeft + getWindowScrollBarX($e);
  const at = -Fe.scrollTop;
  return getComputedStyle$1(Ke).direction === "rtl" && (Qe += max(Ze.clientWidth, Ke.clientWidth) - Ve), {
    width: Ve,
    height: Je,
    x: Qe,
    y: at
  };
}
function getViewportRect($e, Ze) {
  const Fe = getWindow($e), Ke = getDocumentElement($e), Ve = Fe.visualViewport;
  let Je = Ke.clientWidth, Qe = Ke.clientHeight, at = 0, ut = 0;
  if (Ve) {
    Je = Ve.width, Qe = Ve.height;
    const lt = isWebKit();
    (!lt || lt && Ze === "fixed") && (at = Ve.offsetLeft, ut = Ve.offsetTop);
  }
  return {
    width: Je,
    height: Qe,
    x: at,
    y: ut
  };
}
function getInnerBoundingClientRect($e, Ze) {
  const Fe = getBoundingClientRect($e, !0, Ze === "fixed"), Ke = Fe.top + $e.clientTop, Ve = Fe.left + $e.clientLeft, Je = isHTMLElement($e) ? getScale($e) : createCoords(1), Qe = $e.clientWidth * Je.x, at = $e.clientHeight * Je.y, ut = Ve * Je.x, lt = Ke * Je.y;
  return {
    width: Qe,
    height: at,
    x: ut,
    y: lt
  };
}
function getClientRectFromClippingAncestor($e, Ze, Fe) {
  let Ke;
  if (Ze === "viewport")
    Ke = getViewportRect($e, Fe);
  else if (Ze === "document")
    Ke = getDocumentRect(getDocumentElement($e));
  else if (isElement(Ze))
    Ke = getInnerBoundingClientRect(Ze, Fe);
  else {
    const Ve = getVisualOffsets($e);
    Ke = {
      ...Ze,
      x: Ze.x - Ve.x,
      y: Ze.y - Ve.y
    };
  }
  return rectToClientRect(Ke);
}
function hasFixedPositionAncestor($e, Ze) {
  const Fe = getParentNode($e);
  return Fe === Ze || !isElement(Fe) || isLastTraversableNode(Fe) ? !1 : getComputedStyle$1(Fe).position === "fixed" || hasFixedPositionAncestor(Fe, Ze);
}
function getClippingElementAncestors($e, Ze) {
  const Fe = Ze.get($e);
  if (Fe)
    return Fe;
  let Ke = getOverflowAncestors($e, [], !1).filter((at) => isElement(at) && getNodeName(at) !== "body"), Ve = null;
  const Je = getComputedStyle$1($e).position === "fixed";
  let Qe = Je ? getParentNode($e) : $e;
  for (; isElement(Qe) && !isLastTraversableNode(Qe); ) {
    const at = getComputedStyle$1(Qe), ut = isContainingBlock(Qe);
    !ut && at.position === "fixed" && (Ve = null), (Je ? !ut && !Ve : !ut && at.position === "static" && !!Ve && ["absolute", "fixed"].includes(Ve.position) || isOverflowElement(Qe) && !ut && hasFixedPositionAncestor($e, Qe)) ? Ke = Ke.filter((dt) => dt !== Qe) : Ve = at, Qe = getParentNode(Qe);
  }
  return Ze.set($e, Ke), Ke;
}
function getClippingRect($e) {
  let {
    element: Ze,
    boundary: Fe,
    rootBoundary: Ke,
    strategy: Ve
  } = $e;
  const Qe = [...Fe === "clippingAncestors" ? getClippingElementAncestors(Ze, this._c) : [].concat(Fe), Ke], at = Qe[0], ut = Qe.reduce((lt, dt) => {
    const bt = getClientRectFromClippingAncestor(Ze, dt, Ve);
    return lt.top = max(bt.top, lt.top), lt.right = min(bt.right, lt.right), lt.bottom = min(bt.bottom, lt.bottom), lt.left = max(bt.left, lt.left), lt;
  }, getClientRectFromClippingAncestor(Ze, at, Ve));
  return {
    width: ut.right - ut.left,
    height: ut.bottom - ut.top,
    x: ut.left,
    y: ut.top
  };
}
function getDimensions($e) {
  return getCssDimensions($e);
}
function getRectRelativeToOffsetParent($e, Ze, Fe) {
  const Ke = isHTMLElement(Ze), Ve = getDocumentElement(Ze), Je = Fe === "fixed", Qe = getBoundingClientRect($e, !0, Je, Ze);
  let at = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const ut = createCoords(0);
  if (Ke || !Ke && !Je)
    if ((getNodeName(Ze) !== "body" || isOverflowElement(Ve)) && (at = getNodeScroll(Ze)), Ke) {
      const lt = getBoundingClientRect(Ze, !0, Je, Ze);
      ut.x = lt.x + Ze.clientLeft, ut.y = lt.y + Ze.clientTop;
    } else
      Ve && (ut.x = getWindowScrollBarX(Ve));
  return {
    x: Qe.left + at.scrollLeft - ut.x,
    y: Qe.top + at.scrollTop - ut.y,
    width: Qe.width,
    height: Qe.height
  };
}
function getTrueOffsetParent($e, Ze) {
  return !isHTMLElement($e) || getComputedStyle$1($e).position === "fixed" ? null : Ze ? Ze($e) : $e.offsetParent;
}
function getOffsetParent($e, Ze) {
  const Fe = getWindow($e);
  if (!isHTMLElement($e))
    return Fe;
  let Ke = getTrueOffsetParent($e, Ze);
  for (; Ke && isTableElement(Ke) && getComputedStyle$1(Ke).position === "static"; )
    Ke = getTrueOffsetParent(Ke, Ze);
  return Ke && (getNodeName(Ke) === "html" || getNodeName(Ke) === "body" && getComputedStyle$1(Ke).position === "static" && !isContainingBlock(Ke)) ? Fe : Ke || getContainingBlock($e) || Fe;
}
const getElementRects = async function($e) {
  let {
    reference: Ze,
    floating: Fe,
    strategy: Ke
  } = $e;
  const Ve = this.getOffsetParent || getOffsetParent, Je = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(Ze, await Ve(Fe), Ke),
    floating: {
      x: 0,
      y: 0,
      ...await Je(Fe)
    }
  };
};
function isRTL($e) {
  return getComputedStyle$1($e).direction === "rtl";
}
const platform$3 = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove($e, Ze) {
  let Fe = null, Ke;
  const Ve = getDocumentElement($e);
  function Je() {
    clearTimeout(Ke), Fe && Fe.disconnect(), Fe = null;
  }
  function Qe(at, ut) {
    at === void 0 && (at = !1), ut === void 0 && (ut = 1), Je();
    const {
      left: lt,
      top: dt,
      width: bt,
      height: $t
    } = $e.getBoundingClientRect();
    if (at || Ze(), !bt || !$t)
      return;
    const vt = floor(dt), wt = floor(Ve.clientWidth - (lt + bt)), xt = floor(Ve.clientHeight - (dt + $t)), Et = floor(lt), Rt = {
      rootMargin: -vt + "px " + -wt + "px " + -xt + "px " + -Et + "px",
      threshold: max(0, min(1, ut)) || 1
    };
    let Ct = !0;
    function Zt(Lt) {
      const Ut = Lt[0].intersectionRatio;
      if (Ut !== ut) {
        if (!Ct)
          return Qe();
        Ut ? Qe(!1, Ut) : Ke = setTimeout(() => {
          Qe(!1, 1e-7);
        }, 100);
      }
      Ct = !1;
    }
    try {
      Fe = new IntersectionObserver(Zt, {
        ...Rt,
        // Handle <iframe>s
        root: Ve.ownerDocument
      });
    } catch {
      Fe = new IntersectionObserver(Zt, Rt);
    }
    Fe.observe($e);
  }
  return Qe(!0), Je;
}
function autoUpdate($e, Ze, Fe, Ke) {
  Ke === void 0 && (Ke = {});
  const {
    ancestorScroll: Ve = !0,
    ancestorResize: Je = !0,
    elementResize: Qe = typeof ResizeObserver == "function",
    layoutShift: at = typeof IntersectionObserver == "function",
    animationFrame: ut = !1
  } = Ke, lt = unwrapElement($e), dt = Ve || Je ? [...lt ? getOverflowAncestors(lt) : [], ...getOverflowAncestors(Ze)] : [];
  dt.forEach((Tt) => {
    Ve && Tt.addEventListener("scroll", Fe, {
      passive: !0
    }), Je && Tt.addEventListener("resize", Fe);
  });
  const bt = lt && at ? observeMove(lt, Fe) : null;
  let $t = -1, vt = null;
  Qe && (vt = new ResizeObserver((Tt) => {
    let [Rt] = Tt;
    Rt && Rt.target === lt && vt && (vt.unobserve(Ze), cancelAnimationFrame($t), $t = requestAnimationFrame(() => {
      vt && vt.observe(Ze);
    })), Fe();
  }), lt && !ut && vt.observe(lt), vt.observe(Ze));
  let wt, xt = ut ? getBoundingClientRect($e) : null;
  ut && Et();
  function Et() {
    const Tt = getBoundingClientRect($e);
    xt && (Tt.x !== xt.x || Tt.y !== xt.y || Tt.width !== xt.width || Tt.height !== xt.height) && Fe(), xt = Tt, wt = requestAnimationFrame(Et);
  }
  return Fe(), () => {
    dt.forEach((Tt) => {
      Ve && Tt.removeEventListener("scroll", Fe), Je && Tt.removeEventListener("resize", Fe);
    }), bt && bt(), vt && vt.disconnect(), vt = null, ut && cancelAnimationFrame(wt);
  };
}
const computePosition = ($e, Ze, Fe) => {
  const Ke = /* @__PURE__ */ new Map(), Ve = {
    platform: platform$3,
    ...Fe
  }, Je = {
    ...Ve.platform,
    _c: Ke
  };
  return computePosition$1($e, Ze, {
    ...Ve,
    platform: Je
  });
};
var index$2 = typeof document < "u" ? useLayoutEffect : useEffect;
function deepEqual($e, Ze) {
  if ($e === Ze)
    return !0;
  if (typeof $e != typeof Ze)
    return !1;
  if (typeof $e == "function" && $e.toString() === Ze.toString())
    return !0;
  let Fe, Ke, Ve;
  if ($e && Ze && typeof $e == "object") {
    if (Array.isArray($e)) {
      if (Fe = $e.length, Fe != Ze.length)
        return !1;
      for (Ke = Fe; Ke-- !== 0; )
        if (!deepEqual($e[Ke], Ze[Ke]))
          return !1;
      return !0;
    }
    if (Ve = Object.keys($e), Fe = Ve.length, Fe !== Object.keys(Ze).length)
      return !1;
    for (Ke = Fe; Ke-- !== 0; )
      if (!{}.hasOwnProperty.call(Ze, Ve[Ke]))
        return !1;
    for (Ke = Fe; Ke-- !== 0; ) {
      const Je = Ve[Ke];
      if (!(Je === "_owner" && $e.$$typeof) && !deepEqual($e[Je], Ze[Je]))
        return !1;
    }
    return !0;
  }
  return $e !== $e && Ze !== Ze;
}
function getDPR($e) {
  return typeof window > "u" ? 1 : ($e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR($e, Ze) {
  const Fe = getDPR($e);
  return Math.round(Ze * Fe) / Fe;
}
function useLatestRef$1($e) {
  const Ze = React.useRef($e);
  return index$2(() => {
    Ze.current = $e;
  }), Ze;
}
function useFloating$1($e) {
  $e === void 0 && ($e = {});
  const {
    placement: Ze = "bottom",
    strategy: Fe = "absolute",
    middleware: Ke = [],
    platform: Ve,
    elements: {
      reference: Je,
      floating: Qe
    } = {},
    transform: at = !0,
    whileElementsMounted: ut,
    open: lt
  } = $e, [dt, bt] = React.useState({
    x: 0,
    y: 0,
    strategy: Fe,
    placement: Ze,
    middlewareData: {},
    isPositioned: !1
  }), [$t, vt] = React.useState(Ke);
  deepEqual($t, Ke) || vt(Ke);
  const [wt, xt] = React.useState(null), [Et, Tt] = React.useState(null), Rt = React.useCallback((mt) => {
    mt != Ut.current && (Ut.current = mt, xt(mt));
  }, [xt]), Ct = React.useCallback((mt) => {
    mt !== Pt.current && (Pt.current = mt, Tt(mt));
  }, [Tt]), Zt = Je || wt, Lt = Qe || Et, Ut = React.useRef(null), Pt = React.useRef(null), Ot = React.useRef(dt), Ft = useLatestRef$1(ut), gt = useLatestRef$1(Ve), We = React.useCallback(() => {
    if (!Ut.current || !Pt.current)
      return;
    const mt = {
      placement: Ze,
      strategy: Fe,
      middleware: $t
    };
    gt.current && (mt.platform = gt.current), computePosition(Ut.current, Pt.current, mt).then((yt) => {
      const pt = {
        ...yt,
        isPositioned: !0
      };
      Xe.current && !deepEqual(Ot.current, pt) && (Ot.current = pt, ReactDOM.flushSync(() => {
        bt(pt);
      }));
    });
  }, [$t, Ze, Fe, gt]);
  index$2(() => {
    lt === !1 && Ot.current.isPositioned && (Ot.current.isPositioned = !1, bt((mt) => ({
      ...mt,
      isPositioned: !1
    })));
  }, [lt]);
  const Xe = React.useRef(!1);
  index$2(() => (Xe.current = !0, () => {
    Xe.current = !1;
  }), []), index$2(() => {
    if (Zt && (Ut.current = Zt), Lt && (Pt.current = Lt), Zt && Lt) {
      if (Ft.current)
        return Ft.current(Zt, Lt, We);
      We();
    }
  }, [Zt, Lt, We, Ft]);
  const rt = React.useMemo(() => ({
    reference: Ut,
    floating: Pt,
    setReference: Rt,
    setFloating: Ct
  }), [Rt, Ct]), ot = React.useMemo(() => ({
    reference: Zt,
    floating: Lt
  }), [Zt, Lt]), ft = React.useMemo(() => {
    const mt = {
      position: Fe,
      left: 0,
      top: 0
    };
    if (!ot.floating)
      return mt;
    const yt = roundByDPR(ot.floating, dt.x), pt = roundByDPR(ot.floating, dt.y);
    return at ? {
      ...mt,
      transform: "translate(" + yt + "px, " + pt + "px)",
      ...getDPR(ot.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: Fe,
      left: yt,
      top: pt
    };
  }, [Fe, at, ot.floating, dt.x, dt.y]);
  return React.useMemo(() => ({
    ...dt,
    update: We,
    refs: rt,
    elements: ot,
    floatingStyles: ft
  }), [dt, We, rt, ot, ft]);
}
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], candidateSelector = /* @__PURE__ */ candidateSelectors.join(","), NoElement = typeof Element > "u", matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, getRootNode = !NoElement && Element.prototype.getRootNode ? function($e) {
  var Ze;
  return $e == null || (Ze = $e.getRootNode) === null || Ze === void 0 ? void 0 : Ze.call($e);
} : function($e) {
  return $e == null ? void 0 : $e.ownerDocument;
}, isInert = function $e(Ze, Fe) {
  var Ke;
  Fe === void 0 && (Fe = !0);
  var Ve = Ze == null || (Ke = Ze.getAttribute) === null || Ke === void 0 ? void 0 : Ke.call(Ze, "inert"), Je = Ve === "" || Ve === "true", Qe = Je || Fe && Ze && $e(Ze.parentNode);
  return Qe;
}, isContentEditable = function(Ze) {
  var Fe, Ke = Ze == null || (Fe = Ze.getAttribute) === null || Fe === void 0 ? void 0 : Fe.call(Ze, "contenteditable");
  return Ke === "" || Ke === "true";
}, getCandidates = function(Ze, Fe, Ke) {
  if (isInert(Ze))
    return [];
  var Ve = Array.prototype.slice.apply(Ze.querySelectorAll(candidateSelector));
  return Fe && matches.call(Ze, candidateSelector) && Ve.unshift(Ze), Ve = Ve.filter(Ke), Ve;
}, getCandidatesIteratively = function $e(Ze, Fe, Ke) {
  for (var Ve = [], Je = Array.from(Ze); Je.length; ) {
    var Qe = Je.shift();
    if (!isInert(Qe, !1))
      if (Qe.tagName === "SLOT") {
        var at = Qe.assignedElements(), ut = at.length ? at : Qe.children, lt = $e(ut, !0, Ke);
        Ke.flatten ? Ve.push.apply(Ve, lt) : Ve.push({
          scopeParent: Qe,
          candidates: lt
        });
      } else {
        var dt = matches.call(Qe, candidateSelector);
        dt && Ke.filter(Qe) && (Fe || !Ze.includes(Qe)) && Ve.push(Qe);
        var bt = Qe.shadowRoot || // check for an undisclosed shadow
        typeof Ke.getShadowRoot == "function" && Ke.getShadowRoot(Qe), $t = !isInert(bt, !1) && (!Ke.shadowRootFilter || Ke.shadowRootFilter(Qe));
        if (bt && $t) {
          var vt = $e(bt === !0 ? Qe.children : bt.children, !0, Ke);
          Ke.flatten ? Ve.push.apply(Ve, vt) : Ve.push({
            scopeParent: Qe,
            candidates: vt
          });
        } else
          Je.unshift.apply(Je, Qe.children);
      }
  }
  return Ve;
}, hasTabIndex = function(Ze) {
  return !isNaN(parseInt(Ze.getAttribute("tabindex"), 10));
}, getTabIndex = function(Ze) {
  if (!Ze)
    throw new Error("No node provided");
  return Ze.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(Ze.tagName) || isContentEditable(Ze)) && !hasTabIndex(Ze) ? 0 : Ze.tabIndex;
}, getSortOrderTabIndex = function(Ze, Fe) {
  var Ke = getTabIndex(Ze);
  return Ke < 0 && Fe && !hasTabIndex(Ze) ? 0 : Ke;
}, sortOrderedTabbables = function(Ze, Fe) {
  return Ze.tabIndex === Fe.tabIndex ? Ze.documentOrder - Fe.documentOrder : Ze.tabIndex - Fe.tabIndex;
}, isInput = function(Ze) {
  return Ze.tagName === "INPUT";
}, isHiddenInput = function(Ze) {
  return isInput(Ze) && Ze.type === "hidden";
}, isDetailsWithSummary = function(Ze) {
  var Fe = Ze.tagName === "DETAILS" && Array.prototype.slice.apply(Ze.children).some(function(Ke) {
    return Ke.tagName === "SUMMARY";
  });
  return Fe;
}, getCheckedRadio = function(Ze, Fe) {
  for (var Ke = 0; Ke < Ze.length; Ke++)
    if (Ze[Ke].checked && Ze[Ke].form === Fe)
      return Ze[Ke];
}, isTabbableRadio = function(Ze) {
  if (!Ze.name)
    return !0;
  var Fe = Ze.form || getRootNode(Ze), Ke = function(at) {
    return Fe.querySelectorAll('input[type="radio"][name="' + at + '"]');
  }, Ve;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    Ve = Ke(window.CSS.escape(Ze.name));
  else
    try {
      Ve = Ke(Ze.name);
    } catch (Qe) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", Qe.message), !1;
    }
  var Je = getCheckedRadio(Ve, Ze.form);
  return !Je || Je === Ze;
}, isRadio = function(Ze) {
  return isInput(Ze) && Ze.type === "radio";
}, isNonTabbableRadio = function(Ze) {
  return isRadio(Ze) && !isTabbableRadio(Ze);
}, isNodeAttached = function(Ze) {
  var Fe, Ke = Ze && getRootNode(Ze), Ve = (Fe = Ke) === null || Fe === void 0 ? void 0 : Fe.host, Je = !1;
  if (Ke && Ke !== Ze) {
    var Qe, at, ut;
    for (Je = !!((Qe = Ve) !== null && Qe !== void 0 && (at = Qe.ownerDocument) !== null && at !== void 0 && at.contains(Ve) || Ze != null && (ut = Ze.ownerDocument) !== null && ut !== void 0 && ut.contains(Ze)); !Je && Ve; ) {
      var lt, dt, bt;
      Ke = getRootNode(Ve), Ve = (lt = Ke) === null || lt === void 0 ? void 0 : lt.host, Je = !!((dt = Ve) !== null && dt !== void 0 && (bt = dt.ownerDocument) !== null && bt !== void 0 && bt.contains(Ve));
    }
  }
  return Je;
}, isZeroArea = function(Ze) {
  var Fe = Ze.getBoundingClientRect(), Ke = Fe.width, Ve = Fe.height;
  return Ke === 0 && Ve === 0;
}, isHidden = function(Ze, Fe) {
  var Ke = Fe.displayCheck, Ve = Fe.getShadowRoot;
  if (getComputedStyle(Ze).visibility === "hidden")
    return !0;
  var Je = matches.call(Ze, "details>summary:first-of-type"), Qe = Je ? Ze.parentElement : Ze;
  if (matches.call(Qe, "details:not([open]) *"))
    return !0;
  if (!Ke || Ke === "full" || Ke === "legacy-full") {
    if (typeof Ve == "function") {
      for (var at = Ze; Ze; ) {
        var ut = Ze.parentElement, lt = getRootNode(Ze);
        if (ut && !ut.shadowRoot && Ve(ut) === !0)
          return isZeroArea(Ze);
        Ze.assignedSlot ? Ze = Ze.assignedSlot : !ut && lt !== Ze.ownerDocument ? Ze = lt.host : Ze = ut;
      }
      Ze = at;
    }
    if (isNodeAttached(Ze))
      return !Ze.getClientRects().length;
    if (Ke !== "legacy-full")
      return !0;
  } else if (Ke === "non-zero-area")
    return isZeroArea(Ze);
  return !1;
}, isDisabledFromFieldset = function(Ze) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(Ze.tagName))
    for (var Fe = Ze.parentElement; Fe; ) {
      if (Fe.tagName === "FIELDSET" && Fe.disabled) {
        for (var Ke = 0; Ke < Fe.children.length; Ke++) {
          var Ve = Fe.children.item(Ke);
          if (Ve.tagName === "LEGEND")
            return matches.call(Fe, "fieldset[disabled] *") ? !0 : !Ve.contains(Ze);
        }
        return !0;
      }
      Fe = Fe.parentElement;
    }
  return !1;
}, isNodeMatchingSelectorFocusable = function(Ze, Fe) {
  return !(Fe.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(Fe) || isHiddenInput(Fe) || isHidden(Fe, Ze) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(Fe) || isDisabledFromFieldset(Fe));
}, isNodeMatchingSelectorTabbable = function(Ze, Fe) {
  return !(isNonTabbableRadio(Fe) || getTabIndex(Fe) < 0 || !isNodeMatchingSelectorFocusable(Ze, Fe));
}, isValidShadowRootTabbable = function(Ze) {
  var Fe = parseInt(Ze.getAttribute("tabindex"), 10);
  return !!(isNaN(Fe) || Fe >= 0);
}, sortByOrder = function $e(Ze) {
  var Fe = [], Ke = [];
  return Ze.forEach(function(Ve, Je) {
    var Qe = !!Ve.scopeParent, at = Qe ? Ve.scopeParent : Ve, ut = getSortOrderTabIndex(at, Qe), lt = Qe ? $e(Ve.candidates) : at;
    ut === 0 ? Qe ? Fe.push.apply(Fe, lt) : Fe.push(at) : Ke.push({
      documentOrder: Je,
      tabIndex: ut,
      item: Ve,
      isScope: Qe,
      content: lt
    });
  }), Ke.sort(sortOrderedTabbables).reduce(function(Ve, Je) {
    return Je.isScope ? Ve.push.apply(Ve, Je.content) : Ve.push(Je.content), Ve;
  }, []).concat(Fe);
}, tabbable = function(Ze, Fe) {
  Fe = Fe || {};
  var Ke;
  return Fe.getShadowRoot ? Ke = getCandidatesIteratively([Ze], Fe.includeContainer, {
    filter: isNodeMatchingSelectorTabbable.bind(null, Fe),
    flatten: !1,
    getShadowRoot: Fe.getShadowRoot,
    shadowRootFilter: isValidShadowRootTabbable
  }) : Ke = getCandidates(Ze, Fe.includeContainer, isNodeMatchingSelectorTabbable.bind(null, Fe)), sortByOrder(Ke);
};
const ARROW_UP = "ArrowUp", ARROW_DOWN = "ArrowDown", ARROW_LEFT = "ArrowLeft", ARROW_RIGHT = "ArrowRight";
function isDifferentRow($e, Ze, Fe) {
  return Math.floor($e / Ze) !== Fe;
}
function isIndexOutOfBounds($e, Ze) {
  return Ze < 0 || Ze >= $e.current.length;
}
function getMinIndex($e, Ze) {
  return findNonDisabledIndex($e, {
    disabledIndices: Ze
  });
}
function getMaxIndex($e, Ze) {
  return findNonDisabledIndex($e, {
    decrement: !0,
    startingIndex: $e.current.length,
    disabledIndices: Ze
  });
}
function findNonDisabledIndex($e, Ze) {
  let {
    startingIndex: Fe = -1,
    decrement: Ke = !1,
    disabledIndices: Ve,
    amount: Je = 1
  } = Ze === void 0 ? {} : Ze;
  const Qe = $e.current;
  let at = Fe;
  do {
    var ut, lt;
    at = at + (Ke ? -Je : Je);
  } while (at >= 0 && at <= Qe.length - 1 && (Ve ? Ve.includes(at) : Qe[at] == null || (ut = Qe[at]) != null && ut.hasAttribute("disabled") || ((lt = Qe[at]) == null ? void 0 : lt.getAttribute("aria-disabled")) === "true"));
  return at;
}
function getGridNavigatedIndex($e, Ze) {
  let {
    event: Fe,
    orientation: Ke,
    loop: Ve,
    cols: Je,
    disabledIndices: Qe,
    minIndex: at,
    maxIndex: ut,
    prevIndex: lt,
    stopEvent: dt = !1
  } = Ze, bt = lt;
  if (Fe.key === ARROW_UP) {
    if (dt && stopEvent(Fe), lt === -1)
      bt = ut;
    else if (bt = findNonDisabledIndex($e, {
      startingIndex: bt,
      amount: Je,
      decrement: !0,
      disabledIndices: Qe
    }), Ve && (lt - Je < at || bt < 0)) {
      const $t = lt % Je, vt = ut % Je, wt = ut - (vt - $t);
      vt === $t ? bt = ut : bt = vt > $t ? wt : wt - Je;
    }
    isIndexOutOfBounds($e, bt) && (bt = lt);
  }
  if (Fe.key === ARROW_DOWN && (dt && stopEvent(Fe), lt === -1 ? bt = at : (bt = findNonDisabledIndex($e, {
    startingIndex: lt,
    amount: Je,
    disabledIndices: Qe
  }), Ve && lt + Je > ut && (bt = findNonDisabledIndex($e, {
    startingIndex: lt % Je - Je,
    amount: Je,
    disabledIndices: Qe
  }))), isIndexOutOfBounds($e, bt) && (bt = lt)), Ke === "both") {
    const $t = floor(lt / Je);
    Fe.key === ARROW_RIGHT && (dt && stopEvent(Fe), lt % Je !== Je - 1 ? (bt = findNonDisabledIndex($e, {
      startingIndex: lt,
      disabledIndices: Qe
    }), Ve && isDifferentRow(bt, Je, $t) && (bt = findNonDisabledIndex($e, {
      startingIndex: lt - lt % Je - 1,
      disabledIndices: Qe
    }))) : Ve && (bt = findNonDisabledIndex($e, {
      startingIndex: lt - lt % Je - 1,
      disabledIndices: Qe
    })), isDifferentRow(bt, Je, $t) && (bt = lt)), Fe.key === ARROW_LEFT && (dt && stopEvent(Fe), lt % Je !== 0 ? (bt = findNonDisabledIndex($e, {
      startingIndex: lt,
      disabledIndices: Qe,
      decrement: !0
    }), Ve && isDifferentRow(bt, Je, $t) && (bt = findNonDisabledIndex($e, {
      startingIndex: lt + (Je - lt % Je),
      decrement: !0,
      disabledIndices: Qe
    }))) : Ve && (bt = findNonDisabledIndex($e, {
      startingIndex: lt + (Je - lt % Je),
      decrement: !0,
      disabledIndices: Qe
    })), isDifferentRow(bt, Je, $t) && (bt = lt));
    const vt = floor(ut / Je) === $t;
    isIndexOutOfBounds($e, bt) && (Ve && vt ? bt = Fe.key === ARROW_LEFT ? ut : findNonDisabledIndex($e, {
      startingIndex: lt - lt % Je - 1,
      disabledIndices: Qe
    }) : bt = lt);
  }
  return bt;
}
let rafId = 0;
function enqueueFocus($e, Ze) {
  Ze === void 0 && (Ze = {});
  const {
    preventScroll: Fe = !1,
    cancelPrevious: Ke = !0,
    sync: Ve = !1
  } = Ze;
  Ke && cancelAnimationFrame(rafId);
  const Je = () => $e == null ? void 0 : $e.focus({
    preventScroll: Fe
  });
  Ve ? Je() : rafId = requestAnimationFrame(Je);
}
var index$1 = typeof document < "u" ? useLayoutEffect : useEffect;
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function($e) {
    for (var Ze = 1; Ze < arguments.length; Ze++) {
      var Fe = arguments[Ze];
      for (var Ke in Fe)
        Object.prototype.hasOwnProperty.call(Fe, Ke) && ($e[Ke] = Fe[Ke]);
    }
    return $e;
  }, _extends.apply(this, arguments);
}
let serverHandoffComplete = !1, count = 0;
const genId = () => "floating-ui-" + count++;
function useFloatingId() {
  const [$e, Ze] = React.useState(() => serverHandoffComplete ? genId() : void 0);
  return index$1(() => {
    $e == null && Ze(genId());
  }, []), React.useEffect(() => {
    serverHandoffComplete || (serverHandoffComplete = !0);
  }, []), $e;
}
const useReactId = React[/* @__PURE__ */ "useId".toString()], useId = useReactId || useFloatingId;
function createPubSub() {
  const $e = /* @__PURE__ */ new Map();
  return {
    emit(Ze, Fe) {
      var Ke;
      (Ke = $e.get(Ze)) == null || Ke.forEach((Ve) => Ve(Fe));
    },
    on(Ze, Fe) {
      $e.set(Ze, [...$e.get(Ze) || [], Fe]);
    },
    off(Ze, Fe) {
      var Ke;
      $e.set(Ze, ((Ke = $e.get(Ze)) == null ? void 0 : Ke.filter((Ve) => Ve !== Fe)) || []);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ React.createContext(null), FloatingTreeContext = /* @__PURE__ */ React.createContext(null), useFloatingParentNodeId = () => {
  var $e;
  return (($e = React.useContext(FloatingNodeContext)) == null ? void 0 : $e.id) || null;
}, useFloatingTree = () => React.useContext(FloatingTreeContext);
function createAttribute($e) {
  return "data-floating-ui-" + $e;
}
function useLatestRef($e) {
  const Ze = useRef($e);
  return index$1(() => {
    Ze.current = $e;
  }), Ze;
}
function getAncestors($e, Ze) {
  var Fe;
  let Ke = [], Ve = (Fe = $e.find((Je) => Je.id === Ze)) == null ? void 0 : Fe.parentId;
  for (; Ve; ) {
    const Je = $e.find((Qe) => Qe.id === Ve);
    Ve = Je == null ? void 0 : Je.parentId, Je && (Ke = Ke.concat(Je));
  }
  return Ke;
}
function getChildren($e, Ze) {
  let Fe = $e.filter((Ve) => {
    var Je;
    return Ve.parentId === Ze && ((Je = Ve.context) == null ? void 0 : Je.open);
  }), Ke = Fe;
  for (; Ke.length; )
    Ke = $e.filter((Ve) => {
      var Je;
      return (Je = Ke) == null ? void 0 : Je.some((Qe) => {
        var at;
        return Ve.parentId === Qe.id && ((at = Ve.context) == null ? void 0 : at.open);
      });
    }), Fe = Fe.concat(Ke);
  return Fe;
}
function getDeepestNode($e, Ze) {
  let Fe, Ke = -1;
  function Ve(Je, Qe) {
    Qe > Ke && (Fe = Je, Ke = Qe), getChildren($e, Je).forEach((ut) => {
      Ve(ut.id, Qe + 1);
    });
  }
  return Ve(Ze, 0), $e.find((Je) => Je.id === Fe);
}
let counterMap$1 = /* @__PURE__ */ new WeakMap(), uncontrolledElementsSet = /* @__PURE__ */ new WeakSet(), markerMap$1 = {}, lockCount$1 = 0;
const supportsInert = () => typeof HTMLElement < "u" && "inert" in HTMLElement.prototype, unwrapHost$1 = ($e) => $e && ($e.host || unwrapHost$1($e.parentNode)), correctElements = ($e, Ze) => Ze.map((Fe) => {
  if ($e.contains(Fe))
    return Fe;
  const Ke = unwrapHost$1(Fe);
  return $e.contains(Ke) ? Ke : null;
}).filter((Fe) => Fe != null);
function applyAttributeToOthers$1($e, Ze, Fe, Ke) {
  const Ve = "data-floating-ui-inert", Je = Ke ? "inert" : Fe ? "aria-hidden" : null, Qe = correctElements(Ze, $e), at = /* @__PURE__ */ new Set(), ut = new Set(Qe), lt = [];
  markerMap$1[Ve] || (markerMap$1[Ve] = /* @__PURE__ */ new WeakMap());
  const dt = markerMap$1[Ve];
  Qe.forEach(bt), $t(Ze), at.clear();
  function bt(vt) {
    !vt || at.has(vt) || (at.add(vt), vt.parentNode && bt(vt.parentNode));
  }
  function $t(vt) {
    !vt || ut.has(vt) || Array.prototype.forEach.call(vt.children, (wt) => {
      if (at.has(wt))
        $t(wt);
      else {
        const xt = Je ? wt.getAttribute(Je) : null, Et = xt !== null && xt !== "false", Tt = (counterMap$1.get(wt) || 0) + 1, Rt = (dt.get(wt) || 0) + 1;
        counterMap$1.set(wt, Tt), dt.set(wt, Rt), lt.push(wt), Tt === 1 && Et && uncontrolledElementsSet.add(wt), Rt === 1 && wt.setAttribute(Ve, ""), !Et && Je && wt.setAttribute(Je, "true");
      }
    });
  }
  return lockCount$1++, () => {
    lt.forEach((vt) => {
      const wt = (counterMap$1.get(vt) || 0) - 1, xt = (dt.get(vt) || 0) - 1;
      counterMap$1.set(vt, wt), dt.set(vt, xt), wt || (!uncontrolledElementsSet.has(vt) && Je && vt.removeAttribute(Je), uncontrolledElementsSet.delete(vt)), xt || vt.removeAttribute(Ve);
    }), lockCount$1--, lockCount$1 || (counterMap$1 = /* @__PURE__ */ new WeakMap(), counterMap$1 = /* @__PURE__ */ new WeakMap(), uncontrolledElementsSet = /* @__PURE__ */ new WeakSet(), markerMap$1 = {});
  };
}
function markOthers($e, Ze, Fe) {
  Ze === void 0 && (Ze = !1), Fe === void 0 && (Fe = !1);
  const Ke = getDocument($e[0]).body;
  return applyAttributeToOthers$1($e.concat(Array.from(Ke.querySelectorAll("[aria-live]"))), Ke, Ze, Fe);
}
const getTabbableOptions = () => ({
  getShadowRoot: !0,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver == "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function getTabbableIn($e, Ze) {
  const Fe = tabbable($e, getTabbableOptions());
  Ze === "prev" && Fe.reverse();
  const Ke = Fe.indexOf(activeElement(getDocument($e)));
  return Fe.slice(Ke + 1)[0];
}
function getNextTabbable() {
  return getTabbableIn(document.body, "next");
}
function getPreviousTabbable() {
  return getTabbableIn(document.body, "prev");
}
function isOutsideEvent($e, Ze) {
  const Fe = Ze || $e.currentTarget, Ke = $e.relatedTarget;
  return !Ke || !contains(Fe, Ke);
}
function disableFocusInside($e) {
  tabbable($e, getTabbableOptions()).forEach((Fe) => {
    Fe.dataset.tabindex = Fe.getAttribute("tabindex") || "", Fe.setAttribute("tabindex", "-1");
  });
}
function enableFocusInside($e) {
  $e.querySelectorAll("[data-tabindex]").forEach((Fe) => {
    const Ke = Fe.dataset.tabindex;
    delete Fe.dataset.tabindex, Ke ? Fe.setAttribute("tabindex", Ke) : Fe.removeAttribute("tabindex");
  });
}
const HIDDEN_STYLES = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
let timeoutId;
function setActiveElementOnTab($e) {
  $e.key === "Tab" && ($e.target, clearTimeout(timeoutId));
}
const FocusGuard = /* @__PURE__ */ React.forwardRef(function(Ze, Fe) {
  const [Ke, Ve] = React.useState();
  index$1(() => (isSafari() && Ve("button"), document.addEventListener("keydown", setActiveElementOnTab), () => {
    document.removeEventListener("keydown", setActiveElementOnTab);
  }), []);
  const Je = {
    ref: Fe,
    tabIndex: 0,
    // Role is only for VoiceOver
    role: Ke,
    "aria-hidden": Ke ? void 0 : !0,
    [createAttribute("focus-guard")]: "",
    style: HIDDEN_STYLES
  };
  return /* @__PURE__ */ React.createElement("span", _extends({}, Ze, Je));
}), PortalContext = /* @__PURE__ */ React.createContext(null);
function useFloatingPortalNode($e) {
  let {
    id: Ze,
    root: Fe
  } = $e === void 0 ? {} : $e;
  const [Ke, Ve] = React.useState(null), Je = useId(), Qe = usePortalContext(), at = React.useMemo(() => ({
    id: Ze,
    root: Fe,
    portalContext: Qe,
    uniqueId: Je
  }), [Ze, Fe, Qe, Je]), ut = React.useRef();
  return index$1(() => () => {
    Ke == null || Ke.remove();
  }, [Ke, at]), index$1(() => {
    if (ut.current === at)
      return;
    ut.current = at;
    const {
      id: lt,
      root: dt,
      portalContext: bt,
      uniqueId: $t
    } = at, vt = lt ? document.getElementById(lt) : null, wt = createAttribute("portal");
    if (vt) {
      const xt = document.createElement("div");
      xt.id = $t, xt.setAttribute(wt, ""), vt.appendChild(xt), Ve(xt);
    } else {
      let xt = dt || (bt == null ? void 0 : bt.portalNode);
      xt && !isElement(xt) && (xt = xt.current), xt = xt || document.body;
      let Et = null;
      lt && (Et = document.createElement("div"), Et.id = lt, xt.appendChild(Et));
      const Tt = document.createElement("div");
      Tt.id = $t, Tt.setAttribute(wt, ""), xt = Et || xt, xt.appendChild(Tt), Ve(Tt);
    }
  }, [at]), Ke;
}
function FloatingPortal($e) {
  let {
    children: Ze,
    id: Fe,
    root: Ke = null,
    preserveTabOrder: Ve = !0
  } = $e;
  const Je = useFloatingPortalNode({
    id: Fe,
    root: Ke
  }), [Qe, at] = React.useState(null), ut = React.useRef(null), lt = React.useRef(null), dt = React.useRef(null), bt = React.useRef(null), $t = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!Qe && // Guards are only for non-modal focus management.
    !Qe.modal && // Don't render if unmount is transitioning.
    Qe.open && Ve && !!(Ke || Je)
  );
  return React.useEffect(() => {
    if (!Je || !Ve || Qe != null && Qe.modal)
      return;
    function vt(wt) {
      Je && isOutsideEvent(wt) && (wt.type === "focusin" ? enableFocusInside : disableFocusInside)(Je);
    }
    return Je.addEventListener("focusin", vt, !0), Je.addEventListener("focusout", vt, !0), () => {
      Je.removeEventListener("focusin", vt, !0), Je.removeEventListener("focusout", vt, !0);
    };
  }, [Je, Ve, Qe == null ? void 0 : Qe.modal]), /* @__PURE__ */ React.createElement(PortalContext.Provider, {
    value: React.useMemo(() => ({
      preserveTabOrder: Ve,
      beforeOutsideRef: ut,
      afterOutsideRef: lt,
      beforeInsideRef: dt,
      afterInsideRef: bt,
      portalNode: Je,
      setFocusManagerState: at
    }), [Ve, Je])
  }, $t && Je && /* @__PURE__ */ React.createElement(FocusGuard, {
    "data-type": "outside",
    ref: ut,
    onFocus: (vt) => {
      if (isOutsideEvent(vt, Je)) {
        var wt;
        (wt = dt.current) == null || wt.focus();
      } else {
        const xt = getPreviousTabbable() || (Qe == null ? void 0 : Qe.refs.domReference.current);
        xt == null || xt.focus();
      }
    }
  }), $t && Je && /* @__PURE__ */ React.createElement("span", {
    "aria-owns": Je.id,
    style: HIDDEN_STYLES
  }), Je && /* @__PURE__ */ createPortal(Ze, Je), $t && Je && /* @__PURE__ */ React.createElement(FocusGuard, {
    "data-type": "outside",
    ref: lt,
    onFocus: (vt) => {
      if (isOutsideEvent(vt, Je)) {
        var wt;
        (wt = bt.current) == null || wt.focus();
      } else {
        const xt = getNextTabbable() || (Qe == null ? void 0 : Qe.refs.domReference.current);
        xt == null || xt.focus(), Qe != null && Qe.closeOnFocusOut && (Qe == null || Qe.onOpenChange(!1, vt.nativeEvent));
      }
    }
  }));
}
const usePortalContext = () => React.useContext(PortalContext), VisuallyHiddenDismiss = /* @__PURE__ */ React.forwardRef(function(Ze, Fe) {
  return /* @__PURE__ */ React.createElement("button", _extends({}, Ze, {
    type: "button",
    ref: Fe,
    tabIndex: -1,
    style: HIDDEN_STYLES
  }));
});
function FloatingFocusManager($e) {
  const {
    context: Ze,
    children: Fe,
    disabled: Ke = !1,
    order: Ve = ["content"],
    guards: Je = !0,
    initialFocus: Qe = 0,
    returnFocus: at = !0,
    modal: ut = !0,
    visuallyHiddenDismiss: lt = !1,
    closeOnFocusOut: dt = !0
  } = $e, {
    open: bt,
    refs: $t,
    nodeId: vt,
    onOpenChange: wt,
    events: xt,
    dataRef: Et,
    elements: {
      domReference: Tt,
      floating: Rt
    }
  } = Ze, Ct = supportsInert() ? Je : !0, Zt = useLatestRef(Ve), Lt = useLatestRef(Qe), Ut = useLatestRef(at), Pt = useFloatingTree(), Ot = usePortalContext(), Ft = typeof Qe == "number" && Qe < 0, gt = React.useRef(null), We = React.useRef(null), Xe = React.useRef(!1), rt = React.useRef(null), ot = React.useRef(!1), ft = Ot != null, mt = Tt && Tt.getAttribute("role") === "combobox" && isTypeableElement(Tt) && Ft, yt = React.useCallback(function(Mt) {
    return Mt === void 0 && (Mt = Rt), Mt ? tabbable(Mt, getTabbableOptions()) : [];
  }, [Rt]), pt = React.useCallback((Mt) => {
    const St = yt(Mt);
    return Zt.current.map((At) => Tt && At === "reference" ? Tt : Rt && At === "floating" ? Rt : St).filter(Boolean).flat();
  }, [Tt, Rt, Zt, yt]);
  React.useEffect(() => {
    if (Ke || !ut)
      return;
    function Mt(At) {
      if (At.key === "Tab") {
        contains(Rt, activeElement(getDocument(Rt))) && yt().length === 0 && !mt && stopEvent(At);
        const Nt = pt(), qt = getTarget(At);
        Zt.current[0] === "reference" && qt === Tt && (stopEvent(At), At.shiftKey ? enqueueFocus(Nt[Nt.length - 1]) : enqueueFocus(Nt[1])), Zt.current[1] === "floating" && qt === Rt && At.shiftKey && (stopEvent(At), enqueueFocus(Nt[0]));
      }
    }
    const St = getDocument(Rt);
    return St.addEventListener("keydown", Mt), () => {
      St.removeEventListener("keydown", Mt);
    };
  }, [Ke, Tt, Rt, ut, Zt, $t, mt, yt, pt]), React.useEffect(() => {
    if (Ke || !dt)
      return;
    function Mt() {
      ot.current = !0, setTimeout(() => {
        ot.current = !1;
      });
    }
    function St(At) {
      const Nt = At.relatedTarget;
      queueMicrotask(() => {
        const qt = !(contains(Tt, Nt) || contains(Rt, Nt) || contains(Nt, Rt) || contains(Ot == null ? void 0 : Ot.portalNode, Nt) || Nt != null && Nt.hasAttribute(createAttribute("focus-guard")) || Pt && (getChildren(Pt.nodesRef.current, vt).find((Qt) => {
          var Xt, zt;
          return contains((Xt = Qt.context) == null ? void 0 : Xt.elements.floating, Nt) || contains((zt = Qt.context) == null ? void 0 : zt.elements.domReference, Nt);
        }) || getAncestors(Pt.nodesRef.current, vt).find((Qt) => {
          var Xt, zt;
          return ((Xt = Qt.context) == null ? void 0 : Xt.elements.floating) === Nt || ((zt = Qt.context) == null ? void 0 : zt.elements.domReference) === Nt;
        })));
        Nt && qt && !ot.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        Nt !== rt.current && (Xe.current = !0, wt(!1, At));
      });
    }
    if (Rt && isHTMLElement(Tt))
      return Tt.addEventListener("focusout", St), Tt.addEventListener("pointerdown", Mt), !ut && Rt.addEventListener("focusout", St), () => {
        Tt.removeEventListener("focusout", St), Tt.removeEventListener("pointerdown", Mt), !ut && Rt.removeEventListener("focusout", St);
      };
  }, [Ke, Tt, Rt, ut, vt, Pt, Ot, wt, dt]), React.useEffect(() => {
    var Mt;
    if (Ke)
      return;
    const St = Array.from((Ot == null || (Mt = Ot.portalNode) == null ? void 0 : Mt.querySelectorAll("[" + createAttribute("portal") + "]")) || []);
    if (Rt) {
      const At = [Rt, ...St, gt.current, We.current, Zt.current.includes("reference") || mt ? Tt : null].filter((qt) => qt != null), Nt = ut ? markOthers(At, Ct, !Ct) : markOthers(At);
      return () => {
        Nt();
      };
    }
  }, [Ke, Tt, Rt, ut, Zt, Ot, mt, Ct]), index$1(() => {
    if (Ke || !Rt)
      return;
    const Mt = getDocument(Rt), St = activeElement(Mt);
    queueMicrotask(() => {
      const At = pt(Rt), Nt = Lt.current, qt = (typeof Nt == "number" ? At[Nt] : Nt.current) || Rt, Qt = contains(Rt, St);
      !Ft && !Qt && bt && enqueueFocus(qt, {
        preventScroll: qt === Rt
      });
    });
  }, [Ke, bt, Rt, Ft, pt, Lt]), index$1(() => {
    if (Ke || !Rt)
      return;
    let Mt = !1;
    const St = getDocument(Rt), At = activeElement(St), Nt = Et.current;
    rt.current = At;
    function qt(Qt) {
      if (Qt.type === "escapeKey" && $t.domReference.current && (rt.current = $t.domReference.current), ["referencePress", "escapeKey"].includes(Qt.type))
        return;
      const Xt = Qt.data.returnFocus;
      typeof Xt == "object" ? (Xe.current = !1, Mt = Xt.preventScroll) : Xe.current = !Xt;
    }
    return xt.on("dismiss", qt), () => {
      xt.off("dismiss", qt);
      const Qt = activeElement(St);
      (contains(Rt, Qt) || Pt && getChildren(Pt.nodesRef.current, vt).some((zt) => {
        var Kt;
        return contains((Kt = zt.context) == null ? void 0 : Kt.elements.floating, Qt);
      }) || Nt.openEvent && ["click", "mousedown"].includes(Nt.openEvent.type)) && $t.domReference.current && (rt.current = $t.domReference.current), // eslint-disable-next-line react-hooks/exhaustive-deps
      Ut.current && isHTMLElement(rt.current) && !Xe.current && enqueueFocus(rt.current, {
        // When dismissing nested floating elements, by the time the rAF has
        // executed, the menus will all have been unmounted. When they try
        // to get focused, the calls get ignored — leaving the root
        // reference focused as desired.
        cancelPrevious: !1,
        preventScroll: Mt
      });
    };
  }, [Ke, Rt, Ut, Et, $t, xt, Pt, vt]), index$1(() => {
    if (!(Ke || !Ot))
      return Ot.setFocusManagerState({
        modal: ut,
        closeOnFocusOut: dt,
        open: bt,
        onOpenChange: wt,
        refs: $t
      }), () => {
        Ot.setFocusManagerState(null);
      };
  }, [Ke, Ot, ut, bt, wt, $t, dt]), index$1(() => {
    if (!Ke && Rt && typeof MutationObserver == "function" && !Ft) {
      const Mt = () => {
        const At = Rt.getAttribute("tabindex");
        Zt.current.includes("floating") || activeElement(getDocument(Rt)) !== $t.domReference.current && yt().length === 0 ? At !== "0" && Rt.setAttribute("tabindex", "0") : At !== "-1" && Rt.setAttribute("tabindex", "-1");
      };
      Mt();
      const St = new MutationObserver(Mt);
      return St.observe(Rt, {
        childList: !0,
        subtree: !0,
        attributes: !0
      }), () => {
        St.disconnect();
      };
    }
  }, [Ke, Rt, $t, Zt, yt, Ft]);
  function Ge(Mt) {
    return Ke || !lt || !ut ? null : /* @__PURE__ */ React.createElement(VisuallyHiddenDismiss, {
      ref: Mt === "start" ? gt : We,
      onClick: (St) => wt(!1, St.nativeEvent)
    }, typeof lt == "string" ? lt : "Dismiss");
  }
  const ct = !Ke && Ct && !mt && (ft || ut);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, ct && /* @__PURE__ */ React.createElement(FocusGuard, {
    "data-type": "inside",
    ref: Ot == null ? void 0 : Ot.beforeInsideRef,
    onFocus: (Mt) => {
      if (ut) {
        const At = pt();
        enqueueFocus(Ve[0] === "reference" ? At[0] : At[At.length - 1]);
      } else if (Ot != null && Ot.preserveTabOrder && Ot.portalNode)
        if (Xe.current = !1, isOutsideEvent(Mt, Ot.portalNode)) {
          const At = getNextTabbable() || Tt;
          At == null || At.focus();
        } else {
          var St;
          (St = Ot.beforeOutsideRef.current) == null || St.focus();
        }
    }
  }), !mt && Ge("start"), Fe, Ge("end"), ct && /* @__PURE__ */ React.createElement(FocusGuard, {
    "data-type": "inside",
    ref: Ot == null ? void 0 : Ot.afterInsideRef,
    onFocus: (Mt) => {
      if (ut)
        enqueueFocus(pt()[0]);
      else if (Ot != null && Ot.preserveTabOrder && Ot.portalNode)
        if (dt && (Xe.current = !0), isOutsideEvent(Mt, Ot.portalNode)) {
          const At = getPreviousTabbable() || Tt;
          At == null || At.focus();
        } else {
          var St;
          (St = Ot.afterOutsideRef.current) == null || St.focus();
        }
    }
  }));
}
function isButtonTarget($e) {
  return isHTMLElement($e.target) && $e.target.tagName === "BUTTON";
}
function isSpaceIgnored($e) {
  return isTypeableElement($e);
}
function useClick($e, Ze) {
  Ze === void 0 && (Ze = {});
  const {
    open: Fe,
    onOpenChange: Ke,
    dataRef: Ve,
    elements: {
      domReference: Je
    }
  } = $e, {
    enabled: Qe = !0,
    event: at = "click",
    toggle: ut = !0,
    ignoreMouse: lt = !1,
    keyboardHandlers: dt = !0
  } = Ze, bt = React.useRef(), $t = React.useRef(!1);
  return React.useMemo(() => Qe ? {
    reference: {
      onPointerDown(vt) {
        bt.current = vt.pointerType;
      },
      onMouseDown(vt) {
        vt.button === 0 && (isMouseLikePointerType(bt.current, !0) && lt || at !== "click" && (Fe && ut && (!Ve.current.openEvent || Ve.current.openEvent.type === "mousedown") ? Ke(!1, vt.nativeEvent) : (vt.preventDefault(), Ke(!0, vt.nativeEvent))));
      },
      onClick(vt) {
        if (at === "mousedown" && bt.current) {
          bt.current = void 0;
          return;
        }
        isMouseLikePointerType(bt.current, !0) && lt || (Fe && ut && (!Ve.current.openEvent || Ve.current.openEvent.type === "click") ? Ke(!1, vt.nativeEvent) : Ke(!0, vt.nativeEvent));
      },
      onKeyDown(vt) {
        bt.current = void 0, !(vt.defaultPrevented || !dt || isButtonTarget(vt)) && (vt.key === " " && !isSpaceIgnored(Je) && (vt.preventDefault(), $t.current = !0), vt.key === "Enter" && Ke(!(Fe && ut), vt.nativeEvent));
      },
      onKeyUp(vt) {
        vt.defaultPrevented || !dt || isButtonTarget(vt) || isSpaceIgnored(Je) || vt.key === " " && $t.current && ($t.current = !1, Ke(!(Fe && ut), vt.nativeEvent));
      }
    }
  } : {}, [Qe, Ve, at, lt, dt, Je, ut, Fe, Ke]);
}
const useInsertionEffect = React[/* @__PURE__ */ "useInsertionEffect".toString()], useSafeInsertionEffect = useInsertionEffect || (($e) => $e());
function useEffectEvent($e) {
  const Ze = React.useRef(() => {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return useSafeInsertionEffect(() => {
    Ze.current = $e;
  }), React.useCallback(function() {
    for (var Fe = arguments.length, Ke = new Array(Fe), Ve = 0; Ve < Fe; Ve++)
      Ke[Ve] = arguments[Ve];
    return Ze.current == null ? void 0 : Ze.current(...Ke);
  }, []);
}
const bubbleHandlerKeys = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, captureHandlerKeys = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, normalizeBubblesProp = ($e) => {
  var Ze, Fe;
  return {
    escapeKeyBubbles: typeof $e == "boolean" ? $e : (Ze = $e == null ? void 0 : $e.escapeKey) != null ? Ze : !1,
    outsidePressBubbles: typeof $e == "boolean" ? $e : (Fe = $e == null ? void 0 : $e.outsidePress) != null ? Fe : !0
  };
};
function useDismiss($e, Ze) {
  Ze === void 0 && (Ze = {});
  const {
    open: Fe,
    onOpenChange: Ke,
    events: Ve,
    nodeId: Je,
    elements: {
      reference: Qe,
      domReference: at,
      floating: ut
    },
    dataRef: lt
  } = $e, {
    enabled: dt = !0,
    escapeKey: bt = !0,
    outsidePress: $t = !0,
    outsidePressEvent: vt = "pointerdown",
    referencePress: wt = !1,
    referencePressEvent: xt = "pointerdown",
    ancestorScroll: Et = !1,
    bubbles: Tt
  } = Ze, Rt = useFloatingTree(), Ct = useFloatingParentNodeId() != null, Zt = useEffectEvent(typeof $t == "function" ? $t : () => !1), Lt = typeof $t == "function" ? Zt : $t, Ut = React.useRef(!1), {
    escapeKeyBubbles: Pt,
    outsidePressBubbles: Ot
  } = normalizeBubblesProp(Tt), Ft = useEffectEvent((We) => {
    if (!Fe || !dt || !bt || We.key !== "Escape")
      return;
    const Xe = Rt ? getChildren(Rt.nodesRef.current, Je) : [];
    if (!Pt && (We.stopPropagation(), Xe.length > 0)) {
      let rt = !0;
      if (Xe.forEach((ot) => {
        var ft;
        if ((ft = ot.context) != null && ft.open && !ot.context.dataRef.current.__escapeKeyBubbles) {
          rt = !1;
          return;
        }
      }), !rt)
        return;
    }
    Ve.emit("dismiss", {
      type: "escapeKey",
      data: {
        returnFocus: {
          preventScroll: !1
        }
      }
    }), Ke(!1, isReactEvent(We) ? We.nativeEvent : We);
  }), gt = useEffectEvent((We) => {
    const Xe = Ut.current;
    if (Ut.current = !1, Xe || typeof Lt == "function" && !Lt(We))
      return;
    const rt = getTarget(We), ot = "[" + createAttribute("inert") + "]", ft = getDocument(ut).querySelectorAll(ot);
    let mt = isElement(rt) ? rt : null;
    for (; mt && !isLastTraversableNode(mt); ) {
      const Ge = getParentNode(mt);
      if (Ge === getDocument(ut).body || !isElement(Ge))
        break;
      mt = Ge;
    }
    if (ft.length && isElement(rt) && !isRootElement(rt) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !contains(rt, ut) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(ft).every((Ge) => !contains(mt, Ge)))
      return;
    if (isHTMLElement(rt) && ut) {
      const Ge = rt.clientWidth > 0 && rt.scrollWidth > rt.clientWidth, ct = rt.clientHeight > 0 && rt.scrollHeight > rt.clientHeight;
      let Mt = ct && We.offsetX > rt.clientWidth;
      if (ct && getComputedStyle$1(rt).direction === "rtl" && (Mt = We.offsetX <= rt.offsetWidth - rt.clientWidth), Mt || Ge && We.offsetY > rt.clientHeight)
        return;
    }
    const yt = Rt && getChildren(Rt.nodesRef.current, Je).some((Ge) => {
      var ct;
      return isEventTargetWithin(We, (ct = Ge.context) == null ? void 0 : ct.elements.floating);
    });
    if (isEventTargetWithin(We, ut) || isEventTargetWithin(We, at) || yt)
      return;
    const pt = Rt ? getChildren(Rt.nodesRef.current, Je) : [];
    if (pt.length > 0) {
      let Ge = !0;
      if (pt.forEach((ct) => {
        var Mt;
        if ((Mt = ct.context) != null && Mt.open && !ct.context.dataRef.current.__outsidePressBubbles) {
          Ge = !1;
          return;
        }
      }), !Ge)
        return;
    }
    Ve.emit("dismiss", {
      type: "outsidePress",
      data: {
        returnFocus: Ct ? {
          preventScroll: !0
        } : isVirtualClick(We) || isVirtualPointerEvent(We)
      }
    }), Ke(!1, We);
  });
  return React.useEffect(() => {
    if (!Fe || !dt)
      return;
    lt.current.__escapeKeyBubbles = Pt, lt.current.__outsidePressBubbles = Ot;
    function We(ot) {
      Ke(!1, ot);
    }
    const Xe = getDocument(ut);
    bt && Xe.addEventListener("keydown", Ft), Lt && Xe.addEventListener(vt, gt);
    let rt = [];
    return Et && (isElement(at) && (rt = getOverflowAncestors(at)), isElement(ut) && (rt = rt.concat(getOverflowAncestors(ut))), !isElement(Qe) && Qe && Qe.contextElement && (rt = rt.concat(getOverflowAncestors(Qe.contextElement)))), rt = rt.filter((ot) => {
      var ft;
      return ot !== ((ft = Xe.defaultView) == null ? void 0 : ft.visualViewport);
    }), rt.forEach((ot) => {
      ot.addEventListener("scroll", We, {
        passive: !0
      });
    }), () => {
      bt && Xe.removeEventListener("keydown", Ft), Lt && Xe.removeEventListener(vt, gt), rt.forEach((ot) => {
        ot.removeEventListener("scroll", We);
      });
    };
  }, [lt, ut, at, Qe, bt, Lt, vt, Fe, Ke, Et, dt, Pt, Ot, Ft, gt]), React.useEffect(() => {
    Ut.current = !1;
  }, [Lt, vt]), React.useMemo(() => dt ? {
    reference: {
      onKeyDown: Ft,
      [bubbleHandlerKeys[xt]]: (We) => {
        wt && (Ve.emit("dismiss", {
          type: "referencePress",
          data: {
            returnFocus: !1
          }
        }), Ke(!1, We.nativeEvent));
      }
    },
    floating: {
      onKeyDown: Ft,
      [captureHandlerKeys[vt]]: () => {
        Ut.current = !0;
      }
    }
  } : {}, [dt, Ve, wt, vt, xt, Ke, Ft]);
}
let devMessageSet;
process.env.NODE_ENV !== "production" && (devMessageSet = /* @__PURE__ */ new Set());
function useFloating($e) {
  var Ze;
  $e === void 0 && ($e = {});
  const {
    open: Fe = !1,
    onOpenChange: Ke,
    nodeId: Ve
  } = $e;
  if (process.env.NODE_ENV !== "production") {
    var Je;
    const Pt = "Floating UI: Cannot pass a virtual element to the `elements.reference` option, as it must be a real DOM element. Use `refs.setPositionReference` instead.";
    if ((Je = $e.elements) != null && Je.reference && !isElement($e.elements.reference)) {
      var Qe;
      if (!((Qe = devMessageSet) != null && Qe.has(Pt))) {
        var at;
        (at = devMessageSet) == null || at.add(Pt), console.error(Pt);
      }
    }
  }
  const [ut, lt] = React.useState(null), dt = ((Ze = $e.elements) == null ? void 0 : Ze.reference) || ut, bt = useFloating$1($e), $t = useFloatingTree(), vt = useEffectEvent((Pt, Ot) => {
    Pt && (xt.current.openEvent = Ot), Ke == null || Ke(Pt, Ot);
  }), wt = React.useRef(null), xt = React.useRef({}), Et = React.useState(() => createPubSub())[0], Tt = useId(), Rt = React.useCallback((Pt) => {
    const Ot = isElement(Pt) ? {
      getBoundingClientRect: () => Pt.getBoundingClientRect(),
      contextElement: Pt
    } : Pt;
    bt.refs.setReference(Ot);
  }, [bt.refs]), Ct = React.useCallback((Pt) => {
    (isElement(Pt) || Pt === null) && (wt.current = Pt, lt(Pt)), (isElement(bt.refs.reference.current) || bt.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    Pt !== null && !isElement(Pt)) && bt.refs.setReference(Pt);
  }, [bt.refs]), Zt = React.useMemo(() => ({
    ...bt.refs,
    setReference: Ct,
    setPositionReference: Rt,
    domReference: wt
  }), [bt.refs, Ct, Rt]), Lt = React.useMemo(() => ({
    ...bt.elements,
    domReference: dt
  }), [bt.elements, dt]), Ut = React.useMemo(() => ({
    ...bt,
    refs: Zt,
    elements: Lt,
    dataRef: xt,
    nodeId: Ve,
    floatingId: Tt,
    events: Et,
    open: Fe,
    onOpenChange: vt
  }), [bt, Ve, Tt, Et, Fe, vt, Zt, Lt]);
  return index$1(() => {
    const Pt = $t == null ? void 0 : $t.nodesRef.current.find((Ot) => Ot.id === Ve);
    Pt && (Pt.context = Ut);
  }), React.useMemo(() => ({
    ...bt,
    context: Ut,
    refs: Zt,
    elements: Lt
  }), [bt, Zt, Lt, Ut]);
}
function mergeProps($e, Ze, Fe) {
  const Ke = /* @__PURE__ */ new Map();
  return {
    ...Fe === "floating" && {
      tabIndex: -1
    },
    ...$e,
    ...Ze.map((Ve) => Ve ? Ve[Fe] : null).concat($e).reduce((Ve, Je) => (Je && Object.entries(Je).forEach((Qe) => {
      let [at, ut] = Qe;
      if (at.indexOf("on") === 0) {
        if (Ke.has(at) || Ke.set(at, []), typeof ut == "function") {
          var lt;
          (lt = Ke.get(at)) == null || lt.push(ut), Ve[at] = function() {
            for (var dt, bt = arguments.length, $t = new Array(bt), vt = 0; vt < bt; vt++)
              $t[vt] = arguments[vt];
            return (dt = Ke.get(at)) == null ? void 0 : dt.map((wt) => wt(...$t)).find((wt) => wt !== void 0);
          };
        }
      } else
        Ve[at] = ut;
    }), Ve), {})
  };
}
function useInteractions($e) {
  $e === void 0 && ($e = []);
  const Ze = $e, Fe = React.useCallback(
    (Je) => mergeProps(Je, $e, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    Ze
  ), Ke = React.useCallback(
    (Je) => mergeProps(Je, $e, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    Ze
  ), Ve = React.useCallback(
    (Je) => mergeProps(Je, $e, "item"),
    // Granularly check for `item` changes, because the `getItemProps` getter
    // should be as referentially stable as possible since it may be passed as
    // a prop to many components. All `item` key values must therefore be
    // memoized.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    $e.map((Je) => Je == null ? void 0 : Je.item)
  );
  return React.useMemo(() => ({
    getReferenceProps: Fe,
    getFloatingProps: Ke,
    getItemProps: Ve
  }), [Fe, Ke, Ve]);
}
let isPreventScrollSupported = !1;
function doSwitch($e, Ze, Fe) {
  switch ($e) {
    case "vertical":
      return Ze;
    case "horizontal":
      return Fe;
    default:
      return Ze || Fe;
  }
}
function isMainOrientationKey($e, Ze) {
  return doSwitch(Ze, $e === ARROW_UP || $e === ARROW_DOWN, $e === ARROW_LEFT || $e === ARROW_RIGHT);
}
function isMainOrientationToEndKey($e, Ze, Fe) {
  return doSwitch(Ze, $e === ARROW_DOWN, Fe ? $e === ARROW_LEFT : $e === ARROW_RIGHT) || $e === "Enter" || $e == " " || $e === "";
}
function isCrossOrientationOpenKey($e, Ze, Fe) {
  return doSwitch(Ze, Fe ? $e === ARROW_LEFT : $e === ARROW_RIGHT, $e === ARROW_DOWN);
}
function isCrossOrientationCloseKey($e, Ze, Fe) {
  return doSwitch(Ze, Fe ? $e === ARROW_RIGHT : $e === ARROW_LEFT, $e === ARROW_UP);
}
function useListNavigation($e, Ze) {
  const {
    open: Fe,
    onOpenChange: Ke,
    refs: Ve,
    elements: {
      domReference: Je,
      floating: Qe
    }
  } = $e, {
    listRef: at,
    activeIndex: ut,
    onNavigate: lt = () => {
    },
    enabled: dt = !0,
    selectedIndex: bt = null,
    allowEscape: $t = !1,
    loop: vt = !1,
    nested: wt = !1,
    rtl: xt = !1,
    virtual: Et = !1,
    focusItemOnOpen: Tt = "auto",
    focusItemOnHover: Rt = !0,
    openOnArrowKeyDown: Ct = !0,
    disabledIndices: Zt = void 0,
    orientation: Lt = "vertical",
    cols: Ut = 1,
    scrollItemIntoView: Pt = !0,
    virtualItemRef: Ot
  } = Ze;
  process.env.NODE_ENV !== "production" && ($t && (vt || console.warn(["Floating UI: `useListNavigation` looping must be enabled to allow", "escaping."].join(" ")), Et || console.warn(["Floating UI: `useListNavigation` must be virtual to allow", "escaping."].join(" "))), Lt === "vertical" && Ut > 1 && console.warn(["Floating UI: In grid list navigation mode (`cols` > 1), the", '`orientation` should be either "horizontal" or "both".'].join(" ")));
  const Ft = useFloatingParentNodeId(), gt = useFloatingTree(), We = useEffectEvent(lt), Xe = React.useRef(Tt), rt = React.useRef(bt ?? -1), ot = React.useRef(null), ft = React.useRef(!0), mt = React.useRef(We), yt = React.useRef(!!Qe), pt = React.useRef(!1), Ge = React.useRef(!1), ct = useLatestRef(Zt), Mt = useLatestRef(Fe), St = useLatestRef(Pt), [At, Nt] = React.useState(), [qt, Qt] = React.useState(), Xt = useEffectEvent(function(ur, er, Dt) {
    Dt === void 0 && (Dt = !1);
    const Ht = ur.current[er.current];
    Ht && (Et ? (Nt(Ht.id), gt == null || gt.events.emit("virtualfocus", Ht), Ot && (Ot.current = Ht)) : enqueueFocus(Ht, {
      preventScroll: !0,
      // Mac Safari does not move the virtual cursor unless the focus call
      // is sync. However, for the very first focus call, we need to wait
      // for the position to be ready in order to prevent unwanted
      // scrolling. This means the virtual cursor will not move to the first
      // item when first opening the floating element, but will on
      // subsequent calls. `preventScroll` is supported in modern Safari,
      // so we can use that instead.
      // iOS Safari must be async or the first item will not be focused.
      sync: isMac() && isSafari() ? isPreventScrollSupported || pt.current : !1
    }), requestAnimationFrame(() => {
      const Gt = St.current;
      Gt && Ht && (Dt || !ft.current) && (Ht.scrollIntoView == null || Ht.scrollIntoView(typeof Gt == "boolean" ? {
        block: "nearest",
        inline: "nearest"
      } : Gt));
    }));
  });
  index$1(() => {
    document.createElement("div").focus({
      get preventScroll() {
        return isPreventScrollSupported = !0, !1;
      }
    });
  }, []), index$1(() => {
    dt && (Fe && Qe ? Xe.current && bt != null && (Ge.current = !0, We(bt)) : yt.current && (rt.current = -1, mt.current(null)));
  }, [dt, Fe, Qe, bt, We]), index$1(() => {
    if (dt && Fe && Qe)
      if (ut == null) {
        if (pt.current = !1, bt != null)
          return;
        if (yt.current && (rt.current = -1, Xt(at, rt)), !yt.current && Xe.current && (ot.current != null || Xe.current === !0 && ot.current == null)) {
          let ur = 0;
          const er = () => {
            at.current[0] == null ? (ur < 2 && (ur ? requestAnimationFrame : queueMicrotask)(er), ur++) : (rt.current = ot.current == null || isMainOrientationToEndKey(ot.current, Lt, xt) || wt ? getMinIndex(at, ct.current) : getMaxIndex(at, ct.current), ot.current = null, We(rt.current));
          };
          er();
        }
      } else
        isIndexOutOfBounds(at, ut) || (rt.current = ut, Xt(at, rt, Ge.current), Ge.current = !1);
  }, [dt, Fe, Qe, ut, bt, wt, at, Lt, xt, We, Xt, ct]), index$1(() => {
    var ur, er;
    if (!dt || Qe || !gt || Et || !yt.current)
      return;
    const Dt = gt.nodesRef.current, Ht = (ur = Dt.find((sr) => sr.id === Ft)) == null || (er = ur.context) == null ? void 0 : er.elements.floating, Gt = activeElement(getDocument(Qe)), rr = Dt.some((sr) => sr.context && contains(sr.context.elements.floating, Gt));
    Ht && !rr && ft.current && Ht.focus({
      preventScroll: !0
    });
  }, [dt, Qe, gt, Ft, Et]), index$1(() => {
    if (!dt || !gt || !Et || Ft)
      return;
    function ur(er) {
      Qt(er.id), Ot && (Ot.current = er);
    }
    return gt.events.on("virtualfocus", ur), () => {
      gt.events.off("virtualfocus", ur);
    };
  }, [dt, gt, Et, Ft, Ot]), index$1(() => {
    mt.current = We, yt.current = !!Qe;
  }), index$1(() => {
    Fe || (ot.current = null);
  }, [Fe]);
  const zt = ut != null, Kt = React.useMemo(() => {
    function ur(Dt) {
      if (!Fe)
        return;
      const Ht = at.current.indexOf(Dt);
      Ht !== -1 && We(Ht);
    }
    return {
      onFocus(Dt) {
        let {
          currentTarget: Ht
        } = Dt;
        ur(Ht);
      },
      onClick: (Dt) => {
        let {
          currentTarget: Ht
        } = Dt;
        return Ht.focus({
          preventScroll: !0
        });
      },
      // Safari
      ...Rt && {
        onMouseMove(Dt) {
          let {
            currentTarget: Ht
          } = Dt;
          ur(Ht);
        },
        onPointerLeave(Dt) {
          let {
            pointerType: Ht
          } = Dt;
          !ft.current || Ht === "touch" || (rt.current = -1, Xt(at, rt), We(null), Et || enqueueFocus(Ve.floating.current, {
            preventScroll: !0
          }));
        }
      }
    };
  }, [Fe, Ve, Xt, Rt, at, We, Et]);
  return React.useMemo(() => {
    if (!dt)
      return {};
    const ur = ct.current;
    function er(sr) {
      if (ft.current = !1, pt.current = !0, !Mt.current && sr.currentTarget === Ve.floating.current)
        return;
      if (wt && isCrossOrientationCloseKey(sr.key, Lt, xt)) {
        stopEvent(sr), Ke(!1, sr.nativeEvent), isHTMLElement(Je) && !Et && Je.focus();
        return;
      }
      const Jt = rt.current, ir = getMinIndex(at, ur), Br = getMaxIndex(at, ur);
      if (sr.key === "Home" && (stopEvent(sr), rt.current = ir, We(rt.current)), sr.key === "End" && (stopEvent(sr), rt.current = Br, We(rt.current)), !(Ut > 1 && (rt.current = getGridNavigatedIndex(at, {
        event: sr,
        orientation: Lt,
        loop: vt,
        cols: Ut,
        disabledIndices: ur,
        minIndex: ir,
        maxIndex: Br,
        prevIndex: rt.current,
        stopEvent: !0
      }), We(rt.current), Lt === "both")) && isMainOrientationKey(sr.key, Lt)) {
        if (stopEvent(sr), Fe && !Et && activeElement(sr.currentTarget.ownerDocument) === sr.currentTarget) {
          rt.current = isMainOrientationToEndKey(sr.key, Lt, xt) ? ir : Br, We(rt.current);
          return;
        }
        isMainOrientationToEndKey(sr.key, Lt, xt) ? vt ? rt.current = Jt >= Br ? $t && Jt !== at.current.length ? -1 : ir : findNonDisabledIndex(at, {
          startingIndex: Jt,
          disabledIndices: ur
        }) : rt.current = Math.min(Br, findNonDisabledIndex(at, {
          startingIndex: Jt,
          disabledIndices: ur
        })) : vt ? rt.current = Jt <= ir ? $t && Jt !== -1 ? at.current.length : Br : findNonDisabledIndex(at, {
          startingIndex: Jt,
          decrement: !0,
          disabledIndices: ur
        }) : rt.current = Math.max(ir, findNonDisabledIndex(at, {
          startingIndex: Jt,
          decrement: !0,
          disabledIndices: ur
        })), isIndexOutOfBounds(at, rt.current) ? We(null) : We(rt.current);
      }
    }
    function Dt(sr) {
      Tt === "auto" && isVirtualClick(sr.nativeEvent) && (Xe.current = !0);
    }
    function Ht(sr) {
      Xe.current = Tt, Tt === "auto" && isVirtualPointerEvent(sr.nativeEvent) && (Xe.current = !0);
    }
    const Gt = Et && Fe && zt && {
      "aria-activedescendant": qt || At
    }, rr = at.current.find((sr) => (sr == null ? void 0 : sr.id) === At);
    return {
      reference: {
        ...Gt,
        onKeyDown(sr) {
          ft.current = !1;
          const Jt = sr.key.indexOf("Arrow") === 0, ir = isCrossOrientationOpenKey(sr.key, Lt, xt), Br = isCrossOrientationCloseKey(sr.key, Lt, xt), or = isMainOrientationKey(sr.key, Lt), lr = (wt ? ir : or) || sr.key === "Enter" || sr.key.trim() === "";
          if (Et && Fe) {
            const Zr = gt == null ? void 0 : gt.nodesRef.current.find((kt) => kt.parentId == null), Bt = gt && Zr ? getDeepestNode(gt.nodesRef.current, Zr.id) : null;
            if (Jt && Bt && Ot) {
              const kt = new KeyboardEvent("keydown", {
                key: sr.key,
                bubbles: !0
              });
              if (ir || Br) {
                var Nr, dr;
                const It = ((Nr = Bt.context) == null ? void 0 : Nr.elements.domReference) === sr.currentTarget, jt = Br && !It ? (dr = Bt.context) == null ? void 0 : dr.elements.domReference : ir ? rr : null;
                jt && (stopEvent(sr), jt.dispatchEvent(kt), Qt(void 0));
              }
              if (or && Bt.context && Bt.context.open && Bt.parentId && sr.currentTarget !== Bt.context.elements.domReference) {
                var gr;
                stopEvent(sr), (gr = Bt.context.elements.domReference) == null || gr.dispatchEvent(kt);
                return;
              }
            }
            return er(sr);
          }
          if (!(!Fe && !Ct && Jt)) {
            if (lr && (ot.current = wt && or ? null : sr.key), wt) {
              ir && (stopEvent(sr), Fe ? (rt.current = getMinIndex(at, ur), We(rt.current)) : Ke(!0, sr.nativeEvent));
              return;
            }
            or && (bt != null && (rt.current = bt), stopEvent(sr), !Fe && Ct ? Ke(!0, sr.nativeEvent) : er(sr), Fe && We(rt.current));
          }
        },
        onFocus() {
          Fe && We(null);
        },
        onPointerDown: Ht,
        onMouseDown: Dt,
        onClick: Dt
      },
      floating: {
        "aria-orientation": Lt === "both" ? void 0 : Lt,
        ...Gt,
        onKeyDown: er,
        onPointerMove() {
          ft.current = !0;
        }
      },
      item: Kt
    };
  }, [Je, Ve, At, qt, ct, Mt, at, dt, Lt, xt, Et, Fe, zt, wt, bt, Ct, $t, Ut, vt, Tt, We, Ke, Kt, gt, Ot]);
}
function useRole($e, Ze) {
  Ze === void 0 && (Ze = {});
  const {
    open: Fe,
    floatingId: Ke
  } = $e, {
    enabled: Ve = !0,
    role: Je = "dialog"
  } = Ze, Qe = useId();
  return React.useMemo(() => {
    const at = {
      id: Ke,
      role: Je
    };
    return Ve ? Je === "tooltip" ? {
      reference: {
        "aria-describedby": Fe ? Ke : void 0
      },
      floating: at
    } : {
      reference: {
        "aria-expanded": Fe ? "true" : "false",
        "aria-haspopup": Je === "alertdialog" ? "dialog" : Je,
        "aria-controls": Fe ? Ke : void 0,
        ...Je === "listbox" && {
          role: "combobox"
        },
        ...Je === "menu" && {
          id: Qe
        }
      },
      floating: {
        ...at,
        ...Je === "menu" && {
          "aria-labelledby": Qe
        }
      }
    } : {};
  }, [Ve, Je, Fe, Ke, Qe]);
}
function useTypeahead($e, Ze) {
  var Fe;
  const {
    open: Ke,
    dataRef: Ve
  } = $e, {
    listRef: Je,
    activeIndex: Qe,
    onMatch: at,
    onTypingChange: ut,
    enabled: lt = !0,
    findMatch: dt = null,
    resetMs: bt = 750,
    ignoreKeys: $t = [],
    selectedIndex: vt = null
  } = Ze, wt = React.useRef(), xt = React.useRef(""), Et = React.useRef((Fe = vt ?? Qe) != null ? Fe : -1), Tt = React.useRef(null), Rt = useEffectEvent(at), Ct = useEffectEvent(ut), Zt = useLatestRef(dt), Lt = useLatestRef($t);
  return index$1(() => {
    Ke && (clearTimeout(wt.current), Tt.current = null, xt.current = "");
  }, [Ke]), index$1(() => {
    if (Ke && xt.current === "") {
      var Ut;
      Et.current = (Ut = vt ?? Qe) != null ? Ut : -1;
    }
  }, [Ke, vt, Qe]), React.useMemo(() => {
    if (!lt)
      return {};
    function Ut(Ft) {
      Ft ? Ve.current.typing || (Ve.current.typing = Ft, Ct(Ft)) : Ve.current.typing && (Ve.current.typing = Ft, Ct(Ft));
    }
    function Pt(Ft, gt, We) {
      const Xe = Zt.current ? Zt.current(gt, We) : gt.find((rt) => (rt == null ? void 0 : rt.toLocaleLowerCase().indexOf(We.toLocaleLowerCase())) === 0);
      return Xe ? Ft.indexOf(Xe) : -1;
    }
    function Ot(Ft) {
      const gt = Je.current;
      if (xt.current.length > 0 && xt.current[0] !== " " && (Pt(gt, gt, xt.current) === -1 ? Ut(!1) : Ft.key === " " && stopEvent(Ft)), gt == null || Lt.current.includes(Ft.key) || // Character key.
      Ft.key.length !== 1 || // Modifier key.
      Ft.ctrlKey || Ft.metaKey || Ft.altKey)
        return;
      Ke && Ft.key !== " " && (stopEvent(Ft), Ut(!0)), gt.every((ot) => {
        var ft, mt;
        return ot ? ((ft = ot[0]) == null ? void 0 : ft.toLocaleLowerCase()) !== ((mt = ot[1]) == null ? void 0 : mt.toLocaleLowerCase()) : !0;
      }) && xt.current === Ft.key && (xt.current = "", Et.current = Tt.current), xt.current += Ft.key, clearTimeout(wt.current), wt.current = setTimeout(() => {
        xt.current = "", Et.current = Tt.current, Ut(!1);
      }, bt);
      const Xe = Et.current, rt = Pt(gt, [...gt.slice((Xe || 0) + 1), ...gt.slice(0, (Xe || 0) + 1)], xt.current);
      rt !== -1 ? (Rt(rt), Tt.current = rt) : Ft.key !== " " && (xt.current = "", Ut(!1));
    }
    return {
      reference: {
        onKeyDown: Ot
      },
      floating: {
        onKeyDown: Ot,
        onKeyUp(Ft) {
          Ft.key === " " && Ut(!1);
        }
      }
    };
  }, [lt, Ke, Ve, Je, bt, Lt, Zt, Rt, Ct]);
}
const Dropdown = ({ styles: $e, type: Ze, options: Fe, label: Ke, reusable: Ve }) => {
  var mt, yt, pt, Ge, ct, Mt, St, At, Nt, qt, Qt, Xt;
  const { state: Je } = useWebchatContext(), [Qe, at] = React.useState(!1), [ut, lt] = React.useState(null), [dt, bt] = React.useState(null), { client: $t } = useWebchatContext(), vt = Fe.reduce((zt, Kt) => (zt[Kt.label] = Kt.value, zt), {}), wt = vt ? Object.keys(vt) : [], xt = (zt) => {
    at(dt !== null && !Ve ? !1 : zt);
  }, { refs: Et, floatingStyles: Tt, context: Rt } = useFloating({
    placement: "bottom-start",
    open: Qe,
    onOpenChange: xt,
    whileElementsMounted: autoUpdate,
    middleware: [
      offset(5),
      flip({ padding: 10 }),
      size({
        apply({ rects: zt, elements: Kt, availableHeight: ur }) {
          Object.assign(Kt.floating.style, {
            maxHeight: `${ur}px`,
            minWidth: `${zt.reference.width}px`
          });
        },
        padding: 10
      })
    ]
  }), Ct = React.useRef([]), Zt = React.useRef(wt), Lt = React.useRef(!1), Ut = useClick(Rt, { event: "mousedown" }), Pt = useDismiss(Rt), Ot = useRole(Rt, { role: "listbox" }), Ft = useListNavigation(Rt, {
    listRef: Ct,
    activeIndex: ut,
    selectedIndex: dt,
    onNavigate: lt,
    // This is a large list, allow looping.
    loop: !0
  }), gt = useTypeahead(Rt, {
    listRef: Zt,
    activeIndex: ut,
    selectedIndex: dt,
    onMatch: Qe ? lt : bt,
    onTypingChange(zt) {
      Lt.current = zt;
    }
  }), { getReferenceProps: We, getFloatingProps: Xe, getItemProps: rt } = useInteractions([
    Pt,
    Ot,
    Ft,
    gt,
    Ut
  ]), ot = (zt) => {
    bt(zt), $t == null || $t.sendMessage(vt[wt[zt]]), at(!1);
  }, ft = dt !== null ? wt[dt] : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        tabIndex: 0,
        ref: Et.setReference,
        "aria-labelledby": "select-label",
        "aria-autocomplete": "none",
        "data-disabled": dt !== null && !Ve ? "" : void 0,
        ...(yt = (mt = $e == null ? void 0 : $e[Ze]) == null ? void 0 : mt.button) == null ? void 0 : yt.container,
        ...We(),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { ...(Ge = (pt = $e == null ? void 0 : $e[Ze]) == null ? void 0 : pt.button) == null ? void 0 : Ge.text, children: ft || Ke || "Select..." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDownIcon$1, { ...(Mt = (ct = $e == null ? void 0 : $e[Ze]) == null ? void 0 : ct.button) == null ? void 0 : Mt.icon })
        ]
      }
    ),
    Qe && /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingPortal, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingFocusManager, { context: Rt, modal: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: Et.setFloating,
        className: (Nt = (At = (St = $e == null ? void 0 : $e[Ze]) == null ? void 0 : St.content) == null ? void 0 : At.container) == null ? void 0 : Nt.className,
        style: { ...Tt, ...(Xt = (Qt = (qt = $e == null ? void 0 : $e[Ze]) == null ? void 0 : qt.content) == null ? void 0 : Qt.container) == null ? void 0 : Xt.style },
        ...Xe(),
        children: wt.map((zt, Kt) => {
          var ur, er;
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              ref: (Dt) => {
                Ct.current[Kt] = Dt;
              },
              role: "option",
              tabIndex: Kt === ut ? 0 : -1,
              "aria-selected": Kt === dt && Kt === ut,
              "data-active": Kt === ut ? "" : void 0,
              ...(er = (ur = $e == null ? void 0 : $e[Ze]) == null ? void 0 : ur.content) == null ? void 0 : er.item,
              ...rt({
                onClick() {
                  Je.isReadOnly || ot(Kt);
                },
                onKeyDown(Dt) {
                  Je.isReadOnly || (Dt.key === "Enter" && (Dt.preventDefault(), ot(Kt)), Dt.key === " " && !Lt.current && (Dt.preventDefault(), ot(Kt)));
                }
              }),
              children: zt
            },
            zt
          );
        })
      }
    ) }) })
  ] });
}, File$1 = forwardRef(({ type: $e, title: Ze, styles: Fe, url: Ke, ...Ve }, Je) => {
  var Qe, at, ut;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { ...Ve, ...(Qe = Fe == null ? void 0 : Fe[$e]) == null ? void 0 : Qe.container, href: Ke, download: !0, ref: Je, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { ...(at = Fe == null ? void 0 : Fe[$e]) == null ? void 0 : at.title, children: Ze || Ke }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DocumentArrowDownIcon$1, { ...(ut = Fe == null ? void 0 : Fe[$e]) == null ? void 0 : ut.icon })
  ] });
}), renderers = {
  text: Text,
  button: Button,
  bubble: Bubble,
  audio: Audio,
  column: Column,
  file: File$1,
  image: Image$1,
  location: Location,
  row: Row,
  video: Video,
  carousel: Carousel,
  dropdown: Dropdown
}, Block = ({
  block: $e,
  styles: Ze,
  ...Fe
}) => {
  const Ke = renderers[$e.type];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Ke, { ...Fe, ...$e, styles: Ze });
}, createStoreImpl = ($e) => {
  let Ze;
  const Fe = /* @__PURE__ */ new Set(), Ke = (ut, lt) => {
    const dt = typeof ut == "function" ? ut(Ze) : ut;
    if (!Object.is(dt, Ze)) {
      const bt = Ze;
      Ze = lt ?? typeof dt != "object" ? dt : Object.assign({}, Ze, dt), Fe.forEach(($t) => $t(Ze, bt));
    }
  }, Ve = () => Ze, at = { setState: Ke, getState: Ve, subscribe: (ut) => (Fe.add(ut), () => Fe.delete(ut)), destroy: () => {
    Fe.clear();
  } };
  return Ze = $e(Ke, Ve, at), at;
}, createStore = ($e) => $e ? createStoreImpl($e) : createStoreImpl;
var withSelector = { exports: {} }, withSelector_production_min = {}, shim = { exports: {} }, useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_production_min;
function requireUseSyncExternalStoreShim_production_min() {
  if (hasRequiredUseSyncExternalStoreShim_production_min)
    return useSyncExternalStoreShim_production_min;
  hasRequiredUseSyncExternalStoreShim_production_min = 1;
  var $e = React__default;
  function Ze(bt, $t) {
    return bt === $t && (bt !== 0 || 1 / bt === 1 / $t) || bt !== bt && $t !== $t;
  }
  var Fe = typeof Object.is == "function" ? Object.is : Ze, Ke = $e.useState, Ve = $e.useEffect, Je = $e.useLayoutEffect, Qe = $e.useDebugValue;
  function at(bt, $t) {
    var vt = $t(), wt = Ke({ inst: { value: vt, getSnapshot: $t } }), xt = wt[0].inst, Et = wt[1];
    return Je(function() {
      xt.value = vt, xt.getSnapshot = $t, ut(xt) && Et({ inst: xt });
    }, [bt, vt, $t]), Ve(function() {
      return ut(xt) && Et({ inst: xt }), bt(function() {
        ut(xt) && Et({ inst: xt });
      });
    }, [bt]), Qe(vt), vt;
  }
  function ut(bt) {
    var $t = bt.getSnapshot;
    bt = bt.value;
    try {
      var vt = $t();
      return !Fe(bt, vt);
    } catch {
      return !0;
    }
  }
  function lt(bt, $t) {
    return $t();
  }
  var dt = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? lt : at;
  return useSyncExternalStoreShim_production_min.useSyncExternalStore = $e.useSyncExternalStore !== void 0 ? $e.useSyncExternalStore : dt, useSyncExternalStoreShim_production_min;
}
var useSyncExternalStoreShim_development = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_development;
function requireUseSyncExternalStoreShim_development() {
  return hasRequiredUseSyncExternalStoreShim_development || (hasRequiredUseSyncExternalStoreShim_development = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var $e = React__default, Ze = $e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function Fe(Ct) {
      {
        for (var Zt = arguments.length, Lt = new Array(Zt > 1 ? Zt - 1 : 0), Ut = 1; Ut < Zt; Ut++)
          Lt[Ut - 1] = arguments[Ut];
        Ke("error", Ct, Lt);
      }
    }
    function Ke(Ct, Zt, Lt) {
      {
        var Ut = Ze.ReactDebugCurrentFrame, Pt = Ut.getStackAddendum();
        Pt !== "" && (Zt += "%s", Lt = Lt.concat([Pt]));
        var Ot = Lt.map(function(Ft) {
          return String(Ft);
        });
        Ot.unshift("Warning: " + Zt), Function.prototype.apply.call(console[Ct], console, Ot);
      }
    }
    function Ve(Ct, Zt) {
      return Ct === Zt && (Ct !== 0 || 1 / Ct === 1 / Zt) || Ct !== Ct && Zt !== Zt;
    }
    var Je = typeof Object.is == "function" ? Object.is : Ve, Qe = $e.useState, at = $e.useEffect, ut = $e.useLayoutEffect, lt = $e.useDebugValue, dt = !1, bt = !1;
    function $t(Ct, Zt, Lt) {
      dt || $e.startTransition !== void 0 && (dt = !0, Fe("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var Ut = Zt();
      if (!bt) {
        var Pt = Zt();
        Je(Ut, Pt) || (Fe("The result of getSnapshot should be cached to avoid an infinite loop"), bt = !0);
      }
      var Ot = Qe({
        inst: {
          value: Ut,
          getSnapshot: Zt
        }
      }), Ft = Ot[0].inst, gt = Ot[1];
      return ut(function() {
        Ft.value = Ut, Ft.getSnapshot = Zt, vt(Ft) && gt({
          inst: Ft
        });
      }, [Ct, Ut, Zt]), at(function() {
        vt(Ft) && gt({
          inst: Ft
        });
        var We = function() {
          vt(Ft) && gt({
            inst: Ft
          });
        };
        return Ct(We);
      }, [Ct]), lt(Ut), Ut;
    }
    function vt(Ct) {
      var Zt = Ct.getSnapshot, Lt = Ct.value;
      try {
        var Ut = Zt();
        return !Je(Lt, Ut);
      } catch {
        return !0;
      }
    }
    function wt(Ct, Zt, Lt) {
      return Zt();
    }
    var xt = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Et = !xt, Tt = Et ? wt : $t, Rt = $e.useSyncExternalStore !== void 0 ? $e.useSyncExternalStore : Tt;
    useSyncExternalStoreShim_development.useSyncExternalStore = Rt, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), useSyncExternalStoreShim_development;
}
var hasRequiredShim;
function requireShim() {
  return hasRequiredShim || (hasRequiredShim = 1, process.env.NODE_ENV === "production" ? shim.exports = requireUseSyncExternalStoreShim_production_min() : shim.exports = requireUseSyncExternalStoreShim_development()), shim.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredWithSelector_production_min;
function requireWithSelector_production_min() {
  if (hasRequiredWithSelector_production_min)
    return withSelector_production_min;
  hasRequiredWithSelector_production_min = 1;
  var $e = React__default, Ze = requireShim();
  function Fe(lt, dt) {
    return lt === dt && (lt !== 0 || 1 / lt === 1 / dt) || lt !== lt && dt !== dt;
  }
  var Ke = typeof Object.is == "function" ? Object.is : Fe, Ve = Ze.useSyncExternalStore, Je = $e.useRef, Qe = $e.useEffect, at = $e.useMemo, ut = $e.useDebugValue;
  return withSelector_production_min.useSyncExternalStoreWithSelector = function(lt, dt, bt, $t, vt) {
    var wt = Je(null);
    if (wt.current === null) {
      var xt = { hasValue: !1, value: null };
      wt.current = xt;
    } else
      xt = wt.current;
    wt = at(function() {
      function Tt(Ut) {
        if (!Rt) {
          if (Rt = !0, Ct = Ut, Ut = $t(Ut), vt !== void 0 && xt.hasValue) {
            var Pt = xt.value;
            if (vt(Pt, Ut))
              return Zt = Pt;
          }
          return Zt = Ut;
        }
        if (Pt = Zt, Ke(Ct, Ut))
          return Pt;
        var Ot = $t(Ut);
        return vt !== void 0 && vt(Pt, Ot) ? Pt : (Ct = Ut, Zt = Ot);
      }
      var Rt = !1, Ct, Zt, Lt = bt === void 0 ? null : bt;
      return [function() {
        return Tt(dt());
      }, Lt === null ? void 0 : function() {
        return Tt(Lt());
      }];
    }, [dt, bt, $t, vt]);
    var Et = Ve(lt, wt[0], wt[1]);
    return Qe(function() {
      xt.hasValue = !0, xt.value = Et;
    }, [Et]), ut(Et), Et;
  }, withSelector_production_min;
}
var withSelector_development = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredWithSelector_development;
function requireWithSelector_development() {
  return hasRequiredWithSelector_development || (hasRequiredWithSelector_development = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var $e = React__default, Ze = requireShim();
    function Fe(dt, bt) {
      return dt === bt && (dt !== 0 || 1 / dt === 1 / bt) || dt !== dt && bt !== bt;
    }
    var Ke = typeof Object.is == "function" ? Object.is : Fe, Ve = Ze.useSyncExternalStore, Je = $e.useRef, Qe = $e.useEffect, at = $e.useMemo, ut = $e.useDebugValue;
    function lt(dt, bt, $t, vt, wt) {
      var xt = Je(null), Et;
      xt.current === null ? (Et = {
        hasValue: !1,
        value: null
      }, xt.current = Et) : Et = xt.current;
      var Tt = at(function() {
        var Lt = !1, Ut, Pt, Ot = function(Xe) {
          if (!Lt) {
            Lt = !0, Ut = Xe;
            var rt = vt(Xe);
            if (wt !== void 0 && Et.hasValue) {
              var ot = Et.value;
              if (wt(ot, rt))
                return Pt = ot, ot;
            }
            return Pt = rt, rt;
          }
          var ft = Ut, mt = Pt;
          if (Ke(ft, Xe))
            return mt;
          var yt = vt(Xe);
          return wt !== void 0 && wt(mt, yt) ? mt : (Ut = Xe, Pt = yt, yt);
        }, Ft = $t === void 0 ? null : $t, gt = function() {
          return Ot(bt());
        }, We = Ft === null ? void 0 : function() {
          return Ot(Ft());
        };
        return [gt, We];
      }, [bt, $t, vt, wt]), Rt = Tt[0], Ct = Tt[1], Zt = Ve(dt, Rt, Ct);
      return Qe(function() {
        Et.hasValue = !0, Et.value = Zt;
      }, [Zt]), ut(Zt), Zt;
    }
    withSelector_development.useSyncExternalStoreWithSelector = lt, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), withSelector_development;
}
process.env.NODE_ENV === "production" ? withSelector.exports = requireWithSelector_production_min() : withSelector.exports = requireWithSelector_development();
var withSelectorExports = withSelector.exports;
const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports), { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;
let didWarnAboutEqualityFn = !1;
function useStore($e, Ze = $e.getState, Fe) {
  const Ke = useSyncExternalStoreWithSelector(
    $e.subscribe,
    $e.getState,
    $e.getServerState || $e.getState,
    Ze,
    Fe
  );
  return useDebugValue(Ke), Ke;
}
const createImpl = ($e) => {
  const Ze = typeof $e == "function" ? createStore($e) : $e, Fe = (Ke, Ve) => useStore(Ze, Ke, Ve);
  return Object.assign(Fe, Ze), Fe;
}, create = ($e) => $e ? createImpl($e) : createImpl, trackedConnections = /* @__PURE__ */ new Map(), getTrackedConnectionState = ($e) => {
  const Ze = trackedConnections.get($e);
  return Ze ? Object.fromEntries(
    Object.entries(Ze.stores).map(([Fe, Ke]) => [Fe, Ke.getState()])
  ) : {};
}, extractConnectionInformation = ($e, Ze, Fe) => {
  if ($e === void 0)
    return {
      type: "untracked",
      connection: Ze.connect(Fe)
    };
  const Ke = trackedConnections.get(Fe.name);
  if (Ke)
    return { type: "tracked", store: $e, ...Ke };
  const Ve = {
    connection: Ze.connect(Fe),
    stores: {}
  };
  return trackedConnections.set(Fe.name, Ve), { type: "tracked", store: $e, ...Ve };
}, devtoolsImpl = ($e, Ze = {}) => (Fe, Ke, Ve) => {
  const { enabled: Je, anonymousActionType: Qe, store: at, ...ut } = Ze;
  let lt;
  try {
    lt = (Je ?? !1) && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch {
  }
  if (!lt)
    return $e(Fe, Ke, Ve);
  const { connection: dt, ...bt } = extractConnectionInformation(at, lt, ut);
  let $t = !0;
  Ve.setState = (xt, Et, Tt) => {
    const Rt = Fe(xt, Et);
    if (!$t)
      return Rt;
    const Ct = Tt === void 0 ? { type: Qe || "anonymous" } : typeof Tt == "string" ? { type: Tt } : Tt;
    return at === void 0 ? (dt == null || dt.send(Ct, Ke()), Rt) : (dt == null || dt.send(
      {
        ...Ct,
        type: `${at}/${Ct.type}`
      },
      {
        ...getTrackedConnectionState(ut.name),
        [at]: Ve.getState()
      }
    ), Rt);
  };
  const vt = (...xt) => {
    const Et = $t;
    $t = !1, Fe(...xt), $t = Et;
  }, wt = $e(Ve.setState, Ke, Ve);
  if (bt.type === "untracked" ? dt == null || dt.init(wt) : (bt.stores[bt.store] = Ve, dt == null || dt.init(
    Object.fromEntries(
      Object.entries(bt.stores).map(([xt, Et]) => [
        xt,
        xt === bt.store ? wt : Et.getState()
      ])
    )
  )), Ve.dispatchFromDevtools && typeof Ve.dispatch == "function") {
    let xt = !1;
    const Et = Ve.dispatch;
    Ve.dispatch = (...Tt) => {
      Et(...Tt);
    };
  }
  return dt.subscribe((xt) => {
    var Et;
    switch (xt.type) {
      case "ACTION":
        if (typeof xt.payload != "string") {
          console.error(
            "[zustand devtools middleware] Unsupported action format"
          );
          return;
        }
        return parseJsonThen(
          xt.payload,
          (Tt) => {
            if (Tt.type === "__setState") {
              if (at === void 0) {
                vt(Tt.state);
                return;
              }
              Object.keys(Tt.state).length !== 1 && console.error(
                `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
              );
              const Rt = Tt.state[at];
              if (Rt == null)
                return;
              JSON.stringify(Ve.getState()) !== JSON.stringify(Rt) && vt(Rt);
              return;
            }
            Ve.dispatchFromDevtools && typeof Ve.dispatch == "function" && Ve.dispatch(Tt);
          }
        );
      case "DISPATCH":
        switch (xt.payload.type) {
          case "RESET":
            return vt(wt), at === void 0 ? dt == null ? void 0 : dt.init(Ve.getState()) : dt == null ? void 0 : dt.init(getTrackedConnectionState(ut.name));
          case "COMMIT":
            if (at === void 0) {
              dt == null || dt.init(Ve.getState());
              return;
            }
            return dt == null ? void 0 : dt.init(getTrackedConnectionState(ut.name));
          case "ROLLBACK":
            return parseJsonThen(xt.state, (Tt) => {
              if (at === void 0) {
                vt(Tt), dt == null || dt.init(Ve.getState());
                return;
              }
              vt(Tt[at]), dt == null || dt.init(getTrackedConnectionState(ut.name));
            });
          case "JUMP_TO_STATE":
          case "JUMP_TO_ACTION":
            return parseJsonThen(xt.state, (Tt) => {
              if (at === void 0) {
                vt(Tt);
                return;
              }
              JSON.stringify(Ve.getState()) !== JSON.stringify(Tt[at]) && vt(Tt[at]);
            });
          case "IMPORT_STATE": {
            const { nextLiftedState: Tt } = xt.payload, Rt = (Et = Tt.computedStates.slice(-1)[0]) == null ? void 0 : Et.state;
            if (!Rt)
              return;
            vt(at === void 0 ? Rt : Rt[at]), dt == null || dt.send(
              null,
              // FIXME no-any
              Tt
            );
            return;
          }
          case "PAUSE_RECORDING":
            return $t = !$t;
        }
        return;
    }
  }), wt;
}, devtools = devtoolsImpl, parseJsonThen = ($e, Ze) => {
  let Fe;
  try {
    Fe = JSON.parse($e);
  } catch (Ke) {
    console.error(
      "[zustand devtools middleware] Could not parse the received json",
      Ke
    );
  }
  Fe !== void 0 && Ze(Fe);
};
function createJSONStorage($e, Ze) {
  let Fe;
  try {
    Fe = $e();
  } catch {
    return;
  }
  return {
    getItem: (Ve) => {
      var Je;
      const Qe = (ut) => ut === null ? null : JSON.parse(ut, Ze == null ? void 0 : Ze.reviver), at = (Je = Fe.getItem(Ve)) != null ? Je : null;
      return at instanceof Promise ? at.then(Qe) : Qe(at);
    },
    setItem: (Ve, Je) => Fe.setItem(
      Ve,
      JSON.stringify(Je, Ze == null ? void 0 : Ze.replacer)
    ),
    removeItem: (Ve) => Fe.removeItem(Ve)
  };
}
const toThenable = ($e) => (Ze) => {
  try {
    const Fe = $e(Ze);
    return Fe instanceof Promise ? Fe : {
      then(Ke) {
        return toThenable(Ke)(Fe);
      },
      catch(Ke) {
        return this;
      }
    };
  } catch (Fe) {
    return {
      then(Ke) {
        return this;
      },
      catch(Ke) {
        return toThenable(Ke)(Fe);
      }
    };
  }
}, oldImpl = ($e, Ze) => (Fe, Ke, Ve) => {
  let Je = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (Et) => Et,
    version: 0,
    merge: (Et, Tt) => ({
      ...Tt,
      ...Et
    }),
    ...Ze
  }, Qe = !1;
  const at = /* @__PURE__ */ new Set(), ut = /* @__PURE__ */ new Set();
  let lt;
  try {
    lt = Je.getStorage();
  } catch {
  }
  if (!lt)
    return $e(
      (...Et) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${Je.name}', the given storage is currently unavailable.`
        ), Fe(...Et);
      },
      Ke,
      Ve
    );
  const dt = toThenable(Je.serialize), bt = () => {
    const Et = Je.partialize({ ...Ke() });
    let Tt;
    const Rt = dt({ state: Et, version: Je.version }).then(
      (Ct) => lt.setItem(Je.name, Ct)
    ).catch((Ct) => {
      Tt = Ct;
    });
    if (Tt)
      throw Tt;
    return Rt;
  }, $t = Ve.setState;
  Ve.setState = (Et, Tt) => {
    $t(Et, Tt), bt();
  };
  const vt = $e(
    (...Et) => {
      Fe(...Et), bt();
    },
    Ke,
    Ve
  );
  let wt;
  const xt = () => {
    var Et;
    if (!lt)
      return;
    Qe = !1, at.forEach((Rt) => Rt(Ke()));
    const Tt = ((Et = Je.onRehydrateStorage) == null ? void 0 : Et.call(Je, Ke())) || void 0;
    return toThenable(lt.getItem.bind(lt))(Je.name).then((Rt) => {
      if (Rt)
        return Je.deserialize(Rt);
    }).then((Rt) => {
      if (Rt)
        if (typeof Rt.version == "number" && Rt.version !== Je.version) {
          if (Je.migrate)
            return Je.migrate(
              Rt.state,
              Rt.version
            );
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return Rt.state;
    }).then((Rt) => {
      var Ct;
      return wt = Je.merge(
        Rt,
        (Ct = Ke()) != null ? Ct : vt
      ), Fe(wt, !0), bt();
    }).then(() => {
      Tt == null || Tt(wt, void 0), Qe = !0, ut.forEach((Rt) => Rt(wt));
    }).catch((Rt) => {
      Tt == null || Tt(void 0, Rt);
    });
  };
  return Ve.persist = {
    setOptions: (Et) => {
      Je = {
        ...Je,
        ...Et
      }, Et.getStorage && (lt = Et.getStorage());
    },
    clearStorage: () => {
      lt == null || lt.removeItem(Je.name);
    },
    getOptions: () => Je,
    rehydrate: () => xt(),
    hasHydrated: () => Qe,
    onHydrate: (Et) => (at.add(Et), () => {
      at.delete(Et);
    }),
    onFinishHydration: (Et) => (ut.add(Et), () => {
      ut.delete(Et);
    })
  }, xt(), wt || vt;
}, newImpl = ($e, Ze) => (Fe, Ke, Ve) => {
  let Je = {
    storage: createJSONStorage(() => localStorage),
    partialize: (xt) => xt,
    version: 0,
    merge: (xt, Et) => ({
      ...Et,
      ...xt
    }),
    ...Ze
  }, Qe = !1;
  const at = /* @__PURE__ */ new Set(), ut = /* @__PURE__ */ new Set();
  let lt = Je.storage;
  if (!lt)
    return $e(
      (...xt) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${Je.name}', the given storage is currently unavailable.`
        ), Fe(...xt);
      },
      Ke,
      Ve
    );
  const dt = () => {
    const xt = Je.partialize({ ...Ke() });
    return lt.setItem(Je.name, {
      state: xt,
      version: Je.version
    });
  }, bt = Ve.setState;
  Ve.setState = (xt, Et) => {
    bt(xt, Et), dt();
  };
  const $t = $e(
    (...xt) => {
      Fe(...xt), dt();
    },
    Ke,
    Ve
  );
  let vt;
  const wt = () => {
    var xt, Et;
    if (!lt)
      return;
    Qe = !1, at.forEach((Rt) => {
      var Ct;
      return Rt((Ct = Ke()) != null ? Ct : $t);
    });
    const Tt = ((Et = Je.onRehydrateStorage) == null ? void 0 : Et.call(Je, (xt = Ke()) != null ? xt : $t)) || void 0;
    return toThenable(lt.getItem.bind(lt))(Je.name).then((Rt) => {
      if (Rt)
        if (typeof Rt.version == "number" && Rt.version !== Je.version) {
          if (Je.migrate)
            return Je.migrate(
              Rt.state,
              Rt.version
            );
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return Rt.state;
    }).then((Rt) => {
      var Ct;
      return vt = Je.merge(
        Rt,
        (Ct = Ke()) != null ? Ct : $t
      ), Fe(vt, !0), dt();
    }).then(() => {
      Tt == null || Tt(vt, void 0), vt = Ke(), Qe = !0, ut.forEach((Rt) => Rt(vt));
    }).catch((Rt) => {
      Tt == null || Tt(void 0, Rt);
    });
  };
  return Ve.persist = {
    setOptions: (xt) => {
      Je = {
        ...Je,
        ...xt
      }, xt.storage && (lt = xt.storage);
    },
    clearStorage: () => {
      lt == null || lt.removeItem(Je.name);
    },
    getOptions: () => Je,
    rehydrate: () => wt(),
    hasHydrated: () => Qe,
    onHydrate: (xt) => (at.add(xt), () => {
      at.delete(xt);
    }),
    onFinishHydration: (xt) => (ut.add(xt), () => {
      ut.delete(xt);
    })
  }, Je.skipHydration || wt(), vt || $t;
}, persistImpl = ($e, Ze) => "getStorage" in Ze || "serialize" in Ze || "deserialize" in Ze ? oldImpl($e, Ze) : newImpl($e, Ze), persist = persistImpl, useWebchatStore = create()(
  devtools(
    persist(
      ($e) => ({
        messageHistory: {},
        addMessageToHistory: ({ userId: Ze, message: Fe }) => $e((Ke) => ({
          ...Ke,
          messageHistory: {
            ...Ke.messageHistory,
            [Ze]: [Fe, ...(Ke.messageHistory[Ze] ?? []).slice(0, 100)]
          }
        })),
        setUser: (Ze) => $e((Fe) => ({
          ...Fe,
          user: Ze
        })),
        setConversationId: (Ze) => $e((Fe) => ({
          ...Fe,
          conversationId: Ze
        }))
      }),
      {
        name: "botpress-webchat"
      }
    )
  )
);
var __assign = function() {
  return __assign = Object.assign || function(Ze) {
    for (var Fe, Ke = 1, Ve = arguments.length; Ke < Ve; Ke++) {
      Fe = arguments[Ke];
      for (var Je in Fe)
        Object.prototype.hasOwnProperty.call(Fe, Je) && (Ze[Je] = Fe[Je]);
    }
    return Ze;
  }, __assign.apply(this, arguments);
};
function __rest($e, Ze) {
  var Fe = {};
  for (var Ke in $e)
    Object.prototype.hasOwnProperty.call($e, Ke) && Ze.indexOf(Ke) < 0 && (Fe[Ke] = $e[Ke]);
  if ($e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var Ve = 0, Ke = Object.getOwnPropertySymbols($e); Ve < Ke.length; Ve++)
      Ze.indexOf(Ke[Ve]) < 0 && Object.prototype.propertyIsEnumerable.call($e, Ke[Ve]) && (Fe[Ke[Ve]] = $e[Ke[Ve]]);
  return Fe;
}
function __spreadArray($e, Ze, Fe) {
  if (Fe || arguments.length === 2)
    for (var Ke = 0, Ve = Ze.length, Je; Ke < Ve; Ke++)
      (Je || !(Ke in Ze)) && (Je || (Je = Array.prototype.slice.call(Ze, 0, Ke)), Je[Ke] = Ze[Ke]);
  return $e.concat(Je || Array.prototype.slice.call(Ze));
}
typeof SuppressedError == "function" && SuppressedError;
function useMountedState() {
  var $e = useRef(!1), Ze = useCallback(function() {
    return $e.current;
  }, []);
  return useEffect(function() {
    return $e.current = !0, function() {
      $e.current = !1;
    };
  }, []), Ze;
}
function useAsyncFn($e, Ze, Fe) {
  Ze === void 0 && (Ze = []), Fe === void 0 && (Fe = { loading: !1 });
  var Ke = useRef(0), Ve = useMountedState(), Je = useState(Fe), Qe = Je[0], at = Je[1], ut = useCallback(function() {
    for (var lt = [], dt = 0; dt < arguments.length; dt++)
      lt[dt] = arguments[dt];
    var bt = ++Ke.current;
    return Qe.loading || at(function($t) {
      return __assign(__assign({}, $t), { loading: !0 });
    }), $e.apply(void 0, lt).then(function($t) {
      return Ve() && bt === Ke.current && at({ value: $t, loading: !1 }), $t;
    }, function($t) {
      return Ve() && bt === Ke.current && at({ error: $t, loading: !1 }), $t;
    });
  }, Ze);
  return [Qe, ut];
}
function useAsync($e, Ze) {
  Ze === void 0 && (Ze = []);
  var Fe = useAsyncFn($e, Ze, {
    loading: !0
  }), Ke = Fe[0], Ve = Fe[1];
  return useEffect(function() {
    Ve();
  }, [Ve]), Ke;
}
function on$3($e) {
  for (var Ze = [], Fe = 1; Fe < arguments.length; Fe++)
    Ze[Fe - 1] = arguments[Fe];
  $e && $e.addEventListener && $e.addEventListener.apply($e, Ze);
}
function off$1($e) {
  for (var Ze = [], Fe = 1; Fe < arguments.length; Fe++)
    Ze[Fe - 1] = arguments[Fe];
  $e && $e.removeEventListener && $e.removeEventListener.apply($e, Ze);
}
var useEffectOnce = function($e) {
  useEffect($e, []);
};
const useEffectOnce$1 = useEffectOnce;
var useMount = function($e) {
  useEffectOnce$1(function() {
    $e();
  });
};
const useMount$1 = useMount;
var useUnmount = function($e) {
  var Ze = useRef($e);
  Ze.current = $e, useEffectOnce$1(function() {
    return function() {
      return Ze.current();
    };
  });
};
const useUnmount$1 = useUnmount;
var useRafState = function($e) {
  var Ze = useRef(0), Fe = useState($e), Ke = Fe[0], Ve = Fe[1], Je = useCallback(function(Qe) {
    cancelAnimationFrame(Ze.current), Ze.current = requestAnimationFrame(function() {
      Ve(Qe);
    });
  }, []);
  return useUnmount$1(function() {
    cancelAnimationFrame(Ze.current);
  }), [Ke, Je];
};
const useRafState$1 = useRafState;
var useScroll = function($e) {
  process.env.NODE_ENV === "development" && (typeof $e != "object" || typeof $e.current > "u") && console.error("`useScroll` expects a single ref argument.");
  var Ze = useRafState$1({
    x: 0,
    y: 0
  }), Fe = Ze[0], Ke = Ze[1];
  return useEffect(function() {
    var Ve = function() {
      $e.current && Ke({
        x: $e.current.scrollLeft,
        y: $e.current.scrollTop
      });
    };
    return $e.current && on$3($e.current, "scroll", Ve, {
      capture: !1,
      passive: !0
    }), function() {
      $e.current && off$1($e.current, "scroll", Ve);
    };
  }, [$e]), Fe;
};
const useScroll$1 = useScroll, defaultGetRefreshTime = ($e) => {
  const Ze = /* @__PURE__ */ new Date();
  return $e.getTime() - Ze.getTime();
}, useRefresh = ($e = defaultGetRefreshTime) => {
  const [Ze, Fe] = useState(0), [Ke, Ve] = useState(), Je = () => Fe((Qe) => Qe + 1);
  return useAsync(async () => {
    if (Ke) {
      const Qe = setTimeout(Je, $e(Ke));
      return () => {
        clearTimeout(Qe);
      };
    }
  }, [Ke]), [Ze, Ve];
};
var dist$3 = {}, dist$2 = {}, conversations = {};
Object.defineProperty(conversations, "__esModule", { value: !0 });
var emitter$1 = {}, __awaiter$2 = commonjsGlobal && commonjsGlobal.__awaiter || function($e, Ze, Fe, Ke) {
  function Ve(Je) {
    return Je instanceof Fe ? Je : new Fe(function(Qe) {
      Qe(Je);
    });
  }
  return new (Fe || (Fe = Promise))(function(Je, Qe) {
    function at(dt) {
      try {
        lt(Ke.next(dt));
      } catch (bt) {
        Qe(bt);
      }
    }
    function ut(dt) {
      try {
        lt(Ke.throw(dt));
      } catch (bt) {
        Qe(bt);
      }
    }
    function lt(dt) {
      dt.done ? Je(dt.value) : Ve(dt.value).then(at, ut);
    }
    lt((Ke = Ke.apply($e, Ze || [])).next());
  });
};
Object.defineProperty(emitter$1, "__esModule", { value: !0 });
emitter$1.Emitter = void 0;
let Emitter$1 = class {
  constructor() {
    this.listeners = {};
  }
  on(Ze, Fe, Ke = !1) {
    const Ve = this.listeners[Ze];
    Ve ? Ke ? Ve.unshift(Fe) : Ve.push(Fe) : this.listeners[Ze] = [Fe];
  }
  emit(Ze, Fe) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const Ke = this.listeners[Ze];
      if (Ke != null && Ke.length) {
        for (const Ve of Ke)
          yield Ve(Fe);
        return !0;
      } else
        return !1;
    });
  }
};
emitter$1.Emitter = Emitter$1;
var endpoint = {};
Object.defineProperty(endpoint, "__esModule", { value: !0 });
var health = {};
(function($e) {
  Object.defineProperty($e, "__esModule", { value: !0 }), $e.HealthEventType = void 0, function(Ze) {
    Ze.Create = "create", Ze.Configure = "configure", Ze.Start = "start", Ze.StartFailure = "start-failure", Ze.Initialize = "initialize", Ze.InitializeFailure = "initialize-failure", Ze.Sleep = "sleep", Ze.Delete = "delete";
  }($e.HealthEventType || ($e.HealthEventType = {}));
})(health);
var messages = {};
Object.defineProperty(messages, "__esModule", { value: !0 });
var sync = {};
Object.defineProperty(sync, "__esModule", { value: !0 });
var users = {};
Object.defineProperty(users, "__esModule", { value: !0 });
var uuid = {};
Object.defineProperty(uuid, "__esModule", { value: !0 });
(function($e) {
  var Ze = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(Ke, Ve, Je, Qe) {
    Qe === void 0 && (Qe = Je), Object.defineProperty(Ke, Qe, { enumerable: !0, get: function() {
      return Ve[Je];
    } });
  } : function(Ke, Ve, Je, Qe) {
    Qe === void 0 && (Qe = Je), Ke[Qe] = Ve[Je];
  }), Fe = commonjsGlobal && commonjsGlobal.__exportStar || function(Ke, Ve) {
    for (var Je in Ke)
      Je !== "default" && !Object.prototype.hasOwnProperty.call(Ve, Je) && Ze(Ve, Ke, Je);
  };
  Object.defineProperty($e, "__esModule", { value: !0 }), Fe(conversations, $e), Fe(emitter$1, $e), Fe(endpoint, $e), Fe(health, $e), Fe(messages, $e), Fe(sync, $e), Fe(users, $e), Fe(uuid, $e);
})(dist$2);
var socket$2 = {}, com = {}, cjs$3 = { exports: {} }, url$1 = {}, cjs$2 = {}, socket$1 = {}, transports = {}, polling = {}, transport = {}, cjs$1 = {}, encodePacket_browser = {}, commons = {};
Object.defineProperty(commons, "__esModule", { value: !0 });
commons.ERROR_PACKET = commons.PACKET_TYPES_REVERSE = commons.PACKET_TYPES = void 0;
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
commons.PACKET_TYPES = PACKET_TYPES;
PACKET_TYPES.open = "0";
PACKET_TYPES.close = "1";
PACKET_TYPES.ping = "2";
PACKET_TYPES.pong = "3";
PACKET_TYPES.message = "4";
PACKET_TYPES.upgrade = "5";
PACKET_TYPES.noop = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
commons.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
Object.keys(PACKET_TYPES).forEach(($e) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[$e]] = $e;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
commons.ERROR_PACKET = ERROR_PACKET;
Object.defineProperty(encodePacket_browser, "__esModule", { value: !0 });
encodePacket_browser.encodePacket = encodePacket_browser.encodePacketToBinary = void 0;
const commons_js_1$1 = commons, withNativeBlob$1 = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", withNativeArrayBuffer$2 = typeof ArrayBuffer == "function", isView$1 = ($e) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView($e) : $e && $e.buffer instanceof ArrayBuffer, encodePacket = ({ type: $e, data: Ze }, Fe, Ke) => withNativeBlob$1 && Ze instanceof Blob ? Fe ? Ke(Ze) : encodeBlobAsBase64(Ze, Ke) : withNativeArrayBuffer$2 && (Ze instanceof ArrayBuffer || isView$1(Ze)) ? Fe ? Ke(Ze) : encodeBlobAsBase64(new Blob([Ze]), Ke) : Ke(commons_js_1$1.PACKET_TYPES[$e] + (Ze || ""));
encodePacket_browser.encodePacket = encodePacket;
const encodeBlobAsBase64 = ($e, Ze) => {
  const Fe = new FileReader();
  return Fe.onload = function() {
    const Ke = Fe.result.split(",")[1];
    Ze("b" + (Ke || ""));
  }, Fe.readAsDataURL($e);
};
function toArray$2($e) {
  return $e instanceof Uint8Array ? $e : $e instanceof ArrayBuffer ? new Uint8Array($e) : new Uint8Array($e.buffer, $e.byteOffset, $e.byteLength);
}
let TEXT_ENCODER;
function encodePacketToBinary($e, Ze) {
  if (withNativeBlob$1 && $e.data instanceof Blob)
    return $e.data.arrayBuffer().then(toArray$2).then(Ze);
  if (withNativeArrayBuffer$2 && ($e.data instanceof ArrayBuffer || isView$1($e.data)))
    return Ze(toArray$2($e.data));
  encodePacket($e, !1, (Fe) => {
    TEXT_ENCODER || (TEXT_ENCODER = new TextEncoder()), Ze(TEXT_ENCODER.encode(Fe));
  });
}
encodePacket_browser.encodePacketToBinary = encodePacketToBinary;
var decodePacket_browser = {}, base64Arraybuffer = {};
Object.defineProperty(base64Arraybuffer, "__esModule", { value: !0 });
base64Arraybuffer.decode = base64Arraybuffer.encode = void 0;
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lookup = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let $e = 0; $e < chars.length; $e++)
  lookup[chars.charCodeAt($e)] = $e;
const encode$5 = ($e) => {
  let Ze = new Uint8Array($e), Fe, Ke = Ze.length, Ve = "";
  for (Fe = 0; Fe < Ke; Fe += 3)
    Ve += chars[Ze[Fe] >> 2], Ve += chars[(Ze[Fe] & 3) << 4 | Ze[Fe + 1] >> 4], Ve += chars[(Ze[Fe + 1] & 15) << 2 | Ze[Fe + 2] >> 6], Ve += chars[Ze[Fe + 2] & 63];
  return Ke % 3 === 2 ? Ve = Ve.substring(0, Ve.length - 1) + "=" : Ke % 3 === 1 && (Ve = Ve.substring(0, Ve.length - 2) + "=="), Ve;
};
base64Arraybuffer.encode = encode$5;
const decode$2 = ($e) => {
  let Ze = $e.length * 0.75, Fe = $e.length, Ke, Ve = 0, Je, Qe, at, ut;
  $e[$e.length - 1] === "=" && (Ze--, $e[$e.length - 2] === "=" && Ze--);
  const lt = new ArrayBuffer(Ze), dt = new Uint8Array(lt);
  for (Ke = 0; Ke < Fe; Ke += 4)
    Je = lookup[$e.charCodeAt(Ke)], Qe = lookup[$e.charCodeAt(Ke + 1)], at = lookup[$e.charCodeAt(Ke + 2)], ut = lookup[$e.charCodeAt(Ke + 3)], dt[Ve++] = Je << 2 | Qe >> 4, dt[Ve++] = (Qe & 15) << 4 | at >> 2, dt[Ve++] = (at & 3) << 6 | ut & 63;
  return lt;
};
base64Arraybuffer.decode = decode$2;
Object.defineProperty(decodePacket_browser, "__esModule", { value: !0 });
decodePacket_browser.decodePacket = void 0;
const commons_js_1 = commons, base64_arraybuffer_js_1 = base64Arraybuffer, withNativeArrayBuffer$1 = typeof ArrayBuffer == "function", decodePacket = ($e, Ze) => {
  if (typeof $e != "string")
    return {
      type: "message",
      data: mapBinary($e, Ze)
    };
  const Fe = $e.charAt(0);
  return Fe === "b" ? {
    type: "message",
    data: decodeBase64Packet($e.substring(1), Ze)
  } : commons_js_1.PACKET_TYPES_REVERSE[Fe] ? $e.length > 1 ? {
    type: commons_js_1.PACKET_TYPES_REVERSE[Fe],
    data: $e.substring(1)
  } : {
    type: commons_js_1.PACKET_TYPES_REVERSE[Fe]
  } : commons_js_1.ERROR_PACKET;
};
decodePacket_browser.decodePacket = decodePacket;
const decodeBase64Packet = ($e, Ze) => {
  if (withNativeArrayBuffer$1) {
    const Fe = (0, base64_arraybuffer_js_1.decode)($e);
    return mapBinary(Fe, Ze);
  } else
    return { base64: !0, data: $e };
}, mapBinary = ($e, Ze) => {
  switch (Ze) {
    case "blob":
      return $e instanceof Blob ? $e : new Blob([$e]);
    case "arraybuffer":
    default:
      return $e instanceof ArrayBuffer ? $e : $e.buffer;
  }
};
(function($e) {
  Object.defineProperty($e, "__esModule", { value: !0 }), $e.decodePayload = $e.decodePacket = $e.encodePayload = $e.encodePacket = $e.protocol = $e.createPacketDecoderStream = $e.createPacketEncoderStream = void 0;
  const Ze = encodePacket_browser;
  Object.defineProperty($e, "encodePacket", { enumerable: !0, get: function() {
    return Ze.encodePacket;
  } });
  const Fe = decodePacket_browser;
  Object.defineProperty($e, "decodePacket", { enumerable: !0, get: function() {
    return Fe.decodePacket;
  } });
  const Ke = commons, Ve = String.fromCharCode(30), Je = ($t, vt) => {
    const wt = $t.length, xt = new Array(wt);
    let Et = 0;
    $t.forEach((Tt, Rt) => {
      (0, Ze.encodePacket)(Tt, !1, (Ct) => {
        xt[Rt] = Ct, ++Et === wt && vt(xt.join(Ve));
      });
    });
  };
  $e.encodePayload = Je;
  const Qe = ($t, vt) => {
    const wt = $t.split(Ve), xt = [];
    for (let Et = 0; Et < wt.length; Et++) {
      const Tt = (0, Fe.decodePacket)(wt[Et], vt);
      if (xt.push(Tt), Tt.type === "error")
        break;
    }
    return xt;
  };
  $e.decodePayload = Qe;
  function at() {
    return new TransformStream({
      transform($t, vt) {
        (0, Ze.encodePacketToBinary)($t, (wt) => {
          const xt = wt.length;
          let Et;
          if (xt < 126)
            Et = new Uint8Array(1), new DataView(Et.buffer).setUint8(0, xt);
          else if (xt < 65536) {
            Et = new Uint8Array(3);
            const Tt = new DataView(Et.buffer);
            Tt.setUint8(0, 126), Tt.setUint16(1, xt);
          } else {
            Et = new Uint8Array(9);
            const Tt = new DataView(Et.buffer);
            Tt.setUint8(0, 127), Tt.setBigUint64(1, BigInt(xt));
          }
          $t.data && typeof $t.data != "string" && (Et[0] |= 128), vt.enqueue(Et), vt.enqueue(wt);
        });
      }
    });
  }
  $e.createPacketEncoderStream = at;
  let ut;
  function lt($t) {
    return $t.reduce((vt, wt) => vt + wt.length, 0);
  }
  function dt($t, vt) {
    if ($t[0].length === vt)
      return $t.shift();
    const wt = new Uint8Array(vt);
    let xt = 0;
    for (let Et = 0; Et < vt; Et++)
      wt[Et] = $t[0][xt++], xt === $t[0].length && ($t.shift(), xt = 0);
    return $t.length && xt < $t[0].length && ($t[0] = $t[0].slice(xt)), wt;
  }
  function bt($t, vt) {
    ut || (ut = new TextDecoder());
    const wt = [];
    let xt = 0, Et = -1, Tt = !1;
    return new TransformStream({
      transform(Rt, Ct) {
        for (wt.push(Rt); ; ) {
          if (xt === 0) {
            if (lt(wt) < 1)
              break;
            const Zt = dt(wt, 1);
            Tt = (Zt[0] & 128) === 128, Et = Zt[0] & 127, Et < 126 ? xt = 3 : Et === 126 ? xt = 1 : xt = 2;
          } else if (xt === 1) {
            if (lt(wt) < 2)
              break;
            const Zt = dt(wt, 2);
            Et = new DataView(Zt.buffer, Zt.byteOffset, Zt.length).getUint16(0), xt = 3;
          } else if (xt === 2) {
            if (lt(wt) < 8)
              break;
            const Zt = dt(wt, 8), Lt = new DataView(Zt.buffer, Zt.byteOffset, Zt.length), Ut = Lt.getUint32(0);
            if (Ut > Math.pow(2, 53 - 32) - 1) {
              Ct.enqueue(Ke.ERROR_PACKET);
              break;
            }
            Et = Ut * Math.pow(2, 32) + Lt.getUint32(4), xt = 3;
          } else {
            if (lt(wt) < Et)
              break;
            const Zt = dt(wt, Et);
            Ct.enqueue((0, Fe.decodePacket)(Tt ? Zt : ut.decode(Zt), vt)), xt = 0;
          }
          if (Et === 0 || Et > $t) {
            Ct.enqueue(Ke.ERROR_PACKET);
            break;
          }
        }
      }
    });
  }
  $e.createPacketDecoderStream = bt, $e.protocol = 4;
})(cjs$1);
function Emitter($e) {
  if ($e)
    return mixin($e);
}
function mixin($e) {
  for (var Ze in Emitter.prototype)
    $e[Ze] = Emitter.prototype[Ze];
  return $e;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function($e, Ze) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + $e] = this._callbacks["$" + $e] || []).push(Ze), this;
};
Emitter.prototype.once = function($e, Ze) {
  function Fe() {
    this.off($e, Fe), Ze.apply(this, arguments);
  }
  return Fe.fn = Ze, this.on($e, Fe), this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function($e, Ze) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var Fe = this._callbacks["$" + $e];
  if (!Fe)
    return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + $e], this;
  for (var Ke, Ve = 0; Ve < Fe.length; Ve++)
    if (Ke = Fe[Ve], Ke === Ze || Ke.fn === Ze) {
      Fe.splice(Ve, 1);
      break;
    }
  return Fe.length === 0 && delete this._callbacks["$" + $e], this;
};
Emitter.prototype.emit = function($e) {
  this._callbacks = this._callbacks || {};
  for (var Ze = new Array(arguments.length - 1), Fe = this._callbacks["$" + $e], Ke = 1; Ke < arguments.length; Ke++)
    Ze[Ke - 1] = arguments[Ke];
  if (Fe) {
    Fe = Fe.slice(0);
    for (var Ke = 0, Ve = Fe.length; Ke < Ve; ++Ke)
      Fe[Ke].apply(this, Ze);
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function($e) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + $e] || [];
};
Emitter.prototype.hasListeners = function($e) {
  return !!this.listeners($e).length;
};
const componentEmitter = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Emitter
}, Symbol.toStringTag, { value: "Module" })), require$$5 = /* @__PURE__ */ getAugmentedNamespace(componentEmitter);
var util$4 = {}, globalThis_browser = {};
Object.defineProperty(globalThis_browser, "__esModule", { value: !0 });
globalThis_browser.globalThisShim = void 0;
globalThis_browser.globalThisShim = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())();
Object.defineProperty(util$4, "__esModule", { value: !0 });
util$4.byteLength = util$4.installTimerFunctions = util$4.pick = void 0;
const globalThis_js_1$3 = globalThis_browser;
function pick($e, ...Ze) {
  return Ze.reduce((Fe, Ke) => ($e.hasOwnProperty(Ke) && (Fe[Ke] = $e[Ke]), Fe), {});
}
util$4.pick = pick;
const NATIVE_SET_TIMEOUT = globalThis_js_1$3.globalThisShim.setTimeout, NATIVE_CLEAR_TIMEOUT = globalThis_js_1$3.globalThisShim.clearTimeout;
function installTimerFunctions($e, Ze) {
  Ze.useNativeTimers ? ($e.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis_js_1$3.globalThisShim), $e.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis_js_1$3.globalThisShim)) : ($e.setTimeoutFn = globalThis_js_1$3.globalThisShim.setTimeout.bind(globalThis_js_1$3.globalThisShim), $e.clearTimeoutFn = globalThis_js_1$3.globalThisShim.clearTimeout.bind(globalThis_js_1$3.globalThisShim));
}
util$4.installTimerFunctions = installTimerFunctions;
const BASE64_OVERHEAD = 1.33;
function byteLength($e) {
  return typeof $e == "string" ? utf8Length($e) : Math.ceil(($e.byteLength || $e.size) * BASE64_OVERHEAD);
}
util$4.byteLength = byteLength;
function utf8Length($e) {
  let Ze = 0, Fe = 0;
  for (let Ke = 0, Ve = $e.length; Ke < Ve; Ke++)
    Ze = $e.charCodeAt(Ke), Ze < 128 ? Fe += 1 : Ze < 2048 ? Fe += 2 : Ze < 55296 || Ze >= 57344 ? Fe += 3 : (Ke++, Fe += 4);
  return Fe;
}
var browser = { exports: {} }, ms, hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var $e = 1e3, Ze = $e * 60, Fe = Ze * 60, Ke = Fe * 24, Ve = Ke * 7, Je = Ke * 365.25;
  ms = function(dt, bt) {
    bt = bt || {};
    var $t = typeof dt;
    if ($t === "string" && dt.length > 0)
      return Qe(dt);
    if ($t === "number" && isFinite(dt))
      return bt.long ? ut(dt) : at(dt);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(dt)
    );
  };
  function Qe(dt) {
    if (dt = String(dt), !(dt.length > 100)) {
      var bt = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        dt
      );
      if (bt) {
        var $t = parseFloat(bt[1]), vt = (bt[2] || "ms").toLowerCase();
        switch (vt) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return $t * Je;
          case "weeks":
          case "week":
          case "w":
            return $t * Ve;
          case "days":
          case "day":
          case "d":
            return $t * Ke;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return $t * Fe;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return $t * Ze;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return $t * $e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return $t;
          default:
            return;
        }
      }
    }
  }
  function at(dt) {
    var bt = Math.abs(dt);
    return bt >= Ke ? Math.round(dt / Ke) + "d" : bt >= Fe ? Math.round(dt / Fe) + "h" : bt >= Ze ? Math.round(dt / Ze) + "m" : bt >= $e ? Math.round(dt / $e) + "s" : dt + "ms";
  }
  function ut(dt) {
    var bt = Math.abs(dt);
    return bt >= Ke ? lt(dt, bt, Ke, "day") : bt >= Fe ? lt(dt, bt, Fe, "hour") : bt >= Ze ? lt(dt, bt, Ze, "minute") : bt >= $e ? lt(dt, bt, $e, "second") : dt + " ms";
  }
  function lt(dt, bt, $t, vt) {
    var wt = bt >= $t * 1.5;
    return Math.round(dt / $t) + " " + vt + (wt ? "s" : "");
  }
  return ms;
}
function setup($e) {
  Fe.debug = Fe, Fe.default = Fe, Fe.coerce = ut, Fe.disable = Je, Fe.enable = Ve, Fe.enabled = Qe, Fe.humanize = requireMs(), Fe.destroy = lt, Object.keys($e).forEach((dt) => {
    Fe[dt] = $e[dt];
  }), Fe.names = [], Fe.skips = [], Fe.formatters = {};
  function Ze(dt) {
    let bt = 0;
    for (let $t = 0; $t < dt.length; $t++)
      bt = (bt << 5) - bt + dt.charCodeAt($t), bt |= 0;
    return Fe.colors[Math.abs(bt) % Fe.colors.length];
  }
  Fe.selectColor = Ze;
  function Fe(dt) {
    let bt, $t = null, vt, wt;
    function xt(...Et) {
      if (!xt.enabled)
        return;
      const Tt = xt, Rt = Number(/* @__PURE__ */ new Date()), Ct = Rt - (bt || Rt);
      Tt.diff = Ct, Tt.prev = bt, Tt.curr = Rt, bt = Rt, Et[0] = Fe.coerce(Et[0]), typeof Et[0] != "string" && Et.unshift("%O");
      let Zt = 0;
      Et[0] = Et[0].replace(/%([a-zA-Z%])/g, (Ut, Pt) => {
        if (Ut === "%%")
          return "%";
        Zt++;
        const Ot = Fe.formatters[Pt];
        if (typeof Ot == "function") {
          const Ft = Et[Zt];
          Ut = Ot.call(Tt, Ft), Et.splice(Zt, 1), Zt--;
        }
        return Ut;
      }), Fe.formatArgs.call(Tt, Et), (Tt.log || Fe.log).apply(Tt, Et);
    }
    return xt.namespace = dt, xt.useColors = Fe.useColors(), xt.color = Fe.selectColor(dt), xt.extend = Ke, xt.destroy = Fe.destroy, Object.defineProperty(xt, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => $t !== null ? $t : (vt !== Fe.namespaces && (vt = Fe.namespaces, wt = Fe.enabled(dt)), wt),
      set: (Et) => {
        $t = Et;
      }
    }), typeof Fe.init == "function" && Fe.init(xt), xt;
  }
  function Ke(dt, bt) {
    const $t = Fe(this.namespace + (typeof bt > "u" ? ":" : bt) + dt);
    return $t.log = this.log, $t;
  }
  function Ve(dt) {
    Fe.save(dt), Fe.namespaces = dt, Fe.names = [], Fe.skips = [];
    let bt;
    const $t = (typeof dt == "string" ? dt : "").split(/[\s,]+/), vt = $t.length;
    for (bt = 0; bt < vt; bt++)
      $t[bt] && (dt = $t[bt].replace(/\*/g, ".*?"), dt[0] === "-" ? Fe.skips.push(new RegExp("^" + dt.slice(1) + "$")) : Fe.names.push(new RegExp("^" + dt + "$")));
  }
  function Je() {
    const dt = [
      ...Fe.names.map(at),
      ...Fe.skips.map(at).map((bt) => "-" + bt)
    ].join(",");
    return Fe.enable(""), dt;
  }
  function Qe(dt) {
    if (dt[dt.length - 1] === "*")
      return !0;
    let bt, $t;
    for (bt = 0, $t = Fe.skips.length; bt < $t; bt++)
      if (Fe.skips[bt].test(dt))
        return !1;
    for (bt = 0, $t = Fe.names.length; bt < $t; bt++)
      if (Fe.names[bt].test(dt))
        return !0;
    return !1;
  }
  function at(dt) {
    return dt.toString().substring(2, dt.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function ut(dt) {
    return dt instanceof Error ? dt.stack || dt.message : dt;
  }
  function lt() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return Fe.enable(Fe.load()), Fe;
}
var common = setup;
(function($e, Ze) {
  Ze.formatArgs = Ke, Ze.save = Ve, Ze.load = Je, Ze.useColors = Fe, Ze.storage = Qe(), Ze.destroy = (() => {
    let ut = !1;
    return () => {
      ut || (ut = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), Ze.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function Fe() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function Ke(ut) {
    if (ut[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + ut[0] + (this.useColors ? "%c " : " ") + "+" + $e.exports.humanize(this.diff), !this.useColors)
      return;
    const lt = "color: " + this.color;
    ut.splice(1, 0, lt, "color: inherit");
    let dt = 0, bt = 0;
    ut[0].replace(/%[a-zA-Z%]/g, ($t) => {
      $t !== "%%" && (dt++, $t === "%c" && (bt = dt));
    }), ut.splice(bt, 0, lt);
  }
  Ze.log = console.debug || console.log || (() => {
  });
  function Ve(ut) {
    try {
      ut ? Ze.storage.setItem("debug", ut) : Ze.storage.removeItem("debug");
    } catch {
    }
  }
  function Je() {
    let ut;
    try {
      ut = Ze.storage.getItem("debug");
    } catch {
    }
    return !ut && typeof process < "u" && "env" in process && (ut = process.env.DEBUG), ut;
  }
  function Qe() {
    try {
      return localStorage;
    } catch {
    }
  }
  $e.exports = common(Ze);
  const { formatters: at } = $e.exports;
  at.j = function(ut) {
    try {
      return JSON.stringify(ut);
    } catch (lt) {
      return "[UnexpectedJSONParseError]: " + lt.message;
    }
  };
})(browser, browser.exports);
var browserExports = browser.exports, parseqs = {};
Object.defineProperty(parseqs, "__esModule", { value: !0 });
parseqs.decode = parseqs.encode = void 0;
function encode$4($e) {
  let Ze = "";
  for (let Fe in $e)
    $e.hasOwnProperty(Fe) && (Ze.length && (Ze += "&"), Ze += encodeURIComponent(Fe) + "=" + encodeURIComponent($e[Fe]));
  return Ze;
}
parseqs.encode = encode$4;
function decode$1($e) {
  let Ze = {}, Fe = $e.split("&");
  for (let Ke = 0, Ve = Fe.length; Ke < Ve; Ke++) {
    let Je = Fe[Ke].split("=");
    Ze[decodeURIComponent(Je[0])] = decodeURIComponent(Je[1]);
  }
  return Ze;
}
parseqs.decode = decode$1;
var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function($e) {
  return $e && $e.__esModule ? $e : { default: $e };
};
Object.defineProperty(transport, "__esModule", { value: !0 });
transport.Transport = void 0;
const engine_io_parser_1$4 = cjs$1, component_emitter_1$4 = require$$5, util_js_1$3 = util$4, debug_1$7 = __importDefault$8(browserExports), parseqs_js_1$1 = parseqs, debug$7 = (0, debug_1$7.default)("engine.io-client:transport");
class TransportError extends Error {
  constructor(Ze, Fe, Ke) {
    super(Ze), this.description = Fe, this.context = Ke, this.type = "TransportError";
  }
}
class Transport extends component_emitter_1$4.Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(Ze) {
    super(), this.writable = !1, (0, util_js_1$3.installTimerFunctions)(this, Ze), this.opts = Ze, this.query = Ze.query, this.socket = Ze.socket;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(Ze, Fe, Ke) {
    return super.emitReserved("error", new TransportError(Ze, Fe, Ke)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(Ze) {
    this.readyState === "open" ? this.write(Ze) : debug$7("transport is not open, discarding packets");
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(Ze) {
    const Fe = (0, engine_io_parser_1$4.decodePacket)(Ze, this.socket.binaryType);
    this.onPacket(Fe);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(Ze) {
    super.emitReserved("packet", Ze);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(Ze) {
    this.readyState = "closed", super.emitReserved("close", Ze);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(Ze) {
  }
  createUri(Ze, Fe = {}) {
    return Ze + "://" + this._hostname() + this._port() + this.opts.path + this._query(Fe);
  }
  _hostname() {
    const Ze = this.opts.hostname;
    return Ze.indexOf(":") === -1 ? Ze : "[" + Ze + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(Ze) {
    const Fe = (0, parseqs_js_1$1.encode)(Ze);
    return Fe.length ? "?" + Fe : "";
  }
}
transport.Transport = Transport;
var yeast$1 = {};
Object.defineProperty(yeast$1, "__esModule", { value: !0 });
yeast$1.yeast = yeast$1.decode = yeast$1.encode = void 0;
const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map = {};
let seed = 0, i$g = 0, prev;
function encode$3($e) {
  let Ze = "";
  do
    Ze = alphabet[$e % length] + Ze, $e = Math.floor($e / length);
  while ($e > 0);
  return Ze;
}
yeast$1.encode = encode$3;
function decode($e) {
  let Ze = 0;
  for (i$g = 0; i$g < $e.length; i$g++)
    Ze = Ze * length + map[$e.charAt(i$g)];
  return Ze;
}
yeast$1.decode = decode;
function yeast() {
  const $e = encode$3(+/* @__PURE__ */ new Date());
  return $e !== prev ? (seed = 0, prev = $e) : $e + "." + encode$3(seed++);
}
yeast$1.yeast = yeast;
for (; i$g < length; i$g++)
  map[alphabet[i$g]] = i$g;
var xmlhttprequest_browser = {}, hasCors = {};
Object.defineProperty(hasCors, "__esModule", { value: !0 });
hasCors.hasCORS = void 0;
let value = !1;
try {
  value = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
hasCors.hasCORS = value;
Object.defineProperty(xmlhttprequest_browser, "__esModule", { value: !0 });
xmlhttprequest_browser.createCookieJar = xmlhttprequest_browser.XHR = void 0;
const has_cors_js_1 = hasCors, globalThis_js_1$2 = globalThis_browser;
function XHR($e) {
  const Ze = $e.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!Ze || has_cors_js_1.hasCORS))
      return new XMLHttpRequest();
  } catch {
  }
  if (!Ze)
    try {
      return new globalThis_js_1$2.globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
xmlhttprequest_browser.XHR = XHR;
function createCookieJar() {
}
xmlhttprequest_browser.createCookieJar = createCookieJar;
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function($e) {
  return $e && $e.__esModule ? $e : { default: $e };
};
Object.defineProperty(polling, "__esModule", { value: !0 });
polling.Request = polling.Polling = void 0;
const transport_js_1$2 = transport, debug_1$6 = __importDefault$7(browserExports), yeast_js_1$1 = yeast$1, engine_io_parser_1$3 = cjs$1, xmlhttprequest_js_1 = xmlhttprequest_browser, component_emitter_1$3 = require$$5, util_js_1$2 = util$4, globalThis_js_1$1 = globalThis_browser, debug$6 = (0, debug_1$6.default)("engine.io-client:polling");
function empty() {
}
const hasXHR2 = function() {
  return new xmlhttprequest_js_1.XHR({
    xdomain: !1
  }).responseType != null;
}();
class Polling extends transport_js_1$2.Transport {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(Ze) {
    if (super(Ze), this.polling = !1, typeof location < "u") {
      const Ke = location.protocol === "https:";
      let Ve = location.port;
      Ve || (Ve = Ke ? "443" : "80"), this.xd = typeof location < "u" && Ze.hostname !== location.hostname || Ve !== Ze.port;
    }
    const Fe = Ze && Ze.forceBase64;
    this.supportsBinary = hasXHR2 && !Fe, this.opts.withCredentials && (this.cookieJar = (0, xmlhttprequest_js_1.createCookieJar)());
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this.poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(Ze) {
    this.readyState = "pausing";
    const Fe = () => {
      debug$6("paused"), this.readyState = "paused", Ze();
    };
    if (this.polling || !this.writable) {
      let Ke = 0;
      this.polling && (debug$6("we are currently polling - waiting to pause"), Ke++, this.once("pollComplete", function() {
        debug$6("pre-pause polling complete"), --Ke || Fe();
      })), this.writable || (debug$6("we are currently writing - waiting to pause"), Ke++, this.once("drain", function() {
        debug$6("pre-pause writing complete"), --Ke || Fe();
      }));
    } else
      Fe();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  poll() {
    debug$6("polling"), this.polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(Ze) {
    debug$6("polling got data %s", Ze);
    const Fe = (Ke) => {
      if (this.readyState === "opening" && Ke.type === "open" && this.onOpen(), Ke.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(Ke);
    };
    (0, engine_io_parser_1$3.decodePayload)(Ze, this.socket.binaryType).forEach(Fe), this.readyState !== "closed" && (this.polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" ? this.poll() : debug$6('ignoring poll - transport state "%s"', this.readyState));
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const Ze = () => {
      debug$6("writing close packet"), this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? (debug$6("transport open - closing"), Ze()) : (debug$6("transport not open - deferring close"), this.once("open", Ze));
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(Ze) {
    this.writable = !1, (0, engine_io_parser_1$3.encodePayload)(Ze, (Fe) => {
      this.doWrite(Fe, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const Ze = this.opts.secure ? "https" : "http", Fe = this.query || {};
    return this.opts.timestampRequests !== !1 && (Fe[this.opts.timestampParam] = (0, yeast_js_1$1.yeast)()), !this.supportsBinary && !Fe.sid && (Fe.b64 = 1), this.createUri(Ze, Fe);
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @private
   */
  request(Ze = {}) {
    return Object.assign(Ze, { xd: this.xd, cookieJar: this.cookieJar }, this.opts), new Request(this.uri(), Ze);
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(Ze, Fe) {
    const Ke = this.request({
      method: "POST",
      data: Ze
    });
    Ke.on("success", Fe), Ke.on("error", (Ve, Je) => {
      this.onError("xhr post error", Ve, Je);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    debug$6("xhr poll");
    const Ze = this.request();
    Ze.on("data", this.onData.bind(this)), Ze.on("error", (Fe, Ke) => {
      this.onError("xhr poll error", Fe, Ke);
    }), this.pollXhr = Ze;
  }
}
polling.Polling = Polling;
class Request extends component_emitter_1$3.Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(Ze, Fe) {
    super(), (0, util_js_1$2.installTimerFunctions)(this, Fe), this.opts = Fe, this.method = Fe.method || "GET", this.uri = Ze, this.data = Fe.data !== void 0 ? Fe.data : null, this.create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  create() {
    var Ze;
    const Fe = (0, util_js_1$2.pick)(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    Fe.xdomain = !!this.opts.xd;
    const Ke = this.xhr = new xmlhttprequest_js_1.XHR(Fe);
    try {
      debug$6("xhr open %s: %s", this.method, this.uri), Ke.open(this.method, this.uri, !0);
      try {
        if (this.opts.extraHeaders) {
          Ke.setDisableHeaderCheck && Ke.setDisableHeaderCheck(!0);
          for (let Ve in this.opts.extraHeaders)
            this.opts.extraHeaders.hasOwnProperty(Ve) && Ke.setRequestHeader(Ve, this.opts.extraHeaders[Ve]);
        }
      } catch {
      }
      if (this.method === "POST")
        try {
          Ke.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        Ke.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (Ze = this.opts.cookieJar) === null || Ze === void 0 || Ze.addCookies(Ke), "withCredentials" in Ke && (Ke.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (Ke.timeout = this.opts.requestTimeout), Ke.onreadystatechange = () => {
        var Ve;
        Ke.readyState === 3 && ((Ve = this.opts.cookieJar) === null || Ve === void 0 || Ve.parseCookies(Ke)), Ke.readyState === 4 && (Ke.status === 200 || Ke.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {
          this.onError(typeof Ke.status == "number" ? Ke.status : 0);
        }, 0));
      }, debug$6("xhr data %s", this.data), Ke.send(this.data);
    } catch (Ve) {
      this.setTimeoutFn(() => {
        this.onError(Ve);
      }, 0);
      return;
    }
    typeof document < "u" && (this.index = Request.requestsCount++, Request.requests[this.index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  onError(Ze) {
    this.emitReserved("error", Ze, this.xhr), this.cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  cleanup(Ze) {
    if (!(typeof this.xhr > "u" || this.xhr === null)) {
      if (this.xhr.onreadystatechange = empty, Ze)
        try {
          this.xhr.abort();
        } catch {
        }
      typeof document < "u" && delete Request.requests[this.index], this.xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  onLoad() {
    const Ze = this.xhr.responseText;
    Ze !== null && (this.emitReserved("data", Ze), this.emitReserved("success"), this.cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this.cleanup();
  }
}
polling.Request = Request;
Request.requestsCount = 0;
Request.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", unloadHandler);
  else if (typeof addEventListener == "function") {
    const $e = "onpagehide" in globalThis_js_1$1.globalThisShim ? "pagehide" : "unload";
    addEventListener($e, unloadHandler, !1);
  }
}
function unloadHandler() {
  for (let $e in Request.requests)
    Request.requests.hasOwnProperty($e) && Request.requests[$e].abort();
}
var websocket = {}, websocketConstructor_browser = {};
Object.defineProperty(websocketConstructor_browser, "__esModule", { value: !0 });
websocketConstructor_browser.defaultBinaryType = websocketConstructor_browser.usingBrowserWebSocket = websocketConstructor_browser.WebSocket = websocketConstructor_browser.nextTick = void 0;
const globalThis_js_1 = globalThis_browser;
websocketConstructor_browser.nextTick = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? (Ze) => Promise.resolve().then(Ze) : (Ze, Fe) => Fe(Ze, 0))();
websocketConstructor_browser.WebSocket = globalThis_js_1.globalThisShim.WebSocket || globalThis_js_1.globalThisShim.MozWebSocket;
websocketConstructor_browser.usingBrowserWebSocket = !0;
websocketConstructor_browser.defaultBinaryType = "arraybuffer";
var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function($e) {
  return $e && $e.__esModule ? $e : { default: $e };
};
Object.defineProperty(websocket, "__esModule", { value: !0 });
websocket.WS = void 0;
const transport_js_1$1 = transport, yeast_js_1 = yeast$1, util_js_1$1 = util$4, websocket_constructor_js_1$2 = websocketConstructor_browser, debug_1$5 = __importDefault$6(browserExports), engine_io_parser_1$2 = cjs$1, debug$5 = (0, debug_1$5.default)("engine.io-client:websocket"), isReactNative = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class WS extends transport_js_1$1.Transport {
  /**
   * WebSocket transport constructor.
   *
   * @param {Object} opts - connection options
   * @protected
   */
  constructor(Ze) {
    super(Ze), this.supportsBinary = !Ze.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check())
      return;
    const Ze = this.uri(), Fe = this.opts.protocols, Ke = isReactNative ? {} : (0, util_js_1$1.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (Ke.headers = this.opts.extraHeaders);
    try {
      this.ws = websocket_constructor_js_1$2.usingBrowserWebSocket && !isReactNative ? Fe ? new websocket_constructor_js_1$2.WebSocket(Ze, Fe) : new websocket_constructor_js_1$2.WebSocket(Ze) : new websocket_constructor_js_1$2.WebSocket(Ze, Fe, Ke);
    } catch (Ve) {
      return this.emitReserved("error", Ve);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (Ze) => this.onClose({
      description: "websocket connection closed",
      context: Ze
    }), this.ws.onmessage = (Ze) => this.onData(Ze.data), this.ws.onerror = (Ze) => this.onError("websocket error", Ze);
  }
  write(Ze) {
    this.writable = !1;
    for (let Fe = 0; Fe < Ze.length; Fe++) {
      const Ke = Ze[Fe], Ve = Fe === Ze.length - 1;
      (0, engine_io_parser_1$2.encodePacket)(Ke, this.supportsBinary, (Je) => {
        const Qe = {};
        websocket_constructor_js_1$2.usingBrowserWebSocket || (Ke.options && (Qe.compress = Ke.options.compress), this.opts.perMessageDeflate && // @ts-ignore
        (typeof Je == "string" ? Buffer.byteLength(Je) : Je.length) < this.opts.perMessageDeflate.threshold && (Qe.compress = !1));
        try {
          websocket_constructor_js_1$2.usingBrowserWebSocket ? this.ws.send(Je) : this.ws.send(Je, Qe);
        } catch {
          debug$5("websocket closed before onclose event");
        }
        Ve && (0, websocket_constructor_js_1$2.nextTick)(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const Ze = this.opts.secure ? "wss" : "ws", Fe = this.query || {};
    return this.opts.timestampRequests && (Fe[this.opts.timestampParam] = (0, yeast_js_1.yeast)()), this.supportsBinary || (Fe.b64 = 1), this.createUri(Ze, Fe);
  }
  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @private
   */
  check() {
    return !!websocket_constructor_js_1$2.WebSocket;
  }
}
websocket.WS = WS;
var webtransport = {}, __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function($e) {
  return $e && $e.__esModule ? $e : { default: $e };
};
Object.defineProperty(webtransport, "__esModule", { value: !0 });
webtransport.WT = void 0;
const transport_js_1 = transport, websocket_constructor_js_1$1 = websocketConstructor_browser, engine_io_parser_1$1 = cjs$1, debug_1$4 = __importDefault$5(browserExports), debug$4 = (0, debug_1$4.default)("engine.io-client:webtransport");
class WT extends transport_js_1.Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    typeof WebTransport == "function" && (this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]), this.transport.closed.then(() => {
      debug$4("transport closed gracefully"), this.onClose();
    }).catch((Ze) => {
      debug$4("transport closed due to %s", Ze), this.onError("webtransport error", Ze);
    }), this.transport.ready.then(() => {
      this.transport.createBidirectionalStream().then((Ze) => {
        const Fe = (0, engine_io_parser_1$1.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, this.socket.binaryType), Ke = Ze.readable.pipeThrough(Fe).getReader(), Ve = (0, engine_io_parser_1$1.createPacketEncoderStream)();
        Ve.readable.pipeTo(Ze.writable), this.writer = Ve.writable.getWriter();
        const Je = () => {
          Ke.read().then(({ done: at, value: ut }) => {
            if (at) {
              debug$4("session is closed");
              return;
            }
            debug$4("received chunk: %o", ut), this.onPacket(ut), Je();
          }).catch((at) => {
            debug$4("an error occurred while reading: %s", at);
          });
        };
        Je();
        const Qe = { type: "open" };
        this.query.sid && (Qe.data = `{"sid":"${this.query.sid}"}`), this.writer.write(Qe).then(() => this.onOpen());
      });
    }));
  }
  write(Ze) {
    this.writable = !1;
    for (let Fe = 0; Fe < Ze.length; Fe++) {
      const Ke = Ze[Fe], Ve = Fe === Ze.length - 1;
      this.writer.write(Ke).then(() => {
        Ve && (0, websocket_constructor_js_1$1.nextTick)(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var Ze;
    (Ze = this.transport) === null || Ze === void 0 || Ze.close();
  }
}
webtransport.WT = WT;
Object.defineProperty(transports, "__esModule", { value: !0 });
transports.transports = void 0;
const polling_js_1 = polling, websocket_js_1 = websocket, webtransport_js_1 = webtransport;
transports.transports = {
  websocket: websocket_js_1.WS,
  webtransport: webtransport_js_1.WT,
  polling: polling_js_1.Polling
};
var parseuri = {};
Object.defineProperty(parseuri, "__esModule", { value: !0 });
parseuri.parse = void 0;
const re$3 = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse$5($e) {
  const Ze = $e, Fe = $e.indexOf("["), Ke = $e.indexOf("]");
  Fe != -1 && Ke != -1 && ($e = $e.substring(0, Fe) + $e.substring(Fe, Ke).replace(/:/g, ";") + $e.substring(Ke, $e.length));
  let Ve = re$3.exec($e || ""), Je = {}, Qe = 14;
  for (; Qe--; )
    Je[parts[Qe]] = Ve[Qe] || "";
  return Fe != -1 && Ke != -1 && (Je.source = Ze, Je.host = Je.host.substring(1, Je.host.length - 1).replace(/;/g, ":"), Je.authority = Je.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), Je.ipv6uri = !0), Je.pathNames = pathNames(Je, Je.path), Je.queryKey = queryKey(Je, Je.query), Je;
}
parseuri.parse = parse$5;
function pathNames($e, Ze) {
  const Fe = /\/{2,9}/g, Ke = Ze.replace(Fe, "/").split("/");
  return (Ze.slice(0, 1) == "/" || Ze.length === 0) && Ke.splice(0, 1), Ze.slice(-1) == "/" && Ke.splice(Ke.length - 1, 1), Ke;
}
function queryKey($e, Ze) {
  const Fe = {};
  return Ze.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(Ke, Ve, Je) {
    Ve && (Fe[Ve] = Je);
  }), Fe;
}
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function($e) {
  return $e && $e.__esModule ? $e : { default: $e };
};
Object.defineProperty(socket$1, "__esModule", { value: !0 });
socket$1.Socket = void 0;
const index_js_1 = transports, util_js_1 = util$4, parseqs_js_1 = parseqs, parseuri_js_1 = parseuri, debug_1$3 = __importDefault$4(browserExports), component_emitter_1$2 = require$$5, engine_io_parser_1 = cjs$1, websocket_constructor_js_1 = websocketConstructor_browser, debug$3 = (0, debug_1$3.default)("engine.io-client:socket");
let Socket$1 = class gn extends component_emitter_1$2.Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(Ze, Fe = {}) {
    super(), this.binaryType = websocket_constructor_js_1.defaultBinaryType, this.writeBuffer = [], Ze && typeof Ze == "object" && (Fe = Ze, Ze = null), Ze ? (Ze = (0, parseuri_js_1.parse)(Ze), Fe.hostname = Ze.host, Fe.secure = Ze.protocol === "https" || Ze.protocol === "wss", Fe.port = Ze.port, Ze.query && (Fe.query = Ze.query)) : Fe.host && (Fe.hostname = (0, parseuri_js_1.parse)(Fe.host).host), (0, util_js_1.installTimerFunctions)(this, Fe), this.secure = Fe.secure != null ? Fe.secure : typeof location < "u" && location.protocol === "https:", Fe.hostname && !Fe.port && (Fe.port = this.secure ? "443" : "80"), this.hostname = Fe.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = Fe.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = Fe.transports || [
      "polling",
      "websocket",
      "webtransport"
    ], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, Fe), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = (0, parseqs_js_1.decode)(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this.beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this.offlineEventListener = () => {
      this.onClose("transport close", {
        description: "network connection lost"
      });
    }, addEventListener("offline", this.offlineEventListener, !1))), this.open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(Ze) {
    debug$3('creating transport "%s"', Ze);
    const Fe = Object.assign({}, this.opts.query);
    Fe.EIO = engine_io_parser_1.protocol, Fe.transport = Ze, this.id && (Fe.sid = this.id);
    const Ke = Object.assign({}, this.opts, {
      query: Fe,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[Ze]);
    return debug$3("options: %j", Ke), new index_js_1.transports[Ze](Ke);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  open() {
    let Ze;
    if (this.opts.rememberUpgrade && gn.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
      Ze = "websocket";
    else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else
      Ze = this.transports[0];
    this.readyState = "opening";
    try {
      Ze = this.createTransport(Ze);
    } catch (Fe) {
      debug$3("error while creating transport: %s", Fe), this.transports.shift(), this.open();
      return;
    }
    Ze.open(), this.setTransport(Ze);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(Ze) {
    debug$3("setting transport %s", Ze.name), this.transport && (debug$3("clearing existing transport %s", this.transport.name), this.transport.removeAllListeners()), this.transport = Ze, Ze.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (Fe) => this.onClose("transport close", Fe));
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  probe(Ze) {
    debug$3('probing transport "%s"', Ze);
    let Fe = this.createTransport(Ze), Ke = !1;
    gn.priorWebsocketSuccess = !1;
    const Ve = () => {
      Ke || (debug$3('probe transport "%s" opened', Ze), Fe.send([{ type: "ping", data: "probe" }]), Fe.once("packet", (bt) => {
        if (!Ke)
          if (bt.type === "pong" && bt.data === "probe") {
            if (debug$3('probe transport "%s" pong', Ze), this.upgrading = !0, this.emitReserved("upgrading", Fe), !Fe)
              return;
            gn.priorWebsocketSuccess = Fe.name === "websocket", debug$3('pausing current transport "%s"', this.transport.name), this.transport.pause(() => {
              Ke || this.readyState !== "closed" && (debug$3("changing transport and sending upgrade packet"), dt(), this.setTransport(Fe), Fe.send([{ type: "upgrade" }]), this.emitReserved("upgrade", Fe), Fe = null, this.upgrading = !1, this.flush());
            });
          } else {
            debug$3('probe transport "%s" failed', Ze);
            const $t = new Error("probe error");
            $t.transport = Fe.name, this.emitReserved("upgradeError", $t);
          }
      }));
    };
    function Je() {
      Ke || (Ke = !0, dt(), Fe.close(), Fe = null);
    }
    const Qe = (bt) => {
      const $t = new Error("probe error: " + bt);
      $t.transport = Fe.name, Je(), debug$3('probe transport "%s" failed because of error: %s', Ze, bt), this.emitReserved("upgradeError", $t);
    };
    function at() {
      Qe("transport closed");
    }
    function ut() {
      Qe("socket closed");
    }
    function lt(bt) {
      Fe && bt.name !== Fe.name && (debug$3('"%s" works - aborting "%s"', bt.name, Fe.name), Je());
    }
    const dt = () => {
      Fe.removeListener("open", Ve), Fe.removeListener("error", Qe), Fe.removeListener("close", at), this.off("close", ut), this.off("upgrading", lt);
    };
    Fe.once("open", Ve), Fe.once("error", Qe), Fe.once("close", at), this.once("close", ut), this.once("upgrading", lt), this.upgrades.indexOf("webtransport") !== -1 && Ze !== "webtransport" ? this.setTimeoutFn(() => {
      Ke || Fe.open();
    }, 200) : Fe.open();
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    if (debug$3("socket open"), this.readyState = "open", gn.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade) {
      debug$3("starting upgrade probes");
      let Ze = 0;
      const Fe = this.upgrades.length;
      for (; Ze < Fe; Ze++)
        this.probe(this.upgrades[Ze]);
    }
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  onPacket(Ze) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (debug$3('socket receive: type "%s", data "%s"', Ze.type, Ze.data), this.emitReserved("packet", Ze), this.emitReserved("heartbeat"), this.resetPingTimeout(), Ze.type) {
        case "open":
          this.onHandshake(JSON.parse(Ze.data));
          break;
        case "ping":
          this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
          break;
        case "error":
          const Fe = new Error("server error");
          Fe.code = Ze.data, this.onError(Fe);
          break;
        case "message":
          this.emitReserved("data", Ze.data), this.emitReserved("message", Ze.data);
          break;
      }
    else
      debug$3('packet received with socket readyState "%s"', this.readyState);
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(Ze) {
    this.emitReserved("handshake", Ze), this.id = Ze.sid, this.transport.query.sid = Ze.sid, this.upgrades = this.filterUpgrades(Ze.upgrades), this.pingInterval = Ze.pingInterval, this.pingTimeout = Ze.pingTimeout, this.maxPayload = Ze.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const Ze = this.getWritablePackets();
      debug$3("flushing %d packets in socket", Ze.length), this.transport.send(Ze), this.prevBufferLen = Ze.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  getWritablePackets() {
    if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let Fe = 1;
    for (let Ke = 0; Ke < this.writeBuffer.length; Ke++) {
      const Ve = this.writeBuffer[Ke].data;
      if (Ve && (Fe += (0, util_js_1.byteLength)(Ve)), Ke > 0 && Fe > this.maxPayload)
        return debug$3("only send %d out of %d packets", Ke, this.writeBuffer.length), this.writeBuffer.slice(0, Ke);
      Fe += 2;
    }
    return debug$3("payload size is %d (max: %d)", Fe, this.maxPayload), this.writeBuffer;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} callback function.
   * @return {Socket} for chaining.
   */
  write(Ze, Fe, Ke) {
    return this.sendPacket("message", Ze, Fe, Ke), this;
  }
  send(Ze, Fe, Ke) {
    return this.sendPacket("message", Ze, Fe, Ke), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  sendPacket(Ze, Fe, Ke, Ve) {
    if (typeof Fe == "function" && (Ve = Fe, Fe = void 0), typeof Ke == "function" && (Ve = Ke, Ke = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    Ke = Ke || {}, Ke.compress = Ke.compress !== !1;
    const Je = {
      type: Ze,
      data: Fe,
      options: Ke
    };
    this.emitReserved("packetCreate", Je), this.writeBuffer.push(Je), Ve && this.once("flush", Ve), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const Ze = () => {
      this.onClose("forced close"), debug$3("socket closing - telling transport to close"), this.transport.close();
    }, Fe = () => {
      this.off("upgrade", Fe), this.off("upgradeError", Fe), Ze();
    }, Ke = () => {
      this.once("upgrade", Fe), this.once("upgradeError", Fe);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? Ke() : Ze();
    }) : this.upgrading ? Ke() : Ze()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  onError(Ze) {
    debug$3("socket error %j", Ze), gn.priorWebsocketSuccess = !1, this.emitReserved("error", Ze), this.onClose("transport error", Ze);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  onClose(Ze, Fe) {
    (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (debug$3('socket close with reason: "%s"', Ze), this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1), removeEventListener("offline", this.offlineEventListener, !1)), this.readyState = "closed", this.id = null, this.emitReserved("close", Ze, Fe), this.writeBuffer = [], this.prevBufferLen = 0);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  filterUpgrades(Ze) {
    const Fe = [];
    let Ke = 0;
    const Ve = Ze.length;
    for (; Ke < Ve; Ke++)
      ~this.transports.indexOf(Ze[Ke]) && Fe.push(Ze[Ke]);
    return Fe;
  }
};
socket$1.Socket = Socket$1;
Socket$1.protocol = engine_io_parser_1.protocol;
(function($e) {
  Object.defineProperty($e, "__esModule", { value: !0 }), $e.nextTick = $e.parse = $e.installTimerFunctions = $e.transports = $e.Transport = $e.protocol = $e.Socket = void 0;
  const Ze = socket$1;
  Object.defineProperty($e, "Socket", { enumerable: !0, get: function() {
    return Ze.Socket;
  } }), $e.protocol = Ze.Socket.protocol;
  var Fe = transport;
  Object.defineProperty($e, "Transport", { enumerable: !0, get: function() {
    return Fe.Transport;
  } });
  var Ke = transports;
  Object.defineProperty($e, "transports", { enumerable: !0, get: function() {
    return Ke.transports;
  } });
  var Ve = util$4;
  Object.defineProperty($e, "installTimerFunctions", { enumerable: !0, get: function() {
    return Ve.installTimerFunctions;
  } });
  var Je = parseuri;
  Object.defineProperty($e, "parse", { enumerable: !0, get: function() {
    return Je.parse;
  } });
  var Qe = websocketConstructor_browser;
  Object.defineProperty($e, "nextTick", { enumerable: !0, get: function() {
    return Qe.nextTick;
  } });
})(cjs$2);
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function($e) {
  return $e && $e.__esModule ? $e : { default: $e };
};
Object.defineProperty(url$1, "__esModule", { value: !0 });
url$1.url = void 0;
const engine_io_client_1$1 = cjs$2, debug_1$2 = __importDefault$3(browserExports), debug$2 = debug_1$2.default("socket.io-client:url");
function url($e, Ze = "", Fe) {
  let Ke = $e;
  Fe = Fe || typeof location < "u" && location, $e == null && ($e = Fe.protocol + "//" + Fe.host), typeof $e == "string" && ($e.charAt(0) === "/" && ($e.charAt(1) === "/" ? $e = Fe.protocol + $e : $e = Fe.host + $e), /^(https?|wss?):\/\//.test($e) || (debug$2("protocol-less url %s", $e), typeof Fe < "u" ? $e = Fe.protocol + "//" + $e : $e = "https://" + $e), debug$2("parse %s", $e), Ke = engine_io_client_1$1.parse($e)), Ke.port || (/^(http|ws)$/.test(Ke.protocol) ? Ke.port = "80" : /^(http|ws)s$/.test(Ke.protocol) && (Ke.port = "443")), Ke.path = Ke.path || "/";
  const Je = Ke.host.indexOf(":") !== -1 ? "[" + Ke.host + "]" : Ke.host;
  return Ke.id = Ke.protocol + "://" + Je + ":" + Ke.port + Ze, Ke.href = Ke.protocol + "://" + Je + (Fe && Fe.port === Ke.port ? "" : ":" + Ke.port), Ke;
}
url$1.url = url;
var manager = {}, socket = {}, cjs = {}, binary = {}, isBinary$1 = {};
Object.defineProperty(isBinary$1, "__esModule", { value: !0 });
isBinary$1.hasBinary = isBinary$1.isBinary = void 0;
const withNativeArrayBuffer = typeof ArrayBuffer == "function", isView = ($e) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView($e) : $e.buffer instanceof ArrayBuffer, toString$3 = Object.prototype.toString, withNativeBlob = typeof Blob == "function" || typeof Blob < "u" && toString$3.call(Blob) === "[object BlobConstructor]", withNativeFile = typeof File == "function" || typeof File < "u" && toString$3.call(File) === "[object FileConstructor]";
function isBinary($e) {
  return withNativeArrayBuffer && ($e instanceof ArrayBuffer || isView($e)) || withNativeBlob && $e instanceof Blob || withNativeFile && $e instanceof File;
}
isBinary$1.isBinary = isBinary;
function hasBinary($e, Ze) {
  if (!$e || typeof $e != "object")
    return !1;
  if (Array.isArray($e)) {
    for (let Fe = 0, Ke = $e.length; Fe < Ke; Fe++)
      if (hasBinary($e[Fe]))
        return !0;
    return !1;
  }
  if (isBinary($e))
    return !0;
  if ($e.toJSON && typeof $e.toJSON == "function" && arguments.length === 1)
    return hasBinary($e.toJSON(), !0);
  for (const Fe in $e)
    if (Object.prototype.hasOwnProperty.call($e, Fe) && hasBinary($e[Fe]))
      return !0;
  return !1;
}
isBinary$1.hasBinary = hasBinary;
Object.defineProperty(binary, "__esModule", { value: !0 });
binary.reconstructPacket = binary.deconstructPacket = void 0;
const is_binary_js_1 = isBinary$1;
function deconstructPacket($e) {
  const Ze = [], Fe = $e.data, Ke = $e;
  return Ke.data = _deconstructPacket(Fe, Ze), Ke.attachments = Ze.length, { packet: Ke, buffers: Ze };
}
binary.deconstructPacket = deconstructPacket;
function _deconstructPacket($e, Ze) {
  if (!$e)
    return $e;
  if ((0, is_binary_js_1.isBinary)($e)) {
    const Fe = { _placeholder: !0, num: Ze.length };
    return Ze.push($e), Fe;
  } else if (Array.isArray($e)) {
    const Fe = new Array($e.length);
    for (let Ke = 0; Ke < $e.length; Ke++)
      Fe[Ke] = _deconstructPacket($e[Ke], Ze);
    return Fe;
  } else if (typeof $e == "object" && !($e instanceof Date)) {
    const Fe = {};
    for (const Ke in $e)
      Object.prototype.hasOwnProperty.call($e, Ke) && (Fe[Ke] = _deconstructPacket($e[Ke], Ze));
    return Fe;
  }
  return $e;
}
function reconstructPacket($e, Ze) {
  return $e.data = _reconstructPacket($e.data, Ze), delete $e.attachments, $e;
}
binary.reconstructPacket = reconstructPacket;
function _reconstructPacket($e, Ze) {
  if (!$e)
    return $e;
  if ($e && $e._placeholder === !0) {
    if (typeof $e.num == "number" && $e.num >= 0 && $e.num < Ze.length)
      return Ze[$e.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray($e))
    for (let Fe = 0; Fe < $e.length; Fe++)
      $e[Fe] = _reconstructPacket($e[Fe], Ze);
  else if (typeof $e == "object")
    for (const Fe in $e)
      Object.prototype.hasOwnProperty.call($e, Fe) && ($e[Fe] = _reconstructPacket($e[Fe], Ze));
  return $e;
}
(function($e) {
  Object.defineProperty($e, "__esModule", { value: !0 }), $e.Decoder = $e.Encoder = $e.PacketType = $e.protocol = void 0;
  const Ze = require$$5, Fe = binary, Ke = isBinary$1, Je = (0, browserExports.default)("socket.io-parser"), Qe = [
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener"
    // used by the Node.js EventEmitter
  ];
  $e.protocol = 5;
  var at;
  (function($t) {
    $t[$t.CONNECT = 0] = "CONNECT", $t[$t.DISCONNECT = 1] = "DISCONNECT", $t[$t.EVENT = 2] = "EVENT", $t[$t.ACK = 3] = "ACK", $t[$t.CONNECT_ERROR = 4] = "CONNECT_ERROR", $t[$t.BINARY_EVENT = 5] = "BINARY_EVENT", $t[$t.BINARY_ACK = 6] = "BINARY_ACK";
  })(at = $e.PacketType || ($e.PacketType = {}));
  class ut {
    /**
     * Encoder constructor
     *
     * @param {function} replacer - custom replacer to pass down to JSON.parse
     */
    constructor(vt) {
      this.replacer = vt;
    }
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    encode(vt) {
      return Je("encoding packet %j", vt), (vt.type === at.EVENT || vt.type === at.ACK) && (0, Ke.hasBinary)(vt) ? this.encodeAsBinary({
        type: vt.type === at.EVENT ? at.BINARY_EVENT : at.BINARY_ACK,
        nsp: vt.nsp,
        data: vt.data,
        id: vt.id
      }) : [this.encodeAsString(vt)];
    }
    /**
     * Encode packet as string.
     */
    encodeAsString(vt) {
      let wt = "" + vt.type;
      return (vt.type === at.BINARY_EVENT || vt.type === at.BINARY_ACK) && (wt += vt.attachments + "-"), vt.nsp && vt.nsp !== "/" && (wt += vt.nsp + ","), vt.id != null && (wt += vt.id), vt.data != null && (wt += JSON.stringify(vt.data, this.replacer)), Je("encoded %j as %s", vt, wt), wt;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
    encodeAsBinary(vt) {
      const wt = (0, Fe.deconstructPacket)(vt), xt = this.encodeAsString(wt.packet), Et = wt.buffers;
      return Et.unshift(xt), Et;
    }
  }
  $e.Encoder = ut;
  function lt($t) {
    return Object.prototype.toString.call($t) === "[object Object]";
  }
  class dt extends Ze.Emitter {
    /**
     * Decoder constructor
     *
     * @param {function} reviver - custom reviver to pass down to JSON.stringify
     */
    constructor(vt) {
      super(), this.reviver = vt;
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */
    add(vt) {
      let wt;
      if (typeof vt == "string") {
        if (this.reconstructor)
          throw new Error("got plaintext data when reconstructing a packet");
        wt = this.decodeString(vt);
        const xt = wt.type === at.BINARY_EVENT;
        xt || wt.type === at.BINARY_ACK ? (wt.type = xt ? at.EVENT : at.ACK, this.reconstructor = new bt(wt), wt.attachments === 0 && super.emitReserved("decoded", wt)) : super.emitReserved("decoded", wt);
      } else if ((0, Ke.isBinary)(vt) || vt.base64)
        if (this.reconstructor)
          wt = this.reconstructor.takeBinaryData(vt), wt && (this.reconstructor = null, super.emitReserved("decoded", wt));
        else
          throw new Error("got binary data when not reconstructing a packet");
      else
        throw new Error("Unknown type: " + vt);
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
    decodeString(vt) {
      let wt = 0;
      const xt = {
        type: Number(vt.charAt(0))
      };
      if (at[xt.type] === void 0)
        throw new Error("unknown packet type " + xt.type);
      if (xt.type === at.BINARY_EVENT || xt.type === at.BINARY_ACK) {
        const Tt = wt + 1;
        for (; vt.charAt(++wt) !== "-" && wt != vt.length; )
          ;
        const Rt = vt.substring(Tt, wt);
        if (Rt != Number(Rt) || vt.charAt(wt) !== "-")
          throw new Error("Illegal attachments");
        xt.attachments = Number(Rt);
      }
      if (vt.charAt(wt + 1) === "/") {
        const Tt = wt + 1;
        for (; ++wt && !(vt.charAt(wt) === "," || wt === vt.length); )
          ;
        xt.nsp = vt.substring(Tt, wt);
      } else
        xt.nsp = "/";
      const Et = vt.charAt(wt + 1);
      if (Et !== "" && Number(Et) == Et) {
        const Tt = wt + 1;
        for (; ++wt; ) {
          const Rt = vt.charAt(wt);
          if (Rt == null || Number(Rt) != Rt) {
            --wt;
            break;
          }
          if (wt === vt.length)
            break;
        }
        xt.id = Number(vt.substring(Tt, wt + 1));
      }
      if (vt.charAt(++wt)) {
        const Tt = this.tryParse(vt.substr(wt));
        if (dt.isPayloadValid(xt.type, Tt))
          xt.data = Tt;
        else
          throw new Error("invalid payload");
      }
      return Je("decoded %s as %j", vt, xt), xt;
    }
    tryParse(vt) {
      try {
        return JSON.parse(vt, this.reviver);
      } catch {
        return !1;
      }
    }
    static isPayloadValid(vt, wt) {
      switch (vt) {
        case at.CONNECT:
          return lt(wt);
        case at.DISCONNECT:
          return wt === void 0;
        case at.CONNECT_ERROR:
          return typeof wt == "string" || lt(wt);
        case at.EVENT:
        case at.BINARY_EVENT:
          return Array.isArray(wt) && (typeof wt[0] == "number" || typeof wt[0] == "string" && Qe.indexOf(wt[0]) === -1);
        case at.ACK:
        case at.BINARY_ACK:
          return Array.isArray(wt);
      }
    }
    /**
     * Deallocates a parser's resources
     */
    destroy() {
      this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
    }
  }
  $e.Decoder = dt;
  class bt {
    constructor(vt) {
      this.packet = vt, this.buffers = [], this.reconPack = vt;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */
    takeBinaryData(vt) {
      if (this.buffers.push(vt), this.buffers.length === this.reconPack.attachments) {
        const wt = (0, Fe.reconstructPacket)(this.reconPack, this.buffers);
        return this.finishedReconstruction(), wt;
      }
      return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
    finishedReconstruction() {
      this.reconPack = null, this.buffers = [];
    }
  }
})(cjs);
var on$2 = {};
Object.defineProperty(on$2, "__esModule", { value: !0 });
on$2.on = void 0;
function on$1($e, Ze, Fe) {
  return $e.on(Ze, Fe), function() {
    $e.off(Ze, Fe);
  };
}
on$2.on = on$1;
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function($e) {
  return $e && $e.__esModule ? $e : { default: $e };
};
Object.defineProperty(socket, "__esModule", { value: !0 });
socket.Socket = void 0;
const socket_io_parser_1 = cjs, on_js_1$1 = on$2, component_emitter_1$1 = require$$5, debug_1$1 = __importDefault$2(browserExports), debug$1 = debug_1$1.default("socket.io-client:socket"), RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket extends component_emitter_1$1.Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(Ze, Fe, Ke) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = Ze, this.nsp = Fe, Ke && Ke.auth && (this.auth = Ke.auth), this._opts = Object.assign({}, Ke), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const Ze = this.io;
    this.subs = [
      on_js_1$1.on(Ze, "open", this.onopen.bind(this)),
      on_js_1$1.on(Ze, "packet", this.onpacket.bind(this)),
      on_js_1$1.on(Ze, "error", this.onerror.bind(this)),
      on_js_1$1.on(Ze, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...Ze) {
    return Ze.unshift("message"), this.emit.apply(this, Ze), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(Ze, ...Fe) {
    if (RESERVED_EVENTS.hasOwnProperty(Ze))
      throw new Error('"' + Ze.toString() + '" is a reserved event name');
    if (Fe.unshift(Ze), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(Fe), this;
    const Ke = {
      type: socket_io_parser_1.PacketType.EVENT,
      data: Fe
    };
    if (Ke.options = {}, Ke.options.compress = this.flags.compress !== !1, typeof Fe[Fe.length - 1] == "function") {
      const Qe = this.ids++;
      debug$1("emitting packet with ack id %d", Qe);
      const at = Fe.pop();
      this._registerAckCallback(Qe, at), Ke.id = Qe;
    }
    const Ve = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    return this.flags.volatile && (!Ve || !this.connected) ? debug$1("discard packet as the transport is not currently writable") : this.connected ? (this.notifyOutgoingListeners(Ke), this.packet(Ke)) : this.sendBuffer.push(Ke), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(Ze, Fe) {
    var Ke;
    const Ve = (Ke = this.flags.timeout) !== null && Ke !== void 0 ? Ke : this._opts.ackTimeout;
    if (Ve === void 0) {
      this.acks[Ze] = Fe;
      return;
    }
    const Je = this.io.setTimeoutFn(() => {
      delete this.acks[Ze];
      for (let Qe = 0; Qe < this.sendBuffer.length; Qe++)
        this.sendBuffer[Qe].id === Ze && (debug$1("removing packet with ack id %d from the buffer", Ze), this.sendBuffer.splice(Qe, 1));
      debug$1("event with ack id %d has timed out after %d ms", Ze, Ve), Fe.call(this, new Error("operation has timed out"));
    }, Ve);
    this.acks[Ze] = (...Qe) => {
      this.io.clearTimeoutFn(Je), Fe.apply(this, [null, ...Qe]);
    };
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(Ze, ...Fe) {
    const Ke = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
    return new Promise((Ve, Je) => {
      Fe.push((Qe, at) => Ke ? Qe ? Je(Qe) : Ve(at) : Ve(Qe)), this.emit(Ze, ...Fe);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(Ze) {
    let Fe;
    typeof Ze[Ze.length - 1] == "function" && (Fe = Ze.pop());
    const Ke = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: Ze,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    Ze.push((Ve, ...Je) => Ke !== this._queue[0] ? void 0 : (Ve !== null ? Ke.tryCount > this._opts.retries && (debug$1("packet [%d] is discarded after %d tries", Ke.id, Ke.tryCount), this._queue.shift(), Fe && Fe(Ve)) : (debug$1("packet [%d] was successfully sent", Ke.id), this._queue.shift(), Fe && Fe(null, ...Je)), Ke.pending = !1, this._drainQueue())), this._queue.push(Ke), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(Ze = !1) {
    if (debug$1("draining queue"), !this.connected || this._queue.length === 0)
      return;
    const Fe = this._queue[0];
    if (Fe.pending && !Ze) {
      debug$1("packet [%d] has already been sent and is waiting for an ack", Fe.id);
      return;
    }
    Fe.pending = !0, Fe.tryCount++, debug$1("sending packet [%d] (try n°%d)", Fe.id, Fe.tryCount), this.flags = Fe.flags, this.emit.apply(this, Fe.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(Ze) {
    Ze.nsp = this.nsp, this.io._packet(Ze);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    debug$1("transport is open - connecting"), typeof this.auth == "function" ? this.auth((Ze) => {
      this._sendConnectPacket(Ze);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(Ze) {
    this.packet({
      type: socket_io_parser_1.PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, Ze) : Ze
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(Ze) {
    this.connected || this.emitReserved("connect_error", Ze);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(Ze, Fe) {
    debug$1("close (%s)", Ze), this.connected = !1, delete this.id, this.emitReserved("disconnect", Ze, Fe);
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(Ze) {
    if (Ze.nsp === this.nsp)
      switch (Ze.type) {
        case socket_io_parser_1.PacketType.CONNECT:
          Ze.data && Ze.data.sid ? this.onconnect(Ze.data.sid, Ze.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case socket_io_parser_1.PacketType.EVENT:
        case socket_io_parser_1.PacketType.BINARY_EVENT:
          this.onevent(Ze);
          break;
        case socket_io_parser_1.PacketType.ACK:
        case socket_io_parser_1.PacketType.BINARY_ACK:
          this.onack(Ze);
          break;
        case socket_io_parser_1.PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case socket_io_parser_1.PacketType.CONNECT_ERROR:
          this.destroy();
          const Ke = new Error(Ze.data.message);
          Ke.data = Ze.data.data, this.emitReserved("connect_error", Ke);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(Ze) {
    const Fe = Ze.data || [];
    debug$1("emitting event %j", Fe), Ze.id != null && (debug$1("attaching ack callback to event"), Fe.push(this.ack(Ze.id))), this.connected ? this.emitEvent(Fe) : this.receiveBuffer.push(Object.freeze(Fe));
  }
  emitEvent(Ze) {
    if (this._anyListeners && this._anyListeners.length) {
      const Fe = this._anyListeners.slice();
      for (const Ke of Fe)
        Ke.apply(this, Ze);
    }
    super.emit.apply(this, Ze), this._pid && Ze.length && typeof Ze[Ze.length - 1] == "string" && (this._lastOffset = Ze[Ze.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(Ze) {
    const Fe = this;
    let Ke = !1;
    return function(...Ve) {
      Ke || (Ke = !0, debug$1("sending ack %j", Ve), Fe.packet({
        type: socket_io_parser_1.PacketType.ACK,
        id: Ze,
        data: Ve
      }));
    };
  }
  /**
   * Called upon a server acknowlegement.
   *
   * @param packet
   * @private
   */
  onack(Ze) {
    const Fe = this.acks[Ze.id];
    typeof Fe == "function" ? (debug$1("calling ack %s with %j", Ze.id, Ze.data), Fe.apply(this, Ze.data), delete this.acks[Ze.id]) : debug$1("bad ack %s", Ze.id);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(Ze, Fe) {
    debug$1("socket connected with id %s", Ze), this.id = Ze, this.recovered = Fe && this._pid === Fe, this._pid = Fe, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((Ze) => this.emitEvent(Ze)), this.receiveBuffer = [], this.sendBuffer.forEach((Ze) => {
      this.notifyOutgoingListeners(Ze), this.packet(Ze);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    debug$1("server disconnect (%s)", this.nsp), this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((Ze) => Ze()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && (debug$1("performing disconnect (%s)", this.nsp), this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT })), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(Ze) {
    return this.flags.compress = Ze, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(Ze) {
    return this.flags.timeout = Ze, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(Ze) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(Ze), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(Ze) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(Ze), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(Ze) {
    if (!this._anyListeners)
      return this;
    if (Ze) {
      const Fe = this._anyListeners;
      for (let Ke = 0; Ke < Fe.length; Ke++)
        if (Ze === Fe[Ke])
          return Fe.splice(Ke, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(Ze) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(Ze), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(Ze) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(Ze), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(Ze) {
    if (!this._anyOutgoingListeners)
      return this;
    if (Ze) {
      const Fe = this._anyOutgoingListeners;
      for (let Ke = 0; Ke < Fe.length; Ke++)
        if (Ze === Fe[Ke])
          return Fe.splice(Ke, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(Ze) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const Fe = this._anyOutgoingListeners.slice();
      for (const Ke of Fe)
        Ke.apply(this, Ze.data);
    }
  }
}
socket.Socket = Socket;
var backo2 = {};
Object.defineProperty(backo2, "__esModule", { value: !0 });
backo2.Backoff = void 0;
function Backoff($e) {
  $e = $e || {}, this.ms = $e.min || 100, this.max = $e.max || 1e4, this.factor = $e.factor || 2, this.jitter = $e.jitter > 0 && $e.jitter <= 1 ? $e.jitter : 0, this.attempts = 0;
}
backo2.Backoff = Backoff;
Backoff.prototype.duration = function() {
  var $e = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var Ze = Math.random(), Fe = Math.floor(Ze * this.jitter * $e);
    $e = Math.floor(Ze * 10) & 1 ? $e + Fe : $e - Fe;
  }
  return Math.min($e, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function($e) {
  this.ms = $e;
};
Backoff.prototype.setMax = function($e) {
  this.max = $e;
};
Backoff.prototype.setJitter = function($e) {
  this.jitter = $e;
};
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function($e, Ze, Fe, Ke) {
  Ke === void 0 && (Ke = Fe), Object.defineProperty($e, Ke, { enumerable: !0, get: function() {
    return Ze[Fe];
  } });
} : function($e, Ze, Fe, Ke) {
  Ke === void 0 && (Ke = Fe), $e[Ke] = Ze[Fe];
}), __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function($e, Ze) {
  Object.defineProperty($e, "default", { enumerable: !0, value: Ze });
} : function($e, Ze) {
  $e.default = Ze;
}), __importStar = commonjsGlobal && commonjsGlobal.__importStar || function($e) {
  if ($e && $e.__esModule)
    return $e;
  var Ze = {};
  if ($e != null)
    for (var Fe in $e)
      Fe !== "default" && Object.prototype.hasOwnProperty.call($e, Fe) && __createBinding(Ze, $e, Fe);
  return __setModuleDefault(Ze, $e), Ze;
}, __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function($e) {
  return $e && $e.__esModule ? $e : { default: $e };
};
Object.defineProperty(manager, "__esModule", { value: !0 });
manager.Manager = void 0;
const engine_io_client_1 = cjs$2, socket_js_1 = socket, parser = __importStar(cjs), on_js_1 = on$2, backo2_js_1 = backo2, component_emitter_1 = require$$5, debug_1 = __importDefault$1(browserExports), debug = debug_1.default("socket.io-client:manager");
class Manager extends component_emitter_1.Emitter {
  constructor(Ze, Fe) {
    var Ke;
    super(), this.nsps = {}, this.subs = [], Ze && typeof Ze == "object" && (Fe = Ze, Ze = void 0), Fe = Fe || {}, Fe.path = Fe.path || "/socket.io", this.opts = Fe, engine_io_client_1.installTimerFunctions(this, Fe), this.reconnection(Fe.reconnection !== !1), this.reconnectionAttempts(Fe.reconnectionAttempts || 1 / 0), this.reconnectionDelay(Fe.reconnectionDelay || 1e3), this.reconnectionDelayMax(Fe.reconnectionDelayMax || 5e3), this.randomizationFactor((Ke = Fe.randomizationFactor) !== null && Ke !== void 0 ? Ke : 0.5), this.backoff = new backo2_js_1.Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(Fe.timeout == null ? 2e4 : Fe.timeout), this._readyState = "closed", this.uri = Ze;
    const Ve = Fe.parser || parser;
    this.encoder = new Ve.Encoder(), this.decoder = new Ve.Decoder(), this._autoConnect = Fe.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(Ze) {
    return arguments.length ? (this._reconnection = !!Ze, this) : this._reconnection;
  }
  reconnectionAttempts(Ze) {
    return Ze === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = Ze, this);
  }
  reconnectionDelay(Ze) {
    var Fe;
    return Ze === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = Ze, (Fe = this.backoff) === null || Fe === void 0 || Fe.setMin(Ze), this);
  }
  randomizationFactor(Ze) {
    var Fe;
    return Ze === void 0 ? this._randomizationFactor : (this._randomizationFactor = Ze, (Fe = this.backoff) === null || Fe === void 0 || Fe.setJitter(Ze), this);
  }
  reconnectionDelayMax(Ze) {
    var Fe;
    return Ze === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = Ze, (Fe = this.backoff) === null || Fe === void 0 || Fe.setMax(Ze), this);
  }
  timeout(Ze) {
    return arguments.length ? (this._timeout = Ze, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(Ze) {
    if (debug("readyState %s", this._readyState), ~this._readyState.indexOf("open"))
      return this;
    debug("opening %s", this.uri), this.engine = new engine_io_client_1.Socket(this.uri, this.opts);
    const Fe = this.engine, Ke = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const Ve = on_js_1.on(Fe, "open", function() {
      Ke.onopen(), Ze && Ze();
    }), Je = (at) => {
      debug("error"), this.cleanup(), this._readyState = "closed", this.emitReserved("error", at), Ze ? Ze(at) : this.maybeReconnectOnOpen();
    }, Qe = on_js_1.on(Fe, "error", Je);
    if (this._timeout !== !1) {
      const at = this._timeout;
      debug("connect attempt will timeout after %d", at);
      const ut = this.setTimeoutFn(() => {
        debug("connect attempt timed out after %d", at), Ve(), Je(new Error("timeout")), Fe.close();
      }, at);
      this.opts.autoUnref && ut.unref(), this.subs.push(() => {
        this.clearTimeoutFn(ut);
      });
    }
    return this.subs.push(Ve), this.subs.push(Qe), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(Ze) {
    return this.open(Ze);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    debug("open"), this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const Ze = this.engine;
    this.subs.push(on_js_1.on(Ze, "ping", this.onping.bind(this)), on_js_1.on(Ze, "data", this.ondata.bind(this)), on_js_1.on(Ze, "error", this.onerror.bind(this)), on_js_1.on(Ze, "close", this.onclose.bind(this)), on_js_1.on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(Ze) {
    try {
      this.decoder.add(Ze);
    } catch (Fe) {
      this.onclose("parse error", Fe);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(Ze) {
    engine_io_client_1.nextTick(() => {
      this.emitReserved("packet", Ze);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(Ze) {
    debug("error", Ze), this.emitReserved("error", Ze);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(Ze, Fe) {
    let Ke = this.nsps[Ze];
    return Ke ? this._autoConnect && !Ke.active && Ke.connect() : (Ke = new socket_js_1.Socket(this, Ze, Fe), this.nsps[Ze] = Ke), Ke;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(Ze) {
    const Fe = Object.keys(this.nsps);
    for (const Ke of Fe)
      if (this.nsps[Ke].active) {
        debug("socket %s is still active, skipping close", Ke);
        return;
      }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(Ze) {
    debug("writing packet %j", Ze);
    const Fe = this.encoder.encode(Ze);
    for (let Ke = 0; Ke < Fe.length; Ke++)
      this.engine.write(Fe[Ke], Ze.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    debug("cleanup"), this.subs.forEach((Ze) => Ze()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    debug("disconnect"), this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close();
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called upon engine close.
   *
   * @private
   */
  onclose(Ze, Fe) {
    debug("closed due to %s", Ze), this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", Ze, Fe), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const Ze = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      debug("reconnect failed"), this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const Fe = this.backoff.duration();
      debug("will wait %dms before reconnect attempt", Fe), this._reconnecting = !0;
      const Ke = this.setTimeoutFn(() => {
        Ze.skipReconnect || (debug("attempting reconnect"), this.emitReserved("reconnect_attempt", Ze.backoff.attempts), !Ze.skipReconnect && Ze.open((Ve) => {
          Ve ? (debug("reconnect attempt error"), Ze._reconnecting = !1, Ze.reconnect(), this.emitReserved("reconnect_error", Ve)) : (debug("reconnect success"), Ze.onreconnect());
        }));
      }, Fe);
      this.opts.autoUnref && Ke.unref(), this.subs.push(() => {
        this.clearTimeoutFn(Ke);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const Ze = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", Ze);
  }
}
manager.Manager = Manager;
(function($e, Ze) {
  var Fe = commonjsGlobal && commonjsGlobal.__importDefault || function(bt) {
    return bt && bt.__esModule ? bt : { default: bt };
  };
  Object.defineProperty(Ze, "__esModule", { value: !0 }), Ze.default = Ze.connect = Ze.io = Ze.Socket = Ze.Manager = Ze.protocol = void 0;
  const Ke = url$1, Ve = manager;
  Object.defineProperty(Ze, "Manager", { enumerable: !0, get: function() {
    return Ve.Manager;
  } });
  const Je = socket;
  Object.defineProperty(Ze, "Socket", { enumerable: !0, get: function() {
    return Je.Socket;
  } });
  const at = Fe(browserExports).default("socket.io-client"), ut = {};
  function lt(bt, $t) {
    typeof bt == "object" && ($t = bt, bt = void 0), $t = $t || {};
    const vt = Ke.url(bt, $t.path || "/socket.io"), wt = vt.source, xt = vt.id, Et = vt.path, Tt = ut[xt] && Et in ut[xt].nsps, Rt = $t.forceNew || $t["force new connection"] || $t.multiplex === !1 || Tt;
    let Ct;
    return Rt ? (at("ignoring socket cache for %s", wt), Ct = new Ve.Manager(wt, $t)) : (ut[xt] || (at("new io instance for %s", wt), ut[xt] = new Ve.Manager(wt, $t)), Ct = ut[xt]), vt.query && !$t.query && ($t.query = vt.queryKey), Ct.socket(vt.path, $t);
  }
  Ze.io = lt, Ze.connect = lt, Ze.default = lt, Object.assign(lt, {
    Manager: Ve.Manager,
    Socket: Je.Socket,
    io: lt,
    connect: lt
  });
  var dt = cjs;
  Object.defineProperty(Ze, "protocol", { enumerable: !0, get: function() {
    return dt.protocol;
  } }), $e.exports = lt;
})(cjs$3, cjs$3.exports);
var cjsExports = cjs$3.exports;
(function($e) {
  var Ze = commonjsGlobal && commonjsGlobal.__awaiter || function(ut, lt, dt, bt) {
    function $t(vt) {
      return vt instanceof dt ? vt : new dt(function(wt) {
        wt(vt);
      });
    }
    return new (dt || (dt = Promise))(function(vt, wt) {
      function xt(Rt) {
        try {
          Tt(bt.next(Rt));
        } catch (Ct) {
          wt(Ct);
        }
      }
      function Et(Rt) {
        try {
          Tt(bt.throw(Rt));
        } catch (Ct) {
          wt(Ct);
        }
      }
      function Tt(Rt) {
        Rt.done ? vt(Rt.value) : $t(Rt.value).then(xt, Et);
      }
      Tt((bt = bt.apply(ut, lt || [])).next());
    });
  }, Fe = commonjsGlobal && commonjsGlobal.__importDefault || function(ut) {
    return ut && ut.__esModule ? ut : { default: ut };
  };
  Object.defineProperty($e, "__esModule", { value: !0 }), $e.SocketComEmitter = $e.SocketComEvents = $e.SocketCom = void 0;
  const Ke = dist$2, Ve = Fe(cjsExports);
  class Je {
    constructor(lt) {
      this.url = lt, this.pending = {}, this.emitter = new at(), this.events = this.emitter;
    }
    connect(lt) {
      return Ze(this, void 0, void 0, function* () {
        return new Promise((dt, bt) => {
          this.disconnect(), this.socket = (0, Ve.default)(this.url, {
            transports: ["websocket"],
            auth: lt,
            autoConnect: !1
          });
          const $t = setTimeout(() => {
            bt("connection timed out");
          }, 5e3);
          this.socket.on("login", (vt) => Ze(this, void 0, void 0, function* () {
            clearTimeout($t), dt(vt);
          })), this.socket.on("connect_error", (vt) => {
            var wt;
            (wt = this.socket) === null || wt === void 0 || wt.close(), clearTimeout($t), bt(vt.message);
          }), this.socket.on("message", (vt) => Ze(this, void 0, void 0, function* () {
            var wt;
            this.pending[vt.request] && (!((wt = vt.data) === null || wt === void 0) && wt.error ? this.pending[vt.request].reject(new Error(vt.data.message)) : this.pending[vt.request].resolve(vt.data), delete this.pending[vt.request]), yield this.emitter.emit(Qe.Message, vt);
          })), this.socket.connect();
        });
      });
    }
    disconnect() {
      var lt;
      this.socket && !(!((lt = this.socket) === null || lt === void 0) && lt.disconnected) && this.socket.disconnect();
    }
    request(lt, dt) {
      var bt;
      return Ze(this, void 0, void 0, function* () {
        if (!(!((bt = this.socket) === null || bt === void 0) && bt.connected))
          throw new Error("Client is disconnected");
        const $t = this.random(32), vt = new Promise((wt, xt) => {
          this.pending[$t] = { resolve: wt, reject: xt };
        });
        return this.socket.send({ request: $t, type: lt, data: dt }), vt;
      });
    }
    random(lt) {
      const dt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      let bt = "";
      for (let $t = 0; $t < lt; $t++)
        bt += dt.charAt(Math.floor(Math.random() * dt.length));
      return bt;
    }
  }
  $e.SocketCom = Je;
  var Qe;
  (function(ut) {
    ut.Message = "message";
  })(Qe = $e.SocketComEvents || ($e.SocketComEvents = {}));
  class at extends Ke.Emitter {
  }
  $e.SocketComEmitter = at;
})(com);
var emitter = {}, __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function($e, Ze, Fe, Ke) {
  function Ve(Je) {
    return Je instanceof Fe ? Je : new Fe(function(Qe) {
      Qe(Je);
    });
  }
  return new (Fe || (Fe = Promise))(function(Je, Qe) {
    function at(dt) {
      try {
        lt(Ke.next(dt));
      } catch (bt) {
        Qe(bt);
      }
    }
    function ut(dt) {
      try {
        lt(Ke.throw(dt));
      } catch (bt) {
        Qe(bt);
      }
    }
    function lt(dt) {
      dt.done ? Je(dt.value) : Ve(dt.value).then(at, ut);
    }
    lt((Ke = Ke.apply($e, Ze || [])).next());
  });
};
Object.defineProperty(emitter, "__esModule", { value: !0 });
emitter.SocketEmitter = void 0;
class SocketEmitter {
  constructor() {
    this.listeners = {};
  }
  on(Ze, Fe) {
    const Ke = this.listeners[Ze];
    Ke ? Ke.push(Fe) : this.listeners[Ze] = [Fe];
  }
  removeListeners(Ze) {
    this.listeners[Ze] = [];
  }
  emit(Ze, Fe) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const Ke = this.listeners[Ze];
      if (Ke != null && Ke.length) {
        for (const Ve of Ke)
          yield Ve(Fe);
        return !0;
      } else
        return !1;
    });
  }
}
emitter.SocketEmitter = SocketEmitter;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function($e, Ze, Fe, Ke) {
  function Ve(Je) {
    return Je instanceof Fe ? Je : new Fe(function(Qe) {
      Qe(Je);
    });
  }
  return new (Fe || (Fe = Promise))(function(Je, Qe) {
    function at(dt) {
      try {
        lt(Ke.next(dt));
      } catch (bt) {
        Qe(bt);
      }
    }
    function ut(dt) {
      try {
        lt(Ke.throw(dt));
      } catch (bt) {
        Qe(bt);
      }
    }
    function lt(dt) {
      dt.done ? Je(dt.value) : Ve(dt.value).then(at, ut);
    }
    lt((Ke = Ke.apply($e, Ze || [])).next());
  });
};
Object.defineProperty(socket$2, "__esModule", { value: !0 });
socket$2.MessagingSocket = void 0;
const com_1 = com, emitter_1 = emitter;
class MessagingSocket extends emitter_1.SocketEmitter {
  constructor(Ze) {
    super(), this.clientId = Ze.clientId, this.com = new com_1.SocketCom(Ze.url), this.com.events.on(com_1.SocketComEvents.Message, (Fe) => __awaiter(this, void 0, void 0, function* () {
      Fe.type === "message.new" && (yield this.emit("message", Fe.data.message));
    }));
  }
  get creds() {
    return this._creds;
  }
  get userId() {
    var Ze;
    return (Ze = this._creds) === null || Ze === void 0 ? void 0 : Ze.userId;
  }
  get conversationId() {
    return this._conversationId;
  }
  connect(Ze) {
    return __awaiter(this, void 0, void 0, function* () {
      const Fe = yield this.com.connect({ clientId: this.clientId, creds: Ze });
      return Fe.userId === (Ze == null ? void 0 : Ze.userId) && !Fe.userToken && (Fe.userToken = Ze.userToken), this._creds = Fe, yield this.emit("connect", this._creds), yield this.emit("user", this._creds.userId), Fe;
    });
  }
  disconnect() {
    return __awaiter(this, void 0, void 0, function* () {
      this.com.disconnect(), yield this.emit("disconnect", void 0);
    });
  }
  getUser() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.request("users.get", {});
    });
  }
  switchConversation(Ze) {
    return __awaiter(this, void 0, void 0, function* () {
      this._conversationId = Ze, yield this.emit("conversation", this._conversationId);
    });
  }
  createConversation(Ze) {
    return __awaiter(this, void 0, void 0, function* () {
      const Fe = yield this.request("conversations.create", {});
      return (Ze == null ? void 0 : Ze.switch) !== !1 && (yield this.switchConversation(Fe.id)), Fe;
    });
  }
  startConversation(Ze) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.request("conversations.start", { id: Ze || this._conversationId });
    });
  }
  getConversation(Ze) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.request("conversations.get", {
        id: Ze || this._conversationId
      });
    });
  }
  deleteConversation(Ze) {
    return __awaiter(this, void 0, void 0, function* () {
      const Fe = yield this.request("conversations.delete", {
        id: Ze || this._conversationId
      });
      return Fe && (yield this.switchConversation(void 0)), Fe;
    });
  }
  listConversations(Ze) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.request("conversations.list", {
        limit: Ze || 20
      });
    });
  }
  sendText(Ze) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.request("messages.create", {
        conversationId: this._conversationId,
        payload: { type: "text", text: Ze }
      });
    });
  }
  sendPayload(Ze) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.request("messages.create", {
        conversationId: this._conversationId,
        payload: Ze
      });
    });
  }
  listMessages(Ze) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.request("messages.list", {
        conversationId: this._conversationId,
        limit: Ze || 20
      });
    });
  }
  sendFeedback(Ze, Fe) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.request("messages.feedback", {
        messageId: Ze,
        feedback: Fe
      });
    });
  }
  request(Ze, Fe) {
    return this.com.request(Ze, Fe);
  }
}
socket$2.MessagingSocket = MessagingSocket;
(function($e) {
  var Ze = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(Ke, Ve, Je, Qe) {
    Qe === void 0 && (Qe = Je), Object.defineProperty(Ke, Qe, { enumerable: !0, get: function() {
      return Ve[Je];
    } });
  } : function(Ke, Ve, Je, Qe) {
    Qe === void 0 && (Qe = Je), Ke[Qe] = Ve[Je];
  }), Fe = commonjsGlobal && commonjsGlobal.__exportStar || function(Ke, Ve) {
    for (var Je in Ke)
      Je !== "default" && !Object.prototype.hasOwnProperty.call(Ve, Je) && Ze(Ve, Ke, Je);
  };
  Object.defineProperty($e, "__esModule", { value: !0 }), Fe(dist$2, $e), Fe(socket$2, $e);
})(dist$3);
var util$3;
(function($e) {
  $e.assertEqual = (Ve) => Ve;
  function Ze(Ve) {
  }
  $e.assertIs = Ze;
  function Fe(Ve) {
    throw new Error();
  }
  $e.assertNever = Fe, $e.arrayToEnum = (Ve) => {
    const Je = {};
    for (const Qe of Ve)
      Je[Qe] = Qe;
    return Je;
  }, $e.getValidEnumValues = (Ve) => {
    const Je = $e.objectKeys(Ve).filter((at) => typeof Ve[Ve[at]] != "number"), Qe = {};
    for (const at of Je)
      Qe[at] = Ve[at];
    return $e.objectValues(Qe);
  }, $e.objectValues = (Ve) => $e.objectKeys(Ve).map(function(Je) {
    return Ve[Je];
  }), $e.objectKeys = typeof Object.keys == "function" ? (Ve) => Object.keys(Ve) : (Ve) => {
    const Je = [];
    for (const Qe in Ve)
      Object.prototype.hasOwnProperty.call(Ve, Qe) && Je.push(Qe);
    return Je;
  }, $e.find = (Ve, Je) => {
    for (const Qe of Ve)
      if (Je(Qe))
        return Qe;
  }, $e.isInteger = typeof Number.isInteger == "function" ? (Ve) => Number.isInteger(Ve) : (Ve) => typeof Ve == "number" && isFinite(Ve) && Math.floor(Ve) === Ve;
  function Ke(Ve, Je = " | ") {
    return Ve.map((Qe) => typeof Qe == "string" ? `'${Qe}'` : Qe).join(Je);
  }
  $e.joinValues = Ke, $e.jsonStringifyReplacer = (Ve, Je) => typeof Je == "bigint" ? Je.toString() : Je;
})(util$3 || (util$3 = {}));
var objectUtil$2;
(function($e) {
  $e.mergeShapes = (Ze, Fe) => ({
    ...Ze,
    ...Fe
    // second overwrites first
  });
})(objectUtil$2 || (objectUtil$2 = {}));
const ZodParsedType$2 = util$3.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), getParsedType$2 = ($e) => {
  switch (typeof $e) {
    case "undefined":
      return ZodParsedType$2.undefined;
    case "string":
      return ZodParsedType$2.string;
    case "number":
      return isNaN($e) ? ZodParsedType$2.nan : ZodParsedType$2.number;
    case "boolean":
      return ZodParsedType$2.boolean;
    case "function":
      return ZodParsedType$2.function;
    case "bigint":
      return ZodParsedType$2.bigint;
    case "symbol":
      return ZodParsedType$2.symbol;
    case "object":
      return Array.isArray($e) ? ZodParsedType$2.array : $e === null ? ZodParsedType$2.null : $e.then && typeof $e.then == "function" && $e.catch && typeof $e.catch == "function" ? ZodParsedType$2.promise : typeof Map < "u" && $e instanceof Map ? ZodParsedType$2.map : typeof Set < "u" && $e instanceof Set ? ZodParsedType$2.set : typeof Date < "u" && $e instanceof Date ? ZodParsedType$2.date : ZodParsedType$2.object;
    default:
      return ZodParsedType$2.unknown;
  }
}, ZodIssueCode$2 = util$3.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), quotelessJson$3 = ($e) => JSON.stringify($e, null, 2).replace(/"([^"]+)":/g, "$1:");
let ZodError$4 = class extends Error {
  constructor(Ze) {
    super(), this.issues = [], this.addIssue = (Ke) => {
      this.issues = [...this.issues, Ke];
    }, this.addIssues = (Ke = []) => {
      this.issues = [...this.issues, ...Ke];
    };
    const Fe = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, Fe) : this.__proto__ = Fe, this.name = "ZodError", this.issues = Ze;
  }
  get errors() {
    return this.issues;
  }
  format(Ze) {
    const Fe = Ze || function(Je) {
      return Je.message;
    }, Ke = { _errors: [] }, Ve = (Je) => {
      for (const Qe of Je.issues)
        if (Qe.code === "invalid_union")
          Qe.unionErrors.map(Ve);
        else if (Qe.code === "invalid_return_type")
          Ve(Qe.returnTypeError);
        else if (Qe.code === "invalid_arguments")
          Ve(Qe.argumentsError);
        else if (Qe.path.length === 0)
          Ke._errors.push(Fe(Qe));
        else {
          let at = Ke, ut = 0;
          for (; ut < Qe.path.length; ) {
            const lt = Qe.path[ut];
            ut === Qe.path.length - 1 ? (at[lt] = at[lt] || { _errors: [] }, at[lt]._errors.push(Fe(Qe))) : at[lt] = at[lt] || { _errors: [] }, at = at[lt], ut++;
          }
        }
    };
    return Ve(this), Ke;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$3.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(Ze = (Fe) => Fe.message) {
    const Fe = {}, Ke = [];
    for (const Ve of this.issues)
      Ve.path.length > 0 ? (Fe[Ve.path[0]] = Fe[Ve.path[0]] || [], Fe[Ve.path[0]].push(Ze(Ve))) : Ke.push(Ze(Ve));
    return { formErrors: Ke, fieldErrors: Fe };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$4.create = ($e) => new ZodError$4($e);
const errorMap$3 = ($e, Ze) => {
  let Fe;
  switch ($e.code) {
    case ZodIssueCode$2.invalid_type:
      $e.received === ZodParsedType$2.undefined ? Fe = "Required" : Fe = `Expected ${$e.expected}, received ${$e.received}`;
      break;
    case ZodIssueCode$2.invalid_literal:
      Fe = `Invalid literal value, expected ${JSON.stringify($e.expected, util$3.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$2.unrecognized_keys:
      Fe = `Unrecognized key(s) in object: ${util$3.joinValues($e.keys, ", ")}`;
      break;
    case ZodIssueCode$2.invalid_union:
      Fe = "Invalid input";
      break;
    case ZodIssueCode$2.invalid_union_discriminator:
      Fe = `Invalid discriminator value. Expected ${util$3.joinValues($e.options)}`;
      break;
    case ZodIssueCode$2.invalid_enum_value:
      Fe = `Invalid enum value. Expected ${util$3.joinValues($e.options)}, received '${$e.received}'`;
      break;
    case ZodIssueCode$2.invalid_arguments:
      Fe = "Invalid function arguments";
      break;
    case ZodIssueCode$2.invalid_return_type:
      Fe = "Invalid function return type";
      break;
    case ZodIssueCode$2.invalid_date:
      Fe = "Invalid date";
      break;
    case ZodIssueCode$2.invalid_string:
      typeof $e.validation == "object" ? "includes" in $e.validation ? (Fe = `Invalid input: must include "${$e.validation.includes}"`, typeof $e.validation.position == "number" && (Fe = `${Fe} at one or more positions greater than or equal to ${$e.validation.position}`)) : "startsWith" in $e.validation ? Fe = `Invalid input: must start with "${$e.validation.startsWith}"` : "endsWith" in $e.validation ? Fe = `Invalid input: must end with "${$e.validation.endsWith}"` : util$3.assertNever($e.validation) : $e.validation !== "regex" ? Fe = `Invalid ${$e.validation}` : Fe = "Invalid";
      break;
    case ZodIssueCode$2.too_small:
      $e.type === "array" ? Fe = `Array must contain ${$e.exact ? "exactly" : $e.inclusive ? "at least" : "more than"} ${$e.minimum} element(s)` : $e.type === "string" ? Fe = `String must contain ${$e.exact ? "exactly" : $e.inclusive ? "at least" : "over"} ${$e.minimum} character(s)` : $e.type === "number" ? Fe = `Number must be ${$e.exact ? "exactly equal to " : $e.inclusive ? "greater than or equal to " : "greater than "}${$e.minimum}` : $e.type === "date" ? Fe = `Date must be ${$e.exact ? "exactly equal to " : $e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number($e.minimum))}` : Fe = "Invalid input";
      break;
    case ZodIssueCode$2.too_big:
      $e.type === "array" ? Fe = `Array must contain ${$e.exact ? "exactly" : $e.inclusive ? "at most" : "less than"} ${$e.maximum} element(s)` : $e.type === "string" ? Fe = `String must contain ${$e.exact ? "exactly" : $e.inclusive ? "at most" : "under"} ${$e.maximum} character(s)` : $e.type === "number" ? Fe = `Number must be ${$e.exact ? "exactly" : $e.inclusive ? "less than or equal to" : "less than"} ${$e.maximum}` : $e.type === "bigint" ? Fe = `BigInt must be ${$e.exact ? "exactly" : $e.inclusive ? "less than or equal to" : "less than"} ${$e.maximum}` : $e.type === "date" ? Fe = `Date must be ${$e.exact ? "exactly" : $e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number($e.maximum))}` : Fe = "Invalid input";
      break;
    case ZodIssueCode$2.custom:
      Fe = "Invalid input";
      break;
    case ZodIssueCode$2.invalid_intersection_types:
      Fe = "Intersection results could not be merged";
      break;
    case ZodIssueCode$2.not_multiple_of:
      Fe = `Number must be a multiple of ${$e.multipleOf}`;
      break;
    case ZodIssueCode$2.not_finite:
      Fe = "Number must be finite";
      break;
    default:
      Fe = Ze.defaultError, util$3.assertNever($e);
  }
  return { message: Fe };
};
let overrideErrorMap$3 = errorMap$3;
function setErrorMap$3($e) {
  overrideErrorMap$3 = $e;
}
function getErrorMap$3() {
  return overrideErrorMap$3;
}
const makeIssue$2 = ($e) => {
  const { data: Ze, path: Fe, errorMaps: Ke, issueData: Ve } = $e, Je = [...Fe, ...Ve.path || []], Qe = {
    ...Ve,
    path: Je
  };
  let at = "";
  const ut = Ke.filter((lt) => !!lt).slice().reverse();
  for (const lt of ut)
    at = lt(Qe, { data: Ze, defaultError: at }).message;
  return {
    ...Ve,
    path: Je,
    message: Ve.message || at
  };
}, EMPTY_PATH$2 = [];
function addIssueToContext$2($e, Ze) {
  const Fe = makeIssue$2({
    issueData: Ze,
    data: $e.data,
    path: $e.path,
    errorMaps: [
      $e.common.contextualErrorMap,
      $e.schemaErrorMap,
      getErrorMap$3(),
      errorMap$3
      // then global default map
    ].filter((Ke) => !!Ke)
  });
  $e.common.issues.push(Fe);
}
let ParseStatus$2 = class Pn {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(Ze, Fe) {
    const Ke = [];
    for (const Ve of Fe) {
      if (Ve.status === "aborted")
        return INVALID$2;
      Ve.status === "dirty" && Ze.dirty(), Ke.push(Ve.value);
    }
    return { status: Ze.value, value: Ke };
  }
  static async mergeObjectAsync(Ze, Fe) {
    const Ke = [];
    for (const Ve of Fe)
      Ke.push({
        key: await Ve.key,
        value: await Ve.value
      });
    return Pn.mergeObjectSync(Ze, Ke);
  }
  static mergeObjectSync(Ze, Fe) {
    const Ke = {};
    for (const Ve of Fe) {
      const { key: Je, value: Qe } = Ve;
      if (Je.status === "aborted" || Qe.status === "aborted")
        return INVALID$2;
      Je.status === "dirty" && Ze.dirty(), Qe.status === "dirty" && Ze.dirty(), (typeof Qe.value < "u" || Ve.alwaysSet) && (Ke[Je.value] = Qe.value);
    }
    return { status: Ze.value, value: Ke };
  }
};
const INVALID$2 = Object.freeze({
  status: "aborted"
}), DIRTY$2 = ($e) => ({ status: "dirty", value: $e }), OK$2 = ($e) => ({ status: "valid", value: $e }), isAborted$2 = ($e) => $e.status === "aborted", isDirty$2 = ($e) => $e.status === "dirty", isValid$2 = ($e) => $e.status === "valid", isAsync$2 = ($e) => typeof Promise < "u" && $e instanceof Promise;
var errorUtil$3;
(function($e) {
  $e.errToObj = (Ze) => typeof Ze == "string" ? { message: Ze } : Ze || {}, $e.toString = (Ze) => typeof Ze == "string" ? Ze : Ze == null ? void 0 : Ze.message;
})(errorUtil$3 || (errorUtil$3 = {}));
let ParseInputLazyPath$2 = class {
  constructor(Ze, Fe, Ke, Ve) {
    this._cachedPath = [], this.parent = Ze, this.data = Fe, this._path = Ke, this._key = Ve;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
const handleResult$2 = ($e, Ze) => {
  if (isValid$2(Ze))
    return { success: !0, data: Ze.value };
  if (!$e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const Fe = new ZodError$4($e.common.issues);
      return this._error = Fe, this._error;
    }
  };
};
function processCreateParams$2($e) {
  if (!$e)
    return {};
  const { errorMap: Ze, invalid_type_error: Fe, required_error: Ke, description: Ve } = $e;
  if (Ze && (Fe || Ke))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return Ze ? { errorMap: Ze, description: Ve } : { errorMap: (Qe, at) => Qe.code !== "invalid_type" ? { message: at.defaultError } : typeof at.data > "u" ? { message: Ke ?? at.defaultError } : { message: Fe ?? at.defaultError }, description: Ve };
}
let ZodType$2 = class {
  constructor(Ze) {
    this.spa = this.safeParseAsync, this._def = Ze, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(Ze) {
    return getParsedType$2(Ze.data);
  }
  _getOrReturnCtx(Ze, Fe) {
    return Fe || {
      common: Ze.parent.common,
      data: Ze.data,
      parsedType: getParsedType$2(Ze.data),
      schemaErrorMap: this._def.errorMap,
      path: Ze.path,
      parent: Ze.parent
    };
  }
  _processInputParams(Ze) {
    return {
      status: new ParseStatus$2(),
      ctx: {
        common: Ze.parent.common,
        data: Ze.data,
        parsedType: getParsedType$2(Ze.data),
        schemaErrorMap: this._def.errorMap,
        path: Ze.path,
        parent: Ze.parent
      }
    };
  }
  _parseSync(Ze) {
    const Fe = this._parse(Ze);
    if (isAsync$2(Fe))
      throw new Error("Synchronous parse encountered promise.");
    return Fe;
  }
  _parseAsync(Ze) {
    const Fe = this._parse(Ze);
    return Promise.resolve(Fe);
  }
  parse(Ze, Fe) {
    const Ke = this.safeParse(Ze, Fe);
    if (Ke.success)
      return Ke.data;
    throw Ke.error;
  }
  safeParse(Ze, Fe) {
    var Ke;
    const Ve = {
      common: {
        issues: [],
        async: (Ke = Fe == null ? void 0 : Fe.async) !== null && Ke !== void 0 ? Ke : !1,
        contextualErrorMap: Fe == null ? void 0 : Fe.errorMap
      },
      path: (Fe == null ? void 0 : Fe.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: Ze,
      parsedType: getParsedType$2(Ze)
    }, Je = this._parseSync({ data: Ze, path: Ve.path, parent: Ve });
    return handleResult$2(Ve, Je);
  }
  async parseAsync(Ze, Fe) {
    const Ke = await this.safeParseAsync(Ze, Fe);
    if (Ke.success)
      return Ke.data;
    throw Ke.error;
  }
  async safeParseAsync(Ze, Fe) {
    const Ke = {
      common: {
        issues: [],
        contextualErrorMap: Fe == null ? void 0 : Fe.errorMap,
        async: !0
      },
      path: (Fe == null ? void 0 : Fe.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: Ze,
      parsedType: getParsedType$2(Ze)
    }, Ve = this._parse({ data: Ze, path: Ke.path, parent: Ke }), Je = await (isAsync$2(Ve) ? Ve : Promise.resolve(Ve));
    return handleResult$2(Ke, Je);
  }
  refine(Ze, Fe) {
    const Ke = (Ve) => typeof Fe == "string" || typeof Fe > "u" ? { message: Fe } : typeof Fe == "function" ? Fe(Ve) : Fe;
    return this._refinement((Ve, Je) => {
      const Qe = Ze(Ve), at = () => Je.addIssue({
        code: ZodIssueCode$2.custom,
        ...Ke(Ve)
      });
      return typeof Promise < "u" && Qe instanceof Promise ? Qe.then((ut) => ut ? !0 : (at(), !1)) : Qe ? !0 : (at(), !1);
    });
  }
  refinement(Ze, Fe) {
    return this._refinement((Ke, Ve) => Ze(Ke) ? !0 : (Ve.addIssue(typeof Fe == "function" ? Fe(Ke, Ve) : Fe), !1));
  }
  _refinement(Ze) {
    return new ZodEffects$2({
      schema: this,
      typeName: ZodFirstPartyTypeKind$2.ZodEffects,
      effect: { type: "refinement", refinement: Ze }
    });
  }
  superRefine(Ze) {
    return this._refinement(Ze);
  }
  optional() {
    return ZodOptional$2.create(this, this._def);
  }
  nullable() {
    return ZodNullable$2.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$2.create(this, this._def);
  }
  promise() {
    return ZodPromise$2.create(this, this._def);
  }
  or(Ze) {
    return ZodUnion$2.create([this, Ze], this._def);
  }
  and(Ze) {
    return ZodIntersection$2.create(this, Ze, this._def);
  }
  transform(Ze) {
    return new ZodEffects$2({
      ...processCreateParams$2(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$2.ZodEffects,
      effect: { type: "transform", transform: Ze }
    });
  }
  default(Ze) {
    const Fe = typeof Ze == "function" ? Ze : () => Ze;
    return new ZodDefault$2({
      ...processCreateParams$2(this._def),
      innerType: this,
      defaultValue: Fe,
      typeName: ZodFirstPartyTypeKind$2.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$2({
      typeName: ZodFirstPartyTypeKind$2.ZodBranded,
      type: this,
      ...processCreateParams$2(this._def)
    });
  }
  catch(Ze) {
    const Fe = typeof Ze == "function" ? Ze : () => Ze;
    return new ZodCatch$2({
      ...processCreateParams$2(this._def),
      innerType: this,
      catchValue: Fe,
      typeName: ZodFirstPartyTypeKind$2.ZodCatch
    });
  }
  describe(Ze) {
    const Fe = this.constructor;
    return new Fe({
      ...this._def,
      description: Ze
    });
  }
  pipe(Ze) {
    return ZodPipeline$2.create(this, Ze);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$2 = /^c[^\s-]{8,}$/i, cuid2Regex$2 = /^[a-z][a-z0-9]*$/, ulidRegex$2 = /[0-9A-HJKMNP-TV-Z]{26}/, uuidRegex$2 = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, emailRegex$2 = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, emojiRegex$2 = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, ipv4Regex$2 = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, ipv6Regex$2 = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, datetimeRegex$2 = ($e) => $e.precision ? $e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${$e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${$e.precision}}Z$`) : $e.precision === 0 ? $e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : $e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function isValidIP$2($e, Ze) {
  return !!((Ze === "v4" || !Ze) && ipv4Regex$2.test($e) || (Ze === "v6" || !Ze) && ipv6Regex$2.test($e));
}
let ZodString$2 = class bn extends ZodType$2 {
  constructor() {
    super(...arguments), this._regex = (Ze, Fe, Ke) => this.refinement((Ve) => Ze.test(Ve), {
      validation: Fe,
      code: ZodIssueCode$2.invalid_string,
      ...errorUtil$3.errToObj(Ke)
    }), this.nonempty = (Ze) => this.min(1, errorUtil$3.errToObj(Ze)), this.trim = () => new bn({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new bn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new bn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(Ze) {
    if (this._def.coerce && (Ze.data = String(Ze.data)), this._getType(Ze) !== ZodParsedType$2.string) {
      const Je = this._getOrReturnCtx(Ze);
      return addIssueToContext$2(
        Je,
        {
          code: ZodIssueCode$2.invalid_type,
          expected: ZodParsedType$2.string,
          received: Je.parsedType
        }
        //
      ), INVALID$2;
    }
    const Ke = new ParseStatus$2();
    let Ve;
    for (const Je of this._def.checks)
      if (Je.kind === "min")
        Ze.data.length < Je.value && (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$2(Ve, {
          code: ZodIssueCode$2.too_small,
          minimum: Je.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: Je.message
        }), Ke.dirty());
      else if (Je.kind === "max")
        Ze.data.length > Je.value && (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$2(Ve, {
          code: ZodIssueCode$2.too_big,
          maximum: Je.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: Je.message
        }), Ke.dirty());
      else if (Je.kind === "length") {
        const Qe = Ze.data.length > Je.value, at = Ze.data.length < Je.value;
        (Qe || at) && (Ve = this._getOrReturnCtx(Ze, Ve), Qe ? addIssueToContext$2(Ve, {
          code: ZodIssueCode$2.too_big,
          maximum: Je.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: Je.message
        }) : at && addIssueToContext$2(Ve, {
          code: ZodIssueCode$2.too_small,
          minimum: Je.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: Je.message
        }), Ke.dirty());
      } else if (Je.kind === "email")
        emailRegex$2.test(Ze.data) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$2(Ve, {
          validation: "email",
          code: ZodIssueCode$2.invalid_string,
          message: Je.message
        }), Ke.dirty());
      else if (Je.kind === "emoji")
        emojiRegex$2.test(Ze.data) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$2(Ve, {
          validation: "emoji",
          code: ZodIssueCode$2.invalid_string,
          message: Je.message
        }), Ke.dirty());
      else if (Je.kind === "uuid")
        uuidRegex$2.test(Ze.data) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$2(Ve, {
          validation: "uuid",
          code: ZodIssueCode$2.invalid_string,
          message: Je.message
        }), Ke.dirty());
      else if (Je.kind === "cuid")
        cuidRegex$2.test(Ze.data) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$2(Ve, {
          validation: "cuid",
          code: ZodIssueCode$2.invalid_string,
          message: Je.message
        }), Ke.dirty());
      else if (Je.kind === "cuid2")
        cuid2Regex$2.test(Ze.data) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$2(Ve, {
          validation: "cuid2",
          code: ZodIssueCode$2.invalid_string,
          message: Je.message
        }), Ke.dirty());
      else if (Je.kind === "ulid")
        ulidRegex$2.test(Ze.data) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$2(Ve, {
          validation: "ulid",
          code: ZodIssueCode$2.invalid_string,
          message: Je.message
        }), Ke.dirty());
      else if (Je.kind === "url")
        try {
          new URL(Ze.data);
        } catch {
          Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$2(Ve, {
            validation: "url",
            code: ZodIssueCode$2.invalid_string,
            message: Je.message
          }), Ke.dirty();
        }
      else
        Je.kind === "regex" ? (Je.regex.lastIndex = 0, Je.regex.test(Ze.data) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$2(Ve, {
          validation: "regex",
          code: ZodIssueCode$2.invalid_string,
          message: Je.message
        }), Ke.dirty())) : Je.kind === "trim" ? Ze.data = Ze.data.trim() : Je.kind === "includes" ? Ze.data.includes(Je.value, Je.position) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$2(Ve, {
          code: ZodIssueCode$2.invalid_string,
          validation: { includes: Je.value, position: Je.position },
          message: Je.message
        }), Ke.dirty()) : Je.kind === "toLowerCase" ? Ze.data = Ze.data.toLowerCase() : Je.kind === "toUpperCase" ? Ze.data = Ze.data.toUpperCase() : Je.kind === "startsWith" ? Ze.data.startsWith(Je.value) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$2(Ve, {
          code: ZodIssueCode$2.invalid_string,
          validation: { startsWith: Je.value },
          message: Je.message
        }), Ke.dirty()) : Je.kind === "endsWith" ? Ze.data.endsWith(Je.value) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$2(Ve, {
          code: ZodIssueCode$2.invalid_string,
          validation: { endsWith: Je.value },
          message: Je.message
        }), Ke.dirty()) : Je.kind === "datetime" ? datetimeRegex$2(Je).test(Ze.data) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$2(Ve, {
          code: ZodIssueCode$2.invalid_string,
          validation: "datetime",
          message: Je.message
        }), Ke.dirty()) : Je.kind === "ip" ? isValidIP$2(Ze.data, Je.version) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$2(Ve, {
          validation: "ip",
          code: ZodIssueCode$2.invalid_string,
          message: Je.message
        }), Ke.dirty()) : util$3.assertNever(Je);
    return { status: Ke.value, value: Ze.data };
  }
  _addCheck(Ze) {
    return new bn({
      ...this._def,
      checks: [...this._def.checks, Ze]
    });
  }
  email(Ze) {
    return this._addCheck({ kind: "email", ...errorUtil$3.errToObj(Ze) });
  }
  url(Ze) {
    return this._addCheck({ kind: "url", ...errorUtil$3.errToObj(Ze) });
  }
  emoji(Ze) {
    return this._addCheck({ kind: "emoji", ...errorUtil$3.errToObj(Ze) });
  }
  uuid(Ze) {
    return this._addCheck({ kind: "uuid", ...errorUtil$3.errToObj(Ze) });
  }
  cuid(Ze) {
    return this._addCheck({ kind: "cuid", ...errorUtil$3.errToObj(Ze) });
  }
  cuid2(Ze) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$3.errToObj(Ze) });
  }
  ulid(Ze) {
    return this._addCheck({ kind: "ulid", ...errorUtil$3.errToObj(Ze) });
  }
  ip(Ze) {
    return this._addCheck({ kind: "ip", ...errorUtil$3.errToObj(Ze) });
  }
  datetime(Ze) {
    var Fe;
    return typeof Ze == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: Ze
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (Ze == null ? void 0 : Ze.precision) > "u" ? null : Ze == null ? void 0 : Ze.precision,
      offset: (Fe = Ze == null ? void 0 : Ze.offset) !== null && Fe !== void 0 ? Fe : !1,
      ...errorUtil$3.errToObj(Ze == null ? void 0 : Ze.message)
    });
  }
  regex(Ze, Fe) {
    return this._addCheck({
      kind: "regex",
      regex: Ze,
      ...errorUtil$3.errToObj(Fe)
    });
  }
  includes(Ze, Fe) {
    return this._addCheck({
      kind: "includes",
      value: Ze,
      position: Fe == null ? void 0 : Fe.position,
      ...errorUtil$3.errToObj(Fe == null ? void 0 : Fe.message)
    });
  }
  startsWith(Ze, Fe) {
    return this._addCheck({
      kind: "startsWith",
      value: Ze,
      ...errorUtil$3.errToObj(Fe)
    });
  }
  endsWith(Ze, Fe) {
    return this._addCheck({
      kind: "endsWith",
      value: Ze,
      ...errorUtil$3.errToObj(Fe)
    });
  }
  min(Ze, Fe) {
    return this._addCheck({
      kind: "min",
      value: Ze,
      ...errorUtil$3.errToObj(Fe)
    });
  }
  max(Ze, Fe) {
    return this._addCheck({
      kind: "max",
      value: Ze,
      ...errorUtil$3.errToObj(Fe)
    });
  }
  length(Ze, Fe) {
    return this._addCheck({
      kind: "length",
      value: Ze,
      ...errorUtil$3.errToObj(Fe)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((Ze) => Ze.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((Ze) => Ze.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((Ze) => Ze.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((Ze) => Ze.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((Ze) => Ze.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((Ze) => Ze.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((Ze) => Ze.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((Ze) => Ze.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((Ze) => Ze.kind === "ip");
  }
  get minLength() {
    let Ze = null;
    for (const Fe of this._def.checks)
      Fe.kind === "min" && (Ze === null || Fe.value > Ze) && (Ze = Fe.value);
    return Ze;
  }
  get maxLength() {
    let Ze = null;
    for (const Fe of this._def.checks)
      Fe.kind === "max" && (Ze === null || Fe.value < Ze) && (Ze = Fe.value);
    return Ze;
  }
};
ZodString$2.create = ($e) => {
  var Ze;
  return new ZodString$2({
    checks: [],
    typeName: ZodFirstPartyTypeKind$2.ZodString,
    coerce: (Ze = $e == null ? void 0 : $e.coerce) !== null && Ze !== void 0 ? Ze : !1,
    ...processCreateParams$2($e)
  });
};
function floatSafeRemainder$2($e, Ze) {
  const Fe = ($e.toString().split(".")[1] || "").length, Ke = (Ze.toString().split(".")[1] || "").length, Ve = Fe > Ke ? Fe : Ke, Je = parseInt($e.toFixed(Ve).replace(".", "")), Qe = parseInt(Ze.toFixed(Ve).replace(".", ""));
  return Je % Qe / Math.pow(10, Ve);
}
let ZodNumber$2 = class xn extends ZodType$2 {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(Ze) {
    if (this._def.coerce && (Ze.data = Number(Ze.data)), this._getType(Ze) !== ZodParsedType$2.number) {
      const Je = this._getOrReturnCtx(Ze);
      return addIssueToContext$2(Je, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.number,
        received: Je.parsedType
      }), INVALID$2;
    }
    let Ke;
    const Ve = new ParseStatus$2();
    for (const Je of this._def.checks)
      Je.kind === "int" ? util$3.isInteger(Ze.data) || (Ke = this._getOrReturnCtx(Ze, Ke), addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.invalid_type,
        expected: "integer",
        received: "float",
        message: Je.message
      }), Ve.dirty()) : Je.kind === "min" ? (Je.inclusive ? Ze.data < Je.value : Ze.data <= Je.value) && (Ke = this._getOrReturnCtx(Ze, Ke), addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.too_small,
        minimum: Je.value,
        type: "number",
        inclusive: Je.inclusive,
        exact: !1,
        message: Je.message
      }), Ve.dirty()) : Je.kind === "max" ? (Je.inclusive ? Ze.data > Je.value : Ze.data >= Je.value) && (Ke = this._getOrReturnCtx(Ze, Ke), addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.too_big,
        maximum: Je.value,
        type: "number",
        inclusive: Je.inclusive,
        exact: !1,
        message: Je.message
      }), Ve.dirty()) : Je.kind === "multipleOf" ? floatSafeRemainder$2(Ze.data, Je.value) !== 0 && (Ke = this._getOrReturnCtx(Ze, Ke), addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.not_multiple_of,
        multipleOf: Je.value,
        message: Je.message
      }), Ve.dirty()) : Je.kind === "finite" ? Number.isFinite(Ze.data) || (Ke = this._getOrReturnCtx(Ze, Ke), addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.not_finite,
        message: Je.message
      }), Ve.dirty()) : util$3.assertNever(Je);
    return { status: Ve.value, value: Ze.data };
  }
  gte(Ze, Fe) {
    return this.setLimit("min", Ze, !0, errorUtil$3.toString(Fe));
  }
  gt(Ze, Fe) {
    return this.setLimit("min", Ze, !1, errorUtil$3.toString(Fe));
  }
  lte(Ze, Fe) {
    return this.setLimit("max", Ze, !0, errorUtil$3.toString(Fe));
  }
  lt(Ze, Fe) {
    return this.setLimit("max", Ze, !1, errorUtil$3.toString(Fe));
  }
  setLimit(Ze, Fe, Ke, Ve) {
    return new xn({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: Ze,
          value: Fe,
          inclusive: Ke,
          message: errorUtil$3.toString(Ve)
        }
      ]
    });
  }
  _addCheck(Ze) {
    return new xn({
      ...this._def,
      checks: [...this._def.checks, Ze]
    });
  }
  int(Ze) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$3.toString(Ze)
    });
  }
  positive(Ze) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: errorUtil$3.toString(Ze)
    });
  }
  negative(Ze) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: errorUtil$3.toString(Ze)
    });
  }
  nonpositive(Ze) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: errorUtil$3.toString(Ze)
    });
  }
  nonnegative(Ze) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: errorUtil$3.toString(Ze)
    });
  }
  multipleOf(Ze, Fe) {
    return this._addCheck({
      kind: "multipleOf",
      value: Ze,
      message: errorUtil$3.toString(Fe)
    });
  }
  finite(Ze) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$3.toString(Ze)
    });
  }
  safe(Ze) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$3.toString(Ze)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$3.toString(Ze)
    });
  }
  get minValue() {
    let Ze = null;
    for (const Fe of this._def.checks)
      Fe.kind === "min" && (Ze === null || Fe.value > Ze) && (Ze = Fe.value);
    return Ze;
  }
  get maxValue() {
    let Ze = null;
    for (const Fe of this._def.checks)
      Fe.kind === "max" && (Ze === null || Fe.value < Ze) && (Ze = Fe.value);
    return Ze;
  }
  get isInt() {
    return !!this._def.checks.find((Ze) => Ze.kind === "int" || Ze.kind === "multipleOf" && util$3.isInteger(Ze.value));
  }
  get isFinite() {
    let Ze = null, Fe = null;
    for (const Ke of this._def.checks) {
      if (Ke.kind === "finite" || Ke.kind === "int" || Ke.kind === "multipleOf")
        return !0;
      Ke.kind === "min" ? (Fe === null || Ke.value > Fe) && (Fe = Ke.value) : Ke.kind === "max" && (Ze === null || Ke.value < Ze) && (Ze = Ke.value);
    }
    return Number.isFinite(Fe) && Number.isFinite(Ze);
  }
};
ZodNumber$2.create = ($e) => new ZodNumber$2({
  checks: [],
  typeName: ZodFirstPartyTypeKind$2.ZodNumber,
  coerce: ($e == null ? void 0 : $e.coerce) || !1,
  ...processCreateParams$2($e)
});
let ZodBigInt$2 = class Mn extends ZodType$2 {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(Ze) {
    if (this._def.coerce && (Ze.data = BigInt(Ze.data)), this._getType(Ze) !== ZodParsedType$2.bigint) {
      const Je = this._getOrReturnCtx(Ze);
      return addIssueToContext$2(Je, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.bigint,
        received: Je.parsedType
      }), INVALID$2;
    }
    let Ke;
    const Ve = new ParseStatus$2();
    for (const Je of this._def.checks)
      Je.kind === "min" ? (Je.inclusive ? Ze.data < Je.value : Ze.data <= Je.value) && (Ke = this._getOrReturnCtx(Ze, Ke), addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.too_small,
        type: "bigint",
        minimum: Je.value,
        inclusive: Je.inclusive,
        message: Je.message
      }), Ve.dirty()) : Je.kind === "max" ? (Je.inclusive ? Ze.data > Je.value : Ze.data >= Je.value) && (Ke = this._getOrReturnCtx(Ze, Ke), addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.too_big,
        type: "bigint",
        maximum: Je.value,
        inclusive: Je.inclusive,
        message: Je.message
      }), Ve.dirty()) : Je.kind === "multipleOf" ? Ze.data % Je.value !== BigInt(0) && (Ke = this._getOrReturnCtx(Ze, Ke), addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.not_multiple_of,
        multipleOf: Je.value,
        message: Je.message
      }), Ve.dirty()) : util$3.assertNever(Je);
    return { status: Ve.value, value: Ze.data };
  }
  gte(Ze, Fe) {
    return this.setLimit("min", Ze, !0, errorUtil$3.toString(Fe));
  }
  gt(Ze, Fe) {
    return this.setLimit("min", Ze, !1, errorUtil$3.toString(Fe));
  }
  lte(Ze, Fe) {
    return this.setLimit("max", Ze, !0, errorUtil$3.toString(Fe));
  }
  lt(Ze, Fe) {
    return this.setLimit("max", Ze, !1, errorUtil$3.toString(Fe));
  }
  setLimit(Ze, Fe, Ke, Ve) {
    return new Mn({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: Ze,
          value: Fe,
          inclusive: Ke,
          message: errorUtil$3.toString(Ve)
        }
      ]
    });
  }
  _addCheck(Ze) {
    return new Mn({
      ...this._def,
      checks: [...this._def.checks, Ze]
    });
  }
  positive(Ze) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil$3.toString(Ze)
    });
  }
  negative(Ze) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil$3.toString(Ze)
    });
  }
  nonpositive(Ze) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil$3.toString(Ze)
    });
  }
  nonnegative(Ze) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil$3.toString(Ze)
    });
  }
  multipleOf(Ze, Fe) {
    return this._addCheck({
      kind: "multipleOf",
      value: Ze,
      message: errorUtil$3.toString(Fe)
    });
  }
  get minValue() {
    let Ze = null;
    for (const Fe of this._def.checks)
      Fe.kind === "min" && (Ze === null || Fe.value > Ze) && (Ze = Fe.value);
    return Ze;
  }
  get maxValue() {
    let Ze = null;
    for (const Fe of this._def.checks)
      Fe.kind === "max" && (Ze === null || Fe.value < Ze) && (Ze = Fe.value);
    return Ze;
  }
};
ZodBigInt$2.create = ($e) => {
  var Ze;
  return new ZodBigInt$2({
    checks: [],
    typeName: ZodFirstPartyTypeKind$2.ZodBigInt,
    coerce: (Ze = $e == null ? void 0 : $e.coerce) !== null && Ze !== void 0 ? Ze : !1,
    ...processCreateParams$2($e)
  });
};
let ZodBoolean$2 = class extends ZodType$2 {
  _parse(Ze) {
    if (this._def.coerce && (Ze.data = !!Ze.data), this._getType(Ze) !== ZodParsedType$2.boolean) {
      const Ke = this._getOrReturnCtx(Ze);
      return addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.boolean,
        received: Ke.parsedType
      }), INVALID$2;
    }
    return OK$2(Ze.data);
  }
};
ZodBoolean$2.create = ($e) => new ZodBoolean$2({
  typeName: ZodFirstPartyTypeKind$2.ZodBoolean,
  coerce: ($e == null ? void 0 : $e.coerce) || !1,
  ...processCreateParams$2($e)
});
let ZodDate$2 = class On extends ZodType$2 {
  _parse(Ze) {
    if (this._def.coerce && (Ze.data = new Date(Ze.data)), this._getType(Ze) !== ZodParsedType$2.date) {
      const Je = this._getOrReturnCtx(Ze);
      return addIssueToContext$2(Je, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.date,
        received: Je.parsedType
      }), INVALID$2;
    }
    if (isNaN(Ze.data.getTime())) {
      const Je = this._getOrReturnCtx(Ze);
      return addIssueToContext$2(Je, {
        code: ZodIssueCode$2.invalid_date
      }), INVALID$2;
    }
    const Ke = new ParseStatus$2();
    let Ve;
    for (const Je of this._def.checks)
      Je.kind === "min" ? Ze.data.getTime() < Je.value && (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$2(Ve, {
        code: ZodIssueCode$2.too_small,
        message: Je.message,
        inclusive: !0,
        exact: !1,
        minimum: Je.value,
        type: "date"
      }), Ke.dirty()) : Je.kind === "max" ? Ze.data.getTime() > Je.value && (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$2(Ve, {
        code: ZodIssueCode$2.too_big,
        message: Je.message,
        inclusive: !0,
        exact: !1,
        maximum: Je.value,
        type: "date"
      }), Ke.dirty()) : util$3.assertNever(Je);
    return {
      status: Ke.value,
      value: new Date(Ze.data.getTime())
    };
  }
  _addCheck(Ze) {
    return new On({
      ...this._def,
      checks: [...this._def.checks, Ze]
    });
  }
  min(Ze, Fe) {
    return this._addCheck({
      kind: "min",
      value: Ze.getTime(),
      message: errorUtil$3.toString(Fe)
    });
  }
  max(Ze, Fe) {
    return this._addCheck({
      kind: "max",
      value: Ze.getTime(),
      message: errorUtil$3.toString(Fe)
    });
  }
  get minDate() {
    let Ze = null;
    for (const Fe of this._def.checks)
      Fe.kind === "min" && (Ze === null || Fe.value > Ze) && (Ze = Fe.value);
    return Ze != null ? new Date(Ze) : null;
  }
  get maxDate() {
    let Ze = null;
    for (const Fe of this._def.checks)
      Fe.kind === "max" && (Ze === null || Fe.value < Ze) && (Ze = Fe.value);
    return Ze != null ? new Date(Ze) : null;
  }
};
ZodDate$2.create = ($e) => new ZodDate$2({
  checks: [],
  coerce: ($e == null ? void 0 : $e.coerce) || !1,
  typeName: ZodFirstPartyTypeKind$2.ZodDate,
  ...processCreateParams$2($e)
});
let ZodSymbol$2 = class extends ZodType$2 {
  _parse(Ze) {
    if (this._getType(Ze) !== ZodParsedType$2.symbol) {
      const Ke = this._getOrReturnCtx(Ze);
      return addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.symbol,
        received: Ke.parsedType
      }), INVALID$2;
    }
    return OK$2(Ze.data);
  }
};
ZodSymbol$2.create = ($e) => new ZodSymbol$2({
  typeName: ZodFirstPartyTypeKind$2.ZodSymbol,
  ...processCreateParams$2($e)
});
let ZodUndefined$2 = class extends ZodType$2 {
  _parse(Ze) {
    if (this._getType(Ze) !== ZodParsedType$2.undefined) {
      const Ke = this._getOrReturnCtx(Ze);
      return addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.undefined,
        received: Ke.parsedType
      }), INVALID$2;
    }
    return OK$2(Ze.data);
  }
};
ZodUndefined$2.create = ($e) => new ZodUndefined$2({
  typeName: ZodFirstPartyTypeKind$2.ZodUndefined,
  ...processCreateParams$2($e)
});
let ZodNull$2 = class extends ZodType$2 {
  _parse(Ze) {
    if (this._getType(Ze) !== ZodParsedType$2.null) {
      const Ke = this._getOrReturnCtx(Ze);
      return addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.null,
        received: Ke.parsedType
      }), INVALID$2;
    }
    return OK$2(Ze.data);
  }
};
ZodNull$2.create = ($e) => new ZodNull$2({
  typeName: ZodFirstPartyTypeKind$2.ZodNull,
  ...processCreateParams$2($e)
});
let ZodAny$2 = class extends ZodType$2 {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(Ze) {
    return OK$2(Ze.data);
  }
};
ZodAny$2.create = ($e) => new ZodAny$2({
  typeName: ZodFirstPartyTypeKind$2.ZodAny,
  ...processCreateParams$2($e)
});
let ZodUnknown$2 = class extends ZodType$2 {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(Ze) {
    return OK$2(Ze.data);
  }
};
ZodUnknown$2.create = ($e) => new ZodUnknown$2({
  typeName: ZodFirstPartyTypeKind$2.ZodUnknown,
  ...processCreateParams$2($e)
});
let ZodNever$2 = class extends ZodType$2 {
  _parse(Ze) {
    const Fe = this._getOrReturnCtx(Ze);
    return addIssueToContext$2(Fe, {
      code: ZodIssueCode$2.invalid_type,
      expected: ZodParsedType$2.never,
      received: Fe.parsedType
    }), INVALID$2;
  }
};
ZodNever$2.create = ($e) => new ZodNever$2({
  typeName: ZodFirstPartyTypeKind$2.ZodNever,
  ...processCreateParams$2($e)
});
let ZodVoid$2 = class extends ZodType$2 {
  _parse(Ze) {
    if (this._getType(Ze) !== ZodParsedType$2.undefined) {
      const Ke = this._getOrReturnCtx(Ze);
      return addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.void,
        received: Ke.parsedType
      }), INVALID$2;
    }
    return OK$2(Ze.data);
  }
};
ZodVoid$2.create = ($e) => new ZodVoid$2({
  typeName: ZodFirstPartyTypeKind$2.ZodVoid,
  ...processCreateParams$2($e)
});
let ZodArray$2 = class mn extends ZodType$2 {
  _parse(Ze) {
    const { ctx: Fe, status: Ke } = this._processInputParams(Ze), Ve = this._def;
    if (Fe.parsedType !== ZodParsedType$2.array)
      return addIssueToContext$2(Fe, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.array,
        received: Fe.parsedType
      }), INVALID$2;
    if (Ve.exactLength !== null) {
      const Qe = Fe.data.length > Ve.exactLength.value, at = Fe.data.length < Ve.exactLength.value;
      (Qe || at) && (addIssueToContext$2(Fe, {
        code: Qe ? ZodIssueCode$2.too_big : ZodIssueCode$2.too_small,
        minimum: at ? Ve.exactLength.value : void 0,
        maximum: Qe ? Ve.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: Ve.exactLength.message
      }), Ke.dirty());
    }
    if (Ve.minLength !== null && Fe.data.length < Ve.minLength.value && (addIssueToContext$2(Fe, {
      code: ZodIssueCode$2.too_small,
      minimum: Ve.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: Ve.minLength.message
    }), Ke.dirty()), Ve.maxLength !== null && Fe.data.length > Ve.maxLength.value && (addIssueToContext$2(Fe, {
      code: ZodIssueCode$2.too_big,
      maximum: Ve.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: Ve.maxLength.message
    }), Ke.dirty()), Fe.common.async)
      return Promise.all([...Fe.data].map((Qe, at) => Ve.type._parseAsync(new ParseInputLazyPath$2(Fe, Qe, Fe.path, at)))).then((Qe) => ParseStatus$2.mergeArray(Ke, Qe));
    const Je = [...Fe.data].map((Qe, at) => Ve.type._parseSync(new ParseInputLazyPath$2(Fe, Qe, Fe.path, at)));
    return ParseStatus$2.mergeArray(Ke, Je);
  }
  get element() {
    return this._def.type;
  }
  min(Ze, Fe) {
    return new mn({
      ...this._def,
      minLength: { value: Ze, message: errorUtil$3.toString(Fe) }
    });
  }
  max(Ze, Fe) {
    return new mn({
      ...this._def,
      maxLength: { value: Ze, message: errorUtil$3.toString(Fe) }
    });
  }
  length(Ze, Fe) {
    return new mn({
      ...this._def,
      exactLength: { value: Ze, message: errorUtil$3.toString(Fe) }
    });
  }
  nonempty(Ze) {
    return this.min(1, Ze);
  }
};
ZodArray$2.create = ($e, Ze) => new ZodArray$2({
  type: $e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ZodFirstPartyTypeKind$2.ZodArray,
  ...processCreateParams$2(Ze)
});
function deepPartialify$2($e) {
  if ($e instanceof ZodObject$2) {
    const Ze = {};
    for (const Fe in $e.shape) {
      const Ke = $e.shape[Fe];
      Ze[Fe] = ZodOptional$2.create(deepPartialify$2(Ke));
    }
    return new ZodObject$2({
      ...$e._def,
      shape: () => Ze
    });
  } else
    return $e instanceof ZodArray$2 ? new ZodArray$2({
      ...$e._def,
      type: deepPartialify$2($e.element)
    }) : $e instanceof ZodOptional$2 ? ZodOptional$2.create(deepPartialify$2($e.unwrap())) : $e instanceof ZodNullable$2 ? ZodNullable$2.create(deepPartialify$2($e.unwrap())) : $e instanceof ZodTuple$2 ? ZodTuple$2.create($e.items.map((Ze) => deepPartialify$2(Ze))) : $e;
}
let ZodObject$2 = class cn extends ZodType$2 {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const Ze = this._def.shape(), Fe = util$3.objectKeys(Ze);
    return this._cached = { shape: Ze, keys: Fe };
  }
  _parse(Ze) {
    if (this._getType(Ze) !== ZodParsedType$2.object) {
      const lt = this._getOrReturnCtx(Ze);
      return addIssueToContext$2(lt, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.object,
        received: lt.parsedType
      }), INVALID$2;
    }
    const { status: Ke, ctx: Ve } = this._processInputParams(Ze), { shape: Je, keys: Qe } = this._getCached(), at = [];
    if (!(this._def.catchall instanceof ZodNever$2 && this._def.unknownKeys === "strip"))
      for (const lt in Ve.data)
        Qe.includes(lt) || at.push(lt);
    const ut = [];
    for (const lt of Qe) {
      const dt = Je[lt], bt = Ve.data[lt];
      ut.push({
        key: { status: "valid", value: lt },
        value: dt._parse(new ParseInputLazyPath$2(Ve, bt, Ve.path, lt)),
        alwaysSet: lt in Ve.data
      });
    }
    if (this._def.catchall instanceof ZodNever$2) {
      const lt = this._def.unknownKeys;
      if (lt === "passthrough")
        for (const dt of at)
          ut.push({
            key: { status: "valid", value: dt },
            value: { status: "valid", value: Ve.data[dt] }
          });
      else if (lt === "strict")
        at.length > 0 && (addIssueToContext$2(Ve, {
          code: ZodIssueCode$2.unrecognized_keys,
          keys: at
        }), Ke.dirty());
      else if (lt !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const lt = this._def.catchall;
      for (const dt of at) {
        const bt = Ve.data[dt];
        ut.push({
          key: { status: "valid", value: dt },
          value: lt._parse(
            new ParseInputLazyPath$2(Ve, bt, Ve.path, dt)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: dt in Ve.data
        });
      }
    }
    return Ve.common.async ? Promise.resolve().then(async () => {
      const lt = [];
      for (const dt of ut) {
        const bt = await dt.key;
        lt.push({
          key: bt,
          value: await dt.value,
          alwaysSet: dt.alwaysSet
        });
      }
      return lt;
    }).then((lt) => ParseStatus$2.mergeObjectSync(Ke, lt)) : ParseStatus$2.mergeObjectSync(Ke, ut);
  }
  get shape() {
    return this._def.shape();
  }
  strict(Ze) {
    return errorUtil$3.errToObj, new cn({
      ...this._def,
      unknownKeys: "strict",
      ...Ze !== void 0 ? {
        errorMap: (Fe, Ke) => {
          var Ve, Je, Qe, at;
          const ut = (Qe = (Je = (Ve = this._def).errorMap) === null || Je === void 0 ? void 0 : Je.call(Ve, Fe, Ke).message) !== null && Qe !== void 0 ? Qe : Ke.defaultError;
          return Fe.code === "unrecognized_keys" ? {
            message: (at = errorUtil$3.errToObj(Ze).message) !== null && at !== void 0 ? at : ut
          } : {
            message: ut
          };
        }
      } : {}
    });
  }
  strip() {
    return new cn({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new cn({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(Ze) {
    return new cn({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...Ze
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(Ze) {
    return new cn({
      unknownKeys: Ze._def.unknownKeys,
      catchall: Ze._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...Ze._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$2.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(Ze, Fe) {
    return this.augment({ [Ze]: Fe });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(Ze) {
    return new cn({
      ...this._def,
      catchall: Ze
    });
  }
  pick(Ze) {
    const Fe = {};
    return util$3.objectKeys(Ze).forEach((Ke) => {
      Ze[Ke] && this.shape[Ke] && (Fe[Ke] = this.shape[Ke]);
    }), new cn({
      ...this._def,
      shape: () => Fe
    });
  }
  omit(Ze) {
    const Fe = {};
    return util$3.objectKeys(this.shape).forEach((Ke) => {
      Ze[Ke] || (Fe[Ke] = this.shape[Ke]);
    }), new cn({
      ...this._def,
      shape: () => Fe
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$2(this);
  }
  partial(Ze) {
    const Fe = {};
    return util$3.objectKeys(this.shape).forEach((Ke) => {
      const Ve = this.shape[Ke];
      Ze && !Ze[Ke] ? Fe[Ke] = Ve : Fe[Ke] = Ve.optional();
    }), new cn({
      ...this._def,
      shape: () => Fe
    });
  }
  required(Ze) {
    const Fe = {};
    return util$3.objectKeys(this.shape).forEach((Ke) => {
      if (Ze && !Ze[Ke])
        Fe[Ke] = this.shape[Ke];
      else {
        let Je = this.shape[Ke];
        for (; Je instanceof ZodOptional$2; )
          Je = Je._def.innerType;
        Fe[Ke] = Je;
      }
    }), new cn({
      ...this._def,
      shape: () => Fe
    });
  }
  keyof() {
    return createZodEnum$2(util$3.objectKeys(this.shape));
  }
};
ZodObject$2.create = ($e, Ze) => new ZodObject$2({
  shape: () => $e,
  unknownKeys: "strip",
  catchall: ZodNever$2.create(),
  typeName: ZodFirstPartyTypeKind$2.ZodObject,
  ...processCreateParams$2(Ze)
});
ZodObject$2.strictCreate = ($e, Ze) => new ZodObject$2({
  shape: () => $e,
  unknownKeys: "strict",
  catchall: ZodNever$2.create(),
  typeName: ZodFirstPartyTypeKind$2.ZodObject,
  ...processCreateParams$2(Ze)
});
ZodObject$2.lazycreate = ($e, Ze) => new ZodObject$2({
  shape: $e,
  unknownKeys: "strip",
  catchall: ZodNever$2.create(),
  typeName: ZodFirstPartyTypeKind$2.ZodObject,
  ...processCreateParams$2(Ze)
});
let ZodUnion$2 = class extends ZodType$2 {
  _parse(Ze) {
    const { ctx: Fe } = this._processInputParams(Ze), Ke = this._def.options;
    function Ve(Je) {
      for (const at of Je)
        if (at.result.status === "valid")
          return at.result;
      for (const at of Je)
        if (at.result.status === "dirty")
          return Fe.common.issues.push(...at.ctx.common.issues), at.result;
      const Qe = Je.map((at) => new ZodError$4(at.ctx.common.issues));
      return addIssueToContext$2(Fe, {
        code: ZodIssueCode$2.invalid_union,
        unionErrors: Qe
      }), INVALID$2;
    }
    if (Fe.common.async)
      return Promise.all(Ke.map(async (Je) => {
        const Qe = {
          ...Fe,
          common: {
            ...Fe.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await Je._parseAsync({
            data: Fe.data,
            path: Fe.path,
            parent: Qe
          }),
          ctx: Qe
        };
      })).then(Ve);
    {
      let Je;
      const Qe = [];
      for (const ut of Ke) {
        const lt = {
          ...Fe,
          common: {
            ...Fe.common,
            issues: []
          },
          parent: null
        }, dt = ut._parseSync({
          data: Fe.data,
          path: Fe.path,
          parent: lt
        });
        if (dt.status === "valid")
          return dt;
        dt.status === "dirty" && !Je && (Je = { result: dt, ctx: lt }), lt.common.issues.length && Qe.push(lt.common.issues);
      }
      if (Je)
        return Fe.common.issues.push(...Je.ctx.common.issues), Je.result;
      const at = Qe.map((ut) => new ZodError$4(ut));
      return addIssueToContext$2(Fe, {
        code: ZodIssueCode$2.invalid_union,
        unionErrors: at
      }), INVALID$2;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$2.create = ($e, Ze) => new ZodUnion$2({
  options: $e,
  typeName: ZodFirstPartyTypeKind$2.ZodUnion,
  ...processCreateParams$2(Ze)
});
const getDiscriminator$2 = ($e) => $e instanceof ZodLazy$2 ? getDiscriminator$2($e.schema) : $e instanceof ZodEffects$2 ? getDiscriminator$2($e.innerType()) : $e instanceof ZodLiteral$2 ? [$e.value] : $e instanceof ZodEnum$2 ? $e.options : $e instanceof ZodNativeEnum$2 ? Object.keys($e.enum) : $e instanceof ZodDefault$2 ? getDiscriminator$2($e._def.innerType) : $e instanceof ZodUndefined$2 ? [void 0] : $e instanceof ZodNull$2 ? [null] : null;
let ZodDiscriminatedUnion$2 = class Bn extends ZodType$2 {
  _parse(Ze) {
    const { ctx: Fe } = this._processInputParams(Ze);
    if (Fe.parsedType !== ZodParsedType$2.object)
      return addIssueToContext$2(Fe, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.object,
        received: Fe.parsedType
      }), INVALID$2;
    const Ke = this.discriminator, Ve = Fe.data[Ke], Je = this.optionsMap.get(Ve);
    return Je ? Fe.common.async ? Je._parseAsync({
      data: Fe.data,
      path: Fe.path,
      parent: Fe
    }) : Je._parseSync({
      data: Fe.data,
      path: Fe.path,
      parent: Fe
    }) : (addIssueToContext$2(Fe, {
      code: ZodIssueCode$2.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [Ke]
    }), INVALID$2);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(Ze, Fe, Ke) {
    const Ve = /* @__PURE__ */ new Map();
    for (const Je of Fe) {
      const Qe = getDiscriminator$2(Je.shape[Ze]);
      if (!Qe)
        throw new Error(`A discriminator value for key \`${Ze}\` could not be extracted from all schema options`);
      for (const at of Qe) {
        if (Ve.has(at))
          throw new Error(`Discriminator property ${String(Ze)} has duplicate value ${String(at)}`);
        Ve.set(at, Je);
      }
    }
    return new Bn({
      typeName: ZodFirstPartyTypeKind$2.ZodDiscriminatedUnion,
      discriminator: Ze,
      options: Fe,
      optionsMap: Ve,
      ...processCreateParams$2(Ke)
    });
  }
};
function mergeValues$2($e, Ze) {
  const Fe = getParsedType$2($e), Ke = getParsedType$2(Ze);
  if ($e === Ze)
    return { valid: !0, data: $e };
  if (Fe === ZodParsedType$2.object && Ke === ZodParsedType$2.object) {
    const Ve = util$3.objectKeys(Ze), Je = util$3.objectKeys($e).filter((at) => Ve.indexOf(at) !== -1), Qe = { ...$e, ...Ze };
    for (const at of Je) {
      const ut = mergeValues$2($e[at], Ze[at]);
      if (!ut.valid)
        return { valid: !1 };
      Qe[at] = ut.data;
    }
    return { valid: !0, data: Qe };
  } else if (Fe === ZodParsedType$2.array && Ke === ZodParsedType$2.array) {
    if ($e.length !== Ze.length)
      return { valid: !1 };
    const Ve = [];
    for (let Je = 0; Je < $e.length; Je++) {
      const Qe = $e[Je], at = Ze[Je], ut = mergeValues$2(Qe, at);
      if (!ut.valid)
        return { valid: !1 };
      Ve.push(ut.data);
    }
    return { valid: !0, data: Ve };
  } else
    return Fe === ZodParsedType$2.date && Ke === ZodParsedType$2.date && +$e == +Ze ? { valid: !0, data: $e } : { valid: !1 };
}
let ZodIntersection$2 = class extends ZodType$2 {
  _parse(Ze) {
    const { status: Fe, ctx: Ke } = this._processInputParams(Ze), Ve = (Je, Qe) => {
      if (isAborted$2(Je) || isAborted$2(Qe))
        return INVALID$2;
      const at = mergeValues$2(Je.value, Qe.value);
      return at.valid ? ((isDirty$2(Je) || isDirty$2(Qe)) && Fe.dirty(), { status: Fe.value, value: at.data }) : (addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.invalid_intersection_types
      }), INVALID$2);
    };
    return Ke.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: Ke.data,
        path: Ke.path,
        parent: Ke
      }),
      this._def.right._parseAsync({
        data: Ke.data,
        path: Ke.path,
        parent: Ke
      })
    ]).then(([Je, Qe]) => Ve(Je, Qe)) : Ve(this._def.left._parseSync({
      data: Ke.data,
      path: Ke.path,
      parent: Ke
    }), this._def.right._parseSync({
      data: Ke.data,
      path: Ke.path,
      parent: Ke
    }));
  }
};
ZodIntersection$2.create = ($e, Ze, Fe) => new ZodIntersection$2({
  left: $e,
  right: Ze,
  typeName: ZodFirstPartyTypeKind$2.ZodIntersection,
  ...processCreateParams$2(Fe)
});
let ZodTuple$2 = class Nn extends ZodType$2 {
  _parse(Ze) {
    const { status: Fe, ctx: Ke } = this._processInputParams(Ze);
    if (Ke.parsedType !== ZodParsedType$2.array)
      return addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.array,
        received: Ke.parsedType
      }), INVALID$2;
    if (Ke.data.length < this._def.items.length)
      return addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), INVALID$2;
    !this._def.rest && Ke.data.length > this._def.items.length && (addIssueToContext$2(Ke, {
      code: ZodIssueCode$2.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), Fe.dirty());
    const Je = [...Ke.data].map((Qe, at) => {
      const ut = this._def.items[at] || this._def.rest;
      return ut ? ut._parse(new ParseInputLazyPath$2(Ke, Qe, Ke.path, at)) : null;
    }).filter((Qe) => !!Qe);
    return Ke.common.async ? Promise.all(Je).then((Qe) => ParseStatus$2.mergeArray(Fe, Qe)) : ParseStatus$2.mergeArray(Fe, Je);
  }
  get items() {
    return this._def.items;
  }
  rest(Ze) {
    return new Nn({
      ...this._def,
      rest: Ze
    });
  }
};
ZodTuple$2.create = ($e, Ze) => {
  if (!Array.isArray($e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ZodTuple$2({
    items: $e,
    typeName: ZodFirstPartyTypeKind$2.ZodTuple,
    rest: null,
    ...processCreateParams$2(Ze)
  });
};
let ZodRecord$2 = class En extends ZodType$2 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(Ze) {
    const { status: Fe, ctx: Ke } = this._processInputParams(Ze);
    if (Ke.parsedType !== ZodParsedType$2.object)
      return addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.object,
        received: Ke.parsedType
      }), INVALID$2;
    const Ve = [], Je = this._def.keyType, Qe = this._def.valueType;
    for (const at in Ke.data)
      Ve.push({
        key: Je._parse(new ParseInputLazyPath$2(Ke, at, Ke.path, at)),
        value: Qe._parse(new ParseInputLazyPath$2(Ke, Ke.data[at], Ke.path, at))
      });
    return Ke.common.async ? ParseStatus$2.mergeObjectAsync(Fe, Ve) : ParseStatus$2.mergeObjectSync(Fe, Ve);
  }
  get element() {
    return this._def.valueType;
  }
  static create(Ze, Fe, Ke) {
    return Fe instanceof ZodType$2 ? new En({
      keyType: Ze,
      valueType: Fe,
      typeName: ZodFirstPartyTypeKind$2.ZodRecord,
      ...processCreateParams$2(Ke)
    }) : new En({
      keyType: ZodString$2.create(),
      valueType: Ze,
      typeName: ZodFirstPartyTypeKind$2.ZodRecord,
      ...processCreateParams$2(Fe)
    });
  }
}, ZodMap$2 = class extends ZodType$2 {
  _parse(Ze) {
    const { status: Fe, ctx: Ke } = this._processInputParams(Ze);
    if (Ke.parsedType !== ZodParsedType$2.map)
      return addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.map,
        received: Ke.parsedType
      }), INVALID$2;
    const Ve = this._def.keyType, Je = this._def.valueType, Qe = [...Ke.data.entries()].map(([at, ut], lt) => ({
      key: Ve._parse(new ParseInputLazyPath$2(Ke, at, Ke.path, [lt, "key"])),
      value: Je._parse(new ParseInputLazyPath$2(Ke, ut, Ke.path, [lt, "value"]))
    }));
    if (Ke.common.async) {
      const at = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const ut of Qe) {
          const lt = await ut.key, dt = await ut.value;
          if (lt.status === "aborted" || dt.status === "aborted")
            return INVALID$2;
          (lt.status === "dirty" || dt.status === "dirty") && Fe.dirty(), at.set(lt.value, dt.value);
        }
        return { status: Fe.value, value: at };
      });
    } else {
      const at = /* @__PURE__ */ new Map();
      for (const ut of Qe) {
        const lt = ut.key, dt = ut.value;
        if (lt.status === "aborted" || dt.status === "aborted")
          return INVALID$2;
        (lt.status === "dirty" || dt.status === "dirty") && Fe.dirty(), at.set(lt.value, dt.value);
      }
      return { status: Fe.value, value: at };
    }
  }
};
ZodMap$2.create = ($e, Ze, Fe) => new ZodMap$2({
  valueType: Ze,
  keyType: $e,
  typeName: ZodFirstPartyTypeKind$2.ZodMap,
  ...processCreateParams$2(Fe)
});
let ZodSet$2 = class Sn extends ZodType$2 {
  _parse(Ze) {
    const { status: Fe, ctx: Ke } = this._processInputParams(Ze);
    if (Ke.parsedType !== ZodParsedType$2.set)
      return addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.set,
        received: Ke.parsedType
      }), INVALID$2;
    const Ve = this._def;
    Ve.minSize !== null && Ke.data.size < Ve.minSize.value && (addIssueToContext$2(Ke, {
      code: ZodIssueCode$2.too_small,
      minimum: Ve.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: Ve.minSize.message
    }), Fe.dirty()), Ve.maxSize !== null && Ke.data.size > Ve.maxSize.value && (addIssueToContext$2(Ke, {
      code: ZodIssueCode$2.too_big,
      maximum: Ve.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: Ve.maxSize.message
    }), Fe.dirty());
    const Je = this._def.valueType;
    function Qe(ut) {
      const lt = /* @__PURE__ */ new Set();
      for (const dt of ut) {
        if (dt.status === "aborted")
          return INVALID$2;
        dt.status === "dirty" && Fe.dirty(), lt.add(dt.value);
      }
      return { status: Fe.value, value: lt };
    }
    const at = [...Ke.data.values()].map((ut, lt) => Je._parse(new ParseInputLazyPath$2(Ke, ut, Ke.path, lt)));
    return Ke.common.async ? Promise.all(at).then((ut) => Qe(ut)) : Qe(at);
  }
  min(Ze, Fe) {
    return new Sn({
      ...this._def,
      minSize: { value: Ze, message: errorUtil$3.toString(Fe) }
    });
  }
  max(Ze, Fe) {
    return new Sn({
      ...this._def,
      maxSize: { value: Ze, message: errorUtil$3.toString(Fe) }
    });
  }
  size(Ze, Fe) {
    return this.min(Ze, Fe).max(Ze, Fe);
  }
  nonempty(Ze) {
    return this.min(1, Ze);
  }
};
ZodSet$2.create = ($e, Ze) => new ZodSet$2({
  valueType: $e,
  minSize: null,
  maxSize: null,
  typeName: ZodFirstPartyTypeKind$2.ZodSet,
  ...processCreateParams$2(Ze)
});
let ZodFunction$2 = class _n extends ZodType$2 {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(Ze) {
    const { ctx: Fe } = this._processInputParams(Ze);
    if (Fe.parsedType !== ZodParsedType$2.function)
      return addIssueToContext$2(Fe, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.function,
        received: Fe.parsedType
      }), INVALID$2;
    function Ke(at, ut) {
      return makeIssue$2({
        data: at,
        path: Fe.path,
        errorMaps: [
          Fe.common.contextualErrorMap,
          Fe.schemaErrorMap,
          getErrorMap$3(),
          errorMap$3
        ].filter((lt) => !!lt),
        issueData: {
          code: ZodIssueCode$2.invalid_arguments,
          argumentsError: ut
        }
      });
    }
    function Ve(at, ut) {
      return makeIssue$2({
        data: at,
        path: Fe.path,
        errorMaps: [
          Fe.common.contextualErrorMap,
          Fe.schemaErrorMap,
          getErrorMap$3(),
          errorMap$3
        ].filter((lt) => !!lt),
        issueData: {
          code: ZodIssueCode$2.invalid_return_type,
          returnTypeError: ut
        }
      });
    }
    const Je = { errorMap: Fe.common.contextualErrorMap }, Qe = Fe.data;
    return this._def.returns instanceof ZodPromise$2 ? OK$2(async (...at) => {
      const ut = new ZodError$4([]), lt = await this._def.args.parseAsync(at, Je).catch(($t) => {
        throw ut.addIssue(Ke(at, $t)), ut;
      }), dt = await Qe(...lt);
      return await this._def.returns._def.type.parseAsync(dt, Je).catch(($t) => {
        throw ut.addIssue(Ve(dt, $t)), ut;
      });
    }) : OK$2((...at) => {
      const ut = this._def.args.safeParse(at, Je);
      if (!ut.success)
        throw new ZodError$4([Ke(at, ut.error)]);
      const lt = Qe(...ut.data), dt = this._def.returns.safeParse(lt, Je);
      if (!dt.success)
        throw new ZodError$4([Ve(lt, dt.error)]);
      return dt.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...Ze) {
    return new _n({
      ...this._def,
      args: ZodTuple$2.create(Ze).rest(ZodUnknown$2.create())
    });
  }
  returns(Ze) {
    return new _n({
      ...this._def,
      returns: Ze
    });
  }
  implement(Ze) {
    return this.parse(Ze);
  }
  strictImplement(Ze) {
    return this.parse(Ze);
  }
  static create(Ze, Fe, Ke) {
    return new _n({
      args: Ze || ZodTuple$2.create([]).rest(ZodUnknown$2.create()),
      returns: Fe || ZodUnknown$2.create(),
      typeName: ZodFirstPartyTypeKind$2.ZodFunction,
      ...processCreateParams$2(Ke)
    });
  }
}, ZodLazy$2 = class extends ZodType$2 {
  get schema() {
    return this._def.getter();
  }
  _parse(Ze) {
    const { ctx: Fe } = this._processInputParams(Ze);
    return this._def.getter()._parse({ data: Fe.data, path: Fe.path, parent: Fe });
  }
};
ZodLazy$2.create = ($e, Ze) => new ZodLazy$2({
  getter: $e,
  typeName: ZodFirstPartyTypeKind$2.ZodLazy,
  ...processCreateParams$2(Ze)
});
let ZodLiteral$2 = class extends ZodType$2 {
  _parse(Ze) {
    if (Ze.data !== this._def.value) {
      const Fe = this._getOrReturnCtx(Ze);
      return addIssueToContext$2(Fe, {
        received: Fe.data,
        code: ZodIssueCode$2.invalid_literal,
        expected: this._def.value
      }), INVALID$2;
    }
    return { status: "valid", value: Ze.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$2.create = ($e, Ze) => new ZodLiteral$2({
  value: $e,
  typeName: ZodFirstPartyTypeKind$2.ZodLiteral,
  ...processCreateParams$2(Ze)
});
function createZodEnum$2($e, Ze) {
  return new ZodEnum$2({
    values: $e,
    typeName: ZodFirstPartyTypeKind$2.ZodEnum,
    ...processCreateParams$2(Ze)
  });
}
let ZodEnum$2 = class Tn extends ZodType$2 {
  _parse(Ze) {
    if (typeof Ze.data != "string") {
      const Fe = this._getOrReturnCtx(Ze), Ke = this._def.values;
      return addIssueToContext$2(Fe, {
        expected: util$3.joinValues(Ke),
        received: Fe.parsedType,
        code: ZodIssueCode$2.invalid_type
      }), INVALID$2;
    }
    if (this._def.values.indexOf(Ze.data) === -1) {
      const Fe = this._getOrReturnCtx(Ze), Ke = this._def.values;
      return addIssueToContext$2(Fe, {
        received: Fe.data,
        code: ZodIssueCode$2.invalid_enum_value,
        options: Ke
      }), INVALID$2;
    }
    return OK$2(Ze.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const Ze = {};
    for (const Fe of this._def.values)
      Ze[Fe] = Fe;
    return Ze;
  }
  get Values() {
    const Ze = {};
    for (const Fe of this._def.values)
      Ze[Fe] = Fe;
    return Ze;
  }
  get Enum() {
    const Ze = {};
    for (const Fe of this._def.values)
      Ze[Fe] = Fe;
    return Ze;
  }
  extract(Ze) {
    return Tn.create(Ze);
  }
  exclude(Ze) {
    return Tn.create(this.options.filter((Fe) => !Ze.includes(Fe)));
  }
};
ZodEnum$2.create = createZodEnum$2;
let ZodNativeEnum$2 = class extends ZodType$2 {
  _parse(Ze) {
    const Fe = util$3.getValidEnumValues(this._def.values), Ke = this._getOrReturnCtx(Ze);
    if (Ke.parsedType !== ZodParsedType$2.string && Ke.parsedType !== ZodParsedType$2.number) {
      const Ve = util$3.objectValues(Fe);
      return addIssueToContext$2(Ke, {
        expected: util$3.joinValues(Ve),
        received: Ke.parsedType,
        code: ZodIssueCode$2.invalid_type
      }), INVALID$2;
    }
    if (Fe.indexOf(Ze.data) === -1) {
      const Ve = util$3.objectValues(Fe);
      return addIssueToContext$2(Ke, {
        received: Ke.data,
        code: ZodIssueCode$2.invalid_enum_value,
        options: Ve
      }), INVALID$2;
    }
    return OK$2(Ze.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum$2.create = ($e, Ze) => new ZodNativeEnum$2({
  values: $e,
  typeName: ZodFirstPartyTypeKind$2.ZodNativeEnum,
  ...processCreateParams$2(Ze)
});
let ZodPromise$2 = class extends ZodType$2 {
  unwrap() {
    return this._def.type;
  }
  _parse(Ze) {
    const { ctx: Fe } = this._processInputParams(Ze);
    if (Fe.parsedType !== ZodParsedType$2.promise && Fe.common.async === !1)
      return addIssueToContext$2(Fe, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.promise,
        received: Fe.parsedType
      }), INVALID$2;
    const Ke = Fe.parsedType === ZodParsedType$2.promise ? Fe.data : Promise.resolve(Fe.data);
    return OK$2(Ke.then((Ve) => this._def.type.parseAsync(Ve, {
      path: Fe.path,
      errorMap: Fe.common.contextualErrorMap
    })));
  }
};
ZodPromise$2.create = ($e, Ze) => new ZodPromise$2({
  type: $e,
  typeName: ZodFirstPartyTypeKind$2.ZodPromise,
  ...processCreateParams$2(Ze)
});
let ZodEffects$2 = class extends ZodType$2 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$2.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(Ze) {
    const { status: Fe, ctx: Ke } = this._processInputParams(Ze), Ve = this._def.effect || null;
    if (Ve.type === "preprocess") {
      const Qe = Ve.transform(Ke.data);
      return Ke.common.async ? Promise.resolve(Qe).then((at) => this._def.schema._parseAsync({
        data: at,
        path: Ke.path,
        parent: Ke
      })) : this._def.schema._parseSync({
        data: Qe,
        path: Ke.path,
        parent: Ke
      });
    }
    const Je = {
      addIssue: (Qe) => {
        addIssueToContext$2(Ke, Qe), Qe.fatal ? Fe.abort() : Fe.dirty();
      },
      get path() {
        return Ke.path;
      }
    };
    if (Je.addIssue = Je.addIssue.bind(Je), Ve.type === "refinement") {
      const Qe = (at) => {
        const ut = Ve.refinement(at, Je);
        if (Ke.common.async)
          return Promise.resolve(ut);
        if (ut instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return at;
      };
      if (Ke.common.async === !1) {
        const at = this._def.schema._parseSync({
          data: Ke.data,
          path: Ke.path,
          parent: Ke
        });
        return at.status === "aborted" ? INVALID$2 : (at.status === "dirty" && Fe.dirty(), Qe(at.value), { status: Fe.value, value: at.value });
      } else
        return this._def.schema._parseAsync({ data: Ke.data, path: Ke.path, parent: Ke }).then((at) => at.status === "aborted" ? INVALID$2 : (at.status === "dirty" && Fe.dirty(), Qe(at.value).then(() => ({ status: Fe.value, value: at.value }))));
    }
    if (Ve.type === "transform")
      if (Ke.common.async === !1) {
        const Qe = this._def.schema._parseSync({
          data: Ke.data,
          path: Ke.path,
          parent: Ke
        });
        if (!isValid$2(Qe))
          return Qe;
        const at = Ve.transform(Qe.value, Je);
        if (at instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: Fe.value, value: at };
      } else
        return this._def.schema._parseAsync({ data: Ke.data, path: Ke.path, parent: Ke }).then((Qe) => isValid$2(Qe) ? Promise.resolve(Ve.transform(Qe.value, Je)).then((at) => ({ status: Fe.value, value: at })) : Qe);
    util$3.assertNever(Ve);
  }
};
ZodEffects$2.create = ($e, Ze, Fe) => new ZodEffects$2({
  schema: $e,
  typeName: ZodFirstPartyTypeKind$2.ZodEffects,
  effect: Ze,
  ...processCreateParams$2(Fe)
});
ZodEffects$2.createWithPreprocess = ($e, Ze, Fe) => new ZodEffects$2({
  schema: Ze,
  effect: { type: "preprocess", transform: $e },
  typeName: ZodFirstPartyTypeKind$2.ZodEffects,
  ...processCreateParams$2(Fe)
});
let ZodOptional$2 = class extends ZodType$2 {
  _parse(Ze) {
    return this._getType(Ze) === ZodParsedType$2.undefined ? OK$2(void 0) : this._def.innerType._parse(Ze);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$2.create = ($e, Ze) => new ZodOptional$2({
  innerType: $e,
  typeName: ZodFirstPartyTypeKind$2.ZodOptional,
  ...processCreateParams$2(Ze)
});
let ZodNullable$2 = class extends ZodType$2 {
  _parse(Ze) {
    return this._getType(Ze) === ZodParsedType$2.null ? OK$2(null) : this._def.innerType._parse(Ze);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$2.create = ($e, Ze) => new ZodNullable$2({
  innerType: $e,
  typeName: ZodFirstPartyTypeKind$2.ZodNullable,
  ...processCreateParams$2(Ze)
});
let ZodDefault$2 = class extends ZodType$2 {
  _parse(Ze) {
    const { ctx: Fe } = this._processInputParams(Ze);
    let Ke = Fe.data;
    return Fe.parsedType === ZodParsedType$2.undefined && (Ke = this._def.defaultValue()), this._def.innerType._parse({
      data: Ke,
      path: Fe.path,
      parent: Fe
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$2.create = ($e, Ze) => new ZodDefault$2({
  innerType: $e,
  typeName: ZodFirstPartyTypeKind$2.ZodDefault,
  defaultValue: typeof Ze.default == "function" ? Ze.default : () => Ze.default,
  ...processCreateParams$2(Ze)
});
let ZodCatch$2 = class extends ZodType$2 {
  _parse(Ze) {
    const { ctx: Fe } = this._processInputParams(Ze), Ke = {
      ...Fe,
      common: {
        ...Fe.common,
        issues: []
      }
    }, Ve = this._def.innerType._parse({
      data: Ke.data,
      path: Ke.path,
      parent: {
        ...Ke
      }
    });
    return isAsync$2(Ve) ? Ve.then((Je) => ({
      status: "valid",
      value: Je.status === "valid" ? Je.value : this._def.catchValue({
        get error() {
          return new ZodError$4(Ke.common.issues);
        },
        input: Ke.data
      })
    })) : {
      status: "valid",
      value: Ve.status === "valid" ? Ve.value : this._def.catchValue({
        get error() {
          return new ZodError$4(Ke.common.issues);
        },
        input: Ke.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$2.create = ($e, Ze) => new ZodCatch$2({
  innerType: $e,
  typeName: ZodFirstPartyTypeKind$2.ZodCatch,
  catchValue: typeof Ze.catch == "function" ? Ze.catch : () => Ze.catch,
  ...processCreateParams$2(Ze)
});
let ZodNaN$2 = class extends ZodType$2 {
  _parse(Ze) {
    if (this._getType(Ze) !== ZodParsedType$2.nan) {
      const Ke = this._getOrReturnCtx(Ze);
      return addIssueToContext$2(Ke, {
        code: ZodIssueCode$2.invalid_type,
        expected: ZodParsedType$2.nan,
        received: Ke.parsedType
      }), INVALID$2;
    }
    return { status: "valid", value: Ze.data };
  }
};
ZodNaN$2.create = ($e) => new ZodNaN$2({
  typeName: ZodFirstPartyTypeKind$2.ZodNaN,
  ...processCreateParams$2($e)
});
const BRAND$2 = Symbol("zod_brand");
let ZodBranded$2 = class extends ZodType$2 {
  _parse(Ze) {
    const { ctx: Fe } = this._processInputParams(Ze), Ke = Fe.data;
    return this._def.type._parse({
      data: Ke,
      path: Fe.path,
      parent: Fe
    });
  }
  unwrap() {
    return this._def.type;
  }
}, ZodPipeline$2 = class Ln extends ZodType$2 {
  _parse(Ze) {
    const { status: Fe, ctx: Ke } = this._processInputParams(Ze);
    if (Ke.common.async)
      return (async () => {
        const Je = await this._def.in._parseAsync({
          data: Ke.data,
          path: Ke.path,
          parent: Ke
        });
        return Je.status === "aborted" ? INVALID$2 : Je.status === "dirty" ? (Fe.dirty(), DIRTY$2(Je.value)) : this._def.out._parseAsync({
          data: Je.value,
          path: Ke.path,
          parent: Ke
        });
      })();
    {
      const Ve = this._def.in._parseSync({
        data: Ke.data,
        path: Ke.path,
        parent: Ke
      });
      return Ve.status === "aborted" ? INVALID$2 : Ve.status === "dirty" ? (Fe.dirty(), {
        status: "dirty",
        value: Ve.value
      }) : this._def.out._parseSync({
        data: Ve.value,
        path: Ke.path,
        parent: Ke
      });
    }
  }
  static create(Ze, Fe) {
    return new Ln({
      in: Ze,
      out: Fe,
      typeName: ZodFirstPartyTypeKind$2.ZodPipeline
    });
  }
};
const custom$2 = ($e, Ze = {}, Fe) => $e ? ZodAny$2.create().superRefine((Ke, Ve) => {
  var Je, Qe;
  if (!$e(Ke)) {
    const at = typeof Ze == "function" ? Ze(Ke) : typeof Ze == "string" ? { message: Ze } : Ze, ut = (Qe = (Je = at.fatal) !== null && Je !== void 0 ? Je : Fe) !== null && Qe !== void 0 ? Qe : !0, lt = typeof at == "string" ? { message: at } : at;
    Ve.addIssue({ code: "custom", ...lt, fatal: ut });
  }
}) : ZodAny$2.create(), late$2 = {
  object: ZodObject$2.lazycreate
};
var ZodFirstPartyTypeKind$2;
(function($e) {
  $e.ZodString = "ZodString", $e.ZodNumber = "ZodNumber", $e.ZodNaN = "ZodNaN", $e.ZodBigInt = "ZodBigInt", $e.ZodBoolean = "ZodBoolean", $e.ZodDate = "ZodDate", $e.ZodSymbol = "ZodSymbol", $e.ZodUndefined = "ZodUndefined", $e.ZodNull = "ZodNull", $e.ZodAny = "ZodAny", $e.ZodUnknown = "ZodUnknown", $e.ZodNever = "ZodNever", $e.ZodVoid = "ZodVoid", $e.ZodArray = "ZodArray", $e.ZodObject = "ZodObject", $e.ZodUnion = "ZodUnion", $e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", $e.ZodIntersection = "ZodIntersection", $e.ZodTuple = "ZodTuple", $e.ZodRecord = "ZodRecord", $e.ZodMap = "ZodMap", $e.ZodSet = "ZodSet", $e.ZodFunction = "ZodFunction", $e.ZodLazy = "ZodLazy", $e.ZodLiteral = "ZodLiteral", $e.ZodEnum = "ZodEnum", $e.ZodEffects = "ZodEffects", $e.ZodNativeEnum = "ZodNativeEnum", $e.ZodOptional = "ZodOptional", $e.ZodNullable = "ZodNullable", $e.ZodDefault = "ZodDefault", $e.ZodCatch = "ZodCatch", $e.ZodPromise = "ZodPromise", $e.ZodBranded = "ZodBranded", $e.ZodPipeline = "ZodPipeline";
})(ZodFirstPartyTypeKind$2 || (ZodFirstPartyTypeKind$2 = {}));
const instanceOfType$2 = ($e, Ze = {
  message: `Input not instance of ${$e.name}`
}) => custom$2((Fe) => Fe instanceof $e, Ze), stringType$2 = ZodString$2.create, numberType$2 = ZodNumber$2.create, nanType$2 = ZodNaN$2.create, bigIntType$2 = ZodBigInt$2.create, booleanType$2 = ZodBoolean$2.create, dateType$2 = ZodDate$2.create, symbolType$2 = ZodSymbol$2.create, undefinedType$2 = ZodUndefined$2.create, nullType$2 = ZodNull$2.create, anyType$2 = ZodAny$2.create, unknownType$2 = ZodUnknown$2.create, neverType$2 = ZodNever$2.create, voidType$2 = ZodVoid$2.create, arrayType$2 = ZodArray$2.create, objectType$2 = ZodObject$2.create, strictObjectType$2 = ZodObject$2.strictCreate, unionType$2 = ZodUnion$2.create, discriminatedUnionType$2 = ZodDiscriminatedUnion$2.create, intersectionType$2 = ZodIntersection$2.create, tupleType$2 = ZodTuple$2.create, recordType$2 = ZodRecord$2.create, mapType$2 = ZodMap$2.create, setType$2 = ZodSet$2.create, functionType$2 = ZodFunction$2.create, lazyType$2 = ZodLazy$2.create, literalType$2 = ZodLiteral$2.create, enumType$2 = ZodEnum$2.create, nativeEnumType$2 = ZodNativeEnum$2.create, promiseType$2 = ZodPromise$2.create, effectsType$2 = ZodEffects$2.create, optionalType$2 = ZodOptional$2.create, nullableType$2 = ZodNullable$2.create, preprocessType$2 = ZodEffects$2.createWithPreprocess, pipelineType$2 = ZodPipeline$2.create, ostring$2 = () => stringType$2().optional(), onumber$2 = () => numberType$2().optional(), oboolean$2 = () => booleanType$2().optional(), coerce$2 = {
  string: ($e) => ZodString$2.create({ ...$e, coerce: !0 }),
  number: ($e) => ZodNumber$2.create({ ...$e, coerce: !0 }),
  boolean: ($e) => ZodBoolean$2.create({
    ...$e,
    coerce: !0
  }),
  bigint: ($e) => ZodBigInt$2.create({ ...$e, coerce: !0 }),
  date: ($e) => ZodDate$2.create({ ...$e, coerce: !0 })
}, NEVER$2 = INVALID$2;
var z$d = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap$3,
  setErrorMap: setErrorMap$3,
  getErrorMap: getErrorMap$3,
  makeIssue: makeIssue$2,
  EMPTY_PATH: EMPTY_PATH$2,
  addIssueToContext: addIssueToContext$2,
  ParseStatus: ParseStatus$2,
  INVALID: INVALID$2,
  DIRTY: DIRTY$2,
  OK: OK$2,
  isAborted: isAborted$2,
  isDirty: isDirty$2,
  isValid: isValid$2,
  isAsync: isAsync$2,
  get util() {
    return util$3;
  },
  get objectUtil() {
    return objectUtil$2;
  },
  ZodParsedType: ZodParsedType$2,
  getParsedType: getParsedType$2,
  ZodType: ZodType$2,
  ZodString: ZodString$2,
  ZodNumber: ZodNumber$2,
  ZodBigInt: ZodBigInt$2,
  ZodBoolean: ZodBoolean$2,
  ZodDate: ZodDate$2,
  ZodSymbol: ZodSymbol$2,
  ZodUndefined: ZodUndefined$2,
  ZodNull: ZodNull$2,
  ZodAny: ZodAny$2,
  ZodUnknown: ZodUnknown$2,
  ZodNever: ZodNever$2,
  ZodVoid: ZodVoid$2,
  ZodArray: ZodArray$2,
  ZodObject: ZodObject$2,
  ZodUnion: ZodUnion$2,
  ZodDiscriminatedUnion: ZodDiscriminatedUnion$2,
  ZodIntersection: ZodIntersection$2,
  ZodTuple: ZodTuple$2,
  ZodRecord: ZodRecord$2,
  ZodMap: ZodMap$2,
  ZodSet: ZodSet$2,
  ZodFunction: ZodFunction$2,
  ZodLazy: ZodLazy$2,
  ZodLiteral: ZodLiteral$2,
  ZodEnum: ZodEnum$2,
  ZodNativeEnum: ZodNativeEnum$2,
  ZodPromise: ZodPromise$2,
  ZodEffects: ZodEffects$2,
  ZodTransformer: ZodEffects$2,
  ZodOptional: ZodOptional$2,
  ZodNullable: ZodNullable$2,
  ZodDefault: ZodDefault$2,
  ZodCatch: ZodCatch$2,
  ZodNaN: ZodNaN$2,
  BRAND: BRAND$2,
  ZodBranded: ZodBranded$2,
  ZodPipeline: ZodPipeline$2,
  custom: custom$2,
  Schema: ZodType$2,
  ZodSchema: ZodType$2,
  late: late$2,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind$2;
  },
  coerce: coerce$2,
  any: anyType$2,
  array: arrayType$2,
  bigint: bigIntType$2,
  boolean: booleanType$2,
  date: dateType$2,
  discriminatedUnion: discriminatedUnionType$2,
  effect: effectsType$2,
  enum: enumType$2,
  function: functionType$2,
  instanceof: instanceOfType$2,
  intersection: intersectionType$2,
  lazy: lazyType$2,
  literal: literalType$2,
  map: mapType$2,
  nan: nanType$2,
  nativeEnum: nativeEnumType$2,
  never: neverType$2,
  null: nullType$2,
  nullable: nullableType$2,
  number: numberType$2,
  object: objectType$2,
  oboolean: oboolean$2,
  onumber: onumber$2,
  optional: optionalType$2,
  ostring: ostring$2,
  pipeline: pipelineType$2,
  preprocess: preprocessType$2,
  promise: promiseType$2,
  record: recordType$2,
  set: setType$2,
  strictObject: strictObjectType$2,
  string: stringType$2,
  symbol: symbolType$2,
  transformer: effectsType$2,
  tuple: tupleType$2,
  undefined: undefinedType$2,
  union: unionType$2,
  unknown: unknownType$2,
  void: voidType$2,
  NEVER: NEVER$2,
  ZodIssueCode: ZodIssueCode$2,
  quotelessJson: quotelessJson$3,
  ZodError: ZodError$4
});
const TriggerSchema = z$d.object({
  trigger: z$d.union([
    z$d.object({
      type: z$d.literal("webchat-visibility"),
      visibility: z$d.union([z$d.literal("show"), z$d.literal("hide"), z$d.literal("toggle")])
    }),
    z$d.object({ type: z$d.literal("custom-event") })
  ])
});
var lib$1 = {}, external = {}, errors = {}, en = {}, util$2 = {};
(function($e) {
  Object.defineProperty($e, "__esModule", { value: !0 }), $e.getParsedType = $e.ZodParsedType = $e.objectUtil = $e.util = void 0;
  var Ze;
  (function(Ke) {
    Ke.assertEqual = (at) => at;
    function Ve(at) {
    }
    Ke.assertIs = Ve;
    function Je(at) {
      throw new Error();
    }
    Ke.assertNever = Je, Ke.arrayToEnum = (at) => {
      const ut = {};
      for (const lt of at)
        ut[lt] = lt;
      return ut;
    }, Ke.getValidEnumValues = (at) => {
      const ut = Ke.objectKeys(at).filter((dt) => typeof at[at[dt]] != "number"), lt = {};
      for (const dt of ut)
        lt[dt] = at[dt];
      return Ke.objectValues(lt);
    }, Ke.objectValues = (at) => Ke.objectKeys(at).map(function(ut) {
      return at[ut];
    }), Ke.objectKeys = typeof Object.keys == "function" ? (at) => Object.keys(at) : (at) => {
      const ut = [];
      for (const lt in at)
        Object.prototype.hasOwnProperty.call(at, lt) && ut.push(lt);
      return ut;
    }, Ke.find = (at, ut) => {
      for (const lt of at)
        if (ut(lt))
          return lt;
    }, Ke.isInteger = typeof Number.isInteger == "function" ? (at) => Number.isInteger(at) : (at) => typeof at == "number" && isFinite(at) && Math.floor(at) === at;
    function Qe(at, ut = " | ") {
      return at.map((lt) => typeof lt == "string" ? `'${lt}'` : lt).join(ut);
    }
    Ke.joinValues = Qe, Ke.jsonStringifyReplacer = (at, ut) => typeof ut == "bigint" ? ut.toString() : ut;
  })(Ze = $e.util || ($e.util = {})), function(Ke) {
    Ke.mergeShapes = (Ve, Je) => ({
      ...Ve,
      ...Je
      // second overwrites first
    });
  }($e.objectUtil || ($e.objectUtil = {})), $e.ZodParsedType = Ze.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const Fe = (Ke) => {
    switch (typeof Ke) {
      case "undefined":
        return $e.ZodParsedType.undefined;
      case "string":
        return $e.ZodParsedType.string;
      case "number":
        return isNaN(Ke) ? $e.ZodParsedType.nan : $e.ZodParsedType.number;
      case "boolean":
        return $e.ZodParsedType.boolean;
      case "function":
        return $e.ZodParsedType.function;
      case "bigint":
        return $e.ZodParsedType.bigint;
      case "symbol":
        return $e.ZodParsedType.symbol;
      case "object":
        return Array.isArray(Ke) ? $e.ZodParsedType.array : Ke === null ? $e.ZodParsedType.null : Ke.then && typeof Ke.then == "function" && Ke.catch && typeof Ke.catch == "function" ? $e.ZodParsedType.promise : typeof Map < "u" && Ke instanceof Map ? $e.ZodParsedType.map : typeof Set < "u" && Ke instanceof Set ? $e.ZodParsedType.set : typeof Date < "u" && Ke instanceof Date ? $e.ZodParsedType.date : $e.ZodParsedType.object;
      default:
        return $e.ZodParsedType.unknown;
    }
  };
  $e.getParsedType = Fe;
})(util$2);
var ZodError$3 = {};
Object.defineProperty(ZodError$3, "__esModule", { value: !0 });
ZodError$3.ZodError = ZodError$3.quotelessJson = ZodError$3.ZodIssueCode = void 0;
const util_1$1 = util$2;
ZodError$3.ZodIssueCode = util_1$1.util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson$2 = ($e) => JSON.stringify($e, null, 2).replace(/"([^"]+)":/g, "$1:");
ZodError$3.quotelessJson = quotelessJson$2;
let ZodError$2 = class extends Error {
  constructor(Ze) {
    super(), this.issues = [], this.addIssue = (Ke) => {
      this.issues = [...this.issues, Ke];
    }, this.addIssues = (Ke = []) => {
      this.issues = [...this.issues, ...Ke];
    };
    const Fe = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, Fe) : this.__proto__ = Fe, this.name = "ZodError", this.issues = Ze;
  }
  get errors() {
    return this.issues;
  }
  format(Ze) {
    const Fe = Ze || function(Je) {
      return Je.message;
    }, Ke = { _errors: [] }, Ve = (Je) => {
      for (const Qe of Je.issues)
        if (Qe.code === "invalid_union")
          Qe.unionErrors.map(Ve);
        else if (Qe.code === "invalid_return_type")
          Ve(Qe.returnTypeError);
        else if (Qe.code === "invalid_arguments")
          Ve(Qe.argumentsError);
        else if (Qe.path.length === 0)
          Ke._errors.push(Fe(Qe));
        else {
          let at = Ke, ut = 0;
          for (; ut < Qe.path.length; ) {
            const lt = Qe.path[ut];
            ut === Qe.path.length - 1 ? (at[lt] = at[lt] || { _errors: [] }, at[lt]._errors.push(Fe(Qe))) : at[lt] = at[lt] || { _errors: [] }, at = at[lt], ut++;
          }
        }
    };
    return Ve(this), Ke;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util_1$1.util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(Ze = (Fe) => Fe.message) {
    const Fe = {}, Ke = [];
    for (const Ve of this.issues)
      Ve.path.length > 0 ? (Fe[Ve.path[0]] = Fe[Ve.path[0]] || [], Fe[Ve.path[0]].push(Ze(Ve))) : Ke.push(Ze(Ve));
    return { formErrors: Ke, fieldErrors: Fe };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$3.ZodError = ZodError$2;
ZodError$2.create = ($e) => new ZodError$2($e);
Object.defineProperty(en, "__esModule", { value: !0 });
const util_1 = util$2, ZodError_1 = ZodError$3, errorMap$2 = ($e, Ze) => {
  let Fe;
  switch ($e.code) {
    case ZodError_1.ZodIssueCode.invalid_type:
      $e.received === util_1.ZodParsedType.undefined ? Fe = "Required" : Fe = `Expected ${$e.expected}, received ${$e.received}`;
      break;
    case ZodError_1.ZodIssueCode.invalid_literal:
      Fe = `Invalid literal value, expected ${JSON.stringify($e.expected, util_1.util.jsonStringifyReplacer)}`;
      break;
    case ZodError_1.ZodIssueCode.unrecognized_keys:
      Fe = `Unrecognized key(s) in object: ${util_1.util.joinValues($e.keys, ", ")}`;
      break;
    case ZodError_1.ZodIssueCode.invalid_union:
      Fe = "Invalid input";
      break;
    case ZodError_1.ZodIssueCode.invalid_union_discriminator:
      Fe = `Invalid discriminator value. Expected ${util_1.util.joinValues($e.options)}`;
      break;
    case ZodError_1.ZodIssueCode.invalid_enum_value:
      Fe = `Invalid enum value. Expected ${util_1.util.joinValues($e.options)}, received '${$e.received}'`;
      break;
    case ZodError_1.ZodIssueCode.invalid_arguments:
      Fe = "Invalid function arguments";
      break;
    case ZodError_1.ZodIssueCode.invalid_return_type:
      Fe = "Invalid function return type";
      break;
    case ZodError_1.ZodIssueCode.invalid_date:
      Fe = "Invalid date";
      break;
    case ZodError_1.ZodIssueCode.invalid_string:
      typeof $e.validation == "object" ? "includes" in $e.validation ? (Fe = `Invalid input: must include "${$e.validation.includes}"`, typeof $e.validation.position == "number" && (Fe = `${Fe} at one or more positions greater than or equal to ${$e.validation.position}`)) : "startsWith" in $e.validation ? Fe = `Invalid input: must start with "${$e.validation.startsWith}"` : "endsWith" in $e.validation ? Fe = `Invalid input: must end with "${$e.validation.endsWith}"` : util_1.util.assertNever($e.validation) : $e.validation !== "regex" ? Fe = `Invalid ${$e.validation}` : Fe = "Invalid";
      break;
    case ZodError_1.ZodIssueCode.too_small:
      $e.type === "array" ? Fe = `Array must contain ${$e.exact ? "exactly" : $e.inclusive ? "at least" : "more than"} ${$e.minimum} element(s)` : $e.type === "string" ? Fe = `String must contain ${$e.exact ? "exactly" : $e.inclusive ? "at least" : "over"} ${$e.minimum} character(s)` : $e.type === "number" ? Fe = `Number must be ${$e.exact ? "exactly equal to " : $e.inclusive ? "greater than or equal to " : "greater than "}${$e.minimum}` : $e.type === "date" ? Fe = `Date must be ${$e.exact ? "exactly equal to " : $e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number($e.minimum))}` : Fe = "Invalid input";
      break;
    case ZodError_1.ZodIssueCode.too_big:
      $e.type === "array" ? Fe = `Array must contain ${$e.exact ? "exactly" : $e.inclusive ? "at most" : "less than"} ${$e.maximum} element(s)` : $e.type === "string" ? Fe = `String must contain ${$e.exact ? "exactly" : $e.inclusive ? "at most" : "under"} ${$e.maximum} character(s)` : $e.type === "number" ? Fe = `Number must be ${$e.exact ? "exactly" : $e.inclusive ? "less than or equal to" : "less than"} ${$e.maximum}` : $e.type === "bigint" ? Fe = `BigInt must be ${$e.exact ? "exactly" : $e.inclusive ? "less than or equal to" : "less than"} ${$e.maximum}` : $e.type === "date" ? Fe = `Date must be ${$e.exact ? "exactly" : $e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number($e.maximum))}` : Fe = "Invalid input";
      break;
    case ZodError_1.ZodIssueCode.custom:
      Fe = "Invalid input";
      break;
    case ZodError_1.ZodIssueCode.invalid_intersection_types:
      Fe = "Intersection results could not be merged";
      break;
    case ZodError_1.ZodIssueCode.not_multiple_of:
      Fe = `Number must be a multiple of ${$e.multipleOf}`;
      break;
    case ZodError_1.ZodIssueCode.not_finite:
      Fe = "Number must be finite";
      break;
    default:
      Fe = Ze.defaultError, util_1.util.assertNever($e);
  }
  return { message: Fe };
};
en.default = errorMap$2;
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function($e) {
  return $e && $e.__esModule ? $e : { default: $e };
};
Object.defineProperty(errors, "__esModule", { value: !0 });
errors.getErrorMap = errors.setErrorMap = errors.defaultErrorMap = void 0;
const en_1 = __importDefault(en);
errors.defaultErrorMap = en_1.default;
let overrideErrorMap$2 = en_1.default;
function setErrorMap$2($e) {
  overrideErrorMap$2 = $e;
}
errors.setErrorMap = setErrorMap$2;
function getErrorMap$2() {
  return overrideErrorMap$2;
}
errors.getErrorMap = getErrorMap$2;
var parseUtil = {};
(function($e) {
  var Ze = commonjsGlobal && commonjsGlobal.__importDefault || function(vt) {
    return vt && vt.__esModule ? vt : { default: vt };
  };
  Object.defineProperty($e, "__esModule", { value: !0 }), $e.isAsync = $e.isValid = $e.isDirty = $e.isAborted = $e.OK = $e.DIRTY = $e.INVALID = $e.ParseStatus = $e.addIssueToContext = $e.EMPTY_PATH = $e.makeIssue = void 0;
  const Fe = errors, Ke = Ze(en), Ve = (vt) => {
    const { data: wt, path: xt, errorMaps: Et, issueData: Tt } = vt, Rt = [...xt, ...Tt.path || []], Ct = {
      ...Tt,
      path: Rt
    };
    let Zt = "";
    const Lt = Et.filter((Ut) => !!Ut).slice().reverse();
    for (const Ut of Lt)
      Zt = Ut(Ct, { data: wt, defaultError: Zt }).message;
    return {
      ...Tt,
      path: Rt,
      message: Tt.message || Zt
    };
  };
  $e.makeIssue = Ve, $e.EMPTY_PATH = [];
  function Je(vt, wt) {
    const xt = (0, $e.makeIssue)({
      issueData: wt,
      data: vt.data,
      path: vt.path,
      errorMaps: [
        vt.common.contextualErrorMap,
        vt.schemaErrorMap,
        (0, Fe.getErrorMap)(),
        Ke.default
        // then global default map
      ].filter((Et) => !!Et)
    });
    vt.common.issues.push(xt);
  }
  $e.addIssueToContext = Je;
  class Qe {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(wt, xt) {
      const Et = [];
      for (const Tt of xt) {
        if (Tt.status === "aborted")
          return $e.INVALID;
        Tt.status === "dirty" && wt.dirty(), Et.push(Tt.value);
      }
      return { status: wt.value, value: Et };
    }
    static async mergeObjectAsync(wt, xt) {
      const Et = [];
      for (const Tt of xt)
        Et.push({
          key: await Tt.key,
          value: await Tt.value
        });
      return Qe.mergeObjectSync(wt, Et);
    }
    static mergeObjectSync(wt, xt) {
      const Et = {};
      for (const Tt of xt) {
        const { key: Rt, value: Ct } = Tt;
        if (Rt.status === "aborted" || Ct.status === "aborted")
          return $e.INVALID;
        Rt.status === "dirty" && wt.dirty(), Ct.status === "dirty" && wt.dirty(), Rt.value !== "__proto__" && (typeof Ct.value < "u" || Tt.alwaysSet) && (Et[Rt.value] = Ct.value);
      }
      return { status: wt.value, value: Et };
    }
  }
  $e.ParseStatus = Qe, $e.INVALID = Object.freeze({
    status: "aborted"
  });
  const at = (vt) => ({ status: "dirty", value: vt });
  $e.DIRTY = at;
  const ut = (vt) => ({ status: "valid", value: vt });
  $e.OK = ut;
  const lt = (vt) => vt.status === "aborted";
  $e.isAborted = lt;
  const dt = (vt) => vt.status === "dirty";
  $e.isDirty = dt;
  const bt = (vt) => vt.status === "valid";
  $e.isValid = bt;
  const $t = (vt) => typeof Promise < "u" && vt instanceof Promise;
  $e.isAsync = $t;
})(parseUtil);
var typeAliases = {};
Object.defineProperty(typeAliases, "__esModule", { value: !0 });
var types = {}, errorUtil$2 = {};
(function($e) {
  Object.defineProperty($e, "__esModule", { value: !0 }), $e.errorUtil = void 0, function(Ze) {
    Ze.errToObj = (Fe) => typeof Fe == "string" ? { message: Fe } : Fe || {}, Ze.toString = (Fe) => typeof Fe == "string" ? Fe : Fe == null ? void 0 : Fe.message;
  }($e.errorUtil || ($e.errorUtil = {}));
})(errorUtil$2);
(function($e) {
  Object.defineProperty($e, "__esModule", { value: !0 }), $e.date = $e.boolean = $e.bigint = $e.array = $e.any = $e.coerce = $e.ZodFirstPartyTypeKind = $e.late = $e.ZodSchema = $e.Schema = $e.custom = $e.ZodReadonly = $e.ZodPipeline = $e.ZodBranded = $e.BRAND = $e.ZodNaN = $e.ZodCatch = $e.ZodDefault = $e.ZodNullable = $e.ZodOptional = $e.ZodTransformer = $e.ZodEffects = $e.ZodPromise = $e.ZodNativeEnum = $e.ZodEnum = $e.ZodLiteral = $e.ZodLazy = $e.ZodFunction = $e.ZodSet = $e.ZodMap = $e.ZodRecord = $e.ZodTuple = $e.ZodIntersection = $e.ZodDiscriminatedUnion = $e.ZodUnion = $e.ZodObject = $e.ZodArray = $e.ZodVoid = $e.ZodNever = $e.ZodUnknown = $e.ZodAny = $e.ZodNull = $e.ZodUndefined = $e.ZodSymbol = $e.ZodDate = $e.ZodBoolean = $e.ZodBigInt = $e.ZodNumber = $e.ZodString = $e.ZodType = void 0, $e.NEVER = $e.void = $e.unknown = $e.union = $e.undefined = $e.tuple = $e.transformer = $e.symbol = $e.string = $e.strictObject = $e.set = $e.record = $e.promise = $e.preprocess = $e.pipeline = $e.ostring = $e.optional = $e.onumber = $e.oboolean = $e.object = $e.number = $e.nullable = $e.null = $e.never = $e.nativeEnum = $e.nan = $e.map = $e.literal = $e.lazy = $e.intersection = $e.instanceof = $e.function = $e.enum = $e.effect = $e.discriminatedUnion = void 0;
  const Ze = errors, Fe = errorUtil$2, Ke = parseUtil, Ve = util$2, Je = ZodError$3;
  class Qe {
    constructor(Wt, nr, pr, Pr) {
      this._cachedPath = [], this.parent = Wt, this.data = nr, this._path = pr, this._key = Pr;
    }
    get path() {
      return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
  }
  const at = (Er, Wt) => {
    if ((0, Ke.isValid)(Wt))
      return { success: !0, data: Wt.value };
    if (!Er.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error)
          return this._error;
        const nr = new Je.ZodError(Er.common.issues);
        return this._error = nr, this._error;
      }
    };
  };
  function ut(Er) {
    if (!Er)
      return {};
    const { errorMap: Wt, invalid_type_error: nr, required_error: pr, description: Pr } = Er;
    if (Wt && (nr || pr))
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return Wt ? { errorMap: Wt, description: Pr } : { errorMap: (Ur, jr) => Ur.code !== "invalid_type" ? { message: jr.defaultError } : typeof jr.data > "u" ? { message: pr ?? jr.defaultError } : { message: nr ?? jr.defaultError }, description: Pr };
  }
  class lt {
    constructor(Wt) {
      this.spa = this.safeParseAsync, this._def = Wt, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(Wt) {
      return (0, Ve.getParsedType)(Wt.data);
    }
    _getOrReturnCtx(Wt, nr) {
      return nr || {
        common: Wt.parent.common,
        data: Wt.data,
        parsedType: (0, Ve.getParsedType)(Wt.data),
        schemaErrorMap: this._def.errorMap,
        path: Wt.path,
        parent: Wt.parent
      };
    }
    _processInputParams(Wt) {
      return {
        status: new Ke.ParseStatus(),
        ctx: {
          common: Wt.parent.common,
          data: Wt.data,
          parsedType: (0, Ve.getParsedType)(Wt.data),
          schemaErrorMap: this._def.errorMap,
          path: Wt.path,
          parent: Wt.parent
        }
      };
    }
    _parseSync(Wt) {
      const nr = this._parse(Wt);
      if ((0, Ke.isAsync)(nr))
        throw new Error("Synchronous parse encountered promise.");
      return nr;
    }
    _parseAsync(Wt) {
      const nr = this._parse(Wt);
      return Promise.resolve(nr);
    }
    parse(Wt, nr) {
      const pr = this.safeParse(Wt, nr);
      if (pr.success)
        return pr.data;
      throw pr.error;
    }
    safeParse(Wt, nr) {
      var pr;
      const Pr = {
        common: {
          issues: [],
          async: (pr = nr == null ? void 0 : nr.async) !== null && pr !== void 0 ? pr : !1,
          contextualErrorMap: nr == null ? void 0 : nr.errorMap
        },
        path: (nr == null ? void 0 : nr.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: Wt,
        parsedType: (0, Ve.getParsedType)(Wt)
      }, Sr = this._parseSync({ data: Wt, path: Pr.path, parent: Pr });
      return at(Pr, Sr);
    }
    async parseAsync(Wt, nr) {
      const pr = await this.safeParseAsync(Wt, nr);
      if (pr.success)
        return pr.data;
      throw pr.error;
    }
    async safeParseAsync(Wt, nr) {
      const pr = {
        common: {
          issues: [],
          contextualErrorMap: nr == null ? void 0 : nr.errorMap,
          async: !0
        },
        path: (nr == null ? void 0 : nr.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: Wt,
        parsedType: (0, Ve.getParsedType)(Wt)
      }, Pr = this._parse({ data: Wt, path: pr.path, parent: pr }), Sr = await ((0, Ke.isAsync)(Pr) ? Pr : Promise.resolve(Pr));
      return at(pr, Sr);
    }
    refine(Wt, nr) {
      const pr = (Pr) => typeof nr == "string" || typeof nr > "u" ? { message: nr } : typeof nr == "function" ? nr(Pr) : nr;
      return this._refinement((Pr, Sr) => {
        const Ur = Wt(Pr), jr = () => Sr.addIssue({
          code: Je.ZodIssueCode.custom,
          ...pr(Pr)
        });
        return typeof Promise < "u" && Ur instanceof Promise ? Ur.then((Gr) => Gr ? !0 : (jr(), !1)) : Ur ? !0 : (jr(), !1);
      });
    }
    refinement(Wt, nr) {
      return this._refinement((pr, Pr) => Wt(pr) ? !0 : (Pr.addIssue(typeof nr == "function" ? nr(pr, Pr) : nr), !1));
    }
    _refinement(Wt) {
      return new Jt({
        schema: this,
        typeName: kt.ZodEffects,
        effect: { type: "refinement", refinement: Wt }
      });
    }
    superRefine(Wt) {
      return this._refinement(Wt);
    }
    optional() {
      return ir.create(this, this._def);
    }
    nullable() {
      return Br.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return pt.create(this, this._def);
    }
    promise() {
      return sr.create(this, this._def);
    }
    or(Wt) {
      return Mt.create([this, Wt], this._def);
    }
    and(Wt) {
      return qt.create(this, Wt, this._def);
    }
    transform(Wt) {
      return new Jt({
        ...ut(this._def),
        schema: this,
        typeName: kt.ZodEffects,
        effect: { type: "transform", transform: Wt }
      });
    }
    default(Wt) {
      const nr = typeof Wt == "function" ? Wt : () => Wt;
      return new or({
        ...ut(this._def),
        innerType: this,
        defaultValue: nr,
        typeName: kt.ZodDefault
      });
    }
    brand() {
      return new dr({
        typeName: kt.ZodBranded,
        type: this,
        ...ut(this._def)
      });
    }
    catch(Wt) {
      const nr = typeof Wt == "function" ? Wt : () => Wt;
      return new lr({
        ...ut(this._def),
        innerType: this,
        catchValue: nr,
        typeName: kt.ZodCatch
      });
    }
    describe(Wt) {
      const nr = this.constructor;
      return new nr({
        ...this._def,
        description: Wt
      });
    }
    pipe(Wt) {
      return gr.create(this, Wt);
    }
    readonly() {
      return Zr.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  $e.ZodType = lt, $e.Schema = lt, $e.ZodSchema = lt;
  const dt = /^c[^\s-]{8,}$/i, bt = /^[a-z][a-z0-9]*$/, $t = /^[0-9A-HJKMNP-TV-Z]{26}$/, vt = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, wt = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, xt = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
  let Et;
  const Tt = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, Rt = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, Ct = (Er) => Er.precision ? Er.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${Er.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${Er.precision}}Z$`) : Er.precision === 0 ? Er.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : Er.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
  function Zt(Er, Wt) {
    return !!((Wt === "v4" || !Wt) && Tt.test(Er) || (Wt === "v6" || !Wt) && Rt.test(Er));
  }
  class Lt extends lt {
    _parse(Wt) {
      if (this._def.coerce && (Wt.data = String(Wt.data)), this._getType(Wt) !== Ve.ZodParsedType.string) {
        const Sr = this._getOrReturnCtx(Wt);
        return (0, Ke.addIssueToContext)(
          Sr,
          {
            code: Je.ZodIssueCode.invalid_type,
            expected: Ve.ZodParsedType.string,
            received: Sr.parsedType
          }
          //
        ), Ke.INVALID;
      }
      const pr = new Ke.ParseStatus();
      let Pr;
      for (const Sr of this._def.checks)
        if (Sr.kind === "min")
          Wt.data.length < Sr.value && (Pr = this._getOrReturnCtx(Wt, Pr), (0, Ke.addIssueToContext)(Pr, {
            code: Je.ZodIssueCode.too_small,
            minimum: Sr.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: Sr.message
          }), pr.dirty());
        else if (Sr.kind === "max")
          Wt.data.length > Sr.value && (Pr = this._getOrReturnCtx(Wt, Pr), (0, Ke.addIssueToContext)(Pr, {
            code: Je.ZodIssueCode.too_big,
            maximum: Sr.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: Sr.message
          }), pr.dirty());
        else if (Sr.kind === "length") {
          const Ur = Wt.data.length > Sr.value, jr = Wt.data.length < Sr.value;
          (Ur || jr) && (Pr = this._getOrReturnCtx(Wt, Pr), Ur ? (0, Ke.addIssueToContext)(Pr, {
            code: Je.ZodIssueCode.too_big,
            maximum: Sr.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: Sr.message
          }) : jr && (0, Ke.addIssueToContext)(Pr, {
            code: Je.ZodIssueCode.too_small,
            minimum: Sr.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: Sr.message
          }), pr.dirty());
        } else if (Sr.kind === "email")
          wt.test(Wt.data) || (Pr = this._getOrReturnCtx(Wt, Pr), (0, Ke.addIssueToContext)(Pr, {
            validation: "email",
            code: Je.ZodIssueCode.invalid_string,
            message: Sr.message
          }), pr.dirty());
        else if (Sr.kind === "emoji")
          Et || (Et = new RegExp(xt, "u")), Et.test(Wt.data) || (Pr = this._getOrReturnCtx(Wt, Pr), (0, Ke.addIssueToContext)(Pr, {
            validation: "emoji",
            code: Je.ZodIssueCode.invalid_string,
            message: Sr.message
          }), pr.dirty());
        else if (Sr.kind === "uuid")
          vt.test(Wt.data) || (Pr = this._getOrReturnCtx(Wt, Pr), (0, Ke.addIssueToContext)(Pr, {
            validation: "uuid",
            code: Je.ZodIssueCode.invalid_string,
            message: Sr.message
          }), pr.dirty());
        else if (Sr.kind === "cuid")
          dt.test(Wt.data) || (Pr = this._getOrReturnCtx(Wt, Pr), (0, Ke.addIssueToContext)(Pr, {
            validation: "cuid",
            code: Je.ZodIssueCode.invalid_string,
            message: Sr.message
          }), pr.dirty());
        else if (Sr.kind === "cuid2")
          bt.test(Wt.data) || (Pr = this._getOrReturnCtx(Wt, Pr), (0, Ke.addIssueToContext)(Pr, {
            validation: "cuid2",
            code: Je.ZodIssueCode.invalid_string,
            message: Sr.message
          }), pr.dirty());
        else if (Sr.kind === "ulid")
          $t.test(Wt.data) || (Pr = this._getOrReturnCtx(Wt, Pr), (0, Ke.addIssueToContext)(Pr, {
            validation: "ulid",
            code: Je.ZodIssueCode.invalid_string,
            message: Sr.message
          }), pr.dirty());
        else if (Sr.kind === "url")
          try {
            new URL(Wt.data);
          } catch {
            Pr = this._getOrReturnCtx(Wt, Pr), (0, Ke.addIssueToContext)(Pr, {
              validation: "url",
              code: Je.ZodIssueCode.invalid_string,
              message: Sr.message
            }), pr.dirty();
          }
        else
          Sr.kind === "regex" ? (Sr.regex.lastIndex = 0, Sr.regex.test(Wt.data) || (Pr = this._getOrReturnCtx(Wt, Pr), (0, Ke.addIssueToContext)(Pr, {
            validation: "regex",
            code: Je.ZodIssueCode.invalid_string,
            message: Sr.message
          }), pr.dirty())) : Sr.kind === "trim" ? Wt.data = Wt.data.trim() : Sr.kind === "includes" ? Wt.data.includes(Sr.value, Sr.position) || (Pr = this._getOrReturnCtx(Wt, Pr), (0, Ke.addIssueToContext)(Pr, {
            code: Je.ZodIssueCode.invalid_string,
            validation: { includes: Sr.value, position: Sr.position },
            message: Sr.message
          }), pr.dirty()) : Sr.kind === "toLowerCase" ? Wt.data = Wt.data.toLowerCase() : Sr.kind === "toUpperCase" ? Wt.data = Wt.data.toUpperCase() : Sr.kind === "startsWith" ? Wt.data.startsWith(Sr.value) || (Pr = this._getOrReturnCtx(Wt, Pr), (0, Ke.addIssueToContext)(Pr, {
            code: Je.ZodIssueCode.invalid_string,
            validation: { startsWith: Sr.value },
            message: Sr.message
          }), pr.dirty()) : Sr.kind === "endsWith" ? Wt.data.endsWith(Sr.value) || (Pr = this._getOrReturnCtx(Wt, Pr), (0, Ke.addIssueToContext)(Pr, {
            code: Je.ZodIssueCode.invalid_string,
            validation: { endsWith: Sr.value },
            message: Sr.message
          }), pr.dirty()) : Sr.kind === "datetime" ? Ct(Sr).test(Wt.data) || (Pr = this._getOrReturnCtx(Wt, Pr), (0, Ke.addIssueToContext)(Pr, {
            code: Je.ZodIssueCode.invalid_string,
            validation: "datetime",
            message: Sr.message
          }), pr.dirty()) : Sr.kind === "ip" ? Zt(Wt.data, Sr.version) || (Pr = this._getOrReturnCtx(Wt, Pr), (0, Ke.addIssueToContext)(Pr, {
            validation: "ip",
            code: Je.ZodIssueCode.invalid_string,
            message: Sr.message
          }), pr.dirty()) : Ve.util.assertNever(Sr);
      return { status: pr.value, value: Wt.data };
    }
    _regex(Wt, nr, pr) {
      return this.refinement((Pr) => Wt.test(Pr), {
        validation: nr,
        code: Je.ZodIssueCode.invalid_string,
        ...Fe.errorUtil.errToObj(pr)
      });
    }
    _addCheck(Wt) {
      return new Lt({
        ...this._def,
        checks: [...this._def.checks, Wt]
      });
    }
    email(Wt) {
      return this._addCheck({ kind: "email", ...Fe.errorUtil.errToObj(Wt) });
    }
    url(Wt) {
      return this._addCheck({ kind: "url", ...Fe.errorUtil.errToObj(Wt) });
    }
    emoji(Wt) {
      return this._addCheck({ kind: "emoji", ...Fe.errorUtil.errToObj(Wt) });
    }
    uuid(Wt) {
      return this._addCheck({ kind: "uuid", ...Fe.errorUtil.errToObj(Wt) });
    }
    cuid(Wt) {
      return this._addCheck({ kind: "cuid", ...Fe.errorUtil.errToObj(Wt) });
    }
    cuid2(Wt) {
      return this._addCheck({ kind: "cuid2", ...Fe.errorUtil.errToObj(Wt) });
    }
    ulid(Wt) {
      return this._addCheck({ kind: "ulid", ...Fe.errorUtil.errToObj(Wt) });
    }
    ip(Wt) {
      return this._addCheck({ kind: "ip", ...Fe.errorUtil.errToObj(Wt) });
    }
    datetime(Wt) {
      var nr;
      return typeof Wt == "string" ? this._addCheck({
        kind: "datetime",
        precision: null,
        offset: !1,
        message: Wt
      }) : this._addCheck({
        kind: "datetime",
        precision: typeof (Wt == null ? void 0 : Wt.precision) > "u" ? null : Wt == null ? void 0 : Wt.precision,
        offset: (nr = Wt == null ? void 0 : Wt.offset) !== null && nr !== void 0 ? nr : !1,
        ...Fe.errorUtil.errToObj(Wt == null ? void 0 : Wt.message)
      });
    }
    regex(Wt, nr) {
      return this._addCheck({
        kind: "regex",
        regex: Wt,
        ...Fe.errorUtil.errToObj(nr)
      });
    }
    includes(Wt, nr) {
      return this._addCheck({
        kind: "includes",
        value: Wt,
        position: nr == null ? void 0 : nr.position,
        ...Fe.errorUtil.errToObj(nr == null ? void 0 : nr.message)
      });
    }
    startsWith(Wt, nr) {
      return this._addCheck({
        kind: "startsWith",
        value: Wt,
        ...Fe.errorUtil.errToObj(nr)
      });
    }
    endsWith(Wt, nr) {
      return this._addCheck({
        kind: "endsWith",
        value: Wt,
        ...Fe.errorUtil.errToObj(nr)
      });
    }
    min(Wt, nr) {
      return this._addCheck({
        kind: "min",
        value: Wt,
        ...Fe.errorUtil.errToObj(nr)
      });
    }
    max(Wt, nr) {
      return this._addCheck({
        kind: "max",
        value: Wt,
        ...Fe.errorUtil.errToObj(nr)
      });
    }
    length(Wt, nr) {
      return this._addCheck({
        kind: "length",
        value: Wt,
        ...Fe.errorUtil.errToObj(nr)
      });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(Wt) {
      return this.min(1, Fe.errorUtil.errToObj(Wt));
    }
    trim() {
      return new Lt({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new Lt({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new Lt({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((Wt) => Wt.kind === "datetime");
    }
    get isEmail() {
      return !!this._def.checks.find((Wt) => Wt.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((Wt) => Wt.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((Wt) => Wt.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((Wt) => Wt.kind === "uuid");
    }
    get isCUID() {
      return !!this._def.checks.find((Wt) => Wt.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((Wt) => Wt.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((Wt) => Wt.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((Wt) => Wt.kind === "ip");
    }
    get minLength() {
      let Wt = null;
      for (const nr of this._def.checks)
        nr.kind === "min" && (Wt === null || nr.value > Wt) && (Wt = nr.value);
      return Wt;
    }
    get maxLength() {
      let Wt = null;
      for (const nr of this._def.checks)
        nr.kind === "max" && (Wt === null || nr.value < Wt) && (Wt = nr.value);
      return Wt;
    }
  }
  $e.ZodString = Lt, Lt.create = (Er) => {
    var Wt;
    return new Lt({
      checks: [],
      typeName: kt.ZodString,
      coerce: (Wt = Er == null ? void 0 : Er.coerce) !== null && Wt !== void 0 ? Wt : !1,
      ...ut(Er)
    });
  };
  function Ut(Er, Wt) {
    const nr = (Er.toString().split(".")[1] || "").length, pr = (Wt.toString().split(".")[1] || "").length, Pr = nr > pr ? nr : pr, Sr = parseInt(Er.toFixed(Pr).replace(".", "")), Ur = parseInt(Wt.toFixed(Pr).replace(".", ""));
    return Sr % Ur / Math.pow(10, Pr);
  }
  class Pt extends lt {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(Wt) {
      if (this._def.coerce && (Wt.data = Number(Wt.data)), this._getType(Wt) !== Ve.ZodParsedType.number) {
        const Sr = this._getOrReturnCtx(Wt);
        return (0, Ke.addIssueToContext)(Sr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.number,
          received: Sr.parsedType
        }), Ke.INVALID;
      }
      let pr;
      const Pr = new Ke.ParseStatus();
      for (const Sr of this._def.checks)
        Sr.kind === "int" ? Ve.util.isInteger(Wt.data) || (pr = this._getOrReturnCtx(Wt, pr), (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: "integer",
          received: "float",
          message: Sr.message
        }), Pr.dirty()) : Sr.kind === "min" ? (Sr.inclusive ? Wt.data < Sr.value : Wt.data <= Sr.value) && (pr = this._getOrReturnCtx(Wt, pr), (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.too_small,
          minimum: Sr.value,
          type: "number",
          inclusive: Sr.inclusive,
          exact: !1,
          message: Sr.message
        }), Pr.dirty()) : Sr.kind === "max" ? (Sr.inclusive ? Wt.data > Sr.value : Wt.data >= Sr.value) && (pr = this._getOrReturnCtx(Wt, pr), (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.too_big,
          maximum: Sr.value,
          type: "number",
          inclusive: Sr.inclusive,
          exact: !1,
          message: Sr.message
        }), Pr.dirty()) : Sr.kind === "multipleOf" ? Ut(Wt.data, Sr.value) !== 0 && (pr = this._getOrReturnCtx(Wt, pr), (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.not_multiple_of,
          multipleOf: Sr.value,
          message: Sr.message
        }), Pr.dirty()) : Sr.kind === "finite" ? Number.isFinite(Wt.data) || (pr = this._getOrReturnCtx(Wt, pr), (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.not_finite,
          message: Sr.message
        }), Pr.dirty()) : Ve.util.assertNever(Sr);
      return { status: Pr.value, value: Wt.data };
    }
    gte(Wt, nr) {
      return this.setLimit("min", Wt, !0, Fe.errorUtil.toString(nr));
    }
    gt(Wt, nr) {
      return this.setLimit("min", Wt, !1, Fe.errorUtil.toString(nr));
    }
    lte(Wt, nr) {
      return this.setLimit("max", Wt, !0, Fe.errorUtil.toString(nr));
    }
    lt(Wt, nr) {
      return this.setLimit("max", Wt, !1, Fe.errorUtil.toString(nr));
    }
    setLimit(Wt, nr, pr, Pr) {
      return new Pt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: Wt,
            value: nr,
            inclusive: pr,
            message: Fe.errorUtil.toString(Pr)
          }
        ]
      });
    }
    _addCheck(Wt) {
      return new Pt({
        ...this._def,
        checks: [...this._def.checks, Wt]
      });
    }
    int(Wt) {
      return this._addCheck({
        kind: "int",
        message: Fe.errorUtil.toString(Wt)
      });
    }
    positive(Wt) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !1,
        message: Fe.errorUtil.toString(Wt)
      });
    }
    negative(Wt) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !1,
        message: Fe.errorUtil.toString(Wt)
      });
    }
    nonpositive(Wt) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !0,
        message: Fe.errorUtil.toString(Wt)
      });
    }
    nonnegative(Wt) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !0,
        message: Fe.errorUtil.toString(Wt)
      });
    }
    multipleOf(Wt, nr) {
      return this._addCheck({
        kind: "multipleOf",
        value: Wt,
        message: Fe.errorUtil.toString(nr)
      });
    }
    finite(Wt) {
      return this._addCheck({
        kind: "finite",
        message: Fe.errorUtil.toString(Wt)
      });
    }
    safe(Wt) {
      return this._addCheck({
        kind: "min",
        inclusive: !0,
        value: Number.MIN_SAFE_INTEGER,
        message: Fe.errorUtil.toString(Wt)
      })._addCheck({
        kind: "max",
        inclusive: !0,
        value: Number.MAX_SAFE_INTEGER,
        message: Fe.errorUtil.toString(Wt)
      });
    }
    get minValue() {
      let Wt = null;
      for (const nr of this._def.checks)
        nr.kind === "min" && (Wt === null || nr.value > Wt) && (Wt = nr.value);
      return Wt;
    }
    get maxValue() {
      let Wt = null;
      for (const nr of this._def.checks)
        nr.kind === "max" && (Wt === null || nr.value < Wt) && (Wt = nr.value);
      return Wt;
    }
    get isInt() {
      return !!this._def.checks.find((Wt) => Wt.kind === "int" || Wt.kind === "multipleOf" && Ve.util.isInteger(Wt.value));
    }
    get isFinite() {
      let Wt = null, nr = null;
      for (const pr of this._def.checks) {
        if (pr.kind === "finite" || pr.kind === "int" || pr.kind === "multipleOf")
          return !0;
        pr.kind === "min" ? (nr === null || pr.value > nr) && (nr = pr.value) : pr.kind === "max" && (Wt === null || pr.value < Wt) && (Wt = pr.value);
      }
      return Number.isFinite(nr) && Number.isFinite(Wt);
    }
  }
  $e.ZodNumber = Pt, Pt.create = (Er) => new Pt({
    checks: [],
    typeName: kt.ZodNumber,
    coerce: (Er == null ? void 0 : Er.coerce) || !1,
    ...ut(Er)
  });
  class Ot extends lt {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(Wt) {
      if (this._def.coerce && (Wt.data = BigInt(Wt.data)), this._getType(Wt) !== Ve.ZodParsedType.bigint) {
        const Sr = this._getOrReturnCtx(Wt);
        return (0, Ke.addIssueToContext)(Sr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.bigint,
          received: Sr.parsedType
        }), Ke.INVALID;
      }
      let pr;
      const Pr = new Ke.ParseStatus();
      for (const Sr of this._def.checks)
        Sr.kind === "min" ? (Sr.inclusive ? Wt.data < Sr.value : Wt.data <= Sr.value) && (pr = this._getOrReturnCtx(Wt, pr), (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.too_small,
          type: "bigint",
          minimum: Sr.value,
          inclusive: Sr.inclusive,
          message: Sr.message
        }), Pr.dirty()) : Sr.kind === "max" ? (Sr.inclusive ? Wt.data > Sr.value : Wt.data >= Sr.value) && (pr = this._getOrReturnCtx(Wt, pr), (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.too_big,
          type: "bigint",
          maximum: Sr.value,
          inclusive: Sr.inclusive,
          message: Sr.message
        }), Pr.dirty()) : Sr.kind === "multipleOf" ? Wt.data % Sr.value !== BigInt(0) && (pr = this._getOrReturnCtx(Wt, pr), (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.not_multiple_of,
          multipleOf: Sr.value,
          message: Sr.message
        }), Pr.dirty()) : Ve.util.assertNever(Sr);
      return { status: Pr.value, value: Wt.data };
    }
    gte(Wt, nr) {
      return this.setLimit("min", Wt, !0, Fe.errorUtil.toString(nr));
    }
    gt(Wt, nr) {
      return this.setLimit("min", Wt, !1, Fe.errorUtil.toString(nr));
    }
    lte(Wt, nr) {
      return this.setLimit("max", Wt, !0, Fe.errorUtil.toString(nr));
    }
    lt(Wt, nr) {
      return this.setLimit("max", Wt, !1, Fe.errorUtil.toString(nr));
    }
    setLimit(Wt, nr, pr, Pr) {
      return new Ot({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: Wt,
            value: nr,
            inclusive: pr,
            message: Fe.errorUtil.toString(Pr)
          }
        ]
      });
    }
    _addCheck(Wt) {
      return new Ot({
        ...this._def,
        checks: [...this._def.checks, Wt]
      });
    }
    positive(Wt) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !1,
        message: Fe.errorUtil.toString(Wt)
      });
    }
    negative(Wt) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !1,
        message: Fe.errorUtil.toString(Wt)
      });
    }
    nonpositive(Wt) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !0,
        message: Fe.errorUtil.toString(Wt)
      });
    }
    nonnegative(Wt) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !0,
        message: Fe.errorUtil.toString(Wt)
      });
    }
    multipleOf(Wt, nr) {
      return this._addCheck({
        kind: "multipleOf",
        value: Wt,
        message: Fe.errorUtil.toString(nr)
      });
    }
    get minValue() {
      let Wt = null;
      for (const nr of this._def.checks)
        nr.kind === "min" && (Wt === null || nr.value > Wt) && (Wt = nr.value);
      return Wt;
    }
    get maxValue() {
      let Wt = null;
      for (const nr of this._def.checks)
        nr.kind === "max" && (Wt === null || nr.value < Wt) && (Wt = nr.value);
      return Wt;
    }
  }
  $e.ZodBigInt = Ot, Ot.create = (Er) => {
    var Wt;
    return new Ot({
      checks: [],
      typeName: kt.ZodBigInt,
      coerce: (Wt = Er == null ? void 0 : Er.coerce) !== null && Wt !== void 0 ? Wt : !1,
      ...ut(Er)
    });
  };
  class Ft extends lt {
    _parse(Wt) {
      if (this._def.coerce && (Wt.data = !!Wt.data), this._getType(Wt) !== Ve.ZodParsedType.boolean) {
        const pr = this._getOrReturnCtx(Wt);
        return (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.boolean,
          received: pr.parsedType
        }), Ke.INVALID;
      }
      return (0, Ke.OK)(Wt.data);
    }
  }
  $e.ZodBoolean = Ft, Ft.create = (Er) => new Ft({
    typeName: kt.ZodBoolean,
    coerce: (Er == null ? void 0 : Er.coerce) || !1,
    ...ut(Er)
  });
  class gt extends lt {
    _parse(Wt) {
      if (this._def.coerce && (Wt.data = new Date(Wt.data)), this._getType(Wt) !== Ve.ZodParsedType.date) {
        const Sr = this._getOrReturnCtx(Wt);
        return (0, Ke.addIssueToContext)(Sr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.date,
          received: Sr.parsedType
        }), Ke.INVALID;
      }
      if (isNaN(Wt.data.getTime())) {
        const Sr = this._getOrReturnCtx(Wt);
        return (0, Ke.addIssueToContext)(Sr, {
          code: Je.ZodIssueCode.invalid_date
        }), Ke.INVALID;
      }
      const pr = new Ke.ParseStatus();
      let Pr;
      for (const Sr of this._def.checks)
        Sr.kind === "min" ? Wt.data.getTime() < Sr.value && (Pr = this._getOrReturnCtx(Wt, Pr), (0, Ke.addIssueToContext)(Pr, {
          code: Je.ZodIssueCode.too_small,
          message: Sr.message,
          inclusive: !0,
          exact: !1,
          minimum: Sr.value,
          type: "date"
        }), pr.dirty()) : Sr.kind === "max" ? Wt.data.getTime() > Sr.value && (Pr = this._getOrReturnCtx(Wt, Pr), (0, Ke.addIssueToContext)(Pr, {
          code: Je.ZodIssueCode.too_big,
          message: Sr.message,
          inclusive: !0,
          exact: !1,
          maximum: Sr.value,
          type: "date"
        }), pr.dirty()) : Ve.util.assertNever(Sr);
      return {
        status: pr.value,
        value: new Date(Wt.data.getTime())
      };
    }
    _addCheck(Wt) {
      return new gt({
        ...this._def,
        checks: [...this._def.checks, Wt]
      });
    }
    min(Wt, nr) {
      return this._addCheck({
        kind: "min",
        value: Wt.getTime(),
        message: Fe.errorUtil.toString(nr)
      });
    }
    max(Wt, nr) {
      return this._addCheck({
        kind: "max",
        value: Wt.getTime(),
        message: Fe.errorUtil.toString(nr)
      });
    }
    get minDate() {
      let Wt = null;
      for (const nr of this._def.checks)
        nr.kind === "min" && (Wt === null || nr.value > Wt) && (Wt = nr.value);
      return Wt != null ? new Date(Wt) : null;
    }
    get maxDate() {
      let Wt = null;
      for (const nr of this._def.checks)
        nr.kind === "max" && (Wt === null || nr.value < Wt) && (Wt = nr.value);
      return Wt != null ? new Date(Wt) : null;
    }
  }
  $e.ZodDate = gt, gt.create = (Er) => new gt({
    checks: [],
    coerce: (Er == null ? void 0 : Er.coerce) || !1,
    typeName: kt.ZodDate,
    ...ut(Er)
  });
  class We extends lt {
    _parse(Wt) {
      if (this._getType(Wt) !== Ve.ZodParsedType.symbol) {
        const pr = this._getOrReturnCtx(Wt);
        return (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.symbol,
          received: pr.parsedType
        }), Ke.INVALID;
      }
      return (0, Ke.OK)(Wt.data);
    }
  }
  $e.ZodSymbol = We, We.create = (Er) => new We({
    typeName: kt.ZodSymbol,
    ...ut(Er)
  });
  class Xe extends lt {
    _parse(Wt) {
      if (this._getType(Wt) !== Ve.ZodParsedType.undefined) {
        const pr = this._getOrReturnCtx(Wt);
        return (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.undefined,
          received: pr.parsedType
        }), Ke.INVALID;
      }
      return (0, Ke.OK)(Wt.data);
    }
  }
  $e.ZodUndefined = Xe, Xe.create = (Er) => new Xe({
    typeName: kt.ZodUndefined,
    ...ut(Er)
  });
  class rt extends lt {
    _parse(Wt) {
      if (this._getType(Wt) !== Ve.ZodParsedType.null) {
        const pr = this._getOrReturnCtx(Wt);
        return (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.null,
          received: pr.parsedType
        }), Ke.INVALID;
      }
      return (0, Ke.OK)(Wt.data);
    }
  }
  $e.ZodNull = rt, rt.create = (Er) => new rt({
    typeName: kt.ZodNull,
    ...ut(Er)
  });
  class ot extends lt {
    constructor() {
      super(...arguments), this._any = !0;
    }
    _parse(Wt) {
      return (0, Ke.OK)(Wt.data);
    }
  }
  $e.ZodAny = ot, ot.create = (Er) => new ot({
    typeName: kt.ZodAny,
    ...ut(Er)
  });
  class ft extends lt {
    constructor() {
      super(...arguments), this._unknown = !0;
    }
    _parse(Wt) {
      return (0, Ke.OK)(Wt.data);
    }
  }
  $e.ZodUnknown = ft, ft.create = (Er) => new ft({
    typeName: kt.ZodUnknown,
    ...ut(Er)
  });
  class mt extends lt {
    _parse(Wt) {
      const nr = this._getOrReturnCtx(Wt);
      return (0, Ke.addIssueToContext)(nr, {
        code: Je.ZodIssueCode.invalid_type,
        expected: Ve.ZodParsedType.never,
        received: nr.parsedType
      }), Ke.INVALID;
    }
  }
  $e.ZodNever = mt, mt.create = (Er) => new mt({
    typeName: kt.ZodNever,
    ...ut(Er)
  });
  class yt extends lt {
    _parse(Wt) {
      if (this._getType(Wt) !== Ve.ZodParsedType.undefined) {
        const pr = this._getOrReturnCtx(Wt);
        return (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.void,
          received: pr.parsedType
        }), Ke.INVALID;
      }
      return (0, Ke.OK)(Wt.data);
    }
  }
  $e.ZodVoid = yt, yt.create = (Er) => new yt({
    typeName: kt.ZodVoid,
    ...ut(Er)
  });
  class pt extends lt {
    _parse(Wt) {
      const { ctx: nr, status: pr } = this._processInputParams(Wt), Pr = this._def;
      if (nr.parsedType !== Ve.ZodParsedType.array)
        return (0, Ke.addIssueToContext)(nr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.array,
          received: nr.parsedType
        }), Ke.INVALID;
      if (Pr.exactLength !== null) {
        const Ur = nr.data.length > Pr.exactLength.value, jr = nr.data.length < Pr.exactLength.value;
        (Ur || jr) && ((0, Ke.addIssueToContext)(nr, {
          code: Ur ? Je.ZodIssueCode.too_big : Je.ZodIssueCode.too_small,
          minimum: jr ? Pr.exactLength.value : void 0,
          maximum: Ur ? Pr.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: Pr.exactLength.message
        }), pr.dirty());
      }
      if (Pr.minLength !== null && nr.data.length < Pr.minLength.value && ((0, Ke.addIssueToContext)(nr, {
        code: Je.ZodIssueCode.too_small,
        minimum: Pr.minLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: Pr.minLength.message
      }), pr.dirty()), Pr.maxLength !== null && nr.data.length > Pr.maxLength.value && ((0, Ke.addIssueToContext)(nr, {
        code: Je.ZodIssueCode.too_big,
        maximum: Pr.maxLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: Pr.maxLength.message
      }), pr.dirty()), nr.common.async)
        return Promise.all([...nr.data].map((Ur, jr) => Pr.type._parseAsync(new Qe(nr, Ur, nr.path, jr)))).then((Ur) => Ke.ParseStatus.mergeArray(pr, Ur));
      const Sr = [...nr.data].map((Ur, jr) => Pr.type._parseSync(new Qe(nr, Ur, nr.path, jr)));
      return Ke.ParseStatus.mergeArray(pr, Sr);
    }
    get element() {
      return this._def.type;
    }
    min(Wt, nr) {
      return new pt({
        ...this._def,
        minLength: { value: Wt, message: Fe.errorUtil.toString(nr) }
      });
    }
    max(Wt, nr) {
      return new pt({
        ...this._def,
        maxLength: { value: Wt, message: Fe.errorUtil.toString(nr) }
      });
    }
    length(Wt, nr) {
      return new pt({
        ...this._def,
        exactLength: { value: Wt, message: Fe.errorUtil.toString(nr) }
      });
    }
    nonempty(Wt) {
      return this.min(1, Wt);
    }
  }
  $e.ZodArray = pt, pt.create = (Er, Wt) => new pt({
    type: Er,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: kt.ZodArray,
    ...ut(Wt)
  });
  function Ge(Er) {
    if (Er instanceof ct) {
      const Wt = {};
      for (const nr in Er.shape) {
        const pr = Er.shape[nr];
        Wt[nr] = ir.create(Ge(pr));
      }
      return new ct({
        ...Er._def,
        shape: () => Wt
      });
    } else
      return Er instanceof pt ? new pt({
        ...Er._def,
        type: Ge(Er.element)
      }) : Er instanceof ir ? ir.create(Ge(Er.unwrap())) : Er instanceof Br ? Br.create(Ge(Er.unwrap())) : Er instanceof Qt ? Qt.create(Er.items.map((Wt) => Ge(Wt))) : Er;
  }
  class ct extends lt {
    constructor() {
      super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const Wt = this._def.shape(), nr = Ve.util.objectKeys(Wt);
      return this._cached = { shape: Wt, keys: nr };
    }
    _parse(Wt) {
      if (this._getType(Wt) !== Ve.ZodParsedType.object) {
        const Vr = this._getOrReturnCtx(Wt);
        return (0, Ke.addIssueToContext)(Vr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.object,
          received: Vr.parsedType
        }), Ke.INVALID;
      }
      const { status: pr, ctx: Pr } = this._processInputParams(Wt), { shape: Sr, keys: Ur } = this._getCached(), jr = [];
      if (!(this._def.catchall instanceof mt && this._def.unknownKeys === "strip"))
        for (const Vr in Pr.data)
          Ur.includes(Vr) || jr.push(Vr);
      const Gr = [];
      for (const Vr of Ur) {
        const rn = Sr[Vr], an = Pr.data[Vr];
        Gr.push({
          key: { status: "valid", value: Vr },
          value: rn._parse(new Qe(Pr, an, Pr.path, Vr)),
          alwaysSet: Vr in Pr.data
        });
      }
      if (this._def.catchall instanceof mt) {
        const Vr = this._def.unknownKeys;
        if (Vr === "passthrough")
          for (const rn of jr)
            Gr.push({
              key: { status: "valid", value: rn },
              value: { status: "valid", value: Pr.data[rn] }
            });
        else if (Vr === "strict")
          jr.length > 0 && ((0, Ke.addIssueToContext)(Pr, {
            code: Je.ZodIssueCode.unrecognized_keys,
            keys: jr
          }), pr.dirty());
        else if (Vr !== "strip")
          throw new Error("Internal ZodObject error: invalid unknownKeys value.");
      } else {
        const Vr = this._def.catchall;
        for (const rn of jr) {
          const an = Pr.data[rn];
          Gr.push({
            key: { status: "valid", value: rn },
            value: Vr._parse(
              new Qe(Pr, an, Pr.path, rn)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: rn in Pr.data
          });
        }
      }
      return Pr.common.async ? Promise.resolve().then(async () => {
        const Vr = [];
        for (const rn of Gr) {
          const an = await rn.key;
          Vr.push({
            key: an,
            value: await rn.value,
            alwaysSet: rn.alwaysSet
          });
        }
        return Vr;
      }).then((Vr) => Ke.ParseStatus.mergeObjectSync(pr, Vr)) : Ke.ParseStatus.mergeObjectSync(pr, Gr);
    }
    get shape() {
      return this._def.shape();
    }
    strict(Wt) {
      return Fe.errorUtil.errToObj, new ct({
        ...this._def,
        unknownKeys: "strict",
        ...Wt !== void 0 ? {
          errorMap: (nr, pr) => {
            var Pr, Sr, Ur, jr;
            const Gr = (Ur = (Sr = (Pr = this._def).errorMap) === null || Sr === void 0 ? void 0 : Sr.call(Pr, nr, pr).message) !== null && Ur !== void 0 ? Ur : pr.defaultError;
            return nr.code === "unrecognized_keys" ? {
              message: (jr = Fe.errorUtil.errToObj(Wt).message) !== null && jr !== void 0 ? jr : Gr
            } : {
              message: Gr
            };
          }
        } : {}
      });
    }
    strip() {
      return new ct({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ct({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(Wt) {
      return new ct({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...Wt
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(Wt) {
      return new ct({
        unknownKeys: Wt._def.unknownKeys,
        catchall: Wt._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...Wt._def.shape()
        }),
        typeName: kt.ZodObject
      });
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(Wt, nr) {
      return this.augment({ [Wt]: nr });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(Wt) {
      return new ct({
        ...this._def,
        catchall: Wt
      });
    }
    pick(Wt) {
      const nr = {};
      return Ve.util.objectKeys(Wt).forEach((pr) => {
        Wt[pr] && this.shape[pr] && (nr[pr] = this.shape[pr]);
      }), new ct({
        ...this._def,
        shape: () => nr
      });
    }
    omit(Wt) {
      const nr = {};
      return Ve.util.objectKeys(this.shape).forEach((pr) => {
        Wt[pr] || (nr[pr] = this.shape[pr]);
      }), new ct({
        ...this._def,
        shape: () => nr
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return Ge(this);
    }
    partial(Wt) {
      const nr = {};
      return Ve.util.objectKeys(this.shape).forEach((pr) => {
        const Pr = this.shape[pr];
        Wt && !Wt[pr] ? nr[pr] = Pr : nr[pr] = Pr.optional();
      }), new ct({
        ...this._def,
        shape: () => nr
      });
    }
    required(Wt) {
      const nr = {};
      return Ve.util.objectKeys(this.shape).forEach((pr) => {
        if (Wt && !Wt[pr])
          nr[pr] = this.shape[pr];
        else {
          let Sr = this.shape[pr];
          for (; Sr instanceof ir; )
            Sr = Sr._def.innerType;
          nr[pr] = Sr;
        }
      }), new ct({
        ...this._def,
        shape: () => nr
      });
    }
    keyof() {
      return Ht(Ve.util.objectKeys(this.shape));
    }
  }
  $e.ZodObject = ct, ct.create = (Er, Wt) => new ct({
    shape: () => Er,
    unknownKeys: "strip",
    catchall: mt.create(),
    typeName: kt.ZodObject,
    ...ut(Wt)
  }), ct.strictCreate = (Er, Wt) => new ct({
    shape: () => Er,
    unknownKeys: "strict",
    catchall: mt.create(),
    typeName: kt.ZodObject,
    ...ut(Wt)
  }), ct.lazycreate = (Er, Wt) => new ct({
    shape: Er,
    unknownKeys: "strip",
    catchall: mt.create(),
    typeName: kt.ZodObject,
    ...ut(Wt)
  });
  class Mt extends lt {
    _parse(Wt) {
      const { ctx: nr } = this._processInputParams(Wt), pr = this._def.options;
      function Pr(Sr) {
        for (const jr of Sr)
          if (jr.result.status === "valid")
            return jr.result;
        for (const jr of Sr)
          if (jr.result.status === "dirty")
            return nr.common.issues.push(...jr.ctx.common.issues), jr.result;
        const Ur = Sr.map((jr) => new Je.ZodError(jr.ctx.common.issues));
        return (0, Ke.addIssueToContext)(nr, {
          code: Je.ZodIssueCode.invalid_union,
          unionErrors: Ur
        }), Ke.INVALID;
      }
      if (nr.common.async)
        return Promise.all(pr.map(async (Sr) => {
          const Ur = {
            ...nr,
            common: {
              ...nr.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await Sr._parseAsync({
              data: nr.data,
              path: nr.path,
              parent: Ur
            }),
            ctx: Ur
          };
        })).then(Pr);
      {
        let Sr;
        const Ur = [];
        for (const Gr of pr) {
          const Vr = {
            ...nr,
            common: {
              ...nr.common,
              issues: []
            },
            parent: null
          }, rn = Gr._parseSync({
            data: nr.data,
            path: nr.path,
            parent: Vr
          });
          if (rn.status === "valid")
            return rn;
          rn.status === "dirty" && !Sr && (Sr = { result: rn, ctx: Vr }), Vr.common.issues.length && Ur.push(Vr.common.issues);
        }
        if (Sr)
          return nr.common.issues.push(...Sr.ctx.common.issues), Sr.result;
        const jr = Ur.map((Gr) => new Je.ZodError(Gr));
        return (0, Ke.addIssueToContext)(nr, {
          code: Je.ZodIssueCode.invalid_union,
          unionErrors: jr
        }), Ke.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  $e.ZodUnion = Mt, Mt.create = (Er, Wt) => new Mt({
    options: Er,
    typeName: kt.ZodUnion,
    ...ut(Wt)
  });
  const St = (Er) => Er instanceof er ? St(Er.schema) : Er instanceof Jt ? St(Er.innerType()) : Er instanceof Dt ? [Er.value] : Er instanceof Gt ? Er.options : Er instanceof rr ? Object.keys(Er.enum) : Er instanceof or ? St(Er._def.innerType) : Er instanceof Xe ? [void 0] : Er instanceof rt ? [null] : null;
  class At extends lt {
    _parse(Wt) {
      const { ctx: nr } = this._processInputParams(Wt);
      if (nr.parsedType !== Ve.ZodParsedType.object)
        return (0, Ke.addIssueToContext)(nr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.object,
          received: nr.parsedType
        }), Ke.INVALID;
      const pr = this.discriminator, Pr = nr.data[pr], Sr = this.optionsMap.get(Pr);
      return Sr ? nr.common.async ? Sr._parseAsync({
        data: nr.data,
        path: nr.path,
        parent: nr
      }) : Sr._parseSync({
        data: nr.data,
        path: nr.path,
        parent: nr
      }) : ((0, Ke.addIssueToContext)(nr, {
        code: Je.ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [pr]
      }), Ke.INVALID);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(Wt, nr, pr) {
      const Pr = /* @__PURE__ */ new Map();
      for (const Sr of nr) {
        const Ur = St(Sr.shape[Wt]);
        if (!Ur)
          throw new Error(`A discriminator value for key \`${Wt}\` could not be extracted from all schema options`);
        for (const jr of Ur) {
          if (Pr.has(jr))
            throw new Error(`Discriminator property ${String(Wt)} has duplicate value ${String(jr)}`);
          Pr.set(jr, Sr);
        }
      }
      return new At({
        typeName: kt.ZodDiscriminatedUnion,
        discriminator: Wt,
        options: nr,
        optionsMap: Pr,
        ...ut(pr)
      });
    }
  }
  $e.ZodDiscriminatedUnion = At;
  function Nt(Er, Wt) {
    const nr = (0, Ve.getParsedType)(Er), pr = (0, Ve.getParsedType)(Wt);
    if (Er === Wt)
      return { valid: !0, data: Er };
    if (nr === Ve.ZodParsedType.object && pr === Ve.ZodParsedType.object) {
      const Pr = Ve.util.objectKeys(Wt), Sr = Ve.util.objectKeys(Er).filter((jr) => Pr.indexOf(jr) !== -1), Ur = { ...Er, ...Wt };
      for (const jr of Sr) {
        const Gr = Nt(Er[jr], Wt[jr]);
        if (!Gr.valid)
          return { valid: !1 };
        Ur[jr] = Gr.data;
      }
      return { valid: !0, data: Ur };
    } else if (nr === Ve.ZodParsedType.array && pr === Ve.ZodParsedType.array) {
      if (Er.length !== Wt.length)
        return { valid: !1 };
      const Pr = [];
      for (let Sr = 0; Sr < Er.length; Sr++) {
        const Ur = Er[Sr], jr = Wt[Sr], Gr = Nt(Ur, jr);
        if (!Gr.valid)
          return { valid: !1 };
        Pr.push(Gr.data);
      }
      return { valid: !0, data: Pr };
    } else
      return nr === Ve.ZodParsedType.date && pr === Ve.ZodParsedType.date && +Er == +Wt ? { valid: !0, data: Er } : { valid: !1 };
  }
  class qt extends lt {
    _parse(Wt) {
      const { status: nr, ctx: pr } = this._processInputParams(Wt), Pr = (Sr, Ur) => {
        if ((0, Ke.isAborted)(Sr) || (0, Ke.isAborted)(Ur))
          return Ke.INVALID;
        const jr = Nt(Sr.value, Ur.value);
        return jr.valid ? (((0, Ke.isDirty)(Sr) || (0, Ke.isDirty)(Ur)) && nr.dirty(), { status: nr.value, value: jr.data }) : ((0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.invalid_intersection_types
        }), Ke.INVALID);
      };
      return pr.common.async ? Promise.all([
        this._def.left._parseAsync({
          data: pr.data,
          path: pr.path,
          parent: pr
        }),
        this._def.right._parseAsync({
          data: pr.data,
          path: pr.path,
          parent: pr
        })
      ]).then(([Sr, Ur]) => Pr(Sr, Ur)) : Pr(this._def.left._parseSync({
        data: pr.data,
        path: pr.path,
        parent: pr
      }), this._def.right._parseSync({
        data: pr.data,
        path: pr.path,
        parent: pr
      }));
    }
  }
  $e.ZodIntersection = qt, qt.create = (Er, Wt, nr) => new qt({
    left: Er,
    right: Wt,
    typeName: kt.ZodIntersection,
    ...ut(nr)
  });
  class Qt extends lt {
    _parse(Wt) {
      const { status: nr, ctx: pr } = this._processInputParams(Wt);
      if (pr.parsedType !== Ve.ZodParsedType.array)
        return (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.array,
          received: pr.parsedType
        }), Ke.INVALID;
      if (pr.data.length < this._def.items.length)
        return (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array"
        }), Ke.INVALID;
      !this._def.rest && pr.data.length > this._def.items.length && ((0, Ke.addIssueToContext)(pr, {
        code: Je.ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), nr.dirty());
      const Sr = [...pr.data].map((Ur, jr) => {
        const Gr = this._def.items[jr] || this._def.rest;
        return Gr ? Gr._parse(new Qe(pr, Ur, pr.path, jr)) : null;
      }).filter((Ur) => !!Ur);
      return pr.common.async ? Promise.all(Sr).then((Ur) => Ke.ParseStatus.mergeArray(nr, Ur)) : Ke.ParseStatus.mergeArray(nr, Sr);
    }
    get items() {
      return this._def.items;
    }
    rest(Wt) {
      return new Qt({
        ...this._def,
        rest: Wt
      });
    }
  }
  $e.ZodTuple = Qt, Qt.create = (Er, Wt) => {
    if (!Array.isArray(Er))
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new Qt({
      items: Er,
      typeName: kt.ZodTuple,
      rest: null,
      ...ut(Wt)
    });
  };
  class Xt extends lt {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(Wt) {
      const { status: nr, ctx: pr } = this._processInputParams(Wt);
      if (pr.parsedType !== Ve.ZodParsedType.object)
        return (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.object,
          received: pr.parsedType
        }), Ke.INVALID;
      const Pr = [], Sr = this._def.keyType, Ur = this._def.valueType;
      for (const jr in pr.data)
        Pr.push({
          key: Sr._parse(new Qe(pr, jr, pr.path, jr)),
          value: Ur._parse(new Qe(pr, pr.data[jr], pr.path, jr))
        });
      return pr.common.async ? Ke.ParseStatus.mergeObjectAsync(nr, Pr) : Ke.ParseStatus.mergeObjectSync(nr, Pr);
    }
    get element() {
      return this._def.valueType;
    }
    static create(Wt, nr, pr) {
      return nr instanceof lt ? new Xt({
        keyType: Wt,
        valueType: nr,
        typeName: kt.ZodRecord,
        ...ut(pr)
      }) : new Xt({
        keyType: Lt.create(),
        valueType: Wt,
        typeName: kt.ZodRecord,
        ...ut(nr)
      });
    }
  }
  $e.ZodRecord = Xt;
  class zt extends lt {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(Wt) {
      const { status: nr, ctx: pr } = this._processInputParams(Wt);
      if (pr.parsedType !== Ve.ZodParsedType.map)
        return (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.map,
          received: pr.parsedType
        }), Ke.INVALID;
      const Pr = this._def.keyType, Sr = this._def.valueType, Ur = [...pr.data.entries()].map(([jr, Gr], Vr) => ({
        key: Pr._parse(new Qe(pr, jr, pr.path, [Vr, "key"])),
        value: Sr._parse(new Qe(pr, Gr, pr.path, [Vr, "value"]))
      }));
      if (pr.common.async) {
        const jr = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const Gr of Ur) {
            const Vr = await Gr.key, rn = await Gr.value;
            if (Vr.status === "aborted" || rn.status === "aborted")
              return Ke.INVALID;
            (Vr.status === "dirty" || rn.status === "dirty") && nr.dirty(), jr.set(Vr.value, rn.value);
          }
          return { status: nr.value, value: jr };
        });
      } else {
        const jr = /* @__PURE__ */ new Map();
        for (const Gr of Ur) {
          const Vr = Gr.key, rn = Gr.value;
          if (Vr.status === "aborted" || rn.status === "aborted")
            return Ke.INVALID;
          (Vr.status === "dirty" || rn.status === "dirty") && nr.dirty(), jr.set(Vr.value, rn.value);
        }
        return { status: nr.value, value: jr };
      }
    }
  }
  $e.ZodMap = zt, zt.create = (Er, Wt, nr) => new zt({
    valueType: Wt,
    keyType: Er,
    typeName: kt.ZodMap,
    ...ut(nr)
  });
  class Kt extends lt {
    _parse(Wt) {
      const { status: nr, ctx: pr } = this._processInputParams(Wt);
      if (pr.parsedType !== Ve.ZodParsedType.set)
        return (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.set,
          received: pr.parsedType
        }), Ke.INVALID;
      const Pr = this._def;
      Pr.minSize !== null && pr.data.size < Pr.minSize.value && ((0, Ke.addIssueToContext)(pr, {
        code: Je.ZodIssueCode.too_small,
        minimum: Pr.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: Pr.minSize.message
      }), nr.dirty()), Pr.maxSize !== null && pr.data.size > Pr.maxSize.value && ((0, Ke.addIssueToContext)(pr, {
        code: Je.ZodIssueCode.too_big,
        maximum: Pr.maxSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: Pr.maxSize.message
      }), nr.dirty());
      const Sr = this._def.valueType;
      function Ur(Gr) {
        const Vr = /* @__PURE__ */ new Set();
        for (const rn of Gr) {
          if (rn.status === "aborted")
            return Ke.INVALID;
          rn.status === "dirty" && nr.dirty(), Vr.add(rn.value);
        }
        return { status: nr.value, value: Vr };
      }
      const jr = [...pr.data.values()].map((Gr, Vr) => Sr._parse(new Qe(pr, Gr, pr.path, Vr)));
      return pr.common.async ? Promise.all(jr).then((Gr) => Ur(Gr)) : Ur(jr);
    }
    min(Wt, nr) {
      return new Kt({
        ...this._def,
        minSize: { value: Wt, message: Fe.errorUtil.toString(nr) }
      });
    }
    max(Wt, nr) {
      return new Kt({
        ...this._def,
        maxSize: { value: Wt, message: Fe.errorUtil.toString(nr) }
      });
    }
    size(Wt, nr) {
      return this.min(Wt, nr).max(Wt, nr);
    }
    nonempty(Wt) {
      return this.min(1, Wt);
    }
  }
  $e.ZodSet = Kt, Kt.create = (Er, Wt) => new Kt({
    valueType: Er,
    minSize: null,
    maxSize: null,
    typeName: kt.ZodSet,
    ...ut(Wt)
  });
  class ur extends lt {
    constructor() {
      super(...arguments), this.validate = this.implement;
    }
    _parse(Wt) {
      const { ctx: nr } = this._processInputParams(Wt);
      if (nr.parsedType !== Ve.ZodParsedType.function)
        return (0, Ke.addIssueToContext)(nr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.function,
          received: nr.parsedType
        }), Ke.INVALID;
      function pr(jr, Gr) {
        return (0, Ke.makeIssue)({
          data: jr,
          path: nr.path,
          errorMaps: [
            nr.common.contextualErrorMap,
            nr.schemaErrorMap,
            (0, Ze.getErrorMap)(),
            Ze.defaultErrorMap
          ].filter((Vr) => !!Vr),
          issueData: {
            code: Je.ZodIssueCode.invalid_arguments,
            argumentsError: Gr
          }
        });
      }
      function Pr(jr, Gr) {
        return (0, Ke.makeIssue)({
          data: jr,
          path: nr.path,
          errorMaps: [
            nr.common.contextualErrorMap,
            nr.schemaErrorMap,
            (0, Ze.getErrorMap)(),
            Ze.defaultErrorMap
          ].filter((Vr) => !!Vr),
          issueData: {
            code: Je.ZodIssueCode.invalid_return_type,
            returnTypeError: Gr
          }
        });
      }
      const Sr = { errorMap: nr.common.contextualErrorMap }, Ur = nr.data;
      if (this._def.returns instanceof sr) {
        const jr = this;
        return (0, Ke.OK)(async function(...Gr) {
          const Vr = new Je.ZodError([]), rn = await jr._def.args.parseAsync(Gr, Sr).catch((sn) => {
            throw Vr.addIssue(pr(Gr, sn)), Vr;
          }), an = await Reflect.apply(Ur, this, rn);
          return await jr._def.returns._def.type.parseAsync(an, Sr).catch((sn) => {
            throw Vr.addIssue(Pr(an, sn)), Vr;
          });
        });
      } else {
        const jr = this;
        return (0, Ke.OK)(function(...Gr) {
          const Vr = jr._def.args.safeParse(Gr, Sr);
          if (!Vr.success)
            throw new Je.ZodError([pr(Gr, Vr.error)]);
          const rn = Reflect.apply(Ur, this, Vr.data), an = jr._def.returns.safeParse(rn, Sr);
          if (!an.success)
            throw new Je.ZodError([Pr(rn, an.error)]);
          return an.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...Wt) {
      return new ur({
        ...this._def,
        args: Qt.create(Wt).rest(ft.create())
      });
    }
    returns(Wt) {
      return new ur({
        ...this._def,
        returns: Wt
      });
    }
    implement(Wt) {
      return this.parse(Wt);
    }
    strictImplement(Wt) {
      return this.parse(Wt);
    }
    static create(Wt, nr, pr) {
      return new ur({
        args: Wt || Qt.create([]).rest(ft.create()),
        returns: nr || ft.create(),
        typeName: kt.ZodFunction,
        ...ut(pr)
      });
    }
  }
  $e.ZodFunction = ur;
  class er extends lt {
    get schema() {
      return this._def.getter();
    }
    _parse(Wt) {
      const { ctx: nr } = this._processInputParams(Wt);
      return this._def.getter()._parse({ data: nr.data, path: nr.path, parent: nr });
    }
  }
  $e.ZodLazy = er, er.create = (Er, Wt) => new er({
    getter: Er,
    typeName: kt.ZodLazy,
    ...ut(Wt)
  });
  class Dt extends lt {
    _parse(Wt) {
      if (Wt.data !== this._def.value) {
        const nr = this._getOrReturnCtx(Wt);
        return (0, Ke.addIssueToContext)(nr, {
          received: nr.data,
          code: Je.ZodIssueCode.invalid_literal,
          expected: this._def.value
        }), Ke.INVALID;
      }
      return { status: "valid", value: Wt.data };
    }
    get value() {
      return this._def.value;
    }
  }
  $e.ZodLiteral = Dt, Dt.create = (Er, Wt) => new Dt({
    value: Er,
    typeName: kt.ZodLiteral,
    ...ut(Wt)
  });
  function Ht(Er, Wt) {
    return new Gt({
      values: Er,
      typeName: kt.ZodEnum,
      ...ut(Wt)
    });
  }
  class Gt extends lt {
    _parse(Wt) {
      if (typeof Wt.data != "string") {
        const nr = this._getOrReturnCtx(Wt), pr = this._def.values;
        return (0, Ke.addIssueToContext)(nr, {
          expected: Ve.util.joinValues(pr),
          received: nr.parsedType,
          code: Je.ZodIssueCode.invalid_type
        }), Ke.INVALID;
      }
      if (this._def.values.indexOf(Wt.data) === -1) {
        const nr = this._getOrReturnCtx(Wt), pr = this._def.values;
        return (0, Ke.addIssueToContext)(nr, {
          received: nr.data,
          code: Je.ZodIssueCode.invalid_enum_value,
          options: pr
        }), Ke.INVALID;
      }
      return (0, Ke.OK)(Wt.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const Wt = {};
      for (const nr of this._def.values)
        Wt[nr] = nr;
      return Wt;
    }
    get Values() {
      const Wt = {};
      for (const nr of this._def.values)
        Wt[nr] = nr;
      return Wt;
    }
    get Enum() {
      const Wt = {};
      for (const nr of this._def.values)
        Wt[nr] = nr;
      return Wt;
    }
    extract(Wt) {
      return Gt.create(Wt);
    }
    exclude(Wt) {
      return Gt.create(this.options.filter((nr) => !Wt.includes(nr)));
    }
  }
  $e.ZodEnum = Gt, Gt.create = Ht;
  class rr extends lt {
    _parse(Wt) {
      const nr = Ve.util.getValidEnumValues(this._def.values), pr = this._getOrReturnCtx(Wt);
      if (pr.parsedType !== Ve.ZodParsedType.string && pr.parsedType !== Ve.ZodParsedType.number) {
        const Pr = Ve.util.objectValues(nr);
        return (0, Ke.addIssueToContext)(pr, {
          expected: Ve.util.joinValues(Pr),
          received: pr.parsedType,
          code: Je.ZodIssueCode.invalid_type
        }), Ke.INVALID;
      }
      if (nr.indexOf(Wt.data) === -1) {
        const Pr = Ve.util.objectValues(nr);
        return (0, Ke.addIssueToContext)(pr, {
          received: pr.data,
          code: Je.ZodIssueCode.invalid_enum_value,
          options: Pr
        }), Ke.INVALID;
      }
      return (0, Ke.OK)(Wt.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  $e.ZodNativeEnum = rr, rr.create = (Er, Wt) => new rr({
    values: Er,
    typeName: kt.ZodNativeEnum,
    ...ut(Wt)
  });
  class sr extends lt {
    unwrap() {
      return this._def.type;
    }
    _parse(Wt) {
      const { ctx: nr } = this._processInputParams(Wt);
      if (nr.parsedType !== Ve.ZodParsedType.promise && nr.common.async === !1)
        return (0, Ke.addIssueToContext)(nr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.promise,
          received: nr.parsedType
        }), Ke.INVALID;
      const pr = nr.parsedType === Ve.ZodParsedType.promise ? nr.data : Promise.resolve(nr.data);
      return (0, Ke.OK)(pr.then((Pr) => this._def.type.parseAsync(Pr, {
        path: nr.path,
        errorMap: nr.common.contextualErrorMap
      })));
    }
  }
  $e.ZodPromise = sr, sr.create = (Er, Wt) => new sr({
    type: Er,
    typeName: kt.ZodPromise,
    ...ut(Wt)
  });
  class Jt extends lt {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === kt.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(Wt) {
      const { status: nr, ctx: pr } = this._processInputParams(Wt), Pr = this._def.effect || null, Sr = {
        addIssue: (Ur) => {
          (0, Ke.addIssueToContext)(pr, Ur), Ur.fatal ? nr.abort() : nr.dirty();
        },
        get path() {
          return pr.path;
        }
      };
      if (Sr.addIssue = Sr.addIssue.bind(Sr), Pr.type === "preprocess") {
        const Ur = Pr.transform(pr.data, Sr);
        return pr.common.issues.length ? {
          status: "dirty",
          value: pr.data
        } : pr.common.async ? Promise.resolve(Ur).then((jr) => this._def.schema._parseAsync({
          data: jr,
          path: pr.path,
          parent: pr
        })) : this._def.schema._parseSync({
          data: Ur,
          path: pr.path,
          parent: pr
        });
      }
      if (Pr.type === "refinement") {
        const Ur = (jr) => {
          const Gr = Pr.refinement(jr, Sr);
          if (pr.common.async)
            return Promise.resolve(Gr);
          if (Gr instanceof Promise)
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          return jr;
        };
        if (pr.common.async === !1) {
          const jr = this._def.schema._parseSync({
            data: pr.data,
            path: pr.path,
            parent: pr
          });
          return jr.status === "aborted" ? Ke.INVALID : (jr.status === "dirty" && nr.dirty(), Ur(jr.value), { status: nr.value, value: jr.value });
        } else
          return this._def.schema._parseAsync({ data: pr.data, path: pr.path, parent: pr }).then((jr) => jr.status === "aborted" ? Ke.INVALID : (jr.status === "dirty" && nr.dirty(), Ur(jr.value).then(() => ({ status: nr.value, value: jr.value }))));
      }
      if (Pr.type === "transform")
        if (pr.common.async === !1) {
          const Ur = this._def.schema._parseSync({
            data: pr.data,
            path: pr.path,
            parent: pr
          });
          if (!(0, Ke.isValid)(Ur))
            return Ur;
          const jr = Pr.transform(Ur.value, Sr);
          if (jr instanceof Promise)
            throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
          return { status: nr.value, value: jr };
        } else
          return this._def.schema._parseAsync({ data: pr.data, path: pr.path, parent: pr }).then((Ur) => (0, Ke.isValid)(Ur) ? Promise.resolve(Pr.transform(Ur.value, Sr)).then((jr) => ({ status: nr.value, value: jr })) : Ur);
      Ve.util.assertNever(Pr);
    }
  }
  $e.ZodEffects = Jt, $e.ZodTransformer = Jt, Jt.create = (Er, Wt, nr) => new Jt({
    schema: Er,
    typeName: kt.ZodEffects,
    effect: Wt,
    ...ut(nr)
  }), Jt.createWithPreprocess = (Er, Wt, nr) => new Jt({
    schema: Wt,
    effect: { type: "preprocess", transform: Er },
    typeName: kt.ZodEffects,
    ...ut(nr)
  });
  class ir extends lt {
    _parse(Wt) {
      return this._getType(Wt) === Ve.ZodParsedType.undefined ? (0, Ke.OK)(void 0) : this._def.innerType._parse(Wt);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  $e.ZodOptional = ir, ir.create = (Er, Wt) => new ir({
    innerType: Er,
    typeName: kt.ZodOptional,
    ...ut(Wt)
  });
  class Br extends lt {
    _parse(Wt) {
      return this._getType(Wt) === Ve.ZodParsedType.null ? (0, Ke.OK)(null) : this._def.innerType._parse(Wt);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  $e.ZodNullable = Br, Br.create = (Er, Wt) => new Br({
    innerType: Er,
    typeName: kt.ZodNullable,
    ...ut(Wt)
  });
  class or extends lt {
    _parse(Wt) {
      const { ctx: nr } = this._processInputParams(Wt);
      let pr = nr.data;
      return nr.parsedType === Ve.ZodParsedType.undefined && (pr = this._def.defaultValue()), this._def.innerType._parse({
        data: pr,
        path: nr.path,
        parent: nr
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  $e.ZodDefault = or, or.create = (Er, Wt) => new or({
    innerType: Er,
    typeName: kt.ZodDefault,
    defaultValue: typeof Wt.default == "function" ? Wt.default : () => Wt.default,
    ...ut(Wt)
  });
  class lr extends lt {
    _parse(Wt) {
      const { ctx: nr } = this._processInputParams(Wt), pr = {
        ...nr,
        common: {
          ...nr.common,
          issues: []
        }
      }, Pr = this._def.innerType._parse({
        data: pr.data,
        path: pr.path,
        parent: {
          ...pr
        }
      });
      return (0, Ke.isAsync)(Pr) ? Pr.then((Sr) => ({
        status: "valid",
        value: Sr.status === "valid" ? Sr.value : this._def.catchValue({
          get error() {
            return new Je.ZodError(pr.common.issues);
          },
          input: pr.data
        })
      })) : {
        status: "valid",
        value: Pr.status === "valid" ? Pr.value : this._def.catchValue({
          get error() {
            return new Je.ZodError(pr.common.issues);
          },
          input: pr.data
        })
      };
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  $e.ZodCatch = lr, lr.create = (Er, Wt) => new lr({
    innerType: Er,
    typeName: kt.ZodCatch,
    catchValue: typeof Wt.catch == "function" ? Wt.catch : () => Wt.catch,
    ...ut(Wt)
  });
  class Nr extends lt {
    _parse(Wt) {
      if (this._getType(Wt) !== Ve.ZodParsedType.nan) {
        const pr = this._getOrReturnCtx(Wt);
        return (0, Ke.addIssueToContext)(pr, {
          code: Je.ZodIssueCode.invalid_type,
          expected: Ve.ZodParsedType.nan,
          received: pr.parsedType
        }), Ke.INVALID;
      }
      return { status: "valid", value: Wt.data };
    }
  }
  $e.ZodNaN = Nr, Nr.create = (Er) => new Nr({
    typeName: kt.ZodNaN,
    ...ut(Er)
  }), $e.BRAND = Symbol("zod_brand");
  class dr extends lt {
    _parse(Wt) {
      const { ctx: nr } = this._processInputParams(Wt), pr = nr.data;
      return this._def.type._parse({
        data: pr,
        path: nr.path,
        parent: nr
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  $e.ZodBranded = dr;
  class gr extends lt {
    _parse(Wt) {
      const { status: nr, ctx: pr } = this._processInputParams(Wt);
      if (pr.common.async)
        return (async () => {
          const Sr = await this._def.in._parseAsync({
            data: pr.data,
            path: pr.path,
            parent: pr
          });
          return Sr.status === "aborted" ? Ke.INVALID : Sr.status === "dirty" ? (nr.dirty(), (0, Ke.DIRTY)(Sr.value)) : this._def.out._parseAsync({
            data: Sr.value,
            path: pr.path,
            parent: pr
          });
        })();
      {
        const Pr = this._def.in._parseSync({
          data: pr.data,
          path: pr.path,
          parent: pr
        });
        return Pr.status === "aborted" ? Ke.INVALID : Pr.status === "dirty" ? (nr.dirty(), {
          status: "dirty",
          value: Pr.value
        }) : this._def.out._parseSync({
          data: Pr.value,
          path: pr.path,
          parent: pr
        });
      }
    }
    static create(Wt, nr) {
      return new gr({
        in: Wt,
        out: nr,
        typeName: kt.ZodPipeline
      });
    }
  }
  $e.ZodPipeline = gr;
  class Zr extends lt {
    _parse(Wt) {
      const nr = this._def.innerType._parse(Wt);
      return (0, Ke.isValid)(nr) && (nr.value = Object.freeze(nr.value)), nr;
    }
  }
  $e.ZodReadonly = Zr, Zr.create = (Er, Wt) => new Zr({
    innerType: Er,
    typeName: kt.ZodReadonly,
    ...ut(Wt)
  });
  const Bt = (Er, Wt = {}, nr) => Er ? ot.create().superRefine((pr, Pr) => {
    var Sr, Ur;
    if (!Er(pr)) {
      const jr = typeof Wt == "function" ? Wt(pr) : typeof Wt == "string" ? { message: Wt } : Wt, Gr = (Ur = (Sr = jr.fatal) !== null && Sr !== void 0 ? Sr : nr) !== null && Ur !== void 0 ? Ur : !0, Vr = typeof jr == "string" ? { message: jr } : jr;
      Pr.addIssue({ code: "custom", ...Vr, fatal: Gr });
    }
  }) : ot.create();
  $e.custom = Bt, $e.late = {
    object: ct.lazycreate
  };
  var kt;
  (function(Er) {
    Er.ZodString = "ZodString", Er.ZodNumber = "ZodNumber", Er.ZodNaN = "ZodNaN", Er.ZodBigInt = "ZodBigInt", Er.ZodBoolean = "ZodBoolean", Er.ZodDate = "ZodDate", Er.ZodSymbol = "ZodSymbol", Er.ZodUndefined = "ZodUndefined", Er.ZodNull = "ZodNull", Er.ZodAny = "ZodAny", Er.ZodUnknown = "ZodUnknown", Er.ZodNever = "ZodNever", Er.ZodVoid = "ZodVoid", Er.ZodArray = "ZodArray", Er.ZodObject = "ZodObject", Er.ZodUnion = "ZodUnion", Er.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", Er.ZodIntersection = "ZodIntersection", Er.ZodTuple = "ZodTuple", Er.ZodRecord = "ZodRecord", Er.ZodMap = "ZodMap", Er.ZodSet = "ZodSet", Er.ZodFunction = "ZodFunction", Er.ZodLazy = "ZodLazy", Er.ZodLiteral = "ZodLiteral", Er.ZodEnum = "ZodEnum", Er.ZodEffects = "ZodEffects", Er.ZodNativeEnum = "ZodNativeEnum", Er.ZodOptional = "ZodOptional", Er.ZodNullable = "ZodNullable", Er.ZodDefault = "ZodDefault", Er.ZodCatch = "ZodCatch", Er.ZodPromise = "ZodPromise", Er.ZodBranded = "ZodBranded", Er.ZodPipeline = "ZodPipeline", Er.ZodReadonly = "ZodReadonly";
  })(kt = $e.ZodFirstPartyTypeKind || ($e.ZodFirstPartyTypeKind = {}));
  const It = (Er, Wt = {
    message: `Input not instance of ${Er.name}`
  }) => (0, $e.custom)((nr) => nr instanceof Er, Wt);
  $e.instanceof = It;
  const jt = Lt.create;
  $e.string = jt;
  const Vt = Pt.create;
  $e.number = Vt;
  const ar = Nr.create;
  $e.nan = ar;
  const Yt = Ot.create;
  $e.bigint = Yt;
  const hr = Ft.create;
  $e.boolean = hr;
  const zr = gt.create;
  $e.date = zr;
  const cr = We.create;
  $e.symbol = cr;
  const _r = Xe.create;
  $e.undefined = _r;
  const Lr = rt.create;
  $e.null = Lr;
  const br = ot.create;
  $e.any = br;
  const kr = ft.create;
  $e.unknown = kr;
  const Xr = mt.create;
  $e.never = Xr;
  const yr = yt.create;
  $e.void = yr;
  const Ir = pt.create;
  $e.array = Ir;
  const Yr = ct.create;
  $e.object = Yr;
  const wr = ct.strictCreate;
  $e.strictObject = wr;
  const Cr = Mt.create;
  $e.union = Cr;
  const Hr = At.create;
  $e.discriminatedUnion = Hr;
  const $r = qt.create;
  $e.intersection = $r;
  const Ar = Qt.create;
  $e.tuple = Ar;
  const Wr = Xt.create;
  $e.record = Wr;
  const mr = zt.create;
  $e.map = mr;
  const Tr = Kt.create;
  $e.set = Tr;
  const Kr = ur.create;
  $e.function = Kr;
  const vr = er.create;
  $e.lazy = vr;
  const Rr = Dt.create;
  $e.literal = Rr;
  const Jr = Gt.create;
  $e.enum = Jr;
  const xr = rr.create;
  $e.nativeEnum = xr;
  const tr = sr.create;
  $e.promise = tr;
  const Dr = Jt.create;
  $e.effect = Dr, $e.transformer = Dr;
  const fr = ir.create;
  $e.optional = fr;
  const Mr = Br.create;
  $e.nullable = Mr;
  const Fr = Jt.createWithPreprocess;
  $e.preprocess = Fr;
  const qr = gr.create;
  $e.pipeline = qr;
  const tn = () => jt().optional();
  $e.ostring = tn;
  const Qr = () => Vt().optional();
  $e.onumber = Qr;
  const nn = () => hr().optional();
  $e.oboolean = nn, $e.coerce = {
    string: (Er) => Lt.create({ ...Er, coerce: !0 }),
    number: (Er) => Pt.create({ ...Er, coerce: !0 }),
    boolean: (Er) => Ft.create({
      ...Er,
      coerce: !0
    }),
    bigint: (Er) => Ot.create({ ...Er, coerce: !0 }),
    date: (Er) => gt.create({ ...Er, coerce: !0 })
  }, $e.NEVER = Ke.INVALID;
})(types);
(function($e) {
  var Ze = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(Ke, Ve, Je, Qe) {
    Qe === void 0 && (Qe = Je), Object.defineProperty(Ke, Qe, { enumerable: !0, get: function() {
      return Ve[Je];
    } });
  } : function(Ke, Ve, Je, Qe) {
    Qe === void 0 && (Qe = Je), Ke[Qe] = Ve[Je];
  }), Fe = commonjsGlobal && commonjsGlobal.__exportStar || function(Ke, Ve) {
    for (var Je in Ke)
      Je !== "default" && !Object.prototype.hasOwnProperty.call(Ve, Je) && Ze(Ve, Ke, Je);
  };
  Object.defineProperty($e, "__esModule", { value: !0 }), Fe(errors, $e), Fe(parseUtil, $e), Fe(typeAliases, $e), Fe(util$2, $e), Fe(types, $e), Fe(ZodError$3, $e);
})(external);
(function($e) {
  var Ze = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(Qe, at, ut, lt) {
    lt === void 0 && (lt = ut), Object.defineProperty(Qe, lt, { enumerable: !0, get: function() {
      return at[ut];
    } });
  } : function(Qe, at, ut, lt) {
    lt === void 0 && (lt = ut), Qe[lt] = at[ut];
  }), Fe = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(Qe, at) {
    Object.defineProperty(Qe, "default", { enumerable: !0, value: at });
  } : function(Qe, at) {
    Qe.default = at;
  }), Ke = commonjsGlobal && commonjsGlobal.__importStar || function(Qe) {
    if (Qe && Qe.__esModule)
      return Qe;
    var at = {};
    if (Qe != null)
      for (var ut in Qe)
        ut !== "default" && Object.prototype.hasOwnProperty.call(Qe, ut) && Ze(at, Qe, ut);
    return Fe(at, Qe), at;
  }, Ve = commonjsGlobal && commonjsGlobal.__exportStar || function(Qe, at) {
    for (var ut in Qe)
      ut !== "default" && !Object.prototype.hasOwnProperty.call(at, ut) && Ze(at, Qe, ut);
  };
  Object.defineProperty($e, "__esModule", { value: !0 }), $e.z = void 0;
  const Je = Ke(external);
  $e.z = Je, Ve(external, $e), $e.default = Je;
})(lib$1);
const he$2 = {}, __viteBrowserExternal = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: he$2
}, Symbol.toStringTag, { value: "Module" })), require$$3 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal);
function bind$1($e, Ze) {
  return function() {
    return $e.apply(Ze, arguments);
  };
}
const { toString: toString$2 } = Object.prototype, { getPrototypeOf: getPrototypeOf$1 } = Object, kindOf$1 = (($e) => (Ze) => {
  const Fe = toString$2.call(Ze);
  return $e[Fe] || ($e[Fe] = Fe.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), kindOfTest$1 = ($e) => ($e = $e.toLowerCase(), (Ze) => kindOf$1(Ze) === $e), typeOfTest$1 = ($e) => (Ze) => typeof Ze === $e, { isArray: isArray$1 } = Array, isUndefined$1 = typeOfTest$1("undefined");
function isBuffer$1($e) {
  return $e !== null && !isUndefined$1($e) && $e.constructor !== null && !isUndefined$1($e.constructor) && isFunction$1($e.constructor.isBuffer) && $e.constructor.isBuffer($e);
}
const isArrayBuffer$1 = kindOfTest$1("ArrayBuffer");
function isArrayBufferView$1($e) {
  let Ze;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? Ze = ArrayBuffer.isView($e) : Ze = $e && $e.buffer && isArrayBuffer$1($e.buffer), Ze;
}
const isString$1 = typeOfTest$1("string"), isFunction$1 = typeOfTest$1("function"), isNumber$1 = typeOfTest$1("number"), isObject$1 = ($e) => $e !== null && typeof $e == "object", isBoolean$1 = ($e) => $e === !0 || $e === !1, isPlainObject$1 = ($e) => {
  if (kindOf$1($e) !== "object")
    return !1;
  const Ze = getPrototypeOf$1($e);
  return (Ze === null || Ze === Object.prototype || Object.getPrototypeOf(Ze) === null) && !(Symbol.toStringTag in $e) && !(Symbol.iterator in $e);
}, isDate$1 = kindOfTest$1("Date"), isFile$1 = kindOfTest$1("File"), isBlob$1 = kindOfTest$1("Blob"), isFileList$1 = kindOfTest$1("FileList"), isStream$1 = ($e) => isObject$1($e) && isFunction$1($e.pipe), isFormData$1 = ($e) => {
  let Ze;
  return $e && (typeof FormData == "function" && $e instanceof FormData || isFunction$1($e.append) && ((Ze = kindOf$1($e)) === "formdata" || // detect form-data instance
  Ze === "object" && isFunction$1($e.toString) && $e.toString() === "[object FormData]"));
}, isURLSearchParams$1 = kindOfTest$1("URLSearchParams"), trim$1 = ($e) => $e.trim ? $e.trim() : $e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach$1($e, Ze, { allOwnKeys: Fe = !1 } = {}) {
  if ($e === null || typeof $e > "u")
    return;
  let Ke, Ve;
  if (typeof $e != "object" && ($e = [$e]), isArray$1($e))
    for (Ke = 0, Ve = $e.length; Ke < Ve; Ke++)
      Ze.call(null, $e[Ke], Ke, $e);
  else {
    const Je = Fe ? Object.getOwnPropertyNames($e) : Object.keys($e), Qe = Je.length;
    let at;
    for (Ke = 0; Ke < Qe; Ke++)
      at = Je[Ke], Ze.call(null, $e[at], at, $e);
  }
}
function findKey$1($e, Ze) {
  Ze = Ze.toLowerCase();
  const Fe = Object.keys($e);
  let Ke = Fe.length, Ve;
  for (; Ke-- > 0; )
    if (Ve = Fe[Ke], Ze === Ve.toLowerCase())
      return Ve;
  return null;
}
const _global$V = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), isContextDefined$1 = ($e) => !isUndefined$1($e) && $e !== _global$V;
function merge$2() {
  const { caseless: $e } = isContextDefined$1(this) && this || {}, Ze = {}, Fe = (Ke, Ve) => {
    const Je = $e && findKey$1(Ze, Ve) || Ve;
    isPlainObject$1(Ze[Je]) && isPlainObject$1(Ke) ? Ze[Je] = merge$2(Ze[Je], Ke) : isPlainObject$1(Ke) ? Ze[Je] = merge$2({}, Ke) : isArray$1(Ke) ? Ze[Je] = Ke.slice() : Ze[Je] = Ke;
  };
  for (let Ke = 0, Ve = arguments.length; Ke < Ve; Ke++)
    arguments[Ke] && forEach$1(arguments[Ke], Fe);
  return Ze;
}
const extend$1 = ($e, Ze, Fe, { allOwnKeys: Ke } = {}) => (forEach$1(Ze, (Ve, Je) => {
  Fe && isFunction$1(Ve) ? $e[Je] = bind$1(Ve, Fe) : $e[Je] = Ve;
}, { allOwnKeys: Ke }), $e), stripBOM$1 = ($e) => ($e.charCodeAt(0) === 65279 && ($e = $e.slice(1)), $e), inherits$1 = ($e, Ze, Fe, Ke) => {
  $e.prototype = Object.create(Ze.prototype, Ke), $e.prototype.constructor = $e, Object.defineProperty($e, "super", {
    value: Ze.prototype
  }), Fe && Object.assign($e.prototype, Fe);
}, toFlatObject$1 = ($e, Ze, Fe, Ke) => {
  let Ve, Je, Qe;
  const at = {};
  if (Ze = Ze || {}, $e == null)
    return Ze;
  do {
    for (Ve = Object.getOwnPropertyNames($e), Je = Ve.length; Je-- > 0; )
      Qe = Ve[Je], (!Ke || Ke(Qe, $e, Ze)) && !at[Qe] && (Ze[Qe] = $e[Qe], at[Qe] = !0);
    $e = Fe !== !1 && getPrototypeOf$1($e);
  } while ($e && (!Fe || Fe($e, Ze)) && $e !== Object.prototype);
  return Ze;
}, endsWith$1 = ($e, Ze, Fe) => {
  $e = String($e), (Fe === void 0 || Fe > $e.length) && (Fe = $e.length), Fe -= Ze.length;
  const Ke = $e.indexOf(Ze, Fe);
  return Ke !== -1 && Ke === Fe;
}, toArray$1 = ($e) => {
  if (!$e)
    return null;
  if (isArray$1($e))
    return $e;
  let Ze = $e.length;
  if (!isNumber$1(Ze))
    return null;
  const Fe = new Array(Ze);
  for (; Ze-- > 0; )
    Fe[Ze] = $e[Ze];
  return Fe;
}, isTypedArray$1 = (($e) => (Ze) => $e && Ze instanceof $e)(typeof Uint8Array < "u" && getPrototypeOf$1(Uint8Array)), forEachEntry$1 = ($e, Ze) => {
  const Ke = ($e && $e[Symbol.iterator]).call($e);
  let Ve;
  for (; (Ve = Ke.next()) && !Ve.done; ) {
    const Je = Ve.value;
    Ze.call($e, Je[0], Je[1]);
  }
}, matchAll$1 = ($e, Ze) => {
  let Fe;
  const Ke = [];
  for (; (Fe = $e.exec(Ze)) !== null; )
    Ke.push(Fe);
  return Ke;
}, isHTMLForm$1 = kindOfTest$1("HTMLFormElement"), toCamelCase$1 = ($e) => $e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(Fe, Ke, Ve) {
    return Ke.toUpperCase() + Ve;
  }
), hasOwnProperty$1 = (({ hasOwnProperty: $e }) => (Ze, Fe) => $e.call(Ze, Fe))(Object.prototype), isRegExp$1 = kindOfTest$1("RegExp"), reduceDescriptors$1 = ($e, Ze) => {
  const Fe = Object.getOwnPropertyDescriptors($e), Ke = {};
  forEach$1(Fe, (Ve, Je) => {
    let Qe;
    (Qe = Ze(Ve, Je, $e)) !== !1 && (Ke[Je] = Qe || Ve);
  }), Object.defineProperties($e, Ke);
}, freezeMethods$1 = ($e) => {
  reduceDescriptors$1($e, (Ze, Fe) => {
    if (isFunction$1($e) && ["arguments", "caller", "callee"].indexOf(Fe) !== -1)
      return !1;
    const Ke = $e[Fe];
    if (isFunction$1(Ke)) {
      if (Ze.enumerable = !1, "writable" in Ze) {
        Ze.writable = !1;
        return;
      }
      Ze.set || (Ze.set = () => {
        throw Error("Can not rewrite read-only method '" + Fe + "'");
      });
    }
  });
}, toObjectSet$1 = ($e, Ze) => {
  const Fe = {}, Ke = (Ve) => {
    Ve.forEach((Je) => {
      Fe[Je] = !0;
    });
  };
  return isArray$1($e) ? Ke($e) : Ke(String($e).split(Ze)), Fe;
}, noop$2 = () => {
}, toFiniteNumber$1 = ($e, Ze) => ($e = +$e, Number.isFinite($e) ? $e : Ze), ALPHA = "abcdefghijklmnopqrstuvwxyz", DIGIT = "0123456789", ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}, generateString = ($e = 16, Ze = ALPHABET.ALPHA_DIGIT) => {
  let Fe = "";
  const { length: Ke } = Ze;
  for (; $e--; )
    Fe += Ze[Math.random() * Ke | 0];
  return Fe;
};
function isSpecCompliantForm($e) {
  return !!($e && isFunction$1($e.append) && $e[Symbol.toStringTag] === "FormData" && $e[Symbol.iterator]);
}
const toJSONObject$1 = ($e) => {
  const Ze = new Array(10), Fe = (Ke, Ve) => {
    if (isObject$1(Ke)) {
      if (Ze.indexOf(Ke) >= 0)
        return;
      if (!("toJSON" in Ke)) {
        Ze[Ve] = Ke;
        const Je = isArray$1(Ke) ? [] : {};
        return forEach$1(Ke, (Qe, at) => {
          const ut = Fe(Qe, Ve + 1);
          !isUndefined$1(ut) && (Je[at] = ut);
        }), Ze[Ve] = void 0, Je;
      }
    }
    return Ke;
  };
  return Fe($e, 0);
}, isAsyncFn = kindOfTest$1("AsyncFunction"), isThenable = ($e) => $e && (isObject$1($e) || isFunction$1($e)) && isFunction$1($e.then) && isFunction$1($e.catch), utils$1 = {
  isArray: isArray$1,
  isArrayBuffer: isArrayBuffer$1,
  isBuffer: isBuffer$1,
  isFormData: isFormData$1,
  isArrayBufferView: isArrayBufferView$1,
  isString: isString$1,
  isNumber: isNumber$1,
  isBoolean: isBoolean$1,
  isObject: isObject$1,
  isPlainObject: isPlainObject$1,
  isUndefined: isUndefined$1,
  isDate: isDate$1,
  isFile: isFile$1,
  isBlob: isBlob$1,
  isRegExp: isRegExp$1,
  isFunction: isFunction$1,
  isStream: isStream$1,
  isURLSearchParams: isURLSearchParams$1,
  isTypedArray: isTypedArray$1,
  isFileList: isFileList$1,
  forEach: forEach$1,
  merge: merge$2,
  extend: extend$1,
  trim: trim$1,
  stripBOM: stripBOM$1,
  inherits: inherits$1,
  toFlatObject: toFlatObject$1,
  kindOf: kindOf$1,
  kindOfTest: kindOfTest$1,
  endsWith: endsWith$1,
  toArray: toArray$1,
  forEachEntry: forEachEntry$1,
  matchAll: matchAll$1,
  isHTMLForm: isHTMLForm$1,
  hasOwnProperty: hasOwnProperty$1,
  hasOwnProp: hasOwnProperty$1,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: reduceDescriptors$1,
  freezeMethods: freezeMethods$1,
  toObjectSet: toObjectSet$1,
  toCamelCase: toCamelCase$1,
  noop: noop$2,
  toFiniteNumber: toFiniteNumber$1,
  findKey: findKey$1,
  global: _global$V,
  isContextDefined: isContextDefined$1,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject: toJSONObject$1,
  isAsyncFn,
  isThenable
};
function AxiosError$2($e, Ze, Fe, Ke, Ve) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = $e, this.name = "AxiosError", Ze && (this.code = Ze), Fe && (this.config = Fe), Ke && (this.request = Ke), Ve && (this.response = Ve);
}
utils$1.inherits(AxiosError$2, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$2 = AxiosError$2.prototype, descriptors$1 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach(($e) => {
  descriptors$1[$e] = { value: $e };
});
Object.defineProperties(AxiosError$2, descriptors$1);
Object.defineProperty(prototype$2, "isAxiosError", { value: !0 });
AxiosError$2.from = ($e, Ze, Fe, Ke, Ve, Je) => {
  const Qe = Object.create(prototype$2);
  return utils$1.toFlatObject($e, Qe, function(ut) {
    return ut !== Error.prototype;
  }, (at) => at !== "isAxiosError"), AxiosError$2.call(Qe, $e.message, Ze, Fe, Ke, Ve), Qe.cause = $e, Qe.name = $e.name, Je && Object.assign(Qe, Je), Qe;
};
const httpAdapter = null;
function isVisitable$1($e) {
  return utils$1.isPlainObject($e) || utils$1.isArray($e);
}
function removeBrackets$1($e) {
  return utils$1.endsWith($e, "[]") ? $e.slice(0, -2) : $e;
}
function renderKey$1($e, Ze, Fe) {
  return $e ? $e.concat(Ze).map(function(Ve, Je) {
    return Ve = removeBrackets$1(Ve), !Fe && Je ? "[" + Ve + "]" : Ve;
  }).join(Fe ? "." : "") : Ze;
}
function isFlatArray$1($e) {
  return utils$1.isArray($e) && !$e.some(isVisitable$1);
}
const predicates$1 = utils$1.toFlatObject(utils$1, {}, null, function(Ze) {
  return /^is[A-Z]/.test(Ze);
});
function toFormData$2($e, Ze, Fe) {
  if (!utils$1.isObject($e))
    throw new TypeError("target must be an object");
  Ze = Ze || new FormData(), Fe = utils$1.toFlatObject(Fe, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(xt, Et) {
    return !utils$1.isUndefined(Et[xt]);
  });
  const Ke = Fe.metaTokens, Ve = Fe.visitor || dt, Je = Fe.dots, Qe = Fe.indexes, ut = (Fe.Blob || typeof Blob < "u" && Blob) && utils$1.isSpecCompliantForm(Ze);
  if (!utils$1.isFunction(Ve))
    throw new TypeError("visitor must be a function");
  function lt(wt) {
    if (wt === null)
      return "";
    if (utils$1.isDate(wt))
      return wt.toISOString();
    if (!ut && utils$1.isBlob(wt))
      throw new AxiosError$2("Blob is not supported. Use a Buffer instead.");
    return utils$1.isArrayBuffer(wt) || utils$1.isTypedArray(wt) ? ut && typeof Blob == "function" ? new Blob([wt]) : Buffer.from(wt) : wt;
  }
  function dt(wt, xt, Et) {
    let Tt = wt;
    if (wt && !Et && typeof wt == "object") {
      if (utils$1.endsWith(xt, "{}"))
        xt = Ke ? xt : xt.slice(0, -2), wt = JSON.stringify(wt);
      else if (utils$1.isArray(wt) && isFlatArray$1(wt) || (utils$1.isFileList(wt) || utils$1.endsWith(xt, "[]")) && (Tt = utils$1.toArray(wt)))
        return xt = removeBrackets$1(xt), Tt.forEach(function(Ct, Zt) {
          !(utils$1.isUndefined(Ct) || Ct === null) && Ze.append(
            // eslint-disable-next-line no-nested-ternary
            Qe === !0 ? renderKey$1([xt], Zt, Je) : Qe === null ? xt : xt + "[]",
            lt(Ct)
          );
        }), !1;
    }
    return isVisitable$1(wt) ? !0 : (Ze.append(renderKey$1(Et, xt, Je), lt(wt)), !1);
  }
  const bt = [], $t = Object.assign(predicates$1, {
    defaultVisitor: dt,
    convertValue: lt,
    isVisitable: isVisitable$1
  });
  function vt(wt, xt) {
    if (!utils$1.isUndefined(wt)) {
      if (bt.indexOf(wt) !== -1)
        throw Error("Circular reference detected in " + xt.join("."));
      bt.push(wt), utils$1.forEach(wt, function(Tt, Rt) {
        (!(utils$1.isUndefined(Tt) || Tt === null) && Ve.call(
          Ze,
          Tt,
          utils$1.isString(Rt) ? Rt.trim() : Rt,
          xt,
          $t
        )) === !0 && vt(Tt, xt ? xt.concat(Rt) : [Rt]);
      }), bt.pop();
    }
  }
  if (!utils$1.isObject($e))
    throw new TypeError("data must be an object");
  return vt($e), Ze;
}
function encode$2($e) {
  const Ze = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent($e).replace(/[!'()~]|%20|%00/g, function(Ke) {
    return Ze[Ke];
  });
}
function AxiosURLSearchParams$1($e, Ze) {
  this._pairs = [], $e && toFormData$2($e, this, Ze);
}
const prototype$1 = AxiosURLSearchParams$1.prototype;
prototype$1.append = function(Ze, Fe) {
  this._pairs.push([Ze, Fe]);
};
prototype$1.toString = function(Ze) {
  const Fe = Ze ? function(Ke) {
    return Ze.call(this, Ke, encode$2);
  } : encode$2;
  return this._pairs.map(function(Ve) {
    return Fe(Ve[0]) + "=" + Fe(Ve[1]);
  }, "").join("&");
};
function encode$1($e) {
  return encodeURIComponent($e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL$1($e, Ze, Fe) {
  if (!Ze)
    return $e;
  const Ke = Fe && Fe.encode || encode$1, Ve = Fe && Fe.serialize;
  let Je;
  if (Ve ? Je = Ve(Ze, Fe) : Je = utils$1.isURLSearchParams(Ze) ? Ze.toString() : new AxiosURLSearchParams$1(Ze, Fe).toString(Ke), Je) {
    const Qe = $e.indexOf("#");
    Qe !== -1 && ($e = $e.slice(0, Qe)), $e += ($e.indexOf("?") === -1 ? "?" : "&") + Je;
  }
  return $e;
}
let InterceptorManager$1 = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(Ze, Fe, Ke) {
    return this.handlers.push({
      fulfilled: Ze,
      rejected: Fe,
      synchronous: Ke ? Ke.synchronous : !1,
      runWhen: Ke ? Ke.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(Ze) {
    this.handlers[Ze] && (this.handlers[Ze] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(Ze) {
    utils$1.forEach(this.handlers, function(Ke) {
      Ke !== null && Ze(Ke);
    });
  }
};
const InterceptorManager$2 = InterceptorManager$1, transitionalDefaults = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, URLSearchParams$1 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams$1, FormData$1 = typeof FormData < "u" ? FormData : null, Blob$1 = typeof Blob < "u" ? Blob : null, platform$2 = {
  isBrowser: !0,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, hasBrowserEnv = typeof window < "u" && typeof document < "u", hasStandardBrowserEnv = (($e) => hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf($e) < 0)(typeof navigator < "u" && navigator.product), hasStandardBrowserWebWorkerEnv = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv
}, Symbol.toStringTag, { value: "Module" })), platform$1 = {
  ...utils,
  ...platform$2
};
function toURLEncodedForm$1($e, Ze) {
  return toFormData$2($e, new platform$1.classes.URLSearchParams(), Object.assign({
    visitor: function(Fe, Ke, Ve, Je) {
      return platform$1.isNode && utils$1.isBuffer(Fe) ? (this.append(Ke, Fe.toString("base64")), !1) : Je.defaultVisitor.apply(this, arguments);
    }
  }, Ze));
}
function parsePropPath$1($e) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, $e).map((Ze) => Ze[0] === "[]" ? "" : Ze[1] || Ze[0]);
}
function arrayToObject$1($e) {
  const Ze = {}, Fe = Object.keys($e);
  let Ke;
  const Ve = Fe.length;
  let Je;
  for (Ke = 0; Ke < Ve; Ke++)
    Je = Fe[Ke], Ze[Je] = $e[Je];
  return Ze;
}
function formDataToJSON$1($e) {
  function Ze(Fe, Ke, Ve, Je) {
    let Qe = Fe[Je++];
    const at = Number.isFinite(+Qe), ut = Je >= Fe.length;
    return Qe = !Qe && utils$1.isArray(Ve) ? Ve.length : Qe, ut ? (utils$1.hasOwnProp(Ve, Qe) ? Ve[Qe] = [Ve[Qe], Ke] : Ve[Qe] = Ke, !at) : ((!Ve[Qe] || !utils$1.isObject(Ve[Qe])) && (Ve[Qe] = []), Ze(Fe, Ke, Ve[Qe], Je) && utils$1.isArray(Ve[Qe]) && (Ve[Qe] = arrayToObject$1(Ve[Qe])), !at);
  }
  if (utils$1.isFormData($e) && utils$1.isFunction($e.entries)) {
    const Fe = {};
    return utils$1.forEachEntry($e, (Ke, Ve) => {
      Ze(parsePropPath$1(Ke), Ve, Fe, 0);
    }), Fe;
  }
  return null;
}
function stringifySafely$1($e, Ze, Fe) {
  if (utils$1.isString($e))
    try {
      return (Ze || JSON.parse)($e), utils$1.trim($e);
    } catch (Ke) {
      if (Ke.name !== "SyntaxError")
        throw Ke;
    }
  return (Fe || JSON.stringify)($e);
}
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function(Ze, Fe) {
    const Ke = Fe.getContentType() || "", Ve = Ke.indexOf("application/json") > -1, Je = utils$1.isObject(Ze);
    if (Je && utils$1.isHTMLForm(Ze) && (Ze = new FormData(Ze)), utils$1.isFormData(Ze))
      return Ve && Ve ? JSON.stringify(formDataToJSON$1(Ze)) : Ze;
    if (utils$1.isArrayBuffer(Ze) || utils$1.isBuffer(Ze) || utils$1.isStream(Ze) || utils$1.isFile(Ze) || utils$1.isBlob(Ze))
      return Ze;
    if (utils$1.isArrayBufferView(Ze))
      return Ze.buffer;
    if (utils$1.isURLSearchParams(Ze))
      return Fe.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), Ze.toString();
    let at;
    if (Je) {
      if (Ke.indexOf("application/x-www-form-urlencoded") > -1)
        return toURLEncodedForm$1(Ze, this.formSerializer).toString();
      if ((at = utils$1.isFileList(Ze)) || Ke.indexOf("multipart/form-data") > -1) {
        const ut = this.env && this.env.FormData;
        return toFormData$2(
          at ? { "files[]": Ze } : Ze,
          ut && new ut(),
          this.formSerializer
        );
      }
    }
    return Je || Ve ? (Fe.setContentType("application/json", !1), stringifySafely$1(Ze)) : Ze;
  }],
  transformResponse: [function(Ze) {
    const Fe = this.transitional || defaults$1.transitional, Ke = Fe && Fe.forcedJSONParsing, Ve = this.responseType === "json";
    if (Ze && utils$1.isString(Ze) && (Ke && !this.responseType || Ve)) {
      const Qe = !(Fe && Fe.silentJSONParsing) && Ve;
      try {
        return JSON.parse(Ze);
      } catch (at) {
        if (Qe)
          throw at.name === "SyntaxError" ? AxiosError$2.from(at, AxiosError$2.ERR_BAD_RESPONSE, this, null, this.response) : at;
      }
    }
    return Ze;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform$1.classes.FormData,
    Blob: platform$1.classes.Blob
  },
  validateStatus: function(Ze) {
    return Ze >= 200 && Ze < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], ($e) => {
  defaults$1.headers[$e] = {};
});
const defaults$2 = defaults$1, ignoreDuplicateOf$1 = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), parseHeaders = ($e) => {
  const Ze = {};
  let Fe, Ke, Ve;
  return $e && $e.split(`
`).forEach(function(Qe) {
    Ve = Qe.indexOf(":"), Fe = Qe.substring(0, Ve).trim().toLowerCase(), Ke = Qe.substring(Ve + 1).trim(), !(!Fe || Ze[Fe] && ignoreDuplicateOf$1[Fe]) && (Fe === "set-cookie" ? Ze[Fe] ? Ze[Fe].push(Ke) : Ze[Fe] = [Ke] : Ze[Fe] = Ze[Fe] ? Ze[Fe] + ", " + Ke : Ke);
  }), Ze;
}, $internals$1 = Symbol("internals");
function normalizeHeader$1($e) {
  return $e && String($e).trim().toLowerCase();
}
function normalizeValue$1($e) {
  return $e === !1 || $e == null ? $e : utils$1.isArray($e) ? $e.map(normalizeValue$1) : String($e);
}
function parseTokens$1($e) {
  const Ze = /* @__PURE__ */ Object.create(null), Fe = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let Ke;
  for (; Ke = Fe.exec($e); )
    Ze[Ke[1]] = Ke[2];
  return Ze;
}
const isValidHeaderName$1 = ($e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test($e.trim());
function matchHeaderValue$1($e, Ze, Fe, Ke, Ve) {
  if (utils$1.isFunction(Ke))
    return Ke.call(this, Ze, Fe);
  if (Ve && (Ze = Fe), !!utils$1.isString(Ze)) {
    if (utils$1.isString(Ke))
      return Ze.indexOf(Ke) !== -1;
    if (utils$1.isRegExp(Ke))
      return Ke.test(Ze);
  }
}
function formatHeader$1($e) {
  return $e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (Ze, Fe, Ke) => Fe.toUpperCase() + Ke);
}
function buildAccessors$1($e, Ze) {
  const Fe = utils$1.toCamelCase(" " + Ze);
  ["get", "set", "has"].forEach((Ke) => {
    Object.defineProperty($e, Ke + Fe, {
      value: function(Ve, Je, Qe) {
        return this[Ke].call(this, Ze, Ve, Je, Qe);
      },
      configurable: !0
    });
  });
}
let AxiosHeaders$2 = class {
  constructor(Ze) {
    Ze && this.set(Ze);
  }
  set(Ze, Fe, Ke) {
    const Ve = this;
    function Je(at, ut, lt) {
      const dt = normalizeHeader$1(ut);
      if (!dt)
        throw new Error("header name must be a non-empty string");
      const bt = utils$1.findKey(Ve, dt);
      (!bt || Ve[bt] === void 0 || lt === !0 || lt === void 0 && Ve[bt] !== !1) && (Ve[bt || ut] = normalizeValue$1(at));
    }
    const Qe = (at, ut) => utils$1.forEach(at, (lt, dt) => Je(lt, dt, ut));
    return utils$1.isPlainObject(Ze) || Ze instanceof this.constructor ? Qe(Ze, Fe) : utils$1.isString(Ze) && (Ze = Ze.trim()) && !isValidHeaderName$1(Ze) ? Qe(parseHeaders(Ze), Fe) : Ze != null && Je(Fe, Ze, Ke), this;
  }
  get(Ze, Fe) {
    if (Ze = normalizeHeader$1(Ze), Ze) {
      const Ke = utils$1.findKey(this, Ze);
      if (Ke) {
        const Ve = this[Ke];
        if (!Fe)
          return Ve;
        if (Fe === !0)
          return parseTokens$1(Ve);
        if (utils$1.isFunction(Fe))
          return Fe.call(this, Ve, Ke);
        if (utils$1.isRegExp(Fe))
          return Fe.exec(Ve);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(Ze, Fe) {
    if (Ze = normalizeHeader$1(Ze), Ze) {
      const Ke = utils$1.findKey(this, Ze);
      return !!(Ke && this[Ke] !== void 0 && (!Fe || matchHeaderValue$1(this, this[Ke], Ke, Fe)));
    }
    return !1;
  }
  delete(Ze, Fe) {
    const Ke = this;
    let Ve = !1;
    function Je(Qe) {
      if (Qe = normalizeHeader$1(Qe), Qe) {
        const at = utils$1.findKey(Ke, Qe);
        at && (!Fe || matchHeaderValue$1(Ke, Ke[at], at, Fe)) && (delete Ke[at], Ve = !0);
      }
    }
    return utils$1.isArray(Ze) ? Ze.forEach(Je) : Je(Ze), Ve;
  }
  clear(Ze) {
    const Fe = Object.keys(this);
    let Ke = Fe.length, Ve = !1;
    for (; Ke--; ) {
      const Je = Fe[Ke];
      (!Ze || matchHeaderValue$1(this, this[Je], Je, Ze, !0)) && (delete this[Je], Ve = !0);
    }
    return Ve;
  }
  normalize(Ze) {
    const Fe = this, Ke = {};
    return utils$1.forEach(this, (Ve, Je) => {
      const Qe = utils$1.findKey(Ke, Je);
      if (Qe) {
        Fe[Qe] = normalizeValue$1(Ve), delete Fe[Je];
        return;
      }
      const at = Ze ? formatHeader$1(Je) : String(Je).trim();
      at !== Je && delete Fe[Je], Fe[at] = normalizeValue$1(Ve), Ke[at] = !0;
    }), this;
  }
  concat(...Ze) {
    return this.constructor.concat(this, ...Ze);
  }
  toJSON(Ze) {
    const Fe = /* @__PURE__ */ Object.create(null);
    return utils$1.forEach(this, (Ke, Ve) => {
      Ke != null && Ke !== !1 && (Fe[Ve] = Ze && utils$1.isArray(Ke) ? Ke.join(", ") : Ke);
    }), Fe;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([Ze, Fe]) => Ze + ": " + Fe).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(Ze) {
    return Ze instanceof this ? Ze : new this(Ze);
  }
  static concat(Ze, ...Fe) {
    const Ke = new this(Ze);
    return Fe.forEach((Ve) => Ke.set(Ve)), Ke;
  }
  static accessor(Ze) {
    const Ke = (this[$internals$1] = this[$internals$1] = {
      accessors: {}
    }).accessors, Ve = this.prototype;
    function Je(Qe) {
      const at = normalizeHeader$1(Qe);
      Ke[at] || (buildAccessors$1(Ve, Qe), Ke[at] = !0);
    }
    return utils$1.isArray(Ze) ? Ze.forEach(Je) : Je(Ze), this;
  }
};
AxiosHeaders$2.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders$2.prototype, ({ value: $e }, Ze) => {
  let Fe = Ze[0].toUpperCase() + Ze.slice(1);
  return {
    get: () => $e,
    set(Ke) {
      this[Fe] = Ke;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders$2);
const AxiosHeaders$3 = AxiosHeaders$2;
function transformData$1($e, Ze) {
  const Fe = this || defaults$2, Ke = Ze || Fe, Ve = AxiosHeaders$3.from(Ke.headers);
  let Je = Ke.data;
  return utils$1.forEach($e, function(at) {
    Je = at.call(Fe, Je, Ve.normalize(), Ze ? Ze.status : void 0);
  }), Ve.normalize(), Je;
}
function isCancel$2($e) {
  return !!($e && $e.__CANCEL__);
}
function CanceledError$2($e, Ze, Fe) {
  AxiosError$2.call(this, $e ?? "canceled", AxiosError$2.ERR_CANCELED, Ze, Fe), this.name = "CanceledError";
}
utils$1.inherits(CanceledError$2, AxiosError$2, {
  __CANCEL__: !0
});
function settle$1($e, Ze, Fe) {
  const Ke = Fe.config.validateStatus;
  !Fe.status || !Ke || Ke(Fe.status) ? $e(Fe) : Ze(new AxiosError$2(
    "Request failed with status code " + Fe.status,
    [AxiosError$2.ERR_BAD_REQUEST, AxiosError$2.ERR_BAD_RESPONSE][Math.floor(Fe.status / 100) - 4],
    Fe.config,
    Fe.request,
    Fe
  ));
}
const cookies = platform$1.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write($e, Ze, Fe, Ke, Ve, Je) {
      const Qe = [$e + "=" + encodeURIComponent(Ze)];
      utils$1.isNumber(Fe) && Qe.push("expires=" + new Date(Fe).toGMTString()), utils$1.isString(Ke) && Qe.push("path=" + Ke), utils$1.isString(Ve) && Qe.push("domain=" + Ve), Je === !0 && Qe.push("secure"), document.cookie = Qe.join("; ");
    },
    read($e) {
      const Ze = document.cookie.match(new RegExp("(^|;\\s*)(" + $e + ")=([^;]*)"));
      return Ze ? decodeURIComponent(Ze[3]) : null;
    },
    remove($e) {
      this.write($e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL$1($e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test($e);
}
function combineURLs$1($e, Ze) {
  return Ze ? $e.replace(/\/+$/, "") + "/" + Ze.replace(/^\/+/, "") : $e;
}
function buildFullPath$1($e, Ze) {
  return $e && !isAbsoluteURL$1(Ze) ? combineURLs$1($e, Ze) : Ze;
}
const isURLSameOrigin = platform$1.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const Ze = /(msie|trident)/i.test(navigator.userAgent), Fe = document.createElement("a");
    let Ke;
    function Ve(Je) {
      let Qe = Je;
      return Ze && (Fe.setAttribute("href", Qe), Qe = Fe.href), Fe.setAttribute("href", Qe), {
        href: Fe.href,
        protocol: Fe.protocol ? Fe.protocol.replace(/:$/, "") : "",
        host: Fe.host,
        search: Fe.search ? Fe.search.replace(/^\?/, "") : "",
        hash: Fe.hash ? Fe.hash.replace(/^#/, "") : "",
        hostname: Fe.hostname,
        port: Fe.port,
        pathname: Fe.pathname.charAt(0) === "/" ? Fe.pathname : "/" + Fe.pathname
      };
    }
    return Ke = Ve(window.location.href), function(Qe) {
      const at = utils$1.isString(Qe) ? Ve(Qe) : Qe;
      return at.protocol === Ke.protocol && at.host === Ke.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function() {
    return function() {
      return !0;
    };
  }()
);
function parseProtocol$1($e) {
  const Ze = /^([-+\w]{1,25})(:?\/\/|:)/.exec($e);
  return Ze && Ze[1] || "";
}
function speedometer$1($e, Ze) {
  $e = $e || 10;
  const Fe = new Array($e), Ke = new Array($e);
  let Ve = 0, Je = 0, Qe;
  return Ze = Ze !== void 0 ? Ze : 1e3, function(ut) {
    const lt = Date.now(), dt = Ke[Je];
    Qe || (Qe = lt), Fe[Ve] = ut, Ke[Ve] = lt;
    let bt = Je, $t = 0;
    for (; bt !== Ve; )
      $t += Fe[bt++], bt = bt % $e;
    if (Ve = (Ve + 1) % $e, Ve === Je && (Je = (Je + 1) % $e), lt - Qe < Ze)
      return;
    const vt = dt && lt - dt;
    return vt ? Math.round($t * 1e3 / vt) : void 0;
  };
}
function progressEventReducer$1($e, Ze) {
  let Fe = 0;
  const Ke = speedometer$1(50, 250);
  return (Ve) => {
    const Je = Ve.loaded, Qe = Ve.lengthComputable ? Ve.total : void 0, at = Je - Fe, ut = Ke(at), lt = Je <= Qe;
    Fe = Je;
    const dt = {
      loaded: Je,
      total: Qe,
      progress: Qe ? Je / Qe : void 0,
      bytes: at,
      rate: ut || void 0,
      estimated: ut && Qe && lt ? (Qe - Je) / ut : void 0,
      event: Ve
    };
    dt[Ze ? "download" : "upload"] = !0, $e(dt);
  };
}
const isXHRAdapterSupported$1 = typeof XMLHttpRequest < "u", xhrAdapter = isXHRAdapterSupported$1 && function($e) {
  return new Promise(function(Fe, Ke) {
    let Ve = $e.data;
    const Je = AxiosHeaders$3.from($e.headers).normalize();
    let { responseType: Qe, withXSRFToken: at } = $e, ut;
    function lt() {
      $e.cancelToken && $e.cancelToken.unsubscribe(ut), $e.signal && $e.signal.removeEventListener("abort", ut);
    }
    let dt;
    if (utils$1.isFormData(Ve)) {
      if (platform$1.hasStandardBrowserEnv || platform$1.hasStandardBrowserWebWorkerEnv)
        Je.setContentType(!1);
      else if ((dt = Je.getContentType()) !== !1) {
        const [xt, ...Et] = dt ? dt.split(";").map((Tt) => Tt.trim()).filter(Boolean) : [];
        Je.setContentType([xt || "multipart/form-data", ...Et].join("; "));
      }
    }
    let bt = new XMLHttpRequest();
    if ($e.auth) {
      const xt = $e.auth.username || "", Et = $e.auth.password ? unescape(encodeURIComponent($e.auth.password)) : "";
      Je.set("Authorization", "Basic " + btoa(xt + ":" + Et));
    }
    const $t = buildFullPath$1($e.baseURL, $e.url);
    bt.open($e.method.toUpperCase(), buildURL$1($t, $e.params, $e.paramsSerializer), !0), bt.timeout = $e.timeout;
    function vt() {
      if (!bt)
        return;
      const xt = AxiosHeaders$3.from(
        "getAllResponseHeaders" in bt && bt.getAllResponseHeaders()
      ), Tt = {
        data: !Qe || Qe === "text" || Qe === "json" ? bt.responseText : bt.response,
        status: bt.status,
        statusText: bt.statusText,
        headers: xt,
        config: $e,
        request: bt
      };
      settle$1(function(Ct) {
        Fe(Ct), lt();
      }, function(Ct) {
        Ke(Ct), lt();
      }, Tt), bt = null;
    }
    if ("onloadend" in bt ? bt.onloadend = vt : bt.onreadystatechange = function() {
      !bt || bt.readyState !== 4 || bt.status === 0 && !(bt.responseURL && bt.responseURL.indexOf("file:") === 0) || setTimeout(vt);
    }, bt.onabort = function() {
      bt && (Ke(new AxiosError$2("Request aborted", AxiosError$2.ECONNABORTED, $e, bt)), bt = null);
    }, bt.onerror = function() {
      Ke(new AxiosError$2("Network Error", AxiosError$2.ERR_NETWORK, $e, bt)), bt = null;
    }, bt.ontimeout = function() {
      let Et = $e.timeout ? "timeout of " + $e.timeout + "ms exceeded" : "timeout exceeded";
      const Tt = $e.transitional || transitionalDefaults;
      $e.timeoutErrorMessage && (Et = $e.timeoutErrorMessage), Ke(new AxiosError$2(
        Et,
        Tt.clarifyTimeoutError ? AxiosError$2.ETIMEDOUT : AxiosError$2.ECONNABORTED,
        $e,
        bt
      )), bt = null;
    }, platform$1.hasStandardBrowserEnv && (at && utils$1.isFunction(at) && (at = at($e)), at || at !== !1 && isURLSameOrigin($t))) {
      const xt = $e.xsrfHeaderName && $e.xsrfCookieName && cookies.read($e.xsrfCookieName);
      xt && Je.set($e.xsrfHeaderName, xt);
    }
    Ve === void 0 && Je.setContentType(null), "setRequestHeader" in bt && utils$1.forEach(Je.toJSON(), function(Et, Tt) {
      bt.setRequestHeader(Tt, Et);
    }), utils$1.isUndefined($e.withCredentials) || (bt.withCredentials = !!$e.withCredentials), Qe && Qe !== "json" && (bt.responseType = $e.responseType), typeof $e.onDownloadProgress == "function" && bt.addEventListener("progress", progressEventReducer$1($e.onDownloadProgress, !0)), typeof $e.onUploadProgress == "function" && bt.upload && bt.upload.addEventListener("progress", progressEventReducer$1($e.onUploadProgress)), ($e.cancelToken || $e.signal) && (ut = (xt) => {
      bt && (Ke(!xt || xt.type ? new CanceledError$2(null, $e, bt) : xt), bt.abort(), bt = null);
    }, $e.cancelToken && $e.cancelToken.subscribe(ut), $e.signal && ($e.signal.aborted ? ut() : $e.signal.addEventListener("abort", ut)));
    const wt = parseProtocol$1($t);
    if (wt && platform$1.protocols.indexOf(wt) === -1) {
      Ke(new AxiosError$2("Unsupported protocol " + wt + ":", AxiosError$2.ERR_BAD_REQUEST, $e));
      return;
    }
    bt.send(Ve || null);
  });
}, knownAdapters$1 = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils$1.forEach(knownAdapters$1, ($e, Ze) => {
  if ($e) {
    try {
      Object.defineProperty($e, "name", { value: Ze });
    } catch {
    }
    Object.defineProperty($e, "adapterName", { value: Ze });
  }
});
const renderReason = ($e) => `- ${$e}`, isResolvedHandle = ($e) => utils$1.isFunction($e) || $e === null || $e === !1, adapters = {
  getAdapter: ($e) => {
    $e = utils$1.isArray($e) ? $e : [$e];
    const { length: Ze } = $e;
    let Fe, Ke;
    const Ve = {};
    for (let Je = 0; Je < Ze; Je++) {
      Fe = $e[Je];
      let Qe;
      if (Ke = Fe, !isResolvedHandle(Fe) && (Ke = knownAdapters$1[(Qe = String(Fe)).toLowerCase()], Ke === void 0))
        throw new AxiosError$2(`Unknown adapter '${Qe}'`);
      if (Ke)
        break;
      Ve[Qe || "#" + Je] = Ke;
    }
    if (!Ke) {
      const Je = Object.entries(Ve).map(
        ([at, ut]) => `adapter ${at} ` + (ut === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let Qe = Ze ? Je.length > 1 ? `since :
` + Je.map(renderReason).join(`
`) : " " + renderReason(Je[0]) : "as no adapter specified";
      throw new AxiosError$2(
        "There is no suitable adapter to dispatch the request " + Qe,
        "ERR_NOT_SUPPORT"
      );
    }
    return Ke;
  },
  adapters: knownAdapters$1
};
function throwIfCancellationRequested$1($e) {
  if ($e.cancelToken && $e.cancelToken.throwIfRequested(), $e.signal && $e.signal.aborted)
    throw new CanceledError$2(null, $e);
}
function dispatchRequest$1($e) {
  return throwIfCancellationRequested$1($e), $e.headers = AxiosHeaders$3.from($e.headers), $e.data = transformData$1.call(
    $e,
    $e.transformRequest
  ), ["post", "put", "patch"].indexOf($e.method) !== -1 && $e.headers.setContentType("application/x-www-form-urlencoded", !1), adapters.getAdapter($e.adapter || defaults$2.adapter)($e).then(function(Ke) {
    return throwIfCancellationRequested$1($e), Ke.data = transformData$1.call(
      $e,
      $e.transformResponse,
      Ke
    ), Ke.headers = AxiosHeaders$3.from(Ke.headers), Ke;
  }, function(Ke) {
    return isCancel$2(Ke) || (throwIfCancellationRequested$1($e), Ke && Ke.response && (Ke.response.data = transformData$1.call(
      $e,
      $e.transformResponse,
      Ke.response
    ), Ke.response.headers = AxiosHeaders$3.from(Ke.response.headers))), Promise.reject(Ke);
  });
}
const headersToObject$1 = ($e) => $e instanceof AxiosHeaders$3 ? $e.toJSON() : $e;
function mergeConfig$2($e, Ze) {
  Ze = Ze || {};
  const Fe = {};
  function Ke(lt, dt, bt) {
    return utils$1.isPlainObject(lt) && utils$1.isPlainObject(dt) ? utils$1.merge.call({ caseless: bt }, lt, dt) : utils$1.isPlainObject(dt) ? utils$1.merge({}, dt) : utils$1.isArray(dt) ? dt.slice() : dt;
  }
  function Ve(lt, dt, bt) {
    if (utils$1.isUndefined(dt)) {
      if (!utils$1.isUndefined(lt))
        return Ke(void 0, lt, bt);
    } else
      return Ke(lt, dt, bt);
  }
  function Je(lt, dt) {
    if (!utils$1.isUndefined(dt))
      return Ke(void 0, dt);
  }
  function Qe(lt, dt) {
    if (utils$1.isUndefined(dt)) {
      if (!utils$1.isUndefined(lt))
        return Ke(void 0, lt);
    } else
      return Ke(void 0, dt);
  }
  function at(lt, dt, bt) {
    if (bt in Ze)
      return Ke(lt, dt);
    if (bt in $e)
      return Ke(void 0, lt);
  }
  const ut = {
    url: Je,
    method: Je,
    data: Je,
    baseURL: Qe,
    transformRequest: Qe,
    transformResponse: Qe,
    paramsSerializer: Qe,
    timeout: Qe,
    timeoutMessage: Qe,
    withCredentials: Qe,
    withXSRFToken: Qe,
    adapter: Qe,
    responseType: Qe,
    xsrfCookieName: Qe,
    xsrfHeaderName: Qe,
    onUploadProgress: Qe,
    onDownloadProgress: Qe,
    decompress: Qe,
    maxContentLength: Qe,
    maxBodyLength: Qe,
    beforeRedirect: Qe,
    transport: Qe,
    httpAgent: Qe,
    httpsAgent: Qe,
    cancelToken: Qe,
    socketPath: Qe,
    responseEncoding: Qe,
    validateStatus: at,
    headers: (lt, dt) => Ve(headersToObject$1(lt), headersToObject$1(dt), !0)
  };
  return utils$1.forEach(Object.keys(Object.assign({}, $e, Ze)), function(dt) {
    const bt = ut[dt] || Ve, $t = bt($e[dt], Ze[dt], dt);
    utils$1.isUndefined($t) && bt !== at || (Fe[dt] = $t);
  }), Fe;
}
const VERSION$2 = "1.6.2", validators$2 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(($e, Ze) => {
  validators$2[$e] = function(Ke) {
    return typeof Ke === $e || "a" + (Ze < 1 ? "n " : " ") + $e;
  };
});
const deprecatedWarnings$1 = {};
validators$2.transitional = function(Ze, Fe, Ke) {
  function Ve(Je, Qe) {
    return "[Axios v" + VERSION$2 + "] Transitional option '" + Je + "'" + Qe + (Ke ? ". " + Ke : "");
  }
  return (Je, Qe, at) => {
    if (Ze === !1)
      throw new AxiosError$2(
        Ve(Qe, " has been removed" + (Fe ? " in " + Fe : "")),
        AxiosError$2.ERR_DEPRECATED
      );
    return Fe && !deprecatedWarnings$1[Qe] && (deprecatedWarnings$1[Qe] = !0, console.warn(
      Ve(
        Qe,
        " has been deprecated since v" + Fe + " and will be removed in the near future"
      )
    )), Ze ? Ze(Je, Qe, at) : !0;
  };
};
function assertOptions$1($e, Ze, Fe) {
  if (typeof $e != "object")
    throw new AxiosError$2("options must be an object", AxiosError$2.ERR_BAD_OPTION_VALUE);
  const Ke = Object.keys($e);
  let Ve = Ke.length;
  for (; Ve-- > 0; ) {
    const Je = Ke[Ve], Qe = Ze[Je];
    if (Qe) {
      const at = $e[Je], ut = at === void 0 || Qe(at, Je, $e);
      if (ut !== !0)
        throw new AxiosError$2("option " + Je + " must be " + ut, AxiosError$2.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (Fe !== !0)
      throw new AxiosError$2("Unknown option " + Je, AxiosError$2.ERR_BAD_OPTION);
  }
}
const validator = {
  assertOptions: assertOptions$1,
  validators: validators$2
}, validators$1 = validator.validators;
let Axios$2 = class {
  constructor(Ze) {
    this.defaults = Ze, this.interceptors = {
      request: new InterceptorManager$2(),
      response: new InterceptorManager$2()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(Ze, Fe) {
    typeof Ze == "string" ? (Fe = Fe || {}, Fe.url = Ze) : Fe = Ze || {}, Fe = mergeConfig$2(this.defaults, Fe);
    const { transitional: Ke, paramsSerializer: Ve, headers: Je } = Fe;
    Ke !== void 0 && validator.assertOptions(Ke, {
      silentJSONParsing: validators$1.transitional(validators$1.boolean),
      forcedJSONParsing: validators$1.transitional(validators$1.boolean),
      clarifyTimeoutError: validators$1.transitional(validators$1.boolean)
    }, !1), Ve != null && (utils$1.isFunction(Ve) ? Fe.paramsSerializer = {
      serialize: Ve
    } : validator.assertOptions(Ve, {
      encode: validators$1.function,
      serialize: validators$1.function
    }, !0)), Fe.method = (Fe.method || this.defaults.method || "get").toLowerCase();
    let Qe = Je && utils$1.merge(
      Je.common,
      Je[Fe.method]
    );
    Je && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (wt) => {
        delete Je[wt];
      }
    ), Fe.headers = AxiosHeaders$3.concat(Qe, Je);
    const at = [];
    let ut = !0;
    this.interceptors.request.forEach(function(xt) {
      typeof xt.runWhen == "function" && xt.runWhen(Fe) === !1 || (ut = ut && xt.synchronous, at.unshift(xt.fulfilled, xt.rejected));
    });
    const lt = [];
    this.interceptors.response.forEach(function(xt) {
      lt.push(xt.fulfilled, xt.rejected);
    });
    let dt, bt = 0, $t;
    if (!ut) {
      const wt = [dispatchRequest$1.bind(this), void 0];
      for (wt.unshift.apply(wt, at), wt.push.apply(wt, lt), $t = wt.length, dt = Promise.resolve(Fe); bt < $t; )
        dt = dt.then(wt[bt++], wt[bt++]);
      return dt;
    }
    $t = at.length;
    let vt = Fe;
    for (bt = 0; bt < $t; ) {
      const wt = at[bt++], xt = at[bt++];
      try {
        vt = wt(vt);
      } catch (Et) {
        xt.call(this, Et);
        break;
      }
    }
    try {
      dt = dispatchRequest$1.call(this, vt);
    } catch (wt) {
      return Promise.reject(wt);
    }
    for (bt = 0, $t = lt.length; bt < $t; )
      dt = dt.then(lt[bt++], lt[bt++]);
    return dt;
  }
  getUri(Ze) {
    Ze = mergeConfig$2(this.defaults, Ze);
    const Fe = buildFullPath$1(Ze.baseURL, Ze.url);
    return buildURL$1(Fe, Ze.params, Ze.paramsSerializer);
  }
};
utils$1.forEach(["delete", "get", "head", "options"], function(Ze) {
  Axios$2.prototype[Ze] = function(Fe, Ke) {
    return this.request(mergeConfig$2(Ke || {}, {
      method: Ze,
      url: Fe,
      data: (Ke || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function(Ze) {
  function Fe(Ke) {
    return function(Je, Qe, at) {
      return this.request(mergeConfig$2(at || {}, {
        method: Ze,
        headers: Ke ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: Je,
        data: Qe
      }));
    };
  }
  Axios$2.prototype[Ze] = Fe(), Axios$2.prototype[Ze + "Form"] = Fe(!0);
});
const Axios$3 = Axios$2;
let CancelToken$2 = class Dn {
  constructor(Ze) {
    if (typeof Ze != "function")
      throw new TypeError("executor must be a function.");
    let Fe;
    this.promise = new Promise(function(Je) {
      Fe = Je;
    });
    const Ke = this;
    this.promise.then((Ve) => {
      if (!Ke._listeners)
        return;
      let Je = Ke._listeners.length;
      for (; Je-- > 0; )
        Ke._listeners[Je](Ve);
      Ke._listeners = null;
    }), this.promise.then = (Ve) => {
      let Je;
      const Qe = new Promise((at) => {
        Ke.subscribe(at), Je = at;
      }).then(Ve);
      return Qe.cancel = function() {
        Ke.unsubscribe(Je);
      }, Qe;
    }, Ze(function(Je, Qe, at) {
      Ke.reason || (Ke.reason = new CanceledError$2(Je, Qe, at), Fe(Ke.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(Ze) {
    if (this.reason) {
      Ze(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(Ze) : this._listeners = [Ze];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(Ze) {
    if (!this._listeners)
      return;
    const Fe = this._listeners.indexOf(Ze);
    Fe !== -1 && this._listeners.splice(Fe, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let Ze;
    return {
      token: new Dn(function(Ve) {
        Ze = Ve;
      }),
      cancel: Ze
    };
  }
};
const CancelToken$3 = CancelToken$2;
function spread$2($e) {
  return function(Fe) {
    return $e.apply(null, Fe);
  };
}
function isAxiosError$2($e) {
  return utils$1.isObject($e) && $e.isAxiosError === !0;
}
const HttpStatusCode$2 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode$2).forEach(([$e, Ze]) => {
  HttpStatusCode$2[Ze] = $e;
});
const HttpStatusCode$3 = HttpStatusCode$2;
function createInstance$1($e) {
  const Ze = new Axios$3($e), Fe = bind$1(Axios$3.prototype.request, Ze);
  return utils$1.extend(Fe, Axios$3.prototype, Ze, { allOwnKeys: !0 }), utils$1.extend(Fe, Ze, null, { allOwnKeys: !0 }), Fe.create = function(Ve) {
    return createInstance$1(mergeConfig$2($e, Ve));
  }, Fe;
}
const axios$1 = createInstance$1(defaults$2);
axios$1.Axios = Axios$3;
axios$1.CanceledError = CanceledError$2;
axios$1.CancelToken = CancelToken$3;
axios$1.isCancel = isCancel$2;
axios$1.VERSION = VERSION$2;
axios$1.toFormData = toFormData$2;
axios$1.AxiosError = AxiosError$2;
axios$1.Cancel = axios$1.CanceledError;
axios$1.all = function(Ze) {
  return Promise.all(Ze);
};
axios$1.spread = spread$2;
axios$1.isAxiosError = isAxiosError$2;
axios$1.mergeConfig = mergeConfig$2;
axios$1.AxiosHeaders = AxiosHeaders$3;
axios$1.formToJSON = ($e) => formDataToJSON$1(utils$1.isHTMLForm($e) ? new FormData($e) : $e);
axios$1.getAdapter = adapters.getAdapter;
axios$1.HttpStatusCode = HttpStatusCode$3;
axios$1.default = axios$1;
const Pe$2 = axios$1, {
  Axios: Axios$1,
  AxiosError: AxiosError$1,
  CanceledError: CanceledError$1,
  isCancel: isCancel$1,
  CancelToken: CancelToken$1,
  VERSION: VERSION$1,
  all,
  Cancel: Cancel$1,
  isAxiosError: isAxiosError$1,
  spread: spread$1,
  toFormData: toFormData$1,
  AxiosHeaders: AxiosHeaders$1,
  HttpStatusCode: HttpStatusCode$1,
  formToJSON: formToJSON$1,
  getAdapter,
  mergeConfig: mergeConfig$1
} = Pe$2, index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Axios: Axios$1,
  AxiosError: AxiosError$1,
  AxiosHeaders: AxiosHeaders$1,
  Cancel: Cancel$1,
  CancelToken: CancelToken$1,
  CanceledError: CanceledError$1,
  HttpStatusCode: HttpStatusCode$1,
  VERSION: VERSION$1,
  all,
  default: Pe$2,
  formToJSON: formToJSON$1,
  getAdapter,
  isAxiosError: isAxiosError$1,
  isCancel: isCancel$1,
  mergeConfig: mergeConfig$1,
  spread: spread$1,
  toFormData: toFormData$1
}, Symbol.toStringTag, { value: "Module" }));
var lib = {};
Object.defineProperty(lib, "__esModule", {
  value: !0
});
var _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function($e) {
  return typeof $e;
} : function($e) {
  return $e && typeof Symbol == "function" && $e.constructor === Symbol && $e !== Symbol.prototype ? "symbol" : typeof $e;
}, isBrowser = typeof window < "u" && typeof window.document < "u", isNode = typeof process < "u" && process.versions != null && process.versions.node != null, isWebWorker = (typeof self > "u" ? "undefined" : _typeof(self)) === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope", isJsDom = typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom")), isDeno = typeof Deno < "u" && typeof Deno.version < "u" && typeof Deno.version.deno < "u", isBrowser_1 = lib.isBrowser = isBrowser;
lib.isWebWorker = isWebWorker;
var isNode_1 = lib.isNode = isNode;
lib.isJsDom = isJsDom;
lib.isDeno = isDeno;
var oe$2 = "https://api.botpress.cloud", ne$2 = 6e4, re$2 = "BP_API_URL", ie$2 = "BP_BOT_ID", pe$2 = "BP_INTEGRATION_ID", ce$2 = "BP_WORKSPACE_ID", le$2 = "BP_TOKEN";
function X$6($e) {
  let Ze = ue$2($e), Fe = {};
  Ze.workspaceId && (Fe["x-workspace-id"] = Ze.workspaceId), Ze.botId && (Fe["x-bot-id"] = Ze.botId), Ze.integrationId && (Fe["x-integration-id"] = Ze.integrationId), Ze.token && (Fe.Authorization = `Bearer ${Ze.token}`), Fe = { ...Fe, ...Ze.headers };
  let Ke = Ze.apiUrl ?? oe$2, Ve = Ze.timeout ?? ne$2;
  return { apiUrl: Ke, timeout: Ve, withCredentials: isBrowser_1, headers: Fe };
}
function ue$2($e) {
  return isBrowser_1 ? $e : isNode_1 ? de$2($e) : $e;
}
function de$2($e) {
  let Ze = { ...$e, apiUrl: $e.apiUrl ?? process.env[re$2], botId: $e.botId ?? process.env[ie$2], integrationId: $e.integrationId ?? process.env[pe$2], workspaceId: $e.workspaceId ?? process.env[ce$2] }, Fe = Ze.token ?? process.env[le$2];
  return Fe && (Ze.token = Fe), Ze;
}
var u$r = "https://api.botpress.cloud".replace(/\/+$/, ""), k$i = class {
  constructor(Ze, Fe = u$r, Ke = Pe$2) {
    Or(this, "configuration");
    this.basePath = Fe, this.axios = Ke, Ze && (this.configuration = Ze, this.basePath = Ze.basePath || this.basePath);
  }
}, I$d = class extends Error {
  constructor(Ze, Fe) {
    super(Fe), this.field = Ze, this.name = "RequiredError";
  }
}, d$o = "https://example.com", f$x = function($e, Ze, Fe) {
  if (Fe == null)
    throw new I$d(Ze, `Required parameter ${Ze} was null or undefined when calling ${$e}.`);
};
function v$l($e, Ze, Fe = "") {
  Ze != null && (typeof Ze == "object" ? Array.isArray(Ze) ? Ze.forEach((Ke) => v$l($e, Ke, Fe)) : Object.keys(Ze).forEach((Ke) => v$l($e, Ze[Ke], `${Fe}${Fe !== "" ? "." : ""}${Ke}`)) : $e.has(Fe) ? $e.append(Fe, Ze) : $e.set(Fe, Ze));
}
var g$i = function($e, ...Ze) {
  let Fe = new URLSearchParams($e.search);
  v$l(Fe, Ze), $e.search = Fe.toString();
}, C$a = function($e, Ze, Fe) {
  let Ke = typeof $e != "string";
  return (Ke && Fe && Fe.isJsonMime ? Fe.isJsonMime(Ze.headers["Content-Type"]) : Ke) ? JSON.stringify($e !== void 0 ? $e : {}) : $e || "";
}, y$p = function($e) {
  return $e.pathname + $e.search + $e.hash;
}, h$n = function($e, Ze, Fe, Ke) {
  return (Ve = Ze, Je = Fe) => {
    let Qe = { ...$e.options, url: ((Ke == null ? void 0 : Ke.basePath) || Je) + $e.url };
    return Ve.request(Qe);
  };
}, ye$2 = function($e) {
  return { addParticipant: async (Ze, Fe, Ke = {}) => {
    f$x("addParticipant", "id", Ze);
    let Ve = "/v1/chat/conversations/{id}/participants".replace("{id}", encodeURIComponent(String(Ze))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "POST", ...Qe, ...Ke }, ut = {}, lt = {};
    ut["Content-Type"] = "application/json", g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, at.data = C$a(Fe, at, $e), { url: y$p(Je), options: at };
  }, breakDownWorkspaceUsageByBot: async (Ze, Fe, Ke, Ve = {}) => {
    f$x("breakDownWorkspaceUsageByBot", "id", Ze), f$x("breakDownWorkspaceUsageByBot", "type", Fe);
    let Je = "/v1/admin/workspaces/{id}/usages/by-bot".replace("{id}", encodeURIComponent(String(Ze))), Qe = new URL(Je, d$o), at;
    $e && (at = $e.baseOptions);
    let ut = { method: "GET", ...at, ...Ve }, lt = {}, dt = {};
    Fe !== void 0 && (dt.type = Fe), Ke !== void 0 && (dt.period = Ke), g$i(Qe, dt);
    let bt = at && at.headers ? at.headers : {};
    return ut.headers = { ...lt, ...bt, ...Ve.headers }, { url: y$p(Qe), options: ut };
  }, callAction: async (Ze, Fe = {}) => {
    let Ke = "/v1/chat/actions", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, changeAISpendQuota: async (Ze, Fe = {}) => {
    let Ke = "/v1/admin/quotas/ai-spend", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "PUT", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, changeWorkspacePlan: async (Ze, Fe, Ke = {}) => {
    f$x("changeWorkspacePlan", "id", Ze);
    let Ve = "/v1/admin/workspaces/{id}/change-plan".replace("{id}", encodeURIComponent(String(Ze))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "PUT", ...Qe, ...Ke }, ut = {}, lt = {};
    ut["Content-Type"] = "application/json", g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, at.data = C$a(Fe, at, $e), { url: y$p(Je), options: at };
  }, chargeWorkspaceUnpaidInvoices: async (Ze, Fe, Ke = {}) => {
    f$x("chargeWorkspaceUnpaidInvoices", "id", Ze);
    let Ve = "/v1/admin/workspaces/{id}/billing/invoices/charge-unpaid".replace("{id}", encodeURIComponent(String(Ze))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "POST", ...Qe, ...Ke }, ut = {}, lt = {};
    ut["Content-Type"] = "application/json", g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, at.data = C$a(Fe, at, $e), { url: y$p(Je), options: at };
  }, configureIntegration: async (Ze, Fe = {}) => {
    let Ke = "/v1/chat/integrations/configure", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, createBot: async (Ze, Fe = {}) => {
    let Ke = "/v1/admin/bots", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, createConversation: async (Ze, Fe = {}) => {
    let Ke = "/v1/chat/conversations", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, createEvent: async (Ze, Fe = {}) => {
    let Ke = "/v1/chat/events", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, createFile: async (Ze, Fe = {}) => {
    let Ke = "/v1/storage/files", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, createIntegration: async (Ze, Fe = {}) => {
    let Ke = "/v1/admin/integrations", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, createMessage: async (Ze, Fe = {}) => {
    let Ke = "/v1/chat/messages", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, createPersonalAccessToken: async (Ze, Fe = {}) => {
    let Ke = "/v1/admin/account/pats", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, createUser: async (Ze, Fe = {}) => {
    let Ke = "/v1/chat/users", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, createWorkspace: async (Ze, Fe = {}) => {
    let Ke = "/v1/admin/workspaces", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, createWorkspaceMember: async (Ze, Fe = {}) => {
    let Ke = "/v1/admin/workspace-members", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, deleteBot: async (Ze, Fe = {}) => {
    f$x("deleteBot", "id", Ze);
    let Ke = "/v1/admin/bots/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "DELETE", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, deleteBotIssue: async (Ze, Fe, Ke = {}) => {
    f$x("deleteBotIssue", "id", Ze), f$x("deleteBotIssue", "issueId", Fe);
    let Ve = "/v1/admin/bots/{id}/issues/{issueId}".replace("{id}", encodeURIComponent(String(Ze))).replace("{issueId}", encodeURIComponent(String(Fe))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "DELETE", ...Qe, ...Ke }, ut = {};
    g$i(Je, {});
    let lt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...lt, ...Ke.headers }, { url: y$p(Je), options: at };
  }, deleteConversation: async (Ze, Fe = {}) => {
    f$x("deleteConversation", "id", Ze);
    let Ke = "/v1/chat/conversations/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "DELETE", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, deleteFile: async (Ze, Fe = {}) => {
    f$x("deleteFile", "id", Ze);
    let Ke = "/v1/storage/files/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "DELETE", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, deleteIntegration: async (Ze, Fe = {}) => {
    f$x("deleteIntegration", "id", Ze);
    let Ke = "/v1/admin/integrations/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "DELETE", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, deleteMessage: async (Ze, Fe = {}) => {
    f$x("deleteMessage", "id", Ze);
    let Ke = "/v1/chat/messages/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "DELETE", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, deletePersonalAccessToken: async (Ze, Fe = {}) => {
    f$x("deletePersonalAccessToken", "id", Ze);
    let Ke = "/v1/admin/account/pats/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "DELETE", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, deleteUser: async (Ze, Fe = {}) => {
    f$x("deleteUser", "id", Ze);
    let Ke = "/v1/chat/users/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "DELETE", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, deleteWorkspace: async (Ze, Fe = {}) => {
    f$x("deleteWorkspace", "id", Ze);
    let Ke = "/v1/admin/workspaces/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "DELETE", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, deleteWorkspaceMember: async (Ze, Fe = {}) => {
    f$x("deleteWorkspaceMember", "id", Ze);
    let Ke = "/v1/admin/workspace-members/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "DELETE", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, downloadFile: async (Ze, Fe = {}) => {
    f$x("downloadFile", "id", Ze);
    let Ke = "/v1/storage/files/{id}/download".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "GET", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, getAccount: async (Ze = {}) => {
    let Fe = "/v1/admin/account/me", Ke = new URL(Fe, d$o), Ve;
    $e && (Ve = $e.baseOptions);
    let Je = { method: "GET", ...Ve, ...Ze }, Qe = {};
    g$i(Ke, {});
    let at = Ve && Ve.headers ? Ve.headers : {};
    return Je.headers = { ...Qe, ...at, ...Ze.headers }, { url: y$p(Ke), options: Je };
  }, getAllWorkspaceQuotaCompletion: async (Ze = {}) => {
    let Fe = "/v1/admin/workspaces/usages/quota-completion", Ke = new URL(Fe, d$o), Ve;
    $e && (Ve = $e.baseOptions);
    let Je = { method: "GET", ...Ve, ...Ze }, Qe = {};
    g$i(Ke, {});
    let at = Ve && Ve.headers ? Ve.headers : {};
    return Je.headers = { ...Qe, ...at, ...Ze.headers }, { url: y$p(Ke), options: Je };
  }, getAuditRecords: async (Ze, Fe, Ke = {}) => {
    f$x("getAuditRecords", "id", Ze);
    let Ve = "/v1/admin/workspaces/{id}/audit-records".replace("{id}", encodeURIComponent(String(Ze))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "GET", ...Qe, ...Ke }, ut = {}, lt = {};
    Fe !== void 0 && (lt.nextToken = Fe), g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, { url: y$p(Je), options: at };
  }, getBot: async (Ze, Fe = {}) => {
    f$x("getBot", "id", Ze);
    let Ke = "/v1/admin/bots/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "GET", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, getBotAnalytics: async (Ze, Fe, Ke, Ve = {}) => {
    f$x("getBotAnalytics", "id", Ze), f$x("getBotAnalytics", "startDate", Fe), f$x("getBotAnalytics", "endDate", Ke);
    let Je = "/v1/admin/bots/{id}/analytics".replace("{id}", encodeURIComponent(String(Ze))), Qe = new URL(Je, d$o), at;
    $e && (at = $e.baseOptions);
    let ut = { method: "GET", ...at, ...Ve }, lt = {}, dt = {};
    Fe !== void 0 && (dt.startDate = Fe), Ke !== void 0 && (dt.endDate = Ke), g$i(Qe, dt);
    let bt = at && at.headers ? at.headers : {};
    return ut.headers = { ...lt, ...bt, ...Ve.headers }, { url: y$p(Qe), options: ut };
  }, getBotLogs: async (Ze, Fe, Ke, Ve, Je = {}) => {
    f$x("getBotLogs", "id", Ze), f$x("getBotLogs", "timeStart", Fe), f$x("getBotLogs", "timeEnd", Ke);
    let Qe = "/v1/admin/bots/{id}/logs".replace("{id}", encodeURIComponent(String(Ze))), at = new URL(Qe, d$o), ut;
    $e && (ut = $e.baseOptions);
    let lt = { method: "GET", ...ut, ...Je }, dt = {}, bt = {};
    Fe !== void 0 && (bt.timeStart = Fe), Ke !== void 0 && (bt.timeEnd = Ke), Ve !== void 0 && (bt.nextToken = Ve), g$i(at, bt);
    let $t = ut && ut.headers ? ut.headers : {};
    return lt.headers = { ...dt, ...$t, ...Je.headers }, { url: y$p(at), options: lt };
  }, getBotWebchat: async (Ze, Fe, Ke = {}) => {
    f$x("getBotWebchat", "id", Ze), f$x("getBotWebchat", "type", Fe);
    let Ve = "/v1/admin/bots/{id}/webchat".replace("{id}", encodeURIComponent(String(Ze))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "GET", ...Qe, ...Ke }, ut = {}, lt = {};
    Fe !== void 0 && (lt.type = Fe), g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, { url: y$p(Je), options: at };
  }, getConversation: async (Ze, Fe = {}) => {
    f$x("getConversation", "id", Ze);
    let Ke = "/v1/chat/conversations/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "GET", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, getEvent: async (Ze, Fe = {}) => {
    f$x("getEvent", "id", Ze);
    let Ke = "/v1/chat/events/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "GET", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, getFile: async (Ze, Fe = {}) => {
    f$x("getFile", "id", Ze);
    let Ke = "/v1/storage/files/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "GET", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, getIntegration: async (Ze, Fe = {}) => {
    f$x("getIntegration", "id", Ze);
    let Ke = "/v1/admin/integrations/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "GET", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, getIntegrationByName: async (Ze, Fe, Ke = {}) => {
    f$x("getIntegrationByName", "name", Ze), f$x("getIntegrationByName", "version", Fe);
    let Ve = "/v1/admin/integrations/{name}/{version}".replace("{name}", encodeURIComponent(String(Ze))).replace("{version}", encodeURIComponent(String(Fe))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "GET", ...Qe, ...Ke }, ut = {};
    g$i(Je, {});
    let lt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...lt, ...Ke.headers }, { url: y$p(Je), options: at };
  }, getIntegrationLogs: async (Ze, Fe, Ke, Ve, Je = {}) => {
    f$x("getIntegrationLogs", "id", Ze), f$x("getIntegrationLogs", "timeStart", Fe), f$x("getIntegrationLogs", "timeEnd", Ke);
    let Qe = "/v1/admin/integrations/{id}/logs".replace("{id}", encodeURIComponent(String(Ze))), at = new URL(Qe, d$o), ut;
    $e && (ut = $e.baseOptions);
    let lt = { method: "GET", ...ut, ...Je }, dt = {}, bt = {};
    Fe !== void 0 && (bt.timeStart = Fe), Ke !== void 0 && (bt.timeEnd = Ke), Ve !== void 0 && (bt.nextToken = Ve), g$i(at, bt);
    let $t = ut && ut.headers ? ut.headers : {};
    return lt.headers = { ...dt, ...$t, ...Je.headers }, { url: y$p(at), options: lt };
  }, getMessage: async (Ze, Fe = {}) => {
    f$x("getMessage", "id", Ze);
    let Ke = "/v1/chat/messages/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "GET", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, getOrCreateConversation: async (Ze, Fe = {}) => {
    let Ke = "/v1/chat/conversations/get-or-create", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, getOrCreateMessage: async (Ze, Fe = {}) => {
    let Ke = "/v1/chat/messages/get-or-create", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, getOrCreateUser: async (Ze, Fe = {}) => {
    let Ke = "/v1/chat/users/get-or-create", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, getParticipant: async (Ze, Fe, Ke = {}) => {
    f$x("getParticipant", "id", Ze), f$x("getParticipant", "userId", Fe);
    let Ve = "/v1/chat/conversations/{id}/participants/{userId}".replace("{id}", encodeURIComponent(String(Ze))).replace("{userId}", encodeURIComponent(String(Fe))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "GET", ...Qe, ...Ke }, ut = {};
    g$i(Je, {});
    let lt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...lt, ...Ke.headers }, { url: y$p(Je), options: at };
  }, getPublicIntegration: async (Ze, Fe, Ke = {}) => {
    f$x("getPublicIntegration", "name", Ze), f$x("getPublicIntegration", "version", Fe);
    let Ve = "/v1/admin/hub/integrations/{name}/{version}".replace("{name}", encodeURIComponent(String(Ze))).replace("{version}", encodeURIComponent(String(Fe))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "GET", ...Qe, ...Ke }, ut = {};
    g$i(Je, {});
    let lt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...lt, ...Ke.headers }, { url: y$p(Je), options: at };
  }, getPublicIntegrationById: async (Ze, Fe = {}) => {
    f$x("getPublicIntegrationById", "id", Ze);
    let Ke = "/v1/admin/hub/integrations/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "GET", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, getState: async (Ze, Fe, Ke, Ve = {}) => {
    f$x("getState", "type", Ze), f$x("getState", "id", Fe), f$x("getState", "name", Ke);
    let Je = "/v1/chat/states/{type}/{id}/{name}".replace("{type}", encodeURIComponent(String(Ze))).replace("{id}", encodeURIComponent(String(Fe))).replace("{name}", encodeURIComponent(String(Ke))), Qe = new URL(Je, d$o), at;
    $e && (at = $e.baseOptions);
    let ut = { method: "GET", ...at, ...Ve }, lt = {};
    g$i(Qe, {});
    let dt = at && at.headers ? at.headers : {};
    return ut.headers = { ...lt, ...dt, ...Ve.headers }, { url: y$p(Qe), options: ut };
  }, getUsage: async (Ze, Fe, Ke, Ve = {}) => {
    f$x("getUsage", "type", Ze), f$x("getUsage", "id", Fe);
    let Je = "/v1/admin/usages/{id}".replace("{id}", encodeURIComponent(String(Fe))), Qe = new URL(Je, d$o), at;
    $e && (at = $e.baseOptions);
    let ut = { method: "GET", ...at, ...Ve }, lt = {}, dt = {};
    Ze !== void 0 && (dt.type = Ze), Ke !== void 0 && (dt.period = Ke), g$i(Qe, dt);
    let bt = at && at.headers ? at.headers : {};
    return ut.headers = { ...lt, ...bt, ...Ve.headers }, { url: y$p(Qe), options: ut };
  }, getUser: async (Ze, Fe = {}) => {
    f$x("getUser", "id", Ze);
    let Ke = "/v1/chat/users/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "GET", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, getWorkspace: async (Ze, Fe = {}) => {
    f$x("getWorkspace", "id", Ze);
    let Ke = "/v1/admin/workspaces/{id}".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "GET", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, getWorkspaceBillingDetails: async (Ze, Fe = {}) => {
    f$x("getWorkspaceBillingDetails", "id", Ze);
    let Ke = "/v1/admin/workspaces/{id}/billing/details".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "GET", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, getWorkspaceQuota: async (Ze, Fe, Ke, Ve = {}) => {
    f$x("getWorkspaceQuota", "id", Ze), f$x("getWorkspaceQuota", "type", Fe);
    let Je = "/v1/admin/workspaces/{id}/quota".replace("{id}", encodeURIComponent(String(Ze))), Qe = new URL(Je, d$o), at;
    $e && (at = $e.baseOptions);
    let ut = { method: "GET", ...at, ...Ve }, lt = {}, dt = {};
    Fe !== void 0 && (dt.type = Fe), Ke !== void 0 && (dt.period = Ke), g$i(Qe, dt);
    let bt = at && at.headers ? at.headers : {};
    return ut.headers = { ...lt, ...bt, ...Ve.headers }, { url: y$p(Qe), options: ut };
  }, introspect: async (Ze, Fe = {}) => {
    let Ke = "/v1/admin/introspect", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, listBotIssueEvents: async (Ze, Fe, Ke = {}) => {
    f$x("listBotIssueEvents", "id", Ze), f$x("listBotIssueEvents", "issueId", Fe);
    let Ve = "/v1/admin/bots/{id}/issues/{issueId}/events".replace("{id}", encodeURIComponent(String(Ze))).replace("{issueId}", encodeURIComponent(String(Fe))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "GET", ...Qe, ...Ke }, ut = {};
    g$i(Je, {});
    let lt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...lt, ...Ke.headers }, { url: y$p(Je), options: at };
  }, listBotIssues: async (Ze, Fe, Ke = {}) => {
    f$x("listBotIssues", "id", Ze);
    let Ve = "/v1/admin/bots/{id}/issues".replace("{id}", encodeURIComponent(String(Ze))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "GET", ...Qe, ...Ke }, ut = {}, lt = {};
    Fe !== void 0 && (lt.nextToken = Fe), g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, { url: y$p(Je), options: at };
  }, listBots: async (Ze, Fe, Ke = {}) => {
    let Ve = "/v1/admin/bots", Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "GET", ...Qe, ...Ke }, ut = {}, lt = {};
    Ze !== void 0 && (lt.dev = Ze), Fe !== void 0 && (lt.nextToken = Fe), g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, { url: y$p(Je), options: at };
  }, listConversations: async (Ze, Fe, Ke, Ve = {}) => {
    let Je = "/v1/chat/conversations", Qe = new URL(Je, d$o), at;
    $e && (at = $e.baseOptions);
    let ut = { method: "GET", ...at, ...Ve }, lt = {}, dt = {};
    Ze !== void 0 && (dt.nextToken = Ze), Fe !== void 0 && (dt.tags = Fe), Ke && (dt.participantIds = Ke), g$i(Qe, dt);
    let bt = at && at.headers ? at.headers : {};
    return ut.headers = { ...lt, ...bt, ...Ve.headers }, { url: y$p(Qe), options: ut };
  }, listEvents: async (Ze, Fe, Ke, Ve, Je, Qe = {}) => {
    let at = "/v1/chat/events", ut = new URL(at, d$o), lt;
    $e && (lt = $e.baseOptions);
    let dt = { method: "GET", ...lt, ...Qe }, bt = {}, $t = {};
    Ze !== void 0 && ($t.nextToken = Ze), Fe !== void 0 && ($t.type = Fe), Ke !== void 0 && ($t.conversationId = Ke), Ve !== void 0 && ($t.userId = Ve), Je !== void 0 && ($t.messageId = Je), g$i(ut, $t);
    let vt = lt && lt.headers ? lt.headers : {};
    return dt.headers = { ...bt, ...vt, ...Qe.headers }, { url: y$p(ut), options: dt };
  }, listFiles: async (Ze, Fe, Ke = {}) => {
    f$x("listFiles", "botId", Ze);
    let Ve = "/v1/storage/files", Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "GET", ...Qe, ...Ke }, ut = {}, lt = {};
    Fe !== void 0 && (lt.nextToken = Fe), Ze !== void 0 && (lt.botId = Ze), g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, { url: y$p(Je), options: at };
  }, listIntegrations: async (Ze, Fe, Ke, Ve, Je = {}) => {
    let Qe = "/v1/admin/integrations", at = new URL(Qe, d$o), ut;
    $e && (ut = $e.baseOptions);
    let lt = { method: "GET", ...ut, ...Je }, dt = {}, bt = {};
    Ze !== void 0 && (bt.nextToken = Ze), Fe !== void 0 && (bt.name = Fe), Ke !== void 0 && (bt.version = Ke), Ve !== void 0 && (bt.dev = Ve), g$i(at, bt);
    let $t = ut && ut.headers ? ut.headers : {};
    return lt.headers = { ...dt, ...$t, ...Je.headers }, { url: y$p(at), options: lt };
  }, listMessages: async (Ze, Fe, Ke, Ve = {}) => {
    let Je = "/v1/chat/messages", Qe = new URL(Je, d$o), at;
    $e && (at = $e.baseOptions);
    let ut = { method: "GET", ...at, ...Ve }, lt = {}, dt = {};
    Ze !== void 0 && (dt.nextToken = Ze), Fe !== void 0 && (dt.conversationId = Fe), Ke !== void 0 && (dt.tags = Ke), g$i(Qe, dt);
    let bt = at && at.headers ? at.headers : {};
    return ut.headers = { ...lt, ...bt, ...Ve.headers }, { url: y$p(Qe), options: ut };
  }, listParticipants: async (Ze, Fe, Ke = {}) => {
    f$x("listParticipants", "id", Ze);
    let Ve = "/v1/chat/conversations/{id}/participants".replace("{id}", encodeURIComponent(String(Ze))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "GET", ...Qe, ...Ke }, ut = {}, lt = {};
    Fe !== void 0 && (lt.nextToken = Fe), g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, { url: y$p(Je), options: at };
  }, listPersonalAccessTokens: async (Ze = {}) => {
    let Fe = "/v1/admin/account/pats", Ke = new URL(Fe, d$o), Ve;
    $e && (Ve = $e.baseOptions);
    let Je = { method: "GET", ...Ve, ...Ze }, Qe = {};
    g$i(Ke, {});
    let at = Ve && Ve.headers ? Ve.headers : {};
    return Je.headers = { ...Qe, ...at, ...Ze.headers }, { url: y$p(Ke), options: Je };
  }, listPublicIntegrations: async (Ze, Fe, Ke, Ve = {}) => {
    let Je = "/v1/admin/hub/integrations", Qe = new URL(Je, d$o), at;
    $e && (at = $e.baseOptions);
    let ut = { method: "GET", ...at, ...Ve }, lt = {}, dt = {};
    Ze !== void 0 && (dt.nextToken = Ze), Fe !== void 0 && (dt.name = Fe), Ke !== void 0 && (dt.version = Ke), g$i(Qe, dt);
    let bt = at && at.headers ? at.headers : {};
    return ut.headers = { ...lt, ...bt, ...Ve.headers }, { url: y$p(Qe), options: ut };
  }, listUsageHistory: async (Ze, Fe, Ke = {}) => {
    f$x("listUsageHistory", "type", Ze), f$x("listUsageHistory", "id", Fe);
    let Ve = "/v1/admin/usages/{id}/history".replace("{id}", encodeURIComponent(String(Fe))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "GET", ...Qe, ...Ke }, ut = {}, lt = {};
    Ze !== void 0 && (lt.type = Ze), g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, { url: y$p(Je), options: at };
  }, listUsers: async (Ze, Fe, Ke, Ve = {}) => {
    let Je = "/v1/chat/users", Qe = new URL(Je, d$o), at;
    $e && (at = $e.baseOptions);
    let ut = { method: "GET", ...at, ...Ve }, lt = {}, dt = {};
    Ze !== void 0 && (dt.nextToken = Ze), Fe !== void 0 && (dt.conversationId = Fe), Ke !== void 0 && (dt.tags = Ke), g$i(Qe, dt);
    let bt = at && at.headers ? at.headers : {};
    return ut.headers = { ...lt, ...bt, ...Ve.headers }, { url: y$p(Qe), options: ut };
  }, listWorkspaceInvoices: async (Ze, Fe = {}) => {
    f$x("listWorkspaceInvoices", "id", Ze);
    let Ke = "/v1/admin/workspaces/{id}/billing/invoices".replace("{id}", encodeURIComponent(String(Ze))), Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "GET", ...Je, ...Fe }, at = {};
    g$i(Ve, {});
    let ut = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...ut, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, listWorkspaceMembers: async (Ze, Fe = {}) => {
    let Ke = "/v1/admin/workspace-members", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "GET", ...Je, ...Fe }, at = {}, ut = {};
    Ze !== void 0 && (ut.nextToken = Ze), g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, listWorkspaceQuotas: async (Ze, Fe, Ke = {}) => {
    f$x("listWorkspaceQuotas", "id", Ze);
    let Ve = "/v1/admin/workspaces/{id}/quotas".replace("{id}", encodeURIComponent(String(Ze))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "GET", ...Qe, ...Ke }, ut = {}, lt = {};
    Fe !== void 0 && (lt.period = Fe), g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, { url: y$p(Je), options: at };
  }, listWorkspaceUsages: async (Ze, Fe, Ke, Ve = {}) => {
    f$x("listWorkspaceUsages", "id", Ze), f$x("listWorkspaceUsages", "type", Fe);
    let Je = "/v1/admin/workspaces/{id}/usages".replace("{id}", encodeURIComponent(String(Ze))), Qe = new URL(Je, d$o), at;
    $e && (at = $e.baseOptions);
    let ut = { method: "GET", ...at, ...Ve }, lt = {}, dt = {};
    Fe !== void 0 && (dt.type = Fe), Ke !== void 0 && (dt.period = Ke), g$i(Qe, dt);
    let bt = at && at.headers ? at.headers : {};
    return ut.headers = { ...lt, ...bt, ...Ve.headers }, { url: y$p(Qe), options: ut };
  }, listWorkspaces: async (Ze, Fe = {}) => {
    let Ke = "/v1/admin/workspaces", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "GET", ...Je, ...Fe }, at = {}, ut = {};
    Ze !== void 0 && (ut.nextToken = Ze), g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, { url: y$p(Ve), options: Qe };
  }, patchState: async (Ze, Fe, Ke, Ve, Je = {}) => {
    f$x("patchState", "type", Ze), f$x("patchState", "id", Fe), f$x("patchState", "name", Ke);
    let Qe = "/v1/chat/states/{type}/{id}/{name}".replace("{type}", encodeURIComponent(String(Ze))).replace("{id}", encodeURIComponent(String(Fe))).replace("{name}", encodeURIComponent(String(Ke))), at = new URL(Qe, d$o), ut;
    $e && (ut = $e.baseOptions);
    let lt = { method: "PATCH", ...ut, ...Je }, dt = {}, bt = {};
    dt["Content-Type"] = "application/json", g$i(at, bt);
    let $t = ut && ut.headers ? ut.headers : {};
    return lt.headers = { ...dt, ...$t, ...Je.headers }, lt.data = C$a(Ve, lt, $e), { url: y$p(at), options: lt };
  }, removeParticipant: async (Ze, Fe, Ke = {}) => {
    f$x("removeParticipant", "id", Ze), f$x("removeParticipant", "userId", Fe);
    let Ve = "/v1/chat/conversations/{id}/participants/{userId}".replace("{id}", encodeURIComponent(String(Ze))).replace("{userId}", encodeURIComponent(String(Fe))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "DELETE", ...Qe, ...Ke }, ut = {};
    g$i(Je, {});
    let lt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...lt, ...Ke.headers }, { url: y$p(Je), options: at };
  }, runVrl: async (Ze, Fe = {}) => {
    let Ke = "/v1/admin/helper/vrl", Ve = new URL(Ke, d$o), Je;
    $e && (Je = $e.baseOptions);
    let Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
    at["Content-Type"] = "application/json", g$i(Ve, ut);
    let lt = Je && Je.headers ? Je.headers : {};
    return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = C$a(Ze, Qe, $e), { url: y$p(Ve), options: Qe };
  }, setState: async (Ze, Fe, Ke, Ve, Je = {}) => {
    f$x("setState", "type", Ze), f$x("setState", "id", Fe), f$x("setState", "name", Ke);
    let Qe = "/v1/chat/states/{type}/{id}/{name}".replace("{type}", encodeURIComponent(String(Ze))).replace("{id}", encodeURIComponent(String(Fe))).replace("{name}", encodeURIComponent(String(Ke))), at = new URL(Qe, d$o), ut;
    $e && (ut = $e.baseOptions);
    let lt = { method: "POST", ...ut, ...Je }, dt = {}, bt = {};
    dt["Content-Type"] = "application/json", g$i(at, bt);
    let $t = ut && ut.headers ? ut.headers : {};
    return lt.headers = { ...dt, ...$t, ...Je.headers }, lt.data = C$a(Ve, lt, $e), { url: y$p(at), options: lt };
  }, setWorkspacePaymentMethod: async (Ze, Fe, Ke = {}) => {
    f$x("setWorkspacePaymentMethod", "id", Ze);
    let Ve = "/v1/admin/workspaces/{id}/billing/payment-method".replace("{id}", encodeURIComponent(String(Ze))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "PUT", ...Qe, ...Ke }, ut = {}, lt = {};
    ut["Content-Type"] = "application/json", g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, at.data = C$a(Fe, at, $e), { url: y$p(Je), options: at };
  }, transferBot: async (Ze, Fe, Ke = {}) => {
    f$x("transferBot", "id", Ze);
    let Ve = "/v1/admin/bots/{id}/transfer".replace("{id}", encodeURIComponent(String(Ze))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "POST", ...Qe, ...Ke }, ut = {}, lt = {};
    ut["Content-Type"] = "application/json", g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, at.data = C$a(Fe, at, $e), { url: y$p(Je), options: at };
  }, updateBot: async (Ze, Fe, Ke = {}) => {
    f$x("updateBot", "id", Ze);
    let Ve = "/v1/admin/bots/{id}".replace("{id}", encodeURIComponent(String(Ze))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "PUT", ...Qe, ...Ke }, ut = {}, lt = {};
    ut["Content-Type"] = "application/json", g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, at.data = C$a(Fe, at, $e), { url: y$p(Je), options: at };
  }, updateConversation: async (Ze, Fe, Ke = {}) => {
    f$x("updateConversation", "id", Ze);
    let Ve = "/v1/chat/conversations/{id}".replace("{id}", encodeURIComponent(String(Ze))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "PUT", ...Qe, ...Ke }, ut = {}, lt = {};
    ut["Content-Type"] = "application/json", g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, at.data = C$a(Fe, at, $e), { url: y$p(Je), options: at };
  }, updateIntegration: async (Ze, Fe, Ke = {}) => {
    f$x("updateIntegration", "id", Ze);
    let Ve = "/v1/admin/integrations/{id}".replace("{id}", encodeURIComponent(String(Ze))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "PUT", ...Qe, ...Ke }, ut = {}, lt = {};
    ut["Content-Type"] = "application/json", g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, at.data = C$a(Fe, at, $e), { url: y$p(Je), options: at };
  }, updateMessage: async (Ze, Fe, Ke = {}) => {
    f$x("updateMessage", "id", Ze);
    let Ve = "/v1/chat/messages/{id}".replace("{id}", encodeURIComponent(String(Ze))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "PUT", ...Qe, ...Ke }, ut = {}, lt = {};
    ut["Content-Type"] = "application/json", g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, at.data = C$a(Fe, at, $e), { url: y$p(Je), options: at };
  }, updateUser: async (Ze, Fe, Ke = {}) => {
    f$x("updateUser", "id", Ze);
    let Ve = "/v1/chat/users/{id}".replace("{id}", encodeURIComponent(String(Ze))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "PUT", ...Qe, ...Ke }, ut = {}, lt = {};
    ut["Content-Type"] = "application/json", g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, at.data = C$a(Fe, at, $e), { url: y$p(Je), options: at };
  }, updateWorkspace: async (Ze, Fe, Ke = {}) => {
    f$x("updateWorkspace", "id", Ze);
    let Ve = "/v1/admin/workspaces/{id}".replace("{id}", encodeURIComponent(String(Ze))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "PUT", ...Qe, ...Ke }, ut = {}, lt = {};
    ut["Content-Type"] = "application/json", g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, at.data = C$a(Fe, at, $e), { url: y$p(Je), options: at };
  }, updateWorkspaceMember: async (Ze, Fe, Ke = {}) => {
    f$x("updateWorkspaceMember", "id", Ze);
    let Ve = "/v1/admin/workspace-members/{id}".replace("{id}", encodeURIComponent(String(Ze))), Je = new URL(Ve, d$o), Qe;
    $e && (Qe = $e.baseOptions);
    let at = { method: "PUT", ...Qe, ...Ke }, ut = {}, lt = {};
    ut["Content-Type"] = "application/json", g$i(Je, lt);
    let dt = Qe && Qe.headers ? Qe.headers : {};
    return at.headers = { ...ut, ...dt, ...Ke.headers }, at.data = C$a(Fe, at, $e), { url: y$p(Je), options: at };
  } };
}, m$o = function($e) {
  let Ze = ye$2($e);
  return { async addParticipant(Fe, Ke, Ve) {
    let Je = await Ze.addParticipant(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async breakDownWorkspaceUsageByBot(Fe, Ke, Ve, Je) {
    let Qe = await Ze.breakDownWorkspaceUsageByBot(Fe, Ke, Ve, Je);
    return h$n(Qe, Pe$2, u$r, $e);
  }, async callAction(Fe, Ke) {
    let Ve = await Ze.callAction(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async changeAISpendQuota(Fe, Ke) {
    let Ve = await Ze.changeAISpendQuota(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async changeWorkspacePlan(Fe, Ke, Ve) {
    let Je = await Ze.changeWorkspacePlan(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async chargeWorkspaceUnpaidInvoices(Fe, Ke, Ve) {
    let Je = await Ze.chargeWorkspaceUnpaidInvoices(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async configureIntegration(Fe, Ke) {
    let Ve = await Ze.configureIntegration(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async createBot(Fe, Ke) {
    let Ve = await Ze.createBot(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async createConversation(Fe, Ke) {
    let Ve = await Ze.createConversation(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async createEvent(Fe, Ke) {
    let Ve = await Ze.createEvent(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async createFile(Fe, Ke) {
    let Ve = await Ze.createFile(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async createIntegration(Fe, Ke) {
    let Ve = await Ze.createIntegration(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async createMessage(Fe, Ke) {
    let Ve = await Ze.createMessage(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async createPersonalAccessToken(Fe, Ke) {
    let Ve = await Ze.createPersonalAccessToken(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async createUser(Fe, Ke) {
    let Ve = await Ze.createUser(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async createWorkspace(Fe, Ke) {
    let Ve = await Ze.createWorkspace(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async createWorkspaceMember(Fe, Ke) {
    let Ve = await Ze.createWorkspaceMember(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async deleteBot(Fe, Ke) {
    let Ve = await Ze.deleteBot(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async deleteBotIssue(Fe, Ke, Ve) {
    let Je = await Ze.deleteBotIssue(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async deleteConversation(Fe, Ke) {
    let Ve = await Ze.deleteConversation(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async deleteFile(Fe, Ke) {
    let Ve = await Ze.deleteFile(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async deleteIntegration(Fe, Ke) {
    let Ve = await Ze.deleteIntegration(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async deleteMessage(Fe, Ke) {
    let Ve = await Ze.deleteMessage(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async deletePersonalAccessToken(Fe, Ke) {
    let Ve = await Ze.deletePersonalAccessToken(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async deleteUser(Fe, Ke) {
    let Ve = await Ze.deleteUser(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async deleteWorkspace(Fe, Ke) {
    let Ve = await Ze.deleteWorkspace(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async deleteWorkspaceMember(Fe, Ke) {
    let Ve = await Ze.deleteWorkspaceMember(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async downloadFile(Fe, Ke) {
    let Ve = await Ze.downloadFile(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async getAccount(Fe) {
    let Ke = await Ze.getAccount(Fe);
    return h$n(Ke, Pe$2, u$r, $e);
  }, async getAllWorkspaceQuotaCompletion(Fe) {
    let Ke = await Ze.getAllWorkspaceQuotaCompletion(Fe);
    return h$n(Ke, Pe$2, u$r, $e);
  }, async getAuditRecords(Fe, Ke, Ve) {
    let Je = await Ze.getAuditRecords(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async getBot(Fe, Ke) {
    let Ve = await Ze.getBot(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async getBotAnalytics(Fe, Ke, Ve, Je) {
    let Qe = await Ze.getBotAnalytics(Fe, Ke, Ve, Je);
    return h$n(Qe, Pe$2, u$r, $e);
  }, async getBotLogs(Fe, Ke, Ve, Je, Qe) {
    let at = await Ze.getBotLogs(Fe, Ke, Ve, Je, Qe);
    return h$n(at, Pe$2, u$r, $e);
  }, async getBotWebchat(Fe, Ke, Ve) {
    let Je = await Ze.getBotWebchat(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async getConversation(Fe, Ke) {
    let Ve = await Ze.getConversation(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async getEvent(Fe, Ke) {
    let Ve = await Ze.getEvent(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async getFile(Fe, Ke) {
    let Ve = await Ze.getFile(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async getIntegration(Fe, Ke) {
    let Ve = await Ze.getIntegration(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async getIntegrationByName(Fe, Ke, Ve) {
    let Je = await Ze.getIntegrationByName(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async getIntegrationLogs(Fe, Ke, Ve, Je, Qe) {
    let at = await Ze.getIntegrationLogs(Fe, Ke, Ve, Je, Qe);
    return h$n(at, Pe$2, u$r, $e);
  }, async getMessage(Fe, Ke) {
    let Ve = await Ze.getMessage(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async getOrCreateConversation(Fe, Ke) {
    let Ve = await Ze.getOrCreateConversation(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async getOrCreateMessage(Fe, Ke) {
    let Ve = await Ze.getOrCreateMessage(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async getOrCreateUser(Fe, Ke) {
    let Ve = await Ze.getOrCreateUser(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async getParticipant(Fe, Ke, Ve) {
    let Je = await Ze.getParticipant(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async getPublicIntegration(Fe, Ke, Ve) {
    let Je = await Ze.getPublicIntegration(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async getPublicIntegrationById(Fe, Ke) {
    let Ve = await Ze.getPublicIntegrationById(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async getState(Fe, Ke, Ve, Je) {
    let Qe = await Ze.getState(Fe, Ke, Ve, Je);
    return h$n(Qe, Pe$2, u$r, $e);
  }, async getUsage(Fe, Ke, Ve, Je) {
    let Qe = await Ze.getUsage(Fe, Ke, Ve, Je);
    return h$n(Qe, Pe$2, u$r, $e);
  }, async getUser(Fe, Ke) {
    let Ve = await Ze.getUser(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async getWorkspace(Fe, Ke) {
    let Ve = await Ze.getWorkspace(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async getWorkspaceBillingDetails(Fe, Ke) {
    let Ve = await Ze.getWorkspaceBillingDetails(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async getWorkspaceQuota(Fe, Ke, Ve, Je) {
    let Qe = await Ze.getWorkspaceQuota(Fe, Ke, Ve, Je);
    return h$n(Qe, Pe$2, u$r, $e);
  }, async introspect(Fe, Ke) {
    let Ve = await Ze.introspect(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async listBotIssueEvents(Fe, Ke, Ve) {
    let Je = await Ze.listBotIssueEvents(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async listBotIssues(Fe, Ke, Ve) {
    let Je = await Ze.listBotIssues(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async listBots(Fe, Ke, Ve) {
    let Je = await Ze.listBots(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async listConversations(Fe, Ke, Ve, Je) {
    let Qe = await Ze.listConversations(Fe, Ke, Ve, Je);
    return h$n(Qe, Pe$2, u$r, $e);
  }, async listEvents(Fe, Ke, Ve, Je, Qe, at) {
    let ut = await Ze.listEvents(Fe, Ke, Ve, Je, Qe, at);
    return h$n(ut, Pe$2, u$r, $e);
  }, async listFiles(Fe, Ke, Ve) {
    let Je = await Ze.listFiles(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async listIntegrations(Fe, Ke, Ve, Je, Qe) {
    let at = await Ze.listIntegrations(Fe, Ke, Ve, Je, Qe);
    return h$n(at, Pe$2, u$r, $e);
  }, async listMessages(Fe, Ke, Ve, Je) {
    let Qe = await Ze.listMessages(Fe, Ke, Ve, Je);
    return h$n(Qe, Pe$2, u$r, $e);
  }, async listParticipants(Fe, Ke, Ve) {
    let Je = await Ze.listParticipants(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async listPersonalAccessTokens(Fe) {
    let Ke = await Ze.listPersonalAccessTokens(Fe);
    return h$n(Ke, Pe$2, u$r, $e);
  }, async listPublicIntegrations(Fe, Ke, Ve, Je) {
    let Qe = await Ze.listPublicIntegrations(Fe, Ke, Ve, Je);
    return h$n(Qe, Pe$2, u$r, $e);
  }, async listUsageHistory(Fe, Ke, Ve) {
    let Je = await Ze.listUsageHistory(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async listUsers(Fe, Ke, Ve, Je) {
    let Qe = await Ze.listUsers(Fe, Ke, Ve, Je);
    return h$n(Qe, Pe$2, u$r, $e);
  }, async listWorkspaceInvoices(Fe, Ke) {
    let Ve = await Ze.listWorkspaceInvoices(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async listWorkspaceMembers(Fe, Ke) {
    let Ve = await Ze.listWorkspaceMembers(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async listWorkspaceQuotas(Fe, Ke, Ve) {
    let Je = await Ze.listWorkspaceQuotas(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async listWorkspaceUsages(Fe, Ke, Ve, Je) {
    let Qe = await Ze.listWorkspaceUsages(Fe, Ke, Ve, Je);
    return h$n(Qe, Pe$2, u$r, $e);
  }, async listWorkspaces(Fe, Ke) {
    let Ve = await Ze.listWorkspaces(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async patchState(Fe, Ke, Ve, Je, Qe) {
    let at = await Ze.patchState(Fe, Ke, Ve, Je, Qe);
    return h$n(at, Pe$2, u$r, $e);
  }, async removeParticipant(Fe, Ke, Ve) {
    let Je = await Ze.removeParticipant(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async runVrl(Fe, Ke) {
    let Ve = await Ze.runVrl(Fe, Ke);
    return h$n(Ve, Pe$2, u$r, $e);
  }, async setState(Fe, Ke, Ve, Je, Qe) {
    let at = await Ze.setState(Fe, Ke, Ve, Je, Qe);
    return h$n(at, Pe$2, u$r, $e);
  }, async setWorkspacePaymentMethod(Fe, Ke, Ve) {
    let Je = await Ze.setWorkspacePaymentMethod(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async transferBot(Fe, Ke, Ve) {
    let Je = await Ze.transferBot(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async updateBot(Fe, Ke, Ve) {
    let Je = await Ze.updateBot(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async updateConversation(Fe, Ke, Ve) {
    let Je = await Ze.updateConversation(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async updateIntegration(Fe, Ke, Ve) {
    let Je = await Ze.updateIntegration(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async updateMessage(Fe, Ke, Ve) {
    let Je = await Ze.updateMessage(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async updateUser(Fe, Ke, Ve) {
    let Je = await Ze.updateUser(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async updateWorkspace(Fe, Ke, Ve) {
    let Je = await Ze.updateWorkspace(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  }, async updateWorkspaceMember(Fe, Ke, Ve) {
    let Je = await Ze.updateWorkspaceMember(Fe, Ke, Ve);
    return h$n(Je, Pe$2, u$r, $e);
  } };
}, U$c = class extends k$i {
  addParticipant(Ze, Fe) {
    return m$o(this.configuration).addParticipant(Ze.id, Ze.addParticipantBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  breakDownWorkspaceUsageByBot(Ze, Fe) {
    return m$o(this.configuration).breakDownWorkspaceUsageByBot(Ze.id, Ze.type, Ze.period, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  callAction(Ze = {}, Fe) {
    return m$o(this.configuration).callAction(Ze.callActionBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  changeAISpendQuota(Ze = {}, Fe) {
    return m$o(this.configuration).changeAISpendQuota(Ze.changeAISpendQuotaBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  changeWorkspacePlan(Ze, Fe) {
    return m$o(this.configuration).changeWorkspacePlan(Ze.id, Ze.changeWorkspacePlanBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  chargeWorkspaceUnpaidInvoices(Ze, Fe) {
    return m$o(this.configuration).chargeWorkspaceUnpaidInvoices(Ze.id, Ze.chargeWorkspaceUnpaidInvoicesBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  configureIntegration(Ze = {}, Fe) {
    return m$o(this.configuration).configureIntegration(Ze.configureIntegrationBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  createBot(Ze = {}, Fe) {
    return m$o(this.configuration).createBot(Ze.createBotBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  createConversation(Ze = {}, Fe) {
    return m$o(this.configuration).createConversation(Ze.createConversationBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  createEvent(Ze = {}, Fe) {
    return m$o(this.configuration).createEvent(Ze.createEventBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  createFile(Ze = {}, Fe) {
    return m$o(this.configuration).createFile(Ze.createFileBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  createIntegration(Ze = {}, Fe) {
    return m$o(this.configuration).createIntegration(Ze.createIntegrationBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  createMessage(Ze = {}, Fe) {
    return m$o(this.configuration).createMessage(Ze.createMessageBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  createPersonalAccessToken(Ze = {}, Fe) {
    return m$o(this.configuration).createPersonalAccessToken(Ze.createPersonalAccessTokenBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  createUser(Ze = {}, Fe) {
    return m$o(this.configuration).createUser(Ze.createUserBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  createWorkspace(Ze = {}, Fe) {
    return m$o(this.configuration).createWorkspace(Ze.createWorkspaceBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  createWorkspaceMember(Ze = {}, Fe) {
    return m$o(this.configuration).createWorkspaceMember(Ze.createWorkspaceMemberBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  deleteBot(Ze, Fe) {
    return m$o(this.configuration).deleteBot(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  deleteBotIssue(Ze, Fe) {
    return m$o(this.configuration).deleteBotIssue(Ze.id, Ze.issueId, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  deleteConversation(Ze, Fe) {
    return m$o(this.configuration).deleteConversation(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  deleteFile(Ze, Fe) {
    return m$o(this.configuration).deleteFile(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  deleteIntegration(Ze, Fe) {
    return m$o(this.configuration).deleteIntegration(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  deleteMessage(Ze, Fe) {
    return m$o(this.configuration).deleteMessage(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  deletePersonalAccessToken(Ze, Fe) {
    return m$o(this.configuration).deletePersonalAccessToken(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  deleteUser(Ze, Fe) {
    return m$o(this.configuration).deleteUser(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  deleteWorkspace(Ze, Fe) {
    return m$o(this.configuration).deleteWorkspace(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  deleteWorkspaceMember(Ze, Fe) {
    return m$o(this.configuration).deleteWorkspaceMember(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  downloadFile(Ze, Fe) {
    return m$o(this.configuration).downloadFile(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getAccount(Ze) {
    return m$o(this.configuration).getAccount(Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  getAllWorkspaceQuotaCompletion(Ze) {
    return m$o(this.configuration).getAllWorkspaceQuotaCompletion(Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  getAuditRecords(Ze, Fe) {
    return m$o(this.configuration).getAuditRecords(Ze.id, Ze.nextToken, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getBot(Ze, Fe) {
    return m$o(this.configuration).getBot(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getBotAnalytics(Ze, Fe) {
    return m$o(this.configuration).getBotAnalytics(Ze.id, Ze.startDate, Ze.endDate, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getBotLogs(Ze, Fe) {
    return m$o(this.configuration).getBotLogs(Ze.id, Ze.timeStart, Ze.timeEnd, Ze.nextToken, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getBotWebchat(Ze, Fe) {
    return m$o(this.configuration).getBotWebchat(Ze.id, Ze.type, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getConversation(Ze, Fe) {
    return m$o(this.configuration).getConversation(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getEvent(Ze, Fe) {
    return m$o(this.configuration).getEvent(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getFile(Ze, Fe) {
    return m$o(this.configuration).getFile(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getIntegration(Ze, Fe) {
    return m$o(this.configuration).getIntegration(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getIntegrationByName(Ze, Fe) {
    return m$o(this.configuration).getIntegrationByName(Ze.name, Ze.version, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getIntegrationLogs(Ze, Fe) {
    return m$o(this.configuration).getIntegrationLogs(Ze.id, Ze.timeStart, Ze.timeEnd, Ze.nextToken, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getMessage(Ze, Fe) {
    return m$o(this.configuration).getMessage(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getOrCreateConversation(Ze = {}, Fe) {
    return m$o(this.configuration).getOrCreateConversation(Ze.getOrCreateConversationBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getOrCreateMessage(Ze = {}, Fe) {
    return m$o(this.configuration).getOrCreateMessage(Ze.getOrCreateMessageBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getOrCreateUser(Ze = {}, Fe) {
    return m$o(this.configuration).getOrCreateUser(Ze.getOrCreateUserBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getParticipant(Ze, Fe) {
    return m$o(this.configuration).getParticipant(Ze.id, Ze.userId, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getPublicIntegration(Ze, Fe) {
    return m$o(this.configuration).getPublicIntegration(Ze.name, Ze.version, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getPublicIntegrationById(Ze, Fe) {
    return m$o(this.configuration).getPublicIntegrationById(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getState(Ze, Fe) {
    return m$o(this.configuration).getState(Ze.type, Ze.id, Ze.name, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getUsage(Ze, Fe) {
    return m$o(this.configuration).getUsage(Ze.type, Ze.id, Ze.period, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getUser(Ze, Fe) {
    return m$o(this.configuration).getUser(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getWorkspace(Ze, Fe) {
    return m$o(this.configuration).getWorkspace(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getWorkspaceBillingDetails(Ze, Fe) {
    return m$o(this.configuration).getWorkspaceBillingDetails(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  getWorkspaceQuota(Ze, Fe) {
    return m$o(this.configuration).getWorkspaceQuota(Ze.id, Ze.type, Ze.period, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  introspect(Ze = {}, Fe) {
    return m$o(this.configuration).introspect(Ze.introspectBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  listBotIssueEvents(Ze, Fe) {
    return m$o(this.configuration).listBotIssueEvents(Ze.id, Ze.issueId, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  listBotIssues(Ze, Fe) {
    return m$o(this.configuration).listBotIssues(Ze.id, Ze.nextToken, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  listBots(Ze = {}, Fe) {
    return m$o(this.configuration).listBots(Ze.dev, Ze.nextToken, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  listConversations(Ze = {}, Fe) {
    return m$o(this.configuration).listConversations(Ze.nextToken, Ze.tags, Ze.participantIds, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  listEvents(Ze = {}, Fe) {
    return m$o(this.configuration).listEvents(Ze.nextToken, Ze.type, Ze.conversationId, Ze.userId, Ze.messageId, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  listFiles(Ze, Fe) {
    return m$o(this.configuration).listFiles(Ze.botId, Ze.nextToken, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  listIntegrations(Ze = {}, Fe) {
    return m$o(this.configuration).listIntegrations(Ze.nextToken, Ze.name, Ze.version, Ze.dev, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  listMessages(Ze = {}, Fe) {
    return m$o(this.configuration).listMessages(Ze.nextToken, Ze.conversationId, Ze.tags, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  listParticipants(Ze, Fe) {
    return m$o(this.configuration).listParticipants(Ze.id, Ze.nextToken, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  listPersonalAccessTokens(Ze) {
    return m$o(this.configuration).listPersonalAccessTokens(Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  listPublicIntegrations(Ze = {}, Fe) {
    return m$o(this.configuration).listPublicIntegrations(Ze.nextToken, Ze.name, Ze.version, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  listUsageHistory(Ze, Fe) {
    return m$o(this.configuration).listUsageHistory(Ze.type, Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  listUsers(Ze = {}, Fe) {
    return m$o(this.configuration).listUsers(Ze.nextToken, Ze.conversationId, Ze.tags, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  listWorkspaceInvoices(Ze, Fe) {
    return m$o(this.configuration).listWorkspaceInvoices(Ze.id, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  listWorkspaceMembers(Ze = {}, Fe) {
    return m$o(this.configuration).listWorkspaceMembers(Ze.nextToken, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  listWorkspaceQuotas(Ze, Fe) {
    return m$o(this.configuration).listWorkspaceQuotas(Ze.id, Ze.period, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  listWorkspaceUsages(Ze, Fe) {
    return m$o(this.configuration).listWorkspaceUsages(Ze.id, Ze.type, Ze.period, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  listWorkspaces(Ze = {}, Fe) {
    return m$o(this.configuration).listWorkspaces(Ze.nextToken, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  patchState(Ze, Fe) {
    return m$o(this.configuration).patchState(Ze.type, Ze.id, Ze.name, Ze.patchStateBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  removeParticipant(Ze, Fe) {
    return m$o(this.configuration).removeParticipant(Ze.id, Ze.userId, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  runVrl(Ze = {}, Fe) {
    return m$o(this.configuration).runVrl(Ze.runVrlBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  setState(Ze, Fe) {
    return m$o(this.configuration).setState(Ze.type, Ze.id, Ze.name, Ze.setStateBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  setWorkspacePaymentMethod(Ze, Fe) {
    return m$o(this.configuration).setWorkspacePaymentMethod(Ze.id, Ze.setWorkspacePaymentMethodBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  transferBot(Ze, Fe) {
    return m$o(this.configuration).transferBot(Ze.id, Ze.transferBotBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  updateBot(Ze, Fe) {
    return m$o(this.configuration).updateBot(Ze.id, Ze.updateBotBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  updateConversation(Ze, Fe) {
    return m$o(this.configuration).updateConversation(Ze.id, Ze.updateConversationBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  updateIntegration(Ze, Fe) {
    return m$o(this.configuration).updateIntegration(Ze.id, Ze.updateIntegrationBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  updateMessage(Ze, Fe) {
    return m$o(this.configuration).updateMessage(Ze.id, Ze.updateMessageBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  updateUser(Ze, Fe) {
    return m$o(this.configuration).updateUser(Ze.id, Ze.updateUserBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  updateWorkspace(Ze, Fe) {
    return m$o(this.configuration).updateWorkspace(Ze.id, Ze.updateWorkspaceBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
  updateWorkspaceMember(Ze, Fe) {
    return m$o(this.configuration).updateWorkspaceMember(Ze.id, Ze.updateWorkspaceMemberBody, Fe).then((Ke) => Ke(this.axios, this.basePath));
  }
}, Ae$2 = { getRandomValues: ($e) => new Uint8Array($e.map(() => Math.floor(Math.random() * 256))) }, V$7 = typeof window < "u" && typeof window.document < "u" ? window.crypto : he$2;
V$7.getRandomValues || (V$7 = Ae$2);
var P$a = class extends Error {
  constructor(Fe, Ke, Ve, Je, Qe, at) {
    super(Je);
    Or(this, "isApiError", !0);
    this.code = Fe, this.description = Ke, this.type = Ve, this.message = Je, this.error = Qe, this.id = at, this.id || (this.id = P$a.generateId());
  }
  format() {
    return `[${this.type}] ${this.message} (Error ID: ${this.id})`;
  }
  toJSON() {
    return { id: this.id, code: this.code, type: this.type, message: this.message };
  }
  static generateId() {
    let Fe = this.getPrefix(), Ke = (/* @__PURE__ */ new Date()).toISOString().replace(/[\-:TZ]/g, "").split(".")[0], Ve = 4, Je = Array.from(V$7.getRandomValues(new Uint8Array(Ve))).map((Qe) => Qe.toString(16).padStart(2, "0")).join("").toUpperCase();
    return `${Fe}_${Ke}x${Je}`;
  }
  static getPrefix() {
    return typeof window < "u" && typeof window.document < "u" ? "err_bwsr" : "err";
  }
}, me$2 = ($e) => typeof $e == "object" && !Array.isArray($e) && $e !== null, Re$1 = ($e) => $e instanceof P$a || me$2($e) && $e.isApiError === !0, b$l = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(500, "An unknown error occurred", "Unknown", Ze, Fe, Ke);
  }
}, W$7 = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(500, "An internal error occurred", "Internal", Ze, Fe, Ke);
  }
}, E$g = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(401, "The request requires to be authenticated.", "Unauthorized", Ze, Fe, Ke);
  }
}, D$b = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(403, "The requested action can't be peform by this resource.", "Forbidden", Ze, Fe, Ke);
  }
}, T$a = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(413, "The request payload is too large.", "PayloadTooLarge", Ze, Fe, Ke);
  }
}, O$a = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(400, "The request payload is invalid.", "InvalidPayload", Ze, Fe, Ke);
  }
}, w$l = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(415, "The request is invalid because the content-type is not supported.", "UnsupportedMediaType", Ze, Fe, Ke);
  }
}, M$b = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(405, "The requested method does not exist.", "MethodNotFound", Ze, Fe, Ke);
  }
}, S$g = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(404, "The requested resource does not exist.", "ResourceNotFound", Ze, Fe, Ke);
  }
}, L$a = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(400, "The provided JSON schema is invalid.", "InvalidJsonSchema", Ze, Fe, Ke);
  }
}, G$7 = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(400, "The provided data doesn't respect the provided JSON schema.", "InvalidDataFormat", Ze, Fe, Ke);
  }
}, _$j = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(400, "The provided identifier is not valid. An identifier must start with a lowercase letter, be between 2 and 100 characters long and use only alphanumeric characters.", "InvalidIdentifier", Ze, Fe, Ke);
  }
}, F$a = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(409, "The resource is not related with another resource. This is usually caused when providing two resources that aren't linked together.", "RelationConflict", Ze, Fe, Ke);
  }
}, Q$5 = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(400, "The provided resource reference is missing. This is usually caused when providing an invalid id inside the payload of a request.", "ReferenceNotFound", Ze, Fe, Ke);
  }
}, j$c = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(400, "The provided query is invalid. This is usually caused when providing an invalid parameter for querying a resource.", "InvalidQuery", Ze, Fe, Ke);
  }
}, N$9 = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(400, "An error happened during the execution of a runtime (bot or integration).", "Runtime", Ze, Fe, Ke);
  }
}, H$9 = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(409, "The record attempted to be created already exists.", "AlreadyExists", Ze, Fe, Ke);
  }
}, $$5 = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(429, "The request has been rate limited.", "RateLimited", Ze, Fe, Ke);
  }
}, K$a = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(402, "A payment is required to perform this request.", "PaymentRequired", Ze, Fe, Ke);
  }
}, J$7 = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(403, "The request exceeds the allowed quota. Quotas are a soft limit that can be increased.", "QuotaExceeded", Ze, Fe, Ke);
  }
}, z$c = class extends P$a {
  constructor(Ze, Fe, Ke) {
    super(413, "The request exceeds the allowed limit. Limits are a hard limit that cannot be increased.", "LimitExceeded", Ze, Fe, Ke);
  }
}, fe$2 = { Unknown: b$l, Internal: W$7, Unauthorized: E$g, Forbidden: D$b, PayloadTooLarge: T$a, InvalidPayload: O$a, UnsupportedMediaType: w$l, MethodNotFound: M$b, ResourceNotFound: S$g, InvalidJsonSchema: L$a, InvalidDataFormat: G$7, InvalidIdentifier: _$j, RelationConflict: F$a, ReferenceNotFound: Q$5, InvalidQuery: j$c, Runtime: N$9, AlreadyExists: H$9, RateLimited: $$5, PaymentRequired: K$a, QuotaExceeded: J$7, LimitExceeded: z$c }, Y$6 = ($e) => Re$1($e) ? $e : $e instanceof Error ? new b$l($e.message, $e) : typeof $e == "string" ? new b$l($e) : xe$2($e);
function xe$2($e) {
  if (typeof $e == "object" && "code" in $e && "type" in $e && "id" in $e && "message" in $e && typeof $e.type == "string" && typeof $e.message == "string") {
    let Ze = fe$2[$e.type];
    return Ze ? new Ze($e.message, void 0, $e.id || "UNKNOWN") : new b$l(`An unclassified API error occurred: ${$e.message} (Type: ${$e.type}, Code: ${$e.code})`);
  }
  return new b$l("An invalid error occurred: " + JSON.stringify($e));
}
var q$a = class {
  constructor(Ze, Fe, Ke) {
    Or(this, "_innerClient");
    Or(this, "createConversation", (Ze) => this._innerClient.createConversation({ createConversationBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getConversation", (Ze) => this._innerClient.getConversation(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "listConversations", (Ze) => this._innerClient.listConversations(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getOrCreateConversation", (Ze) => this._innerClient.getOrCreateConversation({ getOrCreateConversationBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "updateConversation", ({ id: Ze, ...Fe }) => this._innerClient.updateConversation({ id: Ze, updateConversationBody: Fe }).then((Ke) => Ke.data).catch((Ke) => {
      throw R$8(Ke);
    }));
    Or(this, "deleteConversation", (Ze) => this._innerClient.deleteConversation(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "listParticipants", (Ze) => this._innerClient.listParticipants(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "addParticipant", ({ id: Ze, ...Fe }) => this._innerClient.addParticipant({ id: Ze, addParticipantBody: Fe }).then((Ke) => Ke.data).catch((Ke) => {
      throw R$8(Ke);
    }));
    Or(this, "getParticipant", (Ze) => this._innerClient.getParticipant(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "removeParticipant", (Ze) => this._innerClient.removeParticipant(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "createEvent", (Ze) => this._innerClient.createEvent({ createEventBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getEvent", (Ze) => this._innerClient.getEvent(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "listEvents", (Ze) => this._innerClient.listEvents(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "createMessage", (Ze) => this._innerClient.createMessage({ createMessageBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getOrCreateMessage", (Ze) => this._innerClient.getOrCreateMessage({ getOrCreateMessageBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getMessage", (Ze) => this._innerClient.getMessage(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "updateMessage", ({ id: Ze, ...Fe }) => this._innerClient.updateMessage({ id: Ze, updateMessageBody: Fe }).then((Ke) => Ke.data).catch((Ke) => {
      throw R$8(Ke);
    }));
    Or(this, "listMessages", (Ze) => this._innerClient.listMessages(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "deleteMessage", (Ze) => this._innerClient.deleteMessage(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "createUser", (Ze) => this._innerClient.createUser({ createUserBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getUser", (Ze) => this._innerClient.getUser(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "listUsers", (Ze) => this._innerClient.listUsers(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getOrCreateUser", (Ze) => this._innerClient.getOrCreateUser({ getOrCreateUserBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "updateUser", ({ id: Ze, ...Fe }) => this._innerClient.updateUser({ id: Ze, updateUserBody: Fe }).then((Ke) => Ke.data).catch((Ke) => {
      throw R$8(Ke);
    }));
    Or(this, "deleteUser", (Ze) => this._innerClient.deleteUser(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getState", (Ze) => this._innerClient.getState(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "setState", ({ type: Ze, id: Fe, name: Ke, ...Ve }) => this._innerClient.setState({ type: Ze, id: Fe, name: Ke, setStateBody: Ve }).then((Je) => Je.data).catch((Je) => {
      throw R$8(Je);
    }));
    Or(this, "patchState", ({ type: Ze, id: Fe, name: Ke, ...Ve }) => this._innerClient.patchState({ type: Ze, id: Fe, name: Ke, patchStateBody: Ve }).then((Je) => Je.data).catch((Je) => {
      throw R$8(Je);
    }));
    Or(this, "callAction", (Ze) => this._innerClient.callAction({ callActionBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "configureIntegration", (Ze) => this._innerClient.configureIntegration({ configureIntegrationBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "runVrl", (Ze) => this._innerClient.runVrl({ runVrlBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getAccount", () => this._innerClient.getAccount().then((Ze) => Ze.data).catch((Ze) => {
      throw R$8(Ze);
    }));
    Or(this, "listPersonalAccessTokens", () => this._innerClient.listPersonalAccessTokens().then((Ze) => Ze.data).catch((Ze) => {
      throw R$8(Ze);
    }));
    Or(this, "createPersonalAccessToken", (Ze) => this._innerClient.createPersonalAccessToken({ createPersonalAccessTokenBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "deletePersonalAccessToken", (Ze) => this._innerClient.deletePersonalAccessToken(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "listPublicIntegrations", (Ze) => this._innerClient.listPublicIntegrations(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getPublicIntegrationById", (Ze) => this._innerClient.getPublicIntegrationById(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getPublicIntegration", (Ze) => this._innerClient.getPublicIntegration(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "createBot", (Ze) => this._innerClient.createBot({ createBotBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "updateBot", ({ id: Ze, ...Fe }) => this._innerClient.updateBot({ id: Ze, updateBotBody: Fe }).then((Ke) => Ke.data).catch((Ke) => {
      throw R$8(Ke);
    }));
    Or(this, "transferBot", ({ id: Ze, ...Fe }) => this._innerClient.transferBot({ id: Ze, transferBotBody: Fe }).then((Ke) => Ke.data).catch((Ke) => {
      throw R$8(Ke);
    }));
    Or(this, "listBots", (Ze) => this._innerClient.listBots(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getBot", (Ze) => this._innerClient.getBot(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "deleteBot", (Ze) => this._innerClient.deleteBot(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getBotLogs", (Ze) => this._innerClient.getBotLogs(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getBotWebchat", (Ze) => this._innerClient.getBotWebchat(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getBotAnalytics", (Ze) => this._innerClient.getBotAnalytics(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "listBotIssues", (Ze) => this._innerClient.listBotIssues(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "deleteBotIssue", (Ze) => this._innerClient.deleteBotIssue(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "listBotIssueEvents", (Ze) => this._innerClient.listBotIssueEvents(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getWorkspaceBillingDetails", (Ze) => this._innerClient.getWorkspaceBillingDetails(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "setWorkspacePaymentMethod", ({ id: Ze, ...Fe }) => this._innerClient.setWorkspacePaymentMethod({ id: Ze, setWorkspacePaymentMethodBody: Fe }).then((Ke) => Ke.data).catch((Ke) => {
      throw R$8(Ke);
    }));
    Or(this, "listWorkspaceInvoices", (Ze) => this._innerClient.listWorkspaceInvoices(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "chargeWorkspaceUnpaidInvoices", ({ id: Ze, ...Fe }) => this._innerClient.chargeWorkspaceUnpaidInvoices({ id: Ze, chargeWorkspaceUnpaidInvoicesBody: Fe }).then((Ke) => Ke.data).catch((Ke) => {
      throw R$8(Ke);
    }));
    Or(this, "createWorkspace", (Ze) => this._innerClient.createWorkspace({ createWorkspaceBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getWorkspace", (Ze) => this._innerClient.getWorkspace(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "listWorkspaceUsages", (Ze) => this._innerClient.listWorkspaceUsages(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "breakDownWorkspaceUsageByBot", (Ze) => this._innerClient.breakDownWorkspaceUsageByBot(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getAllWorkspaceQuotaCompletion", () => this._innerClient.getAllWorkspaceQuotaCompletion().then((Ze) => Ze.data).catch((Ze) => {
      throw R$8(Ze);
    }));
    Or(this, "getWorkspaceQuota", (Ze) => this._innerClient.getWorkspaceQuota(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "listWorkspaceQuotas", (Ze) => this._innerClient.listWorkspaceQuotas(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "updateWorkspace", ({ id: Ze, ...Fe }) => this._innerClient.updateWorkspace({ id: Ze, updateWorkspaceBody: Fe }).then((Ke) => Ke.data).catch((Ke) => {
      throw R$8(Ke);
    }));
    Or(this, "listWorkspaces", (Ze) => this._innerClient.listWorkspaces(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "changeWorkspacePlan", ({ id: Ze, ...Fe }) => this._innerClient.changeWorkspacePlan({ id: Ze, changeWorkspacePlanBody: Fe }).then((Ke) => Ke.data).catch((Ke) => {
      throw R$8(Ke);
    }));
    Or(this, "deleteWorkspace", (Ze) => this._innerClient.deleteWorkspace(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getAuditRecords", (Ze) => this._innerClient.getAuditRecords(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "listWorkspaceMembers", (Ze) => this._innerClient.listWorkspaceMembers(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "deleteWorkspaceMember", (Ze) => this._innerClient.deleteWorkspaceMember(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "createWorkspaceMember", (Ze) => this._innerClient.createWorkspaceMember({ createWorkspaceMemberBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "updateWorkspaceMember", ({ id: Ze, ...Fe }) => this._innerClient.updateWorkspaceMember({ id: Ze, updateWorkspaceMemberBody: Fe }).then((Ke) => Ke.data).catch((Ke) => {
      throw R$8(Ke);
    }));
    Or(this, "createIntegration", (Ze) => this._innerClient.createIntegration({ createIntegrationBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "updateIntegration", ({ id: Ze, ...Fe }) => this._innerClient.updateIntegration({ id: Ze, updateIntegrationBody: Fe }).then((Ke) => Ke.data).catch((Ke) => {
      throw R$8(Ke);
    }));
    Or(this, "listIntegrations", (Ze) => this._innerClient.listIntegrations(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getIntegration", (Ze) => this._innerClient.getIntegration(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getIntegrationLogs", (Ze) => this._innerClient.getIntegrationLogs(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getIntegrationByName", (Ze) => this._innerClient.getIntegrationByName(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "deleteIntegration", (Ze) => this._innerClient.deleteIntegration(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getUsage", (Ze) => this._innerClient.getUsage(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "listUsageHistory", (Ze) => this._innerClient.listUsageHistory(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "changeAISpendQuota", (Ze) => this._innerClient.changeAISpendQuota({ changeAISpendQuotaBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "introspect", (Ze) => this._innerClient.introspect({ introspectBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "createFile", (Ze) => this._innerClient.createFile({ createFileBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "getFile", (Ze) => this._innerClient.getFile(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "downloadFile", (Ze) => this._innerClient.downloadFile(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "deleteFile", (Ze) => this._innerClient.deleteFile(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    Or(this, "listFiles", (Ze) => this._innerClient.listFiles(Ze).then((Fe) => Fe.data).catch((Fe) => {
      throw R$8(Fe);
    }));
    this._innerClient = new U$c(Ze, Fe, Ke);
  }
};
function R$8($e) {
  var Ze;
  return Pe$2.isAxiosError($e) && ((Ze = $e.response) != null && Ze.data) ? Y$6($e.response.data) : Y$6($e);
}
var te$2 = 100 * 1024 * 1024, Be$2 = te$2, be$2 = te$2, ee$3 = class extends q$a {
  constructor(Fe = {}) {
    let Ke = X$6(Fe), { apiUrl: Ve, headers: Je, withCredentials: Qe, timeout: at } = Ke, ut = Pe$2.create({ headers: Je, withCredentials: Qe, timeout: at, maxBodyLength: Be$2, maxContentLength: be$2 });
    super(void 0, Ve, ut);
    Or(this, "config");
    this.config = Ke;
  }
};
const dist$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AlreadyExistsError: H$9,
  Client: ee$3,
  ForbiddenError: D$b,
  InternalError: W$7,
  InvalidDataFormatError: G$7,
  InvalidIdentifierError: _$j,
  InvalidJsonSchemaError: L$a,
  InvalidPayloadError: O$a,
  InvalidQueryError: j$c,
  LimitExceededError: z$c,
  MethodNotFoundError: M$b,
  PayloadTooLargeError: T$a,
  PaymentRequiredError: K$a,
  QuotaExceededError: J$7,
  RateLimitedError: $$5,
  ReferenceNotFoundError: Q$5,
  RelationConflictError: F$a,
  ResourceNotFoundError: S$g,
  RuntimeError: N$9,
  UnauthorizedError: E$g,
  UnknownError: b$l,
  UnsupportedMediaTypeError: w$l,
  axios: index,
  errorFrom: Y$6,
  isApiError: Re$1
}, Symbol.toStringTag, { value: "Module" })), require$$2 = /* @__PURE__ */ getAugmentedNamespace(dist$1);
var X$5 = Object.create, B$d = Object.defineProperty, Y$5 = Object.getOwnPropertyDescriptor, ee$2 = Object.getOwnPropertyNames, te$1 = Object.getPrototypeOf, ne$1 = Object.prototype.hasOwnProperty, O$9 = ($e, Ze) => {
  for (var Fe in Ze)
    B$d($e, Fe, { get: Ze[Fe], enumerable: !0 });
}, F$9 = ($e, Ze, Fe, Ke) => {
  if (Ze && typeof Ze == "object" || typeof Ze == "function")
    for (let Ve of ee$2(Ze))
      !ne$1.call($e, Ve) && Ve !== Fe && B$d($e, Ve, { get: () => Ze[Ve], enumerable: !(Ke = Y$5(Ze, Ve)) || Ke.enumerable });
  return $e;
}, G$6 = ($e, Ze, Fe) => (Fe = $e != null ? X$5(te$1($e)) : {}, F$9(Ze || !$e || !$e.__esModule ? B$d(Fe, "default", { value: $e, enumerable: !0 }) : Fe, $e)), oe$1 = ($e) => F$9(B$d({}, "__esModule", { value: !0 }), $e), Ae$1 = {};
O$9(Ae$1, { Bot: () => E$f, BotSpecificClient: () => I$c, Integration: () => P$9, IntegrationDefinition: () => b$k, IntegrationSpecificClient: () => u$q, botIdHeader: () => f$w, botUserIdHeader: () => U$b, configurationHeader: () => m$n, integrationIdHeader: () => A$d, messages: () => w$k, operationHeader: () => h$m, parseBody: () => p$t, serve: () => y$o, typeHeader: () => D$a, webhookIdHeader: () => k$h });
var dist = oe$1(Ae$1), w$k = {};
O$9(w$k, { defaults: () => de$1 });
var i$f = lib$1, g = i$f.z.string().min(1), se$1 = i$f.z.object({ text: g }), re$1 = i$f.z.object({ markdown: g }), ae$1 = i$f.z.object({ imageUrl: g }), ie$1 = i$f.z.object({ audioUrl: g }), ge$1 = i$f.z.object({ videoUrl: g }), ce$1 = i$f.z.object({ fileUrl: g, title: g.optional() }), pe$1 = i$f.z.object({ latitude: i$f.z.number(), longitude: i$f.z.number(), address: i$f.z.string().optional(), title: i$f.z.string().optional() }), L$9 = i$f.z.object({ title: g, subtitle: g.optional(), imageUrl: g.optional(), actions: i$f.z.array(i$f.z.object({ action: i$f.z.enum(["postback", "url", "say"]), label: g, value: g })) }), _$i = i$f.z.object({ text: g, options: i$f.z.array(i$f.z.object({ label: g, value: g })) }), le$1 = i$f.z.object({ items: i$f.z.array(L$9) }), de$1 = { text: { schema: se$1 }, markdown: { schema: re$1 }, image: { schema: ae$1 }, audio: { schema: ie$1 }, video: { schema: ge$1 }, file: { schema: ce$1 }, location: { schema: pe$1 }, carousel: { schema: le$1 }, card: { schema: L$9 }, dropdown: { schema: _$i }, choice: { schema: _$i } }, f$w = "x-bot-id", U$b = "x-bot-user-id", A$d = "x-integration-id", k$h = "x-webhook-id", m$n = "x-bp-configuration", h$m = "x-bp-operation", D$a = "x-bp-type", q$9 = require$$3, T$9 = console;
function p$t($e) {
  if (!$e.body)
    throw new Error("Missing body");
  return JSON.parse($e.body);
}
async function y$o($e, Ze = 8072, Fe = fe$1) {
  let Ke = (0, q$9.createServer)(async (Ve, Je) => {
    try {
      let Qe = await Te(Ve);
      if (Qe.path === "/health") {
        Je.writeHead(200).end("ok");
        return;
      }
      let at = await $e(Qe);
      Je.writeHead((at == null ? void 0 : at.status) ?? 200, (at == null ? void 0 : at.headers) ?? {}).end((at == null ? void 0 : at.body) ?? "{}");
    } catch (Qe) {
      T$9.error("Error while handling request", { error: (Qe == null ? void 0 : Qe.message) ?? "Internal error occured" }), Je.writeHead(500).end(JSON.stringify({ error: (Qe == null ? void 0 : Qe.message) ?? "Internal error occured" }));
    }
  });
  return Ke.listen(Ze, () => Fe(Ze)), Ke;
}
async function Te($e) {
  var Ve;
  let Ze = await Ie$1($e), Fe = {};
  for (let Je = 0; Je < $e.rawHeaders.length; Je += 2) {
    let Qe = $e.rawHeaders[Je].toLowerCase(), at = $e.rawHeaders[Je + 1];
    Fe[Qe] = at;
  }
  let Ke = new URL($e.url ?? "", $e.headers.host ? `http://${$e.headers.host}` : "http://botpress.cloud");
  return { body: Ze, path: Ke.pathname, query: ue$1(Ke.search, "?"), headers: Fe, method: ((Ve = $e.method) == null ? void 0 : Ve.toUpperCase()) ?? "GET" };
}
function ue$1($e, Ze) {
  return $e.indexOf(Ze) === 0 ? $e.slice(Ze.length) : $e;
}
async function Ie$1($e) {
  return new Promise((Ze, Fe) => {
    if ($e.method !== "POST" && $e.method !== "PUT" && $e.method !== "PATCH")
      return Ze(void 0);
    let Ke = "";
    $e.on("data", (Ve) => Ke += Ve.toString()), $e.on("error", (Ve) => Fe(Ve)), $e.on("end", () => Ze(Ke));
  });
}
function fe$1($e) {
  T$9.info(`Listening on port ${$e}`);
}
var j$b = lib$1, me$1 = j$b.z.enum(["webhook_received", "message_created", "action_triggered", "register", "unregister", "ping", "create_user", "create_conversation"]), K$9 = ($e) => {
  let Ze = $e[f$w], Fe = $e[U$b], Ke = $e[A$d], Ve = $e[k$h], Je = $e[m$n], Qe = me$1.parse($e[h$m]);
  if (!Ze)
    throw new Error("Missing bot headers");
  if (!Fe)
    throw new Error("Missing bot user headers");
  if (!Ke)
    throw new Error("Missing integration headers");
  if (!Ve)
    throw new Error("Missing webhook headers");
  if (!Je)
    throw new Error("Missing configuration headers");
  if (!Qe)
    throw new Error("Missing operation headers");
  return { botId: Ze, botUserId: Fe, integrationId: Ke, webhookId: Ve, operation: Qe, configuration: Je ? JSON.parse(Buffer.from(Je, "base64").toString("utf-8")) : {} };
}, b$k = class {
  constructor(Ze) {
    Or(this, "name");
    Or(this, "version");
    Or(this, "title");
    Or(this, "description");
    Or(this, "icon");
    Or(this, "readme");
    Or(this, "configuration");
    Or(this, "events");
    Or(this, "actions");
    Or(this, "channels");
    Or(this, "states");
    Or(this, "user");
    Or(this, "secrets");
    Or(this, "identifier");
    let { name: Fe, version: Ke, icon: Ve, readme: Je, title: Qe, description: at, configuration: ut, events: lt, actions: dt, channels: bt, states: $t, user: vt, secrets: wt, identifier: xt } = Ze;
    this.name = Fe, this.version = Ke, this.icon = Ve, this.readme = Je, this.title = Qe, this.identifier = xt, this.description = at, this.configuration = ut, this.events = lt, this.actions = dt, this.channels = bt, this.states = $t, this.user = vt, this.secrets = wt;
  }
}, S$f = require$$2, u$q = class {
  constructor(Ze) {
    Or(this, "createConversation", (Ze) => this.client.createConversation(Ze));
    Or(this, "getConversation", (Ze) => this.client.getConversation(Ze));
    Or(this, "listConversations", (Ze) => this.client.listConversations(Ze));
    Or(this, "getOrCreateConversation", (Ze) => this.client.getOrCreateConversation(Ze));
    Or(this, "updateConversation", (Ze) => this.client.updateConversation(Ze));
    Or(this, "deleteConversation", (Ze) => this.client.deleteConversation(Ze));
    Or(this, "listParticipants", (Ze) => this.client.listParticipants(Ze));
    Or(this, "addParticipant", (Ze) => this.client.addParticipant(Ze));
    Or(this, "getParticipant", (Ze) => this.client.getParticipant(Ze));
    Or(this, "removeParticipant", (Ze) => this.client.removeParticipant(Ze));
    Or(this, "createEvent", (Ze) => this.client.createEvent(Ze));
    Or(this, "getEvent", (Ze) => this.client.getEvent(Ze));
    Or(this, "listEvents", (Ze) => this.client.listEvents(Ze));
    Or(this, "createMessage", (Ze) => this.client.createMessage(Ze));
    Or(this, "getOrCreateMessage", (Ze) => this.client.getOrCreateMessage(Ze));
    Or(this, "getMessage", (Ze) => this.client.getMessage(Ze));
    Or(this, "updateMessage", (Ze) => this.client.updateMessage(Ze));
    Or(this, "listMessages", (Ze) => this.client.listMessages(Ze));
    Or(this, "deleteMessage", (Ze) => this.client.deleteMessage(Ze));
    Or(this, "createUser", (Ze) => this.client.createUser(Ze));
    Or(this, "getUser", (Ze) => this.client.getUser(Ze));
    Or(this, "listUsers", (Ze) => this.client.listUsers(Ze));
    Or(this, "getOrCreateUser", (Ze) => this.client.getOrCreateUser(Ze));
    Or(this, "updateUser", (Ze) => this.client.updateUser(Ze));
    Or(this, "deleteUser", (Ze) => this.client.deleteUser(Ze));
    Or(this, "getState", (Ze) => this.client.getState(Ze));
    Or(this, "setState", (Ze) => this.client.setState(Ze));
    Or(this, "patchState", (Ze) => this.client.patchState(Ze));
    Or(this, "configureIntegration", (Ze) => this.client.configureIntegration(Ze));
    this.client = Ze;
  }
}, H$8 = G$6(require$$3), x$b = ($e) => {
  if (process.env.BP_LOG_FORMAT === "json")
    return JSON.stringify({ msg: H$8.default.format(...$e), visible_to_bot_owner: !0 });
  {
    let [Ze, ...Fe] = $e;
    return H$8.default.format(`[For Bot Owner] ${Ze}`, ...Fe);
  }
}, $$4 = { forBot: () => ({ info: (...$e) => {
  console.info(x$b($e));
}, warn: (...$e) => {
  console.warn(x$b($e));
}, error: (...$e) => {
  console.error(x$b($e));
}, debug: (...$e) => {
  console.debug(x$b($e));
} }) }, N$8 = ($e) => async (Ze) => {
  let Fe = K$9(Ze.headers), Ke = new u$q(new S$f.Client({ botId: Fe.botId, integrationId: Fe.integrationId })), Ve = { ctx: Fe, req: Ze, client: Ke, logger: $$4, instance: $e };
  try {
    let Je;
    switch (Fe.operation) {
      case "webhook_received":
        Je = await ye$1(Ve);
        break;
      case "register":
        Je = await ve$1(Ve);
        break;
      case "unregister":
        Je = await Ce(Ve);
        break;
      case "message_created":
        Je = await xe$1(Ve);
        break;
      case "action_triggered":
        Je = await Se$1(Ve);
        break;
      case "ping":
        Je = await he$1(Ve);
        break;
      case "create_user":
        Je = await Be$1(Ve);
        break;
      case "create_conversation":
        Je = await be$1(Ve);
        break;
      default:
        throw new Error(`Unknown operation ${Fe.operation}`);
    }
    return Je ? { ...Je, status: Je.status ?? 200 } : { status: 200 };
  } catch (Je) {
    if (Je instanceof S$f.RuntimeError)
      return { status: Je.code, body: JSON.stringify(Je.toJSON()) };
    throw Je;
  }
}, he$1 = async ($e) => {
}, ye$1 = async ({ client: $e, ctx: Ze, req: Fe, logger: Ke, instance: Ve }) => {
  let { req: Je } = p$t(Fe);
  return Ve.webhook({ client: $e, ctx: Ze, req: Je, logger: Ke });
}, ve$1 = async ({ client: $e, ctx: Ze, req: Fe, logger: Ke, instance: Ve }) => {
  if (!Ve.register)
    return;
  let { webhookUrl: Je } = p$t(Fe);
  await Ve.register({ client: $e, ctx: Ze, webhookUrl: Je, logger: Ke });
}, Ce = async ({ client: $e, ctx: Ze, req: Fe, logger: Ke, instance: Ve }) => {
  if (!Ve.unregister)
    return;
  let { webhookUrl: Je } = p$t(Fe);
  await Ve.unregister({ ctx: Ze, webhookUrl: Je, client: $e, logger: Ke });
}, Be$1 = async ({ client: $e, ctx: Ze, req: Fe, logger: Ke, instance: Ve }) => {
  if (!Ve.createUser)
    return;
  let { tags: Je } = p$t(Fe);
  return await Ve.createUser({ ctx: Ze, client: $e, tags: Je, logger: Ke });
}, be$1 = async ({ client: $e, ctx: Ze, req: Fe, logger: Ke, instance: Ve }) => {
  if (!Ve.createConversation)
    return;
  let { channel: Je, tags: Qe } = p$t(Fe);
  return await Ve.createConversation({ ctx: Ze, client: $e, channel: Je, tags: Qe, logger: Ke });
}, xe$1 = async ({ ctx: $e, req: Ze, client: Fe, logger: Ke, instance: Ve }) => {
  let { conversation: Je, user: Qe, type: at, payload: ut, message: lt } = p$t(Ze), dt = Ve.channels[Je.channel];
  if (!dt)
    throw new Error(`Channel ${Je.channel} not found`);
  let bt = dt.messages[at];
  if (!bt)
    throw new Error(`Message of type ${at} not found in channel ${Je.channel}`);
  await bt({ ctx: $e, conversation: Je, message: lt, user: Qe, type: at, client: Fe, payload: ut, ack: async ({ tags: $t }) => {
    await Fe.updateMessage({ id: lt.id, tags: $t });
  }, logger: Ke });
}, Se$1 = async ({ req: $e, ctx: Ze, client: Fe, logger: Ke, instance: Ve }) => {
  let { input: Je, type: Qe } = p$t($e);
  if (!Qe)
    throw new Error("Missing action type");
  let at = Ve.actions[Qe];
  if (!at)
    throw new Error(`Action ${Qe} not found`);
  let ut = await at({ ctx: Ze, input: Je, client: Fe, type: Qe, logger: Ke });
  return { body: JSON.stringify({ output: ut }) };
}, P$9 = class {
  constructor(Ze) {
    Or(this, "props");
    Or(this, "actions");
    Or(this, "channels");
    Or(this, "register");
    Or(this, "unregister");
    Or(this, "createUser");
    Or(this, "createConversation");
    Or(this, "webhook");
    Or(this, "handler", N$8(commonjsGlobal));
    Or(this, "start", (Ze) => y$o(this.handler, Ze));
    this.props = Ze, this.actions = Ze.actions, this.channels = Ze.channels, this.register = Ze.register, this.unregister = Ze.unregister, this.createUser = Ze.createUser, this.createConversation = Ze.createConversation, this.webhook = Ze.handler;
  }
}, Z$4 = G$6(require$$2), I$c = class {
  constructor(Ze) {
    Or(this, "getConversation", (Ze) => this.client.getConversation(Ze));
    Or(this, "listConversations", (Ze) => this.client.listConversations(Ze));
    Or(this, "updateConversation", (Ze) => this.client.updateConversation(Ze));
    Or(this, "deleteConversation", (Ze) => this.client.deleteConversation(Ze));
    Or(this, "listParticipants", (Ze) => this.client.listParticipants(Ze));
    Or(this, "addParticipant", (Ze) => this.client.addParticipant(Ze));
    Or(this, "getParticipant", (Ze) => this.client.getParticipant(Ze));
    Or(this, "removeParticipant", (Ze) => this.client.removeParticipant(Ze));
    Or(this, "getEvent", (Ze) => this.client.getEvent(Ze));
    Or(this, "listEvents", (Ze) => this.client.listEvents(Ze));
    Or(this, "createMessage", (Ze) => this.client.createMessage(Ze));
    Or(this, "getOrCreateMessage", (Ze) => this.client.getOrCreateMessage(Ze));
    Or(this, "getMessage", (Ze) => this.client.getMessage(Ze));
    Or(this, "updateMessage", (Ze) => this.client.updateMessage(Ze));
    Or(this, "listMessages", (Ze) => this.client.listMessages(Ze));
    Or(this, "deleteMessage", (Ze) => this.client.deleteMessage(Ze));
    Or(this, "getUser", (Ze) => this.client.getUser(Ze));
    Or(this, "listUsers", (Ze) => this.client.listUsers(Ze));
    Or(this, "updateUser", (Ze) => this.client.updateUser(Ze));
    Or(this, "deleteUser", (Ze) => this.client.deleteUser(Ze));
    Or(this, "getState", (Ze) => this.client.getState(Ze).then((Fe) => ({ state: { ...Fe.state, payload: Fe.state.payload } })));
    Or(this, "setState", (Ze) => this.client.setState(Ze).then((Fe) => ({ state: { ...Fe.state, payload: Fe.state.payload } })));
    Or(this, "patchState", (Ze) => this.client.patchState(Ze).then((Fe) => ({ state: { ...Fe.state, payload: Fe.state.payload } })));
    Or(this, "callAction", (Ze) => this.client.callAction(Ze));
    Or(this, "createConversation", (Ze) => this.client.createConversation(Ze));
    Or(this, "getOrCreateConversation", (Ze) => this.client.getOrCreateConversation(Ze));
    Or(this, "createUser", (Ze) => this.client.createUser(Ze));
    Or(this, "getOrCreateUser", (Ze) => this.client.getOrCreateUser(Ze));
    this.client = Ze;
  }
}, W$6 = lib$1, Pe$1 = W$6.z.enum(["event_received", "register", "unregister", "ping"]), z$b = ($e) => {
  let Ze = $e[f$w], Fe = $e[m$n], Ke = $e[D$a], Ve = Pe$1.parse($e[h$m]);
  if (!Ze)
    throw new Error("Missing bot headers");
  if (!Ke)
    throw new Error("Missing type headers");
  if (!Fe)
    throw new Error("Missing configuration headers");
  if (!Ve)
    throw new Error("Missing operation headers");
  return { botId: Ze, operation: Ve, type: Ke, configuration: Fe ? JSON.parse(Buffer.from(Fe, "base64").toString("utf-8")) : {} };
}, J$6 = ($e) => async (Ze) => {
  let Fe = z$b(Ze.headers);
  Fe.operation !== "ping" && T$9.info(`Received ${Fe.operation} operation for bot ${Fe.botId} of type ${Fe.type}`);
  let Ke = new I$c(new Z$4.Client({ botId: Fe.botId })), Ve = { req: Ze, ctx: Fe, client: Ke, instance: $e };
  switch (Fe.operation) {
    case "event_received":
      await Ue(Ve);
      break;
    case "register":
      await Me$1();
      break;
    case "unregister":
      await we$1();
      break;
    case "ping":
      await Ee$1();
      break;
    default:
      throw new Error(`Unknown operation ${Fe.operation}`);
  }
  return { status: 200 };
}, Ee$1 = async ($e) => {
}, Me$1 = async ($e) => {
}, we$1 = async ($e) => {
}, Ue = async ({ ctx: $e, req: Ze, client: Fe, instance: Ke }) => {
  T$9.debug(`Received event ${$e.type}`);
  let Ve = p$t(Ze), Je = Ve.event;
  switch ($e.type) {
    case "message_created":
      let Qe = { user: Je.payload.user, conversation: Je.payload.conversation, message: Je.payload.message, states: Je.payload.states, event: Je };
      await Promise.all(Ke.messageHandlers.map((lt) => lt({ client: Fe, ctx: $e, ...Qe })));
      break;
    case "state_expired":
      let at = { state: Je.payload.state };
      await Promise.all(Ke.stateExpiredHandlers.map((lt) => lt({ client: Fe, ctx: $e, ...at })));
      break;
    default:
      let ut = { event: Ve.event };
      await Promise.all(Ke.eventHandlers.map((lt) => lt({ client: Fe, ctx: $e, ...ut })));
  }
}, E$f = class {
  constructor(Ze) {
    Or(this, "_state", { messageHandlers: [], eventHandlers: [], stateExpiredHandlers: [] });
    Or(this, "props");
    Or(this, "message", (Ze) => {
      this._state.messageHandlers.push(Ze);
    });
    Or(this, "event", (Ze) => {
      this._state.eventHandlers.push(Ze);
    });
    Or(this, "stateExpired", (Ze) => {
      this._state.stateExpiredHandlers.push(Ze);
    });
    Or(this, "handler", J$6(commonjsGlobal._state));
    Or(this, "start", (Ze) => y$o(this.handler, Ze));
    this.props = Ze;
  }
}, util$1;
(function($e) {
  $e.assertEqual = (Ve) => Ve;
  function Ze(Ve) {
  }
  $e.assertIs = Ze;
  function Fe(Ve) {
    throw new Error();
  }
  $e.assertNever = Fe, $e.arrayToEnum = (Ve) => {
    const Je = {};
    for (const Qe of Ve)
      Je[Qe] = Qe;
    return Je;
  }, $e.getValidEnumValues = (Ve) => {
    const Je = $e.objectKeys(Ve).filter((at) => typeof Ve[Ve[at]] != "number"), Qe = {};
    for (const at of Je)
      Qe[at] = Ve[at];
    return $e.objectValues(Qe);
  }, $e.objectValues = (Ve) => $e.objectKeys(Ve).map(function(Je) {
    return Ve[Je];
  }), $e.objectKeys = typeof Object.keys == "function" ? (Ve) => Object.keys(Ve) : (Ve) => {
    const Je = [];
    for (const Qe in Ve)
      Object.prototype.hasOwnProperty.call(Ve, Qe) && Je.push(Qe);
    return Je;
  }, $e.find = (Ve, Je) => {
    for (const Qe of Ve)
      if (Je(Qe))
        return Qe;
  }, $e.isInteger = typeof Number.isInteger == "function" ? (Ve) => Number.isInteger(Ve) : (Ve) => typeof Ve == "number" && isFinite(Ve) && Math.floor(Ve) === Ve;
  function Ke(Ve, Je = " | ") {
    return Ve.map((Qe) => typeof Qe == "string" ? `'${Qe}'` : Qe).join(Je);
  }
  $e.joinValues = Ke, $e.jsonStringifyReplacer = (Ve, Je) => typeof Je == "bigint" ? Je.toString() : Je;
})(util$1 || (util$1 = {}));
var objectUtil$1;
(function($e) {
  $e.mergeShapes = (Ze, Fe) => ({
    ...Ze,
    ...Fe
    // second overwrites first
  });
})(objectUtil$1 || (objectUtil$1 = {}));
const ZodParsedType$1 = util$1.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), getParsedType$1 = ($e) => {
  switch (typeof $e) {
    case "undefined":
      return ZodParsedType$1.undefined;
    case "string":
      return ZodParsedType$1.string;
    case "number":
      return isNaN($e) ? ZodParsedType$1.nan : ZodParsedType$1.number;
    case "boolean":
      return ZodParsedType$1.boolean;
    case "function":
      return ZodParsedType$1.function;
    case "bigint":
      return ZodParsedType$1.bigint;
    case "symbol":
      return ZodParsedType$1.symbol;
    case "object":
      return Array.isArray($e) ? ZodParsedType$1.array : $e === null ? ZodParsedType$1.null : $e.then && typeof $e.then == "function" && $e.catch && typeof $e.catch == "function" ? ZodParsedType$1.promise : typeof Map < "u" && $e instanceof Map ? ZodParsedType$1.map : typeof Set < "u" && $e instanceof Set ? ZodParsedType$1.set : typeof Date < "u" && $e instanceof Date ? ZodParsedType$1.date : ZodParsedType$1.object;
    default:
      return ZodParsedType$1.unknown;
  }
}, ZodIssueCode$1 = util$1.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), quotelessJson$1 = ($e) => JSON.stringify($e, null, 2).replace(/"([^"]+)":/g, "$1:");
let ZodError$1 = class extends Error {
  constructor(Ze) {
    super(), this.issues = [], this.addIssue = (Ke) => {
      this.issues = [...this.issues, Ke];
    }, this.addIssues = (Ke = []) => {
      this.issues = [...this.issues, ...Ke];
    };
    const Fe = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, Fe) : this.__proto__ = Fe, this.name = "ZodError", this.issues = Ze;
  }
  get errors() {
    return this.issues;
  }
  format(Ze) {
    const Fe = Ze || function(Je) {
      return Je.message;
    }, Ke = { _errors: [] }, Ve = (Je) => {
      for (const Qe of Je.issues)
        if (Qe.code === "invalid_union")
          Qe.unionErrors.map(Ve);
        else if (Qe.code === "invalid_return_type")
          Ve(Qe.returnTypeError);
        else if (Qe.code === "invalid_arguments")
          Ve(Qe.argumentsError);
        else if (Qe.path.length === 0)
          Ke._errors.push(Fe(Qe));
        else {
          let at = Ke, ut = 0;
          for (; ut < Qe.path.length; ) {
            const lt = Qe.path[ut];
            ut === Qe.path.length - 1 ? (at[lt] = at[lt] || { _errors: [] }, at[lt]._errors.push(Fe(Qe))) : at[lt] = at[lt] || { _errors: [] }, at = at[lt], ut++;
          }
        }
    };
    return Ve(this), Ke;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$1.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(Ze = (Fe) => Fe.message) {
    const Fe = {}, Ke = [];
    for (const Ve of this.issues)
      Ve.path.length > 0 ? (Fe[Ve.path[0]] = Fe[Ve.path[0]] || [], Fe[Ve.path[0]].push(Ze(Ve))) : Ke.push(Ze(Ve));
    return { formErrors: Ke, fieldErrors: Fe };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError$1.create = ($e) => new ZodError$1($e);
const errorMap$1 = ($e, Ze) => {
  let Fe;
  switch ($e.code) {
    case ZodIssueCode$1.invalid_type:
      $e.received === ZodParsedType$1.undefined ? Fe = "Required" : Fe = `Expected ${$e.expected}, received ${$e.received}`;
      break;
    case ZodIssueCode$1.invalid_literal:
      Fe = `Invalid literal value, expected ${JSON.stringify($e.expected, util$1.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode$1.unrecognized_keys:
      Fe = `Unrecognized key(s) in object: ${util$1.joinValues($e.keys, ", ")}`;
      break;
    case ZodIssueCode$1.invalid_union:
      Fe = "Invalid input";
      break;
    case ZodIssueCode$1.invalid_union_discriminator:
      Fe = `Invalid discriminator value. Expected ${util$1.joinValues($e.options)}`;
      break;
    case ZodIssueCode$1.invalid_enum_value:
      Fe = `Invalid enum value. Expected ${util$1.joinValues($e.options)}, received '${$e.received}'`;
      break;
    case ZodIssueCode$1.invalid_arguments:
      Fe = "Invalid function arguments";
      break;
    case ZodIssueCode$1.invalid_return_type:
      Fe = "Invalid function return type";
      break;
    case ZodIssueCode$1.invalid_date:
      Fe = "Invalid date";
      break;
    case ZodIssueCode$1.invalid_string:
      typeof $e.validation == "object" ? "includes" in $e.validation ? (Fe = `Invalid input: must include "${$e.validation.includes}"`, typeof $e.validation.position == "number" && (Fe = `${Fe} at one or more positions greater than or equal to ${$e.validation.position}`)) : "startsWith" in $e.validation ? Fe = `Invalid input: must start with "${$e.validation.startsWith}"` : "endsWith" in $e.validation ? Fe = `Invalid input: must end with "${$e.validation.endsWith}"` : util$1.assertNever($e.validation) : $e.validation !== "regex" ? Fe = `Invalid ${$e.validation}` : Fe = "Invalid";
      break;
    case ZodIssueCode$1.too_small:
      $e.type === "array" ? Fe = `Array must contain ${$e.exact ? "exactly" : $e.inclusive ? "at least" : "more than"} ${$e.minimum} element(s)` : $e.type === "string" ? Fe = `String must contain ${$e.exact ? "exactly" : $e.inclusive ? "at least" : "over"} ${$e.minimum} character(s)` : $e.type === "number" ? Fe = `Number must be ${$e.exact ? "exactly equal to " : $e.inclusive ? "greater than or equal to " : "greater than "}${$e.minimum}` : $e.type === "date" ? Fe = `Date must be ${$e.exact ? "exactly equal to " : $e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number($e.minimum))}` : Fe = "Invalid input";
      break;
    case ZodIssueCode$1.too_big:
      $e.type === "array" ? Fe = `Array must contain ${$e.exact ? "exactly" : $e.inclusive ? "at most" : "less than"} ${$e.maximum} element(s)` : $e.type === "string" ? Fe = `String must contain ${$e.exact ? "exactly" : $e.inclusive ? "at most" : "under"} ${$e.maximum} character(s)` : $e.type === "number" ? Fe = `Number must be ${$e.exact ? "exactly" : $e.inclusive ? "less than or equal to" : "less than"} ${$e.maximum}` : $e.type === "bigint" ? Fe = `BigInt must be ${$e.exact ? "exactly" : $e.inclusive ? "less than or equal to" : "less than"} ${$e.maximum}` : $e.type === "date" ? Fe = `Date must be ${$e.exact ? "exactly" : $e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number($e.maximum))}` : Fe = "Invalid input";
      break;
    case ZodIssueCode$1.custom:
      Fe = "Invalid input";
      break;
    case ZodIssueCode$1.invalid_intersection_types:
      Fe = "Intersection results could not be merged";
      break;
    case ZodIssueCode$1.not_multiple_of:
      Fe = `Number must be a multiple of ${$e.multipleOf}`;
      break;
    case ZodIssueCode$1.not_finite:
      Fe = "Number must be finite";
      break;
    default:
      Fe = Ze.defaultError, util$1.assertNever($e);
  }
  return { message: Fe };
};
let overrideErrorMap$1 = errorMap$1;
function setErrorMap$1($e) {
  overrideErrorMap$1 = $e;
}
function getErrorMap$1() {
  return overrideErrorMap$1;
}
const makeIssue$1 = ($e) => {
  const { data: Ze, path: Fe, errorMaps: Ke, issueData: Ve } = $e, Je = [...Fe, ...Ve.path || []], Qe = {
    ...Ve,
    path: Je
  };
  let at = "";
  const ut = Ke.filter((lt) => !!lt).slice().reverse();
  for (const lt of ut)
    at = lt(Qe, { data: Ze, defaultError: at }).message;
  return {
    ...Ve,
    path: Je,
    message: Ve.message || at
  };
}, EMPTY_PATH$1 = [];
function addIssueToContext$1($e, Ze) {
  const Fe = makeIssue$1({
    issueData: Ze,
    data: $e.data,
    path: $e.path,
    errorMaps: [
      $e.common.contextualErrorMap,
      $e.schemaErrorMap,
      getErrorMap$1(),
      errorMap$1
      // then global default map
    ].filter((Ke) => !!Ke)
  });
  $e.common.issues.push(Fe);
}
let ParseStatus$1 = class jn {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(Ze, Fe) {
    const Ke = [];
    for (const Ve of Fe) {
      if (Ve.status === "aborted")
        return INVALID$1;
      Ve.status === "dirty" && Ze.dirty(), Ke.push(Ve.value);
    }
    return { status: Ze.value, value: Ke };
  }
  static async mergeObjectAsync(Ze, Fe) {
    const Ke = [];
    for (const Ve of Fe)
      Ke.push({
        key: await Ve.key,
        value: await Ve.value
      });
    return jn.mergeObjectSync(Ze, Ke);
  }
  static mergeObjectSync(Ze, Fe) {
    const Ke = {};
    for (const Ve of Fe) {
      const { key: Je, value: Qe } = Ve;
      if (Je.status === "aborted" || Qe.status === "aborted")
        return INVALID$1;
      Je.status === "dirty" && Ze.dirty(), Qe.status === "dirty" && Ze.dirty(), Je.value !== "__proto__" && (typeof Qe.value < "u" || Ve.alwaysSet) && (Ke[Je.value] = Qe.value);
    }
    return { status: Ze.value, value: Ke };
  }
};
const INVALID$1 = Object.freeze({
  status: "aborted"
}), DIRTY$1 = ($e) => ({ status: "dirty", value: $e }), OK$1 = ($e) => ({ status: "valid", value: $e }), isAborted$1 = ($e) => $e.status === "aborted", isDirty$1 = ($e) => $e.status === "dirty", isValid$1 = ($e) => $e.status === "valid", isAsync$1 = ($e) => typeof Promise < "u" && $e instanceof Promise;
var errorUtil$1;
(function($e) {
  $e.errToObj = (Ze) => typeof Ze == "string" ? { message: Ze } : Ze || {}, $e.toString = (Ze) => typeof Ze == "string" ? Ze : Ze == null ? void 0 : Ze.message;
})(errorUtil$1 || (errorUtil$1 = {}));
let ParseInputLazyPath$1 = class {
  constructor(Ze, Fe, Ke, Ve) {
    this._cachedPath = [], this.parent = Ze, this.data = Fe, this._path = Ke, this._key = Ve;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
const handleResult$1 = ($e, Ze) => {
  if (isValid$1(Ze))
    return { success: !0, data: Ze.value };
  if (!$e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const Fe = new ZodError$1($e.common.issues);
      return this._error = Fe, this._error;
    }
  };
};
function processCreateParams$1($e) {
  if (!$e)
    return {};
  const { errorMap: Ze, invalid_type_error: Fe, required_error: Ke, description: Ve } = $e;
  if (Ze && (Fe || Ke))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return Ze ? { errorMap: Ze, description: Ve } : { errorMap: (Qe, at) => Qe.code !== "invalid_type" ? { message: at.defaultError } : typeof at.data > "u" ? { message: Ke ?? at.defaultError } : { message: Fe ?? at.defaultError }, description: Ve };
}
let ZodType$1 = class {
  constructor(Ze) {
    this.spa = this.safeParseAsync, this._def = Ze, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(Ze) {
    return getParsedType$1(Ze.data);
  }
  _getOrReturnCtx(Ze, Fe) {
    return Fe || {
      common: Ze.parent.common,
      data: Ze.data,
      parsedType: getParsedType$1(Ze.data),
      schemaErrorMap: this._def.errorMap,
      path: Ze.path,
      parent: Ze.parent
    };
  }
  _processInputParams(Ze) {
    return {
      status: new ParseStatus$1(),
      ctx: {
        common: Ze.parent.common,
        data: Ze.data,
        parsedType: getParsedType$1(Ze.data),
        schemaErrorMap: this._def.errorMap,
        path: Ze.path,
        parent: Ze.parent
      }
    };
  }
  _parseSync(Ze) {
    const Fe = this._parse(Ze);
    if (isAsync$1(Fe))
      throw new Error("Synchronous parse encountered promise.");
    return Fe;
  }
  _parseAsync(Ze) {
    const Fe = this._parse(Ze);
    return Promise.resolve(Fe);
  }
  parse(Ze, Fe) {
    const Ke = this.safeParse(Ze, Fe);
    if (Ke.success)
      return Ke.data;
    throw Ke.error;
  }
  safeParse(Ze, Fe) {
    var Ke;
    const Ve = {
      common: {
        issues: [],
        async: (Ke = Fe == null ? void 0 : Fe.async) !== null && Ke !== void 0 ? Ke : !1,
        contextualErrorMap: Fe == null ? void 0 : Fe.errorMap
      },
      path: (Fe == null ? void 0 : Fe.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: Ze,
      parsedType: getParsedType$1(Ze)
    }, Je = this._parseSync({ data: Ze, path: Ve.path, parent: Ve });
    return handleResult$1(Ve, Je);
  }
  async parseAsync(Ze, Fe) {
    const Ke = await this.safeParseAsync(Ze, Fe);
    if (Ke.success)
      return Ke.data;
    throw Ke.error;
  }
  async safeParseAsync(Ze, Fe) {
    const Ke = {
      common: {
        issues: [],
        contextualErrorMap: Fe == null ? void 0 : Fe.errorMap,
        async: !0
      },
      path: (Fe == null ? void 0 : Fe.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: Ze,
      parsedType: getParsedType$1(Ze)
    }, Ve = this._parse({ data: Ze, path: Ke.path, parent: Ke }), Je = await (isAsync$1(Ve) ? Ve : Promise.resolve(Ve));
    return handleResult$1(Ke, Je);
  }
  refine(Ze, Fe) {
    const Ke = (Ve) => typeof Fe == "string" || typeof Fe > "u" ? { message: Fe } : typeof Fe == "function" ? Fe(Ve) : Fe;
    return this._refinement((Ve, Je) => {
      const Qe = Ze(Ve), at = () => Je.addIssue({
        code: ZodIssueCode$1.custom,
        ...Ke(Ve)
      });
      return typeof Promise < "u" && Qe instanceof Promise ? Qe.then((ut) => ut ? !0 : (at(), !1)) : Qe ? !0 : (at(), !1);
    });
  }
  refinement(Ze, Fe) {
    return this._refinement((Ke, Ve) => Ze(Ke) ? !0 : (Ve.addIssue(typeof Fe == "function" ? Fe(Ke, Ve) : Fe), !1));
  }
  _refinement(Ze) {
    return new ZodEffects$1({
      schema: this,
      typeName: ZodFirstPartyTypeKind$1.ZodEffects,
      effect: { type: "refinement", refinement: Ze }
    });
  }
  superRefine(Ze) {
    return this._refinement(Ze);
  }
  optional() {
    return ZodOptional$1.create(this, this._def);
  }
  nullable() {
    return ZodNullable$1.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray$1.create(this, this._def);
  }
  promise() {
    return ZodPromise$1.create(this, this._def);
  }
  or(Ze) {
    return ZodUnion$1.create([this, Ze], this._def);
  }
  and(Ze) {
    return ZodIntersection$1.create(this, Ze, this._def);
  }
  transform(Ze) {
    return new ZodEffects$1({
      ...processCreateParams$1(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind$1.ZodEffects,
      effect: { type: "transform", transform: Ze }
    });
  }
  default(Ze) {
    const Fe = typeof Ze == "function" ? Ze : () => Ze;
    return new ZodDefault$1({
      ...processCreateParams$1(this._def),
      innerType: this,
      defaultValue: Fe,
      typeName: ZodFirstPartyTypeKind$1.ZodDefault
    });
  }
  brand() {
    return new ZodBranded$1({
      typeName: ZodFirstPartyTypeKind$1.ZodBranded,
      type: this,
      ...processCreateParams$1(this._def)
    });
  }
  catch(Ze) {
    const Fe = typeof Ze == "function" ? Ze : () => Ze;
    return new ZodCatch$1({
      ...processCreateParams$1(this._def),
      innerType: this,
      catchValue: Fe,
      typeName: ZodFirstPartyTypeKind$1.ZodCatch
    });
  }
  describe(Ze) {
    const Fe = this.constructor;
    return new Fe({
      ...this._def,
      description: Ze
    });
  }
  pipe(Ze) {
    return ZodPipeline$1.create(this, Ze);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const cuidRegex$1 = /^c[^\s-]{8,}$/i, cuid2Regex$1 = /^[a-z][a-z0-9]*$/, ulidRegex$1 = /^[0-9A-HJKMNP-TV-Z]{26}$/, uuidRegex$1 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, emailRegex$1 = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let emojiRegex$1;
const ipv4Regex$1 = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, ipv6Regex$1 = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, datetimeRegex$1 = ($e) => $e.precision ? $e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${$e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${$e.precision}}Z$`) : $e.precision === 0 ? $e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : $e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function isValidIP$1($e, Ze) {
  return !!((Ze === "v4" || !Ze) && ipv4Regex$1.test($e) || (Ze === "v6" || !Ze) && ipv6Regex$1.test($e));
}
let ZodString$1 = class $n extends ZodType$1 {
  _parse(Ze) {
    if (this._def.coerce && (Ze.data = String(Ze.data)), this._getType(Ze) !== ZodParsedType$1.string) {
      const Je = this._getOrReturnCtx(Ze);
      return addIssueToContext$1(
        Je,
        {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.string,
          received: Je.parsedType
        }
        //
      ), INVALID$1;
    }
    const Ke = new ParseStatus$1();
    let Ve;
    for (const Je of this._def.checks)
      if (Je.kind === "min")
        Ze.data.length < Je.value && (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$1(Ve, {
          code: ZodIssueCode$1.too_small,
          minimum: Je.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: Je.message
        }), Ke.dirty());
      else if (Je.kind === "max")
        Ze.data.length > Je.value && (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$1(Ve, {
          code: ZodIssueCode$1.too_big,
          maximum: Je.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: Je.message
        }), Ke.dirty());
      else if (Je.kind === "length") {
        const Qe = Ze.data.length > Je.value, at = Ze.data.length < Je.value;
        (Qe || at) && (Ve = this._getOrReturnCtx(Ze, Ve), Qe ? addIssueToContext$1(Ve, {
          code: ZodIssueCode$1.too_big,
          maximum: Je.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: Je.message
        }) : at && addIssueToContext$1(Ve, {
          code: ZodIssueCode$1.too_small,
          minimum: Je.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: Je.message
        }), Ke.dirty());
      } else if (Je.kind === "email")
        emailRegex$1.test(Ze.data) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$1(Ve, {
          validation: "email",
          code: ZodIssueCode$1.invalid_string,
          message: Je.message
        }), Ke.dirty());
      else if (Je.kind === "emoji")
        emojiRegex$1 || (emojiRegex$1 = new RegExp(_emojiRegex, "u")), emojiRegex$1.test(Ze.data) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$1(Ve, {
          validation: "emoji",
          code: ZodIssueCode$1.invalid_string,
          message: Je.message
        }), Ke.dirty());
      else if (Je.kind === "uuid")
        uuidRegex$1.test(Ze.data) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$1(Ve, {
          validation: "uuid",
          code: ZodIssueCode$1.invalid_string,
          message: Je.message
        }), Ke.dirty());
      else if (Je.kind === "cuid")
        cuidRegex$1.test(Ze.data) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$1(Ve, {
          validation: "cuid",
          code: ZodIssueCode$1.invalid_string,
          message: Je.message
        }), Ke.dirty());
      else if (Je.kind === "cuid2")
        cuid2Regex$1.test(Ze.data) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$1(Ve, {
          validation: "cuid2",
          code: ZodIssueCode$1.invalid_string,
          message: Je.message
        }), Ke.dirty());
      else if (Je.kind === "ulid")
        ulidRegex$1.test(Ze.data) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$1(Ve, {
          validation: "ulid",
          code: ZodIssueCode$1.invalid_string,
          message: Je.message
        }), Ke.dirty());
      else if (Je.kind === "url")
        try {
          new URL(Ze.data);
        } catch {
          Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$1(Ve, {
            validation: "url",
            code: ZodIssueCode$1.invalid_string,
            message: Je.message
          }), Ke.dirty();
        }
      else
        Je.kind === "regex" ? (Je.regex.lastIndex = 0, Je.regex.test(Ze.data) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$1(Ve, {
          validation: "regex",
          code: ZodIssueCode$1.invalid_string,
          message: Je.message
        }), Ke.dirty())) : Je.kind === "trim" ? Ze.data = Ze.data.trim() : Je.kind === "includes" ? Ze.data.includes(Je.value, Je.position) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$1(Ve, {
          code: ZodIssueCode$1.invalid_string,
          validation: { includes: Je.value, position: Je.position },
          message: Je.message
        }), Ke.dirty()) : Je.kind === "toLowerCase" ? Ze.data = Ze.data.toLowerCase() : Je.kind === "toUpperCase" ? Ze.data = Ze.data.toUpperCase() : Je.kind === "startsWith" ? Ze.data.startsWith(Je.value) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$1(Ve, {
          code: ZodIssueCode$1.invalid_string,
          validation: { startsWith: Je.value },
          message: Je.message
        }), Ke.dirty()) : Je.kind === "endsWith" ? Ze.data.endsWith(Je.value) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$1(Ve, {
          code: ZodIssueCode$1.invalid_string,
          validation: { endsWith: Je.value },
          message: Je.message
        }), Ke.dirty()) : Je.kind === "datetime" ? datetimeRegex$1(Je).test(Ze.data) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$1(Ve, {
          code: ZodIssueCode$1.invalid_string,
          validation: "datetime",
          message: Je.message
        }), Ke.dirty()) : Je.kind === "ip" ? isValidIP$1(Ze.data, Je.version) || (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$1(Ve, {
          validation: "ip",
          code: ZodIssueCode$1.invalid_string,
          message: Je.message
        }), Ke.dirty()) : util$1.assertNever(Je);
    return { status: Ke.value, value: Ze.data };
  }
  _regex(Ze, Fe, Ke) {
    return this.refinement((Ve) => Ze.test(Ve), {
      validation: Fe,
      code: ZodIssueCode$1.invalid_string,
      ...errorUtil$1.errToObj(Ke)
    });
  }
  _addCheck(Ze) {
    return new $n({
      ...this._def,
      checks: [...this._def.checks, Ze]
    });
  }
  email(Ze) {
    return this._addCheck({ kind: "email", ...errorUtil$1.errToObj(Ze) });
  }
  url(Ze) {
    return this._addCheck({ kind: "url", ...errorUtil$1.errToObj(Ze) });
  }
  emoji(Ze) {
    return this._addCheck({ kind: "emoji", ...errorUtil$1.errToObj(Ze) });
  }
  uuid(Ze) {
    return this._addCheck({ kind: "uuid", ...errorUtil$1.errToObj(Ze) });
  }
  cuid(Ze) {
    return this._addCheck({ kind: "cuid", ...errorUtil$1.errToObj(Ze) });
  }
  cuid2(Ze) {
    return this._addCheck({ kind: "cuid2", ...errorUtil$1.errToObj(Ze) });
  }
  ulid(Ze) {
    return this._addCheck({ kind: "ulid", ...errorUtil$1.errToObj(Ze) });
  }
  ip(Ze) {
    return this._addCheck({ kind: "ip", ...errorUtil$1.errToObj(Ze) });
  }
  datetime(Ze) {
    var Fe;
    return typeof Ze == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: Ze
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (Ze == null ? void 0 : Ze.precision) > "u" ? null : Ze == null ? void 0 : Ze.precision,
      offset: (Fe = Ze == null ? void 0 : Ze.offset) !== null && Fe !== void 0 ? Fe : !1,
      ...errorUtil$1.errToObj(Ze == null ? void 0 : Ze.message)
    });
  }
  regex(Ze, Fe) {
    return this._addCheck({
      kind: "regex",
      regex: Ze,
      ...errorUtil$1.errToObj(Fe)
    });
  }
  includes(Ze, Fe) {
    return this._addCheck({
      kind: "includes",
      value: Ze,
      position: Fe == null ? void 0 : Fe.position,
      ...errorUtil$1.errToObj(Fe == null ? void 0 : Fe.message)
    });
  }
  startsWith(Ze, Fe) {
    return this._addCheck({
      kind: "startsWith",
      value: Ze,
      ...errorUtil$1.errToObj(Fe)
    });
  }
  endsWith(Ze, Fe) {
    return this._addCheck({
      kind: "endsWith",
      value: Ze,
      ...errorUtil$1.errToObj(Fe)
    });
  }
  min(Ze, Fe) {
    return this._addCheck({
      kind: "min",
      value: Ze,
      ...errorUtil$1.errToObj(Fe)
    });
  }
  max(Ze, Fe) {
    return this._addCheck({
      kind: "max",
      value: Ze,
      ...errorUtil$1.errToObj(Fe)
    });
  }
  length(Ze, Fe) {
    return this._addCheck({
      kind: "length",
      value: Ze,
      ...errorUtil$1.errToObj(Fe)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(Ze) {
    return this.min(1, errorUtil$1.errToObj(Ze));
  }
  trim() {
    return new $n({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new $n({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new $n({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((Ze) => Ze.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((Ze) => Ze.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((Ze) => Ze.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((Ze) => Ze.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((Ze) => Ze.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((Ze) => Ze.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((Ze) => Ze.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((Ze) => Ze.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((Ze) => Ze.kind === "ip");
  }
  get minLength() {
    let Ze = null;
    for (const Fe of this._def.checks)
      Fe.kind === "min" && (Ze === null || Fe.value > Ze) && (Ze = Fe.value);
    return Ze;
  }
  get maxLength() {
    let Ze = null;
    for (const Fe of this._def.checks)
      Fe.kind === "max" && (Ze === null || Fe.value < Ze) && (Ze = Fe.value);
    return Ze;
  }
};
ZodString$1.create = ($e) => {
  var Ze;
  return new ZodString$1({
    checks: [],
    typeName: ZodFirstPartyTypeKind$1.ZodString,
    coerce: (Ze = $e == null ? void 0 : $e.coerce) !== null && Ze !== void 0 ? Ze : !1,
    ...processCreateParams$1($e)
  });
};
function floatSafeRemainder$1($e, Ze) {
  const Fe = ($e.toString().split(".")[1] || "").length, Ke = (Ze.toString().split(".")[1] || "").length, Ve = Fe > Ke ? Fe : Ke, Je = parseInt($e.toFixed(Ve).replace(".", "")), Qe = parseInt(Ze.toFixed(Ve).replace(".", ""));
  return Je % Qe / Math.pow(10, Ve);
}
let ZodNumber$1 = class kn extends ZodType$1 {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(Ze) {
    if (this._def.coerce && (Ze.data = Number(Ze.data)), this._getType(Ze) !== ZodParsedType$1.number) {
      const Je = this._getOrReturnCtx(Ze);
      return addIssueToContext$1(Je, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.number,
        received: Je.parsedType
      }), INVALID$1;
    }
    let Ke;
    const Ve = new ParseStatus$1();
    for (const Je of this._def.checks)
      Je.kind === "int" ? util$1.isInteger(Ze.data) || (Ke = this._getOrReturnCtx(Ze, Ke), addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.invalid_type,
        expected: "integer",
        received: "float",
        message: Je.message
      }), Ve.dirty()) : Je.kind === "min" ? (Je.inclusive ? Ze.data < Je.value : Ze.data <= Je.value) && (Ke = this._getOrReturnCtx(Ze, Ke), addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.too_small,
        minimum: Je.value,
        type: "number",
        inclusive: Je.inclusive,
        exact: !1,
        message: Je.message
      }), Ve.dirty()) : Je.kind === "max" ? (Je.inclusive ? Ze.data > Je.value : Ze.data >= Je.value) && (Ke = this._getOrReturnCtx(Ze, Ke), addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.too_big,
        maximum: Je.value,
        type: "number",
        inclusive: Je.inclusive,
        exact: !1,
        message: Je.message
      }), Ve.dirty()) : Je.kind === "multipleOf" ? floatSafeRemainder$1(Ze.data, Je.value) !== 0 && (Ke = this._getOrReturnCtx(Ze, Ke), addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.not_multiple_of,
        multipleOf: Je.value,
        message: Je.message
      }), Ve.dirty()) : Je.kind === "finite" ? Number.isFinite(Ze.data) || (Ke = this._getOrReturnCtx(Ze, Ke), addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.not_finite,
        message: Je.message
      }), Ve.dirty()) : util$1.assertNever(Je);
    return { status: Ve.value, value: Ze.data };
  }
  gte(Ze, Fe) {
    return this.setLimit("min", Ze, !0, errorUtil$1.toString(Fe));
  }
  gt(Ze, Fe) {
    return this.setLimit("min", Ze, !1, errorUtil$1.toString(Fe));
  }
  lte(Ze, Fe) {
    return this.setLimit("max", Ze, !0, errorUtil$1.toString(Fe));
  }
  lt(Ze, Fe) {
    return this.setLimit("max", Ze, !1, errorUtil$1.toString(Fe));
  }
  setLimit(Ze, Fe, Ke, Ve) {
    return new kn({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: Ze,
          value: Fe,
          inclusive: Ke,
          message: errorUtil$1.toString(Ve)
        }
      ]
    });
  }
  _addCheck(Ze) {
    return new kn({
      ...this._def,
      checks: [...this._def.checks, Ze]
    });
  }
  int(Ze) {
    return this._addCheck({
      kind: "int",
      message: errorUtil$1.toString(Ze)
    });
  }
  positive(Ze) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: errorUtil$1.toString(Ze)
    });
  }
  negative(Ze) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: errorUtil$1.toString(Ze)
    });
  }
  nonpositive(Ze) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: errorUtil$1.toString(Ze)
    });
  }
  nonnegative(Ze) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: errorUtil$1.toString(Ze)
    });
  }
  multipleOf(Ze, Fe) {
    return this._addCheck({
      kind: "multipleOf",
      value: Ze,
      message: errorUtil$1.toString(Fe)
    });
  }
  finite(Ze) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil$1.toString(Ze)
    });
  }
  safe(Ze) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil$1.toString(Ze)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil$1.toString(Ze)
    });
  }
  get minValue() {
    let Ze = null;
    for (const Fe of this._def.checks)
      Fe.kind === "min" && (Ze === null || Fe.value > Ze) && (Ze = Fe.value);
    return Ze;
  }
  get maxValue() {
    let Ze = null;
    for (const Fe of this._def.checks)
      Fe.kind === "max" && (Ze === null || Fe.value < Ze) && (Ze = Fe.value);
    return Ze;
  }
  get isInt() {
    return !!this._def.checks.find((Ze) => Ze.kind === "int" || Ze.kind === "multipleOf" && util$1.isInteger(Ze.value));
  }
  get isFinite() {
    let Ze = null, Fe = null;
    for (const Ke of this._def.checks) {
      if (Ke.kind === "finite" || Ke.kind === "int" || Ke.kind === "multipleOf")
        return !0;
      Ke.kind === "min" ? (Fe === null || Ke.value > Fe) && (Fe = Ke.value) : Ke.kind === "max" && (Ze === null || Ke.value < Ze) && (Ze = Ke.value);
    }
    return Number.isFinite(Fe) && Number.isFinite(Ze);
  }
};
ZodNumber$1.create = ($e) => new ZodNumber$1({
  checks: [],
  typeName: ZodFirstPartyTypeKind$1.ZodNumber,
  coerce: ($e == null ? void 0 : $e.coerce) || !1,
  ...processCreateParams$1($e)
});
let ZodBigInt$1 = class An extends ZodType$1 {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(Ze) {
    if (this._def.coerce && (Ze.data = BigInt(Ze.data)), this._getType(Ze) !== ZodParsedType$1.bigint) {
      const Je = this._getOrReturnCtx(Ze);
      return addIssueToContext$1(Je, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.bigint,
        received: Je.parsedType
      }), INVALID$1;
    }
    let Ke;
    const Ve = new ParseStatus$1();
    for (const Je of this._def.checks)
      Je.kind === "min" ? (Je.inclusive ? Ze.data < Je.value : Ze.data <= Je.value) && (Ke = this._getOrReturnCtx(Ze, Ke), addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.too_small,
        type: "bigint",
        minimum: Je.value,
        inclusive: Je.inclusive,
        message: Je.message
      }), Ve.dirty()) : Je.kind === "max" ? (Je.inclusive ? Ze.data > Je.value : Ze.data >= Je.value) && (Ke = this._getOrReturnCtx(Ze, Ke), addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.too_big,
        type: "bigint",
        maximum: Je.value,
        inclusive: Je.inclusive,
        message: Je.message
      }), Ve.dirty()) : Je.kind === "multipleOf" ? Ze.data % Je.value !== BigInt(0) && (Ke = this._getOrReturnCtx(Ze, Ke), addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.not_multiple_of,
        multipleOf: Je.value,
        message: Je.message
      }), Ve.dirty()) : util$1.assertNever(Je);
    return { status: Ve.value, value: Ze.data };
  }
  gte(Ze, Fe) {
    return this.setLimit("min", Ze, !0, errorUtil$1.toString(Fe));
  }
  gt(Ze, Fe) {
    return this.setLimit("min", Ze, !1, errorUtil$1.toString(Fe));
  }
  lte(Ze, Fe) {
    return this.setLimit("max", Ze, !0, errorUtil$1.toString(Fe));
  }
  lt(Ze, Fe) {
    return this.setLimit("max", Ze, !1, errorUtil$1.toString(Fe));
  }
  setLimit(Ze, Fe, Ke, Ve) {
    return new An({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: Ze,
          value: Fe,
          inclusive: Ke,
          message: errorUtil$1.toString(Ve)
        }
      ]
    });
  }
  _addCheck(Ze) {
    return new An({
      ...this._def,
      checks: [...this._def.checks, Ze]
    });
  }
  positive(Ze) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil$1.toString(Ze)
    });
  }
  negative(Ze) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil$1.toString(Ze)
    });
  }
  nonpositive(Ze) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil$1.toString(Ze)
    });
  }
  nonnegative(Ze) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil$1.toString(Ze)
    });
  }
  multipleOf(Ze, Fe) {
    return this._addCheck({
      kind: "multipleOf",
      value: Ze,
      message: errorUtil$1.toString(Fe)
    });
  }
  get minValue() {
    let Ze = null;
    for (const Fe of this._def.checks)
      Fe.kind === "min" && (Ze === null || Fe.value > Ze) && (Ze = Fe.value);
    return Ze;
  }
  get maxValue() {
    let Ze = null;
    for (const Fe of this._def.checks)
      Fe.kind === "max" && (Ze === null || Fe.value < Ze) && (Ze = Fe.value);
    return Ze;
  }
};
ZodBigInt$1.create = ($e) => {
  var Ze;
  return new ZodBigInt$1({
    checks: [],
    typeName: ZodFirstPartyTypeKind$1.ZodBigInt,
    coerce: (Ze = $e == null ? void 0 : $e.coerce) !== null && Ze !== void 0 ? Ze : !1,
    ...processCreateParams$1($e)
  });
};
let ZodBoolean$1 = class extends ZodType$1 {
  _parse(Ze) {
    if (this._def.coerce && (Ze.data = !!Ze.data), this._getType(Ze) !== ZodParsedType$1.boolean) {
      const Ke = this._getOrReturnCtx(Ze);
      return addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.boolean,
        received: Ke.parsedType
      }), INVALID$1;
    }
    return OK$1(Ze.data);
  }
};
ZodBoolean$1.create = ($e) => new ZodBoolean$1({
  typeName: ZodFirstPartyTypeKind$1.ZodBoolean,
  coerce: ($e == null ? void 0 : $e.coerce) || !1,
  ...processCreateParams$1($e)
});
let ZodDate$1 = class Zn extends ZodType$1 {
  _parse(Ze) {
    if (this._def.coerce && (Ze.data = new Date(Ze.data)), this._getType(Ze) !== ZodParsedType$1.date) {
      const Je = this._getOrReturnCtx(Ze);
      return addIssueToContext$1(Je, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.date,
        received: Je.parsedType
      }), INVALID$1;
    }
    if (isNaN(Ze.data.getTime())) {
      const Je = this._getOrReturnCtx(Ze);
      return addIssueToContext$1(Je, {
        code: ZodIssueCode$1.invalid_date
      }), INVALID$1;
    }
    const Ke = new ParseStatus$1();
    let Ve;
    for (const Je of this._def.checks)
      Je.kind === "min" ? Ze.data.getTime() < Je.value && (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$1(Ve, {
        code: ZodIssueCode$1.too_small,
        message: Je.message,
        inclusive: !0,
        exact: !1,
        minimum: Je.value,
        type: "date"
      }), Ke.dirty()) : Je.kind === "max" ? Ze.data.getTime() > Je.value && (Ve = this._getOrReturnCtx(Ze, Ve), addIssueToContext$1(Ve, {
        code: ZodIssueCode$1.too_big,
        message: Je.message,
        inclusive: !0,
        exact: !1,
        maximum: Je.value,
        type: "date"
      }), Ke.dirty()) : util$1.assertNever(Je);
    return {
      status: Ke.value,
      value: new Date(Ze.data.getTime())
    };
  }
  _addCheck(Ze) {
    return new Zn({
      ...this._def,
      checks: [...this._def.checks, Ze]
    });
  }
  min(Ze, Fe) {
    return this._addCheck({
      kind: "min",
      value: Ze.getTime(),
      message: errorUtil$1.toString(Fe)
    });
  }
  max(Ze, Fe) {
    return this._addCheck({
      kind: "max",
      value: Ze.getTime(),
      message: errorUtil$1.toString(Fe)
    });
  }
  get minDate() {
    let Ze = null;
    for (const Fe of this._def.checks)
      Fe.kind === "min" && (Ze === null || Fe.value > Ze) && (Ze = Fe.value);
    return Ze != null ? new Date(Ze) : null;
  }
  get maxDate() {
    let Ze = null;
    for (const Fe of this._def.checks)
      Fe.kind === "max" && (Ze === null || Fe.value < Ze) && (Ze = Fe.value);
    return Ze != null ? new Date(Ze) : null;
  }
};
ZodDate$1.create = ($e) => new ZodDate$1({
  checks: [],
  coerce: ($e == null ? void 0 : $e.coerce) || !1,
  typeName: ZodFirstPartyTypeKind$1.ZodDate,
  ...processCreateParams$1($e)
});
let ZodSymbol$1 = class extends ZodType$1 {
  _parse(Ze) {
    if (this._getType(Ze) !== ZodParsedType$1.symbol) {
      const Ke = this._getOrReturnCtx(Ze);
      return addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.symbol,
        received: Ke.parsedType
      }), INVALID$1;
    }
    return OK$1(Ze.data);
  }
};
ZodSymbol$1.create = ($e) => new ZodSymbol$1({
  typeName: ZodFirstPartyTypeKind$1.ZodSymbol,
  ...processCreateParams$1($e)
});
let ZodUndefined$1 = class extends ZodType$1 {
  _parse(Ze) {
    if (this._getType(Ze) !== ZodParsedType$1.undefined) {
      const Ke = this._getOrReturnCtx(Ze);
      return addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.undefined,
        received: Ke.parsedType
      }), INVALID$1;
    }
    return OK$1(Ze.data);
  }
};
ZodUndefined$1.create = ($e) => new ZodUndefined$1({
  typeName: ZodFirstPartyTypeKind$1.ZodUndefined,
  ...processCreateParams$1($e)
});
let ZodNull$1 = class extends ZodType$1 {
  _parse(Ze) {
    if (this._getType(Ze) !== ZodParsedType$1.null) {
      const Ke = this._getOrReturnCtx(Ze);
      return addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.null,
        received: Ke.parsedType
      }), INVALID$1;
    }
    return OK$1(Ze.data);
  }
};
ZodNull$1.create = ($e) => new ZodNull$1({
  typeName: ZodFirstPartyTypeKind$1.ZodNull,
  ...processCreateParams$1($e)
});
let ZodAny$1 = class extends ZodType$1 {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(Ze) {
    return OK$1(Ze.data);
  }
};
ZodAny$1.create = ($e) => new ZodAny$1({
  typeName: ZodFirstPartyTypeKind$1.ZodAny,
  ...processCreateParams$1($e)
});
let ZodUnknown$1 = class extends ZodType$1 {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(Ze) {
    return OK$1(Ze.data);
  }
};
ZodUnknown$1.create = ($e) => new ZodUnknown$1({
  typeName: ZodFirstPartyTypeKind$1.ZodUnknown,
  ...processCreateParams$1($e)
});
let ZodNever$1 = class extends ZodType$1 {
  _parse(Ze) {
    const Fe = this._getOrReturnCtx(Ze);
    return addIssueToContext$1(Fe, {
      code: ZodIssueCode$1.invalid_type,
      expected: ZodParsedType$1.never,
      received: Fe.parsedType
    }), INVALID$1;
  }
};
ZodNever$1.create = ($e) => new ZodNever$1({
  typeName: ZodFirstPartyTypeKind$1.ZodNever,
  ...processCreateParams$1($e)
});
let ZodVoid$1 = class extends ZodType$1 {
  _parse(Ze) {
    if (this._getType(Ze) !== ZodParsedType$1.undefined) {
      const Ke = this._getOrReturnCtx(Ze);
      return addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.void,
        received: Ke.parsedType
      }), INVALID$1;
    }
    return OK$1(Ze.data);
  }
};
ZodVoid$1.create = ($e) => new ZodVoid$1({
  typeName: ZodFirstPartyTypeKind$1.ZodVoid,
  ...processCreateParams$1($e)
});
let ZodArray$1 = class yn extends ZodType$1 {
  _parse(Ze) {
    const { ctx: Fe, status: Ke } = this._processInputParams(Ze), Ve = this._def;
    if (Fe.parsedType !== ZodParsedType$1.array)
      return addIssueToContext$1(Fe, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.array,
        received: Fe.parsedType
      }), INVALID$1;
    if (Ve.exactLength !== null) {
      const Qe = Fe.data.length > Ve.exactLength.value, at = Fe.data.length < Ve.exactLength.value;
      (Qe || at) && (addIssueToContext$1(Fe, {
        code: Qe ? ZodIssueCode$1.too_big : ZodIssueCode$1.too_small,
        minimum: at ? Ve.exactLength.value : void 0,
        maximum: Qe ? Ve.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: Ve.exactLength.message
      }), Ke.dirty());
    }
    if (Ve.minLength !== null && Fe.data.length < Ve.minLength.value && (addIssueToContext$1(Fe, {
      code: ZodIssueCode$1.too_small,
      minimum: Ve.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: Ve.minLength.message
    }), Ke.dirty()), Ve.maxLength !== null && Fe.data.length > Ve.maxLength.value && (addIssueToContext$1(Fe, {
      code: ZodIssueCode$1.too_big,
      maximum: Ve.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: Ve.maxLength.message
    }), Ke.dirty()), Fe.common.async)
      return Promise.all([...Fe.data].map((Qe, at) => Ve.type._parseAsync(new ParseInputLazyPath$1(Fe, Qe, Fe.path, at)))).then((Qe) => ParseStatus$1.mergeArray(Ke, Qe));
    const Je = [...Fe.data].map((Qe, at) => Ve.type._parseSync(new ParseInputLazyPath$1(Fe, Qe, Fe.path, at)));
    return ParseStatus$1.mergeArray(Ke, Je);
  }
  get element() {
    return this._def.type;
  }
  min(Ze, Fe) {
    return new yn({
      ...this._def,
      minLength: { value: Ze, message: errorUtil$1.toString(Fe) }
    });
  }
  max(Ze, Fe) {
    return new yn({
      ...this._def,
      maxLength: { value: Ze, message: errorUtil$1.toString(Fe) }
    });
  }
  length(Ze, Fe) {
    return new yn({
      ...this._def,
      exactLength: { value: Ze, message: errorUtil$1.toString(Fe) }
    });
  }
  nonempty(Ze) {
    return this.min(1, Ze);
  }
};
ZodArray$1.create = ($e, Ze) => new ZodArray$1({
  type: $e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ZodFirstPartyTypeKind$1.ZodArray,
  ...processCreateParams$1(Ze)
});
function deepPartialify$1($e) {
  if ($e instanceof ZodObject$1) {
    const Ze = {};
    for (const Fe in $e.shape) {
      const Ke = $e.shape[Fe];
      Ze[Fe] = ZodOptional$1.create(deepPartialify$1(Ke));
    }
    return new ZodObject$1({
      ...$e._def,
      shape: () => Ze
    });
  } else
    return $e instanceof ZodArray$1 ? new ZodArray$1({
      ...$e._def,
      type: deepPartialify$1($e.element)
    }) : $e instanceof ZodOptional$1 ? ZodOptional$1.create(deepPartialify$1($e.unwrap())) : $e instanceof ZodNullable$1 ? ZodNullable$1.create(deepPartialify$1($e.unwrap())) : $e instanceof ZodTuple$1 ? ZodTuple$1.create($e.items.map((Ze) => deepPartialify$1(Ze))) : $e;
}
let ZodObject$1 = class dn extends ZodType$1 {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const Ze = this._def.shape(), Fe = util$1.objectKeys(Ze);
    return this._cached = { shape: Ze, keys: Fe };
  }
  _parse(Ze) {
    if (this._getType(Ze) !== ZodParsedType$1.object) {
      const lt = this._getOrReturnCtx(Ze);
      return addIssueToContext$1(lt, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.object,
        received: lt.parsedType
      }), INVALID$1;
    }
    const { status: Ke, ctx: Ve } = this._processInputParams(Ze), { shape: Je, keys: Qe } = this._getCached(), at = [];
    if (!(this._def.catchall instanceof ZodNever$1 && this._def.unknownKeys === "strip"))
      for (const lt in Ve.data)
        Qe.includes(lt) || at.push(lt);
    const ut = [];
    for (const lt of Qe) {
      const dt = Je[lt], bt = Ve.data[lt];
      ut.push({
        key: { status: "valid", value: lt },
        value: dt._parse(new ParseInputLazyPath$1(Ve, bt, Ve.path, lt)),
        alwaysSet: lt in Ve.data
      });
    }
    if (this._def.catchall instanceof ZodNever$1) {
      const lt = this._def.unknownKeys;
      if (lt === "passthrough")
        for (const dt of at)
          ut.push({
            key: { status: "valid", value: dt },
            value: { status: "valid", value: Ve.data[dt] }
          });
      else if (lt === "strict")
        at.length > 0 && (addIssueToContext$1(Ve, {
          code: ZodIssueCode$1.unrecognized_keys,
          keys: at
        }), Ke.dirty());
      else if (lt !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const lt = this._def.catchall;
      for (const dt of at) {
        const bt = Ve.data[dt];
        ut.push({
          key: { status: "valid", value: dt },
          value: lt._parse(
            new ParseInputLazyPath$1(Ve, bt, Ve.path, dt)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: dt in Ve.data
        });
      }
    }
    return Ve.common.async ? Promise.resolve().then(async () => {
      const lt = [];
      for (const dt of ut) {
        const bt = await dt.key;
        lt.push({
          key: bt,
          value: await dt.value,
          alwaysSet: dt.alwaysSet
        });
      }
      return lt;
    }).then((lt) => ParseStatus$1.mergeObjectSync(Ke, lt)) : ParseStatus$1.mergeObjectSync(Ke, ut);
  }
  get shape() {
    return this._def.shape();
  }
  strict(Ze) {
    return errorUtil$1.errToObj, new dn({
      ...this._def,
      unknownKeys: "strict",
      ...Ze !== void 0 ? {
        errorMap: (Fe, Ke) => {
          var Ve, Je, Qe, at;
          const ut = (Qe = (Je = (Ve = this._def).errorMap) === null || Je === void 0 ? void 0 : Je.call(Ve, Fe, Ke).message) !== null && Qe !== void 0 ? Qe : Ke.defaultError;
          return Fe.code === "unrecognized_keys" ? {
            message: (at = errorUtil$1.errToObj(Ze).message) !== null && at !== void 0 ? at : ut
          } : {
            message: ut
          };
        }
      } : {}
    });
  }
  strip() {
    return new dn({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new dn({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(Ze) {
    return new dn({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...Ze
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(Ze) {
    return new dn({
      unknownKeys: Ze._def.unknownKeys,
      catchall: Ze._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...Ze._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind$1.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(Ze, Fe) {
    return this.augment({ [Ze]: Fe });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(Ze) {
    return new dn({
      ...this._def,
      catchall: Ze
    });
  }
  pick(Ze) {
    const Fe = {};
    return util$1.objectKeys(Ze).forEach((Ke) => {
      Ze[Ke] && this.shape[Ke] && (Fe[Ke] = this.shape[Ke]);
    }), new dn({
      ...this._def,
      shape: () => Fe
    });
  }
  omit(Ze) {
    const Fe = {};
    return util$1.objectKeys(this.shape).forEach((Ke) => {
      Ze[Ke] || (Fe[Ke] = this.shape[Ke]);
    }), new dn({
      ...this._def,
      shape: () => Fe
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify$1(this);
  }
  partial(Ze) {
    const Fe = {};
    return util$1.objectKeys(this.shape).forEach((Ke) => {
      const Ve = this.shape[Ke];
      Ze && !Ze[Ke] ? Fe[Ke] = Ve : Fe[Ke] = Ve.optional();
    }), new dn({
      ...this._def,
      shape: () => Fe
    });
  }
  required(Ze) {
    const Fe = {};
    return util$1.objectKeys(this.shape).forEach((Ke) => {
      if (Ze && !Ze[Ke])
        Fe[Ke] = this.shape[Ke];
      else {
        let Je = this.shape[Ke];
        for (; Je instanceof ZodOptional$1; )
          Je = Je._def.innerType;
        Fe[Ke] = Je;
      }
    }), new dn({
      ...this._def,
      shape: () => Fe
    });
  }
  keyof() {
    return createZodEnum$1(util$1.objectKeys(this.shape));
  }
};
ZodObject$1.create = ($e, Ze) => new ZodObject$1({
  shape: () => $e,
  unknownKeys: "strip",
  catchall: ZodNever$1.create(),
  typeName: ZodFirstPartyTypeKind$1.ZodObject,
  ...processCreateParams$1(Ze)
});
ZodObject$1.strictCreate = ($e, Ze) => new ZodObject$1({
  shape: () => $e,
  unknownKeys: "strict",
  catchall: ZodNever$1.create(),
  typeName: ZodFirstPartyTypeKind$1.ZodObject,
  ...processCreateParams$1(Ze)
});
ZodObject$1.lazycreate = ($e, Ze) => new ZodObject$1({
  shape: $e,
  unknownKeys: "strip",
  catchall: ZodNever$1.create(),
  typeName: ZodFirstPartyTypeKind$1.ZodObject,
  ...processCreateParams$1(Ze)
});
let ZodUnion$1 = class extends ZodType$1 {
  _parse(Ze) {
    const { ctx: Fe } = this._processInputParams(Ze), Ke = this._def.options;
    function Ve(Je) {
      for (const at of Je)
        if (at.result.status === "valid")
          return at.result;
      for (const at of Je)
        if (at.result.status === "dirty")
          return Fe.common.issues.push(...at.ctx.common.issues), at.result;
      const Qe = Je.map((at) => new ZodError$1(at.ctx.common.issues));
      return addIssueToContext$1(Fe, {
        code: ZodIssueCode$1.invalid_union,
        unionErrors: Qe
      }), INVALID$1;
    }
    if (Fe.common.async)
      return Promise.all(Ke.map(async (Je) => {
        const Qe = {
          ...Fe,
          common: {
            ...Fe.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await Je._parseAsync({
            data: Fe.data,
            path: Fe.path,
            parent: Qe
          }),
          ctx: Qe
        };
      })).then(Ve);
    {
      let Je;
      const Qe = [];
      for (const ut of Ke) {
        const lt = {
          ...Fe,
          common: {
            ...Fe.common,
            issues: []
          },
          parent: null
        }, dt = ut._parseSync({
          data: Fe.data,
          path: Fe.path,
          parent: lt
        });
        if (dt.status === "valid")
          return dt;
        dt.status === "dirty" && !Je && (Je = { result: dt, ctx: lt }), lt.common.issues.length && Qe.push(lt.common.issues);
      }
      if (Je)
        return Fe.common.issues.push(...Je.ctx.common.issues), Je.result;
      const at = Qe.map((ut) => new ZodError$1(ut));
      return addIssueToContext$1(Fe, {
        code: ZodIssueCode$1.invalid_union,
        unionErrors: at
      }), INVALID$1;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion$1.create = ($e, Ze) => new ZodUnion$1({
  options: $e,
  typeName: ZodFirstPartyTypeKind$1.ZodUnion,
  ...processCreateParams$1(Ze)
});
const getDiscriminator$1 = ($e) => $e instanceof ZodLazy$1 ? getDiscriminator$1($e.schema) : $e instanceof ZodEffects$1 ? getDiscriminator$1($e.innerType()) : $e instanceof ZodLiteral$1 ? [$e.value] : $e instanceof ZodEnum$1 ? $e.options : $e instanceof ZodNativeEnum$1 ? Object.keys($e.enum) : $e instanceof ZodDefault$1 ? getDiscriminator$1($e._def.innerType) : $e instanceof ZodUndefined$1 ? [void 0] : $e instanceof ZodNull$1 ? [null] : null;
let ZodDiscriminatedUnion$1 = class zn extends ZodType$1 {
  _parse(Ze) {
    const { ctx: Fe } = this._processInputParams(Ze);
    if (Fe.parsedType !== ZodParsedType$1.object)
      return addIssueToContext$1(Fe, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.object,
        received: Fe.parsedType
      }), INVALID$1;
    const Ke = this.discriminator, Ve = Fe.data[Ke], Je = this.optionsMap.get(Ve);
    return Je ? Fe.common.async ? Je._parseAsync({
      data: Fe.data,
      path: Fe.path,
      parent: Fe
    }) : Je._parseSync({
      data: Fe.data,
      path: Fe.path,
      parent: Fe
    }) : (addIssueToContext$1(Fe, {
      code: ZodIssueCode$1.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [Ke]
    }), INVALID$1);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(Ze, Fe, Ke) {
    const Ve = /* @__PURE__ */ new Map();
    for (const Je of Fe) {
      const Qe = getDiscriminator$1(Je.shape[Ze]);
      if (!Qe)
        throw new Error(`A discriminator value for key \`${Ze}\` could not be extracted from all schema options`);
      for (const at of Qe) {
        if (Ve.has(at))
          throw new Error(`Discriminator property ${String(Ze)} has duplicate value ${String(at)}`);
        Ve.set(at, Je);
      }
    }
    return new zn({
      typeName: ZodFirstPartyTypeKind$1.ZodDiscriminatedUnion,
      discriminator: Ze,
      options: Fe,
      optionsMap: Ve,
      ...processCreateParams$1(Ke)
    });
  }
};
function mergeValues$1($e, Ze) {
  const Fe = getParsedType$1($e), Ke = getParsedType$1(Ze);
  if ($e === Ze)
    return { valid: !0, data: $e };
  if (Fe === ZodParsedType$1.object && Ke === ZodParsedType$1.object) {
    const Ve = util$1.objectKeys(Ze), Je = util$1.objectKeys($e).filter((at) => Ve.indexOf(at) !== -1), Qe = { ...$e, ...Ze };
    for (const at of Je) {
      const ut = mergeValues$1($e[at], Ze[at]);
      if (!ut.valid)
        return { valid: !1 };
      Qe[at] = ut.data;
    }
    return { valid: !0, data: Qe };
  } else if (Fe === ZodParsedType$1.array && Ke === ZodParsedType$1.array) {
    if ($e.length !== Ze.length)
      return { valid: !1 };
    const Ve = [];
    for (let Je = 0; Je < $e.length; Je++) {
      const Qe = $e[Je], at = Ze[Je], ut = mergeValues$1(Qe, at);
      if (!ut.valid)
        return { valid: !1 };
      Ve.push(ut.data);
    }
    return { valid: !0, data: Ve };
  } else
    return Fe === ZodParsedType$1.date && Ke === ZodParsedType$1.date && +$e == +Ze ? { valid: !0, data: $e } : { valid: !1 };
}
let ZodIntersection$1 = class extends ZodType$1 {
  _parse(Ze) {
    const { status: Fe, ctx: Ke } = this._processInputParams(Ze), Ve = (Je, Qe) => {
      if (isAborted$1(Je) || isAborted$1(Qe))
        return INVALID$1;
      const at = mergeValues$1(Je.value, Qe.value);
      return at.valid ? ((isDirty$1(Je) || isDirty$1(Qe)) && Fe.dirty(), { status: Fe.value, value: at.data }) : (addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.invalid_intersection_types
      }), INVALID$1);
    };
    return Ke.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: Ke.data,
        path: Ke.path,
        parent: Ke
      }),
      this._def.right._parseAsync({
        data: Ke.data,
        path: Ke.path,
        parent: Ke
      })
    ]).then(([Je, Qe]) => Ve(Je, Qe)) : Ve(this._def.left._parseSync({
      data: Ke.data,
      path: Ke.path,
      parent: Ke
    }), this._def.right._parseSync({
      data: Ke.data,
      path: Ke.path,
      parent: Ke
    }));
  }
};
ZodIntersection$1.create = ($e, Ze, Fe) => new ZodIntersection$1({
  left: $e,
  right: Ze,
  typeName: ZodFirstPartyTypeKind$1.ZodIntersection,
  ...processCreateParams$1(Fe)
});
let ZodTuple$1 = class Un extends ZodType$1 {
  _parse(Ze) {
    const { status: Fe, ctx: Ke } = this._processInputParams(Ze);
    if (Ke.parsedType !== ZodParsedType$1.array)
      return addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.array,
        received: Ke.parsedType
      }), INVALID$1;
    if (Ke.data.length < this._def.items.length)
      return addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), INVALID$1;
    !this._def.rest && Ke.data.length > this._def.items.length && (addIssueToContext$1(Ke, {
      code: ZodIssueCode$1.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), Fe.dirty());
    const Je = [...Ke.data].map((Qe, at) => {
      const ut = this._def.items[at] || this._def.rest;
      return ut ? ut._parse(new ParseInputLazyPath$1(Ke, Qe, Ke.path, at)) : null;
    }).filter((Qe) => !!Qe);
    return Ke.common.async ? Promise.all(Je).then((Qe) => ParseStatus$1.mergeArray(Fe, Qe)) : ParseStatus$1.mergeArray(Fe, Je);
  }
  get items() {
    return this._def.items;
  }
  rest(Ze) {
    return new Un({
      ...this._def,
      rest: Ze
    });
  }
};
ZodTuple$1.create = ($e, Ze) => {
  if (!Array.isArray($e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ZodTuple$1({
    items: $e,
    typeName: ZodFirstPartyTypeKind$1.ZodTuple,
    rest: null,
    ...processCreateParams$1(Ze)
  });
};
let ZodRecord$1 = class Rn extends ZodType$1 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(Ze) {
    const { status: Fe, ctx: Ke } = this._processInputParams(Ze);
    if (Ke.parsedType !== ZodParsedType$1.object)
      return addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.object,
        received: Ke.parsedType
      }), INVALID$1;
    const Ve = [], Je = this._def.keyType, Qe = this._def.valueType;
    for (const at in Ke.data)
      Ve.push({
        key: Je._parse(new ParseInputLazyPath$1(Ke, at, Ke.path, at)),
        value: Qe._parse(new ParseInputLazyPath$1(Ke, Ke.data[at], Ke.path, at))
      });
    return Ke.common.async ? ParseStatus$1.mergeObjectAsync(Fe, Ve) : ParseStatus$1.mergeObjectSync(Fe, Ve);
  }
  get element() {
    return this._def.valueType;
  }
  static create(Ze, Fe, Ke) {
    return Fe instanceof ZodType$1 ? new Rn({
      keyType: Ze,
      valueType: Fe,
      typeName: ZodFirstPartyTypeKind$1.ZodRecord,
      ...processCreateParams$1(Ke)
    }) : new Rn({
      keyType: ZodString$1.create(),
      valueType: Ze,
      typeName: ZodFirstPartyTypeKind$1.ZodRecord,
      ...processCreateParams$1(Fe)
    });
  }
}, ZodMap$1 = class extends ZodType$1 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(Ze) {
    const { status: Fe, ctx: Ke } = this._processInputParams(Ze);
    if (Ke.parsedType !== ZodParsedType$1.map)
      return addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.map,
        received: Ke.parsedType
      }), INVALID$1;
    const Ve = this._def.keyType, Je = this._def.valueType, Qe = [...Ke.data.entries()].map(([at, ut], lt) => ({
      key: Ve._parse(new ParseInputLazyPath$1(Ke, at, Ke.path, [lt, "key"])),
      value: Je._parse(new ParseInputLazyPath$1(Ke, ut, Ke.path, [lt, "value"]))
    }));
    if (Ke.common.async) {
      const at = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const ut of Qe) {
          const lt = await ut.key, dt = await ut.value;
          if (lt.status === "aborted" || dt.status === "aborted")
            return INVALID$1;
          (lt.status === "dirty" || dt.status === "dirty") && Fe.dirty(), at.set(lt.value, dt.value);
        }
        return { status: Fe.value, value: at };
      });
    } else {
      const at = /* @__PURE__ */ new Map();
      for (const ut of Qe) {
        const lt = ut.key, dt = ut.value;
        if (lt.status === "aborted" || dt.status === "aborted")
          return INVALID$1;
        (lt.status === "dirty" || dt.status === "dirty") && Fe.dirty(), at.set(lt.value, dt.value);
      }
      return { status: Fe.value, value: at };
    }
  }
};
ZodMap$1.create = ($e, Ze, Fe) => new ZodMap$1({
  valueType: Ze,
  keyType: $e,
  typeName: ZodFirstPartyTypeKind$1.ZodMap,
  ...processCreateParams$1(Fe)
});
let ZodSet$1 = class Cn extends ZodType$1 {
  _parse(Ze) {
    const { status: Fe, ctx: Ke } = this._processInputParams(Ze);
    if (Ke.parsedType !== ZodParsedType$1.set)
      return addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.set,
        received: Ke.parsedType
      }), INVALID$1;
    const Ve = this._def;
    Ve.minSize !== null && Ke.data.size < Ve.minSize.value && (addIssueToContext$1(Ke, {
      code: ZodIssueCode$1.too_small,
      minimum: Ve.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: Ve.minSize.message
    }), Fe.dirty()), Ve.maxSize !== null && Ke.data.size > Ve.maxSize.value && (addIssueToContext$1(Ke, {
      code: ZodIssueCode$1.too_big,
      maximum: Ve.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: Ve.maxSize.message
    }), Fe.dirty());
    const Je = this._def.valueType;
    function Qe(ut) {
      const lt = /* @__PURE__ */ new Set();
      for (const dt of ut) {
        if (dt.status === "aborted")
          return INVALID$1;
        dt.status === "dirty" && Fe.dirty(), lt.add(dt.value);
      }
      return { status: Fe.value, value: lt };
    }
    const at = [...Ke.data.values()].map((ut, lt) => Je._parse(new ParseInputLazyPath$1(Ke, ut, Ke.path, lt)));
    return Ke.common.async ? Promise.all(at).then((ut) => Qe(ut)) : Qe(at);
  }
  min(Ze, Fe) {
    return new Cn({
      ...this._def,
      minSize: { value: Ze, message: errorUtil$1.toString(Fe) }
    });
  }
  max(Ze, Fe) {
    return new Cn({
      ...this._def,
      maxSize: { value: Ze, message: errorUtil$1.toString(Fe) }
    });
  }
  size(Ze, Fe) {
    return this.min(Ze, Fe).max(Ze, Fe);
  }
  nonempty(Ze) {
    return this.min(1, Ze);
  }
};
ZodSet$1.create = ($e, Ze) => new ZodSet$1({
  valueType: $e,
  minSize: null,
  maxSize: null,
  typeName: ZodFirstPartyTypeKind$1.ZodSet,
  ...processCreateParams$1(Ze)
});
let ZodFunction$1 = class wn extends ZodType$1 {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(Ze) {
    const { ctx: Fe } = this._processInputParams(Ze);
    if (Fe.parsedType !== ZodParsedType$1.function)
      return addIssueToContext$1(Fe, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.function,
        received: Fe.parsedType
      }), INVALID$1;
    function Ke(at, ut) {
      return makeIssue$1({
        data: at,
        path: Fe.path,
        errorMaps: [
          Fe.common.contextualErrorMap,
          Fe.schemaErrorMap,
          getErrorMap$1(),
          errorMap$1
        ].filter((lt) => !!lt),
        issueData: {
          code: ZodIssueCode$1.invalid_arguments,
          argumentsError: ut
        }
      });
    }
    function Ve(at, ut) {
      return makeIssue$1({
        data: at,
        path: Fe.path,
        errorMaps: [
          Fe.common.contextualErrorMap,
          Fe.schemaErrorMap,
          getErrorMap$1(),
          errorMap$1
        ].filter((lt) => !!lt),
        issueData: {
          code: ZodIssueCode$1.invalid_return_type,
          returnTypeError: ut
        }
      });
    }
    const Je = { errorMap: Fe.common.contextualErrorMap }, Qe = Fe.data;
    if (this._def.returns instanceof ZodPromise$1) {
      const at = this;
      return OK$1(async function(...ut) {
        const lt = new ZodError$1([]), dt = await at._def.args.parseAsync(ut, Je).catch((vt) => {
          throw lt.addIssue(Ke(ut, vt)), lt;
        }), bt = await Reflect.apply(Qe, this, dt);
        return await at._def.returns._def.type.parseAsync(bt, Je).catch((vt) => {
          throw lt.addIssue(Ve(bt, vt)), lt;
        });
      });
    } else {
      const at = this;
      return OK$1(function(...ut) {
        const lt = at._def.args.safeParse(ut, Je);
        if (!lt.success)
          throw new ZodError$1([Ke(ut, lt.error)]);
        const dt = Reflect.apply(Qe, this, lt.data), bt = at._def.returns.safeParse(dt, Je);
        if (!bt.success)
          throw new ZodError$1([Ve(dt, bt.error)]);
        return bt.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...Ze) {
    return new wn({
      ...this._def,
      args: ZodTuple$1.create(Ze).rest(ZodUnknown$1.create())
    });
  }
  returns(Ze) {
    return new wn({
      ...this._def,
      returns: Ze
    });
  }
  implement(Ze) {
    return this.parse(Ze);
  }
  strictImplement(Ze) {
    return this.parse(Ze);
  }
  static create(Ze, Fe, Ke) {
    return new wn({
      args: Ze || ZodTuple$1.create([]).rest(ZodUnknown$1.create()),
      returns: Fe || ZodUnknown$1.create(),
      typeName: ZodFirstPartyTypeKind$1.ZodFunction,
      ...processCreateParams$1(Ke)
    });
  }
}, ZodLazy$1 = class extends ZodType$1 {
  get schema() {
    return this._def.getter();
  }
  _parse(Ze) {
    const { ctx: Fe } = this._processInputParams(Ze);
    return this._def.getter()._parse({ data: Fe.data, path: Fe.path, parent: Fe });
  }
};
ZodLazy$1.create = ($e, Ze) => new ZodLazy$1({
  getter: $e,
  typeName: ZodFirstPartyTypeKind$1.ZodLazy,
  ...processCreateParams$1(Ze)
});
let ZodLiteral$1 = class extends ZodType$1 {
  _parse(Ze) {
    if (Ze.data !== this._def.value) {
      const Fe = this._getOrReturnCtx(Ze);
      return addIssueToContext$1(Fe, {
        received: Fe.data,
        code: ZodIssueCode$1.invalid_literal,
        expected: this._def.value
      }), INVALID$1;
    }
    return { status: "valid", value: Ze.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral$1.create = ($e, Ze) => new ZodLiteral$1({
  value: $e,
  typeName: ZodFirstPartyTypeKind$1.ZodLiteral,
  ...processCreateParams$1(Ze)
});
function createZodEnum$1($e, Ze) {
  return new ZodEnum$1({
    values: $e,
    typeName: ZodFirstPartyTypeKind$1.ZodEnum,
    ...processCreateParams$1(Ze)
  });
}
let ZodEnum$1 = class In extends ZodType$1 {
  _parse(Ze) {
    if (typeof Ze.data != "string") {
      const Fe = this._getOrReturnCtx(Ze), Ke = this._def.values;
      return addIssueToContext$1(Fe, {
        expected: util$1.joinValues(Ke),
        received: Fe.parsedType,
        code: ZodIssueCode$1.invalid_type
      }), INVALID$1;
    }
    if (this._def.values.indexOf(Ze.data) === -1) {
      const Fe = this._getOrReturnCtx(Ze), Ke = this._def.values;
      return addIssueToContext$1(Fe, {
        received: Fe.data,
        code: ZodIssueCode$1.invalid_enum_value,
        options: Ke
      }), INVALID$1;
    }
    return OK$1(Ze.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const Ze = {};
    for (const Fe of this._def.values)
      Ze[Fe] = Fe;
    return Ze;
  }
  get Values() {
    const Ze = {};
    for (const Fe of this._def.values)
      Ze[Fe] = Fe;
    return Ze;
  }
  get Enum() {
    const Ze = {};
    for (const Fe of this._def.values)
      Ze[Fe] = Fe;
    return Ze;
  }
  extract(Ze) {
    return In.create(Ze);
  }
  exclude(Ze) {
    return In.create(this.options.filter((Fe) => !Ze.includes(Fe)));
  }
};
ZodEnum$1.create = createZodEnum$1;
let ZodNativeEnum$1 = class extends ZodType$1 {
  _parse(Ze) {
    const Fe = util$1.getValidEnumValues(this._def.values), Ke = this._getOrReturnCtx(Ze);
    if (Ke.parsedType !== ZodParsedType$1.string && Ke.parsedType !== ZodParsedType$1.number) {
      const Ve = util$1.objectValues(Fe);
      return addIssueToContext$1(Ke, {
        expected: util$1.joinValues(Ve),
        received: Ke.parsedType,
        code: ZodIssueCode$1.invalid_type
      }), INVALID$1;
    }
    if (Fe.indexOf(Ze.data) === -1) {
      const Ve = util$1.objectValues(Fe);
      return addIssueToContext$1(Ke, {
        received: Ke.data,
        code: ZodIssueCode$1.invalid_enum_value,
        options: Ve
      }), INVALID$1;
    }
    return OK$1(Ze.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum$1.create = ($e, Ze) => new ZodNativeEnum$1({
  values: $e,
  typeName: ZodFirstPartyTypeKind$1.ZodNativeEnum,
  ...processCreateParams$1(Ze)
});
let ZodPromise$1 = class extends ZodType$1 {
  unwrap() {
    return this._def.type;
  }
  _parse(Ze) {
    const { ctx: Fe } = this._processInputParams(Ze);
    if (Fe.parsedType !== ZodParsedType$1.promise && Fe.common.async === !1)
      return addIssueToContext$1(Fe, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.promise,
        received: Fe.parsedType
      }), INVALID$1;
    const Ke = Fe.parsedType === ZodParsedType$1.promise ? Fe.data : Promise.resolve(Fe.data);
    return OK$1(Ke.then((Ve) => this._def.type.parseAsync(Ve, {
      path: Fe.path,
      errorMap: Fe.common.contextualErrorMap
    })));
  }
};
ZodPromise$1.create = ($e, Ze) => new ZodPromise$1({
  type: $e,
  typeName: ZodFirstPartyTypeKind$1.ZodPromise,
  ...processCreateParams$1(Ze)
});
let ZodEffects$1 = class extends ZodType$1 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind$1.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(Ze) {
    const { status: Fe, ctx: Ke } = this._processInputParams(Ze), Ve = this._def.effect || null, Je = {
      addIssue: (Qe) => {
        addIssueToContext$1(Ke, Qe), Qe.fatal ? Fe.abort() : Fe.dirty();
      },
      get path() {
        return Ke.path;
      }
    };
    if (Je.addIssue = Je.addIssue.bind(Je), Ve.type === "preprocess") {
      const Qe = Ve.transform(Ke.data, Je);
      return Ke.common.issues.length ? {
        status: "dirty",
        value: Ke.data
      } : Ke.common.async ? Promise.resolve(Qe).then((at) => this._def.schema._parseAsync({
        data: at,
        path: Ke.path,
        parent: Ke
      })) : this._def.schema._parseSync({
        data: Qe,
        path: Ke.path,
        parent: Ke
      });
    }
    if (Ve.type === "refinement") {
      const Qe = (at) => {
        const ut = Ve.refinement(at, Je);
        if (Ke.common.async)
          return Promise.resolve(ut);
        if (ut instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return at;
      };
      if (Ke.common.async === !1) {
        const at = this._def.schema._parseSync({
          data: Ke.data,
          path: Ke.path,
          parent: Ke
        });
        return at.status === "aborted" ? INVALID$1 : (at.status === "dirty" && Fe.dirty(), Qe(at.value), { status: Fe.value, value: at.value });
      } else
        return this._def.schema._parseAsync({ data: Ke.data, path: Ke.path, parent: Ke }).then((at) => at.status === "aborted" ? INVALID$1 : (at.status === "dirty" && Fe.dirty(), Qe(at.value).then(() => ({ status: Fe.value, value: at.value }))));
    }
    if (Ve.type === "transform")
      if (Ke.common.async === !1) {
        const Qe = this._def.schema._parseSync({
          data: Ke.data,
          path: Ke.path,
          parent: Ke
        });
        if (!isValid$1(Qe))
          return Qe;
        const at = Ve.transform(Qe.value, Je);
        if (at instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: Fe.value, value: at };
      } else
        return this._def.schema._parseAsync({ data: Ke.data, path: Ke.path, parent: Ke }).then((Qe) => isValid$1(Qe) ? Promise.resolve(Ve.transform(Qe.value, Je)).then((at) => ({ status: Fe.value, value: at })) : Qe);
    util$1.assertNever(Ve);
  }
};
ZodEffects$1.create = ($e, Ze, Fe) => new ZodEffects$1({
  schema: $e,
  typeName: ZodFirstPartyTypeKind$1.ZodEffects,
  effect: Ze,
  ...processCreateParams$1(Fe)
});
ZodEffects$1.createWithPreprocess = ($e, Ze, Fe) => new ZodEffects$1({
  schema: Ze,
  effect: { type: "preprocess", transform: $e },
  typeName: ZodFirstPartyTypeKind$1.ZodEffects,
  ...processCreateParams$1(Fe)
});
let ZodOptional$1 = class extends ZodType$1 {
  _parse(Ze) {
    return this._getType(Ze) === ZodParsedType$1.undefined ? OK$1(void 0) : this._def.innerType._parse(Ze);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional$1.create = ($e, Ze) => new ZodOptional$1({
  innerType: $e,
  typeName: ZodFirstPartyTypeKind$1.ZodOptional,
  ...processCreateParams$1(Ze)
});
let ZodNullable$1 = class extends ZodType$1 {
  _parse(Ze) {
    return this._getType(Ze) === ZodParsedType$1.null ? OK$1(null) : this._def.innerType._parse(Ze);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable$1.create = ($e, Ze) => new ZodNullable$1({
  innerType: $e,
  typeName: ZodFirstPartyTypeKind$1.ZodNullable,
  ...processCreateParams$1(Ze)
});
let ZodDefault$1 = class extends ZodType$1 {
  _parse(Ze) {
    const { ctx: Fe } = this._processInputParams(Ze);
    let Ke = Fe.data;
    return Fe.parsedType === ZodParsedType$1.undefined && (Ke = this._def.defaultValue()), this._def.innerType._parse({
      data: Ke,
      path: Fe.path,
      parent: Fe
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault$1.create = ($e, Ze) => new ZodDefault$1({
  innerType: $e,
  typeName: ZodFirstPartyTypeKind$1.ZodDefault,
  defaultValue: typeof Ze.default == "function" ? Ze.default : () => Ze.default,
  ...processCreateParams$1(Ze)
});
let ZodCatch$1 = class extends ZodType$1 {
  _parse(Ze) {
    const { ctx: Fe } = this._processInputParams(Ze), Ke = {
      ...Fe,
      common: {
        ...Fe.common,
        issues: []
      }
    }, Ve = this._def.innerType._parse({
      data: Ke.data,
      path: Ke.path,
      parent: {
        ...Ke
      }
    });
    return isAsync$1(Ve) ? Ve.then((Je) => ({
      status: "valid",
      value: Je.status === "valid" ? Je.value : this._def.catchValue({
        get error() {
          return new ZodError$1(Ke.common.issues);
        },
        input: Ke.data
      })
    })) : {
      status: "valid",
      value: Ve.status === "valid" ? Ve.value : this._def.catchValue({
        get error() {
          return new ZodError$1(Ke.common.issues);
        },
        input: Ke.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch$1.create = ($e, Ze) => new ZodCatch$1({
  innerType: $e,
  typeName: ZodFirstPartyTypeKind$1.ZodCatch,
  catchValue: typeof Ze.catch == "function" ? Ze.catch : () => Ze.catch,
  ...processCreateParams$1(Ze)
});
let ZodNaN$1 = class extends ZodType$1 {
  _parse(Ze) {
    if (this._getType(Ze) !== ZodParsedType$1.nan) {
      const Ke = this._getOrReturnCtx(Ze);
      return addIssueToContext$1(Ke, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.nan,
        received: Ke.parsedType
      }), INVALID$1;
    }
    return { status: "valid", value: Ze.data };
  }
};
ZodNaN$1.create = ($e) => new ZodNaN$1({
  typeName: ZodFirstPartyTypeKind$1.ZodNaN,
  ...processCreateParams$1($e)
});
const BRAND$1 = Symbol("zod_brand");
let ZodBranded$1 = class extends ZodType$1 {
  _parse(Ze) {
    const { ctx: Fe } = this._processInputParams(Ze), Ke = Fe.data;
    return this._def.type._parse({
      data: Ke,
      path: Fe.path,
      parent: Fe
    });
  }
  unwrap() {
    return this._def.type;
  }
}, ZodPipeline$1 = class Fn extends ZodType$1 {
  _parse(Ze) {
    const { status: Fe, ctx: Ke } = this._processInputParams(Ze);
    if (Ke.common.async)
      return (async () => {
        const Je = await this._def.in._parseAsync({
          data: Ke.data,
          path: Ke.path,
          parent: Ke
        });
        return Je.status === "aborted" ? INVALID$1 : Je.status === "dirty" ? (Fe.dirty(), DIRTY$1(Je.value)) : this._def.out._parseAsync({
          data: Je.value,
          path: Ke.path,
          parent: Ke
        });
      })();
    {
      const Ve = this._def.in._parseSync({
        data: Ke.data,
        path: Ke.path,
        parent: Ke
      });
      return Ve.status === "aborted" ? INVALID$1 : Ve.status === "dirty" ? (Fe.dirty(), {
        status: "dirty",
        value: Ve.value
      }) : this._def.out._parseSync({
        data: Ve.value,
        path: Ke.path,
        parent: Ke
      });
    }
  }
  static create(Ze, Fe) {
    return new Fn({
      in: Ze,
      out: Fe,
      typeName: ZodFirstPartyTypeKind$1.ZodPipeline
    });
  }
};
class ZodReadonly extends ZodType$1 {
  _parse(Ze) {
    const Fe = this._def.innerType._parse(Ze);
    return isValid$1(Fe) && (Fe.value = Object.freeze(Fe.value)), Fe;
  }
}
ZodReadonly.create = ($e, Ze) => new ZodReadonly({
  innerType: $e,
  typeName: ZodFirstPartyTypeKind$1.ZodReadonly,
  ...processCreateParams$1(Ze)
});
const custom$1 = ($e, Ze = {}, Fe) => $e ? ZodAny$1.create().superRefine((Ke, Ve) => {
  var Je, Qe;
  if (!$e(Ke)) {
    const at = typeof Ze == "function" ? Ze(Ke) : typeof Ze == "string" ? { message: Ze } : Ze, ut = (Qe = (Je = at.fatal) !== null && Je !== void 0 ? Je : Fe) !== null && Qe !== void 0 ? Qe : !0, lt = typeof at == "string" ? { message: at } : at;
    Ve.addIssue({ code: "custom", ...lt, fatal: ut });
  }
}) : ZodAny$1.create(), late$1 = {
  object: ZodObject$1.lazycreate
};
var ZodFirstPartyTypeKind$1;
(function($e) {
  $e.ZodString = "ZodString", $e.ZodNumber = "ZodNumber", $e.ZodNaN = "ZodNaN", $e.ZodBigInt = "ZodBigInt", $e.ZodBoolean = "ZodBoolean", $e.ZodDate = "ZodDate", $e.ZodSymbol = "ZodSymbol", $e.ZodUndefined = "ZodUndefined", $e.ZodNull = "ZodNull", $e.ZodAny = "ZodAny", $e.ZodUnknown = "ZodUnknown", $e.ZodNever = "ZodNever", $e.ZodVoid = "ZodVoid", $e.ZodArray = "ZodArray", $e.ZodObject = "ZodObject", $e.ZodUnion = "ZodUnion", $e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", $e.ZodIntersection = "ZodIntersection", $e.ZodTuple = "ZodTuple", $e.ZodRecord = "ZodRecord", $e.ZodMap = "ZodMap", $e.ZodSet = "ZodSet", $e.ZodFunction = "ZodFunction", $e.ZodLazy = "ZodLazy", $e.ZodLiteral = "ZodLiteral", $e.ZodEnum = "ZodEnum", $e.ZodEffects = "ZodEffects", $e.ZodNativeEnum = "ZodNativeEnum", $e.ZodOptional = "ZodOptional", $e.ZodNullable = "ZodNullable", $e.ZodDefault = "ZodDefault", $e.ZodCatch = "ZodCatch", $e.ZodPromise = "ZodPromise", $e.ZodBranded = "ZodBranded", $e.ZodPipeline = "ZodPipeline", $e.ZodReadonly = "ZodReadonly";
})(ZodFirstPartyTypeKind$1 || (ZodFirstPartyTypeKind$1 = {}));
const instanceOfType$1 = ($e, Ze = {
  message: `Input not instance of ${$e.name}`
}) => custom$1((Fe) => Fe instanceof $e, Ze), stringType$1 = ZodString$1.create, numberType$1 = ZodNumber$1.create, nanType$1 = ZodNaN$1.create, bigIntType$1 = ZodBigInt$1.create, booleanType$1 = ZodBoolean$1.create, dateType$1 = ZodDate$1.create, symbolType$1 = ZodSymbol$1.create, undefinedType$1 = ZodUndefined$1.create, nullType$1 = ZodNull$1.create, anyType$1 = ZodAny$1.create, unknownType$1 = ZodUnknown$1.create, neverType$1 = ZodNever$1.create, voidType$1 = ZodVoid$1.create, arrayType$1 = ZodArray$1.create, objectType$1 = ZodObject$1.create, strictObjectType$1 = ZodObject$1.strictCreate, unionType$1 = ZodUnion$1.create, discriminatedUnionType$1 = ZodDiscriminatedUnion$1.create, intersectionType$1 = ZodIntersection$1.create, tupleType$1 = ZodTuple$1.create, recordType$1 = ZodRecord$1.create, mapType$1 = ZodMap$1.create, setType$1 = ZodSet$1.create, functionType$1 = ZodFunction$1.create, lazyType$1 = ZodLazy$1.create, literalType$1 = ZodLiteral$1.create, enumType$1 = ZodEnum$1.create, nativeEnumType$1 = ZodNativeEnum$1.create, promiseType$1 = ZodPromise$1.create, effectsType$1 = ZodEffects$1.create, optionalType$1 = ZodOptional$1.create, nullableType$1 = ZodNullable$1.create, preprocessType$1 = ZodEffects$1.createWithPreprocess, pipelineType$1 = ZodPipeline$1.create, ostring$1 = () => stringType$1().optional(), onumber$1 = () => numberType$1().optional(), oboolean$1 = () => booleanType$1().optional(), coerce$1 = {
  string: ($e) => ZodString$1.create({ ...$e, coerce: !0 }),
  number: ($e) => ZodNumber$1.create({ ...$e, coerce: !0 }),
  boolean: ($e) => ZodBoolean$1.create({
    ...$e,
    coerce: !0
  }),
  bigint: ($e) => ZodBigInt$1.create({ ...$e, coerce: !0 }),
  date: ($e) => ZodDate$1.create({ ...$e, coerce: !0 })
}, NEVER$1 = INVALID$1;
var z$a = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap$1,
  setErrorMap: setErrorMap$1,
  getErrorMap: getErrorMap$1,
  makeIssue: makeIssue$1,
  EMPTY_PATH: EMPTY_PATH$1,
  addIssueToContext: addIssueToContext$1,
  ParseStatus: ParseStatus$1,
  INVALID: INVALID$1,
  DIRTY: DIRTY$1,
  OK: OK$1,
  isAborted: isAborted$1,
  isDirty: isDirty$1,
  isValid: isValid$1,
  isAsync: isAsync$1,
  get util() {
    return util$1;
  },
  get objectUtil() {
    return objectUtil$1;
  },
  ZodParsedType: ZodParsedType$1,
  getParsedType: getParsedType$1,
  ZodType: ZodType$1,
  ZodString: ZodString$1,
  ZodNumber: ZodNumber$1,
  ZodBigInt: ZodBigInt$1,
  ZodBoolean: ZodBoolean$1,
  ZodDate: ZodDate$1,
  ZodSymbol: ZodSymbol$1,
  ZodUndefined: ZodUndefined$1,
  ZodNull: ZodNull$1,
  ZodAny: ZodAny$1,
  ZodUnknown: ZodUnknown$1,
  ZodNever: ZodNever$1,
  ZodVoid: ZodVoid$1,
  ZodArray: ZodArray$1,
  ZodObject: ZodObject$1,
  ZodUnion: ZodUnion$1,
  ZodDiscriminatedUnion: ZodDiscriminatedUnion$1,
  ZodIntersection: ZodIntersection$1,
  ZodTuple: ZodTuple$1,
  ZodRecord: ZodRecord$1,
  ZodMap: ZodMap$1,
  ZodSet: ZodSet$1,
  ZodFunction: ZodFunction$1,
  ZodLazy: ZodLazy$1,
  ZodLiteral: ZodLiteral$1,
  ZodEnum: ZodEnum$1,
  ZodNativeEnum: ZodNativeEnum$1,
  ZodPromise: ZodPromise$1,
  ZodEffects: ZodEffects$1,
  ZodTransformer: ZodEffects$1,
  ZodOptional: ZodOptional$1,
  ZodNullable: ZodNullable$1,
  ZodDefault: ZodDefault$1,
  ZodCatch: ZodCatch$1,
  ZodNaN: ZodNaN$1,
  BRAND: BRAND$1,
  ZodBranded: ZodBranded$1,
  ZodPipeline: ZodPipeline$1,
  ZodReadonly,
  custom: custom$1,
  Schema: ZodType$1,
  ZodSchema: ZodType$1,
  late: late$1,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind$1;
  },
  coerce: coerce$1,
  any: anyType$1,
  array: arrayType$1,
  bigint: bigIntType$1,
  boolean: booleanType$1,
  date: dateType$1,
  discriminatedUnion: discriminatedUnionType$1,
  effect: effectsType$1,
  enum: enumType$1,
  function: functionType$1,
  instanceof: instanceOfType$1,
  intersection: intersectionType$1,
  lazy: lazyType$1,
  literal: literalType$1,
  map: mapType$1,
  nan: nanType$1,
  nativeEnum: nativeEnumType$1,
  never: neverType$1,
  null: nullType$1,
  nullable: nullableType$1,
  number: numberType$1,
  object: objectType$1,
  oboolean: oboolean$1,
  onumber: onumber$1,
  optional: optionalType$1,
  ostring: ostring$1,
  pipeline: pipelineType$1,
  preprocess: preprocessType$1,
  promise: promiseType$1,
  record: recordType$1,
  set: setType$1,
  strictObject: strictObjectType$1,
  string: stringType$1,
  symbol: symbolType$1,
  transformer: effectsType$1,
  tuple: tupleType$1,
  undefined: undefinedType$1,
  union: unionType$1,
  unknown: unknownType$1,
  void: voidType$1,
  NEVER: NEVER$1,
  ZodIssueCode: ZodIssueCode$1,
  quotelessJson: quotelessJson$1,
  ZodError: ZodError$1
});
const _cssClass = { className: z$a.string().describe("CSS className to apply to the message").optional() }, audioSchema$2 = dist.messages.defaults.audio.schema.extend({ type: z$a.literal("audio"), ..._cssClass }), cardSchema$1 = dist.messages.defaults.card.schema.extend({
  type: z$a.literal("card"),
  subtitle: z$a.string().optional(),
  imageUrl: z$a.string().optional(),
  ..._cssClass
}), carouselSchema = z$a.object({
  type: z$a.literal("carousel"),
  items: z$a.array(cardSchema$1.omit({ type: !0 })),
  ..._cssClass
}), choiceSchema = dist.messages.defaults.choice.schema.extend({ type: z$a.literal("choice"), ..._cssClass }), dropdownSchema$1 = dist.messages.defaults.dropdown.schema.extend({
  type: z$a.literal("dropdown"),
  ..._cssClass
}), fileSchema$2 = dist.messages.defaults.file.schema.extend({ type: z$a.literal("file"), ..._cssClass }), imageSchema$2 = dist.messages.defaults.image.schema.extend({ type: z$a.literal("image"), ..._cssClass }), locationSchema$2 = dist.messages.defaults.location.schema.extend({
  type: z$a.literal("location"),
  ..._cssClass
}), markdownSchema = dist.messages.defaults.markdown.schema.extend({
  type: z$a.literal("markdown"),
  ..._cssClass
}), textSchema$2 = dist.messages.defaults.text.schema.extend({ type: z$a.literal("text"), ..._cssClass }), videoSchema$2 = dist.messages.defaults.video.schema.extend({ type: z$a.literal("video"), ..._cssClass });
z$a.union([
  audioSchema$2,
  cardSchema$1,
  carouselSchema,
  choiceSchema,
  dropdownSchema$1,
  fileSchema$2,
  imageSchema$2,
  locationSchema$2,
  markdownSchema,
  textSchema$2,
  videoSchema$2
]);
const _baseSchema = z$a.object({ className: z$a.string().optional(), avatarUrl: z$a.string().url().optional() }), audioSchema$1 = _baseSchema.extend({
  audio: z$a.string(),
  title: z$a.string().optional()
}), actionSchema = z$a.union([
  z$a.object({
    title: z$a.string(),
    action: z$a.literal("Say something"),
    text: z$a.string()
  }),
  z$a.object({
    title: z$a.string(),
    action: z$a.literal("Open URL"),
    url: z$a.string()
  }),
  z$a.object({
    title: z$a.string(),
    action: z$a.literal("Postback"),
    payload: z$a.string()
  })
]), cardSchema = _baseSchema.extend({
  title: z$a.string(),
  subtitle: z$a.string().optional(),
  image: z$a.string().optional(),
  actions: z$a.array(actionSchema)
  // not sure if this is optional - fleur
}), carouselSchame = _baseSchema.extend({ items: z$a.array(cardSchema) }), dropdownSchema = _baseSchema.extend({
  message: z$a.string().optional(),
  options: z$a.array(z$a.object({ label: z$a.string(), value: z$a.string() })),
  allowCreation: z$a.boolean().optional(),
  placeholderText: z$a.string().optional(),
  allowMultiple: z$a.boolean().optional(),
  buttonText: z$a.string().optional(),
  width: z$a.number().optional(),
  displayInKeyboard: z$a.boolean().optional(),
  markdown: z$a.boolean().optional(),
  text: z$a.string().optional()
}), fileSchema$1 = _baseSchema.extend({
  file: z$a.string(),
  title: z$a.string().optional()
}), imageSchema$1 = _baseSchema.extend({ image: z$a.string() }), locationSchema$1 = _baseSchema.extend({
  latitude: z$a.number(),
  longitude: z$a.number(),
  address: z$a.string().optional(),
  title: z$a.string().optional()
}), singleChoiceSchema = _baseSchema.extend({
  text: z$a.string(),
  disableFreeText: z$a.boolean().optional(),
  choices: z$a.array(z$a.object({ title: z$a.string(), value: z$a.string() }))
}), textSchema$1 = _baseSchema.extend({ text: z$a.string(), markdown: z$a.boolean().optional() }), videoSchema$1 = _baseSchema.extend({
  video: z$a.string(),
  title: z$a.string().optional()
}), messageSchema = z$a.union([
  audioSchema$1.extend({ type: z$a.literal("audio") }),
  cardSchema.extend({ type: z$a.literal("card") }),
  carouselSchame.extend({ type: z$a.literal("carousel") }),
  dropdownSchema.extend({ type: z$a.literal("dropdown") }),
  fileSchema$1.extend({ type: z$a.literal("file") }),
  imageSchema$1.extend({ type: z$a.literal("image") }),
  locationSchema$1.extend({ type: z$a.literal("location") }),
  singleChoiceSchema.extend({ type: z$a.literal("single-choice") }),
  textSchema$1.extend({ type: z$a.literal("text") }),
  videoSchema$1.extend({ type: z$a.literal("video") })
]), zod_buttonBlock = z$a.object({
  type: z$a.literal("button"),
  variant: z$a.enum(["action", "link"]),
  reusable: z$a.boolean().optional(),
  groupId: z$a.string().optional(),
  text: z$a.string(),
  buttonValue: z$a.string()
}), zod_textBlock = z$a.object({ type: z$a.literal("text"), text: z$a.string() }), zod_imageBlock = z$a.object({
  type: z$a.literal("image"),
  orientation: z$a.enum(["portrait", "landscape", "square", "auto"]).optional(),
  url: z$a.string()
}), zod_audioBlock = z$a.object({ type: z$a.literal("audio"), url: z$a.string() }), zod_videoBlock = z$a.object({ type: z$a.literal("video"), url: z$a.string() }), zod_fileBlock = z$a.object({
  type: z$a.literal("file"),
  url: z$a.string(),
  title: z$a.string().optional()
}), zod_locationBlock = z$a.object({
  type: z$a.literal("location"),
  latitude: z$a.number(),
  longitude: z$a.number(),
  title: z$a.string().optional()
}), zod_customBlock = z$a.object({
  type: z$a.literal("custom"),
  payload: z$a.object({}).catchall(z$a.any())
}), zod$1 = {
  buttonBlock: zod_buttonBlock,
  textBlock: zod_textBlock,
  imageBlock: zod_imageBlock,
  audioBlock: zod_audioBlock,
  videoBlock: zod_videoBlock,
  fileBlock: zod_fileBlock,
  locationBlock: zod_locationBlock,
  customBlock: zod_customBlock
}, audioSchema = zod$1.audioBlock, buttonSchema = zod$1.buttonBlock, customSchema = zod$1.customBlock, fileSchema = zod$1.fileBlock, imageSchema = zod$1.imageBlock, locationSchema = zod$1.locationBlock, textSchema = zod$1.textBlock, videoSchema = zod$1.videoBlock;
z$a.union([
  audioSchema,
  buttonSchema,
  customSchema,
  fileSchema,
  imageSchema,
  locationSchema,
  textSchema,
  videoSchema
]);
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let $e = 0; $e < 256; ++$e)
  byteToHex.push(($e + 256).toString(16).slice(1));
function unsafeStringify($e, Ze = 0) {
  return byteToHex[$e[Ze + 0]] + byteToHex[$e[Ze + 1]] + byteToHex[$e[Ze + 2]] + byteToHex[$e[Ze + 3]] + "-" + byteToHex[$e[Ze + 4]] + byteToHex[$e[Ze + 5]] + "-" + byteToHex[$e[Ze + 6]] + byteToHex[$e[Ze + 7]] + "-" + byteToHex[$e[Ze + 8]] + byteToHex[$e[Ze + 9]] + "-" + byteToHex[$e[Ze + 10]] + byteToHex[$e[Ze + 11]] + byteToHex[$e[Ze + 12]] + byteToHex[$e[Ze + 13]] + byteToHex[$e[Ze + 14]] + byteToHex[$e[Ze + 15]];
}
const randomUUID = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), native = {
  randomUUID
};
function v4$1($e, Ze, Fe) {
  if (native.randomUUID && !Ze && !$e)
    return native.randomUUID();
  $e = $e || {};
  const Ke = $e.random || ($e.rng || rng)();
  if (Ke[6] = Ke[6] & 15 | 64, Ke[8] = Ke[8] & 63 | 128, Ze) {
    Fe = Fe || 0;
    for (let Ve = 0; Ve < 16; ++Ve)
      Ze[Fe + Ve] = Ke[Ve];
    return Ze;
  }
  return unsafeStringify(Ke);
}
const withBubble = ($e) => ({
  block: $e,
  type: "bubble"
}), mapAction = ($e) => $e.action === "Say something" ? {
  type: "button",
  variant: "action",
  text: $e.title,
  buttonValue: $e.text,
  reusable: !0
} : $e.action === "Open URL" ? {
  type: "button",
  variant: "link",
  text: $e.title,
  buttonValue: $e.url,
  reusable: !0
} : {
  type: "button",
  variant: "action",
  text: $e.title,
  buttonValue: $e.payload,
  reusable: !0
}, mapCard = ({
  title: $e,
  image: Ze,
  actions: Fe,
  subtitle: Ke
}) => {
  const Ve = [];
  return Ze && Ve.push({
    type: "image",
    url: Ze
  }), $e && Ve.push({
    type: "text",
    text: `## ${$e}`
  }), Ke && Ve.push({
    type: "text",
    text: Ke
  }), Fe.length > 0 && Ve.push({
    type: "row",
    blocks: Fe.map(mapAction)
  }), {
    type: "column",
    horizontalAlignment: "center",
    blocks: [...Ve]
  };
}, mapChoice = ({ choices: $e, text: Ze }) => {
  const Fe = v4$1(), Ke = [
    {
      type: "row",
      blocks: $e.map(({ title: Ve, value: Je }) => ({
        type: "button",
        variant: "action",
        text: Ve,
        buttonValue: Je,
        groupId: Fe
      }))
    }
  ];
  return Ze && Ke.unshift({
    type: "text",
    text: Ze
  }), {
    type: "column",
    blocks: Ke
  };
}, mapDropdown = ({ options: $e, text: Ze }) => {
  const Fe = [
    {
      type: "dropdown",
      label: Ze ?? "Select an option",
      options: $e
    }
  ];
  return Ze && Fe.unshift({
    type: "text",
    text: Ze
  }), {
    type: "column",
    blocks: Fe
  };
}, audioAdapter$1 = ({ type: $e, audio: Ze }) => ({ type: $e, url: Ze }), cardAdapter = ($e) => withBubble(mapCard($e)), carouselAdapter = ({ items: $e }) => ({
  type: "carousel",
  blocks: $e.map(mapCard)
}), choiceAdapter = ($e) => withBubble(mapChoice($e)), dropdownAdapter = ($e) => withBubble(mapDropdown($e)), fileAdapter$1 = ({ file: $e, ...Ze }) => ({
  url: $e,
  ...Ze
}), imageAdapter$1 = ({ type: $e, image: Ze }) => ({ type: $e, url: Ze }), locationAdapter$1 = ({ type: $e, latitude: Ze, longitude: Fe, title: Ke, address: Ve }) => ({
  type: $e,
  latitude: Ze,
  longitude: Fe,
  title: Ke ?? Ve ?? "View on map"
}), textAdapter$1 = ({ type: $e, text: Ze }) => withBubble({ type: $e, text: Ze }), videoAdapter$1 = ({ type: $e, video: Ze }) => ({ type: $e, url: Ze }), messageAdapter$1 = ($e) => {
  switch ($e.type) {
    case "audio":
      return audioAdapter$1($e);
    case "card":
      return cardAdapter($e);
    case "carousel":
      return carouselAdapter($e);
    case "single-choice":
      return choiceAdapter($e);
    case "dropdown":
      return dropdownAdapter($e);
    case "file":
      return fileAdapter$1($e);
    case "image":
      return imageAdapter$1($e);
    case "location":
      return locationAdapter$1($e);
    case "text":
      return textAdapter$1($e);
    case "video":
      return videoAdapter$1($e);
  }
}, audioAdapter = ($e) => $e, buttonAdapter = ($e) => $e, customAdapter = ($e) => $e.payload, fileAdapter = ($e) => $e, imageAdapter = ($e) => $e, locationAdapter = ($e) => $e, textAdapter = ($e) => $e, videoAdapter = ($e) => $e, messageAdapter = ($e) => {
  switch ($e.type) {
    case "audio":
      return audioAdapter($e);
    case "button":
      return buttonAdapter($e);
    case "custom":
      return customAdapter($e);
    case "file":
      return fileAdapter($e);
    case "image":
      return imageAdapter($e);
    case "location":
      return locationAdapter($e);
    case "text":
      return textAdapter($e);
    case "video":
      return videoAdapter($e);
  }
};
class MessagingClient {
  constructor(Ze) {
    Or(this, "socket");
    Or(this, "clientId");
    Or(this, "userId");
    Or(this, "conversationId");
    Or(this, "userToken");
    Or(this, "connected", !1);
    Or(this, "emitter");
    Or(this, "on");
    this.socket = new dist$3.MessagingSocket(Ze), this.emitter = new EventEmitter$1(), this.clientId = Ze.clientId, this.on = this.emitter.on.bind(this.emitter), this.socket.on("connect", (Fe) => {
      this.emitter.emit("connect", Fe);
    }), this.socket.on("disconnect", (Fe) => {
      this.emitter.emit("disconnect", Fe);
    }), this.socket.on("message", (Fe) => {
      if (Fe.payload.type === "trigger")
        this.emitter.emit("trigger", TriggerSchema.parse(Fe.payload).trigger);
      else {
        const Ke = messageSchema.parse(Fe.payload), Ve = messageAdapter$1(Ke);
        this.emitter.emit("message", {
          ...Fe,
          payload: Ve
        });
      }
    }), this.socket.on("conversation", (Fe) => {
      this.emitter.emit("conversation", Fe);
    }), this.socket.on("user", (Fe) => {
      this.emitter.emit("user", Fe);
    });
  }
  async connect(Ze) {
    if (this.connected)
      return;
    this.connected = !0;
    const Fe = await this.socket.connect(Ze).catch((Ke) => {
      throw this.connected = !1, Ke;
    });
    return this.userId = Fe.userId, this.userToken = Fe.userToken, Fe;
  }
  async disconnect() {
    await this.socket.disconnect(), this.connected = !1;
  }
  async sendMessage(Ze) {
    this.conversationId || await this.newConversation(), await this.socket.sendText(Ze), this.emitter.emit("messageSent", Ze);
  }
  async switchConversation(Ze) {
    await this.socket.switchConversation(Ze), this.conversationId = Ze;
  }
  async conversationExists(Ze) {
    return (await this.socket.listConversations()).some((Ke) => Ke.id === Ze);
  }
  async newConversation() {
    const { id: Ze } = await this.socket.createConversation();
    this.conversationId = Ze;
  }
  async listMessages(Ze) {
    return (await this.socket.listMessages(Ze)).map((Ke) => {
      const Ve = messageSchema.parse(Ke.payload), Je = messageAdapter$1(Ve);
      return {
        ...Ke,
        payload: Je
      };
    });
  }
}
var __create = Object.create, __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __defNormalProp = ($e, Ze, Fe) => Ze in $e ? __defProp($e, Ze, { enumerable: !0, configurable: !0, writable: !0, value: Fe }) : $e[Ze] = Fe, __esm = ($e, Ze) => function() {
  return $e && (Ze = (0, $e[__getOwnPropNames($e)[0]])($e = 0)), Ze;
}, __commonJS = ($e, Ze) => function() {
  return Ze || (0, $e[__getOwnPropNames($e)[0]])((Ze = { exports: {} }).exports, Ze), Ze.exports;
}, __export = ($e, Ze) => {
  for (var Fe in Ze)
    __defProp($e, Fe, { get: Ze[Fe], enumerable: !0 });
}, __copyProps = ($e, Ze, Fe, Ke) => {
  if (Ze && typeof Ze == "object" || typeof Ze == "function")
    for (let Ve of __getOwnPropNames(Ze))
      !__hasOwnProp.call($e, Ve) && Ve !== Fe && __defProp($e, Ve, { get: () => Ze[Ve], enumerable: !(Ke = __getOwnPropDesc(Ze, Ve)) || Ke.enumerable });
  return $e;
}, __toESM = ($e, Ze, Fe) => (Fe = $e != null ? __create(__getProtoOf($e)) : {}, __copyProps(
  Ze || !$e || !$e.__esModule ? __defProp(Fe, "default", { value: $e, enumerable: !0 }) : Fe,
  $e
)), __toCommonJS = ($e) => __copyProps(__defProp({}, "__esModule", { value: !0 }), $e), __publicField = ($e, Ze, Fe) => (__defNormalProp($e, typeof Ze != "symbol" ? Ze + "" : Ze, Fe), Fe), init_dirname = __esm({
  "../../node_modules/.pnpm/esbuild-plugin-polyfill-node@0.3.0_esbuild@0.16.12/node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js"() {
  }
}), process_exports = {};
__export(process_exports, {
  _debugEnd: () => _debugEnd,
  _debugProcess: () => _debugProcess,
  _events: () => _events,
  _eventsCount: () => _eventsCount,
  _exiting: () => _exiting,
  _fatalExceptions: () => _fatalExceptions,
  _getActiveHandles: () => _getActiveHandles,
  _getActiveRequests: () => _getActiveRequests,
  _kill: () => _kill,
  _linkedBinding: () => _linkedBinding,
  _maxListeners: () => _maxListeners,
  _preload_modules: () => _preload_modules,
  _rawDebug: () => _rawDebug,
  _startProfilerIdleNotifier: () => _startProfilerIdleNotifier,
  _stopProfilerIdleNotifier: () => _stopProfilerIdleNotifier,
  _tickCallback: () => _tickCallback,
  abort: () => abort,
  addListener: () => addListener,
  allowedNodeEnvironmentFlags: () => allowedNodeEnvironmentFlags,
  arch: () => arch,
  argv: () => argv,
  argv0: () => argv0,
  assert: () => assert,
  binding: () => binding,
  chdir: () => chdir,
  config: () => config$1,
  cpuUsage: () => cpuUsage,
  cwd: () => cwd,
  debugPort: () => debugPort,
  default: () => process$1,
  dlopen: () => dlopen,
  domain: () => domain,
  emit: () => emit,
  emitWarning: () => emitWarning,
  env: () => env,
  execArgv: () => execArgv,
  execPath: () => execPath,
  exit: () => exit,
  features: () => features,
  hasUncaughtExceptionCaptureCallback: () => hasUncaughtExceptionCaptureCallback,
  hrtime: () => hrtime,
  kill: () => kill,
  listeners: () => listeners,
  memoryUsage: () => memoryUsage,
  moduleLoadList: () => moduleLoadList,
  nextTick: () => nextTick,
  off: () => off,
  on: () => on,
  once: () => once,
  openStdin: () => openStdin,
  pid: () => pid,
  platform: () => platform,
  ppid: () => ppid,
  prependListener: () => prependListener,
  prependOnceListener: () => prependOnceListener,
  reallyExit: () => reallyExit,
  release: () => release,
  removeAllListeners: () => removeAllListeners,
  removeListener: () => removeListener,
  resourceUsage: () => resourceUsage,
  setSourceMapsEnabled: () => setSourceMapsEnabled,
  setUncaughtExceptionCaptureCallback: () => setUncaughtExceptionCaptureCallback,
  stderr: () => stderr,
  stdin: () => stdin,
  stdout: () => stdout,
  title: () => title,
  umask: () => umask,
  uptime: () => uptime,
  version: () => version,
  versions: () => versions
});
function unimplemented($e) {
  throw new Error("Node.js process " + $e + " is not supported by JSPM core outside of Node.js");
}
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var $e = setTimeout(cleanUpNextTick, 0);
    draining = !0;
    for (var Ze = queue.length; Ze; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < Ze; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, Ze = queue.length;
    }
    currentQueue = null, draining = !1, clearTimeout($e);
  }
}
function nextTick($e) {
  var Ze = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var Fe = 1; Fe < arguments.length; Fe++)
      Ze[Fe - 1] = arguments[Fe];
  queue.push(new Item($e, Ze)), queue.length === 1 && !draining && setTimeout(drainQueue, 0);
}
function Item($e, Ze) {
  this.fun = $e, this.array = Ze;
}
function noop$1() {
}
function _linkedBinding($e) {
  unimplemented("_linkedBinding");
}
function dlopen($e) {
  unimplemented("dlopen");
}
function _getActiveRequests() {
  return [];
}
function _getActiveHandles() {
  return [];
}
function assert($e, Ze) {
  if (!$e)
    throw new Error(Ze || "assertion error");
}
function hasUncaughtExceptionCaptureCallback() {
  return !1;
}
function uptime() {
  return _performance.now() / 1e3;
}
function hrtime($e) {
  var Ze = Math.floor((Date.now() - _performance.now()) * 1e-3), Fe = _performance.now() * 1e-3, Ke = Math.floor(Fe) + Ze, Ve = Math.floor(Fe % 1 * 1e9);
  return $e && (Ke = Ke - $e[0], Ve = Ve - $e[1], Ve < 0 && (Ke--, Ve += nanoPerSec)), [Ke, Ve];
}
function on() {
  return process$1;
}
function listeners($e) {
  return [];
}
var queue, draining, currentQueue, queueIndex, title, arch, platform, env, argv, execArgv, version, versions, emitWarning, binding, umask, cwd, chdir, release, _rawDebug, moduleLoadList, domain, _exiting, config$1, reallyExit, _kill, cpuUsage, resourceUsage, memoryUsage, kill, exit, openStdin, allowedNodeEnvironmentFlags, features, _fatalExceptions, setUncaughtExceptionCaptureCallback, _tickCallback, _debugProcess, _debugEnd, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, stdout, stderr, stdin, abort, pid, ppid, execPath, debugPort, argv0, _preload_modules, setSourceMapsEnabled, _performance, nowOffset, nanoPerSec, _maxListeners, _events, _eventsCount, addListener, once, off, removeListener, removeAllListeners, emit, prependListener, prependOnceListener, process$1, init_process = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/process.js"() {
    init_dirname(), init_buffer2(), init_process2(), queue = [], draining = !1, queueIndex = -1, Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    }, title = "browser", arch = "x64", platform = "browser", env = {
      PATH: "/usr/bin",
      LANG: navigator.language + ".UTF-8",
      PWD: "/",
      HOME: "/home",
      TMP: "/tmp"
    }, argv = ["/usr/bin/node"], execArgv = [], version = "v16.8.0", versions = {}, emitWarning = function($e, Ze) {
      console.warn((Ze ? Ze + ": " : "") + $e);
    }, binding = function($e) {
      unimplemented("binding");
    }, umask = function($e) {
      return 0;
    }, cwd = function() {
      return "/";
    }, chdir = function($e) {
    }, release = {
      name: "node",
      sourceUrl: "",
      headersUrl: "",
      libUrl: ""
    }, _rawDebug = noop$1, moduleLoadList = [], domain = {}, _exiting = !1, config$1 = {}, reallyExit = noop$1, _kill = noop$1, cpuUsage = function() {
      return {};
    }, resourceUsage = cpuUsage, memoryUsage = cpuUsage, kill = noop$1, exit = noop$1, openStdin = noop$1, allowedNodeEnvironmentFlags = {}, features = {
      inspector: !1,
      debug: !1,
      uv: !1,
      ipv6: !1,
      tls_alpn: !1,
      tls_sni: !1,
      tls_ocsp: !1,
      tls: !1,
      cached_builtins: !0
    }, _fatalExceptions = noop$1, setUncaughtExceptionCaptureCallback = noop$1, _tickCallback = noop$1, _debugProcess = noop$1, _debugEnd = noop$1, _startProfilerIdleNotifier = noop$1, _stopProfilerIdleNotifier = noop$1, stdout = void 0, stderr = void 0, stdin = void 0, abort = noop$1, pid = 2, ppid = 1, execPath = "/bin/usr/node", debugPort = 9229, argv0 = "node", _preload_modules = [], setSourceMapsEnabled = noop$1, _performance = {
      now: typeof performance < "u" ? performance.now.bind(performance) : void 0,
      timing: typeof performance < "u" ? performance.timing : void 0
    }, _performance.now === void 0 && (nowOffset = Date.now(), _performance.timing && _performance.timing.navigationStart && (nowOffset = _performance.timing.navigationStart), _performance.now = () => Date.now() - nowOffset), nanoPerSec = 1e9, hrtime.bigint = function($e) {
      var Ze = hrtime($e);
      return typeof BigInt > "u" ? Ze[0] * nanoPerSec + Ze[1] : BigInt(Ze[0] * nanoPerSec) + BigInt(Ze[1]);
    }, _maxListeners = 10, _events = {}, _eventsCount = 0, addListener = on, once = on, off = on, removeListener = on, removeAllListeners = on, emit = noop$1, prependListener = on, prependOnceListener = on, process$1 = {
      version,
      versions,
      arch,
      platform,
      release,
      _rawDebug,
      moduleLoadList,
      binding,
      _linkedBinding,
      _events,
      _eventsCount,
      _maxListeners,
      on,
      addListener,
      once,
      off,
      removeListener,
      removeAllListeners,
      emit,
      prependListener,
      prependOnceListener,
      listeners,
      domain,
      _exiting,
      config: config$1,
      dlopen,
      uptime,
      _getActiveRequests,
      _getActiveHandles,
      reallyExit,
      _kill,
      cpuUsage,
      resourceUsage,
      memoryUsage,
      kill,
      exit,
      openStdin,
      allowedNodeEnvironmentFlags,
      assert,
      features,
      _fatalExceptions,
      setUncaughtExceptionCaptureCallback,
      hasUncaughtExceptionCaptureCallback,
      emitWarning,
      nextTick,
      _tickCallback,
      _debugProcess,
      _debugEnd,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      stdout,
      stdin,
      stderr,
      abort,
      umask,
      chdir,
      cwd,
      env,
      title,
      argv,
      execArgv,
      pid,
      ppid,
      execPath,
      debugPort,
      hrtime,
      argv0,
      _preload_modules,
      setSourceMapsEnabled
    };
  }
}), init_process2 = __esm({
  "../../node_modules/.pnpm/esbuild-plugin-polyfill-node@0.3.0_esbuild@0.16.12/node_modules/esbuild-plugin-polyfill-node/polyfills/process.js"() {
    init_process();
  }
});
function dew$2() {
  if (_dewExec$2)
    return exports$3;
  _dewExec$2 = !0, exports$3.byteLength = at, exports$3.toByteArray = lt, exports$3.fromByteArray = $t;
  for (var $e = [], Ze = [], Fe = typeof Uint8Array < "u" ? Uint8Array : Array, Ke = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Ve = 0, Je = Ke.length; Ve < Je; ++Ve)
    $e[Ve] = Ke[Ve], Ze[Ke.charCodeAt(Ve)] = Ve;
  Ze["-".charCodeAt(0)] = 62, Ze["_".charCodeAt(0)] = 63;
  function Qe(vt) {
    var wt = vt.length;
    if (wt % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var xt = vt.indexOf("=");
    xt === -1 && (xt = wt);
    var Et = xt === wt ? 0 : 4 - xt % 4;
    return [xt, Et];
  }
  function at(vt) {
    var wt = Qe(vt), xt = wt[0], Et = wt[1];
    return (xt + Et) * 3 / 4 - Et;
  }
  function ut(vt, wt, xt) {
    return (wt + xt) * 3 / 4 - xt;
  }
  function lt(vt) {
    var wt, xt = Qe(vt), Et = xt[0], Tt = xt[1], Rt = new Fe(ut(vt, Et, Tt)), Ct = 0, Zt = Tt > 0 ? Et - 4 : Et, Lt;
    for (Lt = 0; Lt < Zt; Lt += 4)
      wt = Ze[vt.charCodeAt(Lt)] << 18 | Ze[vt.charCodeAt(Lt + 1)] << 12 | Ze[vt.charCodeAt(Lt + 2)] << 6 | Ze[vt.charCodeAt(Lt + 3)], Rt[Ct++] = wt >> 16 & 255, Rt[Ct++] = wt >> 8 & 255, Rt[Ct++] = wt & 255;
    return Tt === 2 && (wt = Ze[vt.charCodeAt(Lt)] << 2 | Ze[vt.charCodeAt(Lt + 1)] >> 4, Rt[Ct++] = wt & 255), Tt === 1 && (wt = Ze[vt.charCodeAt(Lt)] << 10 | Ze[vt.charCodeAt(Lt + 1)] << 4 | Ze[vt.charCodeAt(Lt + 2)] >> 2, Rt[Ct++] = wt >> 8 & 255, Rt[Ct++] = wt & 255), Rt;
  }
  function dt(vt) {
    return $e[vt >> 18 & 63] + $e[vt >> 12 & 63] + $e[vt >> 6 & 63] + $e[vt & 63];
  }
  function bt(vt, wt, xt) {
    for (var Et, Tt = [], Rt = wt; Rt < xt; Rt += 3)
      Et = (vt[Rt] << 16 & 16711680) + (vt[Rt + 1] << 8 & 65280) + (vt[Rt + 2] & 255), Tt.push(dt(Et));
    return Tt.join("");
  }
  function $t(vt) {
    for (var wt, xt = vt.length, Et = xt % 3, Tt = [], Rt = 16383, Ct = 0, Zt = xt - Et; Ct < Zt; Ct += Rt)
      Tt.push(bt(vt, Ct, Ct + Rt > Zt ? Zt : Ct + Rt));
    return Et === 1 ? (wt = vt[xt - 1], Tt.push($e[wt >> 2] + $e[wt << 4 & 63] + "==")) : Et === 2 && (wt = (vt[xt - 2] << 8) + vt[xt - 1], Tt.push($e[wt >> 10] + $e[wt >> 4 & 63] + $e[wt << 2 & 63] + "=")), Tt.join("");
  }
  return exports$3;
}
function dew$1() {
  return _dewExec$1 || (_dewExec$1 = !0, exports$2.read = function($e, Ze, Fe, Ke, Ve) {
    var Je, Qe, at = Ve * 8 - Ke - 1, ut = (1 << at) - 1, lt = ut >> 1, dt = -7, bt = Fe ? Ve - 1 : 0, $t = Fe ? -1 : 1, vt = $e[Ze + bt];
    for (bt += $t, Je = vt & (1 << -dt) - 1, vt >>= -dt, dt += at; dt > 0; Je = Je * 256 + $e[Ze + bt], bt += $t, dt -= 8)
      ;
    for (Qe = Je & (1 << -dt) - 1, Je >>= -dt, dt += Ke; dt > 0; Qe = Qe * 256 + $e[Ze + bt], bt += $t, dt -= 8)
      ;
    if (Je === 0)
      Je = 1 - lt;
    else {
      if (Je === ut)
        return Qe ? NaN : (vt ? -1 : 1) * (1 / 0);
      Qe = Qe + Math.pow(2, Ke), Je = Je - lt;
    }
    return (vt ? -1 : 1) * Qe * Math.pow(2, Je - Ke);
  }, exports$2.write = function($e, Ze, Fe, Ke, Ve, Je) {
    var Qe, at, ut, lt = Je * 8 - Ve - 1, dt = (1 << lt) - 1, bt = dt >> 1, $t = Ve === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, vt = Ke ? 0 : Je - 1, wt = Ke ? 1 : -1, xt = Ze < 0 || Ze === 0 && 1 / Ze < 0 ? 1 : 0;
    for (Ze = Math.abs(Ze), isNaN(Ze) || Ze === 1 / 0 ? (at = isNaN(Ze) ? 1 : 0, Qe = dt) : (Qe = Math.floor(Math.log(Ze) / Math.LN2), Ze * (ut = Math.pow(2, -Qe)) < 1 && (Qe--, ut *= 2), Qe + bt >= 1 ? Ze += $t / ut : Ze += $t * Math.pow(2, 1 - bt), Ze * ut >= 2 && (Qe++, ut /= 2), Qe + bt >= dt ? (at = 0, Qe = dt) : Qe + bt >= 1 ? (at = (Ze * ut - 1) * Math.pow(2, Ve), Qe = Qe + bt) : (at = Ze * Math.pow(2, bt - 1) * Math.pow(2, Ve), Qe = 0)); Ve >= 8; $e[Fe + vt] = at & 255, vt += wt, at /= 256, Ve -= 8)
      ;
    for (Qe = Qe << Ve | at, lt += Ve; lt > 0; $e[Fe + vt] = Qe & 255, vt += wt, Qe /= 256, lt -= 8)
      ;
    $e[Fe + vt - wt] |= xt * 128;
  }), exports$2;
}
function dew() {
  if (_dewExec)
    return exports$1;
  _dewExec = !0;
  const $e = dew$2(), Ze = dew$1(), Fe = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  exports$1.Buffer = Qe, exports$1.SlowBuffer = Tt, exports$1.INSPECT_MAX_BYTES = 50;
  const Ke = 2147483647;
  exports$1.kMaxLength = Ke, Qe.TYPED_ARRAY_SUPPORT = Ve(), !Qe.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function Ve() {
    try {
      const Bt = new Uint8Array(1), kt = {
        foo: function() {
          return 42;
        }
      };
      return Object.setPrototypeOf(kt, Uint8Array.prototype), Object.setPrototypeOf(Bt, kt), Bt.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(Qe.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (Qe.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(Qe.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (Qe.isBuffer(this))
        return this.byteOffset;
    }
  });
  function Je(Bt) {
    if (Bt > Ke)
      throw new RangeError('The value "' + Bt + '" is invalid for option "size"');
    const kt = new Uint8Array(Bt);
    return Object.setPrototypeOf(kt, Qe.prototype), kt;
  }
  function Qe(Bt, kt, It) {
    if (typeof Bt == "number") {
      if (typeof kt == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return dt(Bt);
    }
    return at(Bt, kt, It);
  }
  Qe.poolSize = 8192;
  function at(Bt, kt, It) {
    if (typeof Bt == "string")
      return bt(Bt, kt);
    if (ArrayBuffer.isView(Bt))
      return vt(Bt);
    if (Bt == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Bt);
    if (lr(Bt, ArrayBuffer) || Bt && lr(Bt.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (lr(Bt, SharedArrayBuffer) || Bt && lr(Bt.buffer, SharedArrayBuffer)))
      return wt(Bt, kt, It);
    if (typeof Bt == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    const jt = Bt.valueOf && Bt.valueOf();
    if (jt != null && jt !== Bt)
      return Qe.from(jt, kt, It);
    const Vt = xt(Bt);
    if (Vt)
      return Vt;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Bt[Symbol.toPrimitive] == "function")
      return Qe.from(Bt[Symbol.toPrimitive]("string"), kt, It);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Bt);
  }
  Qe.from = function(Bt, kt, It) {
    return at(Bt, kt, It);
  }, Object.setPrototypeOf(Qe.prototype, Uint8Array.prototype), Object.setPrototypeOf(Qe, Uint8Array);
  function ut(Bt) {
    if (typeof Bt != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Bt < 0)
      throw new RangeError('The value "' + Bt + '" is invalid for option "size"');
  }
  function lt(Bt, kt, It) {
    return ut(Bt), Bt <= 0 ? Je(Bt) : kt !== void 0 ? typeof It == "string" ? Je(Bt).fill(kt, It) : Je(Bt).fill(kt) : Je(Bt);
  }
  Qe.alloc = function(Bt, kt, It) {
    return lt(Bt, kt, It);
  };
  function dt(Bt) {
    return ut(Bt), Je(Bt < 0 ? 0 : Et(Bt) | 0);
  }
  Qe.allocUnsafe = function(Bt) {
    return dt(Bt);
  }, Qe.allocUnsafeSlow = function(Bt) {
    return dt(Bt);
  };
  function bt(Bt, kt) {
    if ((typeof kt != "string" || kt === "") && (kt = "utf8"), !Qe.isEncoding(kt))
      throw new TypeError("Unknown encoding: " + kt);
    const It = Rt(Bt, kt) | 0;
    let jt = Je(It);
    const Vt = jt.write(Bt, kt);
    return Vt !== It && (jt = jt.slice(0, Vt)), jt;
  }
  function $t(Bt) {
    const kt = Bt.length < 0 ? 0 : Et(Bt.length) | 0, It = Je(kt);
    for (let jt = 0; jt < kt; jt += 1)
      It[jt] = Bt[jt] & 255;
    return It;
  }
  function vt(Bt) {
    if (lr(Bt, Uint8Array)) {
      const kt = new Uint8Array(Bt);
      return wt(kt.buffer, kt.byteOffset, kt.byteLength);
    }
    return $t(Bt);
  }
  function wt(Bt, kt, It) {
    if (kt < 0 || Bt.byteLength < kt)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Bt.byteLength < kt + (It || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let jt;
    return kt === void 0 && It === void 0 ? jt = new Uint8Array(Bt) : It === void 0 ? jt = new Uint8Array(Bt, kt) : jt = new Uint8Array(Bt, kt, It), Object.setPrototypeOf(jt, Qe.prototype), jt;
  }
  function xt(Bt) {
    if (Qe.isBuffer(Bt)) {
      const kt = Et(Bt.length) | 0, It = Je(kt);
      return It.length === 0 || Bt.copy(It, 0, 0, kt), It;
    }
    if (Bt.length !== void 0)
      return typeof Bt.length != "number" || Nr(Bt.length) ? Je(0) : $t(Bt);
    if (Bt.type === "Buffer" && Array.isArray(Bt.data))
      return $t(Bt.data);
  }
  function Et(Bt) {
    if (Bt >= Ke)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Ke.toString(16) + " bytes");
    return Bt | 0;
  }
  function Tt(Bt) {
    return +Bt != Bt && (Bt = 0), Qe.alloc(+Bt);
  }
  Qe.isBuffer = function(kt) {
    return kt != null && kt._isBuffer === !0 && kt !== Qe.prototype;
  }, Qe.compare = function(kt, It) {
    if (lr(kt, Uint8Array) && (kt = Qe.from(kt, kt.offset, kt.byteLength)), lr(It, Uint8Array) && (It = Qe.from(It, It.offset, It.byteLength)), !Qe.isBuffer(kt) || !Qe.isBuffer(It))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (kt === It)
      return 0;
    let jt = kt.length, Vt = It.length;
    for (let ar = 0, Yt = Math.min(jt, Vt); ar < Yt; ++ar)
      if (kt[ar] !== It[ar]) {
        jt = kt[ar], Vt = It[ar];
        break;
      }
    return jt < Vt ? -1 : Vt < jt ? 1 : 0;
  }, Qe.isEncoding = function(kt) {
    switch (String(kt).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, Qe.concat = function(kt, It) {
    if (!Array.isArray(kt))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (kt.length === 0)
      return Qe.alloc(0);
    let jt;
    if (It === void 0)
      for (It = 0, jt = 0; jt < kt.length; ++jt)
        It += kt[jt].length;
    const Vt = Qe.allocUnsafe(It);
    let ar = 0;
    for (jt = 0; jt < kt.length; ++jt) {
      let Yt = kt[jt];
      if (lr(Yt, Uint8Array))
        ar + Yt.length > Vt.length ? (Qe.isBuffer(Yt) || (Yt = Qe.from(Yt)), Yt.copy(Vt, ar)) : Uint8Array.prototype.set.call(Vt, Yt, ar);
      else if (Qe.isBuffer(Yt))
        Yt.copy(Vt, ar);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      ar += Yt.length;
    }
    return Vt;
  };
  function Rt(Bt, kt) {
    if (Qe.isBuffer(Bt))
      return Bt.length;
    if (ArrayBuffer.isView(Bt) || lr(Bt, ArrayBuffer))
      return Bt.byteLength;
    if (typeof Bt != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Bt);
    const It = Bt.length, jt = arguments.length > 2 && arguments[2] === !0;
    if (!jt && It === 0)
      return 0;
    let Vt = !1;
    for (; ; )
      switch (kt) {
        case "ascii":
        case "latin1":
        case "binary":
          return It;
        case "utf8":
        case "utf-8":
          return sr(Bt).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return It * 2;
        case "hex":
          return It >>> 1;
        case "base64":
          return Br(Bt).length;
        default:
          if (Vt)
            return jt ? -1 : sr(Bt).length;
          kt = ("" + kt).toLowerCase(), Vt = !0;
      }
  }
  Qe.byteLength = Rt;
  function Ct(Bt, kt, It) {
    let jt = !1;
    if ((kt === void 0 || kt < 0) && (kt = 0), kt > this.length || ((It === void 0 || It > this.length) && (It = this.length), It <= 0) || (It >>>= 0, kt >>>= 0, It <= kt))
      return "";
    for (Bt || (Bt = "utf8"); ; )
      switch (Bt) {
        case "hex":
          return pt(this, kt, It);
        case "utf8":
        case "utf-8":
          return rt(this, kt, It);
        case "ascii":
          return mt(this, kt, It);
        case "latin1":
        case "binary":
          return yt(this, kt, It);
        case "base64":
          return Xe(this, kt, It);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ge(this, kt, It);
        default:
          if (jt)
            throw new TypeError("Unknown encoding: " + Bt);
          Bt = (Bt + "").toLowerCase(), jt = !0;
      }
  }
  Qe.prototype._isBuffer = !0;
  function Zt(Bt, kt, It) {
    const jt = Bt[kt];
    Bt[kt] = Bt[It], Bt[It] = jt;
  }
  Qe.prototype.swap16 = function() {
    const kt = this.length;
    if (kt % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let It = 0; It < kt; It += 2)
      Zt(this, It, It + 1);
    return this;
  }, Qe.prototype.swap32 = function() {
    const kt = this.length;
    if (kt % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let It = 0; It < kt; It += 4)
      Zt(this, It, It + 3), Zt(this, It + 1, It + 2);
    return this;
  }, Qe.prototype.swap64 = function() {
    const kt = this.length;
    if (kt % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let It = 0; It < kt; It += 8)
      Zt(this, It, It + 7), Zt(this, It + 1, It + 6), Zt(this, It + 2, It + 5), Zt(this, It + 3, It + 4);
    return this;
  }, Qe.prototype.toString = function() {
    const kt = this.length;
    return kt === 0 ? "" : arguments.length === 0 ? rt(this, 0, kt) : Ct.apply(this, arguments);
  }, Qe.prototype.toLocaleString = Qe.prototype.toString, Qe.prototype.equals = function(kt) {
    if (!Qe.isBuffer(kt))
      throw new TypeError("Argument must be a Buffer");
    return this === kt ? !0 : Qe.compare(this, kt) === 0;
  }, Qe.prototype.inspect = function() {
    let kt = "";
    const It = exports$1.INSPECT_MAX_BYTES;
    return kt = this.toString("hex", 0, It).replace(/(.{2})/g, "$1 ").trim(), this.length > It && (kt += " ... "), "<Buffer " + kt + ">";
  }, Fe && (Qe.prototype[Fe] = Qe.prototype.inspect), Qe.prototype.compare = function(kt, It, jt, Vt, ar) {
    if (lr(kt, Uint8Array) && (kt = Qe.from(kt, kt.offset, kt.byteLength)), !Qe.isBuffer(kt))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof kt);
    if (It === void 0 && (It = 0), jt === void 0 && (jt = kt ? kt.length : 0), Vt === void 0 && (Vt = 0), ar === void 0 && (ar = this.length), It < 0 || jt > kt.length || Vt < 0 || ar > this.length)
      throw new RangeError("out of range index");
    if (Vt >= ar && It >= jt)
      return 0;
    if (Vt >= ar)
      return -1;
    if (It >= jt)
      return 1;
    if (It >>>= 0, jt >>>= 0, Vt >>>= 0, ar >>>= 0, this === kt)
      return 0;
    let Yt = ar - Vt, hr = jt - It;
    const zr = Math.min(Yt, hr), cr = this.slice(Vt, ar), _r = kt.slice(It, jt);
    for (let Lr = 0; Lr < zr; ++Lr)
      if (cr[Lr] !== _r[Lr]) {
        Yt = cr[Lr], hr = _r[Lr];
        break;
      }
    return Yt < hr ? -1 : hr < Yt ? 1 : 0;
  };
  function Lt(Bt, kt, It, jt, Vt) {
    if (Bt.length === 0)
      return -1;
    if (typeof It == "string" ? (jt = It, It = 0) : It > 2147483647 ? It = 2147483647 : It < -2147483648 && (It = -2147483648), It = +It, Nr(It) && (It = Vt ? 0 : Bt.length - 1), It < 0 && (It = Bt.length + It), It >= Bt.length) {
      if (Vt)
        return -1;
      It = Bt.length - 1;
    } else if (It < 0)
      if (Vt)
        It = 0;
      else
        return -1;
    if (typeof kt == "string" && (kt = Qe.from(kt, jt)), Qe.isBuffer(kt))
      return kt.length === 0 ? -1 : Ut(Bt, kt, It, jt, Vt);
    if (typeof kt == "number")
      return kt = kt & 255, typeof Uint8Array.prototype.indexOf == "function" ? Vt ? Uint8Array.prototype.indexOf.call(Bt, kt, It) : Uint8Array.prototype.lastIndexOf.call(Bt, kt, It) : Ut(Bt, [kt], It, jt, Vt);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Ut(Bt, kt, It, jt, Vt) {
    let ar = 1, Yt = Bt.length, hr = kt.length;
    if (jt !== void 0 && (jt = String(jt).toLowerCase(), jt === "ucs2" || jt === "ucs-2" || jt === "utf16le" || jt === "utf-16le")) {
      if (Bt.length < 2 || kt.length < 2)
        return -1;
      ar = 2, Yt /= 2, hr /= 2, It /= 2;
    }
    function zr(_r, Lr) {
      return ar === 1 ? _r[Lr] : _r.readUInt16BE(Lr * ar);
    }
    let cr;
    if (Vt) {
      let _r = -1;
      for (cr = It; cr < Yt; cr++)
        if (zr(Bt, cr) === zr(kt, _r === -1 ? 0 : cr - _r)) {
          if (_r === -1 && (_r = cr), cr - _r + 1 === hr)
            return _r * ar;
        } else
          _r !== -1 && (cr -= cr - _r), _r = -1;
    } else
      for (It + hr > Yt && (It = Yt - hr), cr = It; cr >= 0; cr--) {
        let _r = !0;
        for (let Lr = 0; Lr < hr; Lr++)
          if (zr(Bt, cr + Lr) !== zr(kt, Lr)) {
            _r = !1;
            break;
          }
        if (_r)
          return cr;
      }
    return -1;
  }
  Qe.prototype.includes = function(kt, It, jt) {
    return this.indexOf(kt, It, jt) !== -1;
  }, Qe.prototype.indexOf = function(kt, It, jt) {
    return Lt(this, kt, It, jt, !0);
  }, Qe.prototype.lastIndexOf = function(kt, It, jt) {
    return Lt(this, kt, It, jt, !1);
  };
  function Pt(Bt, kt, It, jt) {
    It = Number(It) || 0;
    const Vt = Bt.length - It;
    jt ? (jt = Number(jt), jt > Vt && (jt = Vt)) : jt = Vt;
    const ar = kt.length;
    jt > ar / 2 && (jt = ar / 2);
    let Yt;
    for (Yt = 0; Yt < jt; ++Yt) {
      const hr = parseInt(kt.substr(Yt * 2, 2), 16);
      if (Nr(hr))
        return Yt;
      Bt[It + Yt] = hr;
    }
    return Yt;
  }
  function Ot(Bt, kt, It, jt) {
    return or(sr(kt, Bt.length - It), Bt, It, jt);
  }
  function Ft(Bt, kt, It, jt) {
    return or(Jt(kt), Bt, It, jt);
  }
  function gt(Bt, kt, It, jt) {
    return or(Br(kt), Bt, It, jt);
  }
  function We(Bt, kt, It, jt) {
    return or(ir(kt, Bt.length - It), Bt, It, jt);
  }
  Qe.prototype.write = function(kt, It, jt, Vt) {
    if (It === void 0)
      Vt = "utf8", jt = this.length, It = 0;
    else if (jt === void 0 && typeof It == "string")
      Vt = It, jt = this.length, It = 0;
    else if (isFinite(It))
      It = It >>> 0, isFinite(jt) ? (jt = jt >>> 0, Vt === void 0 && (Vt = "utf8")) : (Vt = jt, jt = void 0);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const ar = this.length - It;
    if ((jt === void 0 || jt > ar) && (jt = ar), kt.length > 0 && (jt < 0 || It < 0) || It > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Vt || (Vt = "utf8");
    let Yt = !1;
    for (; ; )
      switch (Vt) {
        case "hex":
          return Pt(this, kt, It, jt);
        case "utf8":
        case "utf-8":
          return Ot(this, kt, It, jt);
        case "ascii":
        case "latin1":
        case "binary":
          return Ft(this, kt, It, jt);
        case "base64":
          return gt(this, kt, It, jt);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return We(this, kt, It, jt);
        default:
          if (Yt)
            throw new TypeError("Unknown encoding: " + Vt);
          Vt = ("" + Vt).toLowerCase(), Yt = !0;
      }
  }, Qe.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Xe(Bt, kt, It) {
    return kt === 0 && It === Bt.length ? $e.fromByteArray(Bt) : $e.fromByteArray(Bt.slice(kt, It));
  }
  function rt(Bt, kt, It) {
    It = Math.min(Bt.length, It);
    const jt = [];
    let Vt = kt;
    for (; Vt < It; ) {
      const ar = Bt[Vt];
      let Yt = null, hr = ar > 239 ? 4 : ar > 223 ? 3 : ar > 191 ? 2 : 1;
      if (Vt + hr <= It) {
        let zr, cr, _r, Lr;
        switch (hr) {
          case 1:
            ar < 128 && (Yt = ar);
            break;
          case 2:
            zr = Bt[Vt + 1], (zr & 192) === 128 && (Lr = (ar & 31) << 6 | zr & 63, Lr > 127 && (Yt = Lr));
            break;
          case 3:
            zr = Bt[Vt + 1], cr = Bt[Vt + 2], (zr & 192) === 128 && (cr & 192) === 128 && (Lr = (ar & 15) << 12 | (zr & 63) << 6 | cr & 63, Lr > 2047 && (Lr < 55296 || Lr > 57343) && (Yt = Lr));
            break;
          case 4:
            zr = Bt[Vt + 1], cr = Bt[Vt + 2], _r = Bt[Vt + 3], (zr & 192) === 128 && (cr & 192) === 128 && (_r & 192) === 128 && (Lr = (ar & 15) << 18 | (zr & 63) << 12 | (cr & 63) << 6 | _r & 63, Lr > 65535 && Lr < 1114112 && (Yt = Lr));
        }
      }
      Yt === null ? (Yt = 65533, hr = 1) : Yt > 65535 && (Yt -= 65536, jt.push(Yt >>> 10 & 1023 | 55296), Yt = 56320 | Yt & 1023), jt.push(Yt), Vt += hr;
    }
    return ft(jt);
  }
  const ot = 4096;
  function ft(Bt) {
    const kt = Bt.length;
    if (kt <= ot)
      return String.fromCharCode.apply(String, Bt);
    let It = "", jt = 0;
    for (; jt < kt; )
      It += String.fromCharCode.apply(String, Bt.slice(jt, jt += ot));
    return It;
  }
  function mt(Bt, kt, It) {
    let jt = "";
    It = Math.min(Bt.length, It);
    for (let Vt = kt; Vt < It; ++Vt)
      jt += String.fromCharCode(Bt[Vt] & 127);
    return jt;
  }
  function yt(Bt, kt, It) {
    let jt = "";
    It = Math.min(Bt.length, It);
    for (let Vt = kt; Vt < It; ++Vt)
      jt += String.fromCharCode(Bt[Vt]);
    return jt;
  }
  function pt(Bt, kt, It) {
    const jt = Bt.length;
    (!kt || kt < 0) && (kt = 0), (!It || It < 0 || It > jt) && (It = jt);
    let Vt = "";
    for (let ar = kt; ar < It; ++ar)
      Vt += dr[Bt[ar]];
    return Vt;
  }
  function Ge(Bt, kt, It) {
    const jt = Bt.slice(kt, It);
    let Vt = "";
    for (let ar = 0; ar < jt.length - 1; ar += 2)
      Vt += String.fromCharCode(jt[ar] + jt[ar + 1] * 256);
    return Vt;
  }
  Qe.prototype.slice = function(kt, It) {
    const jt = this.length;
    kt = ~~kt, It = It === void 0 ? jt : ~~It, kt < 0 ? (kt += jt, kt < 0 && (kt = 0)) : kt > jt && (kt = jt), It < 0 ? (It += jt, It < 0 && (It = 0)) : It > jt && (It = jt), It < kt && (It = kt);
    const Vt = this.subarray(kt, It);
    return Object.setPrototypeOf(Vt, Qe.prototype), Vt;
  };
  function ct(Bt, kt, It) {
    if (Bt % 1 !== 0 || Bt < 0)
      throw new RangeError("offset is not uint");
    if (Bt + kt > It)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Qe.prototype.readUintLE = Qe.prototype.readUIntLE = function(kt, It, jt) {
    kt = kt >>> 0, It = It >>> 0, jt || ct(kt, It, this.length);
    let Vt = this[kt], ar = 1, Yt = 0;
    for (; ++Yt < It && (ar *= 256); )
      Vt += this[kt + Yt] * ar;
    return Vt;
  }, Qe.prototype.readUintBE = Qe.prototype.readUIntBE = function(kt, It, jt) {
    kt = kt >>> 0, It = It >>> 0, jt || ct(kt, It, this.length);
    let Vt = this[kt + --It], ar = 1;
    for (; It > 0 && (ar *= 256); )
      Vt += this[kt + --It] * ar;
    return Vt;
  }, Qe.prototype.readUint8 = Qe.prototype.readUInt8 = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 1, this.length), this[kt];
  }, Qe.prototype.readUint16LE = Qe.prototype.readUInt16LE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 2, this.length), this[kt] | this[kt + 1] << 8;
  }, Qe.prototype.readUint16BE = Qe.prototype.readUInt16BE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 2, this.length), this[kt] << 8 | this[kt + 1];
  }, Qe.prototype.readUint32LE = Qe.prototype.readUInt32LE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 4, this.length), (this[kt] | this[kt + 1] << 8 | this[kt + 2] << 16) + this[kt + 3] * 16777216;
  }, Qe.prototype.readUint32BE = Qe.prototype.readUInt32BE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 4, this.length), this[kt] * 16777216 + (this[kt + 1] << 16 | this[kt + 2] << 8 | this[kt + 3]);
  }, Qe.prototype.readBigUInt64LE = gr(function(kt) {
    kt = kt >>> 0, Dt(kt, "offset");
    const It = this[kt], jt = this[kt + 7];
    (It === void 0 || jt === void 0) && Ht(kt, this.length - 8);
    const Vt = It + this[++kt] * 2 ** 8 + this[++kt] * 2 ** 16 + this[++kt] * 2 ** 24, ar = this[++kt] + this[++kt] * 2 ** 8 + this[++kt] * 2 ** 16 + jt * 2 ** 24;
    return BigInt(Vt) + (BigInt(ar) << BigInt(32));
  }), Qe.prototype.readBigUInt64BE = gr(function(kt) {
    kt = kt >>> 0, Dt(kt, "offset");
    const It = this[kt], jt = this[kt + 7];
    (It === void 0 || jt === void 0) && Ht(kt, this.length - 8);
    const Vt = It * 2 ** 24 + this[++kt] * 2 ** 16 + this[++kt] * 2 ** 8 + this[++kt], ar = this[++kt] * 2 ** 24 + this[++kt] * 2 ** 16 + this[++kt] * 2 ** 8 + jt;
    return (BigInt(Vt) << BigInt(32)) + BigInt(ar);
  }), Qe.prototype.readIntLE = function(kt, It, jt) {
    kt = kt >>> 0, It = It >>> 0, jt || ct(kt, It, this.length);
    let Vt = this[kt], ar = 1, Yt = 0;
    for (; ++Yt < It && (ar *= 256); )
      Vt += this[kt + Yt] * ar;
    return ar *= 128, Vt >= ar && (Vt -= Math.pow(2, 8 * It)), Vt;
  }, Qe.prototype.readIntBE = function(kt, It, jt) {
    kt = kt >>> 0, It = It >>> 0, jt || ct(kt, It, this.length);
    let Vt = It, ar = 1, Yt = this[kt + --Vt];
    for (; Vt > 0 && (ar *= 256); )
      Yt += this[kt + --Vt] * ar;
    return ar *= 128, Yt >= ar && (Yt -= Math.pow(2, 8 * It)), Yt;
  }, Qe.prototype.readInt8 = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 1, this.length), this[kt] & 128 ? (255 - this[kt] + 1) * -1 : this[kt];
  }, Qe.prototype.readInt16LE = function(kt, It) {
    kt = kt >>> 0, It || ct(kt, 2, this.length);
    const jt = this[kt] | this[kt + 1] << 8;
    return jt & 32768 ? jt | 4294901760 : jt;
  }, Qe.prototype.readInt16BE = function(kt, It) {
    kt = kt >>> 0, It || ct(kt, 2, this.length);
    const jt = this[kt + 1] | this[kt] << 8;
    return jt & 32768 ? jt | 4294901760 : jt;
  }, Qe.prototype.readInt32LE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 4, this.length), this[kt] | this[kt + 1] << 8 | this[kt + 2] << 16 | this[kt + 3] << 24;
  }, Qe.prototype.readInt32BE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 4, this.length), this[kt] << 24 | this[kt + 1] << 16 | this[kt + 2] << 8 | this[kt + 3];
  }, Qe.prototype.readBigInt64LE = gr(function(kt) {
    kt = kt >>> 0, Dt(kt, "offset");
    const It = this[kt], jt = this[kt + 7];
    (It === void 0 || jt === void 0) && Ht(kt, this.length - 8);
    const Vt = this[kt + 4] + this[kt + 5] * 2 ** 8 + this[kt + 6] * 2 ** 16 + (jt << 24);
    return (BigInt(Vt) << BigInt(32)) + BigInt(It + this[++kt] * 2 ** 8 + this[++kt] * 2 ** 16 + this[++kt] * 2 ** 24);
  }), Qe.prototype.readBigInt64BE = gr(function(kt) {
    kt = kt >>> 0, Dt(kt, "offset");
    const It = this[kt], jt = this[kt + 7];
    (It === void 0 || jt === void 0) && Ht(kt, this.length - 8);
    const Vt = (It << 24) + this[++kt] * 2 ** 16 + this[++kt] * 2 ** 8 + this[++kt];
    return (BigInt(Vt) << BigInt(32)) + BigInt(this[++kt] * 2 ** 24 + this[++kt] * 2 ** 16 + this[++kt] * 2 ** 8 + jt);
  }), Qe.prototype.readFloatLE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 4, this.length), Ze.read(this, kt, !0, 23, 4);
  }, Qe.prototype.readFloatBE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 4, this.length), Ze.read(this, kt, !1, 23, 4);
  }, Qe.prototype.readDoubleLE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 8, this.length), Ze.read(this, kt, !0, 52, 8);
  }, Qe.prototype.readDoubleBE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 8, this.length), Ze.read(this, kt, !1, 52, 8);
  };
  function Mt(Bt, kt, It, jt, Vt, ar) {
    if (!Qe.isBuffer(Bt))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (kt > Vt || kt < ar)
      throw new RangeError('"value" argument is out of bounds');
    if (It + jt > Bt.length)
      throw new RangeError("Index out of range");
  }
  Qe.prototype.writeUintLE = Qe.prototype.writeUIntLE = function(kt, It, jt, Vt) {
    if (kt = +kt, It = It >>> 0, jt = jt >>> 0, !Vt) {
      const hr = Math.pow(2, 8 * jt) - 1;
      Mt(this, kt, It, jt, hr, 0);
    }
    let ar = 1, Yt = 0;
    for (this[It] = kt & 255; ++Yt < jt && (ar *= 256); )
      this[It + Yt] = kt / ar & 255;
    return It + jt;
  }, Qe.prototype.writeUintBE = Qe.prototype.writeUIntBE = function(kt, It, jt, Vt) {
    if (kt = +kt, It = It >>> 0, jt = jt >>> 0, !Vt) {
      const hr = Math.pow(2, 8 * jt) - 1;
      Mt(this, kt, It, jt, hr, 0);
    }
    let ar = jt - 1, Yt = 1;
    for (this[It + ar] = kt & 255; --ar >= 0 && (Yt *= 256); )
      this[It + ar] = kt / Yt & 255;
    return It + jt;
  }, Qe.prototype.writeUint8 = Qe.prototype.writeUInt8 = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 1, 255, 0), this[It] = kt & 255, It + 1;
  }, Qe.prototype.writeUint16LE = Qe.prototype.writeUInt16LE = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 2, 65535, 0), this[It] = kt & 255, this[It + 1] = kt >>> 8, It + 2;
  }, Qe.prototype.writeUint16BE = Qe.prototype.writeUInt16BE = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 2, 65535, 0), this[It] = kt >>> 8, this[It + 1] = kt & 255, It + 2;
  }, Qe.prototype.writeUint32LE = Qe.prototype.writeUInt32LE = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 4, 4294967295, 0), this[It + 3] = kt >>> 24, this[It + 2] = kt >>> 16, this[It + 1] = kt >>> 8, this[It] = kt & 255, It + 4;
  }, Qe.prototype.writeUint32BE = Qe.prototype.writeUInt32BE = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 4, 4294967295, 0), this[It] = kt >>> 24, this[It + 1] = kt >>> 16, this[It + 2] = kt >>> 8, this[It + 3] = kt & 255, It + 4;
  };
  function St(Bt, kt, It, jt, Vt) {
    er(kt, jt, Vt, Bt, It, 7);
    let ar = Number(kt & BigInt(4294967295));
    Bt[It++] = ar, ar = ar >> 8, Bt[It++] = ar, ar = ar >> 8, Bt[It++] = ar, ar = ar >> 8, Bt[It++] = ar;
    let Yt = Number(kt >> BigInt(32) & BigInt(4294967295));
    return Bt[It++] = Yt, Yt = Yt >> 8, Bt[It++] = Yt, Yt = Yt >> 8, Bt[It++] = Yt, Yt = Yt >> 8, Bt[It++] = Yt, It;
  }
  function At(Bt, kt, It, jt, Vt) {
    er(kt, jt, Vt, Bt, It, 7);
    let ar = Number(kt & BigInt(4294967295));
    Bt[It + 7] = ar, ar = ar >> 8, Bt[It + 6] = ar, ar = ar >> 8, Bt[It + 5] = ar, ar = ar >> 8, Bt[It + 4] = ar;
    let Yt = Number(kt >> BigInt(32) & BigInt(4294967295));
    return Bt[It + 3] = Yt, Yt = Yt >> 8, Bt[It + 2] = Yt, Yt = Yt >> 8, Bt[It + 1] = Yt, Yt = Yt >> 8, Bt[It] = Yt, It + 8;
  }
  Qe.prototype.writeBigUInt64LE = gr(function(kt, It = 0) {
    return St(this, kt, It, BigInt(0), BigInt("0xffffffffffffffff"));
  }), Qe.prototype.writeBigUInt64BE = gr(function(kt, It = 0) {
    return At(this, kt, It, BigInt(0), BigInt("0xffffffffffffffff"));
  }), Qe.prototype.writeIntLE = function(kt, It, jt, Vt) {
    if (kt = +kt, It = It >>> 0, !Vt) {
      const zr = Math.pow(2, 8 * jt - 1);
      Mt(this, kt, It, jt, zr - 1, -zr);
    }
    let ar = 0, Yt = 1, hr = 0;
    for (this[It] = kt & 255; ++ar < jt && (Yt *= 256); )
      kt < 0 && hr === 0 && this[It + ar - 1] !== 0 && (hr = 1), this[It + ar] = (kt / Yt >> 0) - hr & 255;
    return It + jt;
  }, Qe.prototype.writeIntBE = function(kt, It, jt, Vt) {
    if (kt = +kt, It = It >>> 0, !Vt) {
      const zr = Math.pow(2, 8 * jt - 1);
      Mt(this, kt, It, jt, zr - 1, -zr);
    }
    let ar = jt - 1, Yt = 1, hr = 0;
    for (this[It + ar] = kt & 255; --ar >= 0 && (Yt *= 256); )
      kt < 0 && hr === 0 && this[It + ar + 1] !== 0 && (hr = 1), this[It + ar] = (kt / Yt >> 0) - hr & 255;
    return It + jt;
  }, Qe.prototype.writeInt8 = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 1, 127, -128), kt < 0 && (kt = 255 + kt + 1), this[It] = kt & 255, It + 1;
  }, Qe.prototype.writeInt16LE = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 2, 32767, -32768), this[It] = kt & 255, this[It + 1] = kt >>> 8, It + 2;
  }, Qe.prototype.writeInt16BE = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 2, 32767, -32768), this[It] = kt >>> 8, this[It + 1] = kt & 255, It + 2;
  }, Qe.prototype.writeInt32LE = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 4, 2147483647, -2147483648), this[It] = kt & 255, this[It + 1] = kt >>> 8, this[It + 2] = kt >>> 16, this[It + 3] = kt >>> 24, It + 4;
  }, Qe.prototype.writeInt32BE = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 4, 2147483647, -2147483648), kt < 0 && (kt = 4294967295 + kt + 1), this[It] = kt >>> 24, this[It + 1] = kt >>> 16, this[It + 2] = kt >>> 8, this[It + 3] = kt & 255, It + 4;
  }, Qe.prototype.writeBigInt64LE = gr(function(kt, It = 0) {
    return St(this, kt, It, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), Qe.prototype.writeBigInt64BE = gr(function(kt, It = 0) {
    return At(this, kt, It, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Nt(Bt, kt, It, jt, Vt, ar) {
    if (It + jt > Bt.length)
      throw new RangeError("Index out of range");
    if (It < 0)
      throw new RangeError("Index out of range");
  }
  function qt(Bt, kt, It, jt, Vt) {
    return kt = +kt, It = It >>> 0, Vt || Nt(Bt, kt, It, 4), Ze.write(Bt, kt, It, jt, 23, 4), It + 4;
  }
  Qe.prototype.writeFloatLE = function(kt, It, jt) {
    return qt(this, kt, It, !0, jt);
  }, Qe.prototype.writeFloatBE = function(kt, It, jt) {
    return qt(this, kt, It, !1, jt);
  };
  function Qt(Bt, kt, It, jt, Vt) {
    return kt = +kt, It = It >>> 0, Vt || Nt(Bt, kt, It, 8), Ze.write(Bt, kt, It, jt, 52, 8), It + 8;
  }
  Qe.prototype.writeDoubleLE = function(kt, It, jt) {
    return Qt(this, kt, It, !0, jt);
  }, Qe.prototype.writeDoubleBE = function(kt, It, jt) {
    return Qt(this, kt, It, !1, jt);
  }, Qe.prototype.copy = function(kt, It, jt, Vt) {
    if (!Qe.isBuffer(kt))
      throw new TypeError("argument should be a Buffer");
    if (jt || (jt = 0), !Vt && Vt !== 0 && (Vt = this.length), It >= kt.length && (It = kt.length), It || (It = 0), Vt > 0 && Vt < jt && (Vt = jt), Vt === jt || kt.length === 0 || this.length === 0)
      return 0;
    if (It < 0)
      throw new RangeError("targetStart out of bounds");
    if (jt < 0 || jt >= this.length)
      throw new RangeError("Index out of range");
    if (Vt < 0)
      throw new RangeError("sourceEnd out of bounds");
    Vt > this.length && (Vt = this.length), kt.length - It < Vt - jt && (Vt = kt.length - It + jt);
    const ar = Vt - jt;
    return this === kt && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(It, jt, Vt) : Uint8Array.prototype.set.call(kt, this.subarray(jt, Vt), It), ar;
  }, Qe.prototype.fill = function(kt, It, jt, Vt) {
    if (typeof kt == "string") {
      if (typeof It == "string" ? (Vt = It, It = 0, jt = this.length) : typeof jt == "string" && (Vt = jt, jt = this.length), Vt !== void 0 && typeof Vt != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Vt == "string" && !Qe.isEncoding(Vt))
        throw new TypeError("Unknown encoding: " + Vt);
      if (kt.length === 1) {
        const Yt = kt.charCodeAt(0);
        (Vt === "utf8" && Yt < 128 || Vt === "latin1") && (kt = Yt);
      }
    } else
      typeof kt == "number" ? kt = kt & 255 : typeof kt == "boolean" && (kt = Number(kt));
    if (It < 0 || this.length < It || this.length < jt)
      throw new RangeError("Out of range index");
    if (jt <= It)
      return this;
    It = It >>> 0, jt = jt === void 0 ? this.length : jt >>> 0, kt || (kt = 0);
    let ar;
    if (typeof kt == "number")
      for (ar = It; ar < jt; ++ar)
        this[ar] = kt;
    else {
      const Yt = Qe.isBuffer(kt) ? kt : Qe.from(kt, Vt), hr = Yt.length;
      if (hr === 0)
        throw new TypeError('The value "' + kt + '" is invalid for argument "value"');
      for (ar = 0; ar < jt - It; ++ar)
        this[ar + It] = Yt[ar % hr];
    }
    return this;
  };
  const Xt = {};
  function zt(Bt, kt, It) {
    Xt[Bt] = class extends It {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: kt.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Bt}]`, this.stack, delete this.name;
      }
      get code() {
        return Bt;
      }
      set code(Vt) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Vt,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Bt}]: ${this.message}`;
      }
    };
  }
  zt("ERR_BUFFER_OUT_OF_BOUNDS", function(Bt) {
    return Bt ? `${Bt} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), zt("ERR_INVALID_ARG_TYPE", function(Bt, kt) {
    return `The "${Bt}" argument must be of type number. Received type ${typeof kt}`;
  }, TypeError), zt("ERR_OUT_OF_RANGE", function(Bt, kt, It) {
    let jt = `The value of "${Bt}" is out of range.`, Vt = It;
    return Number.isInteger(It) && Math.abs(It) > 2 ** 32 ? Vt = Kt(String(It)) : typeof It == "bigint" && (Vt = String(It), (It > BigInt(2) ** BigInt(32) || It < -(BigInt(2) ** BigInt(32))) && (Vt = Kt(Vt)), Vt += "n"), jt += ` It must be ${kt}. Received ${Vt}`, jt;
  }, RangeError);
  function Kt(Bt) {
    let kt = "", It = Bt.length;
    const jt = Bt[0] === "-" ? 1 : 0;
    for (; It >= jt + 4; It -= 3)
      kt = `_${Bt.slice(It - 3, It)}${kt}`;
    return `${Bt.slice(0, It)}${kt}`;
  }
  function ur(Bt, kt, It) {
    Dt(kt, "offset"), (Bt[kt] === void 0 || Bt[kt + It] === void 0) && Ht(kt, Bt.length - (It + 1));
  }
  function er(Bt, kt, It, jt, Vt, ar) {
    if (Bt > It || Bt < kt) {
      const Yt = typeof kt == "bigint" ? "n" : "";
      let hr;
      throw ar > 3 ? kt === 0 || kt === BigInt(0) ? hr = `>= 0${Yt} and < 2${Yt} ** ${(ar + 1) * 8}${Yt}` : hr = `>= -(2${Yt} ** ${(ar + 1) * 8 - 1}${Yt}) and < 2 ** ${(ar + 1) * 8 - 1}${Yt}` : hr = `>= ${kt}${Yt} and <= ${It}${Yt}`, new Xt.ERR_OUT_OF_RANGE("value", hr, Bt);
    }
    ur(jt, Vt, ar);
  }
  function Dt(Bt, kt) {
    if (typeof Bt != "number")
      throw new Xt.ERR_INVALID_ARG_TYPE(kt, "number", Bt);
  }
  function Ht(Bt, kt, It) {
    throw Math.floor(Bt) !== Bt ? (Dt(Bt, It), new Xt.ERR_OUT_OF_RANGE(It || "offset", "an integer", Bt)) : kt < 0 ? new Xt.ERR_BUFFER_OUT_OF_BOUNDS() : new Xt.ERR_OUT_OF_RANGE(It || "offset", `>= ${It ? 1 : 0} and <= ${kt}`, Bt);
  }
  const Gt = /[^+/0-9A-Za-z-_]/g;
  function rr(Bt) {
    if (Bt = Bt.split("=")[0], Bt = Bt.trim().replace(Gt, ""), Bt.length < 2)
      return "";
    for (; Bt.length % 4 !== 0; )
      Bt = Bt + "=";
    return Bt;
  }
  function sr(Bt, kt) {
    kt = kt || 1 / 0;
    let It;
    const jt = Bt.length;
    let Vt = null;
    const ar = [];
    for (let Yt = 0; Yt < jt; ++Yt) {
      if (It = Bt.charCodeAt(Yt), It > 55295 && It < 57344) {
        if (!Vt) {
          if (It > 56319) {
            (kt -= 3) > -1 && ar.push(239, 191, 189);
            continue;
          } else if (Yt + 1 === jt) {
            (kt -= 3) > -1 && ar.push(239, 191, 189);
            continue;
          }
          Vt = It;
          continue;
        }
        if (It < 56320) {
          (kt -= 3) > -1 && ar.push(239, 191, 189), Vt = It;
          continue;
        }
        It = (Vt - 55296 << 10 | It - 56320) + 65536;
      } else
        Vt && (kt -= 3) > -1 && ar.push(239, 191, 189);
      if (Vt = null, It < 128) {
        if ((kt -= 1) < 0)
          break;
        ar.push(It);
      } else if (It < 2048) {
        if ((kt -= 2) < 0)
          break;
        ar.push(It >> 6 | 192, It & 63 | 128);
      } else if (It < 65536) {
        if ((kt -= 3) < 0)
          break;
        ar.push(It >> 12 | 224, It >> 6 & 63 | 128, It & 63 | 128);
      } else if (It < 1114112) {
        if ((kt -= 4) < 0)
          break;
        ar.push(It >> 18 | 240, It >> 12 & 63 | 128, It >> 6 & 63 | 128, It & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return ar;
  }
  function Jt(Bt) {
    const kt = [];
    for (let It = 0; It < Bt.length; ++It)
      kt.push(Bt.charCodeAt(It) & 255);
    return kt;
  }
  function ir(Bt, kt) {
    let It, jt, Vt;
    const ar = [];
    for (let Yt = 0; Yt < Bt.length && !((kt -= 2) < 0); ++Yt)
      It = Bt.charCodeAt(Yt), jt = It >> 8, Vt = It % 256, ar.push(Vt), ar.push(jt);
    return ar;
  }
  function Br(Bt) {
    return $e.toByteArray(rr(Bt));
  }
  function or(Bt, kt, It, jt) {
    let Vt;
    for (Vt = 0; Vt < jt && !(Vt + It >= kt.length || Vt >= Bt.length); ++Vt)
      kt[Vt + It] = Bt[Vt];
    return Vt;
  }
  function lr(Bt, kt) {
    return Bt instanceof kt || Bt != null && Bt.constructor != null && Bt.constructor.name != null && Bt.constructor.name === kt.name;
  }
  function Nr(Bt) {
    return Bt !== Bt;
  }
  const dr = function() {
    const Bt = "0123456789abcdef", kt = new Array(256);
    for (let It = 0; It < 16; ++It) {
      const jt = It * 16;
      for (let Vt = 0; Vt < 16; ++Vt)
        kt[jt + Vt] = Bt[It] + Bt[Vt];
    }
    return kt;
  }();
  function gr(Bt) {
    return typeof BigInt > "u" ? Zr : Bt;
  }
  function Zr() {
    throw new Error("BigInt not supported");
  }
  return exports$1;
}
var exports$3, _dewExec$2, exports$2, _dewExec$1, exports$1, _dewExec, exports, Buffer2, init_buffer = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/buffer.js"() {
    init_dirname(), init_buffer2(), init_process2(), exports$3 = {}, _dewExec$2 = !1, exports$2 = {}, _dewExec$1 = !1, exports$1 = {}, _dewExec = !1, exports = dew(), exports.Buffer, exports.SlowBuffer, exports.INSPECT_MAX_BYTES, exports.kMaxLength, Buffer2 = exports.Buffer, exports.INSPECT_MAX_BYTES, exports.kMaxLength;
  }
}), init_buffer2 = __esm({
  "../../node_modules/.pnpm/esbuild-plugin-polyfill-node@0.3.0_esbuild@0.16.12/node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js"() {
    init_buffer();
  }
}), require_lib = __commonJS({
  "../../node_modules/.pnpm/browser-or-node@2.1.1/node_modules/browser-or-node/lib/index.js"($e) {
    init_dirname(), init_buffer2(), init_process2(), Object.defineProperty($e, "__esModule", {
      value: !0
    });
    var Ze = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(at) {
      return typeof at;
    } : function(at) {
      return at && typeof Symbol == "function" && at.constructor === Symbol && at !== Symbol.prototype ? "symbol" : typeof at;
    }, Fe = typeof window < "u" && typeof window.document < "u", Ke = typeof process_exports < "u" && process_exports.versions != null && process_exports.versions.node != null, Ve = (typeof self > "u" ? "undefined" : Ze(self)) === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope", Je = typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom")), Qe = typeof Deno < "u" && typeof Deno.version < "u" && typeof Deno.version.deno < "u";
    $e.isBrowser = Fe, $e.isWebWorker = Ve, $e.isNode = Ke, $e.isJsDom = Je, $e.isDeno = Qe;
  }
}), require_browser = __commonJS({
  "../../node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/browser.js"($e, Ze) {
    init_dirname(), init_buffer2(), init_process2(), Ze.exports = typeof self == "object" ? self.FormData : window.FormData;
  }
});
function o() {
  o.init.call(this);
}
function u($e) {
  if (typeof $e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof $e);
}
function f$2($e) {
  return $e._maxListeners === void 0 ? o.defaultMaxListeners : $e._maxListeners;
}
function v($e, Ze, Fe, Ke) {
  var Ve, Je, Qe, at;
  if (u(Fe), (Je = $e._events) === void 0 ? (Je = $e._events = /* @__PURE__ */ Object.create(null), $e._eventsCount = 0) : (Je.newListener !== void 0 && ($e.emit("newListener", Ze, Fe.listener ? Fe.listener : Fe), Je = $e._events), Qe = Je[Ze]), Qe === void 0)
    Qe = Je[Ze] = Fe, ++$e._eventsCount;
  else if (typeof Qe == "function" ? Qe = Je[Ze] = Ke ? [Fe, Qe] : [Qe, Fe] : Ke ? Qe.unshift(Fe) : Qe.push(Fe), (Ve = f$2($e)) > 0 && Qe.length > Ve && !Qe.warned) {
    Qe.warned = !0;
    var ut = new Error("Possible EventEmitter memory leak detected. " + Qe.length + " " + String(Ze) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    ut.name = "MaxListenersExceededWarning", ut.emitter = $e, ut.type = Ze, ut.count = Qe.length, at = ut, console && console.warn && console.warn(at);
  }
  return $e;
}
function a$1() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function l($e, Ze, Fe) {
  var Ke = { fired: !1, wrapFn: void 0, target: $e, type: Ze, listener: Fe }, Ve = a$1.bind(Ke);
  return Ve.listener = Fe, Ke.wrapFn = Ve, Ve;
}
function h($e, Ze, Fe) {
  var Ke = $e._events;
  if (Ke === void 0)
    return [];
  var Ve = Ke[Ze];
  return Ve === void 0 ? [] : typeof Ve == "function" ? Fe ? [Ve.listener || Ve] : [Ve] : Fe ? function(Je) {
    for (var Qe = new Array(Je.length), at = 0; at < Qe.length; ++at)
      Qe[at] = Je[at].listener || Je[at];
    return Qe;
  }(Ve) : c$1(Ve, Ve.length);
}
function p$2($e) {
  var Ze = this._events;
  if (Ze !== void 0) {
    var Fe = Ze[$e];
    if (typeof Fe == "function")
      return 1;
    if (Fe !== void 0)
      return Fe.length;
  }
  return 0;
}
function c$1($e, Ze) {
  for (var Fe = new Array(Ze), Ke = 0; Ke < Ze; ++Ke)
    Fe[Ke] = $e[Ke];
  return Fe;
}
var e$2, t$1, n$2, r$2, i$1, s, y, init_chunk_4bd36a8f = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-4bd36a8f.js"() {
    init_dirname(), init_buffer2(), init_process2(), n$2 = typeof Reflect == "object" ? Reflect : null, r$2 = n$2 && typeof n$2.apply == "function" ? n$2.apply : function($e, Ze, Fe) {
      return Function.prototype.apply.call($e, Ze, Fe);
    }, t$1 = n$2 && typeof n$2.ownKeys == "function" ? n$2.ownKeys : Object.getOwnPropertySymbols ? function($e) {
      return Object.getOwnPropertyNames($e).concat(Object.getOwnPropertySymbols($e));
    } : function($e) {
      return Object.getOwnPropertyNames($e);
    }, i$1 = Number.isNaN || function($e) {
      return $e != $e;
    }, e$2 = o, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0, s = 10, Object.defineProperty(o, "defaultMaxListeners", { enumerable: !0, get: function() {
      return s;
    }, set: function($e) {
      if (typeof $e != "number" || $e < 0 || i$1($e))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + $e + ".");
      s = $e;
    } }), o.init = function() {
      this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    }, o.prototype.setMaxListeners = function($e) {
      if (typeof $e != "number" || $e < 0 || i$1($e))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + $e + ".");
      return this._maxListeners = $e, this;
    }, o.prototype.getMaxListeners = function() {
      return f$2(this);
    }, o.prototype.emit = function($e) {
      for (var Ze = [], Fe = 1; Fe < arguments.length; Fe++)
        Ze.push(arguments[Fe]);
      var Ke = $e === "error", Ve = this._events;
      if (Ve !== void 0)
        Ke = Ke && Ve.error === void 0;
      else if (!Ke)
        return !1;
      if (Ke) {
        var Je;
        if (Ze.length > 0 && (Je = Ze[0]), Je instanceof Error)
          throw Je;
        var Qe = new Error("Unhandled error." + (Je ? " (" + Je.message + ")" : ""));
        throw Qe.context = Je, Qe;
      }
      var at = Ve[$e];
      if (at === void 0)
        return !1;
      if (typeof at == "function")
        r$2(at, this, Ze);
      else {
        var ut = at.length, lt = c$1(at, ut);
        for (Fe = 0; Fe < ut; ++Fe)
          r$2(lt[Fe], this, Ze);
      }
      return !0;
    }, o.prototype.addListener = function($e, Ze) {
      return v(this, $e, Ze, !1);
    }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function($e, Ze) {
      return v(this, $e, Ze, !0);
    }, o.prototype.once = function($e, Ze) {
      return u(Ze), this.on($e, l(this, $e, Ze)), this;
    }, o.prototype.prependOnceListener = function($e, Ze) {
      return u(Ze), this.prependListener($e, l(this, $e, Ze)), this;
    }, o.prototype.removeListener = function($e, Ze) {
      var Fe, Ke, Ve, Je, Qe;
      if (u(Ze), (Ke = this._events) === void 0)
        return this;
      if ((Fe = Ke[$e]) === void 0)
        return this;
      if (Fe === Ze || Fe.listener === Ze)
        --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete Ke[$e], Ke.removeListener && this.emit("removeListener", $e, Fe.listener || Ze));
      else if (typeof Fe != "function") {
        for (Ve = -1, Je = Fe.length - 1; Je >= 0; Je--)
          if (Fe[Je] === Ze || Fe[Je].listener === Ze) {
            Qe = Fe[Je].listener, Ve = Je;
            break;
          }
        if (Ve < 0)
          return this;
        Ve === 0 ? Fe.shift() : function(at, ut) {
          for (; ut + 1 < at.length; ut++)
            at[ut] = at[ut + 1];
          at.pop();
        }(Fe, Ve), Fe.length === 1 && (Ke[$e] = Fe[0]), Ke.removeListener !== void 0 && this.emit("removeListener", $e, Qe || Ze);
      }
      return this;
    }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function($e) {
      var Ze, Fe, Ke;
      if ((Fe = this._events) === void 0)
        return this;
      if (Fe.removeListener === void 0)
        return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Fe[$e] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Fe[$e]), this;
      if (arguments.length === 0) {
        var Ve, Je = Object.keys(Fe);
        for (Ke = 0; Ke < Je.length; ++Ke)
          (Ve = Je[Ke]) !== "removeListener" && this.removeAllListeners(Ve);
        return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
      }
      if (typeof (Ze = Fe[$e]) == "function")
        this.removeListener($e, Ze);
      else if (Ze !== void 0)
        for (Ke = Ze.length - 1; Ke >= 0; Ke--)
          this.removeListener($e, Ze[Ke]);
      return this;
    }, o.prototype.listeners = function($e) {
      return h(this, $e, !0);
    }, o.prototype.rawListeners = function($e) {
      return h(this, $e, !1);
    }, o.listenerCount = function($e, Ze) {
      return typeof $e.listenerCount == "function" ? $e.listenerCount(Ze) : p$2.call($e, Ze);
    }, o.prototype.listenerCount = p$2, o.prototype.eventNames = function() {
      return this._eventsCount > 0 ? t$1(this._events) : [];
    }, y = e$2, y.EventEmitter, y.defaultMaxListeners, y.init, y.listenerCount, y.EventEmitter, y.defaultMaxListeners, y.init, y.listenerCount;
  }
});
function i2() {
  throw new Error("setTimeout has not been defined");
}
function u2() {
  throw new Error("clearTimeout has not been defined");
}
function c2$2($e) {
  if (t2 === setTimeout)
    return setTimeout($e, 0);
  if ((t2 === i2 || !t2) && setTimeout)
    return t2 = setTimeout, setTimeout($e, 0);
  try {
    return t2($e, 0);
  } catch {
    try {
      return t2.call(null, $e, 0);
    } catch {
      return t2.call(this || r2, $e, 0);
    }
  }
}
function h2() {
  f2 && l2 && (f2 = !1, l2.length ? s2 = l2.concat(s2) : a2 = -1, s2.length && d());
}
function d() {
  if (!f2) {
    var $e = c2$2(h2);
    f2 = !0;
    for (var Ze = s2.length; Ze; ) {
      for (l2 = s2, s2 = []; ++a2 < Ze; )
        l2 && l2[a2].run();
      a2 = -1, Ze = s2.length;
    }
    l2 = null, f2 = !1, function(Fe) {
      if (n2 === clearTimeout)
        return clearTimeout(Fe);
      if ((n2 === u2 || !n2) && clearTimeout)
        return n2 = clearTimeout, clearTimeout(Fe);
      try {
        n2(Fe);
      } catch {
        try {
          return n2.call(null, Fe);
        } catch {
          return n2.call(this || r2, Fe);
        }
      }
    }($e);
  }
}
function m($e, Ze) {
  (this || r2).fun = $e, (this || r2).array = Ze;
}
function p2() {
}
var e2, t2, n2, r2, o2, l2, s2, f2, a2, T, init_chunk_5decc758 = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-5decc758.js"() {
    init_dirname(), init_buffer2(), init_process2(), r2 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, o2 = e2 = {}, function() {
      try {
        t2 = typeof setTimeout == "function" ? setTimeout : i2;
      } catch {
        t2 = i2;
      }
      try {
        n2 = typeof clearTimeout == "function" ? clearTimeout : u2;
      } catch {
        n2 = u2;
      }
    }(), s2 = [], f2 = !1, a2 = -1, o2.nextTick = function($e) {
      var Ze = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var Fe = 1; Fe < arguments.length; Fe++)
          Ze[Fe - 1] = arguments[Fe];
      s2.push(new m($e, Ze)), s2.length !== 1 || f2 || c2$2(d);
    }, m.prototype.run = function() {
      (this || r2).fun.apply(null, (this || r2).array);
    }, o2.title = "browser", o2.browser = !0, o2.env = {}, o2.argv = [], o2.version = "", o2.versions = {}, o2.on = p2, o2.addListener = p2, o2.once = p2, o2.off = p2, o2.removeListener = p2, o2.removeAllListeners = p2, o2.emit = p2, o2.prependListener = p2, o2.prependOnceListener = p2, o2.listeners = function($e) {
      return [];
    }, o2.binding = function($e) {
      throw new Error("process.binding is not supported");
    }, o2.cwd = function() {
      return "/";
    }, o2.chdir = function($e) {
      throw new Error("process.chdir is not supported");
    }, o2.umask = function() {
      return 0;
    }, T = e2, T.addListener, T.argv, T.binding, T.browser, T.chdir, T.cwd, T.emit, T.env, T.listeners, T.nextTick, T.off, T.on, T.once, T.prependListener, T.prependOnceListener, T.removeAllListeners, T.removeListener, T.title, T.umask, T.version, T.versions;
  }
});
function c$1$1($e) {
  return $e.call.bind($e);
}
function O($e, Ze) {
  if (typeof $e != "object")
    return !1;
  try {
    return Ze($e), !0;
  } catch {
    return !1;
  }
}
function S($e) {
  return l$1 && y2 ? b($e) !== void 0 : B($e) || k$2($e) || E($e) || D($e) || U($e) || P($e) || x($e) || I($e) || M$1($e) || z($e) || F($e);
}
function B($e) {
  return l$1 && y2 ? b($e) === "Uint8Array" : m2($e) === "[object Uint8Array]" || u$1($e) && $e.buffer !== void 0;
}
function k$2($e) {
  return l$1 && y2 ? b($e) === "Uint8ClampedArray" : m2($e) === "[object Uint8ClampedArray]";
}
function E($e) {
  return l$1 && y2 ? b($e) === "Uint16Array" : m2($e) === "[object Uint16Array]";
}
function D($e) {
  return l$1 && y2 ? b($e) === "Uint32Array" : m2($e) === "[object Uint32Array]";
}
function U($e) {
  return l$1 && y2 ? b($e) === "Int8Array" : m2($e) === "[object Int8Array]";
}
function P($e) {
  return l$1 && y2 ? b($e) === "Int16Array" : m2($e) === "[object Int16Array]";
}
function x($e) {
  return l$1 && y2 ? b($e) === "Int32Array" : m2($e) === "[object Int32Array]";
}
function I($e) {
  return l$1 && y2 ? b($e) === "Float32Array" : m2($e) === "[object Float32Array]";
}
function M$1($e) {
  return l$1 && y2 ? b($e) === "Float64Array" : m2($e) === "[object Float64Array]";
}
function z($e) {
  return l$1 && y2 ? b($e) === "BigInt64Array" : m2($e) === "[object BigInt64Array]";
}
function F($e) {
  return l$1 && y2 ? b($e) === "BigUint64Array" : m2($e) === "[object BigUint64Array]";
}
function T2($e) {
  return m2($e) === "[object Map]";
}
function N($e) {
  return m2($e) === "[object Set]";
}
function W($e) {
  return m2($e) === "[object WeakMap]";
}
function $($e) {
  return m2($e) === "[object WeakSet]";
}
function C($e) {
  return m2($e) === "[object ArrayBuffer]";
}
function V($e) {
  return typeof ArrayBuffer < "u" && (C.working ? C($e) : $e instanceof ArrayBuffer);
}
function G($e) {
  return m2($e) === "[object DataView]";
}
function R($e) {
  return typeof DataView < "u" && (G.working ? G($e) : $e instanceof DataView);
}
function J($e) {
  return m2($e) === "[object SharedArrayBuffer]";
}
function _($e) {
  return typeof SharedArrayBuffer < "u" && (J.working ? J($e) : $e instanceof SharedArrayBuffer);
}
function H($e) {
  return O($e, h3);
}
function Z($e) {
  return O($e, j);
}
function q($e) {
  return O($e, A);
}
function K($e) {
  return s3 && O($e, w);
}
function L($e) {
  return p3 && O($e, v2);
}
function oe($e, Ze) {
  var Fe = { seen: [], stylize: fe };
  return arguments.length >= 3 && (Fe.depth = arguments[2]), arguments.length >= 4 && (Fe.colors = arguments[3]), ye(Ze) ? Fe.showHidden = Ze : Ze && X._extend(Fe, Ze), be(Fe.showHidden) && (Fe.showHidden = !1), be(Fe.depth) && (Fe.depth = 2), be(Fe.colors) && (Fe.colors = !1), be(Fe.customInspect) && (Fe.customInspect = !0), Fe.colors && (Fe.stylize = ue), ae(Fe, $e, Fe.depth);
}
function ue($e, Ze) {
  var Fe = oe.styles[Ze];
  return Fe ? "\x1B[" + oe.colors[Fe][0] + "m" + $e + "\x1B[" + oe.colors[Fe][1] + "m" : $e;
}
function fe($e, Ze) {
  return $e;
}
function ae($e, Ze, Fe) {
  if ($e.customInspect && Ze && we(Ze.inspect) && Ze.inspect !== X.inspect && (!Ze.constructor || Ze.constructor.prototype !== Ze)) {
    var Ke = Ze.inspect(Fe, $e);
    return ge(Ke) || (Ke = ae($e, Ke, Fe)), Ke;
  }
  var Ve = function($t, vt) {
    if (be(vt))
      return $t.stylize("undefined", "undefined");
    if (ge(vt)) {
      var wt = "'" + JSON.stringify(vt).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return $t.stylize(wt, "string");
    }
    if (de(vt))
      return $t.stylize("" + vt, "number");
    if (ye(vt))
      return $t.stylize("" + vt, "boolean");
    if (le(vt))
      return $t.stylize("null", "null");
  }($e, Ze);
  if (Ve)
    return Ve;
  var Je = Object.keys(Ze), Qe = function($t) {
    var vt = {};
    return $t.forEach(function(wt, xt) {
      vt[wt] = !0;
    }), vt;
  }(Je);
  if ($e.showHidden && (Je = Object.getOwnPropertyNames(Ze)), Ae(Ze) && (Je.indexOf("message") >= 0 || Je.indexOf("description") >= 0))
    return ce(Ze);
  if (Je.length === 0) {
    if (we(Ze)) {
      var at = Ze.name ? ": " + Ze.name : "";
      return $e.stylize("[Function" + at + "]", "special");
    }
    if (me(Ze))
      return $e.stylize(RegExp.prototype.toString.call(Ze), "regexp");
    if (je(Ze))
      return $e.stylize(Date.prototype.toString.call(Ze), "date");
    if (Ae(Ze))
      return ce(Ze);
  }
  var ut, lt = "", dt = !1, bt = ["{", "}"];
  return pe(Ze) && (dt = !0, bt = ["[", "]"]), we(Ze) && (lt = " [Function" + (Ze.name ? ": " + Ze.name : "") + "]"), me(Ze) && (lt = " " + RegExp.prototype.toString.call(Ze)), je(Ze) && (lt = " " + Date.prototype.toUTCString.call(Ze)), Ae(Ze) && (lt = " " + ce(Ze)), Je.length !== 0 || dt && Ze.length != 0 ? Fe < 0 ? me(Ze) ? $e.stylize(RegExp.prototype.toString.call(Ze), "regexp") : $e.stylize("[Object]", "special") : ($e.seen.push(Ze), ut = dt ? function($t, vt, wt, xt, Et) {
    for (var Tt = [], Rt = 0, Ct = vt.length; Rt < Ct; ++Rt)
      ke(vt, String(Rt)) ? Tt.push(se($t, vt, wt, xt, String(Rt), !0)) : Tt.push("");
    return Et.forEach(function(Zt) {
      Zt.match(/^\d+$/) || Tt.push(se($t, vt, wt, xt, Zt, !0));
    }), Tt;
  }($e, Ze, Fe, Qe, Je) : Je.map(function($t) {
    return se($e, Ze, Fe, Qe, $t, dt);
  }), $e.seen.pop(), function($t, vt, wt) {
    var xt = 0;
    return $t.reduce(function(Et, Tt) {
      return xt++, Tt.indexOf(`
`) >= 0 && xt++, Et + Tt.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0) > 60 ? wt[0] + (vt === "" ? "" : vt + `
 `) + " " + $t.join(`,
  `) + " " + wt[1] : wt[0] + vt + " " + $t.join(", ") + " " + wt[1];
  }(ut, lt, bt)) : bt[0] + lt + bt[1];
}
function ce($e) {
  return "[" + Error.prototype.toString.call($e) + "]";
}
function se($e, Ze, Fe, Ke, Ve, Je) {
  var Qe, at, ut;
  if ((ut = Object.getOwnPropertyDescriptor(Ze, Ve) || { value: Ze[Ve] }).get ? at = ut.set ? $e.stylize("[Getter/Setter]", "special") : $e.stylize("[Getter]", "special") : ut.set && (at = $e.stylize("[Setter]", "special")), ke(Ke, Ve) || (Qe = "[" + Ve + "]"), at || ($e.seen.indexOf(ut.value) < 0 ? (at = le(Fe) ? ae($e, ut.value, null) : ae($e, ut.value, Fe - 1)).indexOf(`
`) > -1 && (at = Je ? at.split(`
`).map(function(lt) {
    return "  " + lt;
  }).join(`
`).substr(2) : `
` + at.split(`
`).map(function(lt) {
    return "   " + lt;
  }).join(`
`)) : at = $e.stylize("[Circular]", "special")), be(Qe)) {
    if (Je && Ve.match(/^\d+$/))
      return at;
    (Qe = JSON.stringify("" + Ve)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Qe = Qe.substr(1, Qe.length - 2), Qe = $e.stylize(Qe, "name")) : (Qe = Qe.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Qe = $e.stylize(Qe, "string"));
  }
  return Qe + ": " + at;
}
function pe($e) {
  return Array.isArray($e);
}
function ye($e) {
  return typeof $e == "boolean";
}
function le($e) {
  return $e === null;
}
function de($e) {
  return typeof $e == "number";
}
function ge($e) {
  return typeof $e == "string";
}
function be($e) {
  return $e === void 0;
}
function me($e) {
  return he($e) && ve($e) === "[object RegExp]";
}
function he($e) {
  return typeof $e == "object" && $e !== null;
}
function je($e) {
  return he($e) && ve($e) === "[object Date]";
}
function Ae($e) {
  return he($e) && (ve($e) === "[object Error]" || $e instanceof Error);
}
function we($e) {
  return typeof $e == "function";
}
function ve($e) {
  return Object.prototype.toString.call($e);
}
function Oe($e) {
  return $e < 10 ? "0" + $e.toString(10) : $e.toString(10);
}
function Be() {
  var $e = /* @__PURE__ */ new Date(), Ze = [Oe($e.getHours()), Oe($e.getMinutes()), Oe($e.getSeconds())].join(":");
  return [$e.getDate(), Se[$e.getMonth()], Ze].join(" ");
}
function ke($e, Ze) {
  return Object.prototype.hasOwnProperty.call($e, Ze);
}
function De($e, Ze) {
  if (!$e) {
    var Fe = new Error("Promise was rejected with a falsy value");
    Fe.reason = $e, $e = Fe;
  }
  return Ze($e);
}
var t3, e3, o3, n3, r3, l3, t$1$1, o$1, n$1$1, e$1$1, r$1$1, c3$2, u3, i3, t$2, i$1$1, o$2, u$1, f3, a3, s3, p3, y2, l$1, d2, m2, h3, j, A, Q, X, Y, ee, te, re, ne, ie2, Se, Ee, init_chunk_b4205b57 = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-b4205b57.js"() {
    if (init_dirname(), init_buffer2(), init_process2(), init_chunk_5decc758(), t3 = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol", e3 = Object.prototype.toString, o3 = function(Ve) {
      return !(t3 && Ve && typeof Ve == "object" && Symbol.toStringTag in Ve) && e3.call(Ve) === "[object Arguments]";
    }, n3 = function(Ve) {
      return !!o3(Ve) || Ve !== null && typeof Ve == "object" && typeof Ve.length == "number" && Ve.length >= 0 && e3.call(Ve) !== "[object Array]" && e3.call(Ve.callee) === "[object Function]";
    }, r3 = function() {
      return o3(arguments);
    }(), o3.isLegacyArguments = n3, l3 = r3 ? o3 : n3, t$1$1 = Object.prototype.toString, o$1 = Function.prototype.toString, n$1$1 = /^\s*(?:function)?\*/, e$1$1 = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol", r$1$1 = Object.getPrototypeOf, c3$2 = function() {
      if (!e$1$1)
        return !1;
      try {
        return Function("return function*() {}")();
      } catch {
      }
    }(), u3 = c3$2 ? r$1$1(c3$2) : {}, i3 = function(Ve) {
      return typeof Ve == "function" && (!!n$1$1.test(o$1.call(Ve)) || (e$1$1 ? r$1$1(Ve) === u3 : t$1$1.call(Ve) === "[object GeneratorFunction]"));
    }, t$2 = typeof Object.create == "function" ? function(Ve, Je) {
      Je && (Ve.super_ = Je, Ve.prototype = Object.create(Je.prototype, { constructor: { value: Ve, enumerable: !1, writable: !0, configurable: !0 } }));
    } : function(Ve, Je) {
      if (Je) {
        Ve.super_ = Je;
        var Qe = function() {
        };
        Qe.prototype = Je.prototype, Ve.prototype = new Qe(), Ve.prototype.constructor = Ve;
      }
    }, i$1$1 = function(Ve) {
      return Ve && typeof Ve == "object" && typeof Ve.copy == "function" && typeof Ve.fill == "function" && typeof Ve.readUInt8 == "function";
    }, o$2 = {}, u$1 = i$1$1, f3 = l3, a3 = i3, s3 = typeof BigInt < "u", p3 = typeof Symbol < "u", y2 = p3 && Symbol.toStringTag !== void 0, l$1 = typeof Uint8Array < "u", d2 = typeof ArrayBuffer < "u", l$1 && y2)
      var $e = Object.getPrototypeOf(Uint8Array.prototype), Ze = c$1$1(Object.getOwnPropertyDescriptor($e, Symbol.toStringTag).get);
    if (m2 = c$1$1(Object.prototype.toString), h3 = c$1$1(Number.prototype.valueOf), j = c$1$1(String.prototype.valueOf), A = c$1$1(Boolean.prototype.valueOf), s3)
      var Fe = c$1$1(BigInt.prototype.valueOf);
    if (p3)
      var Ke = c$1$1(Symbol.prototype.valueOf);
    o$2.isArgumentsObject = f3, o$2.isGeneratorFunction = a3, o$2.isPromise = function(Ve) {
      return typeof Promise < "u" && Ve instanceof Promise || Ve !== null && typeof Ve == "object" && typeof Ve.then == "function" && typeof Ve.catch == "function";
    }, o$2.isArrayBufferView = function(Ve) {
      return d2 && ArrayBuffer.isView ? ArrayBuffer.isView(Ve) : S(Ve) || R(Ve);
    }, o$2.isTypedArray = S, o$2.isUint8Array = B, o$2.isUint8ClampedArray = k$2, o$2.isUint16Array = E, o$2.isUint32Array = D, o$2.isInt8Array = U, o$2.isInt16Array = P, o$2.isInt32Array = x, o$2.isFloat32Array = I, o$2.isFloat64Array = M$1, o$2.isBigInt64Array = z, o$2.isBigUint64Array = F, T2.working = typeof Map < "u" && T2(/* @__PURE__ */ new Map()), o$2.isMap = function(Ve) {
      return typeof Map < "u" && (T2.working ? T2(Ve) : Ve instanceof Map);
    }, N.working = typeof Set < "u" && N(/* @__PURE__ */ new Set()), o$2.isSet = function(Ve) {
      return typeof Set < "u" && (N.working ? N(Ve) : Ve instanceof Set);
    }, W.working = typeof WeakMap < "u" && W(/* @__PURE__ */ new WeakMap()), o$2.isWeakMap = function(Ve) {
      return typeof WeakMap < "u" && (W.working ? W(Ve) : Ve instanceof WeakMap);
    }, $.working = typeof WeakSet < "u" && $(/* @__PURE__ */ new WeakSet()), o$2.isWeakSet = function(Ve) {
      return $(Ve);
    }, C.working = typeof ArrayBuffer < "u" && C(new ArrayBuffer()), o$2.isArrayBuffer = V, G.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && G(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R, J.working = typeof SharedArrayBuffer < "u" && J(new SharedArrayBuffer()), o$2.isSharedArrayBuffer = _, o$2.isAsyncFunction = function(Ve) {
      return m2(Ve) === "[object AsyncFunction]";
    }, o$2.isMapIterator = function(Ve) {
      return m2(Ve) === "[object Map Iterator]";
    }, o$2.isSetIterator = function(Ve) {
      return m2(Ve) === "[object Set Iterator]";
    }, o$2.isGeneratorObject = function(Ve) {
      return m2(Ve) === "[object Generator]";
    }, o$2.isWebAssemblyCompiledModule = function(Ve) {
      return m2(Ve) === "[object WebAssembly.Module]";
    }, o$2.isNumberObject = H, o$2.isStringObject = Z, o$2.isBooleanObject = q, o$2.isBigIntObject = K, o$2.isSymbolObject = L, o$2.isBoxedPrimitive = function(Ve) {
      return H(Ve) || Z(Ve) || q(Ve) || K(Ve) || L(Ve);
    }, o$2.isAnyArrayBuffer = function(Ve) {
      return l$1 && (V(Ve) || _(Ve));
    }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Ve) {
      Object.defineProperty(o$2, Ve, { enumerable: !1, value: function() {
        throw new Error(Ve + " is not supported in userland");
      } });
    }), Q = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, X = {}, Y = T, ee = Object.getOwnPropertyDescriptors || function(Ve) {
      for (var Je = Object.keys(Ve), Qe = {}, at = 0; at < Je.length; at++)
        Qe[Je[at]] = Object.getOwnPropertyDescriptor(Ve, Je[at]);
      return Qe;
    }, te = /%[sdj%]/g, X.format = function(Ve) {
      if (!ge(Ve)) {
        for (var Je = [], Qe = 0; Qe < arguments.length; Qe++)
          Je.push(oe(arguments[Qe]));
        return Je.join(" ");
      }
      Qe = 1;
      for (var at = arguments, ut = at.length, lt = String(Ve).replace(te, function(bt) {
        if (bt === "%%")
          return "%";
        if (Qe >= ut)
          return bt;
        switch (bt) {
          case "%s":
            return String(at[Qe++]);
          case "%d":
            return Number(at[Qe++]);
          case "%j":
            try {
              return JSON.stringify(at[Qe++]);
            } catch {
              return "[Circular]";
            }
          default:
            return bt;
        }
      }), dt = at[Qe]; Qe < ut; dt = at[++Qe])
        le(dt) || !he(dt) ? lt += " " + dt : lt += " " + oe(dt);
      return lt;
    }, X.deprecate = function(Ve, Je) {
      if (Y !== void 0 && Y.noDeprecation === !0)
        return Ve;
      if (Y === void 0)
        return function() {
          return X.deprecate(Ve, Je).apply(this || Q, arguments);
        };
      var Qe = !1;
      return function() {
        if (!Qe) {
          if (Y.throwDeprecation)
            throw new Error(Je);
          Y.traceDeprecation ? console.trace(Je) : console.error(Je), Qe = !0;
        }
        return Ve.apply(this || Q, arguments);
      };
    }, re = {}, ne = /^$/, Y.env.NODE_DEBUG && (ie2 = Y.env.NODE_DEBUG, ie2 = ie2.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie2 + "$", "i")), X.debuglog = function(Ve) {
      if (Ve = Ve.toUpperCase(), !re[Ve])
        if (ne.test(Ve)) {
          var Je = Y.pid;
          re[Ve] = function() {
            var Qe = X.format.apply(X, arguments);
            console.error("%s %d: %s", Ve, Je, Qe);
          };
        } else
          re[Ve] = function() {
          };
      return re[Ve];
    }, X.inspect = oe, oe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X.types = o$2, X.isArray = pe, X.isBoolean = ye, X.isNull = le, X.isNullOrUndefined = function(Ve) {
      return Ve == null;
    }, X.isNumber = de, X.isString = ge, X.isSymbol = function(Ve) {
      return typeof Ve == "symbol";
    }, X.isUndefined = be, X.isRegExp = me, X.types.isRegExp = me, X.isObject = he, X.isDate = je, X.types.isDate = je, X.isError = Ae, X.types.isNativeError = Ae, X.isFunction = we, X.isPrimitive = function(Ve) {
      return Ve === null || typeof Ve == "boolean" || typeof Ve == "number" || typeof Ve == "string" || typeof Ve == "symbol" || Ve === void 0;
    }, X.isBuffer = i$1$1, Se = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], X.log = function() {
      console.log("%s - %s", Be(), X.format.apply(X, arguments));
    }, X.inherits = t$2, X._extend = function(Ve, Je) {
      if (!Je || !he(Je))
        return Ve;
      for (var Qe = Object.keys(Je), at = Qe.length; at--; )
        Ve[Qe[at]] = Je[Qe[at]];
      return Ve;
    }, Ee = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0, X.promisify = function(Ve) {
      if (typeof Ve != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (Ee && Ve[Ee]) {
        var Je;
        if (typeof (Je = Ve[Ee]) != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(Je, Ee, { value: Je, enumerable: !1, writable: !1, configurable: !0 }), Je;
      }
      function Je() {
        for (var Qe, at, ut = new Promise(function(bt, $t) {
          Qe = bt, at = $t;
        }), lt = [], dt = 0; dt < arguments.length; dt++)
          lt.push(arguments[dt]);
        lt.push(function(bt, $t) {
          bt ? at(bt) : Qe($t);
        });
        try {
          Ve.apply(this || Q, lt);
        } catch (bt) {
          at(bt);
        }
        return ut;
      }
      return Object.setPrototypeOf(Je, Object.getPrototypeOf(Ve)), Ee && Object.defineProperty(Je, Ee, { value: Je, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(Je, ee(Ve));
    }, X.promisify.custom = Ee, X.callbackify = function(Ve) {
      if (typeof Ve != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function Je() {
        for (var Qe = [], at = 0; at < arguments.length; at++)
          Qe.push(arguments[at]);
        var ut = Qe.pop();
        if (typeof ut != "function")
          throw new TypeError("The last argument must be of type Function");
        var lt = this || Q, dt = function() {
          return ut.apply(lt, arguments);
        };
        Ve.apply(this || Q, Qe).then(function(bt) {
          Y.nextTick(dt.bind(null, null, bt));
        }, function(bt) {
          Y.nextTick(De.bind(null, bt, dt));
        });
      }
      return Object.setPrototypeOf(Je, Object.getPrototypeOf(Ve)), Object.defineProperties(Je, ee(Ve)), Je;
    };
  }
}), promisify, init_chunk_ce0fbc82 = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-ce0fbc82.js"() {
    init_dirname(), init_buffer2(), init_process2(), init_chunk_b4205b57(), init_chunk_5decc758(), X._extend, X.callbackify, X.debuglog, X.deprecate, X.format, X.inherits, X.inspect, X.isArray, X.isBoolean, X.isBuffer, X.isDate, X.isError, X.isFunction, X.isNull, X.isNullOrUndefined, X.isNumber, X.isObject, X.isPrimitive, X.isRegExp, X.isString, X.isSymbol, X.isUndefined, X.log, X.promisify, X._extend, X.callbackify, X.debuglog, X.deprecate, X.format, X.inherits, X.inspect, X.isArray, X.isBoolean, X.isBuffer, X.isDate, X.isError, X.isFunction, X.isNull, X.isNullOrUndefined, X.isNumber, X.isObject, X.isPrimitive, X.isRegExp, X.isString, X.isSymbol, X.isUndefined, X.log, promisify = X.promisify, X.types;
  }
});
function dew2() {
  if (_dewExec2)
    return exports2;
  _dewExec2 = !0;
  var $e = exports2 = {}, Ze, Fe;
  function Ke() {
    throw new Error("setTimeout has not been defined");
  }
  function Ve() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      typeof setTimeout == "function" ? Ze = setTimeout : Ze = Ke;
    } catch {
      Ze = Ke;
    }
    try {
      typeof clearTimeout == "function" ? Fe = clearTimeout : Fe = Ve;
    } catch {
      Fe = Ve;
    }
  })();
  function Je(xt) {
    if (Ze === setTimeout)
      return setTimeout(xt, 0);
    if ((Ze === Ke || !Ze) && setTimeout)
      return Ze = setTimeout, setTimeout(xt, 0);
    try {
      return Ze(xt, 0);
    } catch {
      try {
        return Ze.call(null, xt, 0);
      } catch {
        return Ze.call(this || _global2, xt, 0);
      }
    }
  }
  function Qe(xt) {
    if (Fe === clearTimeout)
      return clearTimeout(xt);
    if ((Fe === Ve || !Fe) && clearTimeout)
      return Fe = clearTimeout, clearTimeout(xt);
    try {
      return Fe(xt);
    } catch {
      try {
        return Fe.call(null, xt);
      } catch {
        return Fe.call(this || _global2, xt);
      }
    }
  }
  var at = [], ut = !1, lt, dt = -1;
  function bt() {
    !ut || !lt || (ut = !1, lt.length ? at = lt.concat(at) : dt = -1, at.length && $t());
  }
  function $t() {
    if (!ut) {
      var xt = Je(bt);
      ut = !0;
      for (var Et = at.length; Et; ) {
        for (lt = at, at = []; ++dt < Et; )
          lt && lt[dt].run();
        dt = -1, Et = at.length;
      }
      lt = null, ut = !1, Qe(xt);
    }
  }
  $e.nextTick = function(xt) {
    var Et = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var Tt = 1; Tt < arguments.length; Tt++)
        Et[Tt - 1] = arguments[Tt];
    at.push(new vt(xt, Et)), at.length === 1 && !ut && Je($t);
  };
  function vt(xt, Et) {
    (this || _global2).fun = xt, (this || _global2).array = Et;
  }
  vt.prototype.run = function() {
    (this || _global2).fun.apply(null, (this || _global2).array);
  }, $e.title = "browser", $e.browser = !0, $e.env = {}, $e.argv = [], $e.version = "", $e.versions = {};
  function wt() {
  }
  return $e.on = wt, $e.addListener = wt, $e.once = wt, $e.off = wt, $e.removeListener = wt, $e.removeAllListeners = wt, $e.emit = wt, $e.prependListener = wt, $e.prependOnceListener = wt, $e.listeners = function(xt) {
    return [];
  }, $e.binding = function(xt) {
    throw new Error("process.binding is not supported");
  }, $e.cwd = function() {
    return "/";
  }, $e.chdir = function(xt) {
    throw new Error("process.chdir is not supported");
  }, $e.umask = function() {
    return 0;
  }, exports2;
}
var exports2, _dewExec2, _global2, process2, init_chunk_2eac56ff = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-2eac56ff.js"() {
    init_dirname(), init_buffer2(), init_process2(), exports2 = {}, _dewExec2 = !1, _global2 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, process2 = dew2(), process2.platform = "browser", process2.addListener, process2.argv, process2.binding, process2.browser, process2.chdir, process2.cwd, process2.emit, process2.env, process2.listeners, process2.nextTick, process2.off, process2.on, process2.once, process2.prependListener, process2.prependOnceListener, process2.removeAllListeners, process2.removeListener, process2.title, process2.umask, process2.version, process2.versions;
  }
});
function u$2($e) {
  var Ze = $e.length;
  if (Ze % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var Fe = $e.indexOf("=");
  return Fe === -1 && (Fe = Ze), [Fe, Fe === Ze ? 0 : 4 - Fe % 4];
}
function c$12($e, Ze, Fe) {
  for (var Ke, Ve, Je = [], Qe = Ze; Qe < Fe; Qe += 3)
    Ke = ($e[Qe] << 16 & 16711680) + ($e[Qe + 1] << 8 & 65280) + (255 & $e[Qe + 2]), Je.push(t$13[(Ve = Ke) >> 18 & 63] + t$13[Ve >> 12 & 63] + t$13[Ve >> 6 & 63] + t$13[63 & Ve]);
  return Je.join("");
}
function f$2$1($e) {
  if ($e > 2147483647)
    throw new RangeError('The value "' + $e + '" is invalid for option "size"');
  var Ze = new Uint8Array($e);
  return Object.setPrototypeOf(Ze, u$1$1.prototype), Ze;
}
function u$1$1($e, Ze, Fe) {
  if (typeof $e == "number") {
    if (typeof Ze == "string")
      throw new TypeError('The "string" argument must be of type string. Received type number');
    return a$2($e);
  }
  return s$1($e, Ze, Fe);
}
function s$1($e, Ze, Fe) {
  if (typeof $e == "string")
    return function(Je, Qe) {
      if (typeof Qe == "string" && Qe !== "" || (Qe = "utf8"), !u$1$1.isEncoding(Qe))
        throw new TypeError("Unknown encoding: " + Qe);
      var at = 0 | y3(Je, Qe), ut = f$2$1(at), lt = ut.write(Je, Qe);
      return lt !== at && (ut = ut.slice(0, lt)), ut;
    }($e, Ze);
  if (ArrayBuffer.isView($e))
    return p4($e);
  if ($e == null)
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof $e);
  if (F2($e, ArrayBuffer) || $e && F2($e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (F2($e, SharedArrayBuffer) || $e && F2($e.buffer, SharedArrayBuffer)))
    return c$1$1$1($e, Ze, Fe);
  if (typeof $e == "number")
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  var Ke = $e.valueOf && $e.valueOf();
  if (Ke != null && Ke !== $e)
    return u$1$1.from(Ke, Ze, Fe);
  var Ve = function(Je) {
    if (u$1$1.isBuffer(Je)) {
      var Qe = 0 | l$12(Je.length), at = f$2$1(Qe);
      return at.length === 0 || Je.copy(at, 0, 0, Qe), at;
    }
    if (Je.length !== void 0)
      return typeof Je.length != "number" || N2(Je.length) ? f$2$1(0) : p4(Je);
    if (Je.type === "Buffer" && Array.isArray(Je.data))
      return p4(Je.data);
  }($e);
  if (Ve)
    return Ve;
  if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof $e[Symbol.toPrimitive] == "function")
    return u$1$1.from($e[Symbol.toPrimitive]("string"), Ze, Fe);
  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof $e);
}
function h$1$1($e) {
  if (typeof $e != "number")
    throw new TypeError('"size" argument must be of type number');
  if ($e < 0)
    throw new RangeError('The value "' + $e + '" is invalid for option "size"');
}
function a$2($e) {
  return h$1$1($e), f$2$1($e < 0 ? 0 : 0 | l$12($e));
}
function p4($e) {
  for (var Ze = $e.length < 0 ? 0 : 0 | l$12($e.length), Fe = f$2$1(Ze), Ke = 0; Ke < Ze; Ke += 1)
    Fe[Ke] = 255 & $e[Ke];
  return Fe;
}
function c$1$1$1($e, Ze, Fe) {
  if (Ze < 0 || $e.byteLength < Ze)
    throw new RangeError('"offset" is outside of buffer bounds');
  if ($e.byteLength < Ze + (Fe || 0))
    throw new RangeError('"length" is outside of buffer bounds');
  var Ke;
  return Ke = Ze === void 0 && Fe === void 0 ? new Uint8Array($e) : Fe === void 0 ? new Uint8Array($e, Ze) : new Uint8Array($e, Ze, Fe), Object.setPrototypeOf(Ke, u$1$1.prototype), Ke;
}
function l$12($e) {
  if ($e >= 2147483647)
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
  return 0 | $e;
}
function y3($e, Ze) {
  if (u$1$1.isBuffer($e))
    return $e.length;
  if (ArrayBuffer.isView($e) || F2($e, ArrayBuffer))
    return $e.byteLength;
  if (typeof $e != "string")
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof $e);
  var Fe = $e.length, Ke = arguments.length > 2 && arguments[2] === !0;
  if (!Ke && Fe === 0)
    return 0;
  for (var Ve = !1; ; )
    switch (Ze) {
      case "ascii":
      case "latin1":
      case "binary":
        return Fe;
      case "utf8":
      case "utf-8":
        return _2($e).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * Fe;
      case "hex":
        return Fe >>> 1;
      case "base64":
        return z2($e).length;
      default:
        if (Ve)
          return Ke ? -1 : _2($e).length;
        Ze = ("" + Ze).toLowerCase(), Ve = !0;
    }
}
function g2($e, Ze, Fe) {
  var Ke = !1;
  if ((Ze === void 0 || Ze < 0) && (Ze = 0), Ze > this.length || ((Fe === void 0 || Fe > this.length) && (Fe = this.length), Fe <= 0) || (Fe >>>= 0) <= (Ze >>>= 0))
    return "";
  for ($e || ($e = "utf8"); ; )
    switch ($e) {
      case "hex":
        return O2(this, Ze, Fe);
      case "utf8":
      case "utf-8":
        return I2(this, Ze, Fe);
      case "ascii":
        return S2(this, Ze, Fe);
      case "latin1":
      case "binary":
        return R2(this, Ze, Fe);
      case "base64":
        return T3(this, Ze, Fe);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return L2(this, Ze, Fe);
      default:
        if (Ke)
          throw new TypeError("Unknown encoding: " + $e);
        $e = ($e + "").toLowerCase(), Ke = !0;
    }
}
function w2($e, Ze, Fe) {
  var Ke = $e[Ze];
  $e[Ze] = $e[Fe], $e[Fe] = Ke;
}
function d3($e, Ze, Fe, Ke, Ve) {
  if ($e.length === 0)
    return -1;
  if (typeof Fe == "string" ? (Ke = Fe, Fe = 0) : Fe > 2147483647 ? Fe = 2147483647 : Fe < -2147483648 && (Fe = -2147483648), N2(Fe = +Fe) && (Fe = Ve ? 0 : $e.length - 1), Fe < 0 && (Fe = $e.length + Fe), Fe >= $e.length) {
    if (Ve)
      return -1;
    Fe = $e.length - 1;
  } else if (Fe < 0) {
    if (!Ve)
      return -1;
    Fe = 0;
  }
  if (typeof Ze == "string" && (Ze = u$1$1.from(Ze, Ke)), u$1$1.isBuffer(Ze))
    return Ze.length === 0 ? -1 : v3($e, Ze, Fe, Ke, Ve);
  if (typeof Ze == "number")
    return Ze &= 255, typeof Uint8Array.prototype.indexOf == "function" ? Ve ? Uint8Array.prototype.indexOf.call($e, Ze, Fe) : Uint8Array.prototype.lastIndexOf.call($e, Ze, Fe) : v3($e, [Ze], Fe, Ke, Ve);
  throw new TypeError("val must be string, number or Buffer");
}
function v3($e, Ze, Fe, Ke, Ve) {
  var Je, Qe = 1, at = $e.length, ut = Ze.length;
  if (Ke !== void 0 && ((Ke = String(Ke).toLowerCase()) === "ucs2" || Ke === "ucs-2" || Ke === "utf16le" || Ke === "utf-16le")) {
    if ($e.length < 2 || Ze.length < 2)
      return -1;
    Qe = 2, at /= 2, ut /= 2, Fe /= 2;
  }
  function lt(vt, wt) {
    return Qe === 1 ? vt[wt] : vt.readUInt16BE(wt * Qe);
  }
  if (Ve) {
    var dt = -1;
    for (Je = Fe; Je < at; Je++)
      if (lt($e, Je) === lt(Ze, dt === -1 ? 0 : Je - dt)) {
        if (dt === -1 && (dt = Je), Je - dt + 1 === ut)
          return dt * Qe;
      } else
        dt !== -1 && (Je -= Je - dt), dt = -1;
  } else
    for (Fe + ut > at && (Fe = at - ut), Je = Fe; Je >= 0; Je--) {
      for (var bt = !0, $t = 0; $t < ut; $t++)
        if (lt($e, Je + $t) !== lt(Ze, $t)) {
          bt = !1;
          break;
        }
      if (bt)
        return Je;
    }
  return -1;
}
function b2($e, Ze, Fe, Ke) {
  Fe = Number(Fe) || 0;
  var Ve = $e.length - Fe;
  Ke ? (Ke = Number(Ke)) > Ve && (Ke = Ve) : Ke = Ve;
  var Je = Ze.length;
  Ke > Je / 2 && (Ke = Je / 2);
  for (var Qe = 0; Qe < Ke; ++Qe) {
    var at = parseInt(Ze.substr(2 * Qe, 2), 16);
    if (N2(at))
      return Qe;
    $e[Fe + Qe] = at;
  }
  return Qe;
}
function m3($e, Ze, Fe, Ke) {
  return D2(_2(Ze, $e.length - Fe), $e, Fe, Ke);
}
function E2($e, Ze, Fe, Ke) {
  return D2(function(Ve) {
    for (var Je = [], Qe = 0; Qe < Ve.length; ++Qe)
      Je.push(255 & Ve.charCodeAt(Qe));
    return Je;
  }(Ze), $e, Fe, Ke);
}
function B2($e, Ze, Fe, Ke) {
  return E2($e, Ze, Fe, Ke);
}
function A2($e, Ze, Fe, Ke) {
  return D2(z2(Ze), $e, Fe, Ke);
}
function U2($e, Ze, Fe, Ke) {
  return D2(function(Ve, Je) {
    for (var Qe, at, ut, lt = [], dt = 0; dt < Ve.length && !((Je -= 2) < 0); ++dt)
      Qe = Ve.charCodeAt(dt), at = Qe >> 8, ut = Qe % 256, lt.push(ut), lt.push(at);
    return lt;
  }(Ze, $e.length - Fe), $e, Fe, Ke);
}
function T3($e, Ze, Fe) {
  return Ze === 0 && Fe === $e.length ? n$1$1$1.fromByteArray($e) : n$1$1$1.fromByteArray($e.slice(Ze, Fe));
}
function I2($e, Ze, Fe) {
  Fe = Math.min($e.length, Fe);
  for (var Ke = [], Ve = Ze; Ve < Fe; ) {
    var Je, Qe, at, ut, lt = $e[Ve], dt = null, bt = lt > 239 ? 4 : lt > 223 ? 3 : lt > 191 ? 2 : 1;
    if (Ve + bt <= Fe)
      switch (bt) {
        case 1:
          lt < 128 && (dt = lt);
          break;
        case 2:
          (192 & (Je = $e[Ve + 1])) == 128 && (ut = (31 & lt) << 6 | 63 & Je) > 127 && (dt = ut);
          break;
        case 3:
          Je = $e[Ve + 1], Qe = $e[Ve + 2], (192 & Je) == 128 && (192 & Qe) == 128 && (ut = (15 & lt) << 12 | (63 & Je) << 6 | 63 & Qe) > 2047 && (ut < 55296 || ut > 57343) && (dt = ut);
          break;
        case 4:
          Je = $e[Ve + 1], Qe = $e[Ve + 2], at = $e[Ve + 3], (192 & Je) == 128 && (192 & Qe) == 128 && (192 & at) == 128 && (ut = (15 & lt) << 18 | (63 & Je) << 12 | (63 & Qe) << 6 | 63 & at) > 65535 && ut < 1114112 && (dt = ut);
      }
    dt === null ? (dt = 65533, bt = 1) : dt > 65535 && (dt -= 65536, Ke.push(dt >>> 10 & 1023 | 55296), dt = 56320 | 1023 & dt), Ke.push(dt), Ve += bt;
  }
  return function($t) {
    var vt = $t.length;
    if (vt <= 4096)
      return String.fromCharCode.apply(String, $t);
    for (var wt = "", xt = 0; xt < vt; )
      wt += String.fromCharCode.apply(String, $t.slice(xt, xt += 4096));
    return wt;
  }(Ke);
}
function S2($e, Ze, Fe) {
  var Ke = "";
  Fe = Math.min($e.length, Fe);
  for (var Ve = Ze; Ve < Fe; ++Ve)
    Ke += String.fromCharCode(127 & $e[Ve]);
  return Ke;
}
function R2($e, Ze, Fe) {
  var Ke = "";
  Fe = Math.min($e.length, Fe);
  for (var Ve = Ze; Ve < Fe; ++Ve)
    Ke += String.fromCharCode($e[Ve]);
  return Ke;
}
function O2($e, Ze, Fe) {
  var Ke = $e.length;
  (!Ze || Ze < 0) && (Ze = 0), (!Fe || Fe < 0 || Fe > Ke) && (Fe = Ke);
  for (var Ve = "", Je = Ze; Je < Fe; ++Je)
    Ve += Y2[$e[Je]];
  return Ve;
}
function L2($e, Ze, Fe) {
  for (var Ke = $e.slice(Ze, Fe), Ve = "", Je = 0; Je < Ke.length; Je += 2)
    Ve += String.fromCharCode(Ke[Je] + 256 * Ke[Je + 1]);
  return Ve;
}
function x2($e, Ze, Fe) {
  if ($e % 1 != 0 || $e < 0)
    throw new RangeError("offset is not uint");
  if ($e + Ze > Fe)
    throw new RangeError("Trying to access beyond buffer length");
}
function C2($e, Ze, Fe, Ke, Ve, Je) {
  if (!u$1$1.isBuffer($e))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (Ze > Ve || Ze < Je)
    throw new RangeError('"value" argument is out of bounds');
  if (Fe + Ke > $e.length)
    throw new RangeError("Index out of range");
}
function P2($e, Ze, Fe, Ke, Ve, Je) {
  if (Fe + Ke > $e.length)
    throw new RangeError("Index out of range");
  if (Fe < 0)
    throw new RangeError("Index out of range");
}
function k2($e, Ze, Fe, Ke, Ve) {
  return Ze = +Ze, Fe >>>= 0, Ve || P2($e, 0, Fe, 4), i$12.write($e, Ze, Fe, Ke, 23, 4), Fe + 4;
}
function M2($e, Ze, Fe, Ke, Ve) {
  return Ze = +Ze, Fe >>>= 0, Ve || P2($e, 0, Fe, 8), i$12.write($e, Ze, Fe, Ke, 52, 8), Fe + 8;
}
function _2($e, Ze) {
  var Fe;
  Ze = Ze || 1 / 0;
  for (var Ke = $e.length, Ve = null, Je = [], Qe = 0; Qe < Ke; ++Qe) {
    if ((Fe = $e.charCodeAt(Qe)) > 55295 && Fe < 57344) {
      if (!Ve) {
        if (Fe > 56319) {
          (Ze -= 3) > -1 && Je.push(239, 191, 189);
          continue;
        }
        if (Qe + 1 === Ke) {
          (Ze -= 3) > -1 && Je.push(239, 191, 189);
          continue;
        }
        Ve = Fe;
        continue;
      }
      if (Fe < 56320) {
        (Ze -= 3) > -1 && Je.push(239, 191, 189), Ve = Fe;
        continue;
      }
      Fe = 65536 + (Ve - 55296 << 10 | Fe - 56320);
    } else
      Ve && (Ze -= 3) > -1 && Je.push(239, 191, 189);
    if (Ve = null, Fe < 128) {
      if ((Ze -= 1) < 0)
        break;
      Je.push(Fe);
    } else if (Fe < 2048) {
      if ((Ze -= 2) < 0)
        break;
      Je.push(Fe >> 6 | 192, 63 & Fe | 128);
    } else if (Fe < 65536) {
      if ((Ze -= 3) < 0)
        break;
      Je.push(Fe >> 12 | 224, Fe >> 6 & 63 | 128, 63 & Fe | 128);
    } else {
      if (!(Fe < 1114112))
        throw new Error("Invalid code point");
      if ((Ze -= 4) < 0)
        break;
      Je.push(Fe >> 18 | 240, Fe >> 12 & 63 | 128, Fe >> 6 & 63 | 128, 63 & Fe | 128);
    }
  }
  return Je;
}
function z2($e) {
  return n$1$1$1.toByteArray(function(Ze) {
    if ((Ze = (Ze = Ze.split("=")[0]).trim().replace(j2, "")).length < 2)
      return "";
    for (; Ze.length % 4 != 0; )
      Ze += "=";
    return Ze;
  }($e));
}
function D2($e, Ze, Fe, Ke) {
  for (var Ve = 0; Ve < Ke && !(Ve + Fe >= Ze.length || Ve >= $e.length); ++Ve)
    Ze[Ve + Fe] = $e[Ve];
  return Ve;
}
function F2($e, Ze) {
  return $e instanceof Ze || $e != null && $e.constructor != null && $e.constructor.name != null && $e.constructor.name === Ze.name;
}
function N2($e) {
  return $e != $e;
}
function t4($e, Ze) {
  for (var Fe in $e)
    Ze[Fe] = $e[Fe];
}
function f4($e, Ze, Fe) {
  return o4($e, Ze, Fe);
}
function a4($e) {
  var Ze;
  switch (this.encoding = function(Fe) {
    var Ke = function(Ve) {
      if (!Ve)
        return "utf8";
      for (var Je; ; )
        switch (Ve) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return Ve;
          default:
            if (Je)
              return;
            Ve = ("" + Ve).toLowerCase(), Je = !0;
        }
    }(Fe);
    if (typeof Ke != "string" && (s4.isEncoding === i4 || !i4(Fe)))
      throw new Error("Unknown encoding: " + Fe);
    return Ke || Fe;
  }($e), this.encoding) {
    case "utf16le":
      this.text = h4, this.end = l4, Ze = 4;
      break;
    case "utf8":
      this.fillLast = n$12, Ze = 4;
      break;
    case "base64":
      this.text = u$12, this.end = o$12, Ze = 3;
      break;
    default:
      return this.write = f$1$1, this.end = c4, void 0;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = s4.allocUnsafe(Ze);
}
function r4($e) {
  return $e <= 127 ? 0 : $e >> 5 == 6 ? 2 : $e >> 4 == 14 ? 3 : $e >> 3 == 30 ? 4 : $e >> 6 == 2 ? -1 : -2;
}
function n$12($e) {
  var Ze = this.lastTotal - this.lastNeed, Fe = function(Ke, Ve, Je) {
    if ((192 & Ve[0]) != 128)
      return Ke.lastNeed = 0, "�";
    if (Ke.lastNeed > 1 && Ve.length > 1) {
      if ((192 & Ve[1]) != 128)
        return Ke.lastNeed = 1, "�";
      if (Ke.lastNeed > 2 && Ve.length > 2 && (192 & Ve[2]) != 128)
        return Ke.lastNeed = 2, "�";
    }
  }(this, $e);
  return Fe !== void 0 ? Fe : this.lastNeed <= $e.length ? ($e.copy(this.lastChar, Ze, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : ($e.copy(this.lastChar, Ze, 0, $e.length), this.lastNeed -= $e.length, void 0);
}
function h4($e, Ze) {
  if (($e.length - Ze) % 2 == 0) {
    var Fe = $e.toString("utf16le", Ze);
    if (Fe) {
      var Ke = Fe.charCodeAt(Fe.length - 1);
      if (Ke >= 55296 && Ke <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = $e[$e.length - 2], this.lastChar[1] = $e[$e.length - 1], Fe.slice(0, -1);
    }
    return Fe;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = $e[$e.length - 1], $e.toString("utf16le", Ze, $e.length - 1);
}
function l4($e) {
  var Ze = $e && $e.length ? this.write($e) : "";
  if (this.lastNeed) {
    var Fe = this.lastTotal - this.lastNeed;
    return Ze + this.lastChar.toString("utf16le", 0, Fe);
  }
  return Ze;
}
function u$12($e, Ze) {
  var Fe = ($e.length - Ze) % 3;
  return Fe === 0 ? $e.toString("base64", Ze) : (this.lastNeed = 3 - Fe, this.lastTotal = 3, Fe === 1 ? this.lastChar[0] = $e[$e.length - 1] : (this.lastChar[0] = $e[$e.length - 2], this.lastChar[1] = $e[$e.length - 1]), $e.toString("base64", Ze, $e.length - Fe));
}
function o$12($e) {
  var Ze = $e && $e.length ? this.write($e) : "";
  return this.lastNeed ? Ze + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : Ze;
}
function f$1$1($e) {
  return $e.toString(this.encoding);
}
function c4($e) {
  return $e && $e.length ? this.write($e) : "";
}
var r$13, t$13, e$22, n$22, o$23, a$12, h$12, a$1$1, e$1$1$1, n$1$1$1, i$12, o$1$1, j2, Y2, e4, n4, o4, u4, e$12, s4, i4, init_chunk_4ccc3a29 = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-4ccc3a29.js"() {
    for (init_dirname(), init_buffer2(), init_process2(), r$13 = { byteLength: function($e) {
      var Ze = u$2($e), Fe = Ze[0], Ke = Ze[1];
      return 3 * (Fe + Ke) / 4 - Ke;
    }, toByteArray: function($e) {
      var Ze, Fe, Ke = u$2($e), Ve = Ke[0], Je = Ke[1], Qe = new n$22(function(lt, dt, bt) {
        return 3 * (dt + bt) / 4 - bt;
      }(0, Ve, Je)), at = 0, ut = Je > 0 ? Ve - 4 : Ve;
      for (Fe = 0; Fe < ut; Fe += 4)
        Ze = e$22[$e.charCodeAt(Fe)] << 18 | e$22[$e.charCodeAt(Fe + 1)] << 12 | e$22[$e.charCodeAt(Fe + 2)] << 6 | e$22[$e.charCodeAt(Fe + 3)], Qe[at++] = Ze >> 16 & 255, Qe[at++] = Ze >> 8 & 255, Qe[at++] = 255 & Ze;
      return Je === 2 && (Ze = e$22[$e.charCodeAt(Fe)] << 2 | e$22[$e.charCodeAt(Fe + 1)] >> 4, Qe[at++] = 255 & Ze), Je === 1 && (Ze = e$22[$e.charCodeAt(Fe)] << 10 | e$22[$e.charCodeAt(Fe + 1)] << 4 | e$22[$e.charCodeAt(Fe + 2)] >> 2, Qe[at++] = Ze >> 8 & 255, Qe[at++] = 255 & Ze), Qe;
    }, fromByteArray: function($e) {
      for (var Ze, Fe = $e.length, Ke = Fe % 3, Ve = [], Je = 0, Qe = Fe - Ke; Je < Qe; Je += 16383)
        Ve.push(c$12($e, Je, Je + 16383 > Qe ? Qe : Je + 16383));
      return Ke === 1 ? (Ze = $e[Fe - 1], Ve.push(t$13[Ze >> 2] + t$13[Ze << 4 & 63] + "==")) : Ke === 2 && (Ze = ($e[Fe - 2] << 8) + $e[Fe - 1], Ve.push(t$13[Ze >> 10] + t$13[Ze >> 4 & 63] + t$13[Ze << 2 & 63] + "=")), Ve.join("");
    } }, t$13 = [], e$22 = [], n$22 = typeof Uint8Array < "u" ? Uint8Array : Array, o$23 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a$12 = 0, h$12 = o$23.length; a$12 < h$12; ++a$12)
      t$13[a$12] = o$23[a$12], e$22[o$23.charCodeAt(a$12)] = a$12;
    e$22["-".charCodeAt(0)] = 62, e$22["_".charCodeAt(0)] = 63, a$1$1 = { read: function($e, Ze, Fe, Ke, Ve) {
      var Je, Qe, at = 8 * Ve - Ke - 1, ut = (1 << at) - 1, lt = ut >> 1, dt = -7, bt = Fe ? Ve - 1 : 0, $t = Fe ? -1 : 1, vt = $e[Ze + bt];
      for (bt += $t, Je = vt & (1 << -dt) - 1, vt >>= -dt, dt += at; dt > 0; Je = 256 * Je + $e[Ze + bt], bt += $t, dt -= 8)
        ;
      for (Qe = Je & (1 << -dt) - 1, Je >>= -dt, dt += Ke; dt > 0; Qe = 256 * Qe + $e[Ze + bt], bt += $t, dt -= 8)
        ;
      if (Je === 0)
        Je = 1 - lt;
      else {
        if (Je === ut)
          return Qe ? NaN : 1 / 0 * (vt ? -1 : 1);
        Qe += Math.pow(2, Ke), Je -= lt;
      }
      return (vt ? -1 : 1) * Qe * Math.pow(2, Je - Ke);
    }, write: function($e, Ze, Fe, Ke, Ve, Je) {
      var Qe, at, ut, lt = 8 * Je - Ve - 1, dt = (1 << lt) - 1, bt = dt >> 1, $t = Ve === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, vt = Ke ? 0 : Je - 1, wt = Ke ? 1 : -1, xt = Ze < 0 || Ze === 0 && 1 / Ze < 0 ? 1 : 0;
      for (Ze = Math.abs(Ze), isNaN(Ze) || Ze === 1 / 0 ? (at = isNaN(Ze) ? 1 : 0, Qe = dt) : (Qe = Math.floor(Math.log(Ze) / Math.LN2), Ze * (ut = Math.pow(2, -Qe)) < 1 && (Qe--, ut *= 2), (Ze += Qe + bt >= 1 ? $t / ut : $t * Math.pow(2, 1 - bt)) * ut >= 2 && (Qe++, ut /= 2), Qe + bt >= dt ? (at = 0, Qe = dt) : Qe + bt >= 1 ? (at = (Ze * ut - 1) * Math.pow(2, Ve), Qe += bt) : (at = Ze * Math.pow(2, bt - 1) * Math.pow(2, Ve), Qe = 0)); Ve >= 8; $e[Fe + vt] = 255 & at, vt += wt, at /= 256, Ve -= 8)
        ;
      for (Qe = Qe << Ve | at, lt += Ve; lt > 0; $e[Fe + vt] = 255 & Qe, vt += wt, Qe /= 256, lt -= 8)
        ;
      $e[Fe + vt - wt] |= 128 * xt;
    } }, e$1$1$1 = {}, n$1$1$1 = r$13, i$12 = a$1$1, o$1$1 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null, e$1$1$1.Buffer = u$1$1, e$1$1$1.SlowBuffer = function($e) {
      return +$e != $e && ($e = 0), u$1$1.alloc(+$e);
    }, e$1$1$1.INSPECT_MAX_BYTES = 50, e$1$1$1.kMaxLength = 2147483647, u$1$1.TYPED_ARRAY_SUPPORT = function() {
      try {
        var $e = new Uint8Array(1), Ze = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(Ze, Uint8Array.prototype), Object.setPrototypeOf($e, Ze), $e.foo() === 42;
      } catch {
        return !1;
      }
    }(), u$1$1.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u$1$1.prototype, "parent", { enumerable: !0, get: function() {
      if (u$1$1.isBuffer(this))
        return this.buffer;
    } }), Object.defineProperty(u$1$1.prototype, "offset", { enumerable: !0, get: function() {
      if (u$1$1.isBuffer(this))
        return this.byteOffset;
    } }), u$1$1.poolSize = 8192, u$1$1.from = function($e, Ze, Fe) {
      return s$1($e, Ze, Fe);
    }, Object.setPrototypeOf(u$1$1.prototype, Uint8Array.prototype), Object.setPrototypeOf(u$1$1, Uint8Array), u$1$1.alloc = function($e, Ze, Fe) {
      return function(Ke, Ve, Je) {
        return h$1$1(Ke), Ke <= 0 ? f$2$1(Ke) : Ve !== void 0 ? typeof Je == "string" ? f$2$1(Ke).fill(Ve, Je) : f$2$1(Ke).fill(Ve) : f$2$1(Ke);
      }($e, Ze, Fe);
    }, u$1$1.allocUnsafe = function($e) {
      return a$2($e);
    }, u$1$1.allocUnsafeSlow = function($e) {
      return a$2($e);
    }, u$1$1.isBuffer = function($e) {
      return $e != null && $e._isBuffer === !0 && $e !== u$1$1.prototype;
    }, u$1$1.compare = function($e, Ze) {
      if (F2($e, Uint8Array) && ($e = u$1$1.from($e, $e.offset, $e.byteLength)), F2(Ze, Uint8Array) && (Ze = u$1$1.from(Ze, Ze.offset, Ze.byteLength)), !u$1$1.isBuffer($e) || !u$1$1.isBuffer(Ze))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if ($e === Ze)
        return 0;
      for (var Fe = $e.length, Ke = Ze.length, Ve = 0, Je = Math.min(Fe, Ke); Ve < Je; ++Ve)
        if ($e[Ve] !== Ze[Ve]) {
          Fe = $e[Ve], Ke = Ze[Ve];
          break;
        }
      return Fe < Ke ? -1 : Ke < Fe ? 1 : 0;
    }, u$1$1.isEncoding = function($e) {
      switch (String($e).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, u$1$1.concat = function($e, Ze) {
      if (!Array.isArray($e))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if ($e.length === 0)
        return u$1$1.alloc(0);
      var Fe;
      if (Ze === void 0)
        for (Ze = 0, Fe = 0; Fe < $e.length; ++Fe)
          Ze += $e[Fe].length;
      var Ke = u$1$1.allocUnsafe(Ze), Ve = 0;
      for (Fe = 0; Fe < $e.length; ++Fe) {
        var Je = $e[Fe];
        if (F2(Je, Uint8Array) && (Je = u$1$1.from(Je)), !u$1$1.isBuffer(Je))
          throw new TypeError('"list" argument must be an Array of Buffers');
        Je.copy(Ke, Ve), Ve += Je.length;
      }
      return Ke;
    }, u$1$1.byteLength = y3, u$1$1.prototype._isBuffer = !0, u$1$1.prototype.swap16 = function() {
      var $e = this.length;
      if ($e % 2 != 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var Ze = 0; Ze < $e; Ze += 2)
        w2(this, Ze, Ze + 1);
      return this;
    }, u$1$1.prototype.swap32 = function() {
      var $e = this.length;
      if ($e % 4 != 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var Ze = 0; Ze < $e; Ze += 4)
        w2(this, Ze, Ze + 3), w2(this, Ze + 1, Ze + 2);
      return this;
    }, u$1$1.prototype.swap64 = function() {
      var $e = this.length;
      if ($e % 8 != 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var Ze = 0; Ze < $e; Ze += 8)
        w2(this, Ze, Ze + 7), w2(this, Ze + 1, Ze + 6), w2(this, Ze + 2, Ze + 5), w2(this, Ze + 3, Ze + 4);
      return this;
    }, u$1$1.prototype.toString = function() {
      var $e = this.length;
      return $e === 0 ? "" : arguments.length === 0 ? I2(this, 0, $e) : g2.apply(this, arguments);
    }, u$1$1.prototype.toLocaleString = u$1$1.prototype.toString, u$1$1.prototype.equals = function($e) {
      if (!u$1$1.isBuffer($e))
        throw new TypeError("Argument must be a Buffer");
      return this === $e || u$1$1.compare(this, $e) === 0;
    }, u$1$1.prototype.inspect = function() {
      var $e = "", Ze = e$1$1$1.INSPECT_MAX_BYTES;
      return $e = this.toString("hex", 0, Ze).replace(/(.{2})/g, "$1 ").trim(), this.length > Ze && ($e += " ... "), "<Buffer " + $e + ">";
    }, o$1$1 && (u$1$1.prototype[o$1$1] = u$1$1.prototype.inspect), u$1$1.prototype.compare = function($e, Ze, Fe, Ke, Ve) {
      if (F2($e, Uint8Array) && ($e = u$1$1.from($e, $e.offset, $e.byteLength)), !u$1$1.isBuffer($e))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof $e);
      if (Ze === void 0 && (Ze = 0), Fe === void 0 && (Fe = $e ? $e.length : 0), Ke === void 0 && (Ke = 0), Ve === void 0 && (Ve = this.length), Ze < 0 || Fe > $e.length || Ke < 0 || Ve > this.length)
        throw new RangeError("out of range index");
      if (Ke >= Ve && Ze >= Fe)
        return 0;
      if (Ke >= Ve)
        return -1;
      if (Ze >= Fe)
        return 1;
      if (this === $e)
        return 0;
      for (var Je = (Ve >>>= 0) - (Ke >>>= 0), Qe = (Fe >>>= 0) - (Ze >>>= 0), at = Math.min(Je, Qe), ut = this.slice(Ke, Ve), lt = $e.slice(Ze, Fe), dt = 0; dt < at; ++dt)
        if (ut[dt] !== lt[dt]) {
          Je = ut[dt], Qe = lt[dt];
          break;
        }
      return Je < Qe ? -1 : Qe < Je ? 1 : 0;
    }, u$1$1.prototype.includes = function($e, Ze, Fe) {
      return this.indexOf($e, Ze, Fe) !== -1;
    }, u$1$1.prototype.indexOf = function($e, Ze, Fe) {
      return d3(this, $e, Ze, Fe, !0);
    }, u$1$1.prototype.lastIndexOf = function($e, Ze, Fe) {
      return d3(this, $e, Ze, Fe, !1);
    }, u$1$1.prototype.write = function($e, Ze, Fe, Ke) {
      if (Ze === void 0)
        Ke = "utf8", Fe = this.length, Ze = 0;
      else if (Fe === void 0 && typeof Ze == "string")
        Ke = Ze, Fe = this.length, Ze = 0;
      else {
        if (!isFinite(Ze))
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        Ze >>>= 0, isFinite(Fe) ? (Fe >>>= 0, Ke === void 0 && (Ke = "utf8")) : (Ke = Fe, Fe = void 0);
      }
      var Ve = this.length - Ze;
      if ((Fe === void 0 || Fe > Ve) && (Fe = Ve), $e.length > 0 && (Fe < 0 || Ze < 0) || Ze > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      Ke || (Ke = "utf8");
      for (var Je = !1; ; )
        switch (Ke) {
          case "hex":
            return b2(this, $e, Ze, Fe);
          case "utf8":
          case "utf-8":
            return m3(this, $e, Ze, Fe);
          case "ascii":
            return E2(this, $e, Ze, Fe);
          case "latin1":
          case "binary":
            return B2(this, $e, Ze, Fe);
          case "base64":
            return A2(this, $e, Ze, Fe);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return U2(this, $e, Ze, Fe);
          default:
            if (Je)
              throw new TypeError("Unknown encoding: " + Ke);
            Ke = ("" + Ke).toLowerCase(), Je = !0;
        }
    }, u$1$1.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    }, u$1$1.prototype.slice = function($e, Ze) {
      var Fe = this.length;
      ($e = ~~$e) < 0 ? ($e += Fe) < 0 && ($e = 0) : $e > Fe && ($e = Fe), (Ze = Ze === void 0 ? Fe : ~~Ze) < 0 ? (Ze += Fe) < 0 && (Ze = 0) : Ze > Fe && (Ze = Fe), Ze < $e && (Ze = $e);
      var Ke = this.subarray($e, Ze);
      return Object.setPrototypeOf(Ke, u$1$1.prototype), Ke;
    }, u$1$1.prototype.readUIntLE = function($e, Ze, Fe) {
      $e >>>= 0, Ze >>>= 0, Fe || x2($e, Ze, this.length);
      for (var Ke = this[$e], Ve = 1, Je = 0; ++Je < Ze && (Ve *= 256); )
        Ke += this[$e + Je] * Ve;
      return Ke;
    }, u$1$1.prototype.readUIntBE = function($e, Ze, Fe) {
      $e >>>= 0, Ze >>>= 0, Fe || x2($e, Ze, this.length);
      for (var Ke = this[$e + --Ze], Ve = 1; Ze > 0 && (Ve *= 256); )
        Ke += this[$e + --Ze] * Ve;
      return Ke;
    }, u$1$1.prototype.readUInt8 = function($e, Ze) {
      return $e >>>= 0, Ze || x2($e, 1, this.length), this[$e];
    }, u$1$1.prototype.readUInt16LE = function($e, Ze) {
      return $e >>>= 0, Ze || x2($e, 2, this.length), this[$e] | this[$e + 1] << 8;
    }, u$1$1.prototype.readUInt16BE = function($e, Ze) {
      return $e >>>= 0, Ze || x2($e, 2, this.length), this[$e] << 8 | this[$e + 1];
    }, u$1$1.prototype.readUInt32LE = function($e, Ze) {
      return $e >>>= 0, Ze || x2($e, 4, this.length), (this[$e] | this[$e + 1] << 8 | this[$e + 2] << 16) + 16777216 * this[$e + 3];
    }, u$1$1.prototype.readUInt32BE = function($e, Ze) {
      return $e >>>= 0, Ze || x2($e, 4, this.length), 16777216 * this[$e] + (this[$e + 1] << 16 | this[$e + 2] << 8 | this[$e + 3]);
    }, u$1$1.prototype.readIntLE = function($e, Ze, Fe) {
      $e >>>= 0, Ze >>>= 0, Fe || x2($e, Ze, this.length);
      for (var Ke = this[$e], Ve = 1, Je = 0; ++Je < Ze && (Ve *= 256); )
        Ke += this[$e + Je] * Ve;
      return Ke >= (Ve *= 128) && (Ke -= Math.pow(2, 8 * Ze)), Ke;
    }, u$1$1.prototype.readIntBE = function($e, Ze, Fe) {
      $e >>>= 0, Ze >>>= 0, Fe || x2($e, Ze, this.length);
      for (var Ke = Ze, Ve = 1, Je = this[$e + --Ke]; Ke > 0 && (Ve *= 256); )
        Je += this[$e + --Ke] * Ve;
      return Je >= (Ve *= 128) && (Je -= Math.pow(2, 8 * Ze)), Je;
    }, u$1$1.prototype.readInt8 = function($e, Ze) {
      return $e >>>= 0, Ze || x2($e, 1, this.length), 128 & this[$e] ? -1 * (255 - this[$e] + 1) : this[$e];
    }, u$1$1.prototype.readInt16LE = function($e, Ze) {
      $e >>>= 0, Ze || x2($e, 2, this.length);
      var Fe = this[$e] | this[$e + 1] << 8;
      return 32768 & Fe ? 4294901760 | Fe : Fe;
    }, u$1$1.prototype.readInt16BE = function($e, Ze) {
      $e >>>= 0, Ze || x2($e, 2, this.length);
      var Fe = this[$e + 1] | this[$e] << 8;
      return 32768 & Fe ? 4294901760 | Fe : Fe;
    }, u$1$1.prototype.readInt32LE = function($e, Ze) {
      return $e >>>= 0, Ze || x2($e, 4, this.length), this[$e] | this[$e + 1] << 8 | this[$e + 2] << 16 | this[$e + 3] << 24;
    }, u$1$1.prototype.readInt32BE = function($e, Ze) {
      return $e >>>= 0, Ze || x2($e, 4, this.length), this[$e] << 24 | this[$e + 1] << 16 | this[$e + 2] << 8 | this[$e + 3];
    }, u$1$1.prototype.readFloatLE = function($e, Ze) {
      return $e >>>= 0, Ze || x2($e, 4, this.length), i$12.read(this, $e, !0, 23, 4);
    }, u$1$1.prototype.readFloatBE = function($e, Ze) {
      return $e >>>= 0, Ze || x2($e, 4, this.length), i$12.read(this, $e, !1, 23, 4);
    }, u$1$1.prototype.readDoubleLE = function($e, Ze) {
      return $e >>>= 0, Ze || x2($e, 8, this.length), i$12.read(this, $e, !0, 52, 8);
    }, u$1$1.prototype.readDoubleBE = function($e, Ze) {
      return $e >>>= 0, Ze || x2($e, 8, this.length), i$12.read(this, $e, !1, 52, 8);
    }, u$1$1.prototype.writeUIntLE = function($e, Ze, Fe, Ke) {
      $e = +$e, Ze >>>= 0, Fe >>>= 0, Ke || C2(this, $e, Ze, Fe, Math.pow(2, 8 * Fe) - 1, 0);
      var Ve = 1, Je = 0;
      for (this[Ze] = 255 & $e; ++Je < Fe && (Ve *= 256); )
        this[Ze + Je] = $e / Ve & 255;
      return Ze + Fe;
    }, u$1$1.prototype.writeUIntBE = function($e, Ze, Fe, Ke) {
      $e = +$e, Ze >>>= 0, Fe >>>= 0, Ke || C2(this, $e, Ze, Fe, Math.pow(2, 8 * Fe) - 1, 0);
      var Ve = Fe - 1, Je = 1;
      for (this[Ze + Ve] = 255 & $e; --Ve >= 0 && (Je *= 256); )
        this[Ze + Ve] = $e / Je & 255;
      return Ze + Fe;
    }, u$1$1.prototype.writeUInt8 = function($e, Ze, Fe) {
      return $e = +$e, Ze >>>= 0, Fe || C2(this, $e, Ze, 1, 255, 0), this[Ze] = 255 & $e, Ze + 1;
    }, u$1$1.prototype.writeUInt16LE = function($e, Ze, Fe) {
      return $e = +$e, Ze >>>= 0, Fe || C2(this, $e, Ze, 2, 65535, 0), this[Ze] = 255 & $e, this[Ze + 1] = $e >>> 8, Ze + 2;
    }, u$1$1.prototype.writeUInt16BE = function($e, Ze, Fe) {
      return $e = +$e, Ze >>>= 0, Fe || C2(this, $e, Ze, 2, 65535, 0), this[Ze] = $e >>> 8, this[Ze + 1] = 255 & $e, Ze + 2;
    }, u$1$1.prototype.writeUInt32LE = function($e, Ze, Fe) {
      return $e = +$e, Ze >>>= 0, Fe || C2(this, $e, Ze, 4, 4294967295, 0), this[Ze + 3] = $e >>> 24, this[Ze + 2] = $e >>> 16, this[Ze + 1] = $e >>> 8, this[Ze] = 255 & $e, Ze + 4;
    }, u$1$1.prototype.writeUInt32BE = function($e, Ze, Fe) {
      return $e = +$e, Ze >>>= 0, Fe || C2(this, $e, Ze, 4, 4294967295, 0), this[Ze] = $e >>> 24, this[Ze + 1] = $e >>> 16, this[Ze + 2] = $e >>> 8, this[Ze + 3] = 255 & $e, Ze + 4;
    }, u$1$1.prototype.writeIntLE = function($e, Ze, Fe, Ke) {
      if ($e = +$e, Ze >>>= 0, !Ke) {
        var Ve = Math.pow(2, 8 * Fe - 1);
        C2(this, $e, Ze, Fe, Ve - 1, -Ve);
      }
      var Je = 0, Qe = 1, at = 0;
      for (this[Ze] = 255 & $e; ++Je < Fe && (Qe *= 256); )
        $e < 0 && at === 0 && this[Ze + Je - 1] !== 0 && (at = 1), this[Ze + Je] = ($e / Qe >> 0) - at & 255;
      return Ze + Fe;
    }, u$1$1.prototype.writeIntBE = function($e, Ze, Fe, Ke) {
      if ($e = +$e, Ze >>>= 0, !Ke) {
        var Ve = Math.pow(2, 8 * Fe - 1);
        C2(this, $e, Ze, Fe, Ve - 1, -Ve);
      }
      var Je = Fe - 1, Qe = 1, at = 0;
      for (this[Ze + Je] = 255 & $e; --Je >= 0 && (Qe *= 256); )
        $e < 0 && at === 0 && this[Ze + Je + 1] !== 0 && (at = 1), this[Ze + Je] = ($e / Qe >> 0) - at & 255;
      return Ze + Fe;
    }, u$1$1.prototype.writeInt8 = function($e, Ze, Fe) {
      return $e = +$e, Ze >>>= 0, Fe || C2(this, $e, Ze, 1, 127, -128), $e < 0 && ($e = 255 + $e + 1), this[Ze] = 255 & $e, Ze + 1;
    }, u$1$1.prototype.writeInt16LE = function($e, Ze, Fe) {
      return $e = +$e, Ze >>>= 0, Fe || C2(this, $e, Ze, 2, 32767, -32768), this[Ze] = 255 & $e, this[Ze + 1] = $e >>> 8, Ze + 2;
    }, u$1$1.prototype.writeInt16BE = function($e, Ze, Fe) {
      return $e = +$e, Ze >>>= 0, Fe || C2(this, $e, Ze, 2, 32767, -32768), this[Ze] = $e >>> 8, this[Ze + 1] = 255 & $e, Ze + 2;
    }, u$1$1.prototype.writeInt32LE = function($e, Ze, Fe) {
      return $e = +$e, Ze >>>= 0, Fe || C2(this, $e, Ze, 4, 2147483647, -2147483648), this[Ze] = 255 & $e, this[Ze + 1] = $e >>> 8, this[Ze + 2] = $e >>> 16, this[Ze + 3] = $e >>> 24, Ze + 4;
    }, u$1$1.prototype.writeInt32BE = function($e, Ze, Fe) {
      return $e = +$e, Ze >>>= 0, Fe || C2(this, $e, Ze, 4, 2147483647, -2147483648), $e < 0 && ($e = 4294967295 + $e + 1), this[Ze] = $e >>> 24, this[Ze + 1] = $e >>> 16, this[Ze + 2] = $e >>> 8, this[Ze + 3] = 255 & $e, Ze + 4;
    }, u$1$1.prototype.writeFloatLE = function($e, Ze, Fe) {
      return k2(this, $e, Ze, !0, Fe);
    }, u$1$1.prototype.writeFloatBE = function($e, Ze, Fe) {
      return k2(this, $e, Ze, !1, Fe);
    }, u$1$1.prototype.writeDoubleLE = function($e, Ze, Fe) {
      return M2(this, $e, Ze, !0, Fe);
    }, u$1$1.prototype.writeDoubleBE = function($e, Ze, Fe) {
      return M2(this, $e, Ze, !1, Fe);
    }, u$1$1.prototype.copy = function($e, Ze, Fe, Ke) {
      if (!u$1$1.isBuffer($e))
        throw new TypeError("argument should be a Buffer");
      if (Fe || (Fe = 0), Ke || Ke === 0 || (Ke = this.length), Ze >= $e.length && (Ze = $e.length), Ze || (Ze = 0), Ke > 0 && Ke < Fe && (Ke = Fe), Ke === Fe || $e.length === 0 || this.length === 0)
        return 0;
      if (Ze < 0)
        throw new RangeError("targetStart out of bounds");
      if (Fe < 0 || Fe >= this.length)
        throw new RangeError("Index out of range");
      if (Ke < 0)
        throw new RangeError("sourceEnd out of bounds");
      Ke > this.length && (Ke = this.length), $e.length - Ze < Ke - Fe && (Ke = $e.length - Ze + Fe);
      var Ve = Ke - Fe;
      if (this === $e && typeof Uint8Array.prototype.copyWithin == "function")
        this.copyWithin(Ze, Fe, Ke);
      else if (this === $e && Fe < Ze && Ze < Ke)
        for (var Je = Ve - 1; Je >= 0; --Je)
          $e[Je + Ze] = this[Je + Fe];
      else
        Uint8Array.prototype.set.call($e, this.subarray(Fe, Ke), Ze);
      return Ve;
    }, u$1$1.prototype.fill = function($e, Ze, Fe, Ke) {
      if (typeof $e == "string") {
        if (typeof Ze == "string" ? (Ke = Ze, Ze = 0, Fe = this.length) : typeof Fe == "string" && (Ke = Fe, Fe = this.length), Ke !== void 0 && typeof Ke != "string")
          throw new TypeError("encoding must be a string");
        if (typeof Ke == "string" && !u$1$1.isEncoding(Ke))
          throw new TypeError("Unknown encoding: " + Ke);
        if ($e.length === 1) {
          var Ve = $e.charCodeAt(0);
          (Ke === "utf8" && Ve < 128 || Ke === "latin1") && ($e = Ve);
        }
      } else
        typeof $e == "number" ? $e &= 255 : typeof $e == "boolean" && ($e = Number($e));
      if (Ze < 0 || this.length < Ze || this.length < Fe)
        throw new RangeError("Out of range index");
      if (Fe <= Ze)
        return this;
      var Je;
      if (Ze >>>= 0, Fe = Fe === void 0 ? this.length : Fe >>> 0, $e || ($e = 0), typeof $e == "number")
        for (Je = Ze; Je < Fe; ++Je)
          this[Je] = $e;
      else {
        var Qe = u$1$1.isBuffer($e) ? $e : u$1$1.from($e, Ke), at = Qe.length;
        if (at === 0)
          throw new TypeError('The value "' + $e + '" is invalid for argument "value"');
        for (Je = 0; Je < Fe - Ze; ++Je)
          this[Je + Ze] = Qe[Je % at];
      }
      return this;
    }, j2 = /[^+/0-9A-Za-z-_]/g, Y2 = function() {
      for (var $e = new Array(256), Ze = 0; Ze < 16; ++Ze)
        for (var Fe = 16 * Ze, Ke = 0; Ke < 16; ++Ke)
          $e[Fe + Ke] = "0123456789abcdef"[Ze] + "0123456789abcdef"[Ke];
      return $e;
    }(), e$1$1$1.Buffer, e$1$1$1.INSPECT_MAX_BYTES, e$1$1$1.kMaxLength, e4 = {}, n4 = e$1$1$1, o4 = n4.Buffer, o4.from && o4.alloc && o4.allocUnsafe && o4.allocUnsafeSlow ? e4 = n4 : (t4(n4, e4), e4.Buffer = f4), f4.prototype = Object.create(o4.prototype), t4(o4, f4), f4.from = function($e, Ze, Fe) {
      if (typeof $e == "number")
        throw new TypeError("Argument must not be a number");
      return o4($e, Ze, Fe);
    }, f4.alloc = function($e, Ze, Fe) {
      if (typeof $e != "number")
        throw new TypeError("Argument must be a number");
      var Ke = o4($e);
      return Ze !== void 0 ? typeof Fe == "string" ? Ke.fill(Ze, Fe) : Ke.fill(Ze) : Ke.fill(0), Ke;
    }, f4.allocUnsafe = function($e) {
      if (typeof $e != "number")
        throw new TypeError("Argument must be a number");
      return o4($e);
    }, f4.allocUnsafeSlow = function($e) {
      if (typeof $e != "number")
        throw new TypeError("Argument must be a number");
      return n4.SlowBuffer($e);
    }, u4 = e4, e$12 = {}, s4 = u4.Buffer, i4 = s4.isEncoding || function($e) {
      switch (($e = "" + $e) && $e.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return !0;
        default:
          return !1;
      }
    }, e$12.StringDecoder = a4, a4.prototype.write = function($e) {
      if ($e.length === 0)
        return "";
      var Ze, Fe;
      if (this.lastNeed) {
        if ((Ze = this.fillLast($e)) === void 0)
          return "";
        Fe = this.lastNeed, this.lastNeed = 0;
      } else
        Fe = 0;
      return Fe < $e.length ? Ze ? Ze + this.text($e, Fe) : this.text($e, Fe) : Ze || "";
    }, a4.prototype.end = function($e) {
      var Ze = $e && $e.length ? this.write($e) : "";
      return this.lastNeed ? Ze + "�" : Ze;
    }, a4.prototype.text = function($e, Ze) {
      var Fe = function(Ve, Je, Qe) {
        var at = Je.length - 1;
        if (at < Qe)
          return 0;
        var ut = r4(Je[at]);
        return ut >= 0 ? (ut > 0 && (Ve.lastNeed = ut - 1), ut) : --at < Qe || ut === -2 ? 0 : (ut = r4(Je[at])) >= 0 ? (ut > 0 && (Ve.lastNeed = ut - 2), ut) : --at < Qe || ut === -2 ? 0 : (ut = r4(Je[at])) >= 0 ? (ut > 0 && (ut === 2 ? ut = 0 : Ve.lastNeed = ut - 3), ut) : 0;
      }(this, $e, Ze);
      if (!this.lastNeed)
        return $e.toString("utf8", Ze);
      this.lastTotal = Fe;
      var Ke = $e.length - (Fe - this.lastNeed);
      return $e.copy(this.lastChar, 0, Ke), $e.toString("utf8", Ze, Ke);
    }, a4.prototype.fillLast = function($e) {
      if (this.lastNeed <= $e.length)
        return $e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      $e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, $e.length), this.lastNeed -= $e.length;
    }, e$12.StringDecoder, e$12.StringDecoder;
  }
});
function dew$2$1() {
  if (_dewExec$2$1)
    return exports$2$1;
  _dewExec$2$1 = !0, exports$2$1.byteLength = at, exports$2$1.toByteArray = lt, exports$2$1.fromByteArray = $t;
  for (var $e = [], Ze = [], Fe = typeof Uint8Array < "u" ? Uint8Array : Array, Ke = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Ve = 0, Je = Ke.length; Ve < Je; ++Ve)
    $e[Ve] = Ke[Ve], Ze[Ke.charCodeAt(Ve)] = Ve;
  Ze["-".charCodeAt(0)] = 62, Ze["_".charCodeAt(0)] = 63;
  function Qe(vt) {
    var wt = vt.length;
    if (wt % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var xt = vt.indexOf("=");
    xt === -1 && (xt = wt);
    var Et = xt === wt ? 0 : 4 - xt % 4;
    return [xt, Et];
  }
  function at(vt) {
    var wt = Qe(vt), xt = wt[0], Et = wt[1];
    return (xt + Et) * 3 / 4 - Et;
  }
  function ut(vt, wt, xt) {
    return (wt + xt) * 3 / 4 - xt;
  }
  function lt(vt) {
    var wt, xt = Qe(vt), Et = xt[0], Tt = xt[1], Rt = new Fe(ut(vt, Et, Tt)), Ct = 0, Zt = Tt > 0 ? Et - 4 : Et, Lt;
    for (Lt = 0; Lt < Zt; Lt += 4)
      wt = Ze[vt.charCodeAt(Lt)] << 18 | Ze[vt.charCodeAt(Lt + 1)] << 12 | Ze[vt.charCodeAt(Lt + 2)] << 6 | Ze[vt.charCodeAt(Lt + 3)], Rt[Ct++] = wt >> 16 & 255, Rt[Ct++] = wt >> 8 & 255, Rt[Ct++] = wt & 255;
    return Tt === 2 && (wt = Ze[vt.charCodeAt(Lt)] << 2 | Ze[vt.charCodeAt(Lt + 1)] >> 4, Rt[Ct++] = wt & 255), Tt === 1 && (wt = Ze[vt.charCodeAt(Lt)] << 10 | Ze[vt.charCodeAt(Lt + 1)] << 4 | Ze[vt.charCodeAt(Lt + 2)] >> 2, Rt[Ct++] = wt >> 8 & 255, Rt[Ct++] = wt & 255), Rt;
  }
  function dt(vt) {
    return $e[vt >> 18 & 63] + $e[vt >> 12 & 63] + $e[vt >> 6 & 63] + $e[vt & 63];
  }
  function bt(vt, wt, xt) {
    for (var Et, Tt = [], Rt = wt; Rt < xt; Rt += 3)
      Et = (vt[Rt] << 16 & 16711680) + (vt[Rt + 1] << 8 & 65280) + (vt[Rt + 2] & 255), Tt.push(dt(Et));
    return Tt.join("");
  }
  function $t(vt) {
    for (var wt, xt = vt.length, Et = xt % 3, Tt = [], Rt = 16383, Ct = 0, Zt = xt - Et; Ct < Zt; Ct += Rt)
      Tt.push(bt(vt, Ct, Ct + Rt > Zt ? Zt : Ct + Rt));
    return Et === 1 ? (wt = vt[xt - 1], Tt.push($e[wt >> 2] + $e[wt << 4 & 63] + "==")) : Et === 2 && (wt = (vt[xt - 2] << 8) + vt[xt - 1], Tt.push($e[wt >> 10] + $e[wt >> 4 & 63] + $e[wt << 2 & 63] + "=")), Tt.join("");
  }
  return exports$2$1;
}
function dew$1$1() {
  return _dewExec$1$1 || (_dewExec$1$1 = !0, exports$1$1.read = function($e, Ze, Fe, Ke, Ve) {
    var Je, Qe, at = Ve * 8 - Ke - 1, ut = (1 << at) - 1, lt = ut >> 1, dt = -7, bt = Fe ? Ve - 1 : 0, $t = Fe ? -1 : 1, vt = $e[Ze + bt];
    for (bt += $t, Je = vt & (1 << -dt) - 1, vt >>= -dt, dt += at; dt > 0; Je = Je * 256 + $e[Ze + bt], bt += $t, dt -= 8)
      ;
    for (Qe = Je & (1 << -dt) - 1, Je >>= -dt, dt += Ke; dt > 0; Qe = Qe * 256 + $e[Ze + bt], bt += $t, dt -= 8)
      ;
    if (Je === 0)
      Je = 1 - lt;
    else {
      if (Je === ut)
        return Qe ? NaN : (vt ? -1 : 1) * (1 / 0);
      Qe = Qe + Math.pow(2, Ke), Je = Je - lt;
    }
    return (vt ? -1 : 1) * Qe * Math.pow(2, Je - Ke);
  }, exports$1$1.write = function($e, Ze, Fe, Ke, Ve, Je) {
    var Qe, at, ut, lt = Je * 8 - Ve - 1, dt = (1 << lt) - 1, bt = dt >> 1, $t = Ve === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, vt = Ke ? 0 : Je - 1, wt = Ke ? 1 : -1, xt = Ze < 0 || Ze === 0 && 1 / Ze < 0 ? 1 : 0;
    for (Ze = Math.abs(Ze), isNaN(Ze) || Ze === 1 / 0 ? (at = isNaN(Ze) ? 1 : 0, Qe = dt) : (Qe = Math.floor(Math.log(Ze) / Math.LN2), Ze * (ut = Math.pow(2, -Qe)) < 1 && (Qe--, ut *= 2), Qe + bt >= 1 ? Ze += $t / ut : Ze += $t * Math.pow(2, 1 - bt), Ze * ut >= 2 && (Qe++, ut /= 2), Qe + bt >= dt ? (at = 0, Qe = dt) : Qe + bt >= 1 ? (at = (Ze * ut - 1) * Math.pow(2, Ve), Qe = Qe + bt) : (at = Ze * Math.pow(2, bt - 1) * Math.pow(2, Ve), Qe = 0)); Ve >= 8; $e[Fe + vt] = at & 255, vt += wt, at /= 256, Ve -= 8)
      ;
    for (Qe = Qe << Ve | at, lt += Ve; lt > 0; $e[Fe + vt] = Qe & 255, vt += wt, Qe /= 256, lt -= 8)
      ;
    $e[Fe + vt - wt] |= xt * 128;
  }), exports$1$1;
}
function dew$g() {
  if (_dewExec$g)
    return exports$g;
  _dewExec$g = !0;
  const $e = dew$2$1(), Ze = dew$1$1(), Fe = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  exports$g.Buffer = Qe, exports$g.SlowBuffer = Tt, exports$g.INSPECT_MAX_BYTES = 50;
  const Ke = 2147483647;
  exports$g.kMaxLength = Ke, Qe.TYPED_ARRAY_SUPPORT = Ve(), !Qe.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function Ve() {
    try {
      const Bt = new Uint8Array(1), kt = {
        foo: function() {
          return 42;
        }
      };
      return Object.setPrototypeOf(kt, Uint8Array.prototype), Object.setPrototypeOf(Bt, kt), Bt.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(Qe.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (Qe.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(Qe.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (Qe.isBuffer(this))
        return this.byteOffset;
    }
  });
  function Je(Bt) {
    if (Bt > Ke)
      throw new RangeError('The value "' + Bt + '" is invalid for option "size"');
    const kt = new Uint8Array(Bt);
    return Object.setPrototypeOf(kt, Qe.prototype), kt;
  }
  function Qe(Bt, kt, It) {
    if (typeof Bt == "number") {
      if (typeof kt == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return dt(Bt);
    }
    return at(Bt, kt, It);
  }
  Qe.poolSize = 8192;
  function at(Bt, kt, It) {
    if (typeof Bt == "string")
      return bt(Bt, kt);
    if (ArrayBuffer.isView(Bt))
      return vt(Bt);
    if (Bt == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Bt);
    if (lr(Bt, ArrayBuffer) || Bt && lr(Bt.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (lr(Bt, SharedArrayBuffer) || Bt && lr(Bt.buffer, SharedArrayBuffer)))
      return wt(Bt, kt, It);
    if (typeof Bt == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    const jt = Bt.valueOf && Bt.valueOf();
    if (jt != null && jt !== Bt)
      return Qe.from(jt, kt, It);
    const Vt = xt(Bt);
    if (Vt)
      return Vt;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Bt[Symbol.toPrimitive] == "function")
      return Qe.from(Bt[Symbol.toPrimitive]("string"), kt, It);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Bt);
  }
  Qe.from = function(Bt, kt, It) {
    return at(Bt, kt, It);
  }, Object.setPrototypeOf(Qe.prototype, Uint8Array.prototype), Object.setPrototypeOf(Qe, Uint8Array);
  function ut(Bt) {
    if (typeof Bt != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Bt < 0)
      throw new RangeError('The value "' + Bt + '" is invalid for option "size"');
  }
  function lt(Bt, kt, It) {
    return ut(Bt), Bt <= 0 ? Je(Bt) : kt !== void 0 ? typeof It == "string" ? Je(Bt).fill(kt, It) : Je(Bt).fill(kt) : Je(Bt);
  }
  Qe.alloc = function(Bt, kt, It) {
    return lt(Bt, kt, It);
  };
  function dt(Bt) {
    return ut(Bt), Je(Bt < 0 ? 0 : Et(Bt) | 0);
  }
  Qe.allocUnsafe = function(Bt) {
    return dt(Bt);
  }, Qe.allocUnsafeSlow = function(Bt) {
    return dt(Bt);
  };
  function bt(Bt, kt) {
    if ((typeof kt != "string" || kt === "") && (kt = "utf8"), !Qe.isEncoding(kt))
      throw new TypeError("Unknown encoding: " + kt);
    const It = Rt(Bt, kt) | 0;
    let jt = Je(It);
    const Vt = jt.write(Bt, kt);
    return Vt !== It && (jt = jt.slice(0, Vt)), jt;
  }
  function $t(Bt) {
    const kt = Bt.length < 0 ? 0 : Et(Bt.length) | 0, It = Je(kt);
    for (let jt = 0; jt < kt; jt += 1)
      It[jt] = Bt[jt] & 255;
    return It;
  }
  function vt(Bt) {
    if (lr(Bt, Uint8Array)) {
      const kt = new Uint8Array(Bt);
      return wt(kt.buffer, kt.byteOffset, kt.byteLength);
    }
    return $t(Bt);
  }
  function wt(Bt, kt, It) {
    if (kt < 0 || Bt.byteLength < kt)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Bt.byteLength < kt + (It || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let jt;
    return kt === void 0 && It === void 0 ? jt = new Uint8Array(Bt) : It === void 0 ? jt = new Uint8Array(Bt, kt) : jt = new Uint8Array(Bt, kt, It), Object.setPrototypeOf(jt, Qe.prototype), jt;
  }
  function xt(Bt) {
    if (Qe.isBuffer(Bt)) {
      const kt = Et(Bt.length) | 0, It = Je(kt);
      return It.length === 0 || Bt.copy(It, 0, 0, kt), It;
    }
    if (Bt.length !== void 0)
      return typeof Bt.length != "number" || Nr(Bt.length) ? Je(0) : $t(Bt);
    if (Bt.type === "Buffer" && Array.isArray(Bt.data))
      return $t(Bt.data);
  }
  function Et(Bt) {
    if (Bt >= Ke)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Ke.toString(16) + " bytes");
    return Bt | 0;
  }
  function Tt(Bt) {
    return +Bt != Bt && (Bt = 0), Qe.alloc(+Bt);
  }
  Qe.isBuffer = function(kt) {
    return kt != null && kt._isBuffer === !0 && kt !== Qe.prototype;
  }, Qe.compare = function(kt, It) {
    if (lr(kt, Uint8Array) && (kt = Qe.from(kt, kt.offset, kt.byteLength)), lr(It, Uint8Array) && (It = Qe.from(It, It.offset, It.byteLength)), !Qe.isBuffer(kt) || !Qe.isBuffer(It))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (kt === It)
      return 0;
    let jt = kt.length, Vt = It.length;
    for (let ar = 0, Yt = Math.min(jt, Vt); ar < Yt; ++ar)
      if (kt[ar] !== It[ar]) {
        jt = kt[ar], Vt = It[ar];
        break;
      }
    return jt < Vt ? -1 : Vt < jt ? 1 : 0;
  }, Qe.isEncoding = function(kt) {
    switch (String(kt).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, Qe.concat = function(kt, It) {
    if (!Array.isArray(kt))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (kt.length === 0)
      return Qe.alloc(0);
    let jt;
    if (It === void 0)
      for (It = 0, jt = 0; jt < kt.length; ++jt)
        It += kt[jt].length;
    const Vt = Qe.allocUnsafe(It);
    let ar = 0;
    for (jt = 0; jt < kt.length; ++jt) {
      let Yt = kt[jt];
      if (lr(Yt, Uint8Array))
        ar + Yt.length > Vt.length ? (Qe.isBuffer(Yt) || (Yt = Qe.from(Yt)), Yt.copy(Vt, ar)) : Uint8Array.prototype.set.call(Vt, Yt, ar);
      else if (Qe.isBuffer(Yt))
        Yt.copy(Vt, ar);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      ar += Yt.length;
    }
    return Vt;
  };
  function Rt(Bt, kt) {
    if (Qe.isBuffer(Bt))
      return Bt.length;
    if (ArrayBuffer.isView(Bt) || lr(Bt, ArrayBuffer))
      return Bt.byteLength;
    if (typeof Bt != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Bt);
    const It = Bt.length, jt = arguments.length > 2 && arguments[2] === !0;
    if (!jt && It === 0)
      return 0;
    let Vt = !1;
    for (; ; )
      switch (kt) {
        case "ascii":
        case "latin1":
        case "binary":
          return It;
        case "utf8":
        case "utf-8":
          return sr(Bt).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return It * 2;
        case "hex":
          return It >>> 1;
        case "base64":
          return Br(Bt).length;
        default:
          if (Vt)
            return jt ? -1 : sr(Bt).length;
          kt = ("" + kt).toLowerCase(), Vt = !0;
      }
  }
  Qe.byteLength = Rt;
  function Ct(Bt, kt, It) {
    let jt = !1;
    if ((kt === void 0 || kt < 0) && (kt = 0), kt > this.length || ((It === void 0 || It > this.length) && (It = this.length), It <= 0) || (It >>>= 0, kt >>>= 0, It <= kt))
      return "";
    for (Bt || (Bt = "utf8"); ; )
      switch (Bt) {
        case "hex":
          return pt(this, kt, It);
        case "utf8":
        case "utf-8":
          return rt(this, kt, It);
        case "ascii":
          return mt(this, kt, It);
        case "latin1":
        case "binary":
          return yt(this, kt, It);
        case "base64":
          return Xe(this, kt, It);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ge(this, kt, It);
        default:
          if (jt)
            throw new TypeError("Unknown encoding: " + Bt);
          Bt = (Bt + "").toLowerCase(), jt = !0;
      }
  }
  Qe.prototype._isBuffer = !0;
  function Zt(Bt, kt, It) {
    const jt = Bt[kt];
    Bt[kt] = Bt[It], Bt[It] = jt;
  }
  Qe.prototype.swap16 = function() {
    const kt = this.length;
    if (kt % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let It = 0; It < kt; It += 2)
      Zt(this, It, It + 1);
    return this;
  }, Qe.prototype.swap32 = function() {
    const kt = this.length;
    if (kt % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let It = 0; It < kt; It += 4)
      Zt(this, It, It + 3), Zt(this, It + 1, It + 2);
    return this;
  }, Qe.prototype.swap64 = function() {
    const kt = this.length;
    if (kt % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let It = 0; It < kt; It += 8)
      Zt(this, It, It + 7), Zt(this, It + 1, It + 6), Zt(this, It + 2, It + 5), Zt(this, It + 3, It + 4);
    return this;
  }, Qe.prototype.toString = function() {
    const kt = this.length;
    return kt === 0 ? "" : arguments.length === 0 ? rt(this, 0, kt) : Ct.apply(this, arguments);
  }, Qe.prototype.toLocaleString = Qe.prototype.toString, Qe.prototype.equals = function(kt) {
    if (!Qe.isBuffer(kt))
      throw new TypeError("Argument must be a Buffer");
    return this === kt ? !0 : Qe.compare(this, kt) === 0;
  }, Qe.prototype.inspect = function() {
    let kt = "";
    const It = exports$g.INSPECT_MAX_BYTES;
    return kt = this.toString("hex", 0, It).replace(/(.{2})/g, "$1 ").trim(), this.length > It && (kt += " ... "), "<Buffer " + kt + ">";
  }, Fe && (Qe.prototype[Fe] = Qe.prototype.inspect), Qe.prototype.compare = function(kt, It, jt, Vt, ar) {
    if (lr(kt, Uint8Array) && (kt = Qe.from(kt, kt.offset, kt.byteLength)), !Qe.isBuffer(kt))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof kt);
    if (It === void 0 && (It = 0), jt === void 0 && (jt = kt ? kt.length : 0), Vt === void 0 && (Vt = 0), ar === void 0 && (ar = this.length), It < 0 || jt > kt.length || Vt < 0 || ar > this.length)
      throw new RangeError("out of range index");
    if (Vt >= ar && It >= jt)
      return 0;
    if (Vt >= ar)
      return -1;
    if (It >= jt)
      return 1;
    if (It >>>= 0, jt >>>= 0, Vt >>>= 0, ar >>>= 0, this === kt)
      return 0;
    let Yt = ar - Vt, hr = jt - It;
    const zr = Math.min(Yt, hr), cr = this.slice(Vt, ar), _r = kt.slice(It, jt);
    for (let Lr = 0; Lr < zr; ++Lr)
      if (cr[Lr] !== _r[Lr]) {
        Yt = cr[Lr], hr = _r[Lr];
        break;
      }
    return Yt < hr ? -1 : hr < Yt ? 1 : 0;
  };
  function Lt(Bt, kt, It, jt, Vt) {
    if (Bt.length === 0)
      return -1;
    if (typeof It == "string" ? (jt = It, It = 0) : It > 2147483647 ? It = 2147483647 : It < -2147483648 && (It = -2147483648), It = +It, Nr(It) && (It = Vt ? 0 : Bt.length - 1), It < 0 && (It = Bt.length + It), It >= Bt.length) {
      if (Vt)
        return -1;
      It = Bt.length - 1;
    } else if (It < 0)
      if (Vt)
        It = 0;
      else
        return -1;
    if (typeof kt == "string" && (kt = Qe.from(kt, jt)), Qe.isBuffer(kt))
      return kt.length === 0 ? -1 : Ut(Bt, kt, It, jt, Vt);
    if (typeof kt == "number")
      return kt = kt & 255, typeof Uint8Array.prototype.indexOf == "function" ? Vt ? Uint8Array.prototype.indexOf.call(Bt, kt, It) : Uint8Array.prototype.lastIndexOf.call(Bt, kt, It) : Ut(Bt, [kt], It, jt, Vt);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Ut(Bt, kt, It, jt, Vt) {
    let ar = 1, Yt = Bt.length, hr = kt.length;
    if (jt !== void 0 && (jt = String(jt).toLowerCase(), jt === "ucs2" || jt === "ucs-2" || jt === "utf16le" || jt === "utf-16le")) {
      if (Bt.length < 2 || kt.length < 2)
        return -1;
      ar = 2, Yt /= 2, hr /= 2, It /= 2;
    }
    function zr(_r, Lr) {
      return ar === 1 ? _r[Lr] : _r.readUInt16BE(Lr * ar);
    }
    let cr;
    if (Vt) {
      let _r = -1;
      for (cr = It; cr < Yt; cr++)
        if (zr(Bt, cr) === zr(kt, _r === -1 ? 0 : cr - _r)) {
          if (_r === -1 && (_r = cr), cr - _r + 1 === hr)
            return _r * ar;
        } else
          _r !== -1 && (cr -= cr - _r), _r = -1;
    } else
      for (It + hr > Yt && (It = Yt - hr), cr = It; cr >= 0; cr--) {
        let _r = !0;
        for (let Lr = 0; Lr < hr; Lr++)
          if (zr(Bt, cr + Lr) !== zr(kt, Lr)) {
            _r = !1;
            break;
          }
        if (_r)
          return cr;
      }
    return -1;
  }
  Qe.prototype.includes = function(kt, It, jt) {
    return this.indexOf(kt, It, jt) !== -1;
  }, Qe.prototype.indexOf = function(kt, It, jt) {
    return Lt(this, kt, It, jt, !0);
  }, Qe.prototype.lastIndexOf = function(kt, It, jt) {
    return Lt(this, kt, It, jt, !1);
  };
  function Pt(Bt, kt, It, jt) {
    It = Number(It) || 0;
    const Vt = Bt.length - It;
    jt ? (jt = Number(jt), jt > Vt && (jt = Vt)) : jt = Vt;
    const ar = kt.length;
    jt > ar / 2 && (jt = ar / 2);
    let Yt;
    for (Yt = 0; Yt < jt; ++Yt) {
      const hr = parseInt(kt.substr(Yt * 2, 2), 16);
      if (Nr(hr))
        return Yt;
      Bt[It + Yt] = hr;
    }
    return Yt;
  }
  function Ot(Bt, kt, It, jt) {
    return or(sr(kt, Bt.length - It), Bt, It, jt);
  }
  function Ft(Bt, kt, It, jt) {
    return or(Jt(kt), Bt, It, jt);
  }
  function gt(Bt, kt, It, jt) {
    return or(Br(kt), Bt, It, jt);
  }
  function We(Bt, kt, It, jt) {
    return or(ir(kt, Bt.length - It), Bt, It, jt);
  }
  Qe.prototype.write = function(kt, It, jt, Vt) {
    if (It === void 0)
      Vt = "utf8", jt = this.length, It = 0;
    else if (jt === void 0 && typeof It == "string")
      Vt = It, jt = this.length, It = 0;
    else if (isFinite(It))
      It = It >>> 0, isFinite(jt) ? (jt = jt >>> 0, Vt === void 0 && (Vt = "utf8")) : (Vt = jt, jt = void 0);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const ar = this.length - It;
    if ((jt === void 0 || jt > ar) && (jt = ar), kt.length > 0 && (jt < 0 || It < 0) || It > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Vt || (Vt = "utf8");
    let Yt = !1;
    for (; ; )
      switch (Vt) {
        case "hex":
          return Pt(this, kt, It, jt);
        case "utf8":
        case "utf-8":
          return Ot(this, kt, It, jt);
        case "ascii":
        case "latin1":
        case "binary":
          return Ft(this, kt, It, jt);
        case "base64":
          return gt(this, kt, It, jt);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return We(this, kt, It, jt);
        default:
          if (Yt)
            throw new TypeError("Unknown encoding: " + Vt);
          Vt = ("" + Vt).toLowerCase(), Yt = !0;
      }
  }, Qe.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Xe(Bt, kt, It) {
    return kt === 0 && It === Bt.length ? $e.fromByteArray(Bt) : $e.fromByteArray(Bt.slice(kt, It));
  }
  function rt(Bt, kt, It) {
    It = Math.min(Bt.length, It);
    const jt = [];
    let Vt = kt;
    for (; Vt < It; ) {
      const ar = Bt[Vt];
      let Yt = null, hr = ar > 239 ? 4 : ar > 223 ? 3 : ar > 191 ? 2 : 1;
      if (Vt + hr <= It) {
        let zr, cr, _r, Lr;
        switch (hr) {
          case 1:
            ar < 128 && (Yt = ar);
            break;
          case 2:
            zr = Bt[Vt + 1], (zr & 192) === 128 && (Lr = (ar & 31) << 6 | zr & 63, Lr > 127 && (Yt = Lr));
            break;
          case 3:
            zr = Bt[Vt + 1], cr = Bt[Vt + 2], (zr & 192) === 128 && (cr & 192) === 128 && (Lr = (ar & 15) << 12 | (zr & 63) << 6 | cr & 63, Lr > 2047 && (Lr < 55296 || Lr > 57343) && (Yt = Lr));
            break;
          case 4:
            zr = Bt[Vt + 1], cr = Bt[Vt + 2], _r = Bt[Vt + 3], (zr & 192) === 128 && (cr & 192) === 128 && (_r & 192) === 128 && (Lr = (ar & 15) << 18 | (zr & 63) << 12 | (cr & 63) << 6 | _r & 63, Lr > 65535 && Lr < 1114112 && (Yt = Lr));
        }
      }
      Yt === null ? (Yt = 65533, hr = 1) : Yt > 65535 && (Yt -= 65536, jt.push(Yt >>> 10 & 1023 | 55296), Yt = 56320 | Yt & 1023), jt.push(Yt), Vt += hr;
    }
    return ft(jt);
  }
  const ot = 4096;
  function ft(Bt) {
    const kt = Bt.length;
    if (kt <= ot)
      return String.fromCharCode.apply(String, Bt);
    let It = "", jt = 0;
    for (; jt < kt; )
      It += String.fromCharCode.apply(String, Bt.slice(jt, jt += ot));
    return It;
  }
  function mt(Bt, kt, It) {
    let jt = "";
    It = Math.min(Bt.length, It);
    for (let Vt = kt; Vt < It; ++Vt)
      jt += String.fromCharCode(Bt[Vt] & 127);
    return jt;
  }
  function yt(Bt, kt, It) {
    let jt = "";
    It = Math.min(Bt.length, It);
    for (let Vt = kt; Vt < It; ++Vt)
      jt += String.fromCharCode(Bt[Vt]);
    return jt;
  }
  function pt(Bt, kt, It) {
    const jt = Bt.length;
    (!kt || kt < 0) && (kt = 0), (!It || It < 0 || It > jt) && (It = jt);
    let Vt = "";
    for (let ar = kt; ar < It; ++ar)
      Vt += dr[Bt[ar]];
    return Vt;
  }
  function Ge(Bt, kt, It) {
    const jt = Bt.slice(kt, It);
    let Vt = "";
    for (let ar = 0; ar < jt.length - 1; ar += 2)
      Vt += String.fromCharCode(jt[ar] + jt[ar + 1] * 256);
    return Vt;
  }
  Qe.prototype.slice = function(kt, It) {
    const jt = this.length;
    kt = ~~kt, It = It === void 0 ? jt : ~~It, kt < 0 ? (kt += jt, kt < 0 && (kt = 0)) : kt > jt && (kt = jt), It < 0 ? (It += jt, It < 0 && (It = 0)) : It > jt && (It = jt), It < kt && (It = kt);
    const Vt = this.subarray(kt, It);
    return Object.setPrototypeOf(Vt, Qe.prototype), Vt;
  };
  function ct(Bt, kt, It) {
    if (Bt % 1 !== 0 || Bt < 0)
      throw new RangeError("offset is not uint");
    if (Bt + kt > It)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Qe.prototype.readUintLE = Qe.prototype.readUIntLE = function(kt, It, jt) {
    kt = kt >>> 0, It = It >>> 0, jt || ct(kt, It, this.length);
    let Vt = this[kt], ar = 1, Yt = 0;
    for (; ++Yt < It && (ar *= 256); )
      Vt += this[kt + Yt] * ar;
    return Vt;
  }, Qe.prototype.readUintBE = Qe.prototype.readUIntBE = function(kt, It, jt) {
    kt = kt >>> 0, It = It >>> 0, jt || ct(kt, It, this.length);
    let Vt = this[kt + --It], ar = 1;
    for (; It > 0 && (ar *= 256); )
      Vt += this[kt + --It] * ar;
    return Vt;
  }, Qe.prototype.readUint8 = Qe.prototype.readUInt8 = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 1, this.length), this[kt];
  }, Qe.prototype.readUint16LE = Qe.prototype.readUInt16LE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 2, this.length), this[kt] | this[kt + 1] << 8;
  }, Qe.prototype.readUint16BE = Qe.prototype.readUInt16BE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 2, this.length), this[kt] << 8 | this[kt + 1];
  }, Qe.prototype.readUint32LE = Qe.prototype.readUInt32LE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 4, this.length), (this[kt] | this[kt + 1] << 8 | this[kt + 2] << 16) + this[kt + 3] * 16777216;
  }, Qe.prototype.readUint32BE = Qe.prototype.readUInt32BE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 4, this.length), this[kt] * 16777216 + (this[kt + 1] << 16 | this[kt + 2] << 8 | this[kt + 3]);
  }, Qe.prototype.readBigUInt64LE = gr(function(kt) {
    kt = kt >>> 0, Dt(kt, "offset");
    const It = this[kt], jt = this[kt + 7];
    (It === void 0 || jt === void 0) && Ht(kt, this.length - 8);
    const Vt = It + this[++kt] * 2 ** 8 + this[++kt] * 2 ** 16 + this[++kt] * 2 ** 24, ar = this[++kt] + this[++kt] * 2 ** 8 + this[++kt] * 2 ** 16 + jt * 2 ** 24;
    return BigInt(Vt) + (BigInt(ar) << BigInt(32));
  }), Qe.prototype.readBigUInt64BE = gr(function(kt) {
    kt = kt >>> 0, Dt(kt, "offset");
    const It = this[kt], jt = this[kt + 7];
    (It === void 0 || jt === void 0) && Ht(kt, this.length - 8);
    const Vt = It * 2 ** 24 + this[++kt] * 2 ** 16 + this[++kt] * 2 ** 8 + this[++kt], ar = this[++kt] * 2 ** 24 + this[++kt] * 2 ** 16 + this[++kt] * 2 ** 8 + jt;
    return (BigInt(Vt) << BigInt(32)) + BigInt(ar);
  }), Qe.prototype.readIntLE = function(kt, It, jt) {
    kt = kt >>> 0, It = It >>> 0, jt || ct(kt, It, this.length);
    let Vt = this[kt], ar = 1, Yt = 0;
    for (; ++Yt < It && (ar *= 256); )
      Vt += this[kt + Yt] * ar;
    return ar *= 128, Vt >= ar && (Vt -= Math.pow(2, 8 * It)), Vt;
  }, Qe.prototype.readIntBE = function(kt, It, jt) {
    kt = kt >>> 0, It = It >>> 0, jt || ct(kt, It, this.length);
    let Vt = It, ar = 1, Yt = this[kt + --Vt];
    for (; Vt > 0 && (ar *= 256); )
      Yt += this[kt + --Vt] * ar;
    return ar *= 128, Yt >= ar && (Yt -= Math.pow(2, 8 * It)), Yt;
  }, Qe.prototype.readInt8 = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 1, this.length), this[kt] & 128 ? (255 - this[kt] + 1) * -1 : this[kt];
  }, Qe.prototype.readInt16LE = function(kt, It) {
    kt = kt >>> 0, It || ct(kt, 2, this.length);
    const jt = this[kt] | this[kt + 1] << 8;
    return jt & 32768 ? jt | 4294901760 : jt;
  }, Qe.prototype.readInt16BE = function(kt, It) {
    kt = kt >>> 0, It || ct(kt, 2, this.length);
    const jt = this[kt + 1] | this[kt] << 8;
    return jt & 32768 ? jt | 4294901760 : jt;
  }, Qe.prototype.readInt32LE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 4, this.length), this[kt] | this[kt + 1] << 8 | this[kt + 2] << 16 | this[kt + 3] << 24;
  }, Qe.prototype.readInt32BE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 4, this.length), this[kt] << 24 | this[kt + 1] << 16 | this[kt + 2] << 8 | this[kt + 3];
  }, Qe.prototype.readBigInt64LE = gr(function(kt) {
    kt = kt >>> 0, Dt(kt, "offset");
    const It = this[kt], jt = this[kt + 7];
    (It === void 0 || jt === void 0) && Ht(kt, this.length - 8);
    const Vt = this[kt + 4] + this[kt + 5] * 2 ** 8 + this[kt + 6] * 2 ** 16 + (jt << 24);
    return (BigInt(Vt) << BigInt(32)) + BigInt(It + this[++kt] * 2 ** 8 + this[++kt] * 2 ** 16 + this[++kt] * 2 ** 24);
  }), Qe.prototype.readBigInt64BE = gr(function(kt) {
    kt = kt >>> 0, Dt(kt, "offset");
    const It = this[kt], jt = this[kt + 7];
    (It === void 0 || jt === void 0) && Ht(kt, this.length - 8);
    const Vt = (It << 24) + this[++kt] * 2 ** 16 + this[++kt] * 2 ** 8 + this[++kt];
    return (BigInt(Vt) << BigInt(32)) + BigInt(this[++kt] * 2 ** 24 + this[++kt] * 2 ** 16 + this[++kt] * 2 ** 8 + jt);
  }), Qe.prototype.readFloatLE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 4, this.length), Ze.read(this, kt, !0, 23, 4);
  }, Qe.prototype.readFloatBE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 4, this.length), Ze.read(this, kt, !1, 23, 4);
  }, Qe.prototype.readDoubleLE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 8, this.length), Ze.read(this, kt, !0, 52, 8);
  }, Qe.prototype.readDoubleBE = function(kt, It) {
    return kt = kt >>> 0, It || ct(kt, 8, this.length), Ze.read(this, kt, !1, 52, 8);
  };
  function Mt(Bt, kt, It, jt, Vt, ar) {
    if (!Qe.isBuffer(Bt))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (kt > Vt || kt < ar)
      throw new RangeError('"value" argument is out of bounds');
    if (It + jt > Bt.length)
      throw new RangeError("Index out of range");
  }
  Qe.prototype.writeUintLE = Qe.prototype.writeUIntLE = function(kt, It, jt, Vt) {
    if (kt = +kt, It = It >>> 0, jt = jt >>> 0, !Vt) {
      const hr = Math.pow(2, 8 * jt) - 1;
      Mt(this, kt, It, jt, hr, 0);
    }
    let ar = 1, Yt = 0;
    for (this[It] = kt & 255; ++Yt < jt && (ar *= 256); )
      this[It + Yt] = kt / ar & 255;
    return It + jt;
  }, Qe.prototype.writeUintBE = Qe.prototype.writeUIntBE = function(kt, It, jt, Vt) {
    if (kt = +kt, It = It >>> 0, jt = jt >>> 0, !Vt) {
      const hr = Math.pow(2, 8 * jt) - 1;
      Mt(this, kt, It, jt, hr, 0);
    }
    let ar = jt - 1, Yt = 1;
    for (this[It + ar] = kt & 255; --ar >= 0 && (Yt *= 256); )
      this[It + ar] = kt / Yt & 255;
    return It + jt;
  }, Qe.prototype.writeUint8 = Qe.prototype.writeUInt8 = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 1, 255, 0), this[It] = kt & 255, It + 1;
  }, Qe.prototype.writeUint16LE = Qe.prototype.writeUInt16LE = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 2, 65535, 0), this[It] = kt & 255, this[It + 1] = kt >>> 8, It + 2;
  }, Qe.prototype.writeUint16BE = Qe.prototype.writeUInt16BE = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 2, 65535, 0), this[It] = kt >>> 8, this[It + 1] = kt & 255, It + 2;
  }, Qe.prototype.writeUint32LE = Qe.prototype.writeUInt32LE = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 4, 4294967295, 0), this[It + 3] = kt >>> 24, this[It + 2] = kt >>> 16, this[It + 1] = kt >>> 8, this[It] = kt & 255, It + 4;
  }, Qe.prototype.writeUint32BE = Qe.prototype.writeUInt32BE = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 4, 4294967295, 0), this[It] = kt >>> 24, this[It + 1] = kt >>> 16, this[It + 2] = kt >>> 8, this[It + 3] = kt & 255, It + 4;
  };
  function St(Bt, kt, It, jt, Vt) {
    er(kt, jt, Vt, Bt, It, 7);
    let ar = Number(kt & BigInt(4294967295));
    Bt[It++] = ar, ar = ar >> 8, Bt[It++] = ar, ar = ar >> 8, Bt[It++] = ar, ar = ar >> 8, Bt[It++] = ar;
    let Yt = Number(kt >> BigInt(32) & BigInt(4294967295));
    return Bt[It++] = Yt, Yt = Yt >> 8, Bt[It++] = Yt, Yt = Yt >> 8, Bt[It++] = Yt, Yt = Yt >> 8, Bt[It++] = Yt, It;
  }
  function At(Bt, kt, It, jt, Vt) {
    er(kt, jt, Vt, Bt, It, 7);
    let ar = Number(kt & BigInt(4294967295));
    Bt[It + 7] = ar, ar = ar >> 8, Bt[It + 6] = ar, ar = ar >> 8, Bt[It + 5] = ar, ar = ar >> 8, Bt[It + 4] = ar;
    let Yt = Number(kt >> BigInt(32) & BigInt(4294967295));
    return Bt[It + 3] = Yt, Yt = Yt >> 8, Bt[It + 2] = Yt, Yt = Yt >> 8, Bt[It + 1] = Yt, Yt = Yt >> 8, Bt[It] = Yt, It + 8;
  }
  Qe.prototype.writeBigUInt64LE = gr(function(kt, It = 0) {
    return St(this, kt, It, BigInt(0), BigInt("0xffffffffffffffff"));
  }), Qe.prototype.writeBigUInt64BE = gr(function(kt, It = 0) {
    return At(this, kt, It, BigInt(0), BigInt("0xffffffffffffffff"));
  }), Qe.prototype.writeIntLE = function(kt, It, jt, Vt) {
    if (kt = +kt, It = It >>> 0, !Vt) {
      const zr = Math.pow(2, 8 * jt - 1);
      Mt(this, kt, It, jt, zr - 1, -zr);
    }
    let ar = 0, Yt = 1, hr = 0;
    for (this[It] = kt & 255; ++ar < jt && (Yt *= 256); )
      kt < 0 && hr === 0 && this[It + ar - 1] !== 0 && (hr = 1), this[It + ar] = (kt / Yt >> 0) - hr & 255;
    return It + jt;
  }, Qe.prototype.writeIntBE = function(kt, It, jt, Vt) {
    if (kt = +kt, It = It >>> 0, !Vt) {
      const zr = Math.pow(2, 8 * jt - 1);
      Mt(this, kt, It, jt, zr - 1, -zr);
    }
    let ar = jt - 1, Yt = 1, hr = 0;
    for (this[It + ar] = kt & 255; --ar >= 0 && (Yt *= 256); )
      kt < 0 && hr === 0 && this[It + ar + 1] !== 0 && (hr = 1), this[It + ar] = (kt / Yt >> 0) - hr & 255;
    return It + jt;
  }, Qe.prototype.writeInt8 = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 1, 127, -128), kt < 0 && (kt = 255 + kt + 1), this[It] = kt & 255, It + 1;
  }, Qe.prototype.writeInt16LE = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 2, 32767, -32768), this[It] = kt & 255, this[It + 1] = kt >>> 8, It + 2;
  }, Qe.prototype.writeInt16BE = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 2, 32767, -32768), this[It] = kt >>> 8, this[It + 1] = kt & 255, It + 2;
  }, Qe.prototype.writeInt32LE = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 4, 2147483647, -2147483648), this[It] = kt & 255, this[It + 1] = kt >>> 8, this[It + 2] = kt >>> 16, this[It + 3] = kt >>> 24, It + 4;
  }, Qe.prototype.writeInt32BE = function(kt, It, jt) {
    return kt = +kt, It = It >>> 0, jt || Mt(this, kt, It, 4, 2147483647, -2147483648), kt < 0 && (kt = 4294967295 + kt + 1), this[It] = kt >>> 24, this[It + 1] = kt >>> 16, this[It + 2] = kt >>> 8, this[It + 3] = kt & 255, It + 4;
  }, Qe.prototype.writeBigInt64LE = gr(function(kt, It = 0) {
    return St(this, kt, It, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), Qe.prototype.writeBigInt64BE = gr(function(kt, It = 0) {
    return At(this, kt, It, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Nt(Bt, kt, It, jt, Vt, ar) {
    if (It + jt > Bt.length)
      throw new RangeError("Index out of range");
    if (It < 0)
      throw new RangeError("Index out of range");
  }
  function qt(Bt, kt, It, jt, Vt) {
    return kt = +kt, It = It >>> 0, Vt || Nt(Bt, kt, It, 4), Ze.write(Bt, kt, It, jt, 23, 4), It + 4;
  }
  Qe.prototype.writeFloatLE = function(kt, It, jt) {
    return qt(this, kt, It, !0, jt);
  }, Qe.prototype.writeFloatBE = function(kt, It, jt) {
    return qt(this, kt, It, !1, jt);
  };
  function Qt(Bt, kt, It, jt, Vt) {
    return kt = +kt, It = It >>> 0, Vt || Nt(Bt, kt, It, 8), Ze.write(Bt, kt, It, jt, 52, 8), It + 8;
  }
  Qe.prototype.writeDoubleLE = function(kt, It, jt) {
    return Qt(this, kt, It, !0, jt);
  }, Qe.prototype.writeDoubleBE = function(kt, It, jt) {
    return Qt(this, kt, It, !1, jt);
  }, Qe.prototype.copy = function(kt, It, jt, Vt) {
    if (!Qe.isBuffer(kt))
      throw new TypeError("argument should be a Buffer");
    if (jt || (jt = 0), !Vt && Vt !== 0 && (Vt = this.length), It >= kt.length && (It = kt.length), It || (It = 0), Vt > 0 && Vt < jt && (Vt = jt), Vt === jt || kt.length === 0 || this.length === 0)
      return 0;
    if (It < 0)
      throw new RangeError("targetStart out of bounds");
    if (jt < 0 || jt >= this.length)
      throw new RangeError("Index out of range");
    if (Vt < 0)
      throw new RangeError("sourceEnd out of bounds");
    Vt > this.length && (Vt = this.length), kt.length - It < Vt - jt && (Vt = kt.length - It + jt);
    const ar = Vt - jt;
    return this === kt && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(It, jt, Vt) : Uint8Array.prototype.set.call(kt, this.subarray(jt, Vt), It), ar;
  }, Qe.prototype.fill = function(kt, It, jt, Vt) {
    if (typeof kt == "string") {
      if (typeof It == "string" ? (Vt = It, It = 0, jt = this.length) : typeof jt == "string" && (Vt = jt, jt = this.length), Vt !== void 0 && typeof Vt != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Vt == "string" && !Qe.isEncoding(Vt))
        throw new TypeError("Unknown encoding: " + Vt);
      if (kt.length === 1) {
        const Yt = kt.charCodeAt(0);
        (Vt === "utf8" && Yt < 128 || Vt === "latin1") && (kt = Yt);
      }
    } else
      typeof kt == "number" ? kt = kt & 255 : typeof kt == "boolean" && (kt = Number(kt));
    if (It < 0 || this.length < It || this.length < jt)
      throw new RangeError("Out of range index");
    if (jt <= It)
      return this;
    It = It >>> 0, jt = jt === void 0 ? this.length : jt >>> 0, kt || (kt = 0);
    let ar;
    if (typeof kt == "number")
      for (ar = It; ar < jt; ++ar)
        this[ar] = kt;
    else {
      const Yt = Qe.isBuffer(kt) ? kt : Qe.from(kt, Vt), hr = Yt.length;
      if (hr === 0)
        throw new TypeError('The value "' + kt + '" is invalid for argument "value"');
      for (ar = 0; ar < jt - It; ++ar)
        this[ar + It] = Yt[ar % hr];
    }
    return this;
  };
  const Xt = {};
  function zt(Bt, kt, It) {
    Xt[Bt] = class extends It {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: kt.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Bt}]`, this.stack, delete this.name;
      }
      get code() {
        return Bt;
      }
      set code(Vt) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Vt,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Bt}]: ${this.message}`;
      }
    };
  }
  zt("ERR_BUFFER_OUT_OF_BOUNDS", function(Bt) {
    return Bt ? `${Bt} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), zt("ERR_INVALID_ARG_TYPE", function(Bt, kt) {
    return `The "${Bt}" argument must be of type number. Received type ${typeof kt}`;
  }, TypeError), zt("ERR_OUT_OF_RANGE", function(Bt, kt, It) {
    let jt = `The value of "${Bt}" is out of range.`, Vt = It;
    return Number.isInteger(It) && Math.abs(It) > 2 ** 32 ? Vt = Kt(String(It)) : typeof It == "bigint" && (Vt = String(It), (It > BigInt(2) ** BigInt(32) || It < -(BigInt(2) ** BigInt(32))) && (Vt = Kt(Vt)), Vt += "n"), jt += ` It must be ${kt}. Received ${Vt}`, jt;
  }, RangeError);
  function Kt(Bt) {
    let kt = "", It = Bt.length;
    const jt = Bt[0] === "-" ? 1 : 0;
    for (; It >= jt + 4; It -= 3)
      kt = `_${Bt.slice(It - 3, It)}${kt}`;
    return `${Bt.slice(0, It)}${kt}`;
  }
  function ur(Bt, kt, It) {
    Dt(kt, "offset"), (Bt[kt] === void 0 || Bt[kt + It] === void 0) && Ht(kt, Bt.length - (It + 1));
  }
  function er(Bt, kt, It, jt, Vt, ar) {
    if (Bt > It || Bt < kt) {
      const Yt = typeof kt == "bigint" ? "n" : "";
      let hr;
      throw ar > 3 ? kt === 0 || kt === BigInt(0) ? hr = `>= 0${Yt} and < 2${Yt} ** ${(ar + 1) * 8}${Yt}` : hr = `>= -(2${Yt} ** ${(ar + 1) * 8 - 1}${Yt}) and < 2 ** ${(ar + 1) * 8 - 1}${Yt}` : hr = `>= ${kt}${Yt} and <= ${It}${Yt}`, new Xt.ERR_OUT_OF_RANGE("value", hr, Bt);
    }
    ur(jt, Vt, ar);
  }
  function Dt(Bt, kt) {
    if (typeof Bt != "number")
      throw new Xt.ERR_INVALID_ARG_TYPE(kt, "number", Bt);
  }
  function Ht(Bt, kt, It) {
    throw Math.floor(Bt) !== Bt ? (Dt(Bt, It), new Xt.ERR_OUT_OF_RANGE(It || "offset", "an integer", Bt)) : kt < 0 ? new Xt.ERR_BUFFER_OUT_OF_BOUNDS() : new Xt.ERR_OUT_OF_RANGE(It || "offset", `>= ${It ? 1 : 0} and <= ${kt}`, Bt);
  }
  const Gt = /[^+/0-9A-Za-z-_]/g;
  function rr(Bt) {
    if (Bt = Bt.split("=")[0], Bt = Bt.trim().replace(Gt, ""), Bt.length < 2)
      return "";
    for (; Bt.length % 4 !== 0; )
      Bt = Bt + "=";
    return Bt;
  }
  function sr(Bt, kt) {
    kt = kt || 1 / 0;
    let It;
    const jt = Bt.length;
    let Vt = null;
    const ar = [];
    for (let Yt = 0; Yt < jt; ++Yt) {
      if (It = Bt.charCodeAt(Yt), It > 55295 && It < 57344) {
        if (!Vt) {
          if (It > 56319) {
            (kt -= 3) > -1 && ar.push(239, 191, 189);
            continue;
          } else if (Yt + 1 === jt) {
            (kt -= 3) > -1 && ar.push(239, 191, 189);
            continue;
          }
          Vt = It;
          continue;
        }
        if (It < 56320) {
          (kt -= 3) > -1 && ar.push(239, 191, 189), Vt = It;
          continue;
        }
        It = (Vt - 55296 << 10 | It - 56320) + 65536;
      } else
        Vt && (kt -= 3) > -1 && ar.push(239, 191, 189);
      if (Vt = null, It < 128) {
        if ((kt -= 1) < 0)
          break;
        ar.push(It);
      } else if (It < 2048) {
        if ((kt -= 2) < 0)
          break;
        ar.push(It >> 6 | 192, It & 63 | 128);
      } else if (It < 65536) {
        if ((kt -= 3) < 0)
          break;
        ar.push(It >> 12 | 224, It >> 6 & 63 | 128, It & 63 | 128);
      } else if (It < 1114112) {
        if ((kt -= 4) < 0)
          break;
        ar.push(It >> 18 | 240, It >> 12 & 63 | 128, It >> 6 & 63 | 128, It & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return ar;
  }
  function Jt(Bt) {
    const kt = [];
    for (let It = 0; It < Bt.length; ++It)
      kt.push(Bt.charCodeAt(It) & 255);
    return kt;
  }
  function ir(Bt, kt) {
    let It, jt, Vt;
    const ar = [];
    for (let Yt = 0; Yt < Bt.length && !((kt -= 2) < 0); ++Yt)
      It = Bt.charCodeAt(Yt), jt = It >> 8, Vt = It % 256, ar.push(Vt), ar.push(jt);
    return ar;
  }
  function Br(Bt) {
    return $e.toByteArray(rr(Bt));
  }
  function or(Bt, kt, It, jt) {
    let Vt;
    for (Vt = 0; Vt < jt && !(Vt + It >= kt.length || Vt >= Bt.length); ++Vt)
      kt[Vt + It] = Bt[Vt];
    return Vt;
  }
  function lr(Bt, kt) {
    return Bt instanceof kt || Bt != null && Bt.constructor != null && Bt.constructor.name != null && Bt.constructor.name === kt.name;
  }
  function Nr(Bt) {
    return Bt !== Bt;
  }
  const dr = function() {
    const Bt = "0123456789abcdef", kt = new Array(256);
    for (let It = 0; It < 16; ++It) {
      const jt = It * 16;
      for (let Vt = 0; Vt < 16; ++Vt)
        kt[jt + Vt] = Bt[It] + Bt[Vt];
    }
    return kt;
  }();
  function gr(Bt) {
    return typeof BigInt > "u" ? Zr : Bt;
  }
  function Zr() {
    throw new Error("BigInt not supported");
  }
  return exports$g;
}
function dew$f() {
  return _dewExec$f || (_dewExec$f = !0, typeof Object.create == "function" ? exports$f = function(Ze, Fe) {
    Fe && (Ze.super_ = Fe, Ze.prototype = Object.create(Fe.prototype, {
      constructor: {
        value: Ze,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : exports$f = function(Ze, Fe) {
    if (Fe) {
      Ze.super_ = Fe;
      var Ke = function() {
      };
      Ke.prototype = Fe.prototype, Ze.prototype = new Ke(), Ze.prototype.constructor = Ze;
    }
  }), exports$f;
}
function dew$e() {
  return _dewExec$e || (_dewExec$e = !0, exports$e = y.EventEmitter), exports$e;
}
function dew$d() {
  if (_dewExec$d)
    return exports$d;
  _dewExec$d = !0;
  function $e($t, vt) {
    var wt = Object.keys($t);
    if (Object.getOwnPropertySymbols) {
      var xt = Object.getOwnPropertySymbols($t);
      vt && (xt = xt.filter(function(Et) {
        return Object.getOwnPropertyDescriptor($t, Et).enumerable;
      })), wt.push.apply(wt, xt);
    }
    return wt;
  }
  function Ze($t) {
    for (var vt = 1; vt < arguments.length; vt++) {
      var wt = arguments[vt] != null ? arguments[vt] : {};
      vt % 2 ? $e(Object(wt), !0).forEach(function(xt) {
        Fe($t, xt, wt[xt]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties($t, Object.getOwnPropertyDescriptors(wt)) : $e(Object(wt)).forEach(function(xt) {
        Object.defineProperty($t, xt, Object.getOwnPropertyDescriptor(wt, xt));
      });
    }
    return $t;
  }
  function Fe($t, vt, wt) {
    return vt in $t ? Object.defineProperty($t, vt, {
      value: wt,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : $t[vt] = wt, $t;
  }
  function Ke($t, vt) {
    if (!($t instanceof vt))
      throw new TypeError("Cannot call a class as a function");
  }
  function Ve($t, vt) {
    for (var wt = 0; wt < vt.length; wt++) {
      var xt = vt[wt];
      xt.enumerable = xt.enumerable || !1, xt.configurable = !0, "value" in xt && (xt.writable = !0), Object.defineProperty($t, xt.key, xt);
    }
  }
  function Je($t, vt, wt) {
    return vt && Ve($t.prototype, vt), wt && Ve($t, wt), $t;
  }
  var Qe = buffer, at = Qe.Buffer, ut = X, lt = ut.inspect, dt = lt && lt.custom || "inspect";
  function bt($t, vt, wt) {
    at.prototype.copy.call($t, vt, wt);
  }
  return exports$d = /* @__PURE__ */ function() {
    function $t() {
      Ke(this, $t), this.head = null, this.tail = null, this.length = 0;
    }
    return Je($t, [{
      key: "push",
      value: function(wt) {
        var xt = {
          data: wt,
          next: null
        };
        this.length > 0 ? this.tail.next = xt : this.head = xt, this.tail = xt, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(wt) {
        var xt = {
          data: wt,
          next: this.head
        };
        this.length === 0 && (this.tail = xt), this.head = xt, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var wt = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, wt;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(wt) {
        if (this.length === 0)
          return "";
        for (var xt = this.head, Et = "" + xt.data; xt = xt.next; )
          Et += wt + xt.data;
        return Et;
      }
    }, {
      key: "concat",
      value: function(wt) {
        if (this.length === 0)
          return at.alloc(0);
        for (var xt = at.allocUnsafe(wt >>> 0), Et = this.head, Tt = 0; Et; )
          bt(Et.data, xt, Tt), Tt += Et.data.length, Et = Et.next;
        return xt;
      }
    }, {
      key: "consume",
      value: function(wt, xt) {
        var Et;
        return wt < this.head.data.length ? (Et = this.head.data.slice(0, wt), this.head.data = this.head.data.slice(wt)) : wt === this.head.data.length ? Et = this.shift() : Et = xt ? this._getString(wt) : this._getBuffer(wt), Et;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
    }, {
      key: "_getString",
      value: function(wt) {
        var xt = this.head, Et = 1, Tt = xt.data;
        for (wt -= Tt.length; xt = xt.next; ) {
          var Rt = xt.data, Ct = wt > Rt.length ? Rt.length : wt;
          if (Ct === Rt.length ? Tt += Rt : Tt += Rt.slice(0, wt), wt -= Ct, wt === 0) {
            Ct === Rt.length ? (++Et, xt.next ? this.head = xt.next : this.head = this.tail = null) : (this.head = xt, xt.data = Rt.slice(Ct));
            break;
          }
          ++Et;
        }
        return this.length -= Et, Tt;
      }
    }, {
      key: "_getBuffer",
      value: function(wt) {
        var xt = at.allocUnsafe(wt), Et = this.head, Tt = 1;
        for (Et.data.copy(xt), wt -= Et.data.length; Et = Et.next; ) {
          var Rt = Et.data, Ct = wt > Rt.length ? Rt.length : wt;
          if (Rt.copy(xt, xt.length - wt, 0, Ct), wt -= Ct, wt === 0) {
            Ct === Rt.length ? (++Tt, Et.next ? this.head = Et.next : this.head = this.tail = null) : (this.head = Et, Et.data = Rt.slice(Ct));
            break;
          }
          ++Tt;
        }
        return this.length -= Tt, xt;
      }
    }, {
      key: dt,
      value: function(wt, xt) {
        return lt(this, Ze({}, xt, {
          depth: 0,
          customInspect: !1
        }));
      }
    }]), $t;
  }(), exports$d;
}
function dew$c() {
  if (_dewExec$c)
    return exports$c;
  _dewExec$c = !0;
  var $e = process2;
  function Ze(at, ut) {
    var lt = this, dt = this._readableState && this._readableState.destroyed, bt = this._writableState && this._writableState.destroyed;
    return dt || bt ? (ut ? ut(at) : at && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, $e.nextTick(Je, this, at)) : $e.nextTick(Je, this, at)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(at || null, function($t) {
      !ut && $t ? lt._writableState ? lt._writableState.errorEmitted ? $e.nextTick(Ke, lt) : (lt._writableState.errorEmitted = !0, $e.nextTick(Fe, lt, $t)) : $e.nextTick(Fe, lt, $t) : ut ? ($e.nextTick(Ke, lt), ut($t)) : $e.nextTick(Ke, lt);
    }), this);
  }
  function Fe(at, ut) {
    Je(at, ut), Ke(at);
  }
  function Ke(at) {
    at._writableState && !at._writableState.emitClose || at._readableState && !at._readableState.emitClose || at.emit("close");
  }
  function Ve() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function Je(at, ut) {
    at.emit("error", ut);
  }
  function Qe(at, ut) {
    var lt = at._readableState, dt = at._writableState;
    lt && lt.autoDestroy || dt && dt.autoDestroy ? at.destroy(ut) : at.emit("error", ut);
  }
  return exports$c = {
    destroy: Ze,
    undestroy: Ve,
    errorOrDestroy: Qe
  }, exports$c;
}
function dew$b() {
  if (_dewExec$b)
    return exports$b;
  _dewExec$b = !0;
  const $e = {};
  function Ze(Qe, at, ut) {
    ut || (ut = Error);
    function lt(bt, $t, vt) {
      return typeof at == "string" ? at : at(bt, $t, vt);
    }
    class dt extends ut {
      constructor($t, vt, wt) {
        super(lt($t, vt, wt));
      }
    }
    dt.prototype.name = ut.name, dt.prototype.code = Qe, $e[Qe] = dt;
  }
  function Fe(Qe, at) {
    if (Array.isArray(Qe)) {
      const ut = Qe.length;
      return Qe = Qe.map((lt) => String(lt)), ut > 2 ? `one of ${at} ${Qe.slice(0, ut - 1).join(", ")}, or ` + Qe[ut - 1] : ut === 2 ? `one of ${at} ${Qe[0]} or ${Qe[1]}` : `of ${at} ${Qe[0]}`;
    } else
      return `of ${at} ${String(Qe)}`;
  }
  function Ke(Qe, at, ut) {
    return Qe.substr(!ut || ut < 0 ? 0 : +ut, at.length) === at;
  }
  function Ve(Qe, at, ut) {
    return (ut === void 0 || ut > Qe.length) && (ut = Qe.length), Qe.substring(ut - at.length, ut) === at;
  }
  function Je(Qe, at, ut) {
    return typeof ut != "number" && (ut = 0), ut + at.length > Qe.length ? !1 : Qe.indexOf(at, ut) !== -1;
  }
  return Ze("ERR_INVALID_OPT_VALUE", function(Qe, at) {
    return 'The value "' + at + '" is invalid for option "' + Qe + '"';
  }, TypeError), Ze("ERR_INVALID_ARG_TYPE", function(Qe, at, ut) {
    let lt;
    typeof at == "string" && Ke(at, "not ") ? (lt = "must not be", at = at.replace(/^not /, "")) : lt = "must be";
    let dt;
    if (Ve(Qe, " argument"))
      dt = `The ${Qe} ${lt} ${Fe(at, "type")}`;
    else {
      const bt = Je(Qe, ".") ? "property" : "argument";
      dt = `The "${Qe}" ${bt} ${lt} ${Fe(at, "type")}`;
    }
    return dt += `. Received type ${typeof ut}`, dt;
  }, TypeError), Ze("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), Ze("ERR_METHOD_NOT_IMPLEMENTED", function(Qe) {
    return "The " + Qe + " method is not implemented";
  }), Ze("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), Ze("ERR_STREAM_DESTROYED", function(Qe) {
    return "Cannot call " + Qe + " after a stream was destroyed";
  }), Ze("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), Ze("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), Ze("ERR_STREAM_WRITE_AFTER_END", "write after end"), Ze("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), Ze("ERR_UNKNOWN_ENCODING", function(Qe) {
    return "Unknown encoding: " + Qe;
  }, TypeError), Ze("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), exports$b.codes = $e, exports$b;
}
function dew$a() {
  if (_dewExec$a)
    return exports$a;
  _dewExec$a = !0;
  var $e = dew$b().codes.ERR_INVALID_OPT_VALUE;
  function Ze(Ke, Ve, Je) {
    return Ke.highWaterMark != null ? Ke.highWaterMark : Ve ? Ke[Je] : null;
  }
  function Fe(Ke, Ve, Je, Qe) {
    var at = Ze(Ve, Qe, Je);
    if (at != null) {
      if (!(isFinite(at) && Math.floor(at) === at) || at < 0) {
        var ut = Qe ? Je : "highWaterMark";
        throw new $e(ut, at);
      }
      return Math.floor(at);
    }
    return Ke.objectMode ? 16 : 16 * 1024;
  }
  return exports$a = {
    getHighWaterMark: Fe
  }, exports$a;
}
function dew$9() {
  if (_dewExec$9)
    return exports$9;
  _dewExec$9 = !0, exports$9 = $e;
  function $e(Fe, Ke) {
    if (Ze("noDeprecation"))
      return Fe;
    var Ve = !1;
    function Je() {
      if (!Ve) {
        if (Ze("throwDeprecation"))
          throw new Error(Ke);
        Ze("traceDeprecation") ? console.trace(Ke) : console.warn(Ke), Ve = !0;
      }
      return Fe.apply(this || _global$2, arguments);
    }
    return Je;
  }
  function Ze(Fe) {
    try {
      if (!_global$2.localStorage)
        return !1;
    } catch {
      return !1;
    }
    var Ke = _global$2.localStorage[Fe];
    return Ke == null ? !1 : String(Ke).toLowerCase() === "true";
  }
  return exports$9;
}
function dew$8() {
  if (_dewExec$8)
    return exports$8;
  _dewExec$8 = !0;
  var $e = process2;
  exports$8 = Ft;
  function Ze(Xt) {
    var zt = this;
    this.next = null, this.entry = null, this.finish = function() {
      Qt(zt, Xt);
    };
  }
  var Fe;
  Ft.WritableState = Pt;
  var Ke = {
    deprecate: dew$9()
  }, Ve = dew$e(), Je = buffer.Buffer, Qe = _global$1.Uint8Array || function() {
  };
  function at(Xt) {
    return Je.from(Xt);
  }
  function ut(Xt) {
    return Je.isBuffer(Xt) || Xt instanceof Qe;
  }
  var lt = dew$c(), dt = dew$a(), bt = dt.getHighWaterMark, $t = dew$b().codes, vt = $t.ERR_INVALID_ARG_TYPE, wt = $t.ERR_METHOD_NOT_IMPLEMENTED, xt = $t.ERR_MULTIPLE_CALLBACK, Et = $t.ERR_STREAM_CANNOT_PIPE, Tt = $t.ERR_STREAM_DESTROYED, Rt = $t.ERR_STREAM_NULL_VALUES, Ct = $t.ERR_STREAM_WRITE_AFTER_END, Zt = $t.ERR_UNKNOWN_ENCODING, Lt = lt.errorOrDestroy;
  dew$f()(Ft, Ve);
  function Ut() {
  }
  function Pt(Xt, zt, Kt) {
    Fe = Fe || dew$7(), Xt = Xt || {}, typeof Kt != "boolean" && (Kt = zt instanceof Fe), this.objectMode = !!Xt.objectMode, Kt && (this.objectMode = this.objectMode || !!Xt.writableObjectMode), this.highWaterMark = bt(this, Xt, "writableHighWaterMark", Kt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ur = Xt.decodeStrings === !1;
    this.decodeStrings = !ur, this.defaultEncoding = Xt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(er) {
      yt(zt, er);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Xt.emitClose !== !1, this.autoDestroy = !!Xt.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Ze(this);
  }
  Pt.prototype.getBuffer = function() {
    for (var zt = this.bufferedRequest, Kt = []; zt; )
      Kt.push(zt), zt = zt.next;
    return Kt;
  }, function() {
    try {
      Object.defineProperty(Pt.prototype, "buffer", {
        get: Ke.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Ot;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ot = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ft, Symbol.hasInstance, {
    value: function(zt) {
      return Ot.call(this, zt) ? !0 : this !== Ft ? !1 : zt && zt._writableState instanceof Pt;
    }
  })) : Ot = function(zt) {
    return zt instanceof this;
  };
  function Ft(Xt) {
    Fe = Fe || dew$7();
    var zt = this instanceof Fe;
    if (!zt && !Ot.call(Ft, this))
      return new Ft(Xt);
    this._writableState = new Pt(Xt, this, zt), this.writable = !0, Xt && (typeof Xt.write == "function" && (this._write = Xt.write), typeof Xt.writev == "function" && (this._writev = Xt.writev), typeof Xt.destroy == "function" && (this._destroy = Xt.destroy), typeof Xt.final == "function" && (this._final = Xt.final)), Ve.call(this);
  }
  Ft.prototype.pipe = function() {
    Lt(this, new Et());
  };
  function gt(Xt, zt) {
    var Kt = new Ct();
    Lt(Xt, Kt), $e.nextTick(zt, Kt);
  }
  function We(Xt, zt, Kt, ur) {
    var er;
    return Kt === null ? er = new Rt() : typeof Kt != "string" && !zt.objectMode && (er = new vt("chunk", ["string", "Buffer"], Kt)), er ? (Lt(Xt, er), $e.nextTick(ur, er), !1) : !0;
  }
  Ft.prototype.write = function(Xt, zt, Kt) {
    var ur = this._writableState, er = !1, Dt = !ur.objectMode && ut(Xt);
    return Dt && !Je.isBuffer(Xt) && (Xt = at(Xt)), typeof zt == "function" && (Kt = zt, zt = null), Dt ? zt = "buffer" : zt || (zt = ur.defaultEncoding), typeof Kt != "function" && (Kt = Ut), ur.ending ? gt(this, Kt) : (Dt || We(this, ur, Xt, Kt)) && (ur.pendingcb++, er = rt(this, ur, Dt, Xt, zt, Kt)), er;
  }, Ft.prototype.cork = function() {
    this._writableState.corked++;
  }, Ft.prototype.uncork = function() {
    var Xt = this._writableState;
    Xt.corked && (Xt.corked--, !Xt.writing && !Xt.corked && !Xt.bufferProcessing && Xt.bufferedRequest && ct(this, Xt));
  }, Ft.prototype.setDefaultEncoding = function(zt) {
    if (typeof zt == "string" && (zt = zt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((zt + "").toLowerCase()) > -1))
      throw new Zt(zt);
    return this._writableState.defaultEncoding = zt, this;
  }, Object.defineProperty(Ft.prototype, "writableBuffer", {
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function Xe(Xt, zt, Kt) {
    return !Xt.objectMode && Xt.decodeStrings !== !1 && typeof zt == "string" && (zt = Je.from(zt, Kt)), zt;
  }
  Object.defineProperty(Ft.prototype, "writableHighWaterMark", {
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function rt(Xt, zt, Kt, ur, er, Dt) {
    if (!Kt) {
      var Ht = Xe(zt, ur, er);
      ur !== Ht && (Kt = !0, er = "buffer", ur = Ht);
    }
    var Gt = zt.objectMode ? 1 : ur.length;
    zt.length += Gt;
    var rr = zt.length < zt.highWaterMark;
    if (rr || (zt.needDrain = !0), zt.writing || zt.corked) {
      var sr = zt.lastBufferedRequest;
      zt.lastBufferedRequest = {
        chunk: ur,
        encoding: er,
        isBuf: Kt,
        callback: Dt,
        next: null
      }, sr ? sr.next = zt.lastBufferedRequest : zt.bufferedRequest = zt.lastBufferedRequest, zt.bufferedRequestCount += 1;
    } else
      ot(Xt, zt, !1, Gt, ur, er, Dt);
    return rr;
  }
  function ot(Xt, zt, Kt, ur, er, Dt, Ht) {
    zt.writelen = ur, zt.writecb = Ht, zt.writing = !0, zt.sync = !0, zt.destroyed ? zt.onwrite(new Tt("write")) : Kt ? Xt._writev(er, zt.onwrite) : Xt._write(er, Dt, zt.onwrite), zt.sync = !1;
  }
  function ft(Xt, zt, Kt, ur, er) {
    --zt.pendingcb, Kt ? ($e.nextTick(er, ur), $e.nextTick(Nt, Xt, zt), Xt._writableState.errorEmitted = !0, Lt(Xt, ur)) : (er(ur), Xt._writableState.errorEmitted = !0, Lt(Xt, ur), Nt(Xt, zt));
  }
  function mt(Xt) {
    Xt.writing = !1, Xt.writecb = null, Xt.length -= Xt.writelen, Xt.writelen = 0;
  }
  function yt(Xt, zt) {
    var Kt = Xt._writableState, ur = Kt.sync, er = Kt.writecb;
    if (typeof er != "function")
      throw new xt();
    if (mt(Kt), zt)
      ft(Xt, Kt, ur, zt, er);
    else {
      var Dt = Mt(Kt) || Xt.destroyed;
      !Dt && !Kt.corked && !Kt.bufferProcessing && Kt.bufferedRequest && ct(Xt, Kt), ur ? $e.nextTick(pt, Xt, Kt, Dt, er) : pt(Xt, Kt, Dt, er);
    }
  }
  function pt(Xt, zt, Kt, ur) {
    Kt || Ge(Xt, zt), zt.pendingcb--, ur(), Nt(Xt, zt);
  }
  function Ge(Xt, zt) {
    zt.length === 0 && zt.needDrain && (zt.needDrain = !1, Xt.emit("drain"));
  }
  function ct(Xt, zt) {
    zt.bufferProcessing = !0;
    var Kt = zt.bufferedRequest;
    if (Xt._writev && Kt && Kt.next) {
      var ur = zt.bufferedRequestCount, er = new Array(ur), Dt = zt.corkedRequestsFree;
      Dt.entry = Kt;
      for (var Ht = 0, Gt = !0; Kt; )
        er[Ht] = Kt, Kt.isBuf || (Gt = !1), Kt = Kt.next, Ht += 1;
      er.allBuffers = Gt, ot(Xt, zt, !0, zt.length, er, "", Dt.finish), zt.pendingcb++, zt.lastBufferedRequest = null, Dt.next ? (zt.corkedRequestsFree = Dt.next, Dt.next = null) : zt.corkedRequestsFree = new Ze(zt), zt.bufferedRequestCount = 0;
    } else {
      for (; Kt; ) {
        var rr = Kt.chunk, sr = Kt.encoding, Jt = Kt.callback, ir = zt.objectMode ? 1 : rr.length;
        if (ot(Xt, zt, !1, ir, rr, sr, Jt), Kt = Kt.next, zt.bufferedRequestCount--, zt.writing)
          break;
      }
      Kt === null && (zt.lastBufferedRequest = null);
    }
    zt.bufferedRequest = Kt, zt.bufferProcessing = !1;
  }
  Ft.prototype._write = function(Xt, zt, Kt) {
    Kt(new wt("_write()"));
  }, Ft.prototype._writev = null, Ft.prototype.end = function(Xt, zt, Kt) {
    var ur = this._writableState;
    return typeof Xt == "function" ? (Kt = Xt, Xt = null, zt = null) : typeof zt == "function" && (Kt = zt, zt = null), Xt != null && this.write(Xt, zt), ur.corked && (ur.corked = 1, this.uncork()), ur.ending || qt(this, ur, Kt), this;
  }, Object.defineProperty(Ft.prototype, "writableLength", {
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function Mt(Xt) {
    return Xt.ending && Xt.length === 0 && Xt.bufferedRequest === null && !Xt.finished && !Xt.writing;
  }
  function St(Xt, zt) {
    Xt._final(function(Kt) {
      zt.pendingcb--, Kt && Lt(Xt, Kt), zt.prefinished = !0, Xt.emit("prefinish"), Nt(Xt, zt);
    });
  }
  function At(Xt, zt) {
    !zt.prefinished && !zt.finalCalled && (typeof Xt._final == "function" && !zt.destroyed ? (zt.pendingcb++, zt.finalCalled = !0, $e.nextTick(St, Xt, zt)) : (zt.prefinished = !0, Xt.emit("prefinish")));
  }
  function Nt(Xt, zt) {
    var Kt = Mt(zt);
    if (Kt && (At(Xt, zt), zt.pendingcb === 0 && (zt.finished = !0, Xt.emit("finish"), zt.autoDestroy))) {
      var ur = Xt._readableState;
      (!ur || ur.autoDestroy && ur.endEmitted) && Xt.destroy();
    }
    return Kt;
  }
  function qt(Xt, zt, Kt) {
    zt.ending = !0, Nt(Xt, zt), Kt && (zt.finished ? $e.nextTick(Kt) : Xt.once("finish", Kt)), zt.ended = !0, Xt.writable = !1;
  }
  function Qt(Xt, zt, Kt) {
    var ur = Xt.entry;
    for (Xt.entry = null; ur; ) {
      var er = ur.callback;
      zt.pendingcb--, er(Kt), ur = ur.next;
    }
    zt.corkedRequestsFree.next = Xt;
  }
  return Object.defineProperty(Ft.prototype, "destroyed", {
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(zt) {
      this._writableState && (this._writableState.destroyed = zt);
    }
  }), Ft.prototype.destroy = lt.destroy, Ft.prototype._undestroy = lt.undestroy, Ft.prototype._destroy = function(Xt, zt) {
    zt(Xt);
  }, exports$8;
}
function dew$7() {
  if (_dewExec$7)
    return exports$7;
  _dewExec$7 = !0;
  var $e = process2, Ze = Object.keys || function(dt) {
    var bt = [];
    for (var $t in dt)
      bt.push($t);
    return bt;
  };
  exports$7 = at;
  var Fe = dew$3(), Ke = dew$8();
  dew$f()(at, Fe);
  for (var Ve = Ze(Ke.prototype), Je = 0; Je < Ve.length; Je++) {
    var Qe = Ve[Je];
    at.prototype[Qe] || (at.prototype[Qe] = Ke.prototype[Qe]);
  }
  function at(dt) {
    if (!(this instanceof at))
      return new at(dt);
    Fe.call(this, dt), Ke.call(this, dt), this.allowHalfOpen = !0, dt && (dt.readable === !1 && (this.readable = !1), dt.writable === !1 && (this.writable = !1), dt.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", ut)));
  }
  Object.defineProperty(at.prototype, "writableHighWaterMark", {
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(at.prototype, "writableBuffer", {
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(at.prototype, "writableLength", {
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ut() {
    this._writableState.ended || $e.nextTick(lt, this);
  }
  function lt(dt) {
    dt.end();
  }
  return Object.defineProperty(at.prototype, "destroyed", {
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(bt) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = bt, this._writableState.destroyed = bt);
    }
  }), exports$7;
}
function dew$6() {
  if (_dewExec$6)
    return exports$6;
  _dewExec$6 = !0;
  var $e = dew$b().codes.ERR_STREAM_PREMATURE_CLOSE;
  function Ze(Je) {
    var Qe = !1;
    return function() {
      if (!Qe) {
        Qe = !0;
        for (var at = arguments.length, ut = new Array(at), lt = 0; lt < at; lt++)
          ut[lt] = arguments[lt];
        Je.apply(this, ut);
      }
    };
  }
  function Fe() {
  }
  function Ke(Je) {
    return Je.setHeader && typeof Je.abort == "function";
  }
  function Ve(Je, Qe, at) {
    if (typeof Qe == "function")
      return Ve(Je, null, Qe);
    Qe || (Qe = {}), at = Ze(at || Fe);
    var ut = Qe.readable || Qe.readable !== !1 && Je.readable, lt = Qe.writable || Qe.writable !== !1 && Je.writable, dt = function() {
      Je.writable || $t();
    }, bt = Je._writableState && Je._writableState.finished, $t = function() {
      lt = !1, bt = !0, ut || at.call(Je);
    }, vt = Je._readableState && Je._readableState.endEmitted, wt = function() {
      ut = !1, vt = !0, lt || at.call(Je);
    }, xt = function(Ct) {
      at.call(Je, Ct);
    }, Et = function() {
      var Ct;
      if (ut && !vt)
        return (!Je._readableState || !Je._readableState.ended) && (Ct = new $e()), at.call(Je, Ct);
      if (lt && !bt)
        return (!Je._writableState || !Je._writableState.ended) && (Ct = new $e()), at.call(Je, Ct);
    }, Tt = function() {
      Je.req.on("finish", $t);
    };
    return Ke(Je) ? (Je.on("complete", $t), Je.on("abort", Et), Je.req ? Tt() : Je.on("request", Tt)) : lt && !Je._writableState && (Je.on("end", dt), Je.on("close", dt)), Je.on("end", wt), Je.on("finish", $t), Qe.error !== !1 && Je.on("error", xt), Je.on("close", Et), function() {
      Je.removeListener("complete", $t), Je.removeListener("abort", Et), Je.removeListener("request", Tt), Je.req && Je.req.removeListener("finish", $t), Je.removeListener("end", dt), Je.removeListener("close", dt), Je.removeListener("finish", $t), Je.removeListener("end", wt), Je.removeListener("error", xt), Je.removeListener("close", Et);
    };
  }
  return exports$6 = Ve, exports$6;
}
function dew$5() {
  if (_dewExec$5)
    return exports$5;
  _dewExec$5 = !0;
  var $e = process2, Ze;
  function Fe(Rt, Ct, Zt) {
    return Ct in Rt ? Object.defineProperty(Rt, Ct, {
      value: Zt,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : Rt[Ct] = Zt, Rt;
  }
  var Ke = dew$6(), Ve = Symbol("lastResolve"), Je = Symbol("lastReject"), Qe = Symbol("error"), at = Symbol("ended"), ut = Symbol("lastPromise"), lt = Symbol("handlePromise"), dt = Symbol("stream");
  function bt(Rt, Ct) {
    return {
      value: Rt,
      done: Ct
    };
  }
  function $t(Rt) {
    var Ct = Rt[Ve];
    if (Ct !== null) {
      var Zt = Rt[dt].read();
      Zt !== null && (Rt[ut] = null, Rt[Ve] = null, Rt[Je] = null, Ct(bt(Zt, !1)));
    }
  }
  function vt(Rt) {
    $e.nextTick($t, Rt);
  }
  function wt(Rt, Ct) {
    return function(Zt, Lt) {
      Rt.then(function() {
        if (Ct[at]) {
          Zt(bt(void 0, !0));
          return;
        }
        Ct[lt](Zt, Lt);
      }, Lt);
    };
  }
  var xt = Object.getPrototypeOf(function() {
  }), Et = Object.setPrototypeOf((Ze = {
    get stream() {
      return this[dt];
    },
    next: function() {
      var Ct = this, Zt = this[Qe];
      if (Zt !== null)
        return Promise.reject(Zt);
      if (this[at])
        return Promise.resolve(bt(void 0, !0));
      if (this[dt].destroyed)
        return new Promise(function(Ot, Ft) {
          $e.nextTick(function() {
            Ct[Qe] ? Ft(Ct[Qe]) : Ot(bt(void 0, !0));
          });
        });
      var Lt = this[ut], Ut;
      if (Lt)
        Ut = new Promise(wt(Lt, this));
      else {
        var Pt = this[dt].read();
        if (Pt !== null)
          return Promise.resolve(bt(Pt, !1));
        Ut = new Promise(this[lt]);
      }
      return this[ut] = Ut, Ut;
    }
  }, Fe(Ze, Symbol.asyncIterator, function() {
    return this;
  }), Fe(Ze, "return", function() {
    var Ct = this;
    return new Promise(function(Zt, Lt) {
      Ct[dt].destroy(null, function(Ut) {
        if (Ut) {
          Lt(Ut);
          return;
        }
        Zt(bt(void 0, !0));
      });
    });
  }), Ze), xt), Tt = function(Ct) {
    var Zt, Lt = Object.create(Et, (Zt = {}, Fe(Zt, dt, {
      value: Ct,
      writable: !0
    }), Fe(Zt, Ve, {
      value: null,
      writable: !0
    }), Fe(Zt, Je, {
      value: null,
      writable: !0
    }), Fe(Zt, Qe, {
      value: null,
      writable: !0
    }), Fe(Zt, at, {
      value: Ct._readableState.endEmitted,
      writable: !0
    }), Fe(Zt, lt, {
      value: function(Pt, Ot) {
        var Ft = Lt[dt].read();
        Ft ? (Lt[ut] = null, Lt[Ve] = null, Lt[Je] = null, Pt(bt(Ft, !1))) : (Lt[Ve] = Pt, Lt[Je] = Ot);
      },
      writable: !0
    }), Zt));
    return Lt[ut] = null, Ke(Ct, function(Ut) {
      if (Ut && Ut.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Pt = Lt[Je];
        Pt !== null && (Lt[ut] = null, Lt[Ve] = null, Lt[Je] = null, Pt(Ut)), Lt[Qe] = Ut;
        return;
      }
      var Ot = Lt[Ve];
      Ot !== null && (Lt[ut] = null, Lt[Ve] = null, Lt[Je] = null, Ot(bt(void 0, !0))), Lt[at] = !0;
    }), Ct.on("readable", vt.bind(null, Lt)), Lt;
  };
  return exports$5 = Tt, exports$5;
}
function dew$4() {
  return _dewExec$4 || (_dewExec$4 = !0, exports$4 = function() {
    throw new Error("Readable.from is not available in the browser");
  }), exports$4;
}
function dew$3() {
  if (_dewExec$3)
    return exports$32;
  _dewExec$3 = !0;
  var $e = process2;
  exports$32 = gt;
  var Ze;
  gt.ReadableState = Ft, y.EventEmitter;
  var Fe = function(Ht, Gt) {
    return Ht.listeners(Gt).length;
  }, Ke = dew$e(), Ve = buffer.Buffer, Je = _global3.Uint8Array || function() {
  };
  function Qe(Dt) {
    return Ve.from(Dt);
  }
  function at(Dt) {
    return Ve.isBuffer(Dt) || Dt instanceof Je;
  }
  var ut = X, lt;
  ut && ut.debuglog ? lt = ut.debuglog("stream") : lt = function() {
  };
  var dt = dew$d(), bt = dew$c(), $t = dew$a(), vt = $t.getHighWaterMark, wt = dew$b().codes, xt = wt.ERR_INVALID_ARG_TYPE, Et = wt.ERR_STREAM_PUSH_AFTER_EOF, Tt = wt.ERR_METHOD_NOT_IMPLEMENTED, Rt = wt.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Ct, Zt, Lt;
  dew$f()(gt, Ke);
  var Ut = bt.errorOrDestroy, Pt = ["error", "close", "destroy", "pause", "resume"];
  function Ot(Dt, Ht, Gt) {
    if (typeof Dt.prependListener == "function")
      return Dt.prependListener(Ht, Gt);
    !Dt._events || !Dt._events[Ht] ? Dt.on(Ht, Gt) : Array.isArray(Dt._events[Ht]) ? Dt._events[Ht].unshift(Gt) : Dt._events[Ht] = [Gt, Dt._events[Ht]];
  }
  function Ft(Dt, Ht, Gt) {
    Ze = Ze || dew$7(), Dt = Dt || {}, typeof Gt != "boolean" && (Gt = Ht instanceof Ze), this.objectMode = !!Dt.objectMode, Gt && (this.objectMode = this.objectMode || !!Dt.readableObjectMode), this.highWaterMark = vt(this, Dt, "readableHighWaterMark", Gt), this.buffer = new dt(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Dt.emitClose !== !1, this.autoDestroy = !!Dt.autoDestroy, this.destroyed = !1, this.defaultEncoding = Dt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Dt.encoding && (Ct || (Ct = e$12.StringDecoder), this.decoder = new Ct(Dt.encoding), this.encoding = Dt.encoding);
  }
  function gt(Dt) {
    if (Ze = Ze || dew$7(), !(this instanceof gt))
      return new gt(Dt);
    var Ht = this instanceof Ze;
    this._readableState = new Ft(Dt, this, Ht), this.readable = !0, Dt && (typeof Dt.read == "function" && (this._read = Dt.read), typeof Dt.destroy == "function" && (this._destroy = Dt.destroy)), Ke.call(this);
  }
  Object.defineProperty(gt.prototype, "destroyed", {
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Ht) {
      this._readableState && (this._readableState.destroyed = Ht);
    }
  }), gt.prototype.destroy = bt.destroy, gt.prototype._undestroy = bt.undestroy, gt.prototype._destroy = function(Dt, Ht) {
    Ht(Dt);
  }, gt.prototype.push = function(Dt, Ht) {
    var Gt = this._readableState, rr;
    return Gt.objectMode ? rr = !0 : typeof Dt == "string" && (Ht = Ht || Gt.defaultEncoding, Ht !== Gt.encoding && (Dt = Ve.from(Dt, Ht), Ht = ""), rr = !0), We(this, Dt, Ht, !1, rr);
  }, gt.prototype.unshift = function(Dt) {
    return We(this, Dt, null, !0, !1);
  };
  function We(Dt, Ht, Gt, rr, sr) {
    lt("readableAddChunk", Ht);
    var Jt = Dt._readableState;
    if (Ht === null)
      Jt.reading = !1, yt(Dt, Jt);
    else {
      var ir;
      if (sr || (ir = rt(Jt, Ht)), ir)
        Ut(Dt, ir);
      else if (Jt.objectMode || Ht && Ht.length > 0)
        if (typeof Ht != "string" && !Jt.objectMode && Object.getPrototypeOf(Ht) !== Ve.prototype && (Ht = Qe(Ht)), rr)
          Jt.endEmitted ? Ut(Dt, new Rt()) : Xe(Dt, Jt, Ht, !0);
        else if (Jt.ended)
          Ut(Dt, new Et());
        else {
          if (Jt.destroyed)
            return !1;
          Jt.reading = !1, Jt.decoder && !Gt ? (Ht = Jt.decoder.write(Ht), Jt.objectMode || Ht.length !== 0 ? Xe(Dt, Jt, Ht, !1) : ct(Dt, Jt)) : Xe(Dt, Jt, Ht, !1);
        }
      else
        rr || (Jt.reading = !1, ct(Dt, Jt));
    }
    return !Jt.ended && (Jt.length < Jt.highWaterMark || Jt.length === 0);
  }
  function Xe(Dt, Ht, Gt, rr) {
    Ht.flowing && Ht.length === 0 && !Ht.sync ? (Ht.awaitDrain = 0, Dt.emit("data", Gt)) : (Ht.length += Ht.objectMode ? 1 : Gt.length, rr ? Ht.buffer.unshift(Gt) : Ht.buffer.push(Gt), Ht.needReadable && pt(Dt)), ct(Dt, Ht);
  }
  function rt(Dt, Ht) {
    var Gt;
    return !at(Ht) && typeof Ht != "string" && Ht !== void 0 && !Dt.objectMode && (Gt = new xt("chunk", ["string", "Buffer", "Uint8Array"], Ht)), Gt;
  }
  gt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, gt.prototype.setEncoding = function(Dt) {
    Ct || (Ct = e$12.StringDecoder);
    var Ht = new Ct(Dt);
    this._readableState.decoder = Ht, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Gt = this._readableState.buffer.head, rr = ""; Gt !== null; )
      rr += Ht.write(Gt.data), Gt = Gt.next;
    return this._readableState.buffer.clear(), rr !== "" && this._readableState.buffer.push(rr), this._readableState.length = rr.length, this;
  };
  var ot = 1073741824;
  function ft(Dt) {
    return Dt >= ot ? Dt = ot : (Dt--, Dt |= Dt >>> 1, Dt |= Dt >>> 2, Dt |= Dt >>> 4, Dt |= Dt >>> 8, Dt |= Dt >>> 16, Dt++), Dt;
  }
  function mt(Dt, Ht) {
    return Dt <= 0 || Ht.length === 0 && Ht.ended ? 0 : Ht.objectMode ? 1 : Dt !== Dt ? Ht.flowing && Ht.length ? Ht.buffer.head.data.length : Ht.length : (Dt > Ht.highWaterMark && (Ht.highWaterMark = ft(Dt)), Dt <= Ht.length ? Dt : Ht.ended ? Ht.length : (Ht.needReadable = !0, 0));
  }
  gt.prototype.read = function(Dt) {
    lt("read", Dt), Dt = parseInt(Dt, 10);
    var Ht = this._readableState, Gt = Dt;
    if (Dt !== 0 && (Ht.emittedReadable = !1), Dt === 0 && Ht.needReadable && ((Ht.highWaterMark !== 0 ? Ht.length >= Ht.highWaterMark : Ht.length > 0) || Ht.ended))
      return lt("read: emitReadable", Ht.length, Ht.ended), Ht.length === 0 && Ht.ended ? Kt(this) : pt(this), null;
    if (Dt = mt(Dt, Ht), Dt === 0 && Ht.ended)
      return Ht.length === 0 && Kt(this), null;
    var rr = Ht.needReadable;
    lt("need readable", rr), (Ht.length === 0 || Ht.length - Dt < Ht.highWaterMark) && (rr = !0, lt("length less than watermark", rr)), Ht.ended || Ht.reading ? (rr = !1, lt("reading or ended", rr)) : rr && (lt("do read"), Ht.reading = !0, Ht.sync = !0, Ht.length === 0 && (Ht.needReadable = !0), this._read(Ht.highWaterMark), Ht.sync = !1, Ht.reading || (Dt = mt(Gt, Ht)));
    var sr;
    return Dt > 0 ? sr = zt(Dt, Ht) : sr = null, sr === null ? (Ht.needReadable = Ht.length <= Ht.highWaterMark, Dt = 0) : (Ht.length -= Dt, Ht.awaitDrain = 0), Ht.length === 0 && (Ht.ended || (Ht.needReadable = !0), Gt !== Dt && Ht.ended && Kt(this)), sr !== null && this.emit("data", sr), sr;
  };
  function yt(Dt, Ht) {
    if (lt("onEofChunk"), !Ht.ended) {
      if (Ht.decoder) {
        var Gt = Ht.decoder.end();
        Gt && Gt.length && (Ht.buffer.push(Gt), Ht.length += Ht.objectMode ? 1 : Gt.length);
      }
      Ht.ended = !0, Ht.sync ? pt(Dt) : (Ht.needReadable = !1, Ht.emittedReadable || (Ht.emittedReadable = !0, Ge(Dt)));
    }
  }
  function pt(Dt) {
    var Ht = Dt._readableState;
    lt("emitReadable", Ht.needReadable, Ht.emittedReadable), Ht.needReadable = !1, Ht.emittedReadable || (lt("emitReadable", Ht.flowing), Ht.emittedReadable = !0, $e.nextTick(Ge, Dt));
  }
  function Ge(Dt) {
    var Ht = Dt._readableState;
    lt("emitReadable_", Ht.destroyed, Ht.length, Ht.ended), !Ht.destroyed && (Ht.length || Ht.ended) && (Dt.emit("readable"), Ht.emittedReadable = !1), Ht.needReadable = !Ht.flowing && !Ht.ended && Ht.length <= Ht.highWaterMark, Xt(Dt);
  }
  function ct(Dt, Ht) {
    Ht.readingMore || (Ht.readingMore = !0, $e.nextTick(Mt, Dt, Ht));
  }
  function Mt(Dt, Ht) {
    for (; !Ht.reading && !Ht.ended && (Ht.length < Ht.highWaterMark || Ht.flowing && Ht.length === 0); ) {
      var Gt = Ht.length;
      if (lt("maybeReadMore read 0"), Dt.read(0), Gt === Ht.length)
        break;
    }
    Ht.readingMore = !1;
  }
  gt.prototype._read = function(Dt) {
    Ut(this, new Tt("_read()"));
  }, gt.prototype.pipe = function(Dt, Ht) {
    var Gt = this, rr = this._readableState;
    switch (rr.pipesCount) {
      case 0:
        rr.pipes = Dt;
        break;
      case 1:
        rr.pipes = [rr.pipes, Dt];
        break;
      default:
        rr.pipes.push(Dt);
        break;
    }
    rr.pipesCount += 1, lt("pipe count=%d opts=%j", rr.pipesCount, Ht);
    var sr = (!Ht || Ht.end !== !1) && Dt !== $e.stdout && Dt !== $e.stderr, Jt = sr ? Br : kt;
    rr.endEmitted ? $e.nextTick(Jt) : Gt.once("end", Jt), Dt.on("unpipe", ir);
    function ir(It, jt) {
      lt("onunpipe"), It === Gt && jt && jt.hasUnpiped === !1 && (jt.hasUnpiped = !0, Nr());
    }
    function Br() {
      lt("onend"), Dt.end();
    }
    var or = St(Gt);
    Dt.on("drain", or);
    var lr = !1;
    function Nr() {
      lt("cleanup"), Dt.removeListener("close", Zr), Dt.removeListener("finish", Bt), Dt.removeListener("drain", or), Dt.removeListener("error", gr), Dt.removeListener("unpipe", ir), Gt.removeListener("end", Br), Gt.removeListener("end", kt), Gt.removeListener("data", dr), lr = !0, rr.awaitDrain && (!Dt._writableState || Dt._writableState.needDrain) && or();
    }
    Gt.on("data", dr);
    function dr(It) {
      lt("ondata");
      var jt = Dt.write(It);
      lt("dest.write", jt), jt === !1 && ((rr.pipesCount === 1 && rr.pipes === Dt || rr.pipesCount > 1 && er(rr.pipes, Dt) !== -1) && !lr && (lt("false write response, pause", rr.awaitDrain), rr.awaitDrain++), Gt.pause());
    }
    function gr(It) {
      lt("onerror", It), kt(), Dt.removeListener("error", gr), Fe(Dt, "error") === 0 && Ut(Dt, It);
    }
    Ot(Dt, "error", gr);
    function Zr() {
      Dt.removeListener("finish", Bt), kt();
    }
    Dt.once("close", Zr);
    function Bt() {
      lt("onfinish"), Dt.removeListener("close", Zr), kt();
    }
    Dt.once("finish", Bt);
    function kt() {
      lt("unpipe"), Gt.unpipe(Dt);
    }
    return Dt.emit("pipe", Gt), rr.flowing || (lt("pipe resume"), Gt.resume()), Dt;
  };
  function St(Dt) {
    return function() {
      var Gt = Dt._readableState;
      lt("pipeOnDrain", Gt.awaitDrain), Gt.awaitDrain && Gt.awaitDrain--, Gt.awaitDrain === 0 && Fe(Dt, "data") && (Gt.flowing = !0, Xt(Dt));
    };
  }
  gt.prototype.unpipe = function(Dt) {
    var Ht = this._readableState, Gt = {
      hasUnpiped: !1
    };
    if (Ht.pipesCount === 0)
      return this;
    if (Ht.pipesCount === 1)
      return Dt && Dt !== Ht.pipes ? this : (Dt || (Dt = Ht.pipes), Ht.pipes = null, Ht.pipesCount = 0, Ht.flowing = !1, Dt && Dt.emit("unpipe", this, Gt), this);
    if (!Dt) {
      var rr = Ht.pipes, sr = Ht.pipesCount;
      Ht.pipes = null, Ht.pipesCount = 0, Ht.flowing = !1;
      for (var Jt = 0; Jt < sr; Jt++)
        rr[Jt].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var ir = er(Ht.pipes, Dt);
    return ir === -1 ? this : (Ht.pipes.splice(ir, 1), Ht.pipesCount -= 1, Ht.pipesCount === 1 && (Ht.pipes = Ht.pipes[0]), Dt.emit("unpipe", this, Gt), this);
  }, gt.prototype.on = function(Dt, Ht) {
    var Gt = Ke.prototype.on.call(this, Dt, Ht), rr = this._readableState;
    return Dt === "data" ? (rr.readableListening = this.listenerCount("readable") > 0, rr.flowing !== !1 && this.resume()) : Dt === "readable" && !rr.endEmitted && !rr.readableListening && (rr.readableListening = rr.needReadable = !0, rr.flowing = !1, rr.emittedReadable = !1, lt("on readable", rr.length, rr.reading), rr.length ? pt(this) : rr.reading || $e.nextTick(Nt, this)), Gt;
  }, gt.prototype.addListener = gt.prototype.on, gt.prototype.removeListener = function(Dt, Ht) {
    var Gt = Ke.prototype.removeListener.call(this, Dt, Ht);
    return Dt === "readable" && $e.nextTick(At, this), Gt;
  }, gt.prototype.removeAllListeners = function(Dt) {
    var Ht = Ke.prototype.removeAllListeners.apply(this, arguments);
    return (Dt === "readable" || Dt === void 0) && $e.nextTick(At, this), Ht;
  };
  function At(Dt) {
    var Ht = Dt._readableState;
    Ht.readableListening = Dt.listenerCount("readable") > 0, Ht.resumeScheduled && !Ht.paused ? Ht.flowing = !0 : Dt.listenerCount("data") > 0 && Dt.resume();
  }
  function Nt(Dt) {
    lt("readable nexttick read 0"), Dt.read(0);
  }
  gt.prototype.resume = function() {
    var Dt = this._readableState;
    return Dt.flowing || (lt("resume"), Dt.flowing = !Dt.readableListening, qt(this, Dt)), Dt.paused = !1, this;
  };
  function qt(Dt, Ht) {
    Ht.resumeScheduled || (Ht.resumeScheduled = !0, $e.nextTick(Qt, Dt, Ht));
  }
  function Qt(Dt, Ht) {
    lt("resume", Ht.reading), Ht.reading || Dt.read(0), Ht.resumeScheduled = !1, Dt.emit("resume"), Xt(Dt), Ht.flowing && !Ht.reading && Dt.read(0);
  }
  gt.prototype.pause = function() {
    return lt("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (lt("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Xt(Dt) {
    var Ht = Dt._readableState;
    for (lt("flow", Ht.flowing); Ht.flowing && Dt.read() !== null; )
      ;
  }
  gt.prototype.wrap = function(Dt) {
    var Ht = this, Gt = this._readableState, rr = !1;
    Dt.on("end", function() {
      if (lt("wrapped end"), Gt.decoder && !Gt.ended) {
        var ir = Gt.decoder.end();
        ir && ir.length && Ht.push(ir);
      }
      Ht.push(null);
    }), Dt.on("data", function(ir) {
      if (lt("wrapped data"), Gt.decoder && (ir = Gt.decoder.write(ir)), !(Gt.objectMode && ir == null) && !(!Gt.objectMode && (!ir || !ir.length))) {
        var Br = Ht.push(ir);
        Br || (rr = !0, Dt.pause());
      }
    });
    for (var sr in Dt)
      this[sr] === void 0 && typeof Dt[sr] == "function" && (this[sr] = function(Br) {
        return function() {
          return Dt[Br].apply(Dt, arguments);
        };
      }(sr));
    for (var Jt = 0; Jt < Pt.length; Jt++)
      Dt.on(Pt[Jt], this.emit.bind(this, Pt[Jt]));
    return this._read = function(ir) {
      lt("wrapped _read", ir), rr && (rr = !1, Dt.resume());
    }, this;
  }, typeof Symbol == "function" && (gt.prototype[Symbol.asyncIterator] = function() {
    return Zt === void 0 && (Zt = dew$5()), Zt(this);
  }), Object.defineProperty(gt.prototype, "readableHighWaterMark", {
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(gt.prototype, "readableBuffer", {
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(gt.prototype, "readableFlowing", {
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Ht) {
      this._readableState && (this._readableState.flowing = Ht);
    }
  }), gt._fromList = zt, Object.defineProperty(gt.prototype, "readableLength", {
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function zt(Dt, Ht) {
    if (Ht.length === 0)
      return null;
    var Gt;
    return Ht.objectMode ? Gt = Ht.buffer.shift() : !Dt || Dt >= Ht.length ? (Ht.decoder ? Gt = Ht.buffer.join("") : Ht.buffer.length === 1 ? Gt = Ht.buffer.first() : Gt = Ht.buffer.concat(Ht.length), Ht.buffer.clear()) : Gt = Ht.buffer.consume(Dt, Ht.decoder), Gt;
  }
  function Kt(Dt) {
    var Ht = Dt._readableState;
    lt("endReadable", Ht.endEmitted), Ht.endEmitted || (Ht.ended = !0, $e.nextTick(ur, Ht, Dt));
  }
  function ur(Dt, Ht) {
    if (lt("endReadableNT", Dt.endEmitted, Dt.length), !Dt.endEmitted && Dt.length === 0 && (Dt.endEmitted = !0, Ht.readable = !1, Ht.emit("end"), Dt.autoDestroy)) {
      var Gt = Ht._writableState;
      (!Gt || Gt.autoDestroy && Gt.finished) && Ht.destroy();
    }
  }
  typeof Symbol == "function" && (gt.from = function(Dt, Ht) {
    return Lt === void 0 && (Lt = dew$4()), Lt(gt, Dt, Ht);
  });
  function er(Dt, Ht) {
    for (var Gt = 0, rr = Dt.length; Gt < rr; Gt++)
      if (Dt[Gt] === Ht)
        return Gt;
    return -1;
  }
  return exports$32;
}
function dew$22() {
  if (_dewExec$22)
    return exports$22;
  _dewExec$22 = !0, exports$22 = at;
  var $e = dew$b().codes, Ze = $e.ERR_METHOD_NOT_IMPLEMENTED, Fe = $e.ERR_MULTIPLE_CALLBACK, Ke = $e.ERR_TRANSFORM_ALREADY_TRANSFORMING, Ve = $e.ERR_TRANSFORM_WITH_LENGTH_0, Je = dew$7();
  dew$f()(at, Je);
  function Qe(dt, bt) {
    var $t = this._transformState;
    $t.transforming = !1;
    var vt = $t.writecb;
    if (vt === null)
      return this.emit("error", new Fe());
    $t.writechunk = null, $t.writecb = null, bt != null && this.push(bt), vt(dt);
    var wt = this._readableState;
    wt.reading = !1, (wt.needReadable || wt.length < wt.highWaterMark) && this._read(wt.highWaterMark);
  }
  function at(dt) {
    if (!(this instanceof at))
      return new at(dt);
    Je.call(this, dt), this._transformState = {
      afterTransform: Qe.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, dt && (typeof dt.transform == "function" && (this._transform = dt.transform), typeof dt.flush == "function" && (this._flush = dt.flush)), this.on("prefinish", ut);
  }
  function ut() {
    var dt = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(bt, $t) {
      lt(dt, bt, $t);
    }) : lt(this, null, null);
  }
  at.prototype.push = function(dt, bt) {
    return this._transformState.needTransform = !1, Je.prototype.push.call(this, dt, bt);
  }, at.prototype._transform = function(dt, bt, $t) {
    $t(new Ze("_transform()"));
  }, at.prototype._write = function(dt, bt, $t) {
    var vt = this._transformState;
    if (vt.writecb = $t, vt.writechunk = dt, vt.writeencoding = bt, !vt.transforming) {
      var wt = this._readableState;
      (vt.needTransform || wt.needReadable || wt.length < wt.highWaterMark) && this._read(wt.highWaterMark);
    }
  }, at.prototype._read = function(dt) {
    var bt = this._transformState;
    bt.writechunk !== null && !bt.transforming ? (bt.transforming = !0, this._transform(bt.writechunk, bt.writeencoding, bt.afterTransform)) : bt.needTransform = !0;
  }, at.prototype._destroy = function(dt, bt) {
    Je.prototype._destroy.call(this, dt, function($t) {
      bt($t);
    });
  };
  function lt(dt, bt, $t) {
    if (bt)
      return dt.emit("error", bt);
    if ($t != null && dt.push($t), dt._writableState.length)
      throw new Ve();
    if (dt._transformState.transforming)
      throw new Ke();
    return dt.push(null);
  }
  return exports$22;
}
function dew$12() {
  if (_dewExec$12)
    return exports$12;
  _dewExec$12 = !0, exports$12 = Ze;
  var $e = dew$22();
  dew$f()(Ze, $e);
  function Ze(Fe) {
    if (!(this instanceof Ze))
      return new Ze(Fe);
    $e.call(this, Fe);
  }
  return Ze.prototype._transform = function(Fe, Ke, Ve) {
    Ve(null, Fe);
  }, exports$12;
}
function dew3() {
  if (_dewExec3)
    return exports3;
  _dewExec3 = !0;
  var $e;
  function Ze($t) {
    var vt = !1;
    return function() {
      vt || (vt = !0, $t.apply(void 0, arguments));
    };
  }
  var Fe = dew$b().codes, Ke = Fe.ERR_MISSING_ARGS, Ve = Fe.ERR_STREAM_DESTROYED;
  function Je($t) {
    if ($t)
      throw $t;
  }
  function Qe($t) {
    return $t.setHeader && typeof $t.abort == "function";
  }
  function at($t, vt, wt, xt) {
    xt = Ze(xt);
    var Et = !1;
    $t.on("close", function() {
      Et = !0;
    }), $e === void 0 && ($e = dew$6()), $e($t, {
      readable: vt,
      writable: wt
    }, function(Rt) {
      if (Rt)
        return xt(Rt);
      Et = !0, xt();
    });
    var Tt = !1;
    return function(Rt) {
      if (!Et && !Tt) {
        if (Tt = !0, Qe($t))
          return $t.abort();
        if (typeof $t.destroy == "function")
          return $t.destroy();
        xt(Rt || new Ve("pipe"));
      }
    };
  }
  function ut($t) {
    $t();
  }
  function lt($t, vt) {
    return $t.pipe(vt);
  }
  function dt($t) {
    return !$t.length || typeof $t[$t.length - 1] != "function" ? Je : $t.pop();
  }
  function bt() {
    for (var $t = arguments.length, vt = new Array($t), wt = 0; wt < $t; wt++)
      vt[wt] = arguments[wt];
    var xt = dt(vt);
    if (Array.isArray(vt[0]) && (vt = vt[0]), vt.length < 2)
      throw new Ke("streams");
    var Et, Tt = vt.map(function(Rt, Ct) {
      var Zt = Ct < vt.length - 1, Lt = Ct > 0;
      return at(Rt, Zt, Lt, function(Ut) {
        Et || (Et = Ut), Ut && Tt.forEach(ut), !Zt && (Tt.forEach(ut), xt(Et));
      });
    });
    return vt.reduce(lt);
  }
  return exports3 = bt, exports3;
}
var exports$2$1, _dewExec$2$1, exports$1$1, _dewExec$1$1, exports$g, _dewExec$g, buffer, exports$f, _dewExec$f, exports$e, _dewExec$e, exports$d, _dewExec$d, exports$c, _dewExec$c, exports$b, _dewExec$b, exports$a, _dewExec$a, exports$9, _dewExec$9, _global$2, exports$8, _dewExec$8, _global$1, exports$7, _dewExec$7, exports$6, _dewExec$6, exports$5, _dewExec$5, exports$4, _dewExec$4, exports$32, _dewExec$3, _global3, exports$22, _dewExec$22, exports$12, _dewExec$12, exports3, _dewExec3, init_chunk_44e51b61 = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-44e51b61.js"() {
    init_dirname(), init_buffer2(), init_process2(), init_chunk_4bd36a8f(), init_chunk_ce0fbc82(), init_chunk_b4205b57(), init_chunk_2eac56ff(), init_chunk_4ccc3a29(), exports$2$1 = {}, _dewExec$2$1 = !1, exports$1$1 = {}, _dewExec$1$1 = !1, exports$g = {}, _dewExec$g = !1, buffer = dew$g(), buffer.Buffer, buffer.INSPECT_MAX_BYTES, buffer.kMaxLength, exports$f = {}, _dewExec$f = !1, exports$e = {}, _dewExec$e = !1, exports$d = {}, _dewExec$d = !1, exports$c = {}, _dewExec$c = !1, exports$b = {}, _dewExec$b = !1, exports$a = {}, _dewExec$a = !1, exports$9 = {}, _dewExec$9 = !1, _global$2 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, exports$8 = {}, _dewExec$8 = !1, _global$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, exports$7 = {}, _dewExec$7 = !1, exports$6 = {}, _dewExec$6 = !1, exports$5 = {}, _dewExec$5 = !1, exports$4 = {}, _dewExec$4 = !1, exports$32 = {}, _dewExec$3 = !1, _global3 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, exports$22 = {}, _dewExec$22 = !1, exports$12 = {}, _dewExec$12 = !1, exports3 = {}, _dewExec3 = !1;
  }
});
function dew4() {
  return _dewExec4 || (_dewExec4 = !0, exports4 = exports4 = dew$3(), exports4.Stream = exports4, exports4.Readable = exports4, exports4.Writable = dew$8(), exports4.Duplex = dew$7(), exports4.Transform = dew$22(), exports4.PassThrough = dew$12(), exports4.finished = dew$6(), exports4.pipeline = dew3()), exports4;
}
var exports4, _dewExec4, init_chunk_c3d025d9 = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-c3d025d9.js"() {
    init_dirname(), init_buffer2(), init_process2(), init_chunk_44e51b61(), exports4 = {}, _dewExec4 = !1;
  }
}), require_eventsource = __commonJS({
  "../../node_modules/.pnpm/event-source-polyfill@1.0.31/node_modules/event-source-polyfill/src/eventsource.js"($e, Ze) {
    init_dirname(), init_buffer2(), init_process2(), function(Fe) {
      var Ke = Fe.setTimeout, Ve = Fe.clearTimeout, Je = Fe.XMLHttpRequest, Qe = Fe.XDomainRequest, at = Fe.ActiveXObject, ut = Fe.EventSource, lt = Fe.document, dt = Fe.Promise, bt = Fe.fetch, $t = Fe.Response, vt = Fe.TextDecoder, wt = Fe.TextEncoder, xt = Fe.AbortController;
      if (typeof window < "u" && typeof lt < "u" && !("readyState" in lt) && lt.body == null && (lt.readyState = "loading", window.addEventListener("load", function(sr) {
        lt.readyState = "complete";
      }, !1)), Je == null && at != null && (Je = function() {
        return new at("Microsoft.XMLHTTP");
      }), Object.create == null && (Object.create = function(sr) {
        function Jt() {
        }
        return Jt.prototype = sr, new Jt();
      }), Date.now || (Date.now = function() {
        return (/* @__PURE__ */ new Date()).getTime();
      }), xt == null) {
        var Et = bt;
        bt = function(sr, Jt) {
          var ir = Jt.signal;
          return Et(sr, { headers: Jt.headers, credentials: Jt.credentials, cache: Jt.cache }).then(function(Br) {
            var or = Br.body.getReader();
            return ir._reader = or, ir._aborted && ir._reader.cancel(), {
              status: Br.status,
              statusText: Br.statusText,
              headers: Br.headers,
              body: {
                getReader: function() {
                  return or;
                }
              }
            };
          });
        }, xt = function() {
          this.signal = {
            _reader: null,
            _aborted: !1
          }, this.abort = function() {
            this.signal._reader != null && this.signal._reader.cancel(), this.signal._aborted = !0;
          };
        };
      }
      function Tt() {
        this.bitsNeeded = 0, this.codePoint = 0;
      }
      Tt.prototype.decode = function(sr) {
        function Jt(Zr, Bt, kt) {
          if (kt === 1)
            return Zr >= 128 >> Bt && Zr << Bt <= 2047;
          if (kt === 2)
            return Zr >= 2048 >> Bt && Zr << Bt <= 55295 || Zr >= 57344 >> Bt && Zr << Bt <= 65535;
          if (kt === 3)
            return Zr >= 65536 >> Bt && Zr << Bt <= 1114111;
          throw new Error();
        }
        function ir(Zr, Bt) {
          if (Zr === 6 * 1)
            return Bt >> 6 > 15 ? 3 : Bt > 31 ? 2 : 1;
          if (Zr === 6 * 2)
            return Bt > 15 ? 3 : 2;
          if (Zr === 6 * 3)
            return 3;
          throw new Error();
        }
        for (var Br = 65533, or = "", lr = this.bitsNeeded, Nr = this.codePoint, dr = 0; dr < sr.length; dr += 1) {
          var gr = sr[dr];
          lr !== 0 && (gr < 128 || gr > 191 || !Jt(Nr << 6 | gr & 63, lr - 6, ir(lr, Nr))) && (lr = 0, Nr = Br, or += String.fromCharCode(Nr)), lr === 0 ? (gr >= 0 && gr <= 127 ? (lr = 0, Nr = gr) : gr >= 192 && gr <= 223 ? (lr = 6 * 1, Nr = gr & 31) : gr >= 224 && gr <= 239 ? (lr = 6 * 2, Nr = gr & 15) : gr >= 240 && gr <= 247 ? (lr = 6 * 3, Nr = gr & 7) : (lr = 0, Nr = Br), lr !== 0 && !Jt(Nr, lr, ir(lr, Nr)) && (lr = 0, Nr = Br)) : (lr -= 6, Nr = Nr << 6 | gr & 63), lr === 0 && (Nr <= 65535 ? or += String.fromCharCode(Nr) : (or += String.fromCharCode(55296 + (Nr - 65535 - 1 >> 10)), or += String.fromCharCode(56320 + (Nr - 65535 - 1 & 1023))));
        }
        return this.bitsNeeded = lr, this.codePoint = Nr, or;
      };
      var Rt = function() {
        try {
          return new vt().decode(new wt().encode("test"), { stream: !0 }) === "test";
        } catch (sr) {
          console.debug("TextDecoder does not support streaming option. Using polyfill instead: " + sr);
        }
        return !1;
      };
      (vt == null || wt == null || !Rt()) && (vt = Tt);
      var Ct = function() {
      };
      function Zt(sr) {
        this.withCredentials = !1, this.readyState = 0, this.status = 0, this.statusText = "", this.responseText = "", this.onprogress = Ct, this.onload = Ct, this.onerror = Ct, this.onreadystatechange = Ct, this._contentType = "", this._xhr = sr, this._sendTimeout = 0, this._abort = Ct;
      }
      Zt.prototype.open = function(sr, Jt) {
        this._abort(!0);
        var ir = this, Br = this._xhr, or = 1, lr = 0;
        this._abort = function(kt) {
          ir._sendTimeout !== 0 && (Ve(ir._sendTimeout), ir._sendTimeout = 0), (or === 1 || or === 2 || or === 3) && (or = 4, Br.onload = Ct, Br.onerror = Ct, Br.onabort = Ct, Br.onprogress = Ct, Br.onreadystatechange = Ct, Br.abort(), lr !== 0 && (Ve(lr), lr = 0), kt || (ir.readyState = 4, ir.onabort(null), ir.onreadystatechange())), or = 0;
        };
        var Nr = function() {
          if (or === 1) {
            var kt = 0, It = "", jt = void 0;
            if ("contentType" in Br)
              kt = 200, It = "OK", jt = Br.contentType;
            else
              try {
                kt = Br.status, It = Br.statusText, jt = Br.getResponseHeader("Content-Type");
              } catch {
                kt = 0, It = "", jt = void 0;
              }
            kt !== 0 && (or = 2, ir.readyState = 2, ir.status = kt, ir.statusText = It, ir._contentType = jt, ir.onreadystatechange());
          }
        }, dr = function() {
          if (Nr(), or === 2 || or === 3) {
            or = 3;
            var kt = "";
            try {
              kt = Br.responseText;
            } catch {
            }
            ir.readyState = 3, ir.responseText = kt, ir.onprogress();
          }
        }, gr = function(kt, It) {
          if ((It == null || It.preventDefault == null) && (It = {
            preventDefault: Ct
          }), dr(), or === 1 || or === 2 || or === 3) {
            if (or = 4, lr !== 0 && (Ve(lr), lr = 0), ir.readyState = 4, kt === "load")
              ir.onload(It);
            else if (kt === "error")
              ir.onerror(It);
            else if (kt === "abort")
              ir.onabort(It);
            else
              throw new TypeError();
            ir.onreadystatechange();
          }
        }, Zr = function(kt) {
          Br != null && (Br.readyState === 4 ? (!("onload" in Br) || !("onerror" in Br) || !("onabort" in Br)) && gr(Br.responseText === "" ? "error" : "load", kt) : Br.readyState === 3 ? "onprogress" in Br || dr() : Br.readyState === 2 && Nr());
        }, Bt = function() {
          lr = Ke(function() {
            Bt();
          }, 500), Br.readyState === 3 && dr();
        };
        "onload" in Br && (Br.onload = function(kt) {
          gr("load", kt);
        }), "onerror" in Br && (Br.onerror = function(kt) {
          gr("error", kt);
        }), "onabort" in Br && (Br.onabort = function(kt) {
          gr("abort", kt);
        }), "onprogress" in Br && (Br.onprogress = dr), "onreadystatechange" in Br && (Br.onreadystatechange = function(kt) {
          Zr(kt);
        }), ("contentType" in Br || !("ontimeout" in Je.prototype)) && (Jt += (Jt.indexOf("?") === -1 ? "?" : "&") + "padding=true"), Br.open(sr, Jt, !0), "readyState" in Br && (lr = Ke(function() {
          Bt();
        }, 0));
      }, Zt.prototype.abort = function() {
        this._abort(!1);
      }, Zt.prototype.getResponseHeader = function(sr) {
        return this._contentType;
      }, Zt.prototype.setRequestHeader = function(sr, Jt) {
        var ir = this._xhr;
        "setRequestHeader" in ir && ir.setRequestHeader(sr, Jt);
      }, Zt.prototype.getAllResponseHeaders = function() {
        return this._xhr.getAllResponseHeaders != null && this._xhr.getAllResponseHeaders() || "";
      }, Zt.prototype.send = function() {
        if ((!("ontimeout" in Je.prototype) || !("sendAsBinary" in Je.prototype) && !("mozAnon" in Je.prototype)) && lt != null && lt.readyState != null && lt.readyState !== "complete") {
          var sr = this;
          sr._sendTimeout = Ke(function() {
            sr._sendTimeout = 0, sr.send();
          }, 4);
          return;
        }
        var Jt = this._xhr;
        "withCredentials" in Jt && (Jt.withCredentials = this.withCredentials);
        try {
          Jt.send(void 0);
        } catch (ir) {
          throw ir;
        }
      };
      function Lt(sr) {
        return sr.replace(/[A-Z]/g, function(Jt) {
          return String.fromCharCode(Jt.charCodeAt(0) + 32);
        });
      }
      function Ut(sr) {
        for (var Jt = /* @__PURE__ */ Object.create(null), ir = sr.split(`\r
`), Br = 0; Br < ir.length; Br += 1) {
          var or = ir[Br], lr = or.split(": "), Nr = lr.shift(), dr = lr.join(": ");
          Jt[Lt(Nr)] = dr;
        }
        this._map = Jt;
      }
      Ut.prototype.get = function(sr) {
        return this._map[Lt(sr)];
      }, Je != null && Je.HEADERS_RECEIVED == null && (Je.HEADERS_RECEIVED = 2);
      function Pt() {
      }
      Pt.prototype.open = function(sr, Jt, ir, Br, or, lr, Nr) {
        sr.open("GET", or);
        var dr = 0;
        sr.onprogress = function() {
          var Zr = sr.responseText, Bt = Zr.slice(dr);
          dr += Bt.length, ir(Bt);
        }, sr.onerror = function(Zr) {
          Zr.preventDefault(), Br(new Error("NetworkError"));
        }, sr.onload = function() {
          Br(null);
        }, sr.onabort = function() {
          Br(null);
        }, sr.onreadystatechange = function() {
          if (sr.readyState === Je.HEADERS_RECEIVED) {
            var Zr = sr.status, Bt = sr.statusText, kt = sr.getResponseHeader("Content-Type"), It = sr.getAllResponseHeaders();
            Jt(Zr, Bt, kt, new Ut(It));
          }
        }, sr.withCredentials = lr;
        for (var gr in Nr)
          Object.prototype.hasOwnProperty.call(Nr, gr) && sr.setRequestHeader(gr, Nr[gr]);
        return sr.send(), sr;
      };
      function Ot(sr) {
        this._headers = sr;
      }
      Ot.prototype.get = function(sr) {
        return this._headers.get(sr);
      };
      function Ft() {
      }
      Ft.prototype.open = function(sr, Jt, ir, Br, or, lr, Nr) {
        var dr = null, gr = new xt(), Zr = gr.signal, Bt = new vt();
        return bt(or, {
          headers: Nr,
          credentials: lr ? "include" : "same-origin",
          signal: Zr,
          cache: "no-store"
        }).then(function(kt) {
          return dr = kt.body.getReader(), Jt(kt.status, kt.statusText, kt.headers.get("Content-Type"), new Ot(kt.headers)), new dt(function(It, jt) {
            var Vt = function() {
              dr.read().then(function(ar) {
                if (ar.done)
                  It(void 0);
                else {
                  var Yt = Bt.decode(ar.value, { stream: !0 });
                  ir(Yt), Vt();
                }
              }).catch(function(ar) {
                jt(ar);
              });
            };
            Vt();
          });
        }).catch(function(kt) {
          if (kt.name !== "AbortError")
            return kt;
        }).then(function(kt) {
          Br(kt);
        }), {
          abort: function() {
            dr != null && dr.cancel(), gr.abort();
          }
        };
      };
      function gt() {
        this._listeners = /* @__PURE__ */ Object.create(null);
      }
      function We(sr) {
        Ke(function() {
          throw sr;
        }, 0);
      }
      gt.prototype.dispatchEvent = function(sr) {
        sr.target = this;
        var Jt = this._listeners[sr.type];
        if (Jt != null)
          for (var ir = Jt.length, Br = 0; Br < ir; Br += 1) {
            var or = Jt[Br];
            try {
              typeof or.handleEvent == "function" ? or.handleEvent(sr) : or.call(this, sr);
            } catch (lr) {
              We(lr);
            }
          }
      }, gt.prototype.addEventListener = function(sr, Jt) {
        sr = String(sr);
        var ir = this._listeners, Br = ir[sr];
        Br == null && (Br = [], ir[sr] = Br);
        for (var or = !1, lr = 0; lr < Br.length; lr += 1)
          Br[lr] === Jt && (or = !0);
        or || Br.push(Jt);
      }, gt.prototype.removeEventListener = function(sr, Jt) {
        sr = String(sr);
        var ir = this._listeners, Br = ir[sr];
        if (Br != null) {
          for (var or = [], lr = 0; lr < Br.length; lr += 1)
            Br[lr] !== Jt && or.push(Br[lr]);
          or.length === 0 ? delete ir[sr] : ir[sr] = or;
        }
      };
      function Xe(sr) {
        this.type = sr, this.target = void 0;
      }
      function rt(sr, Jt) {
        Xe.call(this, sr), this.data = Jt.data, this.lastEventId = Jt.lastEventId;
      }
      rt.prototype = Object.create(Xe.prototype);
      function ot(sr, Jt) {
        Xe.call(this, sr), this.status = Jt.status, this.statusText = Jt.statusText, this.headers = Jt.headers;
      }
      ot.prototype = Object.create(Xe.prototype);
      function ft(sr, Jt) {
        Xe.call(this, sr), this.error = Jt.error;
      }
      ft.prototype = Object.create(Xe.prototype);
      var mt = -1, yt = 0, pt = 1, Ge = 2, ct = -1, Mt = 0, St = 1, At = 2, Nt = 3, qt = /^text\/event\-stream(;.*)?$/i, Qt = 1e3, Xt = 18e6, zt = function(sr, Jt) {
        var ir = sr == null ? Jt : parseInt(sr, 10);
        return ir !== ir && (ir = Jt), Kt(ir);
      }, Kt = function(sr) {
        return Math.min(Math.max(sr, Qt), Xt);
      }, ur = function(sr, Jt, ir) {
        try {
          typeof Jt == "function" && Jt.call(sr, ir);
        } catch (Br) {
          We(Br);
        }
      };
      function er(sr, Jt) {
        gt.call(this), Jt = Jt || {}, this.onopen = void 0, this.onmessage = void 0, this.onerror = void 0, this.url = void 0, this.readyState = void 0, this.withCredentials = void 0, this.headers = void 0, this._close = void 0, Gt(this, sr, Jt);
      }
      function Dt() {
        return Je != null && "withCredentials" in Je.prototype || Qe == null ? new Je() : new Qe();
      }
      var Ht = bt != null && $t != null && "body" in $t.prototype;
      function Gt(sr, Jt, ir) {
        Jt = String(Jt);
        var Br = !!ir.withCredentials, or = ir.lastEventIdQueryParameterName || "lastEventId", lr = Kt(1e3), Nr = zt(ir.heartbeatTimeout, 45e3), dr = "", gr = lr, Zr = !1, Bt = 0, kt = ir.headers || {}, It = ir.Transport, jt = Ht && It == null ? void 0 : new Zt(It != null ? new It() : Dt()), Vt = It != null && typeof It != "string" ? new It() : jt == null ? new Ft() : new Pt(), ar = void 0, Yt = 0, hr = mt, zr = "", cr = "", _r = "", Lr = "", br = Mt, kr = 0, Xr = 0, yr = function(Hr, $r, Ar, Wr) {
          if (hr === yt)
            if (Hr === 200 && Ar != null && qt.test(Ar)) {
              hr = pt, Zr = Date.now(), gr = lr, sr.readyState = pt;
              var mr = new ot("open", {
                status: Hr,
                statusText: $r,
                headers: Wr
              });
              sr.dispatchEvent(mr), ur(sr, sr.onopen, mr);
            } else {
              var Tr = "";
              Hr !== 200 ? ($r && ($r = $r.replace(/\s+/g, " ")), Tr = "EventSource's response has a status " + Hr + " " + $r + " that is not 200. Aborting the connection.") : Tr = "EventSource's response has a Content-Type specifying an unsupported type: " + (Ar == null ? "-" : Ar.replace(/\s+/g, " ")) + ". Aborting the connection.", wr();
              var mr = new ot("error", {
                status: Hr,
                statusText: $r,
                headers: Wr
              });
              sr.dispatchEvent(mr), ur(sr, sr.onerror, mr), console.error(Tr);
            }
        }, Ir = function(Hr) {
          if (hr === pt) {
            for (var $r = -1, Ar = 0; Ar < Hr.length; Ar += 1) {
              var Wr = Hr.charCodeAt(Ar);
              (Wr === `
`.charCodeAt(0) || Wr === "\r".charCodeAt(0)) && ($r = Ar);
            }
            var mr = ($r !== -1 ? Lr : "") + Hr.slice(0, $r + 1);
            Lr = ($r === -1 ? Lr : "") + Hr.slice($r + 1), Hr !== "" && (Zr = Date.now(), Bt += Hr.length);
            for (var Tr = 0; Tr < mr.length; Tr += 1) {
              var Wr = mr.charCodeAt(Tr);
              if (br === ct && Wr === `
`.charCodeAt(0))
                br = Mt;
              else if (br === ct && (br = Mt), Wr === "\r".charCodeAt(0) || Wr === `
`.charCodeAt(0)) {
                if (br !== Mt) {
                  br === St && (Xr = Tr + 1);
                  var Kr = mr.slice(kr, Xr - 1), vr = mr.slice(Xr + (Xr < Tr && mr.charCodeAt(Xr) === " ".charCodeAt(0) ? 1 : 0), Tr);
                  Kr === "data" ? (zr += `
`, zr += vr) : Kr === "id" ? cr = vr : Kr === "event" ? _r = vr : Kr === "retry" ? (lr = zt(vr, lr), gr = lr) : Kr === "heartbeatTimeout" && (Nr = zt(vr, Nr), Yt !== 0 && (Ve(Yt), Yt = Ke(function() {
                    Cr();
                  }, Nr)));
                }
                if (br === Mt) {
                  if (zr !== "") {
                    dr = cr, _r === "" && (_r = "message");
                    var Rr = new rt(_r, {
                      data: zr.slice(1),
                      lastEventId: cr
                    });
                    if (sr.dispatchEvent(Rr), _r === "open" ? ur(sr, sr.onopen, Rr) : _r === "message" ? ur(sr, sr.onmessage, Rr) : _r === "error" && ur(sr, sr.onerror, Rr), hr === Ge)
                      return;
                  }
                  zr = "", _r = "";
                }
                br = Wr === "\r".charCodeAt(0) ? ct : Mt;
              } else
                br === Mt && (kr = Tr, br = St), br === St ? Wr === ":".charCodeAt(0) && (Xr = Tr + 1, br = At) : br === At && (br = Nt);
            }
          }
        }, Yr = function(Hr) {
          if (hr === pt || hr === yt) {
            hr = mt, Yt !== 0 && (Ve(Yt), Yt = 0), Yt = Ke(function() {
              Cr();
            }, gr), gr = Kt(Math.min(lr * 16, gr * 2)), sr.readyState = yt;
            var $r = new ft("error", { error: Hr });
            sr.dispatchEvent($r), ur(sr, sr.onerror, $r), Hr != null && console.error(Hr);
          }
        }, wr = function() {
          hr = Ge, ar != null && (ar.abort(), ar = void 0), Yt !== 0 && (Ve(Yt), Yt = 0), sr.readyState = Ge;
        }, Cr = function() {
          if (Yt = 0, hr !== mt) {
            if (!Zr && ar != null)
              Yr(new Error("No activity within " + Nr + " milliseconds. " + (hr === yt ? "No response received." : Bt + " chars received.") + " Reconnecting.")), ar != null && (ar.abort(), ar = void 0);
            else {
              var Hr = Math.max((Zr || Date.now()) + Nr - Date.now(), 1);
              Zr = !1, Yt = Ke(function() {
                Cr();
              }, Hr);
            }
            return;
          }
          Zr = !1, Bt = 0, Yt = Ke(function() {
            Cr();
          }, Nr), hr = yt, zr = "", _r = "", cr = dr, Lr = "", kr = 0, Xr = 0, br = Mt;
          var $r = Jt;
          if (Jt.slice(0, 5) !== "data:" && Jt.slice(0, 5) !== "blob:" && dr !== "") {
            var Ar = Jt.indexOf("?");
            $r = Ar === -1 ? Jt : Jt.slice(0, Ar + 1) + Jt.slice(Ar + 1).replace(/(?:^|&)([^=&]*)(?:=[^&]*)?/g, function(vr, Rr) {
              return Rr === or ? "" : vr;
            }), $r += (Jt.indexOf("?") === -1 ? "?" : "&") + or + "=" + encodeURIComponent(dr);
          }
          var Wr = sr.withCredentials, mr = {};
          mr.Accept = "text/event-stream";
          var Tr = sr.headers;
          if (Tr != null)
            for (var Kr in Tr)
              Object.prototype.hasOwnProperty.call(Tr, Kr) && (mr[Kr] = Tr[Kr]);
          try {
            ar = Vt.open(jt, yr, Ir, Yr, $r, Wr, mr);
          } catch (vr) {
            throw wr(), vr;
          }
        };
        sr.url = Jt, sr.readyState = yt, sr.withCredentials = Br, sr.headers = kt, sr._close = wr, Cr();
      }
      er.prototype = Object.create(gt.prototype), er.prototype.CONNECTING = yt, er.prototype.OPEN = pt, er.prototype.CLOSED = Ge, er.prototype.close = function() {
        this._close();
      }, er.CONNECTING = yt, er.OPEN = pt, er.CLOSED = Ge, er.prototype.withCredentials = void 0;
      var rr = ut;
      Je != null && (ut == null || !("withCredentials" in ut.prototype)) && (rr = er), function(sr) {
        if (typeof Ze == "object" && typeof Ze.exports == "object") {
          var Jt = sr($e);
          Jt !== void 0 && (Ze.exports = Jt);
        } else
          typeof define == "function" && define.amd ? define(["exports"], sr) : sr(Fe);
      }(function(sr) {
        sr.EventSourcePolyfill = er, sr.NativeEventSource = ut, sr.EventSource = rr;
      });
    }(typeof globalThis > "u" ? typeof window < "u" ? window : typeof self < "u" ? self : $e : globalThis);
  }
});
function i6($e) {
  throw new RangeError(r6[$e]);
}
function f7($e, Ze) {
  const Fe = $e.split("@");
  let Ke = "";
  Fe.length > 1 && (Ke = Fe[0] + "@", $e = Fe[1]);
  const Ve = function(Je, Qe) {
    const at = [];
    let ut = Je.length;
    for (; ut--; )
      at[ut] = Qe(Je[ut]);
    return at;
  }(($e = $e.replace(e8, ".")).split("."), Ze).join(".");
  return Ke + Ve;
}
function l6($e) {
  const Ze = [];
  let Fe = 0;
  const Ke = $e.length;
  for (; Fe < Ke; ) {
    const Ve = $e.charCodeAt(Fe++);
    if (Ve >= 55296 && Ve <= 56319 && Fe < Ke) {
      const Je = $e.charCodeAt(Fe++);
      (64512 & Je) == 56320 ? Ze.push(((1023 & Ve) << 10) + (1023 & Je) + 65536) : (Ze.push(Ve), Fe--);
    } else
      Ze.push(Ve);
  }
  return Ze;
}
var t6, o6, n6, e8, r6, c6, s6, u6, a6, d5, h6, p6, init_chunk_924bb2e1 = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-924bb2e1.js"() {
    init_dirname(), init_buffer2(), init_process2(), t6 = 2147483647, o6 = /^xn--/, n6 = /[^\0-\x7E]/, e8 = /[\x2E\u3002\uFF0E\uFF61]/g, r6 = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, c6 = Math.floor, s6 = String.fromCharCode, u6 = function($e, Ze) {
      return $e + 22 + 75 * ($e < 26) - ((Ze != 0) << 5);
    }, a6 = function($e, Ze, Fe) {
      let Ke = 0;
      for ($e = Fe ? c6($e / 700) : $e >> 1, $e += c6($e / Ze); $e > 455; Ke += 36)
        $e = c6($e / 35);
      return c6(Ke + 36 * $e / ($e + 38));
    }, d5 = function($e) {
      const Ze = [], Fe = $e.length;
      let Ke = 0, Ve = 128, Je = 72, Qe = $e.lastIndexOf("-");
      Qe < 0 && (Qe = 0);
      for (let ut = 0; ut < Qe; ++ut)
        $e.charCodeAt(ut) >= 128 && i6("not-basic"), Ze.push($e.charCodeAt(ut));
      for (let ut = Qe > 0 ? Qe + 1 : 0; ut < Fe; ) {
        let lt = Ke;
        for (let bt = 1, $t = 36; ; $t += 36) {
          ut >= Fe && i6("invalid-input");
          const vt = (at = $e.charCodeAt(ut++)) - 48 < 10 ? at - 22 : at - 65 < 26 ? at - 65 : at - 97 < 26 ? at - 97 : 36;
          (vt >= 36 || vt > c6((t6 - Ke) / bt)) && i6("overflow"), Ke += vt * bt;
          const wt = $t <= Je ? 1 : $t >= Je + 26 ? 26 : $t - Je;
          if (vt < wt)
            break;
          const xt = 36 - wt;
          bt > c6(t6 / xt) && i6("overflow"), bt *= xt;
        }
        const dt = Ze.length + 1;
        Je = a6(Ke - lt, dt, lt == 0), c6(Ke / dt) > t6 - Ve && i6("overflow"), Ve += c6(Ke / dt), Ke %= dt, Ze.splice(Ke++, 0, Ve);
      }
      var at;
      return String.fromCodePoint(...Ze);
    }, h6 = function($e) {
      const Ze = [];
      let Fe = ($e = l6($e)).length, Ke = 128, Ve = 0, Je = 72;
      for (const ut of $e)
        ut < 128 && Ze.push(s6(ut));
      let Qe = Ze.length, at = Qe;
      for (Qe && Ze.push("-"); at < Fe; ) {
        let ut = t6;
        for (const dt of $e)
          dt >= Ke && dt < ut && (ut = dt);
        const lt = at + 1;
        ut - Ke > c6((t6 - Ve) / lt) && i6("overflow"), Ve += (ut - Ke) * lt, Ke = ut;
        for (const dt of $e)
          if (dt < Ke && ++Ve > t6 && i6("overflow"), dt == Ke) {
            let bt = Ve;
            for (let $t = 36; ; $t += 36) {
              const vt = $t <= Je ? 1 : $t >= Je + 26 ? 26 : $t - Je;
              if (bt < vt)
                break;
              const wt = bt - vt, xt = 36 - vt;
              Ze.push(s6(u6(vt + wt % xt, 0))), bt = c6(wt / xt);
            }
            Ze.push(s6(u6(bt, 0))), Je = a6(Ve, lt, at == Qe), Ve = 0, ++at;
          }
        ++Ve, ++Ke;
      }
      return Ze.join("");
    }, p6 = { version: "2.1.0", ucs2: { decode: l6, encode: ($e) => String.fromCodePoint(...$e) }, decode: d5, encode: h6, toASCII: function($e) {
      return f7($e, function(Ze) {
        return n6.test(Ze) ? "xn--" + h6(Ze) : Ze;
      });
    }, toUnicode: function($e) {
      return f7($e, function(Ze) {
        return o6.test(Ze) ? d5(Ze.slice(4).toLowerCase()) : Ze;
      });
    } }, p6.decode, p6.encode, p6.toASCII, p6.toUnicode, p6.ucs2, p6.version;
  }
});
function e9($e, Ze) {
  return Object.prototype.hasOwnProperty.call($e, Ze);
}
var n7, r7, t7, o7, init_chunk_b04e620d = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-b04e620d.js"() {
    init_dirname(), init_buffer2(), init_process2(), n7 = function($e, Ze, Fe, Ke) {
      Ze = Ze || "&", Fe = Fe || "=";
      var Ve = {};
      if (typeof $e != "string" || $e.length === 0)
        return Ve;
      var Je = /\+/g;
      $e = $e.split(Ze);
      var Qe = 1e3;
      Ke && typeof Ke.maxKeys == "number" && (Qe = Ke.maxKeys);
      var at = $e.length;
      Qe > 0 && at > Qe && (at = Qe);
      for (var ut = 0; ut < at; ++ut) {
        var lt, dt, bt, $t, vt = $e[ut].replace(Je, "%20"), wt = vt.indexOf(Fe);
        wt >= 0 ? (lt = vt.substr(0, wt), dt = vt.substr(wt + 1)) : (lt = vt, dt = ""), bt = decodeURIComponent(lt), $t = decodeURIComponent(dt), e9(Ve, bt) ? Array.isArray(Ve[bt]) ? Ve[bt].push($t) : Ve[bt] = [Ve[bt], $t] : Ve[bt] = $t;
      }
      return Ve;
    }, r7 = function($e) {
      switch (typeof $e) {
        case "string":
          return $e;
        case "boolean":
          return $e ? "true" : "false";
        case "number":
          return isFinite($e) ? $e : "";
        default:
          return "";
      }
    }, t7 = function($e, Ze, Fe, Ke) {
      return Ze = Ze || "&", Fe = Fe || "=", $e === null && ($e = void 0), typeof $e == "object" ? Object.keys($e).map(function(Ve) {
        var Je = encodeURIComponent(r7(Ve)) + Fe;
        return Array.isArray($e[Ve]) ? $e[Ve].map(function(Qe) {
          return Je + encodeURIComponent(r7(Qe));
        }).join(Ze) : Je + encodeURIComponent(r7($e[Ve]));
      }).join(Ze) : Ke ? encodeURIComponent(r7(Ke)) + Fe + encodeURIComponent(r7($e)) : "";
    }, o7 = {}, o7.decode = o7.parse = n7, o7.encode = o7.stringify = t7, o7.decode, o7.encode, o7.parse, o7.stringify;
  }
});
function dew6() {
  if (_dewExec6)
    return exports$111;
  _dewExec6 = !0;
  var $e = process2;
  function Ze(Je) {
    if (typeof Je != "string")
      throw new TypeError("Path must be a string. Received " + JSON.stringify(Je));
  }
  function Fe(Je, Qe) {
    for (var at = "", ut = 0, lt = -1, dt = 0, bt, $t = 0; $t <= Je.length; ++$t) {
      if ($t < Je.length)
        bt = Je.charCodeAt($t);
      else {
        if (bt === 47)
          break;
        bt = 47;
      }
      if (bt === 47) {
        if (!(lt === $t - 1 || dt === 1))
          if (lt !== $t - 1 && dt === 2) {
            if (at.length < 2 || ut !== 2 || at.charCodeAt(at.length - 1) !== 46 || at.charCodeAt(at.length - 2) !== 46) {
              if (at.length > 2) {
                var vt = at.lastIndexOf("/");
                if (vt !== at.length - 1) {
                  vt === -1 ? (at = "", ut = 0) : (at = at.slice(0, vt), ut = at.length - 1 - at.lastIndexOf("/")), lt = $t, dt = 0;
                  continue;
                }
              } else if (at.length === 2 || at.length === 1) {
                at = "", ut = 0, lt = $t, dt = 0;
                continue;
              }
            }
            Qe && (at.length > 0 ? at += "/.." : at = "..", ut = 2);
          } else
            at.length > 0 ? at += "/" + Je.slice(lt + 1, $t) : at = Je.slice(lt + 1, $t), ut = $t - lt - 1;
        lt = $t, dt = 0;
      } else
        bt === 46 && dt !== -1 ? ++dt : dt = -1;
    }
    return at;
  }
  function Ke(Je, Qe) {
    var at = Qe.dir || Qe.root, ut = Qe.base || (Qe.name || "") + (Qe.ext || "");
    return at ? at === Qe.root ? at + ut : at + Je + ut : ut;
  }
  var Ve = {
    resolve: function() {
      for (var Qe = "", at = !1, ut, lt = arguments.length - 1; lt >= -1 && !at; lt--) {
        var dt;
        lt >= 0 ? dt = arguments[lt] : (ut === void 0 && (ut = $e.cwd()), dt = ut), Ze(dt), dt.length !== 0 && (Qe = dt + "/" + Qe, at = dt.charCodeAt(0) === 47);
      }
      return Qe = Fe(Qe, !at), at ? Qe.length > 0 ? "/" + Qe : "/" : Qe.length > 0 ? Qe : ".";
    },
    normalize: function(Qe) {
      if (Ze(Qe), Qe.length === 0)
        return ".";
      var at = Qe.charCodeAt(0) === 47, ut = Qe.charCodeAt(Qe.length - 1) === 47;
      return Qe = Fe(Qe, !at), Qe.length === 0 && !at && (Qe = "."), Qe.length > 0 && ut && (Qe += "/"), at ? "/" + Qe : Qe;
    },
    isAbsolute: function(Qe) {
      return Ze(Qe), Qe.length > 0 && Qe.charCodeAt(0) === 47;
    },
    join: function() {
      if (arguments.length === 0)
        return ".";
      for (var Qe, at = 0; at < arguments.length; ++at) {
        var ut = arguments[at];
        Ze(ut), ut.length > 0 && (Qe === void 0 ? Qe = ut : Qe += "/" + ut);
      }
      return Qe === void 0 ? "." : Ve.normalize(Qe);
    },
    relative: function(Qe, at) {
      if (Ze(Qe), Ze(at), Qe === at || (Qe = Ve.resolve(Qe), at = Ve.resolve(at), Qe === at))
        return "";
      for (var ut = 1; ut < Qe.length && Qe.charCodeAt(ut) === 47; ++ut)
        ;
      for (var lt = Qe.length, dt = lt - ut, bt = 1; bt < at.length && at.charCodeAt(bt) === 47; ++bt)
        ;
      for (var $t = at.length, vt = $t - bt, wt = dt < vt ? dt : vt, xt = -1, Et = 0; Et <= wt; ++Et) {
        if (Et === wt) {
          if (vt > wt) {
            if (at.charCodeAt(bt + Et) === 47)
              return at.slice(bt + Et + 1);
            if (Et === 0)
              return at.slice(bt + Et);
          } else
            dt > wt && (Qe.charCodeAt(ut + Et) === 47 ? xt = Et : Et === 0 && (xt = 0));
          break;
        }
        var Tt = Qe.charCodeAt(ut + Et), Rt = at.charCodeAt(bt + Et);
        if (Tt !== Rt)
          break;
        Tt === 47 && (xt = Et);
      }
      var Ct = "";
      for (Et = ut + xt + 1; Et <= lt; ++Et)
        (Et === lt || Qe.charCodeAt(Et) === 47) && (Ct.length === 0 ? Ct += ".." : Ct += "/..");
      return Ct.length > 0 ? Ct + at.slice(bt + xt) : (bt += xt, at.charCodeAt(bt) === 47 && ++bt, at.slice(bt));
    },
    _makeLong: function(Qe) {
      return Qe;
    },
    dirname: function(Qe) {
      if (Ze(Qe), Qe.length === 0)
        return ".";
      for (var at = Qe.charCodeAt(0), ut = at === 47, lt = -1, dt = !0, bt = Qe.length - 1; bt >= 1; --bt)
        if (at = Qe.charCodeAt(bt), at === 47) {
          if (!dt) {
            lt = bt;
            break;
          }
        } else
          dt = !1;
      return lt === -1 ? ut ? "/" : "." : ut && lt === 1 ? "//" : Qe.slice(0, lt);
    },
    basename: function(Qe, at) {
      if (at !== void 0 && typeof at != "string")
        throw new TypeError('"ext" argument must be a string');
      Ze(Qe);
      var ut = 0, lt = -1, dt = !0, bt;
      if (at !== void 0 && at.length > 0 && at.length <= Qe.length) {
        if (at.length === Qe.length && at === Qe)
          return "";
        var $t = at.length - 1, vt = -1;
        for (bt = Qe.length - 1; bt >= 0; --bt) {
          var wt = Qe.charCodeAt(bt);
          if (wt === 47) {
            if (!dt) {
              ut = bt + 1;
              break;
            }
          } else
            vt === -1 && (dt = !1, vt = bt + 1), $t >= 0 && (wt === at.charCodeAt($t) ? --$t === -1 && (lt = bt) : ($t = -1, lt = vt));
        }
        return ut === lt ? lt = vt : lt === -1 && (lt = Qe.length), Qe.slice(ut, lt);
      } else {
        for (bt = Qe.length - 1; bt >= 0; --bt)
          if (Qe.charCodeAt(bt) === 47) {
            if (!dt) {
              ut = bt + 1;
              break;
            }
          } else
            lt === -1 && (dt = !1, lt = bt + 1);
        return lt === -1 ? "" : Qe.slice(ut, lt);
      }
    },
    extname: function(Qe) {
      Ze(Qe);
      for (var at = -1, ut = 0, lt = -1, dt = !0, bt = 0, $t = Qe.length - 1; $t >= 0; --$t) {
        var vt = Qe.charCodeAt($t);
        if (vt === 47) {
          if (!dt) {
            ut = $t + 1;
            break;
          }
          continue;
        }
        lt === -1 && (dt = !1, lt = $t + 1), vt === 46 ? at === -1 ? at = $t : bt !== 1 && (bt = 1) : at !== -1 && (bt = -1);
      }
      return at === -1 || lt === -1 || bt === 0 || bt === 1 && at === lt - 1 && at === ut + 1 ? "" : Qe.slice(at, lt);
    },
    format: function(Qe) {
      if (Qe === null || typeof Qe != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof Qe);
      return Ke("/", Qe);
    },
    parse: function(Qe) {
      Ze(Qe);
      var at = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (Qe.length === 0)
        return at;
      var ut = Qe.charCodeAt(0), lt = ut === 47, dt;
      lt ? (at.root = "/", dt = 1) : dt = 0;
      for (var bt = -1, $t = 0, vt = -1, wt = !0, xt = Qe.length - 1, Et = 0; xt >= dt; --xt) {
        if (ut = Qe.charCodeAt(xt), ut === 47) {
          if (!wt) {
            $t = xt + 1;
            break;
          }
          continue;
        }
        vt === -1 && (wt = !1, vt = xt + 1), ut === 46 ? bt === -1 ? bt = xt : Et !== 1 && (Et = 1) : bt !== -1 && (Et = -1);
      }
      return bt === -1 || vt === -1 || Et === 0 || Et === 1 && bt === vt - 1 && bt === $t + 1 ? vt !== -1 && ($t === 0 && lt ? at.base = at.name = Qe.slice(1, vt) : at.base = at.name = Qe.slice($t, vt)) : ($t === 0 && lt ? (at.name = Qe.slice(1, bt), at.base = Qe.slice(1, vt)) : (at.name = Qe.slice($t, bt), at.base = Qe.slice($t, vt)), at.ext = Qe.slice(bt, vt)), $t > 0 ? at.dir = Qe.slice(0, $t - 1) : lt && (at.dir = "/"), at;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  return Ve.posix = Ve, exports$111 = Ve, exports$111;
}
var exports$111, _dewExec6, exports6, init_chunk_23dbec7b = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-23dbec7b.js"() {
    init_dirname(), init_buffer2(), init_process2(), init_chunk_2eac56ff(), exports$111 = {}, _dewExec6 = !1, exports6 = dew6();
  }
}), url_exports = {};
__export(url_exports, {
  URL: () => _URL,
  Url: () => Url,
  default: () => h7,
  fileURLToPath: () => fileURLToPath,
  format: () => format2,
  parse: () => parse$4,
  pathToFileURL: () => pathToFileURL,
  resolve: () => resolve,
  resolveObject: () => resolveObject
});
function r8() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
function O4($e, Ze, Fe) {
  if ($e && a7.isObject($e) && $e instanceof r8)
    return $e;
  var Ke = new r8();
  return Ke.parse($e, Ze, Fe), Ke;
}
function dew7() {
  if (_dewExec7)
    return exports7;
  _dewExec7 = !0;
  var $e = T;
  function Ze(Je) {
    if (typeof Je != "string")
      throw new TypeError("Path must be a string. Received " + JSON.stringify(Je));
  }
  function Fe(Je, Qe) {
    for (var at = "", ut = 0, lt = -1, dt = 0, bt, $t = 0; $t <= Je.length; ++$t) {
      if ($t < Je.length)
        bt = Je.charCodeAt($t);
      else {
        if (bt === 47)
          break;
        bt = 47;
      }
      if (bt === 47) {
        if (!(lt === $t - 1 || dt === 1))
          if (lt !== $t - 1 && dt === 2) {
            if (at.length < 2 || ut !== 2 || at.charCodeAt(at.length - 1) !== 46 || at.charCodeAt(at.length - 2) !== 46) {
              if (at.length > 2) {
                var vt = at.lastIndexOf("/");
                if (vt !== at.length - 1) {
                  vt === -1 ? (at = "", ut = 0) : (at = at.slice(0, vt), ut = at.length - 1 - at.lastIndexOf("/")), lt = $t, dt = 0;
                  continue;
                }
              } else if (at.length === 2 || at.length === 1) {
                at = "", ut = 0, lt = $t, dt = 0;
                continue;
              }
            }
            Qe && (at.length > 0 ? at += "/.." : at = "..", ut = 2);
          } else
            at.length > 0 ? at += "/" + Je.slice(lt + 1, $t) : at = Je.slice(lt + 1, $t), ut = $t - lt - 1;
        lt = $t, dt = 0;
      } else
        bt === 46 && dt !== -1 ? ++dt : dt = -1;
    }
    return at;
  }
  function Ke(Je, Qe) {
    var at = Qe.dir || Qe.root, ut = Qe.base || (Qe.name || "") + (Qe.ext || "");
    return at ? at === Qe.root ? at + ut : at + Je + ut : ut;
  }
  var Ve = {
    resolve: function() {
      for (var Qe = "", at = !1, ut, lt = arguments.length - 1; lt >= -1 && !at; lt--) {
        var dt;
        lt >= 0 ? dt = arguments[lt] : (ut === void 0 && (ut = $e.cwd()), dt = ut), Ze(dt), dt.length !== 0 && (Qe = dt + "/" + Qe, at = dt.charCodeAt(0) === 47);
      }
      return Qe = Fe(Qe, !at), at ? Qe.length > 0 ? "/" + Qe : "/" : Qe.length > 0 ? Qe : ".";
    },
    normalize: function(Qe) {
      if (Ze(Qe), Qe.length === 0)
        return ".";
      var at = Qe.charCodeAt(0) === 47, ut = Qe.charCodeAt(Qe.length - 1) === 47;
      return Qe = Fe(Qe, !at), Qe.length === 0 && !at && (Qe = "."), Qe.length > 0 && ut && (Qe += "/"), at ? "/" + Qe : Qe;
    },
    isAbsolute: function(Qe) {
      return Ze(Qe), Qe.length > 0 && Qe.charCodeAt(0) === 47;
    },
    join: function() {
      if (arguments.length === 0)
        return ".";
      for (var Qe, at = 0; at < arguments.length; ++at) {
        var ut = arguments[at];
        Ze(ut), ut.length > 0 && (Qe === void 0 ? Qe = ut : Qe += "/" + ut);
      }
      return Qe === void 0 ? "." : Ve.normalize(Qe);
    },
    relative: function(Qe, at) {
      if (Ze(Qe), Ze(at), Qe === at || (Qe = Ve.resolve(Qe), at = Ve.resolve(at), Qe === at))
        return "";
      for (var ut = 1; ut < Qe.length && Qe.charCodeAt(ut) === 47; ++ut)
        ;
      for (var lt = Qe.length, dt = lt - ut, bt = 1; bt < at.length && at.charCodeAt(bt) === 47; ++bt)
        ;
      for (var $t = at.length, vt = $t - bt, wt = dt < vt ? dt : vt, xt = -1, Et = 0; Et <= wt; ++Et) {
        if (Et === wt) {
          if (vt > wt) {
            if (at.charCodeAt(bt + Et) === 47)
              return at.slice(bt + Et + 1);
            if (Et === 0)
              return at.slice(bt + Et);
          } else
            dt > wt && (Qe.charCodeAt(ut + Et) === 47 ? xt = Et : Et === 0 && (xt = 0));
          break;
        }
        var Tt = Qe.charCodeAt(ut + Et), Rt = at.charCodeAt(bt + Et);
        if (Tt !== Rt)
          break;
        Tt === 47 && (xt = Et);
      }
      var Ct = "";
      for (Et = ut + xt + 1; Et <= lt; ++Et)
        (Et === lt || Qe.charCodeAt(Et) === 47) && (Ct.length === 0 ? Ct += ".." : Ct += "/..");
      return Ct.length > 0 ? Ct + at.slice(bt + xt) : (bt += xt, at.charCodeAt(bt) === 47 && ++bt, at.slice(bt));
    },
    _makeLong: function(Qe) {
      return Qe;
    },
    dirname: function(Qe) {
      if (Ze(Qe), Qe.length === 0)
        return ".";
      for (var at = Qe.charCodeAt(0), ut = at === 47, lt = -1, dt = !0, bt = Qe.length - 1; bt >= 1; --bt)
        if (at = Qe.charCodeAt(bt), at === 47) {
          if (!dt) {
            lt = bt;
            break;
          }
        } else
          dt = !1;
      return lt === -1 ? ut ? "/" : "." : ut && lt === 1 ? "//" : Qe.slice(0, lt);
    },
    basename: function(Qe, at) {
      if (at !== void 0 && typeof at != "string")
        throw new TypeError('"ext" argument must be a string');
      Ze(Qe);
      var ut = 0, lt = -1, dt = !0, bt;
      if (at !== void 0 && at.length > 0 && at.length <= Qe.length) {
        if (at.length === Qe.length && at === Qe)
          return "";
        var $t = at.length - 1, vt = -1;
        for (bt = Qe.length - 1; bt >= 0; --bt) {
          var wt = Qe.charCodeAt(bt);
          if (wt === 47) {
            if (!dt) {
              ut = bt + 1;
              break;
            }
          } else
            vt === -1 && (dt = !1, vt = bt + 1), $t >= 0 && (wt === at.charCodeAt($t) ? --$t === -1 && (lt = bt) : ($t = -1, lt = vt));
        }
        return ut === lt ? lt = vt : lt === -1 && (lt = Qe.length), Qe.slice(ut, lt);
      } else {
        for (bt = Qe.length - 1; bt >= 0; --bt)
          if (Qe.charCodeAt(bt) === 47) {
            if (!dt) {
              ut = bt + 1;
              break;
            }
          } else
            lt === -1 && (dt = !1, lt = bt + 1);
        return lt === -1 ? "" : Qe.slice(ut, lt);
      }
    },
    extname: function(Qe) {
      Ze(Qe);
      for (var at = -1, ut = 0, lt = -1, dt = !0, bt = 0, $t = Qe.length - 1; $t >= 0; --$t) {
        var vt = Qe.charCodeAt($t);
        if (vt === 47) {
          if (!dt) {
            ut = $t + 1;
            break;
          }
          continue;
        }
        lt === -1 && (dt = !1, lt = $t + 1), vt === 46 ? at === -1 ? at = $t : bt !== 1 && (bt = 1) : at !== -1 && (bt = -1);
      }
      return at === -1 || lt === -1 || bt === 0 || bt === 1 && at === lt - 1 && at === ut + 1 ? "" : Qe.slice(at, lt);
    },
    format: function(Qe) {
      if (Qe === null || typeof Qe != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof Qe);
      return Ke("/", Qe);
    },
    parse: function(Qe) {
      Ze(Qe);
      var at = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (Qe.length === 0)
        return at;
      var ut = Qe.charCodeAt(0), lt = ut === 47, dt;
      lt ? (at.root = "/", dt = 1) : dt = 0;
      for (var bt = -1, $t = 0, vt = -1, wt = !0, xt = Qe.length - 1, Et = 0; xt >= dt; --xt) {
        if (ut = Qe.charCodeAt(xt), ut === 47) {
          if (!wt) {
            $t = xt + 1;
            break;
          }
          continue;
        }
        vt === -1 && (wt = !1, vt = xt + 1), ut === 46 ? bt === -1 ? bt = xt : Et !== 1 && (Et = 1) : bt !== -1 && (Et = -1);
      }
      return bt === -1 || vt === -1 || Et === 0 || Et === 1 && bt === vt - 1 && bt === $t + 1 ? vt !== -1 && ($t === 0 && lt ? at.base = at.name = Qe.slice(1, vt) : at.base = at.name = Qe.slice($t, vt)) : ($t === 0 && lt ? (at.name = Qe.slice(1, bt), at.base = Qe.slice(1, vt)) : (at.name = Qe.slice($t, bt), at.base = Qe.slice($t, vt)), at.ext = Qe.slice(bt, vt)), $t > 0 ? at.dir = Qe.slice(0, $t - 1) : lt && (at.dir = "/"), at;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  return Ve.posix = Ve, exports7 = Ve, exports7;
}
function fileURLToPath$1($e) {
  if (typeof $e == "string")
    $e = new URL($e);
  else if (!($e instanceof URL))
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  if ($e.protocol !== "file:")
    throw new Deno.errors.InvalidData("invalid url scheme");
  return isWindows$1 ? getPathFromURLWin$1($e) : getPathFromURLPosix$1($e);
}
function getPathFromURLWin$1($e) {
  const Ze = $e.hostname;
  let Fe = $e.pathname;
  for (let Ke = 0; Ke < Fe.length; Ke++)
    if (Fe[Ke] === "%") {
      const Ve = Fe.codePointAt(Ke + 2) || 32;
      if (Fe[Ke + 1] === "2" && Ve === 102 || Fe[Ke + 1] === "5" && Ve === 99)
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
    }
  if (Fe = Fe.replace(forwardSlashRegEx$1, "\\"), Fe = decodeURIComponent(Fe), Ze !== "")
    return `\\\\${Ze}${Fe}`;
  {
    const Ke = Fe.codePointAt(1) | 32, Ve = Fe[2];
    if (Ke < CHAR_LOWERCASE_A$1 || Ke > CHAR_LOWERCASE_Z$1 || Ve !== ":")
      throw new Deno.errors.InvalidData("file url path must be absolute");
    return Fe.slice(1);
  }
}
function getPathFromURLPosix$1($e) {
  if ($e.hostname !== "")
    throw new Deno.errors.InvalidData("invalid file url hostname");
  const Ze = $e.pathname;
  for (let Fe = 0; Fe < Ze.length; Fe++)
    if (Ze[Fe] === "%") {
      const Ke = Ze.codePointAt(Fe + 2) || 32;
      if (Ze[Fe + 1] === "2" && Ke === 102)
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
    }
  return decodeURIComponent(Ze);
}
function pathToFileURL$1($e) {
  let Ze = path.resolve($e);
  const Fe = $e.charCodeAt($e.length - 1);
  (Fe === CHAR_FORWARD_SLASH$1 || isWindows$1 && Fe === CHAR_BACKWARD_SLASH$1) && Ze[Ze.length - 1] !== path.sep && (Ze += "/");
  const Ke = new URL("file://");
  return Ze.includes("%") && (Ze = Ze.replace(percentRegEx$1, "%25")), !isWindows$1 && Ze.includes("\\") && (Ze = Ze.replace(backslashRegEx$1, "%5C")), Ze.includes(`
`) && (Ze = Ze.replace(newlineRegEx$1, "%0A")), Ze.includes("\r") && (Ze = Ze.replace(carriageReturnRegEx$1, "%0D")), Ze.includes("	") && (Ze = Ze.replace(tabRegEx$1, "%09")), Ke.pathname = Ze, Ke;
}
function fileURLToPath($e) {
  if (typeof $e == "string")
    $e = new URL($e);
  else if (!($e instanceof URL))
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  if ($e.protocol !== "file:")
    throw new Deno.errors.InvalidData("invalid url scheme");
  return isWindows ? getPathFromURLWin($e) : getPathFromURLPosix($e);
}
function getPathFromURLWin($e) {
  const Ze = $e.hostname;
  let Fe = $e.pathname;
  for (let Ke = 0; Ke < Fe.length; Ke++)
    if (Fe[Ke] === "%") {
      const Ve = Fe.codePointAt(Ke + 2) || 32;
      if (Fe[Ke + 1] === "2" && Ve === 102 || Fe[Ke + 1] === "5" && Ve === 99)
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
    }
  if (Fe = Fe.replace(forwardSlashRegEx, "\\"), Fe = decodeURIComponent(Fe), Ze !== "")
    return `\\\\${Ze}${Fe}`;
  {
    const Ke = Fe.codePointAt(1) | 32, Ve = Fe[2];
    if (Ke < CHAR_LOWERCASE_A || Ke > CHAR_LOWERCASE_Z || Ve !== ":")
      throw new Deno.errors.InvalidData("file url path must be absolute");
    return Fe.slice(1);
  }
}
function getPathFromURLPosix($e) {
  if ($e.hostname !== "")
    throw new Deno.errors.InvalidData("invalid file url hostname");
  const Ze = $e.pathname;
  for (let Fe = 0; Fe < Ze.length; Fe++)
    if (Ze[Fe] === "%") {
      const Ke = Ze.codePointAt(Fe + 2) || 32;
      if (Ze[Fe + 1] === "2" && Ke === 102)
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
    }
  return decodeURIComponent(Ze);
}
function pathToFileURL($e) {
  let Ze = exports6.resolve($e);
  const Fe = $e.charCodeAt($e.length - 1);
  (Fe === CHAR_FORWARD_SLASH || isWindows && Fe === CHAR_BACKWARD_SLASH) && Ze[Ze.length - 1] !== exports6.sep && (Ze += "/");
  const Ke = new URL("file://");
  return Ze.includes("%") && (Ze = Ze.replace(percentRegEx, "%25")), !isWindows && Ze.includes("\\") && (Ze = Ze.replace(backslashRegEx, "%5C")), Ze.includes(`
`) && (Ze = Ze.replace(newlineRegEx, "%0A")), Ze.includes("\r") && (Ze = Ze.replace(carriageReturnRegEx, "%0D")), Ze.includes("	") && (Ze = Ze.replace(tabRegEx, "%09")), Ke.pathname = Ze, Ke;
}
var h7, e10, a7, o8, n8, i7, l7, p7, c7, u7, f8, m5, v5, g4, y5, b4, exports7, _dewExec7, path, processPlatform$1, CHAR_BACKWARD_SLASH$1, CHAR_FORWARD_SLASH$1, CHAR_LOWERCASE_A$1, CHAR_LOWERCASE_Z$1, isWindows$1, forwardSlashRegEx$1, percentRegEx$1, backslashRegEx$1, newlineRegEx$1, carriageReturnRegEx$1, tabRegEx$1, processPlatform, Url, format2, resolve, resolveObject, parse$4, _URL, CHAR_BACKWARD_SLASH, CHAR_FORWARD_SLASH, CHAR_LOWERCASE_A, CHAR_LOWERCASE_Z, isWindows, forwardSlashRegEx, percentRegEx, backslashRegEx, newlineRegEx, carriageReturnRegEx, tabRegEx, init_url = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/url.js"() {
    init_dirname(), init_buffer2(), init_process2(), init_chunk_924bb2e1(), init_chunk_b04e620d(), init_chunk_5decc758(), init_chunk_23dbec7b(), init_chunk_2eac56ff(), h7 = {}, e10 = p6, a7 = { isString: function($e) {
      return typeof $e == "string";
    }, isObject: function($e) {
      return typeof $e == "object" && $e !== null;
    }, isNull: function($e) {
      return $e === null;
    }, isNullOrUndefined: function($e) {
      return $e == null;
    } }, h7.parse = O4, h7.resolve = function($e, Ze) {
      return O4($e, !1, !0).resolve(Ze);
    }, h7.resolveObject = function($e, Ze) {
      return $e ? O4($e, !1, !0).resolveObject(Ze) : Ze;
    }, h7.format = function($e) {
      return a7.isString($e) && ($e = O4($e)), $e instanceof r8 ? $e.format() : r8.prototype.format.call($e);
    }, h7.Url = r8, o8 = /^([a-z0-9.+-]+:)/i, n8 = /:[0-9]*$/, i7 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, l7 = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", `
`, "	"]), p7 = ["'"].concat(l7), c7 = ["%", "/", "?", ";", "#"].concat(p7), u7 = ["/", "?", "#"], f8 = /^[+a-z0-9A-Z_-]{0,63}$/, m5 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, v5 = { javascript: !0, "javascript:": !0 }, g4 = { javascript: !0, "javascript:": !0 }, y5 = { http: !0, https: !0, ftp: !0, gopher: !0, file: !0, "http:": !0, "https:": !0, "ftp:": !0, "gopher:": !0, "file:": !0 }, b4 = o7, r8.prototype.parse = function($e, Ze, Fe) {
      if (!a7.isString($e))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof $e);
      var Ke = $e.indexOf("?"), Ve = Ke !== -1 && Ke < $e.indexOf("#") ? "?" : "#", Je = $e.split(Ve);
      Je[0] = Je[0].replace(/\\/g, "/");
      var Qe = $e = Je.join(Ve);
      if (Qe = Qe.trim(), !Fe && $e.split("#").length === 1) {
        var at = i7.exec(Qe);
        if (at)
          return this.path = Qe, this.href = Qe, this.pathname = at[1], at[2] ? (this.search = at[2], this.query = Ze ? b4.parse(this.search.substr(1)) : this.search.substr(1)) : Ze && (this.search = "", this.query = {}), this;
      }
      var ut = o8.exec(Qe);
      if (ut) {
        var lt = (ut = ut[0]).toLowerCase();
        this.protocol = lt, Qe = Qe.substr(ut.length);
      }
      if (Fe || ut || Qe.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var dt = Qe.substr(0, 2) === "//";
        !dt || ut && g4[ut] || (Qe = Qe.substr(2), this.slashes = !0);
      }
      if (!g4[ut] && (dt || ut && !y5[ut])) {
        for (var bt, $t, vt = -1, wt = 0; wt < u7.length; wt++)
          (xt = Qe.indexOf(u7[wt])) !== -1 && (vt === -1 || xt < vt) && (vt = xt);
        for (($t = vt === -1 ? Qe.lastIndexOf("@") : Qe.lastIndexOf("@", vt)) !== -1 && (bt = Qe.slice(0, $t), Qe = Qe.slice($t + 1), this.auth = decodeURIComponent(bt)), vt = -1, wt = 0; wt < c7.length; wt++) {
          var xt;
          (xt = Qe.indexOf(c7[wt])) !== -1 && (vt === -1 || xt < vt) && (vt = xt);
        }
        vt === -1 && (vt = Qe.length), this.host = Qe.slice(0, vt), Qe = Qe.slice(vt), this.parseHost(), this.hostname = this.hostname || "";
        var Et = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!Et)
          for (var Tt = this.hostname.split(/\./), Rt = (wt = 0, Tt.length); wt < Rt; wt++) {
            var Ct = Tt[wt];
            if (Ct && !Ct.match(f8)) {
              for (var Zt = "", Lt = 0, Ut = Ct.length; Lt < Ut; Lt++)
                Ct.charCodeAt(Lt) > 127 ? Zt += "x" : Zt += Ct[Lt];
              if (!Zt.match(f8)) {
                var Pt = Tt.slice(0, wt), Ot = Tt.slice(wt + 1), Ft = Ct.match(m5);
                Ft && (Pt.push(Ft[1]), Ot.unshift(Ft[2])), Ot.length && (Qe = "/" + Ot.join(".") + Qe), this.hostname = Pt.join(".");
                break;
              }
            }
          }
        this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), Et || (this.hostname = e10.toASCII(this.hostname));
        var gt = this.port ? ":" + this.port : "", We = this.hostname || "";
        this.host = We + gt, this.href += this.host, Et && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), Qe[0] !== "/" && (Qe = "/" + Qe));
      }
      if (!v5[lt])
        for (wt = 0, Rt = p7.length; wt < Rt; wt++) {
          var Xe = p7[wt];
          if (Qe.indexOf(Xe) !== -1) {
            var rt = encodeURIComponent(Xe);
            rt === Xe && (rt = escape(Xe)), Qe = Qe.split(Xe).join(rt);
          }
        }
      var ot = Qe.indexOf("#");
      ot !== -1 && (this.hash = Qe.substr(ot), Qe = Qe.slice(0, ot));
      var ft = Qe.indexOf("?");
      if (ft !== -1 ? (this.search = Qe.substr(ft), this.query = Qe.substr(ft + 1), Ze && (this.query = b4.parse(this.query)), Qe = Qe.slice(0, ft)) : Ze && (this.search = "", this.query = {}), Qe && (this.pathname = Qe), y5[lt] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        gt = this.pathname || "";
        var mt = this.search || "";
        this.path = gt + mt;
      }
      return this.href = this.format(), this;
    }, r8.prototype.format = function() {
      var $e = this.auth || "";
      $e && ($e = ($e = encodeURIComponent($e)).replace(/%3A/i, ":"), $e += "@");
      var Ze = this.protocol || "", Fe = this.pathname || "", Ke = this.hash || "", Ve = !1, Je = "";
      this.host ? Ve = $e + this.host : this.hostname && (Ve = $e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (Ve += ":" + this.port)), this.query && a7.isObject(this.query) && Object.keys(this.query).length && (Je = b4.stringify(this.query));
      var Qe = this.search || Je && "?" + Je || "";
      return Ze && Ze.substr(-1) !== ":" && (Ze += ":"), this.slashes || (!Ze || y5[Ze]) && Ve !== !1 ? (Ve = "//" + (Ve || ""), Fe && Fe.charAt(0) !== "/" && (Fe = "/" + Fe)) : Ve || (Ve = ""), Ke && Ke.charAt(0) !== "#" && (Ke = "#" + Ke), Qe && Qe.charAt(0) !== "?" && (Qe = "?" + Qe), Ze + Ve + (Fe = Fe.replace(/[?#]/g, function(at) {
        return encodeURIComponent(at);
      })) + (Qe = Qe.replace("#", "%23")) + Ke;
    }, r8.prototype.resolve = function($e) {
      return this.resolveObject(O4($e, !1, !0)).format();
    }, r8.prototype.resolveObject = function($e) {
      if (a7.isString($e)) {
        var Ze = new r8();
        Ze.parse($e, !1, !0), $e = Ze;
      }
      for (var Fe = new r8(), Ke = Object.keys(this), Ve = 0; Ve < Ke.length; Ve++) {
        var Je = Ke[Ve];
        Fe[Je] = this[Je];
      }
      if (Fe.hash = $e.hash, $e.href === "")
        return Fe.href = Fe.format(), Fe;
      if ($e.slashes && !$e.protocol) {
        for (var Qe = Object.keys($e), at = 0; at < Qe.length; at++) {
          var ut = Qe[at];
          ut !== "protocol" && (Fe[ut] = $e[ut]);
        }
        return y5[Fe.protocol] && Fe.hostname && !Fe.pathname && (Fe.path = Fe.pathname = "/"), Fe.href = Fe.format(), Fe;
      }
      if ($e.protocol && $e.protocol !== Fe.protocol) {
        if (!y5[$e.protocol]) {
          for (var lt = Object.keys($e), dt = 0; dt < lt.length; dt++) {
            var bt = lt[dt];
            Fe[bt] = $e[bt];
          }
          return Fe.href = Fe.format(), Fe;
        }
        if (Fe.protocol = $e.protocol, $e.host || g4[$e.protocol])
          Fe.pathname = $e.pathname;
        else {
          for (var $t = ($e.pathname || "").split("/"); $t.length && !($e.host = $t.shift()); )
            ;
          $e.host || ($e.host = ""), $e.hostname || ($e.hostname = ""), $t[0] !== "" && $t.unshift(""), $t.length < 2 && $t.unshift(""), Fe.pathname = $t.join("/");
        }
        if (Fe.search = $e.search, Fe.query = $e.query, Fe.host = $e.host || "", Fe.auth = $e.auth, Fe.hostname = $e.hostname || $e.host, Fe.port = $e.port, Fe.pathname || Fe.search) {
          var vt = Fe.pathname || "", wt = Fe.search || "";
          Fe.path = vt + wt;
        }
        return Fe.slashes = Fe.slashes || $e.slashes, Fe.href = Fe.format(), Fe;
      }
      var xt = Fe.pathname && Fe.pathname.charAt(0) === "/", Et = $e.host || $e.pathname && $e.pathname.charAt(0) === "/", Tt = Et || xt || Fe.host && $e.pathname, Rt = Tt, Ct = Fe.pathname && Fe.pathname.split("/") || [], Zt = ($t = $e.pathname && $e.pathname.split("/") || [], Fe.protocol && !y5[Fe.protocol]);
      if (Zt && (Fe.hostname = "", Fe.port = null, Fe.host && (Ct[0] === "" ? Ct[0] = Fe.host : Ct.unshift(Fe.host)), Fe.host = "", $e.protocol && ($e.hostname = null, $e.port = null, $e.host && ($t[0] === "" ? $t[0] = $e.host : $t.unshift($e.host)), $e.host = null), Tt = Tt && ($t[0] === "" || Ct[0] === "")), Et)
        Fe.host = $e.host || $e.host === "" ? $e.host : Fe.host, Fe.hostname = $e.hostname || $e.hostname === "" ? $e.hostname : Fe.hostname, Fe.search = $e.search, Fe.query = $e.query, Ct = $t;
      else if ($t.length)
        Ct || (Ct = []), Ct.pop(), Ct = Ct.concat($t), Fe.search = $e.search, Fe.query = $e.query;
      else if (!a7.isNullOrUndefined($e.search))
        return Zt && (Fe.hostname = Fe.host = Ct.shift(), (Ft = !!(Fe.host && Fe.host.indexOf("@") > 0) && Fe.host.split("@")) && (Fe.auth = Ft.shift(), Fe.host = Fe.hostname = Ft.shift())), Fe.search = $e.search, Fe.query = $e.query, a7.isNull(Fe.pathname) && a7.isNull(Fe.search) || (Fe.path = (Fe.pathname ? Fe.pathname : "") + (Fe.search ? Fe.search : "")), Fe.href = Fe.format(), Fe;
      if (!Ct.length)
        return Fe.pathname = null, Fe.search ? Fe.path = "/" + Fe.search : Fe.path = null, Fe.href = Fe.format(), Fe;
      for (var Lt = Ct.slice(-1)[0], Ut = (Fe.host || $e.host || Ct.length > 1) && (Lt === "." || Lt === "..") || Lt === "", Pt = 0, Ot = Ct.length; Ot >= 0; Ot--)
        (Lt = Ct[Ot]) === "." ? Ct.splice(Ot, 1) : Lt === ".." ? (Ct.splice(Ot, 1), Pt++) : Pt && (Ct.splice(Ot, 1), Pt--);
      if (!Tt && !Rt)
        for (; Pt--; Pt)
          Ct.unshift("..");
      !Tt || Ct[0] === "" || Ct[0] && Ct[0].charAt(0) === "/" || Ct.unshift(""), Ut && Ct.join("/").substr(-1) !== "/" && Ct.push("");
      var Ft, gt = Ct[0] === "" || Ct[0] && Ct[0].charAt(0) === "/";
      return Zt && (Fe.hostname = Fe.host = gt ? "" : Ct.length ? Ct.shift() : "", (Ft = !!(Fe.host && Fe.host.indexOf("@") > 0) && Fe.host.split("@")) && (Fe.auth = Ft.shift(), Fe.host = Fe.hostname = Ft.shift())), (Tt = Tt || Fe.host && Ct.length) && !gt && Ct.unshift(""), Ct.length ? Fe.pathname = Ct.join("/") : (Fe.pathname = null, Fe.path = null), a7.isNull(Fe.pathname) && a7.isNull(Fe.search) || (Fe.path = (Fe.pathname ? Fe.pathname : "") + (Fe.search ? Fe.search : "")), Fe.auth = $e.auth || Fe.auth, Fe.slashes = Fe.slashes || $e.slashes, Fe.href = Fe.format(), Fe;
    }, r8.prototype.parseHost = function() {
      var $e = this.host, Ze = n8.exec($e);
      Ze && ((Ze = Ze[0]) !== ":" && (this.port = Ze.substr(1)), $e = $e.substr(0, $e.length - Ze.length)), $e && (this.hostname = $e);
    }, h7.Url, h7.format, h7.resolve, h7.resolveObject, exports7 = {}, _dewExec7 = !1, path = dew7(), processPlatform$1 = typeof Deno < "u" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0, h7.URL = typeof URL < "u" ? URL : null, h7.pathToFileURL = pathToFileURL$1, h7.fileURLToPath = fileURLToPath$1, h7.Url, h7.format, h7.resolve, h7.resolveObject, h7.URL, CHAR_BACKWARD_SLASH$1 = 92, CHAR_FORWARD_SLASH$1 = 47, CHAR_LOWERCASE_A$1 = 97, CHAR_LOWERCASE_Z$1 = 122, isWindows$1 = processPlatform$1 === "win32", forwardSlashRegEx$1 = /\//g, percentRegEx$1 = /%/g, backslashRegEx$1 = /\\/g, newlineRegEx$1 = /\n/g, carriageReturnRegEx$1 = /\r/g, tabRegEx$1 = /\t/g, processPlatform = typeof Deno < "u" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0, h7.URL = typeof URL < "u" ? URL : null, h7.pathToFileURL = pathToFileURL, h7.fileURLToPath = fileURLToPath, Url = h7.Url, format2 = h7.format, resolve = h7.resolve, resolveObject = h7.resolveObject, parse$4 = h7.parse, _URL = h7.URL, CHAR_BACKWARD_SLASH = 92, CHAR_FORWARD_SLASH = 47, CHAR_LOWERCASE_A = 97, CHAR_LOWERCASE_Z = 122, isWindows = processPlatform === "win32", forwardSlashRegEx = /\//g, percentRegEx = /%/g, backslashRegEx = /\\/g, newlineRegEx = /\n/g, carriageReturnRegEx = /\r/g, tabRegEx = /\t/g;
  }
}), events_exports = {};
__export(events_exports, {
  EventEmitter: () => EventEmitter2,
  default: () => y,
  defaultMaxListeners: () => defaultMaxListeners,
  init: () => init,
  listenerCount: () => listenerCount,
  on: () => on2,
  once: () => once2
});
var EventEmitter2, defaultMaxListeners, init, listenerCount, on2, once2, init_events = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/events.js"() {
    init_dirname(), init_buffer2(), init_process2(), init_chunk_4bd36a8f(), init_chunk_4bd36a8f(), y.once = function($e, Ze) {
      return new Promise((Fe, Ke) => {
        function Ve(...Qe) {
          Je !== void 0 && $e.removeListener("error", Je), Fe(Qe);
        }
        let Je;
        Ze !== "error" && (Je = (Qe) => {
          $e.removeListener(name, Ve), Ke(Qe);
        }, $e.once("error", Je)), $e.once(Ze, Ve);
      });
    }, y.on = function($e, Ze) {
      const Fe = [], Ke = [];
      let Ve = null, Je = !1;
      const Qe = {
        async next() {
          const lt = Fe.shift();
          if (lt)
            return createIterResult(lt, !1);
          if (Ve) {
            const dt = Promise.reject(Ve);
            return Ve = null, dt;
          }
          return Je ? createIterResult(void 0, !0) : new Promise((dt, bt) => Ke.push({ resolve: dt, reject: bt }));
        },
        async return() {
          $e.removeListener(Ze, at), $e.removeListener("error", ut), Je = !0;
          for (const lt of Ke)
            lt.resolve(createIterResult(void 0, !0));
          return createIterResult(void 0, !0);
        },
        throw(lt) {
          Ve = lt, $e.removeListener(Ze, at), $e.removeListener("error", ut);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
      return $e.on(Ze, at), $e.on("error", ut), Qe;
      function at(...lt) {
        const dt = Ke.shift();
        dt ? dt.resolve(createIterResult(lt, !1)) : Fe.push(lt);
      }
      function ut(lt) {
        Je = !0;
        const dt = Ke.shift();
        dt ? dt.reject(lt) : Ve = lt, Qe.return();
      }
    }, {
      EventEmitter: EventEmitter2,
      defaultMaxListeners,
      init,
      listenerCount,
      on: on2,
      once: once2
    } = y;
  }
}), http_exports = {};
__export(http_exports, {
  Agent: () => Agent,
  ClientRequest: () => ClientRequest,
  IncomingMessage: () => IncomingMessage,
  METHODS: () => METHODS,
  STATUS_CODES: () => STATUS_CODES,
  default: () => exports8,
  get: () => get,
  globalAgent: () => globalAgent,
  request: () => request
});
function dew$53() {
  if (_dewExec$53)
    return exports$63;
  _dewExec$53 = !0, exports$63.fetch = Ke(_global$32.fetch) && Ke(_global$32.ReadableStream), exports$63.writableStream = Ke(_global$32.WritableStream), exports$63.abortController = Ke(_global$32.AbortController);
  var $e;
  function Ze() {
    if ($e !== void 0)
      return $e;
    if (_global$32.XMLHttpRequest) {
      $e = new _global$32.XMLHttpRequest();
      try {
        $e.open("GET", _global$32.XDomainRequest ? "/" : "https://example.com");
      } catch {
        $e = null;
      }
    } else
      $e = null;
    return $e;
  }
  function Fe(Ve) {
    var Je = Ze();
    if (!Je)
      return !1;
    try {
      return Je.responseType = Ve, Je.responseType === Ve;
    } catch {
    }
    return !1;
  }
  exports$63.arraybuffer = exports$63.fetch || Fe("arraybuffer"), exports$63.msstream = !exports$63.fetch && Fe("ms-stream"), exports$63.mozchunkedarraybuffer = !exports$63.fetch && Fe("moz-chunked-arraybuffer"), exports$63.overrideMimeType = exports$63.fetch || (Ze() ? Ke(Ze().overrideMimeType) : !1);
  function Ke(Ve) {
    return typeof Ve == "function";
  }
  return $e = null, exports$63;
}
function dew$43() {
  if (_dewExec$43)
    return exports$53;
  _dewExec$43 = !0;
  var $e = buffer.Buffer, Ze = process2, Fe = dew$53(), Ke = dew$f(), Ve = dew4(), Je = exports$53.readyStates = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
  }, Qe = exports$53.IncomingMessage = function(at, ut, lt, dt) {
    var bt = this || _global$23;
    if (Ve.Readable.call(bt), bt._mode = lt, bt.headers = {}, bt.rawHeaders = [], bt.trailers = {}, bt.rawTrailers = [], bt.on("end", function() {
      Ze.nextTick(function() {
        bt.emit("close");
      });
    }), lt === "fetch") {
      let Tt = function() {
        vt.read().then(function(Rt) {
          if (!bt._destroyed) {
            if (dt(Rt.done), Rt.done) {
              bt.push(null);
              return;
            }
            bt.push($e.from(Rt.value)), Tt();
          }
        }).catch(function(Rt) {
          dt(!0), bt._destroyed || bt.emit("error", Rt);
        });
      };
      if (bt._fetchResponse = ut, bt.url = ut.url, bt.statusCode = ut.status, bt.statusMessage = ut.statusText, ut.headers.forEach(function(Rt, Ct) {
        bt.headers[Ct.toLowerCase()] = Rt, bt.rawHeaders.push(Ct, Rt);
      }), Fe.writableStream) {
        var $t = new WritableStream({
          write: function(Rt) {
            return dt(!1), new Promise(function(Ct, Zt) {
              bt._destroyed ? Zt() : bt.push($e.from(Rt)) ? Ct() : bt._resumeFetch = Ct;
            });
          },
          close: function() {
            dt(!0), bt._destroyed || bt.push(null);
          },
          abort: function(Rt) {
            dt(!0), bt._destroyed || bt.emit("error", Rt);
          }
        });
        try {
          ut.body.pipeTo($t).catch(function(Rt) {
            dt(!0), bt._destroyed || bt.emit("error", Rt);
          });
          return;
        } catch {
        }
      }
      var vt = ut.body.getReader();
      Tt();
    } else {
      bt._xhr = at, bt._pos = 0, bt.url = at.responseURL, bt.statusCode = at.status, bt.statusMessage = at.statusText;
      var wt = at.getAllResponseHeaders().split(/\r?\n/);
      if (wt.forEach(function(Tt) {
        var Rt = Tt.match(/^([^:]+):\s*(.*)/);
        if (Rt) {
          var Ct = Rt[1].toLowerCase();
          Ct === "set-cookie" ? (bt.headers[Ct] === void 0 && (bt.headers[Ct] = []), bt.headers[Ct].push(Rt[2])) : bt.headers[Ct] !== void 0 ? bt.headers[Ct] += ", " + Rt[2] : bt.headers[Ct] = Rt[2], bt.rawHeaders.push(Rt[1], Rt[2]);
        }
      }), bt._charset = "x-user-defined", !Fe.overrideMimeType) {
        var xt = bt.rawHeaders["mime-type"];
        if (xt) {
          var Et = xt.match(/;\s*charset=([^;])(;|$)/);
          Et && (bt._charset = Et[1].toLowerCase());
        }
        bt._charset || (bt._charset = "utf-8");
      }
    }
  };
  return Ke(Qe, Ve.Readable), Qe.prototype._read = function() {
    var at = this || _global$23, ut = at._resumeFetch;
    ut && (at._resumeFetch = null, ut());
  }, Qe.prototype._onXHRProgress = function(at) {
    var ut = this || _global$23, lt = ut._xhr, dt = null;
    switch (ut._mode) {
      case "text":
        if (dt = lt.responseText, dt.length > ut._pos) {
          var bt = dt.substr(ut._pos);
          if (ut._charset === "x-user-defined") {
            for (var $t = $e.alloc(bt.length), vt = 0; vt < bt.length; vt++)
              $t[vt] = bt.charCodeAt(vt) & 255;
            ut.push($t);
          } else
            ut.push(bt, ut._charset);
          ut._pos = dt.length;
        }
        break;
      case "arraybuffer":
        if (lt.readyState !== Je.DONE || !lt.response)
          break;
        dt = lt.response, ut.push($e.from(new Uint8Array(dt)));
        break;
      case "moz-chunked-arraybuffer":
        if (dt = lt.response, lt.readyState !== Je.LOADING || !dt)
          break;
        ut.push($e.from(new Uint8Array(dt)));
        break;
      case "ms-stream":
        if (dt = lt.response, lt.readyState !== Je.LOADING)
          break;
        var wt = new _global$23.MSStreamReader();
        wt.onprogress = function() {
          wt.result.byteLength > ut._pos && (ut.push($e.from(new Uint8Array(wt.result.slice(ut._pos)))), ut._pos = wt.result.byteLength);
        }, wt.onload = function() {
          at(!0), ut.push(null);
        }, wt.readAsArrayBuffer(dt);
        break;
    }
    ut._xhr.readyState === Je.DONE && ut._mode !== "ms-stream" && (at(!0), ut.push(null));
  }, exports$53;
}
function dew$33() {
  if (_dewExec$33)
    return exports$43;
  _dewExec$33 = !0;
  var $e = buffer.Buffer, Ze = process2, Fe = dew$53(), Ke = dew$f(), Ve = dew$43(), Je = dew4(), Qe = Ve.IncomingMessage, at = Ve.readyStates;
  function ut($t, vt) {
    return Fe.fetch && vt ? "fetch" : Fe.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : Fe.msstream ? "ms-stream" : Fe.arraybuffer && $t ? "arraybuffer" : "text";
  }
  var lt = exports$43 = function($t) {
    var vt = this || _global$13;
    Je.Writable.call(vt), vt._opts = $t, vt._body = [], vt._headers = {}, $t.auth && vt.setHeader("Authorization", "Basic " + $e.from($t.auth).toString("base64")), Object.keys($t.headers).forEach(function(Et) {
      vt.setHeader(Et, $t.headers[Et]);
    });
    var wt, xt = !0;
    if ($t.mode === "disable-fetch" || "requestTimeout" in $t && !Fe.abortController)
      xt = !1, wt = !0;
    else if ($t.mode === "prefer-streaming")
      wt = !1;
    else if ($t.mode === "allow-wrong-content-type")
      wt = !Fe.overrideMimeType;
    else if (!$t.mode || $t.mode === "default" || $t.mode === "prefer-fast")
      wt = !0;
    else
      throw new Error("Invalid value for opts.mode");
    vt._mode = ut(wt, xt), vt._fetchTimer = null, vt._socketTimeout = null, vt._socketTimer = null, vt.on("finish", function() {
      vt._onFinish();
    });
  };
  Ke(lt, Je.Writable), lt.prototype.setHeader = function($t, vt) {
    var wt = this || _global$13, xt = $t.toLowerCase();
    bt.indexOf(xt) === -1 && (wt._headers[xt] = {
      name: $t,
      value: vt
    });
  }, lt.prototype.getHeader = function($t) {
    var vt = (this || _global$13)._headers[$t.toLowerCase()];
    return vt ? vt.value : null;
  }, lt.prototype.removeHeader = function($t) {
    var vt = this || _global$13;
    delete vt._headers[$t.toLowerCase()];
  }, lt.prototype._onFinish = function() {
    var $t = this || _global$13;
    if (!$t._destroyed) {
      var vt = $t._opts;
      "timeout" in vt && vt.timeout !== 0 && $t.setTimeout(vt.timeout);
      var wt = $t._headers, xt = null;
      vt.method !== "GET" && vt.method !== "HEAD" && (xt = new Blob($t._body, {
        type: (wt["content-type"] || {}).value || ""
      }));
      var Et = [];
      if (Object.keys(wt).forEach(function(Zt) {
        var Lt = wt[Zt].name, Ut = wt[Zt].value;
        Array.isArray(Ut) ? Ut.forEach(function(Pt) {
          Et.push([Lt, Pt]);
        }) : Et.push([Lt, Ut]);
      }), $t._mode === "fetch") {
        var Tt = null;
        if (Fe.abortController) {
          var Rt = new AbortController();
          Tt = Rt.signal, $t._fetchAbortController = Rt, "requestTimeout" in vt && vt.requestTimeout !== 0 && ($t._fetchTimer = _global$13.setTimeout(function() {
            $t.emit("requestTimeout"), $t._fetchAbortController && $t._fetchAbortController.abort();
          }, vt.requestTimeout));
        }
        _global$13.fetch($t._opts.url, {
          method: $t._opts.method,
          headers: Et,
          body: xt || void 0,
          mode: "cors",
          credentials: vt.withCredentials ? "include" : "same-origin",
          signal: Tt
        }).then(function(Zt) {
          $t._fetchResponse = Zt, $t._resetTimers(!1), $t._connect();
        }, function(Zt) {
          $t._resetTimers(!0), $t._destroyed || $t.emit("error", Zt);
        });
      } else {
        var Ct = $t._xhr = new _global$13.XMLHttpRequest();
        try {
          Ct.open($t._opts.method, $t._opts.url, !0);
        } catch (Zt) {
          Ze.nextTick(function() {
            $t.emit("error", Zt);
          });
          return;
        }
        "responseType" in Ct && (Ct.responseType = $t._mode), "withCredentials" in Ct && (Ct.withCredentials = !!vt.withCredentials), $t._mode === "text" && "overrideMimeType" in Ct && Ct.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in vt && (Ct.timeout = vt.requestTimeout, Ct.ontimeout = function() {
          $t.emit("requestTimeout");
        }), Et.forEach(function(Zt) {
          Ct.setRequestHeader(Zt[0], Zt[1]);
        }), $t._response = null, Ct.onreadystatechange = function() {
          switch (Ct.readyState) {
            case at.LOADING:
            case at.DONE:
              $t._onXHRProgress();
              break;
          }
        }, $t._mode === "moz-chunked-arraybuffer" && (Ct.onprogress = function() {
          $t._onXHRProgress();
        }), Ct.onerror = function() {
          $t._destroyed || ($t._resetTimers(!0), $t.emit("error", new Error("XHR error")));
        };
        try {
          Ct.send(xt);
        } catch (Zt) {
          Ze.nextTick(function() {
            $t.emit("error", Zt);
          });
          return;
        }
      }
    }
  };
  function dt($t) {
    try {
      var vt = $t.status;
      return vt !== null && vt !== 0;
    } catch {
      return !1;
    }
  }
  lt.prototype._onXHRProgress = function() {
    var $t = this || _global$13;
    $t._resetTimers(!1), !(!dt($t._xhr) || $t._destroyed) && ($t._response || $t._connect(), $t._response._onXHRProgress($t._resetTimers.bind($t)));
  }, lt.prototype._connect = function() {
    var $t = this || _global$13;
    $t._destroyed || ($t._response = new Qe($t._xhr, $t._fetchResponse, $t._mode, $t._resetTimers.bind($t)), $t._response.on("error", function(vt) {
      $t.emit("error", vt);
    }), $t.emit("response", $t._response));
  }, lt.prototype._write = function($t, vt, wt) {
    var xt = this || _global$13;
    xt._body.push($t), wt();
  }, lt.prototype._resetTimers = function($t) {
    var vt = this || _global$13;
    _global$13.clearTimeout(vt._socketTimer), vt._socketTimer = null, $t ? (_global$13.clearTimeout(vt._fetchTimer), vt._fetchTimer = null) : vt._socketTimeout && (vt._socketTimer = _global$13.setTimeout(function() {
      vt.emit("timeout");
    }, vt._socketTimeout));
  }, lt.prototype.abort = lt.prototype.destroy = function($t) {
    var vt = this || _global$13;
    vt._destroyed = !0, vt._resetTimers(!0), vt._response && (vt._response._destroyed = !0), vt._xhr ? vt._xhr.abort() : vt._fetchAbortController && vt._fetchAbortController.abort(), $t && vt.emit("error", $t);
  }, lt.prototype.end = function($t, vt, wt) {
    var xt = this || _global$13;
    typeof $t == "function" && (wt = $t, $t = void 0), Je.Writable.prototype.end.call(xt, $t, vt, wt);
  }, lt.prototype.setTimeout = function($t, vt) {
    var wt = this || _global$13;
    vt && wt.once("timeout", vt), wt._socketTimeout = $t, wt._resetTimers(!1);
  }, lt.prototype.flushHeaders = function() {
  }, lt.prototype.setNoDelay = function() {
  }, lt.prototype.setSocketKeepAlive = function() {
  };
  var bt = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
  return exports$43;
}
function dew$211() {
  if (_dewExec$211)
    return exports$34;
  _dewExec$211 = !0, exports$34 = Ze;
  var $e = Object.prototype.hasOwnProperty;
  function Ze() {
    for (var Fe = {}, Ke = 0; Ke < arguments.length; Ke++) {
      var Ve = arguments[Ke];
      for (var Je in Ve)
        $e.call(Ve, Je) && (Fe[Je] = Ve[Je]);
    }
    return Fe;
  }
  return exports$34;
}
function dew$111() {
  return _dewExec$111 || (_dewExec$111 = !0, exports$211 = {
    100: "Continue",
    101: "Switching Protocols",
    102: "Processing",
    200: "OK",
    201: "Created",
    202: "Accepted",
    203: "Non-Authoritative Information",
    204: "No Content",
    205: "Reset Content",
    206: "Partial Content",
    207: "Multi-Status",
    208: "Already Reported",
    226: "IM Used",
    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Found",
    303: "See Other",
    304: "Not Modified",
    305: "Use Proxy",
    307: "Temporary Redirect",
    308: "Permanent Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    409: "Conflict",
    410: "Gone",
    411: "Length Required",
    412: "Precondition Failed",
    413: "Payload Too Large",
    414: "URI Too Long",
    415: "Unsupported Media Type",
    416: "Range Not Satisfiable",
    417: "Expectation Failed",
    418: "I'm a teapot",
    421: "Misdirected Request",
    422: "Unprocessable Entity",
    423: "Locked",
    424: "Failed Dependency",
    425: "Unordered Collection",
    426: "Upgrade Required",
    428: "Precondition Required",
    429: "Too Many Requests",
    431: "Request Header Fields Too Large",
    451: "Unavailable For Legal Reasons",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Timeout",
    505: "HTTP Version Not Supported",
    506: "Variant Also Negotiates",
    507: "Insufficient Storage",
    508: "Loop Detected",
    509: "Bandwidth Limit Exceeded",
    510: "Not Extended",
    511: "Network Authentication Required"
  }), exports$211;
}
function dew8() {
  if (_dewExec8)
    return exports$112;
  _dewExec8 = !0;
  var $e = dew$33(), Ze = dew$43(), Fe = dew$211(), Ke = dew$111(), Ve = h7, Je = exports$112;
  return Je.request = function(Qe, at) {
    typeof Qe == "string" ? Qe = Ve.parse(Qe) : Qe = Fe(Qe);
    var ut = _global5.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", lt = Qe.protocol || ut, dt = Qe.hostname || Qe.host, bt = Qe.port, $t = Qe.path || "/";
    dt && dt.indexOf(":") !== -1 && (dt = "[" + dt + "]"), Qe.url = (dt ? lt + "//" + dt : "") + (bt ? ":" + bt : "") + $t, Qe.method = (Qe.method || "GET").toUpperCase(), Qe.headers = Qe.headers || {};
    var vt = new $e(Qe);
    return at && vt.on("response", at), vt;
  }, Je.get = function(at, ut) {
    var lt = Je.request(at, ut);
    return lt.end(), lt;
  }, Je.ClientRequest = $e, Je.IncomingMessage = Ze.IncomingMessage, Je.Agent = function() {
  }, Je.Agent.defaultMaxSockets = 4, Je.globalAgent = new Je.Agent(), Je.STATUS_CODES = Ke, Je.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"], exports$112;
}
var exports$63, _dewExec$53, _global$32, exports$53, _dewExec$43, _global$23, exports$43, _dewExec$33, _global$13, exports$34, _dewExec$211, exports$211, _dewExec$111, exports$112, _dewExec8, _global5, exports8, Agent, ClientRequest, IncomingMessage, METHODS, STATUS_CODES, get, globalAgent, request, init_http = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/http.js"() {
    init_dirname(), init_buffer2(), init_process2(), init_chunk_44e51b61(), init_chunk_c3d025d9(), init_chunk_2eac56ff(), init_url(), init_chunk_4bd36a8f(), init_chunk_ce0fbc82(), init_chunk_b4205b57(), init_chunk_5decc758(), init_chunk_4ccc3a29(), init_chunk_924bb2e1(), init_chunk_b04e620d(), init_chunk_23dbec7b(), exports$63 = {}, _dewExec$53 = !1, _global$32 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, exports$53 = {}, _dewExec$43 = !1, _global$23 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, exports$43 = {}, _dewExec$33 = !1, _global$13 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, exports$34 = {}, _dewExec$211 = !1, exports$211 = {}, _dewExec$111 = !1, exports$112 = {}, _dewExec8 = !1, _global5 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, exports8 = dew8(), Agent = exports8.Agent, ClientRequest = exports8.ClientRequest, IncomingMessage = exports8.IncomingMessage, METHODS = exports8.METHODS, STATUS_CODES = exports8.STATUS_CODES, get = exports8.get, globalAgent = exports8.globalAgent, request = exports8.request;
  }
}), https_exports = {};
__export(https_exports, {
  Agent: () => Agent2,
  ClientRequest: () => ClientRequest2,
  IncomingMessage: () => IncomingMessage2,
  METHODS: () => METHODS2,
  STATUS_CODES: () => STATUS_CODES2,
  default: () => exports9,
  get: () => get2,
  globalAgent: () => globalAgent2,
  request: () => request2
});
function dew9() {
  if (_dewExec9)
    return exports$113;
  _dewExec9 = !0;
  var $e = exports8, Ze = h7, Fe = exports$113;
  for (var Ke in $e)
    $e.hasOwnProperty(Ke) && (Fe[Ke] = $e[Ke]);
  Fe.request = function(Je, Qe) {
    return Je = Ve(Je), $e.request.call(this || _global6, Je, Qe);
  }, Fe.get = function(Je, Qe) {
    return Je = Ve(Je), $e.get.call(this || _global6, Je, Qe);
  };
  function Ve(Je) {
    if (typeof Je == "string" && (Je = Ze.parse(Je)), Je.protocol || (Je.protocol = "https:"), Je.protocol !== "https:")
      throw new Error('Protocol "' + Je.protocol + '" not supported. Expected "https:"');
    return Je;
  }
  return exports$113;
}
var exports$113, _dewExec9, _global6, exports9, Agent2, ClientRequest2, IncomingMessage2, METHODS2, STATUS_CODES2, get2, globalAgent2, request2, init_https = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/https.js"() {
    init_dirname(), init_buffer2(), init_process2(), init_http(), init_url(), init_chunk_44e51b61(), init_chunk_4bd36a8f(), init_chunk_ce0fbc82(), init_chunk_b4205b57(), init_chunk_5decc758(), init_chunk_2eac56ff(), init_chunk_4ccc3a29(), init_chunk_c3d025d9(), init_chunk_924bb2e1(), init_chunk_b04e620d(), init_chunk_23dbec7b(), exports$113 = {}, _dewExec9 = !1, _global6 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, exports9 = dew9(), Agent2 = exports9.Agent, ClientRequest2 = exports9.ClientRequest, IncomingMessage2 = exports9.IncomingMessage, METHODS2 = exports9.METHODS, STATUS_CODES2 = exports9.STATUS_CODES, get2 = exports9.get, globalAgent2 = exports9.globalAgent, request2 = exports9.request;
  }
}), util_exports = {};
__export(util_exports, {
  TextDecoder: () => TextDecoder2,
  TextEncoder: () => TextEncoder2,
  _extend: () => _extend2,
  callbackify: () => callbackify2,
  debuglog: () => debuglog2,
  default: () => X,
  deprecate: () => deprecate2,
  format: () => format3,
  inherits: () => inherits3,
  inspect: () => inspect2,
  isArray: () => isArray3,
  isBoolean: () => isBoolean3,
  isBuffer: () => isBuffer3,
  isDate: () => isDate3,
  isError: () => isError2,
  isFunction: () => isFunction3,
  isNull: () => isNull2,
  isNullOrUndefined: () => isNullOrUndefined2,
  isNumber: () => isNumber3,
  isObject: () => isObject4,
  isPrimitive: () => isPrimitive2,
  isRegExp: () => isRegExp3,
  isString: () => isString3,
  isSymbol: () => isSymbol2,
  isUndefined: () => isUndefined3,
  log: () => log2,
  promisify: () => promisify2,
  types: () => types2
});
var _extend2, callbackify2, debuglog2, deprecate2, format3, inherits3, inspect2, isArray3, isBoolean3, isBuffer3, isDate3, isError2, isFunction3, isNull2, isNullOrUndefined2, isNumber3, isObject4, isPrimitive2, isRegExp3, isString3, isSymbol2, isUndefined3, log2, promisify2, types2, TextEncoder2, TextDecoder2, init_util = __esm({
  "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/util.js"() {
    init_dirname(), init_buffer2(), init_process2(), init_chunk_ce0fbc82(), init_chunk_b4205b57(), init_chunk_b4205b57(), init_chunk_5decc758(), _extend2 = X._extend, callbackify2 = X.callbackify, debuglog2 = X.debuglog, deprecate2 = X.deprecate, format3 = X.format, inherits3 = X.inherits, inspect2 = X.inspect, isArray3 = X.isArray, isBoolean3 = X.isBoolean, isBuffer3 = X.isBuffer, isDate3 = X.isDate, isError2 = X.isError, isFunction3 = X.isFunction, isNull2 = X.isNull, isNullOrUndefined2 = X.isNullOrUndefined, isNumber3 = X.isNumber, isObject4 = X.isObject, isPrimitive2 = X.isPrimitive, isRegExp3 = X.isRegExp, isString3 = X.isString, isSymbol2 = X.isSymbol, isUndefined3 = X.isUndefined, log2 = X.log, promisify2 = X.promisify, types2 = X.types, TextEncoder2 = X.TextEncoder = globalThis.TextEncoder, TextDecoder2 = X.TextDecoder = globalThis.TextDecoder;
  }
}), require_eventsource2 = __commonJS({
  "../../node_modules/.pnpm/eventsource@2.0.2/node_modules/eventsource/lib/eventsource.js"($e, Ze) {
    init_dirname(), init_buffer2(), init_process2();
    var Fe = (init_url(), __toCommonJS(url_exports)).parse, Ke = (init_events(), __toCommonJS(events_exports)), Ve = (init_https(), __toCommonJS(https_exports)), Je = (init_http(), __toCommonJS(http_exports)), Qe = (init_util(), __toCommonJS(util_exports)), at = [
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "rejectUnauthorized",
      "secureProtocol",
      "servername",
      "checkServerIdentity"
    ], ut = [239, 187, 191], lt = 58, dt = 32, bt = 10, $t = 13, vt = 1024 * 256, wt = /^(cookie|authorization)$/i;
    function xt(Zt) {
      return ut.every(function(Lt, Ut) {
        return Zt[Ut] === Lt;
      });
    }
    function Et(Zt, Lt) {
      var Ut = Et.CONNECTING, Pt = Lt && Lt.headers, Ot = !1;
      Object.defineProperty(this, "readyState", {
        get: function() {
          return Ut;
        }
      }), Object.defineProperty(this, "url", {
        get: function() {
          return Zt;
        }
      });
      var Ft = this;
      Ft.reconnectInterval = 1e3, Ft.connectionInProgress = !1;
      function gt(ct) {
        Ut !== Et.CLOSED && (Ut = Et.CONNECTING, pt("error", new Tt("error", { message: ct })), mt && (Zt = mt, mt = null, Ot = !1), setTimeout(function() {
          Ut !== Et.CONNECTING || Ft.connectionInProgress || (Ft.connectionInProgress = !0, yt());
        }, Ft.reconnectInterval));
      }
      var We, Xe = "";
      Pt && Pt["Last-Event-ID"] && (Xe = Pt["Last-Event-ID"], delete Pt["Last-Event-ID"]);
      var rt = !1, ot = "", ft = "", mt = null;
      function yt() {
        var ct = Fe(Zt), Mt = ct.protocol === "https:";
        if (ct.headers = { "Cache-Control": "no-cache", Accept: "text/event-stream" }, Xe && (ct.headers["Last-Event-ID"] = Xe), Pt) {
          var St = Ot ? Ct(Pt) : Pt;
          for (var At in St) {
            var Nt = St[At];
            Nt && (ct.headers[At] = Nt);
          }
        }
        ct.rejectUnauthorized = !(Lt && !Lt.rejectUnauthorized), Lt && Lt.createConnection !== void 0 && (ct.createConnection = Lt.createConnection);
        var qt = Lt && Lt.proxy;
        if (qt) {
          var Qt = Fe(Lt.proxy);
          Mt = Qt.protocol === "https:", ct.protocol = Mt ? "https:" : "http:", ct.path = Zt, ct.headers.Host = ct.host, ct.hostname = Qt.hostname, ct.host = Qt.host, ct.port = Qt.port;
        }
        if (Lt && Lt.https) {
          for (var Xt in Lt.https)
            if (at.indexOf(Xt) !== -1) {
              var zt = Lt.https[Xt];
              zt !== void 0 && (ct[Xt] = zt);
            }
        }
        Lt && Lt.withCredentials !== void 0 && (ct.withCredentials = Lt.withCredentials), We = (Mt ? Ve : Je).request(ct, function(Kt) {
          if (Ft.connectionInProgress = !1, Kt.statusCode === 500 || Kt.statusCode === 502 || Kt.statusCode === 503 || Kt.statusCode === 504) {
            pt("error", new Tt("error", { status: Kt.statusCode, message: Kt.statusMessage })), gt();
            return;
          }
          if (Kt.statusCode === 301 || Kt.statusCode === 302 || Kt.statusCode === 307) {
            var ur = Kt.headers.location;
            if (!ur) {
              pt("error", new Tt("error", { status: Kt.statusCode, message: Kt.statusMessage }));
              return;
            }
            var er = new URL(Zt).origin, Dt = new URL(ur).origin;
            Ot = er !== Dt, Kt.statusCode === 307 && (mt = Zt), Zt = ur, process_exports.nextTick(yt);
            return;
          }
          if (Kt.statusCode !== 200)
            return pt("error", new Tt("error", { status: Kt.statusCode, message: Kt.statusMessage })), Ft.close();
          Ut = Et.OPEN, Kt.on("close", function() {
            Kt.removeAllListeners("close"), Kt.removeAllListeners("end"), gt();
          }), Kt.on("end", function() {
            Kt.removeAllListeners("close"), Kt.removeAllListeners("end"), gt();
          }), pt("open", new Tt("open"));
          var Ht, Gt, rr = 0, sr = -1, Jt = 0, ir = 0;
          Kt.on("data", function(Br) {
            Ht ? (Br.length > Ht.length - ir && (Jt = Ht.length * 2 + Br.length, Jt > vt && (Jt = Ht.length + Br.length + vt), Gt = Buffer2.alloc(Jt), Ht.copy(Gt, 0, 0, ir), Ht = Gt), Br.copy(Ht, ir), ir += Br.length) : (Ht = Br, xt(Ht) && (Ht = Ht.slice(ut.length)), ir = Ht.length);
            for (var or = 0, lr = ir; or < lr; ) {
              rt && (Ht[or] === bt && ++or, rt = !1);
              for (var Nr = -1, dr = sr, gr, Zr = rr; Nr < 0 && Zr < lr; ++Zr)
                gr = Ht[Zr], gr === lt ? dr < 0 && (dr = Zr - or) : gr === $t ? (rt = !0, Nr = Zr - or) : gr === bt && (Nr = Zr - or);
              if (Nr < 0) {
                rr = lr - or, sr = dr;
                break;
              } else
                rr = 0, sr = -1;
              Ge(Ht, or, dr, Nr), or += Nr + 1;
            }
            or === lr ? (Ht = void 0, ir = 0) : or > 0 && (Ht = Ht.slice(or, ir), ir = Ht.length);
          });
        }), We.on("error", function(Kt) {
          Ft.connectionInProgress = !1, gt(Kt.message);
        }), We.setNoDelay && We.setNoDelay(!0), We.end();
      }
      yt();
      function pt() {
        Ft.listeners(arguments[0]).length > 0 && Ft.emit.apply(Ft, arguments);
      }
      this._close = function() {
        Ut !== Et.CLOSED && (Ut = Et.CLOSED, We.abort && We.abort(), We.xhr && We.xhr.abort && We.xhr.abort());
      };
      function Ge(ct, Mt, St, At) {
        if (At === 0) {
          if (ot.length > 0) {
            var Nt = ft || "message";
            pt(Nt, new Rt(Nt, {
              data: ot.slice(0, -1),
              lastEventId: Xe,
              origin: new URL(Zt).origin
            })), ot = "";
          }
          ft = void 0;
        } else if (St > 0) {
          var qt = St < 0, Qt = 0, Xt = ct.slice(Mt, Mt + (qt ? At : St)).toString();
          qt ? Qt = At : ct[Mt + St + 1] !== dt ? Qt = St + 1 : Qt = St + 2, Mt += Qt;
          var zt = At - Qt, Kt = ct.slice(Mt, Mt + zt).toString();
          if (Xt === "data")
            ot += Kt + `
`;
          else if (Xt === "event")
            ft = Kt;
          else if (Xt === "id")
            Xe = Kt;
          else if (Xt === "retry") {
            var ur = parseInt(Kt, 10);
            Number.isNaN(ur) || (Ft.reconnectInterval = ur);
          }
        }
      }
    }
    Ze.exports = Et, Qe.inherits(Et, Ke.EventEmitter), Et.prototype.constructor = Et, ["open", "error", "message"].forEach(function(Zt) {
      Object.defineProperty(Et.prototype, "on" + Zt, {
        get: function() {
          var Ut = this.listeners(Zt)[0];
          return Ut ? Ut._listener ? Ut._listener : Ut : void 0;
        },
        set: function(Ut) {
          this.removeAllListeners(Zt), this.addEventListener(Zt, Ut);
        }
      });
    }), Object.defineProperty(Et, "CONNECTING", { enumerable: !0, value: 0 }), Object.defineProperty(Et, "OPEN", { enumerable: !0, value: 1 }), Object.defineProperty(Et, "CLOSED", { enumerable: !0, value: 2 }), Et.prototype.CONNECTING = 0, Et.prototype.OPEN = 1, Et.prototype.CLOSED = 2, Et.prototype.close = function() {
      this._close();
    }, Et.prototype.addEventListener = function(Lt, Ut) {
      typeof Ut == "function" && (Ut._listener = Ut, this.on(Lt, Ut));
    }, Et.prototype.dispatchEvent = function(Lt) {
      if (!Lt.type)
        throw new Error("UNSPECIFIED_EVENT_TYPE_ERR");
      this.emit(Lt.type, Lt.detail);
    }, Et.prototype.removeEventListener = function(Lt, Ut) {
      typeof Ut == "function" && (Ut._listener = void 0, this.removeListener(Lt, Ut));
    };
    function Tt(Zt, Lt) {
      if (Object.defineProperty(this, "type", { writable: !1, value: Zt, enumerable: !0 }), Lt)
        for (var Ut in Lt)
          Lt.hasOwnProperty(Ut) && Object.defineProperty(this, Ut, { writable: !1, value: Lt[Ut], enumerable: !0 });
    }
    function Rt(Zt, Lt) {
      Object.defineProperty(this, "type", { writable: !1, value: Zt, enumerable: !0 });
      for (var Ut in Lt)
        Lt.hasOwnProperty(Ut) && Object.defineProperty(this, Ut, { writable: !1, value: Lt[Ut], enumerable: !0 });
    }
    function Ct(Zt) {
      var Lt = {};
      for (var Ut in Zt)
        wt.test(Ut) || (Lt[Ut] = Zt[Ut]);
      return Lt;
    }
  }
});
init_dirname();
init_buffer2();
init_process2();
var import_browser_or_node2 = __toESM(require_lib()), axios_exports = {};
__export(axios_exports, {
  Axios: () => Axios2,
  AxiosError: () => AxiosError2,
  AxiosHeaders: () => AxiosHeaders2,
  Cancel: () => Cancel,
  CancelToken: () => CancelToken2,
  CanceledError: () => CanceledError2,
  HttpStatusCode: () => HttpStatusCode2,
  VERSION: () => VERSION2,
  all: () => all2,
  default: () => axios_default,
  formToJSON: () => formToJSON,
  isAxiosError: () => isAxiosError2,
  isCancel: () => isCancel2,
  mergeConfig: () => mergeConfig2,
  spread: () => spread2,
  toFormData: () => toFormData2
});
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
function bind($e, Ze) {
  return function() {
    return $e.apply(Ze, arguments);
  };
}
var { toString: toString$1 } = Object.prototype, { getPrototypeOf } = Object, kindOf = (($e) => (Ze) => {
  const Fe = toString$1.call(Ze);
  return $e[Fe] || ($e[Fe] = Fe.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), kindOfTest = ($e) => ($e = $e.toLowerCase(), (Ze) => kindOf(Ze) === $e), typeOfTest = ($e) => (Ze) => typeof Ze === $e, { isArray } = Array, isUndefined = typeOfTest("undefined");
function isBuffer($e) {
  return $e !== null && !isUndefined($e) && $e.constructor !== null && !isUndefined($e.constructor) && isFunction($e.constructor.isBuffer) && $e.constructor.isBuffer($e);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView($e) {
  let Ze;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? Ze = ArrayBuffer.isView($e) : Ze = $e && $e.buffer && isArrayBuffer($e.buffer), Ze;
}
var isString = typeOfTest("string"), isFunction = typeOfTest("function"), isNumber = typeOfTest("number"), isObject = ($e) => $e !== null && typeof $e == "object", isBoolean = ($e) => $e === !0 || $e === !1, isPlainObject = ($e) => {
  if (kindOf($e) !== "object")
    return !1;
  const Ze = getPrototypeOf($e);
  return (Ze === null || Ze === Object.prototype || Object.getPrototypeOf(Ze) === null) && !(Symbol.toStringTag in $e) && !(Symbol.iterator in $e);
}, isDate = kindOfTest("Date"), isFile = kindOfTest("File"), isBlob = kindOfTest("Blob"), isFileList = kindOfTest("FileList"), isStream = ($e) => isObject($e) && isFunction($e.pipe), isFormData = ($e) => {
  const Ze = "[object FormData]";
  return $e && (typeof FormData == "function" && $e instanceof FormData || toString$1.call($e) === Ze || isFunction($e.toString) && $e.toString() === Ze);
}, isURLSearchParams = kindOfTest("URLSearchParams"), trim = ($e) => $e.trim ? $e.trim() : $e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach($e, Ze, { allOwnKeys: Fe = !1 } = {}) {
  if ($e === null || typeof $e > "u")
    return;
  let Ke, Ve;
  if (typeof $e != "object" && ($e = [$e]), isArray($e))
    for (Ke = 0, Ve = $e.length; Ke < Ve; Ke++)
      Ze.call(null, $e[Ke], Ke, $e);
  else {
    const Je = Fe ? Object.getOwnPropertyNames($e) : Object.keys($e), Qe = Je.length;
    let at;
    for (Ke = 0; Ke < Qe; Ke++)
      at = Je[Ke], Ze.call(null, $e[at], at, $e);
  }
}
function findKey($e, Ze) {
  Ze = Ze.toLowerCase();
  const Fe = Object.keys($e);
  let Ke = Fe.length, Ve;
  for (; Ke-- > 0; )
    if (Ve = Fe[Ke], Ze === Ve.toLowerCase())
      return Ve;
  return null;
}
var _global = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), isContextDefined = ($e) => !isUndefined($e) && $e !== _global;
function merge$1() {
  const { caseless: $e } = isContextDefined(this) && this || {}, Ze = {}, Fe = (Ke, Ve) => {
    const Je = $e && findKey(Ze, Ve) || Ve;
    isPlainObject(Ze[Je]) && isPlainObject(Ke) ? Ze[Je] = merge$1(Ze[Je], Ke) : isPlainObject(Ke) ? Ze[Je] = merge$1({}, Ke) : isArray(Ke) ? Ze[Je] = Ke.slice() : Ze[Je] = Ke;
  };
  for (let Ke = 0, Ve = arguments.length; Ke < Ve; Ke++)
    arguments[Ke] && forEach(arguments[Ke], Fe);
  return Ze;
}
var extend = ($e, Ze, Fe, { allOwnKeys: Ke } = {}) => (forEach(Ze, (Ve, Je) => {
  Fe && isFunction(Ve) ? $e[Je] = bind(Ve, Fe) : $e[Je] = Ve;
}, { allOwnKeys: Ke }), $e), stripBOM = ($e) => ($e.charCodeAt(0) === 65279 && ($e = $e.slice(1)), $e), inherits = ($e, Ze, Fe, Ke) => {
  $e.prototype = Object.create(Ze.prototype, Ke), $e.prototype.constructor = $e, Object.defineProperty($e, "super", {
    value: Ze.prototype
  }), Fe && Object.assign($e.prototype, Fe);
}, toFlatObject = ($e, Ze, Fe, Ke) => {
  let Ve, Je, Qe;
  const at = {};
  if (Ze = Ze || {}, $e == null)
    return Ze;
  do {
    for (Ve = Object.getOwnPropertyNames($e), Je = Ve.length; Je-- > 0; )
      Qe = Ve[Je], (!Ke || Ke(Qe, $e, Ze)) && !at[Qe] && (Ze[Qe] = $e[Qe], at[Qe] = !0);
    $e = Fe !== !1 && getPrototypeOf($e);
  } while ($e && (!Fe || Fe($e, Ze)) && $e !== Object.prototype);
  return Ze;
}, endsWith = ($e, Ze, Fe) => {
  $e = String($e), (Fe === void 0 || Fe > $e.length) && (Fe = $e.length), Fe -= Ze.length;
  const Ke = $e.indexOf(Ze, Fe);
  return Ke !== -1 && Ke === Fe;
}, toArray = ($e) => {
  if (!$e)
    return null;
  if (isArray($e))
    return $e;
  let Ze = $e.length;
  if (!isNumber(Ze))
    return null;
  const Fe = new Array(Ze);
  for (; Ze-- > 0; )
    Fe[Ze] = $e[Ze];
  return Fe;
}, isTypedArray = (($e) => (Ze) => $e && Ze instanceof $e)(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array)), forEachEntry = ($e, Ze) => {
  const Ke = ($e && $e[Symbol.iterator]).call($e);
  let Ve;
  for (; (Ve = Ke.next()) && !Ve.done; ) {
    const Je = Ve.value;
    Ze.call($e, Je[0], Je[1]);
  }
}, matchAll = ($e, Ze) => {
  let Fe;
  const Ke = [];
  for (; (Fe = $e.exec(Ze)) !== null; )
    Ke.push(Fe);
  return Ke;
}, isHTMLForm = kindOfTest("HTMLFormElement"), toCamelCase = ($e) => $e.toLowerCase().replace(
  /[_-\s]([a-z\d])(\w*)/g,
  function(Fe, Ke, Ve) {
    return Ke.toUpperCase() + Ve;
  }
), hasOwnProperty = (({ hasOwnProperty: $e }) => (Ze, Fe) => $e.call(Ze, Fe))(Object.prototype), isRegExp = kindOfTest("RegExp"), reduceDescriptors = ($e, Ze) => {
  const Fe = Object.getOwnPropertyDescriptors($e), Ke = {};
  forEach(Fe, (Ve, Je) => {
    Ze(Ve, Je, $e) !== !1 && (Ke[Je] = Ve);
  }), Object.defineProperties($e, Ke);
}, freezeMethods = ($e) => {
  reduceDescriptors($e, (Ze, Fe) => {
    if (isFunction($e) && ["arguments", "caller", "callee"].indexOf(Fe) !== -1)
      return !1;
    const Ke = $e[Fe];
    if (isFunction(Ke)) {
      if (Ze.enumerable = !1, "writable" in Ze) {
        Ze.writable = !1;
        return;
      }
      Ze.set || (Ze.set = () => {
        throw Error("Can not rewrite read-only method '" + Fe + "'");
      });
    }
  });
}, toObjectSet = ($e, Ze) => {
  const Fe = {}, Ke = (Ve) => {
    Ve.forEach((Je) => {
      Fe[Je] = !0;
    });
  };
  return isArray($e) ? Ke($e) : Ke(String($e).split(Ze)), Fe;
}, noop2 = () => {
}, toFiniteNumber = ($e, Ze) => ($e = +$e, Number.isFinite($e) ? $e : Ze), toJSONObject = ($e) => {
  const Ze = new Array(10), Fe = (Ke, Ve) => {
    if (isObject(Ke)) {
      if (Ze.indexOf(Ke) >= 0)
        return;
      if (!("toJSON" in Ke)) {
        Ze[Ve] = Ke;
        const Je = isArray(Ke) ? [] : {};
        return forEach(Ke, (Qe, at) => {
          const ut = Fe(Qe, Ve + 1);
          !isUndefined(ut) && (Je[at] = ut);
        }), Ze[Ve] = void 0, Je;
      }
    }
    return Ke;
  };
  return Fe($e, 0);
}, utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge$1,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop2,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  toJSONObject
};
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
function AxiosError($e, Ze, Fe, Ke, Ve) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = $e, this.name = "AxiosError", Ze && (this.code = Ze), Fe && (this.config = Fe), Ke && (this.request = Ke), Ve && (this.response = Ve);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype, descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
].forEach(($e) => {
  descriptors[$e] = { value: $e };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: !0 });
AxiosError.from = ($e, Ze, Fe, Ke, Ve, Je) => {
  const Qe = Object.create(prototype);
  return utils_default.toFlatObject($e, Qe, function(ut) {
    return ut !== Error.prototype;
  }, (at) => at !== "isAxiosError"), AxiosError.call(Qe, $e.message, Ze, Fe, Ke, Ve), Qe.cause = $e, Qe.name = $e.name, Je && Object.assign(Qe, Je), Qe;
};
var AxiosError_default = AxiosError;
init_dirname();
init_buffer2();
init_process2();
var import_form_data = __toESM(require_browser(), 1), FormData_default = import_form_data.default;
function isVisitable($e) {
  return utils_default.isPlainObject($e) || utils_default.isArray($e);
}
function removeBrackets($e) {
  return utils_default.endsWith($e, "[]") ? $e.slice(0, -2) : $e;
}
function renderKey($e, Ze, Fe) {
  return $e ? $e.concat(Ze).map(function(Ve, Je) {
    return Ve = removeBrackets(Ve), !Fe && Je ? "[" + Ve + "]" : Ve;
  }).join(Fe ? "." : "") : Ze;
}
function isFlatArray($e) {
  return utils_default.isArray($e) && !$e.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function(Ze) {
  return /^is[A-Z]/.test(Ze);
});
function isSpecCompliant($e) {
  return $e && utils_default.isFunction($e.append) && $e[Symbol.toStringTag] === "FormData" && $e[Symbol.iterator];
}
function toFormData($e, Ze, Fe) {
  if (!utils_default.isObject($e))
    throw new TypeError("target must be an object");
  Ze = Ze || new (FormData_default || FormData)(), Fe = utils_default.toFlatObject(Fe, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(xt, Et) {
    return !utils_default.isUndefined(Et[xt]);
  });
  const Ke = Fe.metaTokens, Ve = Fe.visitor || dt, Je = Fe.dots, Qe = Fe.indexes, ut = (Fe.Blob || typeof Blob < "u" && Blob) && isSpecCompliant(Ze);
  if (!utils_default.isFunction(Ve))
    throw new TypeError("visitor must be a function");
  function lt(wt) {
    if (wt === null)
      return "";
    if (utils_default.isDate(wt))
      return wt.toISOString();
    if (!ut && utils_default.isBlob(wt))
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    return utils_default.isArrayBuffer(wt) || utils_default.isTypedArray(wt) ? ut && typeof Blob == "function" ? new Blob([wt]) : Buffer2.from(wt) : wt;
  }
  function dt(wt, xt, Et) {
    let Tt = wt;
    if (wt && !Et && typeof wt == "object") {
      if (utils_default.endsWith(xt, "{}"))
        xt = Ke ? xt : xt.slice(0, -2), wt = JSON.stringify(wt);
      else if (utils_default.isArray(wt) && isFlatArray(wt) || utils_default.isFileList(wt) || utils_default.endsWith(xt, "[]") && (Tt = utils_default.toArray(wt)))
        return xt = removeBrackets(xt), Tt.forEach(function(Ct, Zt) {
          !(utils_default.isUndefined(Ct) || Ct === null) && Ze.append(
            Qe === !0 ? renderKey([xt], Zt, Je) : Qe === null ? xt : xt + "[]",
            lt(Ct)
          );
        }), !1;
    }
    return isVisitable(wt) ? !0 : (Ze.append(renderKey(Et, xt, Je), lt(wt)), !1);
  }
  const bt = [], $t = Object.assign(predicates, {
    defaultVisitor: dt,
    convertValue: lt,
    isVisitable
  });
  function vt(wt, xt) {
    if (!utils_default.isUndefined(wt)) {
      if (bt.indexOf(wt) !== -1)
        throw Error("Circular reference detected in " + xt.join("."));
      bt.push(wt), utils_default.forEach(wt, function(Tt, Rt) {
        (!(utils_default.isUndefined(Tt) || Tt === null) && Ve.call(
          Ze,
          Tt,
          utils_default.isString(Rt) ? Rt.trim() : Rt,
          xt,
          $t
        )) === !0 && vt(Tt, xt ? xt.concat(Rt) : [Rt]);
      }), bt.pop();
    }
  }
  if (!utils_default.isObject($e))
    throw new TypeError("data must be an object");
  return vt($e), Ze;
}
var toFormData_default = toFormData;
function encode($e) {
  const Ze = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent($e).replace(/[!'()~]|%20|%00/g, function(Ke) {
    return Ze[Ke];
  });
}
function AxiosURLSearchParams($e, Ze) {
  this._pairs = [], $e && toFormData_default($e, this, Ze);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function(Ze, Fe) {
  this._pairs.push([Ze, Fe]);
};
prototype2.toString = function(Ze) {
  const Fe = Ze ? function(Ke) {
    return Ze.call(this, Ke, encode);
  } : encode;
  return this._pairs.map(function(Ve) {
    return Fe(Ve[0]) + "=" + Fe(Ve[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;
function encode2($e) {
  return encodeURIComponent($e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL($e, Ze, Fe) {
  if (!Ze)
    return $e;
  const Ke = Fe && Fe.encode || encode2, Ve = Fe && Fe.serialize;
  let Je;
  if (Ve ? Je = Ve(Ze, Fe) : Je = utils_default.isURLSearchParams(Ze) ? Ze.toString() : new AxiosURLSearchParams_default(Ze, Fe).toString(Ke), Je) {
    const Qe = $e.indexOf("#");
    Qe !== -1 && ($e = $e.slice(0, Qe)), $e += ($e.indexOf("?") === -1 ? "?" : "&") + Je;
  }
  return $e;
}
init_dirname();
init_buffer2();
init_process2();
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  use($e, Ze, Fe) {
    return this.handlers.push({
      fulfilled: $e,
      rejected: Ze,
      synchronous: Fe ? Fe.synchronous : !1,
      runWhen: Fe ? Fe.runWhen : null
    }), this.handlers.length - 1;
  }
  eject($e) {
    this.handlers[$e] && (this.handlers[$e] = null);
  }
  clear() {
    this.handlers && (this.handlers = []);
  }
  forEach($e) {
    utils_default.forEach(this.handlers, function(Fe) {
      Fe !== null && $e(Fe);
    });
  }
}, InterceptorManager_default = InterceptorManager;
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
var transitional_default = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
};
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
var URLSearchParams_default = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams_default;
init_dirname();
init_buffer2();
init_process2();
var FormData_default2 = FormData, isStandardBrowserEnv = (() => {
  let $e;
  return typeof navigator < "u" && (($e = navigator.product) === "ReactNative" || $e === "NativeScript" || $e === "NS") ? !1 : typeof window < "u" && typeof document < "u";
})(), isStandardBrowserWebWorkerEnv = (() => typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), browser_default = {
  isBrowser: !0,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default2,
    Blob
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function toURLEncodedForm($e, Ze) {
  return toFormData_default($e, new browser_default.classes.URLSearchParams(), Object.assign({
    visitor: function(Fe, Ke, Ve, Je) {
      return browser_default.isNode && utils_default.isBuffer(Fe) ? (this.append(Ke, Fe.toString("base64")), !1) : Je.defaultVisitor.apply(this, arguments);
    }
  }, Ze));
}
init_dirname();
init_buffer2();
init_process2();
function parsePropPath($e) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, $e).map((Ze) => Ze[0] === "[]" ? "" : Ze[1] || Ze[0]);
}
function arrayToObject($e) {
  const Ze = {}, Fe = Object.keys($e);
  let Ke;
  const Ve = Fe.length;
  let Je;
  for (Ke = 0; Ke < Ve; Ke++)
    Je = Fe[Ke], Ze[Je] = $e[Je];
  return Ze;
}
function formDataToJSON($e) {
  function Ze(Fe, Ke, Ve, Je) {
    let Qe = Fe[Je++];
    const at = Number.isFinite(+Qe), ut = Je >= Fe.length;
    return Qe = !Qe && utils_default.isArray(Ve) ? Ve.length : Qe, ut ? (utils_default.hasOwnProp(Ve, Qe) ? Ve[Qe] = [Ve[Qe], Ke] : Ve[Qe] = Ke, !at) : ((!Ve[Qe] || !utils_default.isObject(Ve[Qe])) && (Ve[Qe] = []), Ze(Fe, Ke, Ve[Qe], Je) && utils_default.isArray(Ve[Qe]) && (Ve[Qe] = arrayToObject(Ve[Qe])), !at);
  }
  if (utils_default.isFormData($e) && utils_default.isFunction($e.entries)) {
    const Fe = {};
    return utils_default.forEachEntry($e, (Ke, Ve) => {
      Ze(parsePropPath(Ke), Ve, Fe, 0);
    }), Fe;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON, DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely($e, Ze, Fe) {
  if (utils_default.isString($e))
    try {
      return (Ze || JSON.parse)($e), utils_default.trim($e);
    } catch (Ke) {
      if (Ke.name !== "SyntaxError")
        throw Ke;
    }
  return (Fe || JSON.stringify)($e);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function(Ze, Fe) {
    const Ke = Fe.getContentType() || "", Ve = Ke.indexOf("application/json") > -1, Je = utils_default.isObject(Ze);
    if (Je && utils_default.isHTMLForm(Ze) && (Ze = new FormData(Ze)), utils_default.isFormData(Ze))
      return Ve && Ve ? JSON.stringify(formDataToJSON_default(Ze)) : Ze;
    if (utils_default.isArrayBuffer(Ze) || utils_default.isBuffer(Ze) || utils_default.isStream(Ze) || utils_default.isFile(Ze) || utils_default.isBlob(Ze))
      return Ze;
    if (utils_default.isArrayBufferView(Ze))
      return Ze.buffer;
    if (utils_default.isURLSearchParams(Ze))
      return Fe.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), Ze.toString();
    let at;
    if (Je) {
      if (Ke.indexOf("application/x-www-form-urlencoded") > -1)
        return toURLEncodedForm(Ze, this.formSerializer).toString();
      if ((at = utils_default.isFileList(Ze)) || Ke.indexOf("multipart/form-data") > -1) {
        const ut = this.env && this.env.FormData;
        return toFormData_default(
          at ? { "files[]": Ze } : Ze,
          ut && new ut(),
          this.formSerializer
        );
      }
    }
    return Je || Ve ? (Fe.setContentType("application/json", !1), stringifySafely(Ze)) : Ze;
  }],
  transformResponse: [function(Ze) {
    const Fe = this.transitional || defaults.transitional, Ke = Fe && Fe.forcedJSONParsing, Ve = this.responseType === "json";
    if (Ze && utils_default.isString(Ze) && (Ke && !this.responseType || Ve)) {
      const Qe = !(Fe && Fe.silentJSONParsing) && Ve;
      try {
        return JSON.parse(Ze);
      } catch (at) {
        if (Qe)
          throw at.name === "SyntaxError" ? AxiosError_default.from(at, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response) : at;
      }
    }
    return Ze;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: browser_default.classes.FormData,
    Blob: browser_default.classes.Blob
  },
  validateStatus: function(Ze) {
    return Ze >= 200 && Ze < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  }
};
utils_default.forEach(["delete", "get", "head"], function(Ze) {
  defaults.headers[Ze] = {};
});
utils_default.forEach(["post", "put", "patch"], function(Ze) {
  defaults.headers[Ze] = utils_default.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_default = defaults;
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), parseHeaders_default = ($e) => {
  const Ze = {};
  let Fe, Ke, Ve;
  return $e && $e.split(`
`).forEach(function(Qe) {
    Ve = Qe.indexOf(":"), Fe = Qe.substring(0, Ve).trim().toLowerCase(), Ke = Qe.substring(Ve + 1).trim(), !(!Fe || Ze[Fe] && ignoreDuplicateOf[Fe]) && (Fe === "set-cookie" ? Ze[Fe] ? Ze[Fe].push(Ke) : Ze[Fe] = [Ke] : Ze[Fe] = Ze[Fe] ? Ze[Fe] + ", " + Ke : Ke);
  }), Ze;
}, $internals = Symbol("internals");
function normalizeHeader($e) {
  return $e && String($e).trim().toLowerCase();
}
function normalizeValue($e) {
  return $e === !1 || $e == null ? $e : utils_default.isArray($e) ? $e.map(normalizeValue) : String($e);
}
function parseTokens($e) {
  const Ze = /* @__PURE__ */ Object.create(null), Fe = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let Ke;
  for (; Ke = Fe.exec($e); )
    Ze[Ke[1]] = Ke[2];
  return Ze;
}
function isValidHeaderName($e) {
  return /^[-_a-zA-Z]+$/.test($e.trim());
}
function matchHeaderValue($e, Ze, Fe, Ke) {
  if (utils_default.isFunction(Ke))
    return Ke.call(this, Ze, Fe);
  if (utils_default.isString(Ze)) {
    if (utils_default.isString(Ke))
      return Ze.indexOf(Ke) !== -1;
    if (utils_default.isRegExp(Ke))
      return Ke.test(Ze);
  }
}
function formatHeader($e) {
  return $e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (Ze, Fe, Ke) => Fe.toUpperCase() + Ke);
}
function buildAccessors($e, Ze) {
  const Fe = utils_default.toCamelCase(" " + Ze);
  ["get", "set", "has"].forEach((Ke) => {
    Object.defineProperty($e, Ke + Fe, {
      value: function(Ve, Je, Qe) {
        return this[Ke].call(this, Ze, Ve, Je, Qe);
      },
      configurable: !0
    });
  });
}
var AxiosHeaders = class {
  constructor($e) {
    $e && this.set($e);
  }
  set($e, Ze, Fe) {
    const Ke = this;
    function Ve(Qe, at, ut) {
      const lt = normalizeHeader(at);
      if (!lt)
        throw new Error("header name must be a non-empty string");
      const dt = utils_default.findKey(Ke, lt);
      (!dt || Ke[dt] === void 0 || ut === !0 || ut === void 0 && Ke[dt] !== !1) && (Ke[dt || at] = normalizeValue(Qe));
    }
    const Je = (Qe, at) => utils_default.forEach(Qe, (ut, lt) => Ve(ut, lt, at));
    return utils_default.isPlainObject($e) || $e instanceof this.constructor ? Je($e, Ze) : utils_default.isString($e) && ($e = $e.trim()) && !isValidHeaderName($e) ? Je(parseHeaders_default($e), Ze) : $e != null && Ve(Ze, $e, Fe), this;
  }
  get($e, Ze) {
    if ($e = normalizeHeader($e), $e) {
      const Fe = utils_default.findKey(this, $e);
      if (Fe) {
        const Ke = this[Fe];
        if (!Ze)
          return Ke;
        if (Ze === !0)
          return parseTokens(Ke);
        if (utils_default.isFunction(Ze))
          return Ze.call(this, Ke, Fe);
        if (utils_default.isRegExp(Ze))
          return Ze.exec(Ke);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has($e, Ze) {
    if ($e = normalizeHeader($e), $e) {
      const Fe = utils_default.findKey(this, $e);
      return !!(Fe && (!Ze || matchHeaderValue(this, this[Fe], Fe, Ze)));
    }
    return !1;
  }
  delete($e, Ze) {
    const Fe = this;
    let Ke = !1;
    function Ve(Je) {
      if (Je = normalizeHeader(Je), Je) {
        const Qe = utils_default.findKey(Fe, Je);
        Qe && (!Ze || matchHeaderValue(Fe, Fe[Qe], Qe, Ze)) && (delete Fe[Qe], Ke = !0);
      }
    }
    return utils_default.isArray($e) ? $e.forEach(Ve) : Ve($e), Ke;
  }
  clear() {
    return Object.keys(this).forEach(this.delete.bind(this));
  }
  normalize($e) {
    const Ze = this, Fe = {};
    return utils_default.forEach(this, (Ke, Ve) => {
      const Je = utils_default.findKey(Fe, Ve);
      if (Je) {
        Ze[Je] = normalizeValue(Ke), delete Ze[Ve];
        return;
      }
      const Qe = $e ? formatHeader(Ve) : String(Ve).trim();
      Qe !== Ve && delete Ze[Ve], Ze[Qe] = normalizeValue(Ke), Fe[Qe] = !0;
    }), this;
  }
  concat(...$e) {
    return this.constructor.concat(this, ...$e);
  }
  toJSON($e) {
    const Ze = /* @__PURE__ */ Object.create(null);
    return utils_default.forEach(this, (Fe, Ke) => {
      Fe != null && Fe !== !1 && (Ze[Ke] = $e && utils_default.isArray(Fe) ? Fe.join(", ") : Fe);
    }), Ze;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([$e, Ze]) => $e + ": " + Ze).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from($e) {
    return $e instanceof this ? $e : new this($e);
  }
  static concat($e, ...Ze) {
    const Fe = new this($e);
    return Ze.forEach((Ke) => Fe.set(Ke)), Fe;
  }
  static accessor($e) {
    const Fe = (this[$internals] = this[$internals] = {
      accessors: {}
    }).accessors, Ke = this.prototype;
    function Ve(Je) {
      const Qe = normalizeHeader(Je);
      Fe[Qe] || (buildAccessors(Ke, Je), Fe[Qe] = !0);
    }
    return utils_default.isArray($e) ? $e.forEach(Ve) : Ve($e), this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent"]);
utils_default.freezeMethods(AxiosHeaders.prototype);
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;
function transformData($e, Ze) {
  const Fe = this || defaults_default, Ke = Ze || Fe, Ve = AxiosHeaders_default.from(Ke.headers);
  let Je = Ke.data;
  return utils_default.forEach($e, function(at) {
    Je = at.call(Fe, Je, Ve.normalize(), Ze ? Ze.status : void 0);
  }), Ve.normalize(), Je;
}
init_dirname();
init_buffer2();
init_process2();
function isCancel($e) {
  return !!($e && $e.__CANCEL__);
}
init_dirname();
init_buffer2();
init_process2();
function CanceledError($e, Ze, Fe) {
  AxiosError_default.call(this, $e ?? "canceled", AxiosError_default.ERR_CANCELED, Ze, Fe), this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: !0
});
var CanceledError_default = CanceledError;
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
var null_default = null;
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
function settle($e, Ze, Fe) {
  const Ke = Fe.config.validateStatus;
  !Fe.status || !Ke || Ke(Fe.status) ? $e(Fe) : Ze(new AxiosError_default(
    "Request failed with status code " + Fe.status,
    [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(Fe.status / 100) - 4],
    Fe.config,
    Fe.request,
    Fe
  ));
}
init_dirname();
init_buffer2();
init_process2();
var cookies_default = browser_default.isStandardBrowserEnv ? function() {
  return {
    write: function(Fe, Ke, Ve, Je, Qe, at) {
      const ut = [];
      ut.push(Fe + "=" + encodeURIComponent(Ke)), utils_default.isNumber(Ve) && ut.push("expires=" + new Date(Ve).toGMTString()), utils_default.isString(Je) && ut.push("path=" + Je), utils_default.isString(Qe) && ut.push("domain=" + Qe), at === !0 && ut.push("secure"), document.cookie = ut.join("; ");
    },
    read: function(Fe) {
      const Ke = document.cookie.match(new RegExp("(^|;\\s*)(" + Fe + ")=([^;]*)"));
      return Ke ? decodeURIComponent(Ke[3]) : null;
    },
    remove: function(Fe) {
      this.write(Fe, "", Date.now() - 864e5);
    }
  };
}() : function() {
  return {
    write: function() {
    },
    read: function() {
      return null;
    },
    remove: function() {
    }
  };
}();
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
function isAbsoluteURL($e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test($e);
}
init_dirname();
init_buffer2();
init_process2();
function combineURLs($e, Ze) {
  return Ze ? $e.replace(/\/+$/, "") + "/" + Ze.replace(/^\/+/, "") : $e;
}
function buildFullPath($e, Ze) {
  return $e && !isAbsoluteURL(Ze) ? combineURLs($e, Ze) : Ze;
}
init_dirname();
init_buffer2();
init_process2();
var isURLSameOrigin_default = browser_default.isStandardBrowserEnv ? function() {
  const Ze = /(msie|trident)/i.test(navigator.userAgent), Fe = document.createElement("a");
  let Ke;
  function Ve(Je) {
    let Qe = Je;
    return Ze && (Fe.setAttribute("href", Qe), Qe = Fe.href), Fe.setAttribute("href", Qe), {
      href: Fe.href,
      protocol: Fe.protocol ? Fe.protocol.replace(/:$/, "") : "",
      host: Fe.host,
      search: Fe.search ? Fe.search.replace(/^\?/, "") : "",
      hash: Fe.hash ? Fe.hash.replace(/^#/, "") : "",
      hostname: Fe.hostname,
      port: Fe.port,
      pathname: Fe.pathname.charAt(0) === "/" ? Fe.pathname : "/" + Fe.pathname
    };
  }
  return Ke = Ve(window.location.href), function(Qe) {
    const at = utils_default.isString(Qe) ? Ve(Qe) : Qe;
    return at.protocol === Ke.protocol && at.host === Ke.host;
  };
}() : function() {
  return function() {
    return !0;
  };
}();
init_dirname();
init_buffer2();
init_process2();
function parseProtocol($e) {
  const Ze = /^([-+\w]{1,25})(:?\/\/|:)/.exec($e);
  return Ze && Ze[1] || "";
}
init_dirname();
init_buffer2();
init_process2();
function speedometer($e, Ze) {
  $e = $e || 10;
  const Fe = new Array($e), Ke = new Array($e);
  let Ve = 0, Je = 0, Qe;
  return Ze = Ze !== void 0 ? Ze : 1e3, function(ut) {
    const lt = Date.now(), dt = Ke[Je];
    Qe || (Qe = lt), Fe[Ve] = ut, Ke[Ve] = lt;
    let bt = Je, $t = 0;
    for (; bt !== Ve; )
      $t += Fe[bt++], bt = bt % $e;
    if (Ve = (Ve + 1) % $e, Ve === Je && (Je = (Je + 1) % $e), lt - Qe < Ze)
      return;
    const vt = dt && lt - dt;
    return vt ? Math.round($t * 1e3 / vt) : void 0;
  };
}
var speedometer_default = speedometer;
function progressEventReducer($e, Ze) {
  let Fe = 0;
  const Ke = speedometer_default(50, 250);
  return (Ve) => {
    const Je = Ve.loaded, Qe = Ve.lengthComputable ? Ve.total : void 0, at = Je - Fe, ut = Ke(at), lt = Je <= Qe;
    Fe = Je;
    const dt = {
      loaded: Je,
      total: Qe,
      progress: Qe ? Je / Qe : void 0,
      bytes: at,
      rate: ut || void 0,
      estimated: ut && Qe && lt ? (Qe - Je) / ut : void 0,
      event: Ve
    };
    dt[Ze ? "download" : "upload"] = !0, $e(dt);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest < "u", xhr_default = isXHRAdapterSupported && function($e) {
  return new Promise(function(Fe, Ke) {
    let Ve = $e.data;
    const Je = AxiosHeaders_default.from($e.headers).normalize(), Qe = $e.responseType;
    let at;
    function ut() {
      $e.cancelToken && $e.cancelToken.unsubscribe(at), $e.signal && $e.signal.removeEventListener("abort", at);
    }
    utils_default.isFormData(Ve) && (browser_default.isStandardBrowserEnv || browser_default.isStandardBrowserWebWorkerEnv) && Je.setContentType(!1);
    let lt = new XMLHttpRequest();
    if ($e.auth) {
      const vt = $e.auth.username || "", wt = $e.auth.password ? unescape(encodeURIComponent($e.auth.password)) : "";
      Je.set("Authorization", "Basic " + btoa(vt + ":" + wt));
    }
    const dt = buildFullPath($e.baseURL, $e.url);
    lt.open($e.method.toUpperCase(), buildURL(dt, $e.params, $e.paramsSerializer), !0), lt.timeout = $e.timeout;
    function bt() {
      if (!lt)
        return;
      const vt = AxiosHeaders_default.from(
        "getAllResponseHeaders" in lt && lt.getAllResponseHeaders()
      ), xt = {
        data: !Qe || Qe === "text" || Qe === "json" ? lt.responseText : lt.response,
        status: lt.status,
        statusText: lt.statusText,
        headers: vt,
        config: $e,
        request: lt
      };
      settle(function(Tt) {
        Fe(Tt), ut();
      }, function(Tt) {
        Ke(Tt), ut();
      }, xt), lt = null;
    }
    if ("onloadend" in lt ? lt.onloadend = bt : lt.onreadystatechange = function() {
      !lt || lt.readyState !== 4 || lt.status === 0 && !(lt.responseURL && lt.responseURL.indexOf("file:") === 0) || setTimeout(bt);
    }, lt.onabort = function() {
      lt && (Ke(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, $e, lt)), lt = null);
    }, lt.onerror = function() {
      Ke(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, $e, lt)), lt = null;
    }, lt.ontimeout = function() {
      let wt = $e.timeout ? "timeout of " + $e.timeout + "ms exceeded" : "timeout exceeded";
      const xt = $e.transitional || transitional_default;
      $e.timeoutErrorMessage && (wt = $e.timeoutErrorMessage), Ke(new AxiosError_default(
        wt,
        xt.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        $e,
        lt
      )), lt = null;
    }, browser_default.isStandardBrowserEnv) {
      const vt = ($e.withCredentials || isURLSameOrigin_default(dt)) && $e.xsrfCookieName && cookies_default.read($e.xsrfCookieName);
      vt && Je.set($e.xsrfHeaderName, vt);
    }
    Ve === void 0 && Je.setContentType(null), "setRequestHeader" in lt && utils_default.forEach(Je.toJSON(), function(wt, xt) {
      lt.setRequestHeader(xt, wt);
    }), utils_default.isUndefined($e.withCredentials) || (lt.withCredentials = !!$e.withCredentials), Qe && Qe !== "json" && (lt.responseType = $e.responseType), typeof $e.onDownloadProgress == "function" && lt.addEventListener("progress", progressEventReducer($e.onDownloadProgress, !0)), typeof $e.onUploadProgress == "function" && lt.upload && lt.upload.addEventListener("progress", progressEventReducer($e.onUploadProgress)), ($e.cancelToken || $e.signal) && (at = (vt) => {
      lt && (Ke(!vt || vt.type ? new CanceledError_default(null, $e, lt) : vt), lt.abort(), lt = null);
    }, $e.cancelToken && $e.cancelToken.subscribe(at), $e.signal && ($e.signal.aborted ? at() : $e.signal.addEventListener("abort", at)));
    const $t = parseProtocol(dt);
    if ($t && browser_default.protocols.indexOf($t) === -1) {
      Ke(new AxiosError_default("Unsupported protocol " + $t + ":", AxiosError_default.ERR_BAD_REQUEST, $e));
      return;
    }
    lt.send(Ve || null);
  });
}, knownAdapters = {
  http: null_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, ($e, Ze) => {
  if ($e) {
    try {
      Object.defineProperty($e, "name", { value: Ze });
    } catch {
    }
    Object.defineProperty($e, "adapterName", { value: Ze });
  }
});
var adapters_default = {
  getAdapter: ($e) => {
    $e = utils_default.isArray($e) ? $e : [$e];
    const { length: Ze } = $e;
    let Fe, Ke;
    for (let Ve = 0; Ve < Ze && (Fe = $e[Ve], !(Ke = utils_default.isString(Fe) ? knownAdapters[Fe.toLowerCase()] : Fe)); Ve++)
      ;
    if (!Ke)
      throw Ke === !1 ? new AxiosError_default(
        `Adapter ${Fe} is not supported by the environment`,
        "ERR_NOT_SUPPORT"
      ) : new Error(
        utils_default.hasOwnProp(knownAdapters, Fe) ? `Adapter '${Fe}' is not available in the build` : `Unknown adapter '${Fe}'`
      );
    if (!utils_default.isFunction(Ke))
      throw new TypeError("adapter is not a function");
    return Ke;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested($e) {
  if ($e.cancelToken && $e.cancelToken.throwIfRequested(), $e.signal && $e.signal.aborted)
    throw new CanceledError_default(null, $e);
}
function dispatchRequest($e) {
  return throwIfCancellationRequested($e), $e.headers = AxiosHeaders_default.from($e.headers), $e.data = transformData.call(
    $e,
    $e.transformRequest
  ), ["post", "put", "patch"].indexOf($e.method) !== -1 && $e.headers.setContentType("application/x-www-form-urlencoded", !1), adapters_default.getAdapter($e.adapter || defaults_default.adapter)($e).then(function(Ke) {
    return throwIfCancellationRequested($e), Ke.data = transformData.call(
      $e,
      $e.transformResponse,
      Ke
    ), Ke.headers = AxiosHeaders_default.from(Ke.headers), Ke;
  }, function(Ke) {
    return isCancel(Ke) || (throwIfCancellationRequested($e), Ke && Ke.response && (Ke.response.data = transformData.call(
      $e,
      $e.transformResponse,
      Ke.response
    ), Ke.response.headers = AxiosHeaders_default.from(Ke.response.headers))), Promise.reject(Ke);
  });
}
init_dirname();
init_buffer2();
init_process2();
var headersToObject = ($e) => $e instanceof AxiosHeaders_default ? $e.toJSON() : $e;
function mergeConfig($e, Ze) {
  Ze = Ze || {};
  const Fe = {};
  function Ke(lt, dt, bt) {
    return utils_default.isPlainObject(lt) && utils_default.isPlainObject(dt) ? utils_default.merge.call({ caseless: bt }, lt, dt) : utils_default.isPlainObject(dt) ? utils_default.merge({}, dt) : utils_default.isArray(dt) ? dt.slice() : dt;
  }
  function Ve(lt, dt, bt) {
    if (utils_default.isUndefined(dt)) {
      if (!utils_default.isUndefined(lt))
        return Ke(void 0, lt, bt);
    } else
      return Ke(lt, dt, bt);
  }
  function Je(lt, dt) {
    if (!utils_default.isUndefined(dt))
      return Ke(void 0, dt);
  }
  function Qe(lt, dt) {
    if (utils_default.isUndefined(dt)) {
      if (!utils_default.isUndefined(lt))
        return Ke(void 0, lt);
    } else
      return Ke(void 0, dt);
  }
  function at(lt, dt, bt) {
    if (bt in Ze)
      return Ke(lt, dt);
    if (bt in $e)
      return Ke(void 0, lt);
  }
  const ut = {
    url: Je,
    method: Je,
    data: Je,
    baseURL: Qe,
    transformRequest: Qe,
    transformResponse: Qe,
    paramsSerializer: Qe,
    timeout: Qe,
    timeoutMessage: Qe,
    withCredentials: Qe,
    adapter: Qe,
    responseType: Qe,
    xsrfCookieName: Qe,
    xsrfHeaderName: Qe,
    onUploadProgress: Qe,
    onDownloadProgress: Qe,
    decompress: Qe,
    maxContentLength: Qe,
    maxBodyLength: Qe,
    beforeRedirect: Qe,
    transport: Qe,
    httpAgent: Qe,
    httpsAgent: Qe,
    cancelToken: Qe,
    socketPath: Qe,
    responseEncoding: Qe,
    validateStatus: at,
    headers: (lt, dt) => Ve(headersToObject(lt), headersToObject(dt), !0)
  };
  return utils_default.forEach(Object.keys($e).concat(Object.keys(Ze)), function(dt) {
    const bt = ut[dt] || Ve, $t = bt($e[dt], Ze[dt], dt);
    utils_default.isUndefined($t) && bt !== at || (Fe[dt] = $t);
  }), Fe;
}
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
var VERSION = "1.2.5", validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(($e, Ze) => {
  validators[$e] = function(Ke) {
    return typeof Ke === $e || "a" + (Ze < 1 ? "n " : " ") + $e;
  };
});
var deprecatedWarnings = {};
validators.transitional = function(Ze, Fe, Ke) {
  function Ve(Je, Qe) {
    return "[Axios v" + VERSION + "] Transitional option '" + Je + "'" + Qe + (Ke ? ". " + Ke : "");
  }
  return (Je, Qe, at) => {
    if (Ze === !1)
      throw new AxiosError_default(
        Ve(Qe, " has been removed" + (Fe ? " in " + Fe : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    return Fe && !deprecatedWarnings[Qe] && (deprecatedWarnings[Qe] = !0, console.warn(
      Ve(
        Qe,
        " has been deprecated since v" + Fe + " and will be removed in the near future"
      )
    )), Ze ? Ze(Je, Qe, at) : !0;
  };
};
function assertOptions($e, Ze, Fe) {
  if (typeof $e != "object")
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  const Ke = Object.keys($e);
  let Ve = Ke.length;
  for (; Ve-- > 0; ) {
    const Je = Ke[Ve], Qe = Ze[Je];
    if (Qe) {
      const at = $e[Je], ut = at === void 0 || Qe(at, Je, $e);
      if (ut !== !0)
        throw new AxiosError_default("option " + Je + " must be " + ut, AxiosError_default.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (Fe !== !0)
      throw new AxiosError_default("Unknown option " + Je, AxiosError_default.ERR_BAD_OPTION);
  }
}
var validator_default = {
  assertOptions,
  validators
}, validators2 = validator_default.validators, Axios = class {
  constructor($e) {
    this.defaults = $e, this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  request($e, Ze) {
    typeof $e == "string" ? (Ze = Ze || {}, Ze.url = $e) : Ze = $e || {}, Ze = mergeConfig(this.defaults, Ze);
    const { transitional: Fe, paramsSerializer: Ke, headers: Ve } = Ze;
    Fe !== void 0 && validator_default.assertOptions(Fe, {
      silentJSONParsing: validators2.transitional(validators2.boolean),
      forcedJSONParsing: validators2.transitional(validators2.boolean),
      clarifyTimeoutError: validators2.transitional(validators2.boolean)
    }, !1), Ke !== void 0 && validator_default.assertOptions(Ke, {
      encode: validators2.function,
      serialize: validators2.function
    }, !0), Ze.method = (Ze.method || this.defaults.method || "get").toLowerCase();
    let Je;
    Je = Ve && utils_default.merge(
      Ve.common,
      Ve[Ze.method]
    ), Je && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (vt) => {
        delete Ve[vt];
      }
    ), Ze.headers = AxiosHeaders_default.concat(Je, Ve);
    const Qe = [];
    let at = !0;
    this.interceptors.request.forEach(function(wt) {
      typeof wt.runWhen == "function" && wt.runWhen(Ze) === !1 || (at = at && wt.synchronous, Qe.unshift(wt.fulfilled, wt.rejected));
    });
    const ut = [];
    this.interceptors.response.forEach(function(wt) {
      ut.push(wt.fulfilled, wt.rejected);
    });
    let lt, dt = 0, bt;
    if (!at) {
      const vt = [dispatchRequest.bind(this), void 0];
      for (vt.unshift.apply(vt, Qe), vt.push.apply(vt, ut), bt = vt.length, lt = Promise.resolve(Ze); dt < bt; )
        lt = lt.then(vt[dt++], vt[dt++]);
      return lt;
    }
    bt = Qe.length;
    let $t = Ze;
    for (dt = 0; dt < bt; ) {
      const vt = Qe[dt++], wt = Qe[dt++];
      try {
        $t = vt($t);
      } catch (xt) {
        wt.call(this, xt);
        break;
      }
    }
    try {
      lt = dispatchRequest.call(this, $t);
    } catch (vt) {
      return Promise.reject(vt);
    }
    for (dt = 0, bt = ut.length; dt < bt; )
      lt = lt.then(ut[dt++], ut[dt++]);
    return lt;
  }
  getUri($e) {
    $e = mergeConfig(this.defaults, $e);
    const Ze = buildFullPath($e.baseURL, $e.url);
    return buildURL(Ze, $e.params, $e.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function(Ze) {
  Axios.prototype[Ze] = function(Fe, Ke) {
    return this.request(mergeConfig(Ke || {}, {
      method: Ze,
      url: Fe,
      data: (Ke || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function(Ze) {
  function Fe(Ke) {
    return function(Je, Qe, at) {
      return this.request(mergeConfig(at || {}, {
        method: Ze,
        headers: Ke ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: Je,
        data: Qe
      }));
    };
  }
  Axios.prototype[Ze] = Fe(), Axios.prototype[Ze + "Form"] = Fe(!0);
});
var Axios_default = Axios;
init_dirname();
init_buffer2();
init_process2();
var CancelToken = class {
  constructor($e) {
    if (typeof $e != "function")
      throw new TypeError("executor must be a function.");
    let Ze;
    this.promise = new Promise(function(Ve) {
      Ze = Ve;
    });
    const Fe = this;
    this.promise.then((Ke) => {
      if (!Fe._listeners)
        return;
      let Ve = Fe._listeners.length;
      for (; Ve-- > 0; )
        Fe._listeners[Ve](Ke);
      Fe._listeners = null;
    }), this.promise.then = (Ke) => {
      let Ve;
      const Je = new Promise((Qe) => {
        Fe.subscribe(Qe), Ve = Qe;
      }).then(Ke);
      return Je.cancel = function() {
        Fe.unsubscribe(Ve);
      }, Je;
    }, $e(function(Ve, Je, Qe) {
      Fe.reason || (Fe.reason = new CanceledError_default(Ve, Je, Qe), Ze(Fe.reason));
    });
  }
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  subscribe($e) {
    if (this.reason) {
      $e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push($e) : this._listeners = [$e];
  }
  unsubscribe($e) {
    if (!this._listeners)
      return;
    const Ze = this._listeners.indexOf($e);
    Ze !== -1 && this._listeners.splice(Ze, 1);
  }
  static source() {
    let $e;
    return {
      token: new CancelToken(function(Ke) {
        $e = Ke;
      }),
      cancel: $e
    };
  }
}, CancelToken_default = CancelToken;
init_dirname();
init_buffer2();
init_process2();
function spread($e) {
  return function(Fe) {
    return $e.apply(null, Fe);
  };
}
init_dirname();
init_buffer2();
init_process2();
function isAxiosError($e) {
  return utils_default.isObject($e) && $e.isAxiosError === !0;
}
init_dirname();
init_buffer2();
init_process2();
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([$e, Ze]) => {
  HttpStatusCode[Ze] = $e;
});
var HttpStatusCode_default = HttpStatusCode;
function createInstance($e) {
  const Ze = new Axios_default($e), Fe = bind(Axios_default.prototype.request, Ze);
  return utils_default.extend(Fe, Axios_default.prototype, Ze, { allOwnKeys: !0 }), utils_default.extend(Fe, Ze, null, { allOwnKeys: !0 }), Fe.create = function(Ve) {
    return createInstance(mergeConfig($e, Ve));
  }, Fe;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function(Ze) {
  return Promise.all(Ze);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = ($e) => formDataToJSON_default(utils_default.isHTMLForm($e) ? new FormData($e) : $e);
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios, {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  mergeConfig: mergeConfig2
} = axios_default;
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
var BASE_PATH = "https://api.botpress.cloud/webhooks".replace(/\/+$/, ""), BaseAPI = class {
  constructor($e, Ze = BASE_PATH, Fe = axios_default) {
    Or(this, "configuration");
    this.basePath = Ze, this.axios = Fe, $e && (this.configuration = $e, this.basePath = $e.basePath || this.basePath);
  }
}, RequiredError = class extends Error {
  constructor($e, Ze) {
    super(Ze), this.field = $e, this.name = "RequiredError";
  }
}, DUMMY_BASE_URL = "https://example.com", assertParamExists = function($e, Ze, Fe) {
  if (Fe == null)
    throw new RequiredError(Ze, `Required parameter ${Ze} was null or undefined when calling ${$e}.`);
};
function setFlattenedQueryParams($e, Ze, Fe = "") {
  Ze != null && (typeof Ze == "object" ? Array.isArray(Ze) ? Ze.forEach((Ke) => setFlattenedQueryParams($e, Ke, Fe)) : Object.keys(Ze).forEach(
    (Ke) => setFlattenedQueryParams($e, Ze[Ke], `${Fe}${Fe !== "" ? "." : ""}${Ke}`)
  ) : $e.has(Fe) ? $e.append(Fe, Ze) : $e.set(Fe, Ze));
}
var setSearchParams = function($e, ...Ze) {
  const Fe = new URLSearchParams($e.search);
  setFlattenedQueryParams(Fe, Ze), $e.search = Fe.toString();
}, serializeDataIfNeeded = function($e, Ze, Fe) {
  const Ke = typeof $e != "string";
  return (Ke && Fe && Fe.isJsonMime ? Fe.isJsonMime(Ze.headers["Content-Type"]) : Ke) ? JSON.stringify($e !== void 0 ? $e : {}) : $e || "";
}, toPathString = function($e) {
  return $e.pathname + $e.search + $e.hash;
}, createRequestFunction = function($e, Ze, Fe, Ke) {
  return (Ve = Ze, Je = Fe) => {
    const Qe = { ...$e.options, url: ((Ke == null ? void 0 : Ke.basePath) || Je) + $e.url };
    return Ve.request(Qe);
  };
}, DefaultApiAxiosParamCreator = function($e) {
  return {
    addParticipant: async (Ze, Fe, Ke, Ve = {}) => {
      assertParamExists("addParticipant", "xChatKey", Ze), assertParamExists("addParticipant", "id", Fe);
      const Je = "/v1/conversations/{id}/participants".replace("{id}", encodeURIComponent(String(Fe))), Qe = new URL(Je, DUMMY_BASE_URL);
      let at;
      $e && (at = $e.baseOptions);
      const ut = { method: "POST", ...at, ...Ve }, lt = {}, dt = {};
      Ze != null && (lt["x-chat-key"] = String(Ze)), lt["Content-Type"] = "application/json", setSearchParams(Qe, dt);
      let bt = at && at.headers ? at.headers : {};
      return ut.headers = { ...lt, ...bt, ...Ve.headers }, ut.data = serializeDataIfNeeded(Ke, ut, $e), {
        url: toPathString(Qe),
        options: ut
      };
    },
    createConversation: async (Ze, Fe, Ke = {}) => {
      assertParamExists("createConversation", "xChatKey", Ze);
      const Ve = "/v1/conversations", Je = new URL(Ve, DUMMY_BASE_URL);
      let Qe;
      $e && (Qe = $e.baseOptions);
      const at = { method: "POST", ...Qe, ...Ke }, ut = {}, lt = {};
      Ze != null && (ut["x-chat-key"] = String(Ze)), ut["Content-Type"] = "application/json", setSearchParams(Je, lt);
      let dt = Qe && Qe.headers ? Qe.headers : {};
      return at.headers = { ...ut, ...dt, ...Ke.headers }, at.data = serializeDataIfNeeded(Fe, at, $e), {
        url: toPathString(Je),
        options: at
      };
    },
    createMessage: async (Ze, Fe, Ke = {}) => {
      assertParamExists("createMessage", "xChatKey", Ze);
      const Ve = "/v1/messages", Je = new URL(Ve, DUMMY_BASE_URL);
      let Qe;
      $e && (Qe = $e.baseOptions);
      const at = { method: "POST", ...Qe, ...Ke }, ut = {}, lt = {};
      Ze != null && (ut["x-chat-key"] = String(Ze)), ut["Content-Type"] = "application/json", setSearchParams(Je, lt);
      let dt = Qe && Qe.headers ? Qe.headers : {};
      return at.headers = { ...ut, ...dt, ...Ke.headers }, at.data = serializeDataIfNeeded(Fe, at, $e), {
        url: toPathString(Je),
        options: at
      };
    },
    createUser: async (Ze, Fe = {}) => {
      const Ke = "/v1/users", Ve = new URL(Ke, DUMMY_BASE_URL);
      let Je;
      $e && (Je = $e.baseOptions);
      const Qe = { method: "POST", ...Je, ...Fe }, at = {}, ut = {};
      at["Content-Type"] = "application/json", setSearchParams(Ve, ut);
      let lt = Je && Je.headers ? Je.headers : {};
      return Qe.headers = { ...at, ...lt, ...Fe.headers }, Qe.data = serializeDataIfNeeded(Ze, Qe, $e), {
        url: toPathString(Ve),
        options: Qe
      };
    },
    deleteConversation: async (Ze, Fe, Ke = {}) => {
      assertParamExists("deleteConversation", "xChatKey", Ze), assertParamExists("deleteConversation", "id", Fe);
      const Ve = "/v1/conversations/{id}".replace("{id}", encodeURIComponent(String(Fe))), Je = new URL(Ve, DUMMY_BASE_URL);
      let Qe;
      $e && (Qe = $e.baseOptions);
      const at = { method: "DELETE", ...Qe, ...Ke }, ut = {}, lt = {};
      Ze != null && (ut["x-chat-key"] = String(Ze)), setSearchParams(Je, lt);
      let dt = Qe && Qe.headers ? Qe.headers : {};
      return at.headers = { ...ut, ...dt, ...Ke.headers }, {
        url: toPathString(Je),
        options: at
      };
    },
    deleteMessage: async (Ze, Fe, Ke = {}) => {
      assertParamExists("deleteMessage", "xChatKey", Ze), assertParamExists("deleteMessage", "id", Fe);
      const Ve = "/v1/messages/{id}".replace("{id}", encodeURIComponent(String(Fe))), Je = new URL(Ve, DUMMY_BASE_URL);
      let Qe;
      $e && (Qe = $e.baseOptions);
      const at = { method: "DELETE", ...Qe, ...Ke }, ut = {}, lt = {};
      Ze != null && (ut["x-chat-key"] = String(Ze)), setSearchParams(Je, lt);
      let dt = Qe && Qe.headers ? Qe.headers : {};
      return at.headers = { ...ut, ...dt, ...Ke.headers }, {
        url: toPathString(Je),
        options: at
      };
    },
    deleteUser: async (Ze, Fe = {}) => {
      assertParamExists("deleteUser", "xChatKey", Ze);
      const Ke = "/v1/users/me", Ve = new URL(Ke, DUMMY_BASE_URL);
      let Je;
      $e && (Je = $e.baseOptions);
      const Qe = { method: "DELETE", ...Je, ...Fe }, at = {}, ut = {};
      Ze != null && (at["x-chat-key"] = String(Ze)), setSearchParams(Ve, ut);
      let lt = Je && Je.headers ? Je.headers : {};
      return Qe.headers = { ...at, ...lt, ...Fe.headers }, {
        url: toPathString(Ve),
        options: Qe
      };
    },
    getConversation: async (Ze, Fe, Ke = {}) => {
      assertParamExists("getConversation", "xChatKey", Ze), assertParamExists("getConversation", "id", Fe);
      const Ve = "/v1/conversations/{id}".replace("{id}", encodeURIComponent(String(Fe))), Je = new URL(Ve, DUMMY_BASE_URL);
      let Qe;
      $e && (Qe = $e.baseOptions);
      const at = { method: "GET", ...Qe, ...Ke }, ut = {}, lt = {};
      Ze != null && (ut["x-chat-key"] = String(Ze)), setSearchParams(Je, lt);
      let dt = Qe && Qe.headers ? Qe.headers : {};
      return at.headers = { ...ut, ...dt, ...Ke.headers }, {
        url: toPathString(Je),
        options: at
      };
    },
    getMessage: async (Ze, Fe, Ke = {}) => {
      assertParamExists("getMessage", "xChatKey", Ze), assertParamExists("getMessage", "id", Fe);
      const Ve = "/v1/messages/{id}".replace("{id}", encodeURIComponent(String(Fe))), Je = new URL(Ve, DUMMY_BASE_URL);
      let Qe;
      $e && (Qe = $e.baseOptions);
      const at = { method: "GET", ...Qe, ...Ke }, ut = {}, lt = {};
      Ze != null && (ut["x-chat-key"] = String(Ze)), setSearchParams(Je, lt);
      let dt = Qe && Qe.headers ? Qe.headers : {};
      return at.headers = { ...ut, ...dt, ...Ke.headers }, {
        url: toPathString(Je),
        options: at
      };
    },
    getOrCreateConversation: async (Ze, Fe, Ke = {}) => {
      assertParamExists("getOrCreateConversation", "xChatKey", Ze);
      const Ve = "/v1/conversations/get-or-create", Je = new URL(Ve, DUMMY_BASE_URL);
      let Qe;
      $e && (Qe = $e.baseOptions);
      const at = { method: "POST", ...Qe, ...Ke }, ut = {}, lt = {};
      Ze != null && (ut["x-chat-key"] = String(Ze)), ut["Content-Type"] = "application/json", setSearchParams(Je, lt);
      let dt = Qe && Qe.headers ? Qe.headers : {};
      return at.headers = { ...ut, ...dt, ...Ke.headers }, at.data = serializeDataIfNeeded(Fe, at, $e), {
        url: toPathString(Je),
        options: at
      };
    },
    getOrCreateMessage: async (Ze, Fe, Ke = {}) => {
      assertParamExists("getOrCreateMessage", "xChatKey", Ze);
      const Ve = "/v1/messages/get-or-create", Je = new URL(Ve, DUMMY_BASE_URL);
      let Qe;
      $e && (Qe = $e.baseOptions);
      const at = { method: "POST", ...Qe, ...Ke }, ut = {}, lt = {};
      Ze != null && (ut["x-chat-key"] = String(Ze)), ut["Content-Type"] = "application/json", setSearchParams(Je, lt);
      let dt = Qe && Qe.headers ? Qe.headers : {};
      return at.headers = { ...ut, ...dt, ...Ke.headers }, at.data = serializeDataIfNeeded(Fe, at, $e), {
        url: toPathString(Je),
        options: at
      };
    },
    getParticipant: async (Ze, Fe, Ke, Ve = {}) => {
      assertParamExists("getParticipant", "xChatKey", Ze), assertParamExists("getParticipant", "id", Fe), assertParamExists("getParticipant", "userId", Ke);
      const Je = "/v1/conversations/{id}/participants/{userId}".replace("{id}", encodeURIComponent(String(Fe))).replace("{userId}", encodeURIComponent(String(Ke))), Qe = new URL(Je, DUMMY_BASE_URL);
      let at;
      $e && (at = $e.baseOptions);
      const ut = { method: "GET", ...at, ...Ve }, lt = {}, dt = {};
      Ze != null && (lt["x-chat-key"] = String(Ze)), setSearchParams(Qe, dt);
      let bt = at && at.headers ? at.headers : {};
      return ut.headers = { ...lt, ...bt, ...Ve.headers }, {
        url: toPathString(Qe),
        options: ut
      };
    },
    getUser: async (Ze, Fe = {}) => {
      assertParamExists("getUser", "xChatKey", Ze);
      const Ke = "/v1/users/me", Ve = new URL(Ke, DUMMY_BASE_URL);
      let Je;
      $e && (Je = $e.baseOptions);
      const Qe = { method: "GET", ...Je, ...Fe }, at = {}, ut = {};
      Ze != null && (at["x-chat-key"] = String(Ze)), setSearchParams(Ve, ut);
      let lt = Je && Je.headers ? Je.headers : {};
      return Qe.headers = { ...at, ...lt, ...Fe.headers }, {
        url: toPathString(Ve),
        options: Qe
      };
    },
    listConversationMessages: async (Ze, Fe, Ke, Ve = {}) => {
      assertParamExists("listConversationMessages", "xChatKey", Ze), assertParamExists("listConversationMessages", "id", Fe);
      const Je = "/v1/conversations/{id}/messages".replace("{id}", encodeURIComponent(String(Fe))), Qe = new URL(Je, DUMMY_BASE_URL);
      let at;
      $e && (at = $e.baseOptions);
      const ut = { method: "GET", ...at, ...Ve }, lt = {}, dt = {};
      Ke !== void 0 && (dt.nextToken = Ke), Ze != null && (lt["x-chat-key"] = String(Ze)), setSearchParams(Qe, dt);
      let bt = at && at.headers ? at.headers : {};
      return ut.headers = { ...lt, ...bt, ...Ve.headers }, {
        url: toPathString(Qe),
        options: ut
      };
    },
    listConversations: async (Ze, Fe, Ke = {}) => {
      assertParamExists("listConversations", "xChatKey", Ze);
      const Ve = "/v1/conversations", Je = new URL(Ve, DUMMY_BASE_URL);
      let Qe;
      $e && (Qe = $e.baseOptions);
      const at = { method: "GET", ...Qe, ...Ke }, ut = {}, lt = {};
      Fe !== void 0 && (lt.nextToken = Fe), Ze != null && (ut["x-chat-key"] = String(Ze)), setSearchParams(Je, lt);
      let dt = Qe && Qe.headers ? Qe.headers : {};
      return at.headers = { ...ut, ...dt, ...Ke.headers }, {
        url: toPathString(Je),
        options: at
      };
    },
    listParticipants: async (Ze, Fe, Ke, Ve = {}) => {
      assertParamExists("listParticipants", "xChatKey", Ze), assertParamExists("listParticipants", "id", Fe);
      const Je = "/v1/conversations/{id}/participants".replace("{id}", encodeURIComponent(String(Fe))), Qe = new URL(Je, DUMMY_BASE_URL);
      let at;
      $e && (at = $e.baseOptions);
      const ut = { method: "GET", ...at, ...Ve }, lt = {}, dt = {};
      Ke !== void 0 && (dt.nextToken = Ke), Ze != null && (lt["x-chat-key"] = String(Ze)), setSearchParams(Qe, dt);
      let bt = at && at.headers ? at.headers : {};
      return ut.headers = { ...lt, ...bt, ...Ve.headers }, {
        url: toPathString(Qe),
        options: ut
      };
    },
    listenConversation: async (Ze, Fe, Ke = {}) => {
      assertParamExists("listenConversation", "xChatKey", Ze), assertParamExists("listenConversation", "id", Fe);
      const Ve = "/v1/conversations/{id}/listen".replace("{id}", encodeURIComponent(String(Fe))), Je = new URL(Ve, DUMMY_BASE_URL);
      let Qe;
      $e && (Qe = $e.baseOptions);
      const at = { method: "GET", ...Qe, ...Ke }, ut = {}, lt = {};
      Ze != null && (ut["x-chat-key"] = String(Ze)), setSearchParams(Je, lt);
      let dt = Qe && Qe.headers ? Qe.headers : {};
      return at.headers = { ...ut, ...dt, ...Ke.headers }, {
        url: toPathString(Je),
        options: at
      };
    },
    removeParticipant: async (Ze, Fe, Ke, Ve = {}) => {
      assertParamExists("removeParticipant", "xChatKey", Ze), assertParamExists("removeParticipant", "id", Fe), assertParamExists("removeParticipant", "userId", Ke);
      const Je = "/v1/conversations/{id}/participants/{userId}".replace("{id}", encodeURIComponent(String(Fe))).replace("{userId}", encodeURIComponent(String(Ke))), Qe = new URL(Je, DUMMY_BASE_URL);
      let at;
      $e && (at = $e.baseOptions);
      const ut = { method: "DELETE", ...at, ...Ve }, lt = {}, dt = {};
      Ze != null && (lt["x-chat-key"] = String(Ze)), setSearchParams(Qe, dt);
      let bt = at && at.headers ? at.headers : {};
      return ut.headers = { ...lt, ...bt, ...Ve.headers }, {
        url: toPathString(Qe),
        options: ut
      };
    },
    updateConversation: async (Ze, Fe, Ke, Ve = {}) => {
      assertParamExists("updateConversation", "xChatKey", Ze), assertParamExists("updateConversation", "id", Fe);
      const Je = "/v1/conversations/{id}".replace("{id}", encodeURIComponent(String(Fe))), Qe = new URL(Je, DUMMY_BASE_URL);
      let at;
      $e && (at = $e.baseOptions);
      const ut = { method: "PUT", ...at, ...Ve }, lt = {}, dt = {};
      Ze != null && (lt["x-chat-key"] = String(Ze)), lt["Content-Type"] = "application/json", setSearchParams(Qe, dt);
      let bt = at && at.headers ? at.headers : {};
      return ut.headers = { ...lt, ...bt, ...Ve.headers }, ut.data = serializeDataIfNeeded(Ke, ut, $e), {
        url: toPathString(Qe),
        options: ut
      };
    },
    updateMessage: async (Ze, Fe, Ke, Ve = {}) => {
      assertParamExists("updateMessage", "xChatKey", Ze), assertParamExists("updateMessage", "id", Fe);
      const Je = "/v1/messages/{id}".replace("{id}", encodeURIComponent(String(Fe))), Qe = new URL(Je, DUMMY_BASE_URL);
      let at;
      $e && (at = $e.baseOptions);
      const ut = { method: "PUT", ...at, ...Ve }, lt = {}, dt = {};
      Ze != null && (lt["x-chat-key"] = String(Ze)), lt["Content-Type"] = "application/json", setSearchParams(Qe, dt);
      let bt = at && at.headers ? at.headers : {};
      return ut.headers = { ...lt, ...bt, ...Ve.headers }, ut.data = serializeDataIfNeeded(Ke, ut, $e), {
        url: toPathString(Qe),
        options: ut
      };
    },
    updateUser: async (Ze, Fe, Ke = {}) => {
      assertParamExists("updateUser", "xChatKey", Ze);
      const Ve = "/v1/users/me", Je = new URL(Ve, DUMMY_BASE_URL);
      let Qe;
      $e && (Qe = $e.baseOptions);
      const at = { method: "PUT", ...Qe, ...Ke }, ut = {}, lt = {};
      Ze != null && (ut["x-chat-key"] = String(Ze)), ut["Content-Type"] = "application/json", setSearchParams(Je, lt);
      let dt = Qe && Qe.headers ? Qe.headers : {};
      return at.headers = { ...ut, ...dt, ...Ke.headers }, at.data = serializeDataIfNeeded(Fe, at, $e), {
        url: toPathString(Je),
        options: at
      };
    }
  };
}, DefaultApiFp = function($e) {
  const Ze = DefaultApiAxiosParamCreator($e);
  return {
    async addParticipant(Fe, Ke, Ve, Je) {
      const Qe = await Ze.addParticipant(Fe, Ke, Ve, Je);
      return createRequestFunction(Qe, axios_default, BASE_PATH, $e);
    },
    async createConversation(Fe, Ke, Ve) {
      const Je = await Ze.createConversation(Fe, Ke, Ve);
      return createRequestFunction(Je, axios_default, BASE_PATH, $e);
    },
    async createMessage(Fe, Ke, Ve) {
      const Je = await Ze.createMessage(Fe, Ke, Ve);
      return createRequestFunction(Je, axios_default, BASE_PATH, $e);
    },
    async createUser(Fe, Ke) {
      const Ve = await Ze.createUser(Fe, Ke);
      return createRequestFunction(Ve, axios_default, BASE_PATH, $e);
    },
    async deleteConversation(Fe, Ke, Ve) {
      const Je = await Ze.deleteConversation(Fe, Ke, Ve);
      return createRequestFunction(Je, axios_default, BASE_PATH, $e);
    },
    async deleteMessage(Fe, Ke, Ve) {
      const Je = await Ze.deleteMessage(Fe, Ke, Ve);
      return createRequestFunction(Je, axios_default, BASE_PATH, $e);
    },
    async deleteUser(Fe, Ke) {
      const Ve = await Ze.deleteUser(Fe, Ke);
      return createRequestFunction(Ve, axios_default, BASE_PATH, $e);
    },
    async getConversation(Fe, Ke, Ve) {
      const Je = await Ze.getConversation(Fe, Ke, Ve);
      return createRequestFunction(Je, axios_default, BASE_PATH, $e);
    },
    async getMessage(Fe, Ke, Ve) {
      const Je = await Ze.getMessage(Fe, Ke, Ve);
      return createRequestFunction(Je, axios_default, BASE_PATH, $e);
    },
    async getOrCreateConversation(Fe, Ke, Ve) {
      const Je = await Ze.getOrCreateConversation(Fe, Ke, Ve);
      return createRequestFunction(Je, axios_default, BASE_PATH, $e);
    },
    async getOrCreateMessage(Fe, Ke, Ve) {
      const Je = await Ze.getOrCreateMessage(Fe, Ke, Ve);
      return createRequestFunction(Je, axios_default, BASE_PATH, $e);
    },
    async getParticipant(Fe, Ke, Ve, Je) {
      const Qe = await Ze.getParticipant(Fe, Ke, Ve, Je);
      return createRequestFunction(Qe, axios_default, BASE_PATH, $e);
    },
    async getUser(Fe, Ke) {
      const Ve = await Ze.getUser(Fe, Ke);
      return createRequestFunction(Ve, axios_default, BASE_PATH, $e);
    },
    async listConversationMessages(Fe, Ke, Ve, Je) {
      const Qe = await Ze.listConversationMessages(Fe, Ke, Ve, Je);
      return createRequestFunction(Qe, axios_default, BASE_PATH, $e);
    },
    async listConversations(Fe, Ke, Ve) {
      const Je = await Ze.listConversations(Fe, Ke, Ve);
      return createRequestFunction(Je, axios_default, BASE_PATH, $e);
    },
    async listParticipants(Fe, Ke, Ve, Je) {
      const Qe = await Ze.listParticipants(Fe, Ke, Ve, Je);
      return createRequestFunction(Qe, axios_default, BASE_PATH, $e);
    },
    async listenConversation(Fe, Ke, Ve) {
      const Je = await Ze.listenConversation(Fe, Ke, Ve);
      return createRequestFunction(Je, axios_default, BASE_PATH, $e);
    },
    async removeParticipant(Fe, Ke, Ve, Je) {
      const Qe = await Ze.removeParticipant(Fe, Ke, Ve, Je);
      return createRequestFunction(Qe, axios_default, BASE_PATH, $e);
    },
    async updateConversation(Fe, Ke, Ve, Je) {
      const Qe = await Ze.updateConversation(Fe, Ke, Ve, Je);
      return createRequestFunction(Qe, axios_default, BASE_PATH, $e);
    },
    async updateMessage(Fe, Ke, Ve, Je) {
      const Qe = await Ze.updateMessage(Fe, Ke, Ve, Je);
      return createRequestFunction(Qe, axios_default, BASE_PATH, $e);
    },
    async updateUser(Fe, Ke, Ve) {
      const Je = await Ze.updateUser(Fe, Ke, Ve);
      return createRequestFunction(Je, axios_default, BASE_PATH, $e);
    }
  };
}, DefaultApi = class extends BaseAPI {
  addParticipant($e, Ze) {
    return DefaultApiFp(this.configuration).addParticipant($e.xChatKey, $e.id, $e.addParticipantBody, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  createConversation($e, Ze) {
    return DefaultApiFp(this.configuration).createConversation($e.xChatKey, $e.createConversationBody, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  createMessage($e, Ze) {
    return DefaultApiFp(this.configuration).createMessage($e.xChatKey, $e.createMessageBody, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  createUser($e = {}, Ze) {
    return DefaultApiFp(this.configuration).createUser($e.createUserBody, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  deleteConversation($e, Ze) {
    return DefaultApiFp(this.configuration).deleteConversation($e.xChatKey, $e.id, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  deleteMessage($e, Ze) {
    return DefaultApiFp(this.configuration).deleteMessage($e.xChatKey, $e.id, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  deleteUser($e, Ze) {
    return DefaultApiFp(this.configuration).deleteUser($e.xChatKey, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  getConversation($e, Ze) {
    return DefaultApiFp(this.configuration).getConversation($e.xChatKey, $e.id, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  getMessage($e, Ze) {
    return DefaultApiFp(this.configuration).getMessage($e.xChatKey, $e.id, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  getOrCreateConversation($e, Ze) {
    return DefaultApiFp(this.configuration).getOrCreateConversation($e.xChatKey, $e.getOrCreateConversationBody, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  getOrCreateMessage($e, Ze) {
    return DefaultApiFp(this.configuration).getOrCreateMessage($e.xChatKey, $e.getOrCreateMessageBody, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  getParticipant($e, Ze) {
    return DefaultApiFp(this.configuration).getParticipant($e.xChatKey, $e.id, $e.userId, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  getUser($e, Ze) {
    return DefaultApiFp(this.configuration).getUser($e.xChatKey, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  listConversationMessages($e, Ze) {
    return DefaultApiFp(this.configuration).listConversationMessages($e.xChatKey, $e.id, $e.nextToken, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  listConversations($e, Ze) {
    return DefaultApiFp(this.configuration).listConversations($e.xChatKey, $e.nextToken, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  listParticipants($e, Ze) {
    return DefaultApiFp(this.configuration).listParticipants($e.xChatKey, $e.id, $e.nextToken, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  listenConversation($e, Ze) {
    return DefaultApiFp(this.configuration).listenConversation($e.xChatKey, $e.id, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  removeParticipant($e, Ze) {
    return DefaultApiFp(this.configuration).removeParticipant($e.xChatKey, $e.id, $e.userId, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  updateConversation($e, Ze) {
    return DefaultApiFp(this.configuration).updateConversation($e.xChatKey, $e.id, $e.updateConversationBody, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  updateMessage($e, Ze) {
    return DefaultApiFp(this.configuration).updateMessage($e.xChatKey, $e.id, $e.updateMessageBody, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
  updateUser($e, Ze) {
    return DefaultApiFp(this.configuration).updateUser($e.xChatKey, $e.updateUserBody, Ze).then((Fe) => Fe(this.axios, this.basePath));
  }
};
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
init_chunk_44e51b61();
init_chunk_2eac56ff();
init_chunk_c3d025d9();
init_chunk_4bd36a8f();
init_chunk_4ccc3a29();
init_chunk_ce0fbc82();
init_chunk_b4205b57();
init_chunk_5decc758();
var exports$2Q = {}, _dewExec$2P = !1;
function dew$2P() {
  if (_dewExec$2P)
    return exports$2Q;
  _dewExec$2P = !0;
  var $e = buffer, Ze = $e.Buffer;
  function Fe(Ve, Je) {
    for (var Qe in Ve)
      Je[Qe] = Ve[Qe];
  }
  Ze.from && Ze.alloc && Ze.allocUnsafe && Ze.allocUnsafeSlow ? exports$2Q = $e : (Fe($e, exports$2Q), exports$2Q.Buffer = Ke);
  function Ke(Ve, Je, Qe) {
    return Ze(Ve, Je, Qe);
  }
  return Fe(Ze, Ke), Ke.from = function(Ve, Je, Qe) {
    if (typeof Ve == "number")
      throw new TypeError("Argument must not be a number");
    return Ze(Ve, Je, Qe);
  }, Ke.alloc = function(Ve, Je, Qe) {
    if (typeof Ve != "number")
      throw new TypeError("Argument must be a number");
    var at = Ze(Ve);
    return Je !== void 0 ? typeof Qe == "string" ? at.fill(Je, Qe) : at.fill(Je) : at.fill(0), at;
  }, Ke.allocUnsafe = function(Ve) {
    if (typeof Ve != "number")
      throw new TypeError("Argument must be a number");
    return Ze(Ve);
  }, Ke.allocUnsafeSlow = function(Ve) {
    if (typeof Ve != "number")
      throw new TypeError("Argument must be a number");
    return $e.SlowBuffer(Ve);
  }, exports$2Q;
}
var exports$2P = {}, _dewExec$2O = !1, _global$U = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$2O() {
  if (_dewExec$2O)
    return exports$2P;
  _dewExec$2O = !0;
  var $e = process2, Ze = 65536, Fe = 4294967295;
  function Ke() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var Ve = dew$2P().Buffer, Je = _global$U.crypto || _global$U.msCrypto;
  Je && Je.getRandomValues ? exports$2P = Qe : exports$2P = Ke;
  function Qe(at, ut) {
    if (at > Fe)
      throw new RangeError("requested too many random bytes");
    var lt = Ve.allocUnsafe(at);
    if (at > 0)
      if (at > Ze)
        for (var dt = 0; dt < at; dt += Ze)
          Je.getRandomValues(lt.slice(dt, dt + Ze));
      else
        Je.getRandomValues(lt);
    return typeof ut == "function" ? $e.nextTick(function() {
      ut(null, lt);
    }) : lt;
  }
  return exports$2P;
}
var exports$2O = {}, _dewExec$2N = !1;
function dew$2N() {
  if (_dewExec$2N)
    return exports$2O;
  _dewExec$2N = !0;
  var $e = buffer, Ze = $e.Buffer;
  function Fe(Ve, Je) {
    for (var Qe in Ve)
      Je[Qe] = Ve[Qe];
  }
  Ze.from && Ze.alloc && Ze.allocUnsafe && Ze.allocUnsafeSlow ? exports$2O = $e : (Fe($e, exports$2O), exports$2O.Buffer = Ke);
  function Ke(Ve, Je, Qe) {
    return Ze(Ve, Je, Qe);
  }
  return Ke.prototype = Object.create(Ze.prototype), Fe(Ze, Ke), Ke.from = function(Ve, Je, Qe) {
    if (typeof Ve == "number")
      throw new TypeError("Argument must not be a number");
    return Ze(Ve, Je, Qe);
  }, Ke.alloc = function(Ve, Je, Qe) {
    if (typeof Ve != "number")
      throw new TypeError("Argument must be a number");
    var at = Ze(Ve);
    return Je !== void 0 ? typeof Qe == "string" ? at.fill(Je, Qe) : at.fill(Je) : at.fill(0), at;
  }, Ke.allocUnsafe = function(Ve) {
    if (typeof Ve != "number")
      throw new TypeError("Argument must be a number");
    return Ze(Ve);
  }, Ke.allocUnsafeSlow = function(Ve) {
    if (typeof Ve != "number")
      throw new TypeError("Argument must be a number");
    return $e.SlowBuffer(Ve);
  }, exports$2O;
}
var exports$2N = {}, _dewExec$2M = !1;
function dew$2M() {
  if (_dewExec$2M)
    return exports$2N;
  _dewExec$2M = !0;
  var $e = dew$2N().Buffer, Ze = dew4().Transform, Fe = dew$f();
  function Ke(Je, Qe) {
    if (!$e.isBuffer(Je) && typeof Je != "string")
      throw new TypeError(Qe + " must be a string or a buffer");
  }
  function Ve(Je) {
    Ze.call(this), this._block = $e.allocUnsafe(Je), this._blockSize = Je, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return Fe(Ve, Ze), Ve.prototype._transform = function(Je, Qe, at) {
    var ut = null;
    try {
      this.update(Je, Qe);
    } catch (lt) {
      ut = lt;
    }
    at(ut);
  }, Ve.prototype._flush = function(Je) {
    var Qe = null;
    try {
      this.push(this.digest());
    } catch (at) {
      Qe = at;
    }
    Je(Qe);
  }, Ve.prototype.update = function(Je, Qe) {
    if (Ke(Je, "Data"), this._finalized)
      throw new Error("Digest already called");
    $e.isBuffer(Je) || (Je = $e.from(Je, Qe));
    for (var at = this._block, ut = 0; this._blockOffset + Je.length - ut >= this._blockSize; ) {
      for (var lt = this._blockOffset; lt < this._blockSize; )
        at[lt++] = Je[ut++];
      this._update(), this._blockOffset = 0;
    }
    for (; ut < Je.length; )
      at[this._blockOffset++] = Je[ut++];
    for (var dt = 0, bt = Je.length * 8; bt > 0; ++dt)
      this._length[dt] += bt, bt = this._length[dt] / 4294967296 | 0, bt > 0 && (this._length[dt] -= 4294967296 * bt);
    return this;
  }, Ve.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, Ve.prototype.digest = function(Je) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = !0;
    var Qe = this._digest();
    Je !== void 0 && (Qe = Qe.toString(Je)), this._block.fill(0), this._blockOffset = 0;
    for (var at = 0; at < 4; ++at)
      this._length[at] = 0;
    return Qe;
  }, Ve.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, exports$2N = Ve, exports$2N;
}
var exports$2M = {}, _dewExec$2L = !1;
function dew$2L() {
  if (_dewExec$2L)
    return exports$2M;
  _dewExec$2L = !0;
  var $e = dew$f(), Ze = dew$2M(), Fe = dew$2P().Buffer, Ke = new Array(16);
  function Ve() {
    Ze.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  $e(Ve, Ze), Ve.prototype._update = function() {
    for (var dt = Ke, bt = 0; bt < 16; ++bt)
      dt[bt] = this._block.readInt32LE(bt * 4);
    var $t = this._a, vt = this._b, wt = this._c, xt = this._d;
    $t = Qe($t, vt, wt, xt, dt[0], 3614090360, 7), xt = Qe(xt, $t, vt, wt, dt[1], 3905402710, 12), wt = Qe(wt, xt, $t, vt, dt[2], 606105819, 17), vt = Qe(vt, wt, xt, $t, dt[3], 3250441966, 22), $t = Qe($t, vt, wt, xt, dt[4], 4118548399, 7), xt = Qe(xt, $t, vt, wt, dt[5], 1200080426, 12), wt = Qe(wt, xt, $t, vt, dt[6], 2821735955, 17), vt = Qe(vt, wt, xt, $t, dt[7], 4249261313, 22), $t = Qe($t, vt, wt, xt, dt[8], 1770035416, 7), xt = Qe(xt, $t, vt, wt, dt[9], 2336552879, 12), wt = Qe(wt, xt, $t, vt, dt[10], 4294925233, 17), vt = Qe(vt, wt, xt, $t, dt[11], 2304563134, 22), $t = Qe($t, vt, wt, xt, dt[12], 1804603682, 7), xt = Qe(xt, $t, vt, wt, dt[13], 4254626195, 12), wt = Qe(wt, xt, $t, vt, dt[14], 2792965006, 17), vt = Qe(vt, wt, xt, $t, dt[15], 1236535329, 22), $t = at($t, vt, wt, xt, dt[1], 4129170786, 5), xt = at(xt, $t, vt, wt, dt[6], 3225465664, 9), wt = at(wt, xt, $t, vt, dt[11], 643717713, 14), vt = at(vt, wt, xt, $t, dt[0], 3921069994, 20), $t = at($t, vt, wt, xt, dt[5], 3593408605, 5), xt = at(xt, $t, vt, wt, dt[10], 38016083, 9), wt = at(wt, xt, $t, vt, dt[15], 3634488961, 14), vt = at(vt, wt, xt, $t, dt[4], 3889429448, 20), $t = at($t, vt, wt, xt, dt[9], 568446438, 5), xt = at(xt, $t, vt, wt, dt[14], 3275163606, 9), wt = at(wt, xt, $t, vt, dt[3], 4107603335, 14), vt = at(vt, wt, xt, $t, dt[8], 1163531501, 20), $t = at($t, vt, wt, xt, dt[13], 2850285829, 5), xt = at(xt, $t, vt, wt, dt[2], 4243563512, 9), wt = at(wt, xt, $t, vt, dt[7], 1735328473, 14), vt = at(vt, wt, xt, $t, dt[12], 2368359562, 20), $t = ut($t, vt, wt, xt, dt[5], 4294588738, 4), xt = ut(xt, $t, vt, wt, dt[8], 2272392833, 11), wt = ut(wt, xt, $t, vt, dt[11], 1839030562, 16), vt = ut(vt, wt, xt, $t, dt[14], 4259657740, 23), $t = ut($t, vt, wt, xt, dt[1], 2763975236, 4), xt = ut(xt, $t, vt, wt, dt[4], 1272893353, 11), wt = ut(wt, xt, $t, vt, dt[7], 4139469664, 16), vt = ut(vt, wt, xt, $t, dt[10], 3200236656, 23), $t = ut($t, vt, wt, xt, dt[13], 681279174, 4), xt = ut(xt, $t, vt, wt, dt[0], 3936430074, 11), wt = ut(wt, xt, $t, vt, dt[3], 3572445317, 16), vt = ut(vt, wt, xt, $t, dt[6], 76029189, 23), $t = ut($t, vt, wt, xt, dt[9], 3654602809, 4), xt = ut(xt, $t, vt, wt, dt[12], 3873151461, 11), wt = ut(wt, xt, $t, vt, dt[15], 530742520, 16), vt = ut(vt, wt, xt, $t, dt[2], 3299628645, 23), $t = lt($t, vt, wt, xt, dt[0], 4096336452, 6), xt = lt(xt, $t, vt, wt, dt[7], 1126891415, 10), wt = lt(wt, xt, $t, vt, dt[14], 2878612391, 15), vt = lt(vt, wt, xt, $t, dt[5], 4237533241, 21), $t = lt($t, vt, wt, xt, dt[12], 1700485571, 6), xt = lt(xt, $t, vt, wt, dt[3], 2399980690, 10), wt = lt(wt, xt, $t, vt, dt[10], 4293915773, 15), vt = lt(vt, wt, xt, $t, dt[1], 2240044497, 21), $t = lt($t, vt, wt, xt, dt[8], 1873313359, 6), xt = lt(xt, $t, vt, wt, dt[15], 4264355552, 10), wt = lt(wt, xt, $t, vt, dt[6], 2734768916, 15), vt = lt(vt, wt, xt, $t, dt[13], 1309151649, 21), $t = lt($t, vt, wt, xt, dt[4], 4149444226, 6), xt = lt(xt, $t, vt, wt, dt[11], 3174756917, 10), wt = lt(wt, xt, $t, vt, dt[2], 718787259, 15), vt = lt(vt, wt, xt, $t, dt[9], 3951481745, 21), this._a = this._a + $t | 0, this._b = this._b + vt | 0, this._c = this._c + wt | 0, this._d = this._d + xt | 0;
  }, Ve.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var dt = Fe.allocUnsafe(16);
    return dt.writeInt32LE(this._a, 0), dt.writeInt32LE(this._b, 4), dt.writeInt32LE(this._c, 8), dt.writeInt32LE(this._d, 12), dt;
  };
  function Je(dt, bt) {
    return dt << bt | dt >>> 32 - bt;
  }
  function Qe(dt, bt, $t, vt, wt, xt, Et) {
    return Je(dt + (bt & $t | ~bt & vt) + wt + xt | 0, Et) + bt | 0;
  }
  function at(dt, bt, $t, vt, wt, xt, Et) {
    return Je(dt + (bt & vt | $t & ~vt) + wt + xt | 0, Et) + bt | 0;
  }
  function ut(dt, bt, $t, vt, wt, xt, Et) {
    return Je(dt + (bt ^ $t ^ vt) + wt + xt | 0, Et) + bt | 0;
  }
  function lt(dt, bt, $t, vt, wt, xt, Et) {
    return Je(dt + ($t ^ (bt | ~vt)) + wt + xt | 0, Et) + bt | 0;
  }
  return exports$2M = Ve, exports$2M;
}
var exports$2L = {}, _dewExec$2K = !1;
function dew$2K() {
  if (_dewExec$2K)
    return exports$2L;
  _dewExec$2K = !0;
  var $e = buffer.Buffer, Ze = dew$f(), Fe = dew$2M(), Ke = new Array(16), Ve = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], Je = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], Qe = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], at = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], ut = [0, 1518500249, 1859775393, 2400959708, 2840853838], lt = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function dt() {
    Fe.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  Ze(dt, Fe), dt.prototype._update = function() {
    for (var Tt = Ke, Rt = 0; Rt < 16; ++Rt)
      Tt[Rt] = this._block.readInt32LE(Rt * 4);
    for (var Ct = this._a | 0, Zt = this._b | 0, Lt = this._c | 0, Ut = this._d | 0, Pt = this._e | 0, Ot = this._a | 0, Ft = this._b | 0, gt = this._c | 0, We = this._d | 0, Xe = this._e | 0, rt = 0; rt < 80; rt += 1) {
      var ot, ft;
      rt < 16 ? (ot = $t(Ct, Zt, Lt, Ut, Pt, Tt[Ve[rt]], ut[0], Qe[rt]), ft = Et(Ot, Ft, gt, We, Xe, Tt[Je[rt]], lt[0], at[rt])) : rt < 32 ? (ot = vt(Ct, Zt, Lt, Ut, Pt, Tt[Ve[rt]], ut[1], Qe[rt]), ft = xt(Ot, Ft, gt, We, Xe, Tt[Je[rt]], lt[1], at[rt])) : rt < 48 ? (ot = wt(Ct, Zt, Lt, Ut, Pt, Tt[Ve[rt]], ut[2], Qe[rt]), ft = wt(Ot, Ft, gt, We, Xe, Tt[Je[rt]], lt[2], at[rt])) : rt < 64 ? (ot = xt(Ct, Zt, Lt, Ut, Pt, Tt[Ve[rt]], ut[3], Qe[rt]), ft = vt(Ot, Ft, gt, We, Xe, Tt[Je[rt]], lt[3], at[rt])) : (ot = Et(Ct, Zt, Lt, Ut, Pt, Tt[Ve[rt]], ut[4], Qe[rt]), ft = $t(Ot, Ft, gt, We, Xe, Tt[Je[rt]], lt[4], at[rt])), Ct = Pt, Pt = Ut, Ut = bt(Lt, 10), Lt = Zt, Zt = ot, Ot = Xe, Xe = We, We = bt(gt, 10), gt = Ft, Ft = ft;
    }
    var mt = this._b + Lt + We | 0;
    this._b = this._c + Ut + Xe | 0, this._c = this._d + Pt + Ot | 0, this._d = this._e + Ct + Ft | 0, this._e = this._a + Zt + gt | 0, this._a = mt;
  }, dt.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var Tt = $e.alloc ? $e.alloc(20) : new $e(20);
    return Tt.writeInt32LE(this._a, 0), Tt.writeInt32LE(this._b, 4), Tt.writeInt32LE(this._c, 8), Tt.writeInt32LE(this._d, 12), Tt.writeInt32LE(this._e, 16), Tt;
  };
  function bt(Tt, Rt) {
    return Tt << Rt | Tt >>> 32 - Rt;
  }
  function $t(Tt, Rt, Ct, Zt, Lt, Ut, Pt, Ot) {
    return bt(Tt + (Rt ^ Ct ^ Zt) + Ut + Pt | 0, Ot) + Lt | 0;
  }
  function vt(Tt, Rt, Ct, Zt, Lt, Ut, Pt, Ot) {
    return bt(Tt + (Rt & Ct | ~Rt & Zt) + Ut + Pt | 0, Ot) + Lt | 0;
  }
  function wt(Tt, Rt, Ct, Zt, Lt, Ut, Pt, Ot) {
    return bt(Tt + ((Rt | ~Ct) ^ Zt) + Ut + Pt | 0, Ot) + Lt | 0;
  }
  function xt(Tt, Rt, Ct, Zt, Lt, Ut, Pt, Ot) {
    return bt(Tt + (Rt & Zt | Ct & ~Zt) + Ut + Pt | 0, Ot) + Lt | 0;
  }
  function Et(Tt, Rt, Ct, Zt, Lt, Ut, Pt, Ot) {
    return bt(Tt + (Rt ^ (Ct | ~Zt)) + Ut + Pt | 0, Ot) + Lt | 0;
  }
  return exports$2L = dt, exports$2L;
}
var exports$2K = {}, _dewExec$2J = !1, _global$T = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$2J() {
  if (_dewExec$2J)
    return exports$2K;
  _dewExec$2J = !0;
  var $e = dew$2P().Buffer;
  function Ze(Fe, Ke) {
    (this || _global$T)._block = $e.alloc(Fe), (this || _global$T)._finalSize = Ke, (this || _global$T)._blockSize = Fe, (this || _global$T)._len = 0;
  }
  return Ze.prototype.update = function(Fe, Ke) {
    typeof Fe == "string" && (Ke = Ke || "utf8", Fe = $e.from(Fe, Ke));
    for (var Ve = (this || _global$T)._block, Je = (this || _global$T)._blockSize, Qe = Fe.length, at = (this || _global$T)._len, ut = 0; ut < Qe; ) {
      for (var lt = at % Je, dt = Math.min(Qe - ut, Je - lt), bt = 0; bt < dt; bt++)
        Ve[lt + bt] = Fe[ut + bt];
      at += dt, ut += dt, at % Je === 0 && this._update(Ve);
    }
    return (this || _global$T)._len += Qe, this || _global$T;
  }, Ze.prototype.digest = function(Fe) {
    var Ke = (this || _global$T)._len % (this || _global$T)._blockSize;
    (this || _global$T)._block[Ke] = 128, (this || _global$T)._block.fill(0, Ke + 1), Ke >= (this || _global$T)._finalSize && (this._update((this || _global$T)._block), (this || _global$T)._block.fill(0));
    var Ve = (this || _global$T)._len * 8;
    if (Ve <= 4294967295)
      (this || _global$T)._block.writeUInt32BE(Ve, (this || _global$T)._blockSize - 4);
    else {
      var Je = (Ve & 4294967295) >>> 0, Qe = (Ve - Je) / 4294967296;
      (this || _global$T)._block.writeUInt32BE(Qe, (this || _global$T)._blockSize - 8), (this || _global$T)._block.writeUInt32BE(Je, (this || _global$T)._blockSize - 4);
    }
    this._update((this || _global$T)._block);
    var at = this._hash();
    return Fe ? at.toString(Fe) : at;
  }, Ze.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, exports$2K = Ze, exports$2K;
}
var exports$2J = {}, _dewExec$2I = !1, _global$S = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$2I() {
  if (_dewExec$2I)
    return exports$2J;
  _dewExec$2I = !0;
  var $e = dew$f(), Ze = dew$2J(), Fe = dew$2P().Buffer, Ke = [1518500249, 1859775393, -1894007588, -899497514], Ve = new Array(80);
  function Je() {
    this.init(), (this || _global$S)._w = Ve, Ze.call(this || _global$S, 64, 56);
  }
  $e(Je, Ze), Je.prototype.init = function() {
    return (this || _global$S)._a = 1732584193, (this || _global$S)._b = 4023233417, (this || _global$S)._c = 2562383102, (this || _global$S)._d = 271733878, (this || _global$S)._e = 3285377520, this || _global$S;
  };
  function Qe(lt) {
    return lt << 5 | lt >>> 27;
  }
  function at(lt) {
    return lt << 30 | lt >>> 2;
  }
  function ut(lt, dt, bt, $t) {
    return lt === 0 ? dt & bt | ~dt & $t : lt === 2 ? dt & bt | dt & $t | bt & $t : dt ^ bt ^ $t;
  }
  return Je.prototype._update = function(lt) {
    for (var dt = (this || _global$S)._w, bt = (this || _global$S)._a | 0, $t = (this || _global$S)._b | 0, vt = (this || _global$S)._c | 0, wt = (this || _global$S)._d | 0, xt = (this || _global$S)._e | 0, Et = 0; Et < 16; ++Et)
      dt[Et] = lt.readInt32BE(Et * 4);
    for (; Et < 80; ++Et)
      dt[Et] = dt[Et - 3] ^ dt[Et - 8] ^ dt[Et - 14] ^ dt[Et - 16];
    for (var Tt = 0; Tt < 80; ++Tt) {
      var Rt = ~~(Tt / 20), Ct = Qe(bt) + ut(Rt, $t, vt, wt) + xt + dt[Tt] + Ke[Rt] | 0;
      xt = wt, wt = vt, vt = at($t), $t = bt, bt = Ct;
    }
    (this || _global$S)._a = bt + (this || _global$S)._a | 0, (this || _global$S)._b = $t + (this || _global$S)._b | 0, (this || _global$S)._c = vt + (this || _global$S)._c | 0, (this || _global$S)._d = wt + (this || _global$S)._d | 0, (this || _global$S)._e = xt + (this || _global$S)._e | 0;
  }, Je.prototype._hash = function() {
    var lt = Fe.allocUnsafe(20);
    return lt.writeInt32BE((this || _global$S)._a | 0, 0), lt.writeInt32BE((this || _global$S)._b | 0, 4), lt.writeInt32BE((this || _global$S)._c | 0, 8), lt.writeInt32BE((this || _global$S)._d | 0, 12), lt.writeInt32BE((this || _global$S)._e | 0, 16), lt;
  }, exports$2J = Je, exports$2J;
}
var exports$2I = {}, _dewExec$2H = !1, _global$R = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$2H() {
  if (_dewExec$2H)
    return exports$2I;
  _dewExec$2H = !0;
  var $e = dew$f(), Ze = dew$2J(), Fe = dew$2P().Buffer, Ke = [1518500249, 1859775393, -1894007588, -899497514], Ve = new Array(80);
  function Je() {
    this.init(), (this || _global$R)._w = Ve, Ze.call(this || _global$R, 64, 56);
  }
  $e(Je, Ze), Je.prototype.init = function() {
    return (this || _global$R)._a = 1732584193, (this || _global$R)._b = 4023233417, (this || _global$R)._c = 2562383102, (this || _global$R)._d = 271733878, (this || _global$R)._e = 3285377520, this || _global$R;
  };
  function Qe(dt) {
    return dt << 1 | dt >>> 31;
  }
  function at(dt) {
    return dt << 5 | dt >>> 27;
  }
  function ut(dt) {
    return dt << 30 | dt >>> 2;
  }
  function lt(dt, bt, $t, vt) {
    return dt === 0 ? bt & $t | ~bt & vt : dt === 2 ? bt & $t | bt & vt | $t & vt : bt ^ $t ^ vt;
  }
  return Je.prototype._update = function(dt) {
    for (var bt = (this || _global$R)._w, $t = (this || _global$R)._a | 0, vt = (this || _global$R)._b | 0, wt = (this || _global$R)._c | 0, xt = (this || _global$R)._d | 0, Et = (this || _global$R)._e | 0, Tt = 0; Tt < 16; ++Tt)
      bt[Tt] = dt.readInt32BE(Tt * 4);
    for (; Tt < 80; ++Tt)
      bt[Tt] = Qe(bt[Tt - 3] ^ bt[Tt - 8] ^ bt[Tt - 14] ^ bt[Tt - 16]);
    for (var Rt = 0; Rt < 80; ++Rt) {
      var Ct = ~~(Rt / 20), Zt = at($t) + lt(Ct, vt, wt, xt) + Et + bt[Rt] + Ke[Ct] | 0;
      Et = xt, xt = wt, wt = ut(vt), vt = $t, $t = Zt;
    }
    (this || _global$R)._a = $t + (this || _global$R)._a | 0, (this || _global$R)._b = vt + (this || _global$R)._b | 0, (this || _global$R)._c = wt + (this || _global$R)._c | 0, (this || _global$R)._d = xt + (this || _global$R)._d | 0, (this || _global$R)._e = Et + (this || _global$R)._e | 0;
  }, Je.prototype._hash = function() {
    var dt = Fe.allocUnsafe(20);
    return dt.writeInt32BE((this || _global$R)._a | 0, 0), dt.writeInt32BE((this || _global$R)._b | 0, 4), dt.writeInt32BE((this || _global$R)._c | 0, 8), dt.writeInt32BE((this || _global$R)._d | 0, 12), dt.writeInt32BE((this || _global$R)._e | 0, 16), dt;
  }, exports$2I = Je, exports$2I;
}
var exports$2H = {}, _dewExec$2G = !1, _global$Q = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$2G() {
  if (_dewExec$2G)
    return exports$2H;
  _dewExec$2G = !0;
  var $e = dew$f(), Ze = dew$2J(), Fe = dew$2P().Buffer, Ke = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], Ve = new Array(64);
  function Je() {
    this.init(), (this || _global$Q)._w = Ve, Ze.call(this || _global$Q, 64, 56);
  }
  $e(Je, Ze), Je.prototype.init = function() {
    return (this || _global$Q)._a = 1779033703, (this || _global$Q)._b = 3144134277, (this || _global$Q)._c = 1013904242, (this || _global$Q)._d = 2773480762, (this || _global$Q)._e = 1359893119, (this || _global$Q)._f = 2600822924, (this || _global$Q)._g = 528734635, (this || _global$Q)._h = 1541459225, this || _global$Q;
  };
  function Qe($t, vt, wt) {
    return wt ^ $t & (vt ^ wt);
  }
  function at($t, vt, wt) {
    return $t & vt | wt & ($t | vt);
  }
  function ut($t) {
    return ($t >>> 2 | $t << 30) ^ ($t >>> 13 | $t << 19) ^ ($t >>> 22 | $t << 10);
  }
  function lt($t) {
    return ($t >>> 6 | $t << 26) ^ ($t >>> 11 | $t << 21) ^ ($t >>> 25 | $t << 7);
  }
  function dt($t) {
    return ($t >>> 7 | $t << 25) ^ ($t >>> 18 | $t << 14) ^ $t >>> 3;
  }
  function bt($t) {
    return ($t >>> 17 | $t << 15) ^ ($t >>> 19 | $t << 13) ^ $t >>> 10;
  }
  return Je.prototype._update = function($t) {
    for (var vt = (this || _global$Q)._w, wt = (this || _global$Q)._a | 0, xt = (this || _global$Q)._b | 0, Et = (this || _global$Q)._c | 0, Tt = (this || _global$Q)._d | 0, Rt = (this || _global$Q)._e | 0, Ct = (this || _global$Q)._f | 0, Zt = (this || _global$Q)._g | 0, Lt = (this || _global$Q)._h | 0, Ut = 0; Ut < 16; ++Ut)
      vt[Ut] = $t.readInt32BE(Ut * 4);
    for (; Ut < 64; ++Ut)
      vt[Ut] = bt(vt[Ut - 2]) + vt[Ut - 7] + dt(vt[Ut - 15]) + vt[Ut - 16] | 0;
    for (var Pt = 0; Pt < 64; ++Pt) {
      var Ot = Lt + lt(Rt) + Qe(Rt, Ct, Zt) + Ke[Pt] + vt[Pt] | 0, Ft = ut(wt) + at(wt, xt, Et) | 0;
      Lt = Zt, Zt = Ct, Ct = Rt, Rt = Tt + Ot | 0, Tt = Et, Et = xt, xt = wt, wt = Ot + Ft | 0;
    }
    (this || _global$Q)._a = wt + (this || _global$Q)._a | 0, (this || _global$Q)._b = xt + (this || _global$Q)._b | 0, (this || _global$Q)._c = Et + (this || _global$Q)._c | 0, (this || _global$Q)._d = Tt + (this || _global$Q)._d | 0, (this || _global$Q)._e = Rt + (this || _global$Q)._e | 0, (this || _global$Q)._f = Ct + (this || _global$Q)._f | 0, (this || _global$Q)._g = Zt + (this || _global$Q)._g | 0, (this || _global$Q)._h = Lt + (this || _global$Q)._h | 0;
  }, Je.prototype._hash = function() {
    var $t = Fe.allocUnsafe(32);
    return $t.writeInt32BE((this || _global$Q)._a, 0), $t.writeInt32BE((this || _global$Q)._b, 4), $t.writeInt32BE((this || _global$Q)._c, 8), $t.writeInt32BE((this || _global$Q)._d, 12), $t.writeInt32BE((this || _global$Q)._e, 16), $t.writeInt32BE((this || _global$Q)._f, 20), $t.writeInt32BE((this || _global$Q)._g, 24), $t.writeInt32BE((this || _global$Q)._h, 28), $t;
  }, exports$2H = Je, exports$2H;
}
var exports$2G = {}, _dewExec$2F = !1, _global$P = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$2F() {
  if (_dewExec$2F)
    return exports$2G;
  _dewExec$2F = !0;
  var $e = dew$f(), Ze = dew$2G(), Fe = dew$2J(), Ke = dew$2P().Buffer, Ve = new Array(64);
  function Je() {
    this.init(), (this || _global$P)._w = Ve, Fe.call(this || _global$P, 64, 56);
  }
  return $e(Je, Ze), Je.prototype.init = function() {
    return (this || _global$P)._a = 3238371032, (this || _global$P)._b = 914150663, (this || _global$P)._c = 812702999, (this || _global$P)._d = 4144912697, (this || _global$P)._e = 4290775857, (this || _global$P)._f = 1750603025, (this || _global$P)._g = 1694076839, (this || _global$P)._h = 3204075428, this || _global$P;
  }, Je.prototype._hash = function() {
    var Qe = Ke.allocUnsafe(28);
    return Qe.writeInt32BE((this || _global$P)._a, 0), Qe.writeInt32BE((this || _global$P)._b, 4), Qe.writeInt32BE((this || _global$P)._c, 8), Qe.writeInt32BE((this || _global$P)._d, 12), Qe.writeInt32BE((this || _global$P)._e, 16), Qe.writeInt32BE((this || _global$P)._f, 20), Qe.writeInt32BE((this || _global$P)._g, 24), Qe;
  }, exports$2G = Je, exports$2G;
}
var exports$2F = {}, _dewExec$2E = !1, _global$O = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$2E() {
  if (_dewExec$2E)
    return exports$2F;
  _dewExec$2E = !0;
  var $e = dew$f(), Ze = dew$2J(), Fe = dew$2P().Buffer, Ke = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], Ve = new Array(160);
  function Je() {
    this.init(), (this || _global$O)._w = Ve, Ze.call(this || _global$O, 128, 112);
  }
  $e(Je, Ze), Je.prototype.init = function() {
    return (this || _global$O)._ah = 1779033703, (this || _global$O)._bh = 3144134277, (this || _global$O)._ch = 1013904242, (this || _global$O)._dh = 2773480762, (this || _global$O)._eh = 1359893119, (this || _global$O)._fh = 2600822924, (this || _global$O)._gh = 528734635, (this || _global$O)._hh = 1541459225, (this || _global$O)._al = 4089235720, (this || _global$O)._bl = 2227873595, (this || _global$O)._cl = 4271175723, (this || _global$O)._dl = 1595750129, (this || _global$O)._el = 2917565137, (this || _global$O)._fl = 725511199, (this || _global$O)._gl = 4215389547, (this || _global$O)._hl = 327033209, this || _global$O;
  };
  function Qe(xt, Et, Tt) {
    return Tt ^ xt & (Et ^ Tt);
  }
  function at(xt, Et, Tt) {
    return xt & Et | Tt & (xt | Et);
  }
  function ut(xt, Et) {
    return (xt >>> 28 | Et << 4) ^ (Et >>> 2 | xt << 30) ^ (Et >>> 7 | xt << 25);
  }
  function lt(xt, Et) {
    return (xt >>> 14 | Et << 18) ^ (xt >>> 18 | Et << 14) ^ (Et >>> 9 | xt << 23);
  }
  function dt(xt, Et) {
    return (xt >>> 1 | Et << 31) ^ (xt >>> 8 | Et << 24) ^ xt >>> 7;
  }
  function bt(xt, Et) {
    return (xt >>> 1 | Et << 31) ^ (xt >>> 8 | Et << 24) ^ (xt >>> 7 | Et << 25);
  }
  function $t(xt, Et) {
    return (xt >>> 19 | Et << 13) ^ (Et >>> 29 | xt << 3) ^ xt >>> 6;
  }
  function vt(xt, Et) {
    return (xt >>> 19 | Et << 13) ^ (Et >>> 29 | xt << 3) ^ (xt >>> 6 | Et << 26);
  }
  function wt(xt, Et) {
    return xt >>> 0 < Et >>> 0 ? 1 : 0;
  }
  return Je.prototype._update = function(xt) {
    for (var Et = (this || _global$O)._w, Tt = (this || _global$O)._ah | 0, Rt = (this || _global$O)._bh | 0, Ct = (this || _global$O)._ch | 0, Zt = (this || _global$O)._dh | 0, Lt = (this || _global$O)._eh | 0, Ut = (this || _global$O)._fh | 0, Pt = (this || _global$O)._gh | 0, Ot = (this || _global$O)._hh | 0, Ft = (this || _global$O)._al | 0, gt = (this || _global$O)._bl | 0, We = (this || _global$O)._cl | 0, Xe = (this || _global$O)._dl | 0, rt = (this || _global$O)._el | 0, ot = (this || _global$O)._fl | 0, ft = (this || _global$O)._gl | 0, mt = (this || _global$O)._hl | 0, yt = 0; yt < 32; yt += 2)
      Et[yt] = xt.readInt32BE(yt * 4), Et[yt + 1] = xt.readInt32BE(yt * 4 + 4);
    for (; yt < 160; yt += 2) {
      var pt = Et[yt - 30], Ge = Et[yt - 15 * 2 + 1], ct = dt(pt, Ge), Mt = bt(Ge, pt);
      pt = Et[yt - 2 * 2], Ge = Et[yt - 2 * 2 + 1];
      var St = $t(pt, Ge), At = vt(Ge, pt), Nt = Et[yt - 7 * 2], qt = Et[yt - 7 * 2 + 1], Qt = Et[yt - 16 * 2], Xt = Et[yt - 16 * 2 + 1], zt = Mt + qt | 0, Kt = ct + Nt + wt(zt, Mt) | 0;
      zt = zt + At | 0, Kt = Kt + St + wt(zt, At) | 0, zt = zt + Xt | 0, Kt = Kt + Qt + wt(zt, Xt) | 0, Et[yt] = Kt, Et[yt + 1] = zt;
    }
    for (var ur = 0; ur < 160; ur += 2) {
      Kt = Et[ur], zt = Et[ur + 1];
      var er = at(Tt, Rt, Ct), Dt = at(Ft, gt, We), Ht = ut(Tt, Ft), Gt = ut(Ft, Tt), rr = lt(Lt, rt), sr = lt(rt, Lt), Jt = Ke[ur], ir = Ke[ur + 1], Br = Qe(Lt, Ut, Pt), or = Qe(rt, ot, ft), lr = mt + sr | 0, Nr = Ot + rr + wt(lr, mt) | 0;
      lr = lr + or | 0, Nr = Nr + Br + wt(lr, or) | 0, lr = lr + ir | 0, Nr = Nr + Jt + wt(lr, ir) | 0, lr = lr + zt | 0, Nr = Nr + Kt + wt(lr, zt) | 0;
      var dr = Gt + Dt | 0, gr = Ht + er + wt(dr, Gt) | 0;
      Ot = Pt, mt = ft, Pt = Ut, ft = ot, Ut = Lt, ot = rt, rt = Xe + lr | 0, Lt = Zt + Nr + wt(rt, Xe) | 0, Zt = Ct, Xe = We, Ct = Rt, We = gt, Rt = Tt, gt = Ft, Ft = lr + dr | 0, Tt = Nr + gr + wt(Ft, lr) | 0;
    }
    (this || _global$O)._al = (this || _global$O)._al + Ft | 0, (this || _global$O)._bl = (this || _global$O)._bl + gt | 0, (this || _global$O)._cl = (this || _global$O)._cl + We | 0, (this || _global$O)._dl = (this || _global$O)._dl + Xe | 0, (this || _global$O)._el = (this || _global$O)._el + rt | 0, (this || _global$O)._fl = (this || _global$O)._fl + ot | 0, (this || _global$O)._gl = (this || _global$O)._gl + ft | 0, (this || _global$O)._hl = (this || _global$O)._hl + mt | 0, (this || _global$O)._ah = (this || _global$O)._ah + Tt + wt((this || _global$O)._al, Ft) | 0, (this || _global$O)._bh = (this || _global$O)._bh + Rt + wt((this || _global$O)._bl, gt) | 0, (this || _global$O)._ch = (this || _global$O)._ch + Ct + wt((this || _global$O)._cl, We) | 0, (this || _global$O)._dh = (this || _global$O)._dh + Zt + wt((this || _global$O)._dl, Xe) | 0, (this || _global$O)._eh = (this || _global$O)._eh + Lt + wt((this || _global$O)._el, rt) | 0, (this || _global$O)._fh = (this || _global$O)._fh + Ut + wt((this || _global$O)._fl, ot) | 0, (this || _global$O)._gh = (this || _global$O)._gh + Pt + wt((this || _global$O)._gl, ft) | 0, (this || _global$O)._hh = (this || _global$O)._hh + Ot + wt((this || _global$O)._hl, mt) | 0;
  }, Je.prototype._hash = function() {
    var xt = Fe.allocUnsafe(64);
    function Et(Tt, Rt, Ct) {
      xt.writeInt32BE(Tt, Ct), xt.writeInt32BE(Rt, Ct + 4);
    }
    return Et((this || _global$O)._ah, (this || _global$O)._al, 0), Et((this || _global$O)._bh, (this || _global$O)._bl, 8), Et((this || _global$O)._ch, (this || _global$O)._cl, 16), Et((this || _global$O)._dh, (this || _global$O)._dl, 24), Et((this || _global$O)._eh, (this || _global$O)._el, 32), Et((this || _global$O)._fh, (this || _global$O)._fl, 40), Et((this || _global$O)._gh, (this || _global$O)._gl, 48), Et((this || _global$O)._hh, (this || _global$O)._hl, 56), xt;
  }, exports$2F = Je, exports$2F;
}
var exports$2E = {}, _dewExec$2D = !1, _global$N = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$2D() {
  if (_dewExec$2D)
    return exports$2E;
  _dewExec$2D = !0;
  var $e = dew$f(), Ze = dew$2E(), Fe = dew$2J(), Ke = dew$2P().Buffer, Ve = new Array(160);
  function Je() {
    this.init(), (this || _global$N)._w = Ve, Fe.call(this || _global$N, 128, 112);
  }
  return $e(Je, Ze), Je.prototype.init = function() {
    return (this || _global$N)._ah = 3418070365, (this || _global$N)._bh = 1654270250, (this || _global$N)._ch = 2438529370, (this || _global$N)._dh = 355462360, (this || _global$N)._eh = 1731405415, (this || _global$N)._fh = 2394180231, (this || _global$N)._gh = 3675008525, (this || _global$N)._hh = 1203062813, (this || _global$N)._al = 3238371032, (this || _global$N)._bl = 914150663, (this || _global$N)._cl = 812702999, (this || _global$N)._dl = 4144912697, (this || _global$N)._el = 4290775857, (this || _global$N)._fl = 1750603025, (this || _global$N)._gl = 1694076839, (this || _global$N)._hl = 3204075428, this || _global$N;
  }, Je.prototype._hash = function() {
    var Qe = Ke.allocUnsafe(48);
    function at(ut, lt, dt) {
      Qe.writeInt32BE(ut, dt), Qe.writeInt32BE(lt, dt + 4);
    }
    return at((this || _global$N)._ah, (this || _global$N)._al, 0), at((this || _global$N)._bh, (this || _global$N)._bl, 8), at((this || _global$N)._ch, (this || _global$N)._cl, 16), at((this || _global$N)._dh, (this || _global$N)._dl, 24), at((this || _global$N)._eh, (this || _global$N)._el, 32), at((this || _global$N)._fh, (this || _global$N)._fl, 40), Qe;
  }, exports$2E = Je, exports$2E;
}
var exports$2D = {}, _dewExec$2C = !1, module$b = {
  exports: exports$2D
};
function dew$2C() {
  if (_dewExec$2C)
    return module$b.exports;
  _dewExec$2C = !0;
  var $e = module$b.exports = function(Fe) {
    Fe = Fe.toLowerCase();
    var Ke = $e[Fe];
    if (!Ke)
      throw new Error(Fe + " is not supported (we accept pull requests)");
    return new Ke();
  };
  return $e.sha = dew$2I(), $e.sha1 = dew$2H(), $e.sha224 = dew$2F(), $e.sha256 = dew$2G(), $e.sha384 = dew$2D(), $e.sha512 = dew$2E(), module$b.exports;
}
var exports$f$2 = {}, _dewExec$f$2 = !1;
function dew$f$2() {
  return _dewExec$f$2 || (_dewExec$f$2 = !0, typeof Object.create == "function" ? exports$f$2 = function(Ze, Fe) {
    Fe && (Ze.super_ = Fe, Ze.prototype = Object.create(Fe.prototype, {
      constructor: {
        value: Ze,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : exports$f$2 = function(Ze, Fe) {
    if (Fe) {
      Ze.super_ = Fe;
      var Ke = function() {
      };
      Ke.prototype = Fe.prototype, Ze.prototype = new Ke(), Ze.prototype.constructor = Ze;
    }
  }), exports$f$2;
}
var exports$e$2 = {}, _dewExec$e$2 = !1;
function dew$e$2() {
  return _dewExec$e$2 || (_dewExec$e$2 = !0, exports$e$2 = y.EventEmitter), exports$e$2;
}
var exports$d$2 = {}, _dewExec$d$2 = !1;
function dew$d$2() {
  if (_dewExec$d$2)
    return exports$d$2;
  _dewExec$d$2 = !0;
  function $e($t, vt) {
    var wt = Object.keys($t);
    if (Object.getOwnPropertySymbols) {
      var xt = Object.getOwnPropertySymbols($t);
      vt && (xt = xt.filter(function(Et) {
        return Object.getOwnPropertyDescriptor($t, Et).enumerable;
      })), wt.push.apply(wt, xt);
    }
    return wt;
  }
  function Ze($t) {
    for (var vt = 1; vt < arguments.length; vt++) {
      var wt = arguments[vt] != null ? arguments[vt] : {};
      vt % 2 ? $e(Object(wt), !0).forEach(function(xt) {
        Fe($t, xt, wt[xt]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties($t, Object.getOwnPropertyDescriptors(wt)) : $e(Object(wt)).forEach(function(xt) {
        Object.defineProperty($t, xt, Object.getOwnPropertyDescriptor(wt, xt));
      });
    }
    return $t;
  }
  function Fe($t, vt, wt) {
    return vt in $t ? Object.defineProperty($t, vt, {
      value: wt,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : $t[vt] = wt, $t;
  }
  function Ke($t, vt) {
    if (!($t instanceof vt))
      throw new TypeError("Cannot call a class as a function");
  }
  function Ve($t, vt) {
    for (var wt = 0; wt < vt.length; wt++) {
      var xt = vt[wt];
      xt.enumerable = xt.enumerable || !1, xt.configurable = !0, "value" in xt && (xt.writable = !0), Object.defineProperty($t, xt.key, xt);
    }
  }
  function Je($t, vt, wt) {
    return vt && Ve($t.prototype, vt), wt && Ve($t, wt), $t;
  }
  var Qe = e$1$1$1, at = Qe.Buffer, ut = X, lt = ut.inspect, dt = lt && lt.custom || "inspect";
  function bt($t, vt, wt) {
    at.prototype.copy.call($t, vt, wt);
  }
  return exports$d$2 = /* @__PURE__ */ function() {
    function $t() {
      Ke(this, $t), this.head = null, this.tail = null, this.length = 0;
    }
    return Je($t, [{
      key: "push",
      value: function(wt) {
        var xt = {
          data: wt,
          next: null
        };
        this.length > 0 ? this.tail.next = xt : this.head = xt, this.tail = xt, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(wt) {
        var xt = {
          data: wt,
          next: this.head
        };
        this.length === 0 && (this.tail = xt), this.head = xt, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var wt = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, wt;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(wt) {
        if (this.length === 0)
          return "";
        for (var xt = this.head, Et = "" + xt.data; xt = xt.next; )
          Et += wt + xt.data;
        return Et;
      }
    }, {
      key: "concat",
      value: function(wt) {
        if (this.length === 0)
          return at.alloc(0);
        for (var xt = at.allocUnsafe(wt >>> 0), Et = this.head, Tt = 0; Et; )
          bt(Et.data, xt, Tt), Tt += Et.data.length, Et = Et.next;
        return xt;
      }
    }, {
      key: "consume",
      value: function(wt, xt) {
        var Et;
        return wt < this.head.data.length ? (Et = this.head.data.slice(0, wt), this.head.data = this.head.data.slice(wt)) : wt === this.head.data.length ? Et = this.shift() : Et = xt ? this._getString(wt) : this._getBuffer(wt), Et;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
    }, {
      key: "_getString",
      value: function(wt) {
        var xt = this.head, Et = 1, Tt = xt.data;
        for (wt -= Tt.length; xt = xt.next; ) {
          var Rt = xt.data, Ct = wt > Rt.length ? Rt.length : wt;
          if (Ct === Rt.length ? Tt += Rt : Tt += Rt.slice(0, wt), wt -= Ct, wt === 0) {
            Ct === Rt.length ? (++Et, xt.next ? this.head = xt.next : this.head = this.tail = null) : (this.head = xt, xt.data = Rt.slice(Ct));
            break;
          }
          ++Et;
        }
        return this.length -= Et, Tt;
      }
    }, {
      key: "_getBuffer",
      value: function(wt) {
        var xt = at.allocUnsafe(wt), Et = this.head, Tt = 1;
        for (Et.data.copy(xt), wt -= Et.data.length; Et = Et.next; ) {
          var Rt = Et.data, Ct = wt > Rt.length ? Rt.length : wt;
          if (Rt.copy(xt, xt.length - wt, 0, Ct), wt -= Ct, wt === 0) {
            Ct === Rt.length ? (++Tt, Et.next ? this.head = Et.next : this.head = this.tail = null) : (this.head = Et, Et.data = Rt.slice(Ct));
            break;
          }
          ++Tt;
        }
        return this.length -= Tt, xt;
      }
    }, {
      key: dt,
      value: function(wt, xt) {
        return lt(this, Ze({}, xt, {
          depth: 0,
          customInspect: !1
        }));
      }
    }]), $t;
  }(), exports$d$2;
}
var exports$c$2 = {}, _dewExec$c$2 = !1;
function dew$c$2() {
  if (_dewExec$c$2)
    return exports$c$2;
  _dewExec$c$2 = !0;
  var $e = T;
  function Ze(at, ut) {
    var lt = this, dt = this._readableState && this._readableState.destroyed, bt = this._writableState && this._writableState.destroyed;
    return dt || bt ? (ut ? ut(at) : at && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, $e.nextTick(Je, this, at)) : $e.nextTick(Je, this, at)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(at || null, function($t) {
      !ut && $t ? lt._writableState ? lt._writableState.errorEmitted ? $e.nextTick(Ke, lt) : (lt._writableState.errorEmitted = !0, $e.nextTick(Fe, lt, $t)) : $e.nextTick(Fe, lt, $t) : ut ? ($e.nextTick(Ke, lt), ut($t)) : $e.nextTick(Ke, lt);
    }), this);
  }
  function Fe(at, ut) {
    Je(at, ut), Ke(at);
  }
  function Ke(at) {
    at._writableState && !at._writableState.emitClose || at._readableState && !at._readableState.emitClose || at.emit("close");
  }
  function Ve() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function Je(at, ut) {
    at.emit("error", ut);
  }
  function Qe(at, ut) {
    var lt = at._readableState, dt = at._writableState;
    lt && lt.autoDestroy || dt && dt.autoDestroy ? at.destroy(ut) : at.emit("error", ut);
  }
  return exports$c$2 = {
    destroy: Ze,
    undestroy: Ve,
    errorOrDestroy: Qe
  }, exports$c$2;
}
var exports$b$2 = {}, _dewExec$b$2 = !1;
function dew$b$2() {
  if (_dewExec$b$2)
    return exports$b$2;
  _dewExec$b$2 = !0;
  const $e = {};
  function Ze(Qe, at, ut) {
    ut || (ut = Error);
    function lt(bt, $t, vt) {
      return typeof at == "string" ? at : at(bt, $t, vt);
    }
    class dt extends ut {
      constructor($t, vt, wt) {
        super(lt($t, vt, wt));
      }
    }
    dt.prototype.name = ut.name, dt.prototype.code = Qe, $e[Qe] = dt;
  }
  function Fe(Qe, at) {
    if (Array.isArray(Qe)) {
      const ut = Qe.length;
      return Qe = Qe.map((lt) => String(lt)), ut > 2 ? `one of ${at} ${Qe.slice(0, ut - 1).join(", ")}, or ` + Qe[ut - 1] : ut === 2 ? `one of ${at} ${Qe[0]} or ${Qe[1]}` : `of ${at} ${Qe[0]}`;
    } else
      return `of ${at} ${String(Qe)}`;
  }
  function Ke(Qe, at, ut) {
    return Qe.substr(!ut || ut < 0 ? 0 : +ut, at.length) === at;
  }
  function Ve(Qe, at, ut) {
    return (ut === void 0 || ut > Qe.length) && (ut = Qe.length), Qe.substring(ut - at.length, ut) === at;
  }
  function Je(Qe, at, ut) {
    return typeof ut != "number" && (ut = 0), ut + at.length > Qe.length ? !1 : Qe.indexOf(at, ut) !== -1;
  }
  return Ze("ERR_INVALID_OPT_VALUE", function(Qe, at) {
    return 'The value "' + at + '" is invalid for option "' + Qe + '"';
  }, TypeError), Ze("ERR_INVALID_ARG_TYPE", function(Qe, at, ut) {
    let lt;
    typeof at == "string" && Ke(at, "not ") ? (lt = "must not be", at = at.replace(/^not /, "")) : lt = "must be";
    let dt;
    if (Ve(Qe, " argument"))
      dt = `The ${Qe} ${lt} ${Fe(at, "type")}`;
    else {
      const bt = Je(Qe, ".") ? "property" : "argument";
      dt = `The "${Qe}" ${bt} ${lt} ${Fe(at, "type")}`;
    }
    return dt += `. Received type ${typeof ut}`, dt;
  }, TypeError), Ze("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), Ze("ERR_METHOD_NOT_IMPLEMENTED", function(Qe) {
    return "The " + Qe + " method is not implemented";
  }), Ze("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), Ze("ERR_STREAM_DESTROYED", function(Qe) {
    return "Cannot call " + Qe + " after a stream was destroyed";
  }), Ze("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), Ze("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), Ze("ERR_STREAM_WRITE_AFTER_END", "write after end"), Ze("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), Ze("ERR_UNKNOWN_ENCODING", function(Qe) {
    return "Unknown encoding: " + Qe;
  }, TypeError), Ze("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), exports$b$2.codes = $e, exports$b$2;
}
var exports$a$2 = {}, _dewExec$a$2 = !1;
function dew$a$2() {
  if (_dewExec$a$2)
    return exports$a$2;
  _dewExec$a$2 = !0;
  var $e = dew$b$2().codes.ERR_INVALID_OPT_VALUE;
  function Ze(Ke, Ve, Je) {
    return Ke.highWaterMark != null ? Ke.highWaterMark : Ve ? Ke[Je] : null;
  }
  function Fe(Ke, Ve, Je, Qe) {
    var at = Ze(Ve, Qe, Je);
    if (at != null) {
      if (!(isFinite(at) && Math.floor(at) === at) || at < 0) {
        var ut = Qe ? Je : "highWaterMark";
        throw new $e(ut, at);
      }
      return Math.floor(at);
    }
    return Ke.objectMode ? 16 : 16 * 1024;
  }
  return exports$a$2 = {
    getHighWaterMark: Fe
  }, exports$a$2;
}
var exports$9$2 = {}, _dewExec$9$2 = !1, _global$2$2 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$9$2() {
  if (_dewExec$9$2)
    return exports$9$2;
  _dewExec$9$2 = !0, exports$9$2 = $e;
  function $e(Fe, Ke) {
    if (Ze("noDeprecation"))
      return Fe;
    var Ve = !1;
    function Je() {
      if (!Ve) {
        if (Ze("throwDeprecation"))
          throw new Error(Ke);
        Ze("traceDeprecation") ? console.trace(Ke) : console.warn(Ke), Ve = !0;
      }
      return Fe.apply(this || _global$2$2, arguments);
    }
    return Je;
  }
  function Ze(Fe) {
    try {
      if (!_global$2$2.localStorage)
        return !1;
    } catch {
      return !1;
    }
    var Ke = _global$2$2.localStorage[Fe];
    return Ke == null ? !1 : String(Ke).toLowerCase() === "true";
  }
  return exports$9$2;
}
var exports$8$2 = {}, _dewExec$8$2 = !1, _global$1$2 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$8$2() {
  if (_dewExec$8$2)
    return exports$8$2;
  _dewExec$8$2 = !0;
  var $e = T;
  exports$8$2 = Ft;
  function Ze(Xt) {
    var zt = this;
    this.next = null, this.entry = null, this.finish = function() {
      Qt(zt, Xt);
    };
  }
  var Fe;
  Ft.WritableState = Pt;
  var Ke = {
    deprecate: dew$9$2()
  }, Ve = dew$e$2(), Je = e$1$1$1.Buffer, Qe = _global$1$2.Uint8Array || function() {
  };
  function at(Xt) {
    return Je.from(Xt);
  }
  function ut(Xt) {
    return Je.isBuffer(Xt) || Xt instanceof Qe;
  }
  var lt = dew$c$2(), dt = dew$a$2(), bt = dt.getHighWaterMark, $t = dew$b$2().codes, vt = $t.ERR_INVALID_ARG_TYPE, wt = $t.ERR_METHOD_NOT_IMPLEMENTED, xt = $t.ERR_MULTIPLE_CALLBACK, Et = $t.ERR_STREAM_CANNOT_PIPE, Tt = $t.ERR_STREAM_DESTROYED, Rt = $t.ERR_STREAM_NULL_VALUES, Ct = $t.ERR_STREAM_WRITE_AFTER_END, Zt = $t.ERR_UNKNOWN_ENCODING, Lt = lt.errorOrDestroy;
  dew$f$2()(Ft, Ve);
  function Ut() {
  }
  function Pt(Xt, zt, Kt) {
    Fe = Fe || dew$7$2(), Xt = Xt || {}, typeof Kt != "boolean" && (Kt = zt instanceof Fe), this.objectMode = !!Xt.objectMode, Kt && (this.objectMode = this.objectMode || !!Xt.writableObjectMode), this.highWaterMark = bt(this, Xt, "writableHighWaterMark", Kt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ur = Xt.decodeStrings === !1;
    this.decodeStrings = !ur, this.defaultEncoding = Xt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(er) {
      yt(zt, er);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Xt.emitClose !== !1, this.autoDestroy = !!Xt.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Ze(this);
  }
  Pt.prototype.getBuffer = function() {
    for (var zt = this.bufferedRequest, Kt = []; zt; )
      Kt.push(zt), zt = zt.next;
    return Kt;
  }, function() {
    try {
      Object.defineProperty(Pt.prototype, "buffer", {
        get: Ke.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Ot;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ot = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ft, Symbol.hasInstance, {
    value: function(zt) {
      return Ot.call(this, zt) ? !0 : this !== Ft ? !1 : zt && zt._writableState instanceof Pt;
    }
  })) : Ot = function(zt) {
    return zt instanceof this;
  };
  function Ft(Xt) {
    Fe = Fe || dew$7$2();
    var zt = this instanceof Fe;
    if (!zt && !Ot.call(Ft, this))
      return new Ft(Xt);
    this._writableState = new Pt(Xt, this, zt), this.writable = !0, Xt && (typeof Xt.write == "function" && (this._write = Xt.write), typeof Xt.writev == "function" && (this._writev = Xt.writev), typeof Xt.destroy == "function" && (this._destroy = Xt.destroy), typeof Xt.final == "function" && (this._final = Xt.final)), Ve.call(this);
  }
  Ft.prototype.pipe = function() {
    Lt(this, new Et());
  };
  function gt(Xt, zt) {
    var Kt = new Ct();
    Lt(Xt, Kt), $e.nextTick(zt, Kt);
  }
  function We(Xt, zt, Kt, ur) {
    var er;
    return Kt === null ? er = new Rt() : typeof Kt != "string" && !zt.objectMode && (er = new vt("chunk", ["string", "Buffer"], Kt)), er ? (Lt(Xt, er), $e.nextTick(ur, er), !1) : !0;
  }
  Ft.prototype.write = function(Xt, zt, Kt) {
    var ur = this._writableState, er = !1, Dt = !ur.objectMode && ut(Xt);
    return Dt && !Je.isBuffer(Xt) && (Xt = at(Xt)), typeof zt == "function" && (Kt = zt, zt = null), Dt ? zt = "buffer" : zt || (zt = ur.defaultEncoding), typeof Kt != "function" && (Kt = Ut), ur.ending ? gt(this, Kt) : (Dt || We(this, ur, Xt, Kt)) && (ur.pendingcb++, er = rt(this, ur, Dt, Xt, zt, Kt)), er;
  }, Ft.prototype.cork = function() {
    this._writableState.corked++;
  }, Ft.prototype.uncork = function() {
    var Xt = this._writableState;
    Xt.corked && (Xt.corked--, !Xt.writing && !Xt.corked && !Xt.bufferProcessing && Xt.bufferedRequest && ct(this, Xt));
  }, Ft.prototype.setDefaultEncoding = function(zt) {
    if (typeof zt == "string" && (zt = zt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((zt + "").toLowerCase()) > -1))
      throw new Zt(zt);
    return this._writableState.defaultEncoding = zt, this;
  }, Object.defineProperty(Ft.prototype, "writableBuffer", {
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function Xe(Xt, zt, Kt) {
    return !Xt.objectMode && Xt.decodeStrings !== !1 && typeof zt == "string" && (zt = Je.from(zt, Kt)), zt;
  }
  Object.defineProperty(Ft.prototype, "writableHighWaterMark", {
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function rt(Xt, zt, Kt, ur, er, Dt) {
    if (!Kt) {
      var Ht = Xe(zt, ur, er);
      ur !== Ht && (Kt = !0, er = "buffer", ur = Ht);
    }
    var Gt = zt.objectMode ? 1 : ur.length;
    zt.length += Gt;
    var rr = zt.length < zt.highWaterMark;
    if (rr || (zt.needDrain = !0), zt.writing || zt.corked) {
      var sr = zt.lastBufferedRequest;
      zt.lastBufferedRequest = {
        chunk: ur,
        encoding: er,
        isBuf: Kt,
        callback: Dt,
        next: null
      }, sr ? sr.next = zt.lastBufferedRequest : zt.bufferedRequest = zt.lastBufferedRequest, zt.bufferedRequestCount += 1;
    } else
      ot(Xt, zt, !1, Gt, ur, er, Dt);
    return rr;
  }
  function ot(Xt, zt, Kt, ur, er, Dt, Ht) {
    zt.writelen = ur, zt.writecb = Ht, zt.writing = !0, zt.sync = !0, zt.destroyed ? zt.onwrite(new Tt("write")) : Kt ? Xt._writev(er, zt.onwrite) : Xt._write(er, Dt, zt.onwrite), zt.sync = !1;
  }
  function ft(Xt, zt, Kt, ur, er) {
    --zt.pendingcb, Kt ? ($e.nextTick(er, ur), $e.nextTick(Nt, Xt, zt), Xt._writableState.errorEmitted = !0, Lt(Xt, ur)) : (er(ur), Xt._writableState.errorEmitted = !0, Lt(Xt, ur), Nt(Xt, zt));
  }
  function mt(Xt) {
    Xt.writing = !1, Xt.writecb = null, Xt.length -= Xt.writelen, Xt.writelen = 0;
  }
  function yt(Xt, zt) {
    var Kt = Xt._writableState, ur = Kt.sync, er = Kt.writecb;
    if (typeof er != "function")
      throw new xt();
    if (mt(Kt), zt)
      ft(Xt, Kt, ur, zt, er);
    else {
      var Dt = Mt(Kt) || Xt.destroyed;
      !Dt && !Kt.corked && !Kt.bufferProcessing && Kt.bufferedRequest && ct(Xt, Kt), ur ? $e.nextTick(pt, Xt, Kt, Dt, er) : pt(Xt, Kt, Dt, er);
    }
  }
  function pt(Xt, zt, Kt, ur) {
    Kt || Ge(Xt, zt), zt.pendingcb--, ur(), Nt(Xt, zt);
  }
  function Ge(Xt, zt) {
    zt.length === 0 && zt.needDrain && (zt.needDrain = !1, Xt.emit("drain"));
  }
  function ct(Xt, zt) {
    zt.bufferProcessing = !0;
    var Kt = zt.bufferedRequest;
    if (Xt._writev && Kt && Kt.next) {
      var ur = zt.bufferedRequestCount, er = new Array(ur), Dt = zt.corkedRequestsFree;
      Dt.entry = Kt;
      for (var Ht = 0, Gt = !0; Kt; )
        er[Ht] = Kt, Kt.isBuf || (Gt = !1), Kt = Kt.next, Ht += 1;
      er.allBuffers = Gt, ot(Xt, zt, !0, zt.length, er, "", Dt.finish), zt.pendingcb++, zt.lastBufferedRequest = null, Dt.next ? (zt.corkedRequestsFree = Dt.next, Dt.next = null) : zt.corkedRequestsFree = new Ze(zt), zt.bufferedRequestCount = 0;
    } else {
      for (; Kt; ) {
        var rr = Kt.chunk, sr = Kt.encoding, Jt = Kt.callback, ir = zt.objectMode ? 1 : rr.length;
        if (ot(Xt, zt, !1, ir, rr, sr, Jt), Kt = Kt.next, zt.bufferedRequestCount--, zt.writing)
          break;
      }
      Kt === null && (zt.lastBufferedRequest = null);
    }
    zt.bufferedRequest = Kt, zt.bufferProcessing = !1;
  }
  Ft.prototype._write = function(Xt, zt, Kt) {
    Kt(new wt("_write()"));
  }, Ft.prototype._writev = null, Ft.prototype.end = function(Xt, zt, Kt) {
    var ur = this._writableState;
    return typeof Xt == "function" ? (Kt = Xt, Xt = null, zt = null) : typeof zt == "function" && (Kt = zt, zt = null), Xt != null && this.write(Xt, zt), ur.corked && (ur.corked = 1, this.uncork()), ur.ending || qt(this, ur, Kt), this;
  }, Object.defineProperty(Ft.prototype, "writableLength", {
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function Mt(Xt) {
    return Xt.ending && Xt.length === 0 && Xt.bufferedRequest === null && !Xt.finished && !Xt.writing;
  }
  function St(Xt, zt) {
    Xt._final(function(Kt) {
      zt.pendingcb--, Kt && Lt(Xt, Kt), zt.prefinished = !0, Xt.emit("prefinish"), Nt(Xt, zt);
    });
  }
  function At(Xt, zt) {
    !zt.prefinished && !zt.finalCalled && (typeof Xt._final == "function" && !zt.destroyed ? (zt.pendingcb++, zt.finalCalled = !0, $e.nextTick(St, Xt, zt)) : (zt.prefinished = !0, Xt.emit("prefinish")));
  }
  function Nt(Xt, zt) {
    var Kt = Mt(zt);
    if (Kt && (At(Xt, zt), zt.pendingcb === 0 && (zt.finished = !0, Xt.emit("finish"), zt.autoDestroy))) {
      var ur = Xt._readableState;
      (!ur || ur.autoDestroy && ur.endEmitted) && Xt.destroy();
    }
    return Kt;
  }
  function qt(Xt, zt, Kt) {
    zt.ending = !0, Nt(Xt, zt), Kt && (zt.finished ? $e.nextTick(Kt) : Xt.once("finish", Kt)), zt.ended = !0, Xt.writable = !1;
  }
  function Qt(Xt, zt, Kt) {
    var ur = Xt.entry;
    for (Xt.entry = null; ur; ) {
      var er = ur.callback;
      zt.pendingcb--, er(Kt), ur = ur.next;
    }
    zt.corkedRequestsFree.next = Xt;
  }
  return Object.defineProperty(Ft.prototype, "destroyed", {
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(zt) {
      this._writableState && (this._writableState.destroyed = zt);
    }
  }), Ft.prototype.destroy = lt.destroy, Ft.prototype._undestroy = lt.undestroy, Ft.prototype._destroy = function(Xt, zt) {
    zt(Xt);
  }, exports$8$2;
}
var exports$7$2 = {}, _dewExec$7$2 = !1;
function dew$7$2() {
  if (_dewExec$7$2)
    return exports$7$2;
  _dewExec$7$2 = !0;
  var $e = T, Ze = Object.keys || function(dt) {
    var bt = [];
    for (var $t in dt)
      bt.push($t);
    return bt;
  };
  exports$7$2 = at;
  var Fe = dew$3$2(), Ke = dew$8$2();
  dew$f$2()(at, Fe);
  for (var Ve = Ze(Ke.prototype), Je = 0; Je < Ve.length; Je++) {
    var Qe = Ve[Je];
    at.prototype[Qe] || (at.prototype[Qe] = Ke.prototype[Qe]);
  }
  function at(dt) {
    if (!(this instanceof at))
      return new at(dt);
    Fe.call(this, dt), Ke.call(this, dt), this.allowHalfOpen = !0, dt && (dt.readable === !1 && (this.readable = !1), dt.writable === !1 && (this.writable = !1), dt.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", ut)));
  }
  Object.defineProperty(at.prototype, "writableHighWaterMark", {
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(at.prototype, "writableBuffer", {
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(at.prototype, "writableLength", {
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ut() {
    this._writableState.ended || $e.nextTick(lt, this);
  }
  function lt(dt) {
    dt.end();
  }
  return Object.defineProperty(at.prototype, "destroyed", {
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(bt) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = bt, this._writableState.destroyed = bt);
    }
  }), exports$7$2;
}
var exports$6$2 = {}, _dewExec$6$2 = !1;
function dew$6$2() {
  if (_dewExec$6$2)
    return exports$6$2;
  _dewExec$6$2 = !0;
  var $e = dew$b$2().codes.ERR_STREAM_PREMATURE_CLOSE;
  function Ze(Je) {
    var Qe = !1;
    return function() {
      if (!Qe) {
        Qe = !0;
        for (var at = arguments.length, ut = new Array(at), lt = 0; lt < at; lt++)
          ut[lt] = arguments[lt];
        Je.apply(this, ut);
      }
    };
  }
  function Fe() {
  }
  function Ke(Je) {
    return Je.setHeader && typeof Je.abort == "function";
  }
  function Ve(Je, Qe, at) {
    if (typeof Qe == "function")
      return Ve(Je, null, Qe);
    Qe || (Qe = {}), at = Ze(at || Fe);
    var ut = Qe.readable || Qe.readable !== !1 && Je.readable, lt = Qe.writable || Qe.writable !== !1 && Je.writable, dt = function() {
      Je.writable || $t();
    }, bt = Je._writableState && Je._writableState.finished, $t = function() {
      lt = !1, bt = !0, ut || at.call(Je);
    }, vt = Je._readableState && Je._readableState.endEmitted, wt = function() {
      ut = !1, vt = !0, lt || at.call(Je);
    }, xt = function(Ct) {
      at.call(Je, Ct);
    }, Et = function() {
      var Ct;
      if (ut && !vt)
        return (!Je._readableState || !Je._readableState.ended) && (Ct = new $e()), at.call(Je, Ct);
      if (lt && !bt)
        return (!Je._writableState || !Je._writableState.ended) && (Ct = new $e()), at.call(Je, Ct);
    }, Tt = function() {
      Je.req.on("finish", $t);
    };
    return Ke(Je) ? (Je.on("complete", $t), Je.on("abort", Et), Je.req ? Tt() : Je.on("request", Tt)) : lt && !Je._writableState && (Je.on("end", dt), Je.on("close", dt)), Je.on("end", wt), Je.on("finish", $t), Qe.error !== !1 && Je.on("error", xt), Je.on("close", Et), function() {
      Je.removeListener("complete", $t), Je.removeListener("abort", Et), Je.removeListener("request", Tt), Je.req && Je.req.removeListener("finish", $t), Je.removeListener("end", dt), Je.removeListener("close", dt), Je.removeListener("finish", $t), Je.removeListener("end", wt), Je.removeListener("error", xt), Je.removeListener("close", Et);
    };
  }
  return exports$6$2 = Ve, exports$6$2;
}
var exports$5$2 = {}, _dewExec$5$2 = !1;
function dew$5$2() {
  if (_dewExec$5$2)
    return exports$5$2;
  _dewExec$5$2 = !0;
  var $e = T, Ze;
  function Fe(Rt, Ct, Zt) {
    return Ct in Rt ? Object.defineProperty(Rt, Ct, {
      value: Zt,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : Rt[Ct] = Zt, Rt;
  }
  var Ke = dew$6$2(), Ve = Symbol("lastResolve"), Je = Symbol("lastReject"), Qe = Symbol("error"), at = Symbol("ended"), ut = Symbol("lastPromise"), lt = Symbol("handlePromise"), dt = Symbol("stream");
  function bt(Rt, Ct) {
    return {
      value: Rt,
      done: Ct
    };
  }
  function $t(Rt) {
    var Ct = Rt[Ve];
    if (Ct !== null) {
      var Zt = Rt[dt].read();
      Zt !== null && (Rt[ut] = null, Rt[Ve] = null, Rt[Je] = null, Ct(bt(Zt, !1)));
    }
  }
  function vt(Rt) {
    $e.nextTick($t, Rt);
  }
  function wt(Rt, Ct) {
    return function(Zt, Lt) {
      Rt.then(function() {
        if (Ct[at]) {
          Zt(bt(void 0, !0));
          return;
        }
        Ct[lt](Zt, Lt);
      }, Lt);
    };
  }
  var xt = Object.getPrototypeOf(function() {
  }), Et = Object.setPrototypeOf((Ze = {
    get stream() {
      return this[dt];
    },
    next: function() {
      var Ct = this, Zt = this[Qe];
      if (Zt !== null)
        return Promise.reject(Zt);
      if (this[at])
        return Promise.resolve(bt(void 0, !0));
      if (this[dt].destroyed)
        return new Promise(function(Ot, Ft) {
          $e.nextTick(function() {
            Ct[Qe] ? Ft(Ct[Qe]) : Ot(bt(void 0, !0));
          });
        });
      var Lt = this[ut], Ut;
      if (Lt)
        Ut = new Promise(wt(Lt, this));
      else {
        var Pt = this[dt].read();
        if (Pt !== null)
          return Promise.resolve(bt(Pt, !1));
        Ut = new Promise(this[lt]);
      }
      return this[ut] = Ut, Ut;
    }
  }, Fe(Ze, Symbol.asyncIterator, function() {
    return this;
  }), Fe(Ze, "return", function() {
    var Ct = this;
    return new Promise(function(Zt, Lt) {
      Ct[dt].destroy(null, function(Ut) {
        if (Ut) {
          Lt(Ut);
          return;
        }
        Zt(bt(void 0, !0));
      });
    });
  }), Ze), xt), Tt = function(Ct) {
    var Zt, Lt = Object.create(Et, (Zt = {}, Fe(Zt, dt, {
      value: Ct,
      writable: !0
    }), Fe(Zt, Ve, {
      value: null,
      writable: !0
    }), Fe(Zt, Je, {
      value: null,
      writable: !0
    }), Fe(Zt, Qe, {
      value: null,
      writable: !0
    }), Fe(Zt, at, {
      value: Ct._readableState.endEmitted,
      writable: !0
    }), Fe(Zt, lt, {
      value: function(Pt, Ot) {
        var Ft = Lt[dt].read();
        Ft ? (Lt[ut] = null, Lt[Ve] = null, Lt[Je] = null, Pt(bt(Ft, !1))) : (Lt[Ve] = Pt, Lt[Je] = Ot);
      },
      writable: !0
    }), Zt));
    return Lt[ut] = null, Ke(Ct, function(Ut) {
      if (Ut && Ut.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Pt = Lt[Je];
        Pt !== null && (Lt[ut] = null, Lt[Ve] = null, Lt[Je] = null, Pt(Ut)), Lt[Qe] = Ut;
        return;
      }
      var Ot = Lt[Ve];
      Ot !== null && (Lt[ut] = null, Lt[Ve] = null, Lt[Je] = null, Ot(bt(void 0, !0))), Lt[at] = !0;
    }), Ct.on("readable", vt.bind(null, Lt)), Lt;
  };
  return exports$5$2 = Tt, exports$5$2;
}
var exports$4$2 = {}, _dewExec$4$2 = !1;
function dew$4$2() {
  return _dewExec$4$2 || (_dewExec$4$2 = !0, exports$4$2 = function() {
    throw new Error("Readable.from is not available in the browser");
  }), exports$4$2;
}
var exports$3$2 = {}, _dewExec$3$2 = !1, _global$M = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$3$2() {
  if (_dewExec$3$2)
    return exports$3$2;
  _dewExec$3$2 = !0;
  var $e = T;
  exports$3$2 = gt;
  var Ze;
  gt.ReadableState = Ft, y.EventEmitter;
  var Fe = function(Ht, Gt) {
    return Ht.listeners(Gt).length;
  }, Ke = dew$e$2(), Ve = e$1$1$1.Buffer, Je = _global$M.Uint8Array || function() {
  };
  function Qe(Dt) {
    return Ve.from(Dt);
  }
  function at(Dt) {
    return Ve.isBuffer(Dt) || Dt instanceof Je;
  }
  var ut = X, lt;
  ut && ut.debuglog ? lt = ut.debuglog("stream") : lt = function() {
  };
  var dt = dew$d$2(), bt = dew$c$2(), $t = dew$a$2(), vt = $t.getHighWaterMark, wt = dew$b$2().codes, xt = wt.ERR_INVALID_ARG_TYPE, Et = wt.ERR_STREAM_PUSH_AFTER_EOF, Tt = wt.ERR_METHOD_NOT_IMPLEMENTED, Rt = wt.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Ct, Zt, Lt;
  dew$f$2()(gt, Ke);
  var Ut = bt.errorOrDestroy, Pt = ["error", "close", "destroy", "pause", "resume"];
  function Ot(Dt, Ht, Gt) {
    if (typeof Dt.prependListener == "function")
      return Dt.prependListener(Ht, Gt);
    !Dt._events || !Dt._events[Ht] ? Dt.on(Ht, Gt) : Array.isArray(Dt._events[Ht]) ? Dt._events[Ht].unshift(Gt) : Dt._events[Ht] = [Gt, Dt._events[Ht]];
  }
  function Ft(Dt, Ht, Gt) {
    Ze = Ze || dew$7$2(), Dt = Dt || {}, typeof Gt != "boolean" && (Gt = Ht instanceof Ze), this.objectMode = !!Dt.objectMode, Gt && (this.objectMode = this.objectMode || !!Dt.readableObjectMode), this.highWaterMark = vt(this, Dt, "readableHighWaterMark", Gt), this.buffer = new dt(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Dt.emitClose !== !1, this.autoDestroy = !!Dt.autoDestroy, this.destroyed = !1, this.defaultEncoding = Dt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Dt.encoding && (Ct || (Ct = e$12.StringDecoder), this.decoder = new Ct(Dt.encoding), this.encoding = Dt.encoding);
  }
  function gt(Dt) {
    if (Ze = Ze || dew$7$2(), !(this instanceof gt))
      return new gt(Dt);
    var Ht = this instanceof Ze;
    this._readableState = new Ft(Dt, this, Ht), this.readable = !0, Dt && (typeof Dt.read == "function" && (this._read = Dt.read), typeof Dt.destroy == "function" && (this._destroy = Dt.destroy)), Ke.call(this);
  }
  Object.defineProperty(gt.prototype, "destroyed", {
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Ht) {
      this._readableState && (this._readableState.destroyed = Ht);
    }
  }), gt.prototype.destroy = bt.destroy, gt.prototype._undestroy = bt.undestroy, gt.prototype._destroy = function(Dt, Ht) {
    Ht(Dt);
  }, gt.prototype.push = function(Dt, Ht) {
    var Gt = this._readableState, rr;
    return Gt.objectMode ? rr = !0 : typeof Dt == "string" && (Ht = Ht || Gt.defaultEncoding, Ht !== Gt.encoding && (Dt = Ve.from(Dt, Ht), Ht = ""), rr = !0), We(this, Dt, Ht, !1, rr);
  }, gt.prototype.unshift = function(Dt) {
    return We(this, Dt, null, !0, !1);
  };
  function We(Dt, Ht, Gt, rr, sr) {
    lt("readableAddChunk", Ht);
    var Jt = Dt._readableState;
    if (Ht === null)
      Jt.reading = !1, yt(Dt, Jt);
    else {
      var ir;
      if (sr || (ir = rt(Jt, Ht)), ir)
        Ut(Dt, ir);
      else if (Jt.objectMode || Ht && Ht.length > 0)
        if (typeof Ht != "string" && !Jt.objectMode && Object.getPrototypeOf(Ht) !== Ve.prototype && (Ht = Qe(Ht)), rr)
          Jt.endEmitted ? Ut(Dt, new Rt()) : Xe(Dt, Jt, Ht, !0);
        else if (Jt.ended)
          Ut(Dt, new Et());
        else {
          if (Jt.destroyed)
            return !1;
          Jt.reading = !1, Jt.decoder && !Gt ? (Ht = Jt.decoder.write(Ht), Jt.objectMode || Ht.length !== 0 ? Xe(Dt, Jt, Ht, !1) : ct(Dt, Jt)) : Xe(Dt, Jt, Ht, !1);
        }
      else
        rr || (Jt.reading = !1, ct(Dt, Jt));
    }
    return !Jt.ended && (Jt.length < Jt.highWaterMark || Jt.length === 0);
  }
  function Xe(Dt, Ht, Gt, rr) {
    Ht.flowing && Ht.length === 0 && !Ht.sync ? (Ht.awaitDrain = 0, Dt.emit("data", Gt)) : (Ht.length += Ht.objectMode ? 1 : Gt.length, rr ? Ht.buffer.unshift(Gt) : Ht.buffer.push(Gt), Ht.needReadable && pt(Dt)), ct(Dt, Ht);
  }
  function rt(Dt, Ht) {
    var Gt;
    return !at(Ht) && typeof Ht != "string" && Ht !== void 0 && !Dt.objectMode && (Gt = new xt("chunk", ["string", "Buffer", "Uint8Array"], Ht)), Gt;
  }
  gt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, gt.prototype.setEncoding = function(Dt) {
    Ct || (Ct = e$12.StringDecoder);
    var Ht = new Ct(Dt);
    this._readableState.decoder = Ht, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Gt = this._readableState.buffer.head, rr = ""; Gt !== null; )
      rr += Ht.write(Gt.data), Gt = Gt.next;
    return this._readableState.buffer.clear(), rr !== "" && this._readableState.buffer.push(rr), this._readableState.length = rr.length, this;
  };
  var ot = 1073741824;
  function ft(Dt) {
    return Dt >= ot ? Dt = ot : (Dt--, Dt |= Dt >>> 1, Dt |= Dt >>> 2, Dt |= Dt >>> 4, Dt |= Dt >>> 8, Dt |= Dt >>> 16, Dt++), Dt;
  }
  function mt(Dt, Ht) {
    return Dt <= 0 || Ht.length === 0 && Ht.ended ? 0 : Ht.objectMode ? 1 : Dt !== Dt ? Ht.flowing && Ht.length ? Ht.buffer.head.data.length : Ht.length : (Dt > Ht.highWaterMark && (Ht.highWaterMark = ft(Dt)), Dt <= Ht.length ? Dt : Ht.ended ? Ht.length : (Ht.needReadable = !0, 0));
  }
  gt.prototype.read = function(Dt) {
    lt("read", Dt), Dt = parseInt(Dt, 10);
    var Ht = this._readableState, Gt = Dt;
    if (Dt !== 0 && (Ht.emittedReadable = !1), Dt === 0 && Ht.needReadable && ((Ht.highWaterMark !== 0 ? Ht.length >= Ht.highWaterMark : Ht.length > 0) || Ht.ended))
      return lt("read: emitReadable", Ht.length, Ht.ended), Ht.length === 0 && Ht.ended ? Kt(this) : pt(this), null;
    if (Dt = mt(Dt, Ht), Dt === 0 && Ht.ended)
      return Ht.length === 0 && Kt(this), null;
    var rr = Ht.needReadable;
    lt("need readable", rr), (Ht.length === 0 || Ht.length - Dt < Ht.highWaterMark) && (rr = !0, lt("length less than watermark", rr)), Ht.ended || Ht.reading ? (rr = !1, lt("reading or ended", rr)) : rr && (lt("do read"), Ht.reading = !0, Ht.sync = !0, Ht.length === 0 && (Ht.needReadable = !0), this._read(Ht.highWaterMark), Ht.sync = !1, Ht.reading || (Dt = mt(Gt, Ht)));
    var sr;
    return Dt > 0 ? sr = zt(Dt, Ht) : sr = null, sr === null ? (Ht.needReadable = Ht.length <= Ht.highWaterMark, Dt = 0) : (Ht.length -= Dt, Ht.awaitDrain = 0), Ht.length === 0 && (Ht.ended || (Ht.needReadable = !0), Gt !== Dt && Ht.ended && Kt(this)), sr !== null && this.emit("data", sr), sr;
  };
  function yt(Dt, Ht) {
    if (lt("onEofChunk"), !Ht.ended) {
      if (Ht.decoder) {
        var Gt = Ht.decoder.end();
        Gt && Gt.length && (Ht.buffer.push(Gt), Ht.length += Ht.objectMode ? 1 : Gt.length);
      }
      Ht.ended = !0, Ht.sync ? pt(Dt) : (Ht.needReadable = !1, Ht.emittedReadable || (Ht.emittedReadable = !0, Ge(Dt)));
    }
  }
  function pt(Dt) {
    var Ht = Dt._readableState;
    lt("emitReadable", Ht.needReadable, Ht.emittedReadable), Ht.needReadable = !1, Ht.emittedReadable || (lt("emitReadable", Ht.flowing), Ht.emittedReadable = !0, $e.nextTick(Ge, Dt));
  }
  function Ge(Dt) {
    var Ht = Dt._readableState;
    lt("emitReadable_", Ht.destroyed, Ht.length, Ht.ended), !Ht.destroyed && (Ht.length || Ht.ended) && (Dt.emit("readable"), Ht.emittedReadable = !1), Ht.needReadable = !Ht.flowing && !Ht.ended && Ht.length <= Ht.highWaterMark, Xt(Dt);
  }
  function ct(Dt, Ht) {
    Ht.readingMore || (Ht.readingMore = !0, $e.nextTick(Mt, Dt, Ht));
  }
  function Mt(Dt, Ht) {
    for (; !Ht.reading && !Ht.ended && (Ht.length < Ht.highWaterMark || Ht.flowing && Ht.length === 0); ) {
      var Gt = Ht.length;
      if (lt("maybeReadMore read 0"), Dt.read(0), Gt === Ht.length)
        break;
    }
    Ht.readingMore = !1;
  }
  gt.prototype._read = function(Dt) {
    Ut(this, new Tt("_read()"));
  }, gt.prototype.pipe = function(Dt, Ht) {
    var Gt = this, rr = this._readableState;
    switch (rr.pipesCount) {
      case 0:
        rr.pipes = Dt;
        break;
      case 1:
        rr.pipes = [rr.pipes, Dt];
        break;
      default:
        rr.pipes.push(Dt);
        break;
    }
    rr.pipesCount += 1, lt("pipe count=%d opts=%j", rr.pipesCount, Ht);
    var sr = (!Ht || Ht.end !== !1) && Dt !== $e.stdout && Dt !== $e.stderr, Jt = sr ? Br : kt;
    rr.endEmitted ? $e.nextTick(Jt) : Gt.once("end", Jt), Dt.on("unpipe", ir);
    function ir(It, jt) {
      lt("onunpipe"), It === Gt && jt && jt.hasUnpiped === !1 && (jt.hasUnpiped = !0, Nr());
    }
    function Br() {
      lt("onend"), Dt.end();
    }
    var or = St(Gt);
    Dt.on("drain", or);
    var lr = !1;
    function Nr() {
      lt("cleanup"), Dt.removeListener("close", Zr), Dt.removeListener("finish", Bt), Dt.removeListener("drain", or), Dt.removeListener("error", gr), Dt.removeListener("unpipe", ir), Gt.removeListener("end", Br), Gt.removeListener("end", kt), Gt.removeListener("data", dr), lr = !0, rr.awaitDrain && (!Dt._writableState || Dt._writableState.needDrain) && or();
    }
    Gt.on("data", dr);
    function dr(It) {
      lt("ondata");
      var jt = Dt.write(It);
      lt("dest.write", jt), jt === !1 && ((rr.pipesCount === 1 && rr.pipes === Dt || rr.pipesCount > 1 && er(rr.pipes, Dt) !== -1) && !lr && (lt("false write response, pause", rr.awaitDrain), rr.awaitDrain++), Gt.pause());
    }
    function gr(It) {
      lt("onerror", It), kt(), Dt.removeListener("error", gr), Fe(Dt, "error") === 0 && Ut(Dt, It);
    }
    Ot(Dt, "error", gr);
    function Zr() {
      Dt.removeListener("finish", Bt), kt();
    }
    Dt.once("close", Zr);
    function Bt() {
      lt("onfinish"), Dt.removeListener("close", Zr), kt();
    }
    Dt.once("finish", Bt);
    function kt() {
      lt("unpipe"), Gt.unpipe(Dt);
    }
    return Dt.emit("pipe", Gt), rr.flowing || (lt("pipe resume"), Gt.resume()), Dt;
  };
  function St(Dt) {
    return function() {
      var Gt = Dt._readableState;
      lt("pipeOnDrain", Gt.awaitDrain), Gt.awaitDrain && Gt.awaitDrain--, Gt.awaitDrain === 0 && Fe(Dt, "data") && (Gt.flowing = !0, Xt(Dt));
    };
  }
  gt.prototype.unpipe = function(Dt) {
    var Ht = this._readableState, Gt = {
      hasUnpiped: !1
    };
    if (Ht.pipesCount === 0)
      return this;
    if (Ht.pipesCount === 1)
      return Dt && Dt !== Ht.pipes ? this : (Dt || (Dt = Ht.pipes), Ht.pipes = null, Ht.pipesCount = 0, Ht.flowing = !1, Dt && Dt.emit("unpipe", this, Gt), this);
    if (!Dt) {
      var rr = Ht.pipes, sr = Ht.pipesCount;
      Ht.pipes = null, Ht.pipesCount = 0, Ht.flowing = !1;
      for (var Jt = 0; Jt < sr; Jt++)
        rr[Jt].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var ir = er(Ht.pipes, Dt);
    return ir === -1 ? this : (Ht.pipes.splice(ir, 1), Ht.pipesCount -= 1, Ht.pipesCount === 1 && (Ht.pipes = Ht.pipes[0]), Dt.emit("unpipe", this, Gt), this);
  }, gt.prototype.on = function(Dt, Ht) {
    var Gt = Ke.prototype.on.call(this, Dt, Ht), rr = this._readableState;
    return Dt === "data" ? (rr.readableListening = this.listenerCount("readable") > 0, rr.flowing !== !1 && this.resume()) : Dt === "readable" && !rr.endEmitted && !rr.readableListening && (rr.readableListening = rr.needReadable = !0, rr.flowing = !1, rr.emittedReadable = !1, lt("on readable", rr.length, rr.reading), rr.length ? pt(this) : rr.reading || $e.nextTick(Nt, this)), Gt;
  }, gt.prototype.addListener = gt.prototype.on, gt.prototype.removeListener = function(Dt, Ht) {
    var Gt = Ke.prototype.removeListener.call(this, Dt, Ht);
    return Dt === "readable" && $e.nextTick(At, this), Gt;
  }, gt.prototype.removeAllListeners = function(Dt) {
    var Ht = Ke.prototype.removeAllListeners.apply(this, arguments);
    return (Dt === "readable" || Dt === void 0) && $e.nextTick(At, this), Ht;
  };
  function At(Dt) {
    var Ht = Dt._readableState;
    Ht.readableListening = Dt.listenerCount("readable") > 0, Ht.resumeScheduled && !Ht.paused ? Ht.flowing = !0 : Dt.listenerCount("data") > 0 && Dt.resume();
  }
  function Nt(Dt) {
    lt("readable nexttick read 0"), Dt.read(0);
  }
  gt.prototype.resume = function() {
    var Dt = this._readableState;
    return Dt.flowing || (lt("resume"), Dt.flowing = !Dt.readableListening, qt(this, Dt)), Dt.paused = !1, this;
  };
  function qt(Dt, Ht) {
    Ht.resumeScheduled || (Ht.resumeScheduled = !0, $e.nextTick(Qt, Dt, Ht));
  }
  function Qt(Dt, Ht) {
    lt("resume", Ht.reading), Ht.reading || Dt.read(0), Ht.resumeScheduled = !1, Dt.emit("resume"), Xt(Dt), Ht.flowing && !Ht.reading && Dt.read(0);
  }
  gt.prototype.pause = function() {
    return lt("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (lt("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Xt(Dt) {
    var Ht = Dt._readableState;
    for (lt("flow", Ht.flowing); Ht.flowing && Dt.read() !== null; )
      ;
  }
  gt.prototype.wrap = function(Dt) {
    var Ht = this, Gt = this._readableState, rr = !1;
    Dt.on("end", function() {
      if (lt("wrapped end"), Gt.decoder && !Gt.ended) {
        var ir = Gt.decoder.end();
        ir && ir.length && Ht.push(ir);
      }
      Ht.push(null);
    }), Dt.on("data", function(ir) {
      if (lt("wrapped data"), Gt.decoder && (ir = Gt.decoder.write(ir)), !(Gt.objectMode && ir == null) && !(!Gt.objectMode && (!ir || !ir.length))) {
        var Br = Ht.push(ir);
        Br || (rr = !0, Dt.pause());
      }
    });
    for (var sr in Dt)
      this[sr] === void 0 && typeof Dt[sr] == "function" && (this[sr] = function(Br) {
        return function() {
          return Dt[Br].apply(Dt, arguments);
        };
      }(sr));
    for (var Jt = 0; Jt < Pt.length; Jt++)
      Dt.on(Pt[Jt], this.emit.bind(this, Pt[Jt]));
    return this._read = function(ir) {
      lt("wrapped _read", ir), rr && (rr = !1, Dt.resume());
    }, this;
  }, typeof Symbol == "function" && (gt.prototype[Symbol.asyncIterator] = function() {
    return Zt === void 0 && (Zt = dew$5$2()), Zt(this);
  }), Object.defineProperty(gt.prototype, "readableHighWaterMark", {
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(gt.prototype, "readableBuffer", {
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(gt.prototype, "readableFlowing", {
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Ht) {
      this._readableState && (this._readableState.flowing = Ht);
    }
  }), gt._fromList = zt, Object.defineProperty(gt.prototype, "readableLength", {
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function zt(Dt, Ht) {
    if (Ht.length === 0)
      return null;
    var Gt;
    return Ht.objectMode ? Gt = Ht.buffer.shift() : !Dt || Dt >= Ht.length ? (Ht.decoder ? Gt = Ht.buffer.join("") : Ht.buffer.length === 1 ? Gt = Ht.buffer.first() : Gt = Ht.buffer.concat(Ht.length), Ht.buffer.clear()) : Gt = Ht.buffer.consume(Dt, Ht.decoder), Gt;
  }
  function Kt(Dt) {
    var Ht = Dt._readableState;
    lt("endReadable", Ht.endEmitted), Ht.endEmitted || (Ht.ended = !0, $e.nextTick(ur, Ht, Dt));
  }
  function ur(Dt, Ht) {
    if (lt("endReadableNT", Dt.endEmitted, Dt.length), !Dt.endEmitted && Dt.length === 0 && (Dt.endEmitted = !0, Ht.readable = !1, Ht.emit("end"), Dt.autoDestroy)) {
      var Gt = Ht._writableState;
      (!Gt || Gt.autoDestroy && Gt.finished) && Ht.destroy();
    }
  }
  typeof Symbol == "function" && (gt.from = function(Dt, Ht) {
    return Lt === void 0 && (Lt = dew$4$2()), Lt(gt, Dt, Ht);
  });
  function er(Dt, Ht) {
    for (var Gt = 0, rr = Dt.length; Gt < rr; Gt++)
      if (Dt[Gt] === Ht)
        return Gt;
    return -1;
  }
  return exports$3$2;
}
var exports$2$2 = {}, _dewExec$2$2 = !1;
function dew$2$2() {
  if (_dewExec$2$2)
    return exports$2$2;
  _dewExec$2$2 = !0, exports$2$2 = at;
  var $e = dew$b$2().codes, Ze = $e.ERR_METHOD_NOT_IMPLEMENTED, Fe = $e.ERR_MULTIPLE_CALLBACK, Ke = $e.ERR_TRANSFORM_ALREADY_TRANSFORMING, Ve = $e.ERR_TRANSFORM_WITH_LENGTH_0, Je = dew$7$2();
  dew$f$2()(at, Je);
  function Qe(dt, bt) {
    var $t = this._transformState;
    $t.transforming = !1;
    var vt = $t.writecb;
    if (vt === null)
      return this.emit("error", new Fe());
    $t.writechunk = null, $t.writecb = null, bt != null && this.push(bt), vt(dt);
    var wt = this._readableState;
    wt.reading = !1, (wt.needReadable || wt.length < wt.highWaterMark) && this._read(wt.highWaterMark);
  }
  function at(dt) {
    if (!(this instanceof at))
      return new at(dt);
    Je.call(this, dt), this._transformState = {
      afterTransform: Qe.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, dt && (typeof dt.transform == "function" && (this._transform = dt.transform), typeof dt.flush == "function" && (this._flush = dt.flush)), this.on("prefinish", ut);
  }
  function ut() {
    var dt = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(bt, $t) {
      lt(dt, bt, $t);
    }) : lt(this, null, null);
  }
  at.prototype.push = function(dt, bt) {
    return this._transformState.needTransform = !1, Je.prototype.push.call(this, dt, bt);
  }, at.prototype._transform = function(dt, bt, $t) {
    $t(new Ze("_transform()"));
  }, at.prototype._write = function(dt, bt, $t) {
    var vt = this._transformState;
    if (vt.writecb = $t, vt.writechunk = dt, vt.writeencoding = bt, !vt.transforming) {
      var wt = this._readableState;
      (vt.needTransform || wt.needReadable || wt.length < wt.highWaterMark) && this._read(wt.highWaterMark);
    }
  }, at.prototype._read = function(dt) {
    var bt = this._transformState;
    bt.writechunk !== null && !bt.transforming ? (bt.transforming = !0, this._transform(bt.writechunk, bt.writeencoding, bt.afterTransform)) : bt.needTransform = !0;
  }, at.prototype._destroy = function(dt, bt) {
    Je.prototype._destroy.call(this, dt, function($t) {
      bt($t);
    });
  };
  function lt(dt, bt, $t) {
    if (bt)
      return dt.emit("error", bt);
    if ($t != null && dt.push($t), dt._writableState.length)
      throw new Ve();
    if (dt._transformState.transforming)
      throw new Ke();
    return dt.push(null);
  }
  return exports$2$2;
}
var exports$1$2 = {}, _dewExec$1$2 = !1;
function dew$1$2() {
  if (_dewExec$1$2)
    return exports$1$2;
  _dewExec$1$2 = !0, exports$1$2 = Ze;
  var $e = dew$2$2();
  dew$f$2()(Ze, $e);
  function Ze(Fe) {
    if (!(this instanceof Ze))
      return new Ze(Fe);
    $e.call(this, Fe);
  }
  return Ze.prototype._transform = function(Fe, Ke, Ve) {
    Ve(null, Fe);
  }, exports$1$2;
}
var exports$2C = {}, _dewExec$2B = !1;
function dew$2B() {
  if (_dewExec$2B)
    return exports$2C;
  _dewExec$2B = !0;
  var $e;
  function Ze($t) {
    var vt = !1;
    return function() {
      vt || (vt = !0, $t.apply(void 0, arguments));
    };
  }
  var Fe = dew$b$2().codes, Ke = Fe.ERR_MISSING_ARGS, Ve = Fe.ERR_STREAM_DESTROYED;
  function Je($t) {
    if ($t)
      throw $t;
  }
  function Qe($t) {
    return $t.setHeader && typeof $t.abort == "function";
  }
  function at($t, vt, wt, xt) {
    xt = Ze(xt);
    var Et = !1;
    $t.on("close", function() {
      Et = !0;
    }), $e === void 0 && ($e = dew$6$2()), $e($t, {
      readable: vt,
      writable: wt
    }, function(Rt) {
      if (Rt)
        return xt(Rt);
      Et = !0, xt();
    });
    var Tt = !1;
    return function(Rt) {
      if (!Et && !Tt) {
        if (Tt = !0, Qe($t))
          return $t.abort();
        if (typeof $t.destroy == "function")
          return $t.destroy();
        xt(Rt || new Ve("pipe"));
      }
    };
  }
  function ut($t) {
    $t();
  }
  function lt($t, vt) {
    return $t.pipe(vt);
  }
  function dt($t) {
    return !$t.length || typeof $t[$t.length - 1] != "function" ? Je : $t.pop();
  }
  function bt() {
    for (var $t = arguments.length, vt = new Array($t), wt = 0; wt < $t; wt++)
      vt[wt] = arguments[wt];
    var xt = dt(vt);
    if (Array.isArray(vt[0]) && (vt = vt[0]), vt.length < 2)
      throw new Ke("streams");
    var Et, Tt = vt.map(function(Rt, Ct) {
      var Zt = Ct < vt.length - 1, Lt = Ct > 0;
      return at(Rt, Zt, Lt, function(Ut) {
        Et || (Et = Ut), Ut && Tt.forEach(ut), !Zt && (Tt.forEach(ut), xt(Et));
      });
    });
    return vt.reduce(lt);
  }
  return exports$2C = bt, exports$2C;
}
var exports$2B = {}, _dewExec$2A = !1, _global$L = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$2A() {
  if (_dewExec$2A)
    return exports$2B;
  _dewExec$2A = !0, exports$2B = Fe;
  var $e = y.EventEmitter, Ze = dew$f$2();
  Ze(Fe, $e), Fe.Readable = dew$3$2(), Fe.Writable = dew$8$2(), Fe.Duplex = dew$7$2(), Fe.Transform = dew$2$2(), Fe.PassThrough = dew$1$2(), Fe.finished = dew$6$2(), Fe.pipeline = dew$2B(), Fe.Stream = Fe;
  function Fe() {
    $e.call(this || _global$L);
  }
  return Fe.prototype.pipe = function(Ke, Ve) {
    var Je = this || _global$L;
    function Qe(vt) {
      Ke.writable && Ke.write(vt) === !1 && Je.pause && Je.pause();
    }
    Je.on("data", Qe);
    function at() {
      Je.readable && Je.resume && Je.resume();
    }
    Ke.on("drain", at), !Ke._isStdio && (!Ve || Ve.end !== !1) && (Je.on("end", lt), Je.on("close", dt));
    var ut = !1;
    function lt() {
      ut || (ut = !0, Ke.end());
    }
    function dt() {
      ut || (ut = !0, typeof Ke.destroy == "function" && Ke.destroy());
    }
    function bt(vt) {
      if ($t(), $e.listenerCount(this || _global$L, "error") === 0)
        throw vt;
    }
    Je.on("error", bt), Ke.on("error", bt);
    function $t() {
      Je.removeListener("data", Qe), Ke.removeListener("drain", at), Je.removeListener("end", lt), Je.removeListener("close", dt), Je.removeListener("error", bt), Ke.removeListener("error", bt), Je.removeListener("end", $t), Je.removeListener("close", $t), Ke.removeListener("close", $t);
    }
    return Je.on("end", $t), Je.on("close", $t), Ke.on("close", $t), Ke.emit("pipe", Je), Ke;
  }, exports$2B;
}
var stream = dew$2A();
stream.Readable;
stream.Writable;
stream.Duplex;
stream.Transform;
stream.PassThrough;
stream.finished;
stream.pipeline;
stream.Stream;
promisify(stream.finished), promisify(stream.pipeline);
var exports$2A = {}, _dewExec$2z = !1, _global$K = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$2z() {
  if (_dewExec$2z)
    return exports$2A;
  _dewExec$2z = !0;
  var $e = dew$2P().Buffer, Ze = stream.Transform, Fe = e$12.StringDecoder, Ke = dew$f();
  function Ve(Je) {
    Ze.call(this || _global$K), (this || _global$K).hashMode = typeof Je == "string", (this || _global$K).hashMode ? (this || _global$K)[Je] = (this || _global$K)._finalOrDigest : (this || _global$K).final = (this || _global$K)._finalOrDigest, (this || _global$K)._final && ((this || _global$K).__final = (this || _global$K)._final, (this || _global$K)._final = null), (this || _global$K)._decoder = null, (this || _global$K)._encoding = null;
  }
  return Ke(Ve, Ze), Ve.prototype.update = function(Je, Qe, at) {
    typeof Je == "string" && (Je = $e.from(Je, Qe));
    var ut = this._update(Je);
    return (this || _global$K).hashMode ? this || _global$K : (at && (ut = this._toString(ut, at)), ut);
  }, Ve.prototype.setAutoPadding = function() {
  }, Ve.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, Ve.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, Ve.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, Ve.prototype._transform = function(Je, Qe, at) {
    var ut;
    try {
      (this || _global$K).hashMode ? this._update(Je) : this.push(this._update(Je));
    } catch (lt) {
      ut = lt;
    } finally {
      at(ut);
    }
  }, Ve.prototype._flush = function(Je) {
    var Qe;
    try {
      this.push(this.__final());
    } catch (at) {
      Qe = at;
    }
    Je(Qe);
  }, Ve.prototype._finalOrDigest = function(Je) {
    var Qe = this.__final() || $e.alloc(0);
    return Je && (Qe = this._toString(Qe, Je, !0)), Qe;
  }, Ve.prototype._toString = function(Je, Qe, at) {
    if ((this || _global$K)._decoder || ((this || _global$K)._decoder = new Fe(Qe), (this || _global$K)._encoding = Qe), (this || _global$K)._encoding !== Qe)
      throw new Error("can't switch encodings");
    var ut = (this || _global$K)._decoder.write(Je);
    return at && (ut += (this || _global$K)._decoder.end()), ut;
  }, exports$2A = Ve, exports$2A;
}
var exports$2z = {}, _dewExec$2y = !1;
function dew$2y() {
  if (_dewExec$2y)
    return exports$2z;
  _dewExec$2y = !0;
  var $e = dew$f(), Ze = dew$2L(), Fe = dew$2K(), Ke = dew$2C(), Ve = dew$2z();
  function Je(Qe) {
    Ve.call(this, "digest"), this._hash = Qe;
  }
  return $e(Je, Ve), Je.prototype._update = function(Qe) {
    this._hash.update(Qe);
  }, Je.prototype._final = function() {
    return this._hash.digest();
  }, exports$2z = function(at) {
    return at = at.toLowerCase(), at === "md5" ? new Ze() : at === "rmd160" || at === "ripemd160" ? new Fe() : new Je(Ke(at));
  }, exports$2z;
}
var exports$2y = {}, _dewExec$2x = !1;
function dew$2x() {
  if (_dewExec$2x)
    return exports$2y;
  _dewExec$2x = !0;
  var $e = dew$f(), Ze = dew$2P().Buffer, Fe = dew$2z(), Ke = Ze.alloc(128), Ve = 64;
  function Je(Qe, at) {
    Fe.call(this, "digest"), typeof at == "string" && (at = Ze.from(at)), this._alg = Qe, this._key = at, at.length > Ve ? at = Qe(at) : at.length < Ve && (at = Ze.concat([at, Ke], Ve));
    for (var ut = this._ipad = Ze.allocUnsafe(Ve), lt = this._opad = Ze.allocUnsafe(Ve), dt = 0; dt < Ve; dt++)
      ut[dt] = at[dt] ^ 54, lt[dt] = at[dt] ^ 92;
    this._hash = [ut];
  }
  return $e(Je, Fe), Je.prototype._update = function(Qe) {
    this._hash.push(Qe);
  }, Je.prototype._final = function() {
    var Qe = this._alg(Ze.concat(this._hash));
    return this._alg(Ze.concat([this._opad, Qe]));
  }, exports$2y = Je, exports$2y;
}
var exports$2x = {}, _dewExec$2w = !1;
function dew$2w() {
  if (_dewExec$2w)
    return exports$2x;
  _dewExec$2w = !0;
  var $e = dew$2L();
  return exports$2x = function(Ze) {
    return new $e().update(Ze).digest();
  }, exports$2x;
}
var exports$2w = {}, _dewExec$2v = !1;
function dew$2v() {
  if (_dewExec$2v)
    return exports$2w;
  _dewExec$2v = !0;
  var $e = dew$f(), Ze = dew$2x(), Fe = dew$2z(), Ke = dew$2P().Buffer, Ve = dew$2w(), Je = dew$2K(), Qe = dew$2C(), at = Ke.alloc(128);
  function ut(lt, dt) {
    Fe.call(this, "digest"), typeof dt == "string" && (dt = Ke.from(dt));
    var bt = lt === "sha512" || lt === "sha384" ? 128 : 64;
    if (this._alg = lt, this._key = dt, dt.length > bt) {
      var $t = lt === "rmd160" ? new Je() : Qe(lt);
      dt = $t.update(dt).digest();
    } else
      dt.length < bt && (dt = Ke.concat([dt, at], bt));
    for (var vt = this._ipad = Ke.allocUnsafe(bt), wt = this._opad = Ke.allocUnsafe(bt), xt = 0; xt < bt; xt++)
      vt[xt] = dt[xt] ^ 54, wt[xt] = dt[xt] ^ 92;
    this._hash = lt === "rmd160" ? new Je() : Qe(lt), this._hash.update(vt);
  }
  return $e(ut, Fe), ut.prototype._update = function(lt) {
    this._hash.update(lt);
  }, ut.prototype._final = function() {
    var lt = this._hash.digest(), dt = this._alg === "rmd160" ? new Je() : Qe(this._alg);
    return dt.update(this._opad).update(lt).digest();
  }, exports$2w = function(dt, bt) {
    return dt = dt.toLowerCase(), dt === "rmd160" || dt === "ripemd160" ? new ut("rmd160", bt) : dt === "md5" ? new Ze(Ve, bt) : new ut(dt, bt);
  }, exports$2w;
}
var _algorithms$1 = {
  sha224WithRSAEncryption: {
    sign: "rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption: {
    sign: "rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption: {
    sign: "rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption: {
    sign: "rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: {
    sign: "ecdsa",
    hash: "sha256",
    id: ""
  },
  sha224: {
    sign: "ecdsa",
    hash: "sha224",
    id: ""
  },
  sha384: {
    sign: "ecdsa",
    hash: "sha384",
    id: ""
  },
  sha512: {
    sign: "ecdsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA: {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA: {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption: {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  },
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
}, exports$2v = {}, _dewExec$2u = !1;
function dew$2u() {
  return _dewExec$2u || (_dewExec$2u = !0, exports$2v = _algorithms$1), exports$2v;
}
var exports$2u = {}, _dewExec$2t = !1;
function dew$2t() {
  if (_dewExec$2t)
    return exports$2u;
  _dewExec$2t = !0;
  var $e = Math.pow(2, 30) - 1;
  return exports$2u = function(Ze, Fe) {
    if (typeof Ze != "number")
      throw new TypeError("Iterations not a number");
    if (Ze < 0)
      throw new TypeError("Bad iterations");
    if (typeof Fe != "number")
      throw new TypeError("Key length not a number");
    if (Fe < 0 || Fe > $e || Fe !== Fe)
      throw new TypeError("Bad key length");
  }, exports$2u;
}
var exports$2t = {}, _dewExec$2s = !1, _global$J = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$2s() {
  if (_dewExec$2s)
    return exports$2t;
  _dewExec$2s = !0;
  var $e = process2, Ze;
  if (_global$J.process && _global$J.process.browser)
    Ze = "utf-8";
  else if (_global$J.process && _global$J.process.version) {
    var Fe = parseInt($e.version.split(".")[0].slice(1), 10);
    Ze = Fe >= 6 ? "utf-8" : "binary";
  } else
    Ze = "utf-8";
  return exports$2t = Ze, exports$2t;
}
var exports$2s = {}, _dewExec$2r = !1;
function dew$2r() {
  if (_dewExec$2r)
    return exports$2s;
  _dewExec$2r = !0;
  var $e = dew$2P().Buffer;
  return exports$2s = function(Ze, Fe, Ke) {
    if ($e.isBuffer(Ze))
      return Ze;
    if (typeof Ze == "string")
      return $e.from(Ze, Fe);
    if (ArrayBuffer.isView(Ze))
      return $e.from(Ze.buffer);
    throw new TypeError(Ke + " must be a string, a Buffer, a typed array or a DataView");
  }, exports$2s;
}
var exports$2r = {}, _dewExec$2q = !1, _global$I = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$2q() {
  if (_dewExec$2q)
    return exports$2r;
  _dewExec$2q = !0;
  var $e = dew$2w(), Ze = dew$2K(), Fe = dew$2C(), Ke = dew$2P().Buffer, Ve = dew$2t(), Je = dew$2s(), Qe = dew$2r(), at = Ke.alloc(128), ut = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function lt($t, vt, wt) {
    var xt = dt($t), Et = $t === "sha512" || $t === "sha384" ? 128 : 64;
    vt.length > Et ? vt = xt(vt) : vt.length < Et && (vt = Ke.concat([vt, at], Et));
    for (var Tt = Ke.allocUnsafe(Et + ut[$t]), Rt = Ke.allocUnsafe(Et + ut[$t]), Ct = 0; Ct < Et; Ct++)
      Tt[Ct] = vt[Ct] ^ 54, Rt[Ct] = vt[Ct] ^ 92;
    var Zt = Ke.allocUnsafe(Et + wt + 4);
    Tt.copy(Zt, 0, 0, Et), (this || _global$I).ipad1 = Zt, (this || _global$I).ipad2 = Tt, (this || _global$I).opad = Rt, (this || _global$I).alg = $t, (this || _global$I).blocksize = Et, (this || _global$I).hash = xt, (this || _global$I).size = ut[$t];
  }
  lt.prototype.run = function($t, vt) {
    $t.copy(vt, (this || _global$I).blocksize);
    var wt = this.hash(vt);
    return wt.copy((this || _global$I).opad, (this || _global$I).blocksize), this.hash((this || _global$I).opad);
  };
  function dt($t) {
    function vt(xt) {
      return Fe($t).update(xt).digest();
    }
    function wt(xt) {
      return new Ze().update(xt).digest();
    }
    return $t === "rmd160" || $t === "ripemd160" ? wt : $t === "md5" ? $e : vt;
  }
  function bt($t, vt, wt, xt, Et) {
    Ve(wt, xt), $t = Qe($t, Je, "Password"), vt = Qe(vt, Je, "Salt"), Et = Et || "sha1";
    var Tt = new lt(Et, $t, vt.length), Rt = Ke.allocUnsafe(xt), Ct = Ke.allocUnsafe(vt.length + 4);
    vt.copy(Ct, 0, 0, vt.length);
    for (var Zt = 0, Lt = ut[Et], Ut = Math.ceil(xt / Lt), Pt = 1; Pt <= Ut; Pt++) {
      Ct.writeUInt32BE(Pt, vt.length);
      for (var Ot = Tt.run(Ct, Tt.ipad1), Ft = Ot, gt = 1; gt < wt; gt++) {
        Ft = Tt.run(Ft, Tt.ipad2);
        for (var We = 0; We < Lt; We++)
          Ot[We] ^= Ft[We];
      }
      Ot.copy(Rt, Zt), Zt += Lt;
    }
    return Rt;
  }
  return exports$2r = bt, exports$2r;
}
var exports$2q = {}, _dewExec$2p = !1, _global$H = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$2p() {
  if (_dewExec$2p)
    return exports$2q;
  _dewExec$2p = !0;
  var $e = dew$2P().Buffer, Ze = dew$2t(), Fe = dew$2s(), Ke = dew$2q(), Ve = dew$2r(), Je, Qe = _global$H.crypto && _global$H.crypto.subtle, at = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, ut = [];
  function lt(wt) {
    if (_global$H.process && !_global$H.process.browser || !Qe || !Qe.importKey || !Qe.deriveBits)
      return Promise.resolve(!1);
    if (ut[wt] !== void 0)
      return ut[wt];
    Je = Je || $e.alloc(8);
    var xt = $t(Je, Je, 10, 128, wt).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return ut[wt] = xt, xt;
  }
  var dt;
  function bt() {
    return dt || (_global$H.process && _global$H.process.nextTick ? dt = _global$H.process.nextTick : _global$H.queueMicrotask ? dt = _global$H.queueMicrotask : _global$H.setImmediate ? dt = _global$H.setImmediate : dt = _global$H.setTimeout, dt);
  }
  function $t(wt, xt, Et, Tt, Rt) {
    return Qe.importKey("raw", wt, {
      name: "PBKDF2"
    }, !1, ["deriveBits"]).then(function(Ct) {
      return Qe.deriveBits({
        name: "PBKDF2",
        salt: xt,
        iterations: Et,
        hash: {
          name: Rt
        }
      }, Ct, Tt << 3);
    }).then(function(Ct) {
      return $e.from(Ct);
    });
  }
  function vt(wt, xt) {
    wt.then(function(Et) {
      bt()(function() {
        xt(null, Et);
      });
    }, function(Et) {
      bt()(function() {
        xt(Et);
      });
    });
  }
  return exports$2q = function(wt, xt, Et, Tt, Rt, Ct) {
    typeof Rt == "function" && (Ct = Rt, Rt = void 0), Rt = Rt || "sha1";
    var Zt = at[Rt.toLowerCase()];
    if (!Zt || typeof _global$H.Promise != "function") {
      bt()(function() {
        var Lt;
        try {
          Lt = Ke(wt, xt, Et, Tt, Rt);
        } catch (Ut) {
          return Ct(Ut);
        }
        Ct(null, Lt);
      });
      return;
    }
    if (Ze(Et, Tt), wt = Ve(wt, Fe, "Password"), xt = Ve(xt, Fe, "Salt"), typeof Ct != "function")
      throw new Error("No callback provided to pbkdf2");
    vt(lt(Zt).then(function(Lt) {
      return Lt ? $t(wt, xt, Et, Tt, Zt) : Ke(wt, xt, Et, Tt, Rt);
    }), Ct);
  }, exports$2q;
}
var exports$2p = {}, _dewExec$2o = !1;
function dew$2o() {
  return _dewExec$2o || (_dewExec$2o = !0, exports$2p.pbkdf2 = dew$2p(), exports$2p.pbkdf2Sync = dew$2q()), exports$2p;
}
var exports$2o = {}, _dewExec$2n = !1;
function dew$2n() {
  if (_dewExec$2n)
    return exports$2o;
  _dewExec$2n = !0, exports$2o.readUInt32BE = function(Ve, Je) {
    var Qe = Ve[0 + Je] << 24 | Ve[1 + Je] << 16 | Ve[2 + Je] << 8 | Ve[3 + Je];
    return Qe >>> 0;
  }, exports$2o.writeUInt32BE = function(Ve, Je, Qe) {
    Ve[0 + Qe] = Je >>> 24, Ve[1 + Qe] = Je >>> 16 & 255, Ve[2 + Qe] = Je >>> 8 & 255, Ve[3 + Qe] = Je & 255;
  }, exports$2o.ip = function(Ve, Je, Qe, at) {
    for (var ut = 0, lt = 0, dt = 6; dt >= 0; dt -= 2) {
      for (var bt = 0; bt <= 24; bt += 8)
        ut <<= 1, ut |= Je >>> bt + dt & 1;
      for (var bt = 0; bt <= 24; bt += 8)
        ut <<= 1, ut |= Ve >>> bt + dt & 1;
    }
    for (var dt = 6; dt >= 0; dt -= 2) {
      for (var bt = 1; bt <= 25; bt += 8)
        lt <<= 1, lt |= Je >>> bt + dt & 1;
      for (var bt = 1; bt <= 25; bt += 8)
        lt <<= 1, lt |= Ve >>> bt + dt & 1;
    }
    Qe[at + 0] = ut >>> 0, Qe[at + 1] = lt >>> 0;
  }, exports$2o.rip = function(Ve, Je, Qe, at) {
    for (var ut = 0, lt = 0, dt = 0; dt < 4; dt++)
      for (var bt = 24; bt >= 0; bt -= 8)
        ut <<= 1, ut |= Je >>> bt + dt & 1, ut <<= 1, ut |= Ve >>> bt + dt & 1;
    for (var dt = 4; dt < 8; dt++)
      for (var bt = 24; bt >= 0; bt -= 8)
        lt <<= 1, lt |= Je >>> bt + dt & 1, lt <<= 1, lt |= Ve >>> bt + dt & 1;
    Qe[at + 0] = ut >>> 0, Qe[at + 1] = lt >>> 0;
  }, exports$2o.pc1 = function(Ve, Je, Qe, at) {
    for (var ut = 0, lt = 0, dt = 7; dt >= 5; dt--) {
      for (var bt = 0; bt <= 24; bt += 8)
        ut <<= 1, ut |= Je >> bt + dt & 1;
      for (var bt = 0; bt <= 24; bt += 8)
        ut <<= 1, ut |= Ve >> bt + dt & 1;
    }
    for (var bt = 0; bt <= 24; bt += 8)
      ut <<= 1, ut |= Je >> bt + dt & 1;
    for (var dt = 1; dt <= 3; dt++) {
      for (var bt = 0; bt <= 24; bt += 8)
        lt <<= 1, lt |= Je >> bt + dt & 1;
      for (var bt = 0; bt <= 24; bt += 8)
        lt <<= 1, lt |= Ve >> bt + dt & 1;
    }
    for (var bt = 0; bt <= 24; bt += 8)
      lt <<= 1, lt |= Ve >> bt + dt & 1;
    Qe[at + 0] = ut >>> 0, Qe[at + 1] = lt >>> 0;
  }, exports$2o.r28shl = function(Ve, Je) {
    return Ve << Je & 268435455 | Ve >>> 28 - Je;
  };
  var $e = [
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  exports$2o.pc2 = function(Ve, Je, Qe, at) {
    for (var ut = 0, lt = 0, dt = $e.length >>> 1, bt = 0; bt < dt; bt++)
      ut <<= 1, ut |= Ve >>> $e[bt] & 1;
    for (var bt = dt; bt < $e.length; bt++)
      lt <<= 1, lt |= Je >>> $e[bt] & 1;
    Qe[at + 0] = ut >>> 0, Qe[at + 1] = lt >>> 0;
  }, exports$2o.expand = function(Ve, Je, Qe) {
    var at = 0, ut = 0;
    at = (Ve & 1) << 5 | Ve >>> 27;
    for (var lt = 23; lt >= 15; lt -= 4)
      at <<= 6, at |= Ve >>> lt & 63;
    for (var lt = 11; lt >= 3; lt -= 4)
      ut |= Ve >>> lt & 63, ut <<= 6;
    ut |= (Ve & 31) << 1 | Ve >>> 31, Je[Qe + 0] = at >>> 0, Je[Qe + 1] = ut >>> 0;
  };
  var Ze = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
  exports$2o.substitute = function(Ve, Je) {
    for (var Qe = 0, at = 0; at < 4; at++) {
      var ut = Ve >>> 18 - at * 6 & 63, lt = Ze[at * 64 + ut];
      Qe <<= 4, Qe |= lt;
    }
    for (var at = 0; at < 4; at++) {
      var ut = Je >>> 18 - at * 6 & 63, lt = Ze[4 * 64 + at * 64 + ut];
      Qe <<= 4, Qe |= lt;
    }
    return Qe >>> 0;
  };
  var Fe = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
  return exports$2o.permute = function(Ve) {
    for (var Je = 0, Qe = 0; Qe < Fe.length; Qe++)
      Je <<= 1, Je |= Ve >>> Fe[Qe] & 1;
    return Je >>> 0;
  }, exports$2o.padSplit = function(Ve, Je, Qe) {
    for (var at = Ve.toString(2); at.length < Je; )
      at = "0" + at;
    for (var ut = [], lt = 0; lt < Je; lt += Qe)
      ut.push(at.slice(lt, lt + Qe));
    return ut.join(" ");
  }, exports$2o;
}
var exports$2n = {}, _dewExec$2m = !1;
function dew$2m() {
  if (_dewExec$2m)
    return exports$2n;
  _dewExec$2m = !0, exports$2n = $e;
  function $e(Ze, Fe) {
    if (!Ze)
      throw new Error(Fe || "Assertion failed");
  }
  return $e.equal = function(Fe, Ke, Ve) {
    if (Fe != Ke)
      throw new Error(Ve || "Assertion failed: " + Fe + " != " + Ke);
  }, exports$2n;
}
var exports$2m = {}, _dewExec$2l = !1;
function dew$2l() {
  if (_dewExec$2l)
    return exports$2m;
  _dewExec$2l = !0;
  var $e = dew$2m();
  function Ze(Fe) {
    this.options = Fe, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
  }
  return exports$2m = Ze, Ze.prototype._init = function() {
  }, Ze.prototype.update = function(Ke) {
    return Ke.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(Ke) : this._updateEncrypt(Ke);
  }, Ze.prototype._buffer = function(Ke, Ve) {
    for (var Je = Math.min(this.buffer.length - this.bufferOff, Ke.length - Ve), Qe = 0; Qe < Je; Qe++)
      this.buffer[this.bufferOff + Qe] = Ke[Ve + Qe];
    return this.bufferOff += Je, Je;
  }, Ze.prototype._flushBuffer = function(Ke, Ve) {
    return this._update(this.buffer, 0, Ke, Ve), this.bufferOff = 0, this.blockSize;
  }, Ze.prototype._updateEncrypt = function(Ke) {
    var Ve = 0, Je = 0, Qe = (this.bufferOff + Ke.length) / this.blockSize | 0, at = new Array(Qe * this.blockSize);
    this.bufferOff !== 0 && (Ve += this._buffer(Ke, Ve), this.bufferOff === this.buffer.length && (Je += this._flushBuffer(at, Je)));
    for (var ut = Ke.length - (Ke.length - Ve) % this.blockSize; Ve < ut; Ve += this.blockSize)
      this._update(Ke, Ve, at, Je), Je += this.blockSize;
    for (; Ve < Ke.length; Ve++, this.bufferOff++)
      this.buffer[this.bufferOff] = Ke[Ve];
    return at;
  }, Ze.prototype._updateDecrypt = function(Ke) {
    for (var Ve = 0, Je = 0, Qe = Math.ceil((this.bufferOff + Ke.length) / this.blockSize) - 1, at = new Array(Qe * this.blockSize); Qe > 0; Qe--)
      Ve += this._buffer(Ke, Ve), Je += this._flushBuffer(at, Je);
    return Ve += this._buffer(Ke, Ve), at;
  }, Ze.prototype.final = function(Ke) {
    var Ve;
    Ke && (Ve = this.update(Ke));
    var Je;
    return this.type === "encrypt" ? Je = this._finalEncrypt() : Je = this._finalDecrypt(), Ve ? Ve.concat(Je) : Je;
  }, Ze.prototype._pad = function(Ke, Ve) {
    if (Ve === 0)
      return !1;
    for (; Ve < Ke.length; )
      Ke[Ve++] = 0;
    return !0;
  }, Ze.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var Ke = new Array(this.blockSize);
    return this._update(this.buffer, 0, Ke, 0), Ke;
  }, Ze.prototype._unpad = function(Ke) {
    return Ke;
  }, Ze.prototype._finalDecrypt = function() {
    $e.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var Ke = new Array(this.blockSize);
    return this._flushBuffer(Ke, 0), this._unpad(Ke);
  }, exports$2m;
}
var exports$2l = {}, _dewExec$2k = !1;
function dew$2k() {
  if (_dewExec$2k)
    return exports$2l;
  _dewExec$2k = !0;
  var $e = dew$2m(), Ze = dew$f(), Fe = dew$2n(), Ke = dew$2l();
  function Ve() {
    this.tmp = new Array(2), this.keys = null;
  }
  function Je(at) {
    Ke.call(this, at);
    var ut = new Ve();
    this._desState = ut, this.deriveKeys(ut, at.key);
  }
  Ze(Je, Ke), exports$2l = Je, Je.create = function(ut) {
    return new Je(ut);
  };
  var Qe = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
  return Je.prototype.deriveKeys = function(ut, lt) {
    ut.keys = new Array(16 * 2), $e.equal(lt.length, this.blockSize, "Invalid key length");
    var dt = Fe.readUInt32BE(lt, 0), bt = Fe.readUInt32BE(lt, 4);
    Fe.pc1(dt, bt, ut.tmp, 0), dt = ut.tmp[0], bt = ut.tmp[1];
    for (var $t = 0; $t < ut.keys.length; $t += 2) {
      var vt = Qe[$t >>> 1];
      dt = Fe.r28shl(dt, vt), bt = Fe.r28shl(bt, vt), Fe.pc2(dt, bt, ut.keys, $t);
    }
  }, Je.prototype._update = function(ut, lt, dt, bt) {
    var $t = this._desState, vt = Fe.readUInt32BE(ut, lt), wt = Fe.readUInt32BE(ut, lt + 4);
    Fe.ip(vt, wt, $t.tmp, 0), vt = $t.tmp[0], wt = $t.tmp[1], this.type === "encrypt" ? this._encrypt($t, vt, wt, $t.tmp, 0) : this._decrypt($t, vt, wt, $t.tmp, 0), vt = $t.tmp[0], wt = $t.tmp[1], Fe.writeUInt32BE(dt, vt, bt), Fe.writeUInt32BE(dt, wt, bt + 4);
  }, Je.prototype._pad = function(ut, lt) {
    for (var dt = ut.length - lt, bt = lt; bt < ut.length; bt++)
      ut[bt] = dt;
    return !0;
  }, Je.prototype._unpad = function(ut) {
    for (var lt = ut[ut.length - 1], dt = ut.length - lt; dt < ut.length; dt++)
      $e.equal(ut[dt], lt);
    return ut.slice(0, ut.length - lt);
  }, Je.prototype._encrypt = function(ut, lt, dt, bt, $t) {
    for (var vt = lt, wt = dt, xt = 0; xt < ut.keys.length; xt += 2) {
      var Et = ut.keys[xt], Tt = ut.keys[xt + 1];
      Fe.expand(wt, ut.tmp, 0), Et ^= ut.tmp[0], Tt ^= ut.tmp[1];
      var Rt = Fe.substitute(Et, Tt), Ct = Fe.permute(Rt), Zt = wt;
      wt = (vt ^ Ct) >>> 0, vt = Zt;
    }
    Fe.rip(wt, vt, bt, $t);
  }, Je.prototype._decrypt = function(ut, lt, dt, bt, $t) {
    for (var vt = dt, wt = lt, xt = ut.keys.length - 2; xt >= 0; xt -= 2) {
      var Et = ut.keys[xt], Tt = ut.keys[xt + 1];
      Fe.expand(vt, ut.tmp, 0), Et ^= ut.tmp[0], Tt ^= ut.tmp[1];
      var Rt = Fe.substitute(Et, Tt), Ct = Fe.permute(Rt), Zt = vt;
      vt = (wt ^ Ct) >>> 0, wt = Zt;
    }
    Fe.rip(vt, wt, bt, $t);
  }, exports$2l;
}
var exports$2k = {}, _dewExec$2j = !1;
function dew$2j() {
  if (_dewExec$2j)
    return exports$2k;
  _dewExec$2j = !0;
  var $e = dew$2m(), Ze = dew$f(), Fe = {};
  function Ke(Je) {
    $e.equal(Je.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var Qe = 0; Qe < this.iv.length; Qe++)
      this.iv[Qe] = Je[Qe];
  }
  function Ve(Je) {
    function Qe(dt) {
      Je.call(this, dt), this._cbcInit();
    }
    Ze(Qe, Je);
    for (var at = Object.keys(Fe), ut = 0; ut < at.length; ut++) {
      var lt = at[ut];
      Qe.prototype[lt] = Fe[lt];
    }
    return Qe.create = function(bt) {
      return new Qe(bt);
    }, Qe;
  }
  return exports$2k.instantiate = Ve, Fe._cbcInit = function() {
    var Qe = new Ke(this.options.iv);
    this._cbcState = Qe;
  }, Fe._update = function(Qe, at, ut, lt) {
    var dt = this._cbcState, bt = this.constructor.super_.prototype, $t = dt.iv;
    if (this.type === "encrypt") {
      for (var vt = 0; vt < this.blockSize; vt++)
        $t[vt] ^= Qe[at + vt];
      bt._update.call(this, $t, 0, ut, lt);
      for (var vt = 0; vt < this.blockSize; vt++)
        $t[vt] = ut[lt + vt];
    } else {
      bt._update.call(this, Qe, at, ut, lt);
      for (var vt = 0; vt < this.blockSize; vt++)
        ut[lt + vt] ^= $t[vt];
      for (var vt = 0; vt < this.blockSize; vt++)
        $t[vt] = Qe[at + vt];
    }
  }, exports$2k;
}
var exports$2j = {}, _dewExec$2i = !1;
function dew$2i() {
  if (_dewExec$2i)
    return exports$2j;
  _dewExec$2i = !0;
  var $e = dew$2m(), Ze = dew$f(), Fe = dew$2l(), Ke = dew$2k();
  function Ve(Qe, at) {
    $e.equal(at.length, 24, "Invalid key length");
    var ut = at.slice(0, 8), lt = at.slice(8, 16), dt = at.slice(16, 24);
    Qe === "encrypt" ? this.ciphers = [Ke.create({
      type: "encrypt",
      key: ut
    }), Ke.create({
      type: "decrypt",
      key: lt
    }), Ke.create({
      type: "encrypt",
      key: dt
    })] : this.ciphers = [Ke.create({
      type: "decrypt",
      key: dt
    }), Ke.create({
      type: "encrypt",
      key: lt
    }), Ke.create({
      type: "decrypt",
      key: ut
    })];
  }
  function Je(Qe) {
    Fe.call(this, Qe);
    var at = new Ve(this.type, this.options.key);
    this._edeState = at;
  }
  return Ze(Je, Fe), exports$2j = Je, Je.create = function(at) {
    return new Je(at);
  }, Je.prototype._update = function(at, ut, lt, dt) {
    var bt = this._edeState;
    bt.ciphers[0]._update(at, ut, lt, dt), bt.ciphers[1]._update(lt, dt, lt, dt), bt.ciphers[2]._update(lt, dt, lt, dt);
  }, Je.prototype._pad = Ke.prototype._pad, Je.prototype._unpad = Ke.prototype._unpad, exports$2j;
}
var exports$2i = {}, _dewExec$2h = !1;
function dew$2h() {
  return _dewExec$2h || (_dewExec$2h = !0, exports$2i.utils = dew$2n(), exports$2i.Cipher = dew$2l(), exports$2i.DES = dew$2k(), exports$2i.CBC = dew$2j(), exports$2i.EDE = dew$2i()), exports$2i;
}
var exports$2h = {}, _dewExec$2g = !1, _global$G = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$2g() {
  if (_dewExec$2g)
    return exports$2h;
  _dewExec$2g = !0;
  var $e = dew$2z(), Ze = dew$2h(), Fe = dew$f(), Ke = dew$2P().Buffer, Ve = {
    "des-ede3-cbc": Ze.CBC.instantiate(Ze.EDE),
    "des-ede3": Ze.EDE,
    "des-ede-cbc": Ze.CBC.instantiate(Ze.EDE),
    "des-ede": Ze.EDE,
    "des-cbc": Ze.CBC.instantiate(Ze.DES),
    "des-ecb": Ze.DES
  };
  Ve.des = Ve["des-cbc"], Ve.des3 = Ve["des-ede3-cbc"], exports$2h = Je, Fe(Je, $e);
  function Je(Qe) {
    $e.call(this || _global$G);
    var at = Qe.mode.toLowerCase(), ut = Ve[at], lt;
    Qe.decrypt ? lt = "decrypt" : lt = "encrypt";
    var dt = Qe.key;
    Ke.isBuffer(dt) || (dt = Ke.from(dt)), (at === "des-ede" || at === "des-ede-cbc") && (dt = Ke.concat([dt, dt.slice(0, 8)]));
    var bt = Qe.iv;
    Ke.isBuffer(bt) || (bt = Ke.from(bt)), (this || _global$G)._des = ut.create({
      key: dt,
      iv: bt,
      type: lt
    });
  }
  return Je.prototype._update = function(Qe) {
    return Ke.from((this || _global$G)._des.update(Qe));
  }, Je.prototype._final = function() {
    return Ke.from((this || _global$G)._des.final());
  }, exports$2h;
}
var exports$2g = {}, _dewExec$2f = !1;
function dew$2f() {
  return _dewExec$2f || (_dewExec$2f = !0, exports$2g.encrypt = function($e, Ze) {
    return $e._cipher.encryptBlock(Ze);
  }, exports$2g.decrypt = function($e, Ze) {
    return $e._cipher.decryptBlock(Ze);
  }), exports$2g;
}
var exports$2f = {}, _dewExec$2e = !1;
function dew$2e() {
  if (_dewExec$2e)
    return exports$2f;
  _dewExec$2e = !0;
  var $e = buffer.Buffer;
  return exports$2f = function(Fe, Ke) {
    for (var Ve = Math.min(Fe.length, Ke.length), Je = new $e(Ve), Qe = 0; Qe < Ve; ++Qe)
      Je[Qe] = Fe[Qe] ^ Ke[Qe];
    return Je;
  }, exports$2f;
}
var exports$2e = {}, _dewExec$2d = !1;
function dew$2d() {
  if (_dewExec$2d)
    return exports$2e;
  _dewExec$2d = !0;
  var $e = dew$2e();
  return exports$2e.encrypt = function(Ze, Fe) {
    var Ke = $e(Fe, Ze._prev);
    return Ze._prev = Ze._cipher.encryptBlock(Ke), Ze._prev;
  }, exports$2e.decrypt = function(Ze, Fe) {
    var Ke = Ze._prev;
    Ze._prev = Fe;
    var Ve = Ze._cipher.decryptBlock(Fe);
    return $e(Ve, Ke);
  }, exports$2e;
}
var exports$2d = {}, _dewExec$2c = !1;
function dew$2c() {
  if (_dewExec$2c)
    return exports$2d;
  _dewExec$2c = !0;
  var $e = dew$2P().Buffer, Ze = dew$2e();
  function Fe(Ke, Ve, Je) {
    var Qe = Ve.length, at = Ze(Ve, Ke._cache);
    return Ke._cache = Ke._cache.slice(Qe), Ke._prev = $e.concat([Ke._prev, Je ? Ve : at]), at;
  }
  return exports$2d.encrypt = function(Ke, Ve, Je) {
    for (var Qe = $e.allocUnsafe(0), at; Ve.length; )
      if (Ke._cache.length === 0 && (Ke._cache = Ke._cipher.encryptBlock(Ke._prev), Ke._prev = $e.allocUnsafe(0)), Ke._cache.length <= Ve.length)
        at = Ke._cache.length, Qe = $e.concat([Qe, Fe(Ke, Ve.slice(0, at), Je)]), Ve = Ve.slice(at);
      else {
        Qe = $e.concat([Qe, Fe(Ke, Ve, Je)]);
        break;
      }
    return Qe;
  }, exports$2d;
}
var exports$2c = {}, _dewExec$2b = !1;
function dew$2b() {
  if (_dewExec$2b)
    return exports$2c;
  _dewExec$2b = !0;
  var $e = dew$2P().Buffer;
  function Ze(Fe, Ke, Ve) {
    var Je = Fe._cipher.encryptBlock(Fe._prev), Qe = Je[0] ^ Ke;
    return Fe._prev = $e.concat([Fe._prev.slice(1), $e.from([Ve ? Ke : Qe])]), Qe;
  }
  return exports$2c.encrypt = function(Fe, Ke, Ve) {
    for (var Je = Ke.length, Qe = $e.allocUnsafe(Je), at = -1; ++at < Je; )
      Qe[at] = Ze(Fe, Ke[at], Ve);
    return Qe;
  }, exports$2c;
}
var exports$2b = {}, _dewExec$2a = !1;
function dew$2a() {
  if (_dewExec$2a)
    return exports$2b;
  _dewExec$2a = !0;
  var $e = dew$2P().Buffer;
  function Ze(Ke, Ve, Je) {
    for (var Qe, at = -1, ut = 8, lt = 0, dt, bt; ++at < ut; )
      Qe = Ke._cipher.encryptBlock(Ke._prev), dt = Ve & 1 << 7 - at ? 128 : 0, bt = Qe[0] ^ dt, lt += (bt & 128) >> at % 8, Ke._prev = Fe(Ke._prev, Je ? dt : bt);
    return lt;
  }
  function Fe(Ke, Ve) {
    var Je = Ke.length, Qe = -1, at = $e.allocUnsafe(Ke.length);
    for (Ke = $e.concat([Ke, $e.from([Ve])]); ++Qe < Je; )
      at[Qe] = Ke[Qe] << 1 | Ke[Qe + 1] >> 7;
    return at;
  }
  return exports$2b.encrypt = function(Ke, Ve, Je) {
    for (var Qe = Ve.length, at = $e.allocUnsafe(Qe), ut = -1; ++ut < Qe; )
      at[ut] = Ze(Ke, Ve[ut], Je);
    return at;
  }, exports$2b;
}
var exports$2a = {}, _dewExec$29 = !1;
function dew$29() {
  if (_dewExec$29)
    return exports$2a;
  _dewExec$29 = !0;
  var $e = buffer.Buffer, Ze = dew$2e();
  function Fe(Ke) {
    return Ke._prev = Ke._cipher.encryptBlock(Ke._prev), Ke._prev;
  }
  return exports$2a.encrypt = function(Ke, Ve) {
    for (; Ke._cache.length < Ve.length; )
      Ke._cache = $e.concat([Ke._cache, Fe(Ke)]);
    var Je = Ke._cache.slice(0, Ve.length);
    return Ke._cache = Ke._cache.slice(Ve.length), Ze(Ve, Je);
  }, exports$2a;
}
var exports$29 = {}, _dewExec$28 = !1;
function dew$28() {
  if (_dewExec$28)
    return exports$29;
  _dewExec$28 = !0;
  function $e(Ze) {
    for (var Fe = Ze.length, Ke; Fe--; )
      if (Ke = Ze.readUInt8(Fe), Ke === 255)
        Ze.writeUInt8(0, Fe);
      else {
        Ke++, Ze.writeUInt8(Ke, Fe);
        break;
      }
  }
  return exports$29 = $e, exports$29;
}
var exports$28 = {}, _dewExec$27 = !1;
function dew$27() {
  if (_dewExec$27)
    return exports$28;
  _dewExec$27 = !0;
  var $e = dew$2e(), Ze = dew$2P().Buffer, Fe = dew$28();
  function Ke(Je) {
    var Qe = Je._cipher.encryptBlockRaw(Je._prev);
    return Fe(Je._prev), Qe;
  }
  var Ve = 16;
  return exports$28.encrypt = function(Je, Qe) {
    var at = Math.ceil(Qe.length / Ve), ut = Je._cache.length;
    Je._cache = Ze.concat([Je._cache, Ze.allocUnsafe(at * Ve)]);
    for (var lt = 0; lt < at; lt++) {
      var dt = Ke(Je), bt = ut + lt * Ve;
      Je._cache.writeUInt32BE(dt[0], bt + 0), Je._cache.writeUInt32BE(dt[1], bt + 4), Je._cache.writeUInt32BE(dt[2], bt + 8), Je._cache.writeUInt32BE(dt[3], bt + 12);
    }
    var $t = Je._cache.slice(0, Qe.length);
    return Je._cache = Je._cache.slice(Qe.length), $e(Qe, $t);
  }, exports$28;
}
var _list$1 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128: {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes192: {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes256: {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
}, exports$27 = {}, _dewExec$26 = !1;
function dew$26() {
  if (_dewExec$26)
    return exports$27;
  _dewExec$26 = !0;
  var $e = {
    ECB: dew$2f(),
    CBC: dew$2d(),
    CFB: dew$2c(),
    CFB8: dew$2b(),
    CFB1: dew$2a(),
    OFB: dew$29(),
    CTR: dew$27(),
    GCM: dew$27()
  }, Ze = _list$1;
  for (var Fe in Ze)
    Ze[Fe].module = $e[Ze[Fe].mode];
  return exports$27 = Ze, exports$27;
}
var exports$26 = {}, _dewExec$25 = !1, _global$F = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$25() {
  if (_dewExec$25)
    return exports$26;
  _dewExec$25 = !0;
  var $e = dew$2P().Buffer;
  function Ze(at) {
    $e.isBuffer(at) || (at = $e.from(at));
    for (var ut = at.length / 4 | 0, lt = new Array(ut), dt = 0; dt < ut; dt++)
      lt[dt] = at.readUInt32BE(dt * 4);
    return lt;
  }
  function Fe(at) {
    for (var ut = 0; ut < at.length; at++)
      at[ut] = 0;
  }
  function Ke(at, ut, lt, dt, bt) {
    for (var $t = lt[0], vt = lt[1], wt = lt[2], xt = lt[3], Et = at[0] ^ ut[0], Tt = at[1] ^ ut[1], Rt = at[2] ^ ut[2], Ct = at[3] ^ ut[3], Zt, Lt, Ut, Pt, Ot = 4, Ft = 1; Ft < bt; Ft++)
      Zt = $t[Et >>> 24] ^ vt[Tt >>> 16 & 255] ^ wt[Rt >>> 8 & 255] ^ xt[Ct & 255] ^ ut[Ot++], Lt = $t[Tt >>> 24] ^ vt[Rt >>> 16 & 255] ^ wt[Ct >>> 8 & 255] ^ xt[Et & 255] ^ ut[Ot++], Ut = $t[Rt >>> 24] ^ vt[Ct >>> 16 & 255] ^ wt[Et >>> 8 & 255] ^ xt[Tt & 255] ^ ut[Ot++], Pt = $t[Ct >>> 24] ^ vt[Et >>> 16 & 255] ^ wt[Tt >>> 8 & 255] ^ xt[Rt & 255] ^ ut[Ot++], Et = Zt, Tt = Lt, Rt = Ut, Ct = Pt;
    return Zt = (dt[Et >>> 24] << 24 | dt[Tt >>> 16 & 255] << 16 | dt[Rt >>> 8 & 255] << 8 | dt[Ct & 255]) ^ ut[Ot++], Lt = (dt[Tt >>> 24] << 24 | dt[Rt >>> 16 & 255] << 16 | dt[Ct >>> 8 & 255] << 8 | dt[Et & 255]) ^ ut[Ot++], Ut = (dt[Rt >>> 24] << 24 | dt[Ct >>> 16 & 255] << 16 | dt[Et >>> 8 & 255] << 8 | dt[Tt & 255]) ^ ut[Ot++], Pt = (dt[Ct >>> 24] << 24 | dt[Et >>> 16 & 255] << 16 | dt[Tt >>> 8 & 255] << 8 | dt[Rt & 255]) ^ ut[Ot++], Zt = Zt >>> 0, Lt = Lt >>> 0, Ut = Ut >>> 0, Pt = Pt >>> 0, [Zt, Lt, Ut, Pt];
  }
  var Ve = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], Je = function() {
    for (var at = new Array(256), ut = 0; ut < 256; ut++)
      ut < 128 ? at[ut] = ut << 1 : at[ut] = ut << 1 ^ 283;
    for (var lt = [], dt = [], bt = [[], [], [], []], $t = [[], [], [], []], vt = 0, wt = 0, xt = 0; xt < 256; ++xt) {
      var Et = wt ^ wt << 1 ^ wt << 2 ^ wt << 3 ^ wt << 4;
      Et = Et >>> 8 ^ Et & 255 ^ 99, lt[vt] = Et, dt[Et] = vt;
      var Tt = at[vt], Rt = at[Tt], Ct = at[Rt], Zt = at[Et] * 257 ^ Et * 16843008;
      bt[0][vt] = Zt << 24 | Zt >>> 8, bt[1][vt] = Zt << 16 | Zt >>> 16, bt[2][vt] = Zt << 8 | Zt >>> 24, bt[3][vt] = Zt, Zt = Ct * 16843009 ^ Rt * 65537 ^ Tt * 257 ^ vt * 16843008, $t[0][Et] = Zt << 24 | Zt >>> 8, $t[1][Et] = Zt << 16 | Zt >>> 16, $t[2][Et] = Zt << 8 | Zt >>> 24, $t[3][Et] = Zt, vt === 0 ? vt = wt = 1 : (vt = Tt ^ at[at[at[Ct ^ Tt]]], wt ^= at[at[wt]]);
    }
    return {
      SBOX: lt,
      INV_SBOX: dt,
      SUB_MIX: bt,
      INV_SUB_MIX: $t
    };
  }();
  function Qe(at) {
    (this || _global$F)._key = Ze(at), this._reset();
  }
  return Qe.blockSize = 4 * 4, Qe.keySize = 256 / 8, Qe.prototype.blockSize = Qe.blockSize, Qe.prototype.keySize = Qe.keySize, Qe.prototype._reset = function() {
    for (var at = (this || _global$F)._key, ut = at.length, lt = ut + 6, dt = (lt + 1) * 4, bt = [], $t = 0; $t < ut; $t++)
      bt[$t] = at[$t];
    for ($t = ut; $t < dt; $t++) {
      var vt = bt[$t - 1];
      $t % ut === 0 ? (vt = vt << 8 | vt >>> 24, vt = Je.SBOX[vt >>> 24] << 24 | Je.SBOX[vt >>> 16 & 255] << 16 | Je.SBOX[vt >>> 8 & 255] << 8 | Je.SBOX[vt & 255], vt ^= Ve[$t / ut | 0] << 24) : ut > 6 && $t % ut === 4 && (vt = Je.SBOX[vt >>> 24] << 24 | Je.SBOX[vt >>> 16 & 255] << 16 | Je.SBOX[vt >>> 8 & 255] << 8 | Je.SBOX[vt & 255]), bt[$t] = bt[$t - ut] ^ vt;
    }
    for (var wt = [], xt = 0; xt < dt; xt++) {
      var Et = dt - xt, Tt = bt[Et - (xt % 4 ? 0 : 4)];
      xt < 4 || Et <= 4 ? wt[xt] = Tt : wt[xt] = Je.INV_SUB_MIX[0][Je.SBOX[Tt >>> 24]] ^ Je.INV_SUB_MIX[1][Je.SBOX[Tt >>> 16 & 255]] ^ Je.INV_SUB_MIX[2][Je.SBOX[Tt >>> 8 & 255]] ^ Je.INV_SUB_MIX[3][Je.SBOX[Tt & 255]];
    }
    (this || _global$F)._nRounds = lt, (this || _global$F)._keySchedule = bt, (this || _global$F)._invKeySchedule = wt;
  }, Qe.prototype.encryptBlockRaw = function(at) {
    return at = Ze(at), Ke(at, (this || _global$F)._keySchedule, Je.SUB_MIX, Je.SBOX, (this || _global$F)._nRounds);
  }, Qe.prototype.encryptBlock = function(at) {
    var ut = this.encryptBlockRaw(at), lt = $e.allocUnsafe(16);
    return lt.writeUInt32BE(ut[0], 0), lt.writeUInt32BE(ut[1], 4), lt.writeUInt32BE(ut[2], 8), lt.writeUInt32BE(ut[3], 12), lt;
  }, Qe.prototype.decryptBlock = function(at) {
    at = Ze(at);
    var ut = at[1];
    at[1] = at[3], at[3] = ut;
    var lt = Ke(at, (this || _global$F)._invKeySchedule, Je.INV_SUB_MIX, Je.INV_SBOX, (this || _global$F)._nRounds), dt = $e.allocUnsafe(16);
    return dt.writeUInt32BE(lt[0], 0), dt.writeUInt32BE(lt[3], 4), dt.writeUInt32BE(lt[2], 8), dt.writeUInt32BE(lt[1], 12), dt;
  }, Qe.prototype.scrub = function() {
    Fe((this || _global$F)._keySchedule), Fe((this || _global$F)._invKeySchedule), Fe((this || _global$F)._key);
  }, exports$26.AES = Qe, exports$26;
}
var exports$25 = {}, _dewExec$24 = !1, _global$E = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$24() {
  if (_dewExec$24)
    return exports$25;
  _dewExec$24 = !0;
  var $e = dew$2P().Buffer, Ze = $e.alloc(16, 0);
  function Fe(Je) {
    return [Je.readUInt32BE(0), Je.readUInt32BE(4), Je.readUInt32BE(8), Je.readUInt32BE(12)];
  }
  function Ke(Je) {
    var Qe = $e.allocUnsafe(16);
    return Qe.writeUInt32BE(Je[0] >>> 0, 0), Qe.writeUInt32BE(Je[1] >>> 0, 4), Qe.writeUInt32BE(Je[2] >>> 0, 8), Qe.writeUInt32BE(Je[3] >>> 0, 12), Qe;
  }
  function Ve(Je) {
    (this || _global$E).h = Je, (this || _global$E).state = $e.alloc(16, 0), (this || _global$E).cache = $e.allocUnsafe(0);
  }
  return Ve.prototype.ghash = function(Je) {
    for (var Qe = -1; ++Qe < Je.length; )
      (this || _global$E).state[Qe] ^= Je[Qe];
    this._multiply();
  }, Ve.prototype._multiply = function() {
    for (var Je = Fe((this || _global$E).h), Qe = [0, 0, 0, 0], at, ut, lt, dt = -1; ++dt < 128; ) {
      for (ut = ((this || _global$E).state[~~(dt / 8)] & 1 << 7 - dt % 8) !== 0, ut && (Qe[0] ^= Je[0], Qe[1] ^= Je[1], Qe[2] ^= Je[2], Qe[3] ^= Je[3]), lt = (Je[3] & 1) !== 0, at = 3; at > 0; at--)
        Je[at] = Je[at] >>> 1 | (Je[at - 1] & 1) << 31;
      Je[0] = Je[0] >>> 1, lt && (Je[0] = Je[0] ^ 225 << 24);
    }
    (this || _global$E).state = Ke(Qe);
  }, Ve.prototype.update = function(Je) {
    (this || _global$E).cache = $e.concat([(this || _global$E).cache, Je]);
    for (var Qe; (this || _global$E).cache.length >= 16; )
      Qe = (this || _global$E).cache.slice(0, 16), (this || _global$E).cache = (this || _global$E).cache.slice(16), this.ghash(Qe);
  }, Ve.prototype.final = function(Je, Qe) {
    return (this || _global$E).cache.length && this.ghash($e.concat([(this || _global$E).cache, Ze], 16)), this.ghash(Ke([0, Je, 0, Qe])), (this || _global$E).state;
  }, exports$25 = Ve, exports$25;
}
var exports$24 = {}, _dewExec$23 = !1, _global$D = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$23() {
  if (_dewExec$23)
    return exports$24;
  _dewExec$23 = !0;
  var $e = dew$25(), Ze = dew$2P().Buffer, Fe = dew$2z(), Ke = dew$f(), Ve = dew$24(), Je = dew$2e(), Qe = dew$28();
  function at(dt, bt) {
    var $t = 0;
    dt.length !== bt.length && $t++;
    for (var vt = Math.min(dt.length, bt.length), wt = 0; wt < vt; ++wt)
      $t += dt[wt] ^ bt[wt];
    return $t;
  }
  function ut(dt, bt, $t) {
    if (bt.length === 12)
      return dt._finID = Ze.concat([bt, Ze.from([0, 0, 0, 1])]), Ze.concat([bt, Ze.from([0, 0, 0, 2])]);
    var vt = new Ve($t), wt = bt.length, xt = wt % 16;
    vt.update(bt), xt && (xt = 16 - xt, vt.update(Ze.alloc(xt, 0))), vt.update(Ze.alloc(8, 0));
    var Et = wt * 8, Tt = Ze.alloc(8);
    Tt.writeUIntBE(Et, 0, 8), vt.update(Tt), dt._finID = vt.state;
    var Rt = Ze.from(dt._finID);
    return Qe(Rt), Rt;
  }
  function lt(dt, bt, $t, vt) {
    Fe.call(this || _global$D);
    var wt = Ze.alloc(4, 0);
    (this || _global$D)._cipher = new $e.AES(bt);
    var xt = (this || _global$D)._cipher.encryptBlock(wt);
    (this || _global$D)._ghash = new Ve(xt), $t = ut(this || _global$D, $t, xt), (this || _global$D)._prev = Ze.from($t), (this || _global$D)._cache = Ze.allocUnsafe(0), (this || _global$D)._secCache = Ze.allocUnsafe(0), (this || _global$D)._decrypt = vt, (this || _global$D)._alen = 0, (this || _global$D)._len = 0, (this || _global$D)._mode = dt, (this || _global$D)._authTag = null, (this || _global$D)._called = !1;
  }
  return Ke(lt, Fe), lt.prototype._update = function(dt) {
    if (!(this || _global$D)._called && (this || _global$D)._alen) {
      var bt = 16 - (this || _global$D)._alen % 16;
      bt < 16 && (bt = Ze.alloc(bt, 0), (this || _global$D)._ghash.update(bt));
    }
    (this || _global$D)._called = !0;
    var $t = (this || _global$D)._mode.encrypt(this || _global$D, dt);
    return (this || _global$D)._decrypt ? (this || _global$D)._ghash.update(dt) : (this || _global$D)._ghash.update($t), (this || _global$D)._len += dt.length, $t;
  }, lt.prototype._final = function() {
    if ((this || _global$D)._decrypt && !(this || _global$D)._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var dt = Je((this || _global$D)._ghash.final((this || _global$D)._alen * 8, (this || _global$D)._len * 8), (this || _global$D)._cipher.encryptBlock((this || _global$D)._finID));
    if ((this || _global$D)._decrypt && at(dt, (this || _global$D)._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    (this || _global$D)._authTag = dt, (this || _global$D)._cipher.scrub();
  }, lt.prototype.getAuthTag = function() {
    if ((this || _global$D)._decrypt || !Ze.isBuffer((this || _global$D)._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return (this || _global$D)._authTag;
  }, lt.prototype.setAuthTag = function(bt) {
    if (!(this || _global$D)._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    (this || _global$D)._authTag = bt;
  }, lt.prototype.setAAD = function(bt) {
    if ((this || _global$D)._called)
      throw new Error("Attempting to set AAD in unsupported state");
    (this || _global$D)._ghash.update(bt), (this || _global$D)._alen += bt.length;
  }, exports$24 = lt, exports$24;
}
var exports$23 = {}, _dewExec$222 = !1, _global$C = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$222() {
  if (_dewExec$222)
    return exports$23;
  _dewExec$222 = !0;
  var $e = dew$25(), Ze = dew$2P().Buffer, Fe = dew$2z(), Ke = dew$f();
  function Ve(Je, Qe, at, ut) {
    Fe.call(this || _global$C), (this || _global$C)._cipher = new $e.AES(Qe), (this || _global$C)._prev = Ze.from(at), (this || _global$C)._cache = Ze.allocUnsafe(0), (this || _global$C)._secCache = Ze.allocUnsafe(0), (this || _global$C)._decrypt = ut, (this || _global$C)._mode = Je;
  }
  return Ke(Ve, Fe), Ve.prototype._update = function(Je) {
    return (this || _global$C)._mode.encrypt(this || _global$C, Je, (this || _global$C)._decrypt);
  }, Ve.prototype._final = function() {
    (this || _global$C)._cipher.scrub();
  }, exports$23 = Ve, exports$23;
}
var exports$222 = {}, _dewExec$21 = !1;
function dew$21() {
  if (_dewExec$21)
    return exports$222;
  _dewExec$21 = !0;
  var $e = dew$2P().Buffer, Ze = dew$2L();
  function Fe(Ke, Ve, Je, Qe) {
    if ($e.isBuffer(Ke) || (Ke = $e.from(Ke, "binary")), Ve && ($e.isBuffer(Ve) || (Ve = $e.from(Ve, "binary")), Ve.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var at = Je / 8, ut = $e.alloc(at), lt = $e.alloc(Qe || 0), dt = $e.alloc(0); at > 0 || Qe > 0; ) {
      var bt = new Ze();
      bt.update(dt), bt.update(Ke), Ve && bt.update(Ve), dt = bt.digest();
      var $t = 0;
      if (at > 0) {
        var vt = ut.length - at;
        $t = Math.min(at, dt.length), dt.copy(ut, vt, 0, $t), at -= $t;
      }
      if ($t < dt.length && Qe > 0) {
        var wt = lt.length - Qe, xt = Math.min(Qe, dt.length - $t);
        dt.copy(lt, wt, $t, $t + xt), Qe -= xt;
      }
    }
    return dt.fill(0), {
      key: ut,
      iv: lt
    };
  }
  return exports$222 = Fe, exports$222;
}
var exports$21 = {}, _dewExec$20 = !1, _global$B = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$20() {
  if (_dewExec$20)
    return exports$21;
  _dewExec$20 = !0;
  var $e = dew$26(), Ze = dew$23(), Fe = dew$2P().Buffer, Ke = dew$222(), Ve = dew$2z(), Je = dew$25(), Qe = dew$21(), at = dew$f();
  function ut(vt, wt, xt) {
    Ve.call(this || _global$B), (this || _global$B)._cache = new dt(), (this || _global$B)._cipher = new Je.AES(wt), (this || _global$B)._prev = Fe.from(xt), (this || _global$B)._mode = vt, (this || _global$B)._autopadding = !0;
  }
  at(ut, Ve), ut.prototype._update = function(vt) {
    (this || _global$B)._cache.add(vt);
    for (var wt, xt, Et = []; wt = (this || _global$B)._cache.get(); )
      xt = (this || _global$B)._mode.encrypt(this || _global$B, wt), Et.push(xt);
    return Fe.concat(Et);
  };
  var lt = Fe.alloc(16, 16);
  ut.prototype._final = function() {
    var vt = (this || _global$B)._cache.flush();
    if ((this || _global$B)._autopadding)
      return vt = (this || _global$B)._mode.encrypt(this || _global$B, vt), (this || _global$B)._cipher.scrub(), vt;
    if (!vt.equals(lt))
      throw (this || _global$B)._cipher.scrub(), new Error("data not multiple of block length");
  }, ut.prototype.setAutoPadding = function(vt) {
    return (this || _global$B)._autopadding = !!vt, this || _global$B;
  };
  function dt() {
    (this || _global$B).cache = Fe.allocUnsafe(0);
  }
  dt.prototype.add = function(vt) {
    (this || _global$B).cache = Fe.concat([(this || _global$B).cache, vt]);
  }, dt.prototype.get = function() {
    if ((this || _global$B).cache.length > 15) {
      var vt = (this || _global$B).cache.slice(0, 16);
      return (this || _global$B).cache = (this || _global$B).cache.slice(16), vt;
    }
    return null;
  }, dt.prototype.flush = function() {
    for (var vt = 16 - (this || _global$B).cache.length, wt = Fe.allocUnsafe(vt), xt = -1; ++xt < vt; )
      wt.writeUInt8(vt, xt);
    return Fe.concat([(this || _global$B).cache, wt]);
  };
  function bt(vt, wt, xt) {
    var Et = $e[vt.toLowerCase()];
    if (!Et)
      throw new TypeError("invalid suite type");
    if (typeof wt == "string" && (wt = Fe.from(wt)), wt.length !== Et.key / 8)
      throw new TypeError("invalid key length " + wt.length);
    if (typeof xt == "string" && (xt = Fe.from(xt)), Et.mode !== "GCM" && xt.length !== Et.iv)
      throw new TypeError("invalid iv length " + xt.length);
    return Et.type === "stream" ? new Ke(Et.module, wt, xt) : Et.type === "auth" ? new Ze(Et.module, wt, xt) : new ut(Et.module, wt, xt);
  }
  function $t(vt, wt) {
    var xt = $e[vt.toLowerCase()];
    if (!xt)
      throw new TypeError("invalid suite type");
    var Et = Qe(wt, !1, xt.key, xt.iv);
    return bt(vt, Et.key, Et.iv);
  }
  return exports$21.createCipheriv = bt, exports$21.createCipher = $t, exports$21;
}
var exports$20 = {}, _dewExec$1$ = !1, _global$A = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1$() {
  if (_dewExec$1$)
    return exports$20;
  _dewExec$1$ = !0;
  var $e = dew$23(), Ze = dew$2P().Buffer, Fe = dew$26(), Ke = dew$222(), Ve = dew$2z(), Je = dew$25(), Qe = dew$21(), at = dew$f();
  function ut(vt, wt, xt) {
    Ve.call(this || _global$A), (this || _global$A)._cache = new lt(), (this || _global$A)._last = void 0, (this || _global$A)._cipher = new Je.AES(wt), (this || _global$A)._prev = Ze.from(xt), (this || _global$A)._mode = vt, (this || _global$A)._autopadding = !0;
  }
  at(ut, Ve), ut.prototype._update = function(vt) {
    (this || _global$A)._cache.add(vt);
    for (var wt, xt, Et = []; wt = (this || _global$A)._cache.get((this || _global$A)._autopadding); )
      xt = (this || _global$A)._mode.decrypt(this || _global$A, wt), Et.push(xt);
    return Ze.concat(Et);
  }, ut.prototype._final = function() {
    var vt = (this || _global$A)._cache.flush();
    if ((this || _global$A)._autopadding)
      return dt((this || _global$A)._mode.decrypt(this || _global$A, vt));
    if (vt)
      throw new Error("data not multiple of block length");
  }, ut.prototype.setAutoPadding = function(vt) {
    return (this || _global$A)._autopadding = !!vt, this || _global$A;
  };
  function lt() {
    (this || _global$A).cache = Ze.allocUnsafe(0);
  }
  lt.prototype.add = function(vt) {
    (this || _global$A).cache = Ze.concat([(this || _global$A).cache, vt]);
  }, lt.prototype.get = function(vt) {
    var wt;
    if (vt) {
      if ((this || _global$A).cache.length > 16)
        return wt = (this || _global$A).cache.slice(0, 16), (this || _global$A).cache = (this || _global$A).cache.slice(16), wt;
    } else if ((this || _global$A).cache.length >= 16)
      return wt = (this || _global$A).cache.slice(0, 16), (this || _global$A).cache = (this || _global$A).cache.slice(16), wt;
    return null;
  }, lt.prototype.flush = function() {
    if ((this || _global$A).cache.length)
      return (this || _global$A).cache;
  };
  function dt(vt) {
    var wt = vt[15];
    if (wt < 1 || wt > 16)
      throw new Error("unable to decrypt data");
    for (var xt = -1; ++xt < wt; )
      if (vt[xt + (16 - wt)] !== wt)
        throw new Error("unable to decrypt data");
    if (wt !== 16)
      return vt.slice(0, 16 - wt);
  }
  function bt(vt, wt, xt) {
    var Et = Fe[vt.toLowerCase()];
    if (!Et)
      throw new TypeError("invalid suite type");
    if (typeof xt == "string" && (xt = Ze.from(xt)), Et.mode !== "GCM" && xt.length !== Et.iv)
      throw new TypeError("invalid iv length " + xt.length);
    if (typeof wt == "string" && (wt = Ze.from(wt)), wt.length !== Et.key / 8)
      throw new TypeError("invalid key length " + wt.length);
    return Et.type === "stream" ? new Ke(Et.module, wt, xt, !0) : Et.type === "auth" ? new $e(Et.module, wt, xt, !0) : new ut(Et.module, wt, xt);
  }
  function $t(vt, wt) {
    var xt = Fe[vt.toLowerCase()];
    if (!xt)
      throw new TypeError("invalid suite type");
    var Et = Qe(wt, !1, xt.key, xt.iv);
    return bt(vt, Et.key, Et.iv);
  }
  return exports$20.createDecipher = $t, exports$20.createDecipheriv = bt, exports$20;
}
var exports$1$ = {}, _dewExec$1_ = !1;
function dew$1_() {
  if (_dewExec$1_)
    return exports$1$;
  _dewExec$1_ = !0;
  var $e = dew$20(), Ze = dew$1$(), Fe = _list$1;
  function Ke() {
    return Object.keys(Fe);
  }
  return exports$1$.createCipher = exports$1$.Cipher = $e.createCipher, exports$1$.createCipheriv = exports$1$.Cipheriv = $e.createCipheriv, exports$1$.createDecipher = exports$1$.Decipher = Ze.createDecipher, exports$1$.createDecipheriv = exports$1$.Decipheriv = Ze.createDecipheriv, exports$1$.listCiphers = exports$1$.getCiphers = Ke, exports$1$;
}
var exports$1_ = {}, _dewExec$1Z = !1;
function dew$1Z() {
  return _dewExec$1Z || (_dewExec$1Z = !0, exports$1_["des-ecb"] = {
    key: 8,
    iv: 0
  }, exports$1_["des-cbc"] = exports$1_.des = {
    key: 8,
    iv: 8
  }, exports$1_["des-ede3-cbc"] = exports$1_.des3 = {
    key: 24,
    iv: 8
  }, exports$1_["des-ede3"] = {
    key: 24,
    iv: 0
  }, exports$1_["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, exports$1_["des-ede"] = {
    key: 16,
    iv: 0
  }), exports$1_;
}
var exports$1Z = {}, _dewExec$1Y = !1;
function dew$1Y() {
  if (_dewExec$1Y)
    return exports$1Z;
  _dewExec$1Y = !0;
  var $e = dew$2g(), Ze = dew$1_(), Fe = dew$26(), Ke = dew$1Z(), Ve = dew$21();
  function Je(dt, bt) {
    dt = dt.toLowerCase();
    var $t, vt;
    if (Fe[dt])
      $t = Fe[dt].key, vt = Fe[dt].iv;
    else if (Ke[dt])
      $t = Ke[dt].key * 8, vt = Ke[dt].iv;
    else
      throw new TypeError("invalid suite type");
    var wt = Ve(bt, !1, $t, vt);
    return at(dt, wt.key, wt.iv);
  }
  function Qe(dt, bt) {
    dt = dt.toLowerCase();
    var $t, vt;
    if (Fe[dt])
      $t = Fe[dt].key, vt = Fe[dt].iv;
    else if (Ke[dt])
      $t = Ke[dt].key * 8, vt = Ke[dt].iv;
    else
      throw new TypeError("invalid suite type");
    var wt = Ve(bt, !1, $t, vt);
    return ut(dt, wt.key, wt.iv);
  }
  function at(dt, bt, $t) {
    if (dt = dt.toLowerCase(), Fe[dt])
      return Ze.createCipheriv(dt, bt, $t);
    if (Ke[dt])
      return new $e({
        key: bt,
        iv: $t,
        mode: dt
      });
    throw new TypeError("invalid suite type");
  }
  function ut(dt, bt, $t) {
    if (dt = dt.toLowerCase(), Fe[dt])
      return Ze.createDecipheriv(dt, bt, $t);
    if (Ke[dt])
      return new $e({
        key: bt,
        iv: $t,
        mode: dt,
        decrypt: !0
      });
    throw new TypeError("invalid suite type");
  }
  function lt() {
    return Object.keys(Ke).concat(Ze.getCiphers());
  }
  return exports$1Z.createCipher = exports$1Z.Cipher = Je, exports$1Z.createCipheriv = exports$1Z.Cipheriv = at, exports$1Z.createDecipher = exports$1Z.Decipher = Qe, exports$1Z.createDecipheriv = exports$1Z.Decipheriv = ut, exports$1Z.listCiphers = exports$1Z.getCiphers = lt, exports$1Z;
}
var exports$1Y = {}, _dewExec$1X = !1, module$a = {
  exports: exports$1Y
}, _global$z = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1X() {
  return _dewExec$1X || (_dewExec$1X = !0, function($e, Ze) {
    function Fe(gt, We) {
      if (!gt)
        throw new Error(We || "Assertion failed");
    }
    function Ke(gt, We) {
      gt.super_ = We;
      var Xe = function() {
      };
      Xe.prototype = We.prototype, gt.prototype = new Xe(), gt.prototype.constructor = gt;
    }
    function Ve(gt, We, Xe) {
      if (Ve.isBN(gt))
        return gt;
      (this || _global$z).negative = 0, (this || _global$z).words = null, (this || _global$z).length = 0, (this || _global$z).red = null, gt !== null && ((We === "le" || We === "be") && (Xe = We, We = 10), this._init(gt || 0, We || 10, Xe || "be"));
    }
    typeof $e == "object" ? $e.exports = Ve : Ze.BN = Ve, Ve.BN = Ve, Ve.wordSize = 26;
    var Je;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Je = window.Buffer : Je = buffer.Buffer;
    } catch {
    }
    Ve.isBN = function(We) {
      return We instanceof Ve ? !0 : We !== null && typeof We == "object" && We.constructor.wordSize === Ve.wordSize && Array.isArray(We.words);
    }, Ve.max = function(We, Xe) {
      return We.cmp(Xe) > 0 ? We : Xe;
    }, Ve.min = function(We, Xe) {
      return We.cmp(Xe) < 0 ? We : Xe;
    }, Ve.prototype._init = function(We, Xe, rt) {
      if (typeof We == "number")
        return this._initNumber(We, Xe, rt);
      if (typeof We == "object")
        return this._initArray(We, Xe, rt);
      Xe === "hex" && (Xe = 16), Fe(Xe === (Xe | 0) && Xe >= 2 && Xe <= 36), We = We.toString().replace(/\s+/g, "");
      var ot = 0;
      We[0] === "-" && (ot++, (this || _global$z).negative = 1), ot < We.length && (Xe === 16 ? this._parseHex(We, ot, rt) : (this._parseBase(We, Xe, ot), rt === "le" && this._initArray(this.toArray(), Xe, rt)));
    }, Ve.prototype._initNumber = function(We, Xe, rt) {
      We < 0 && ((this || _global$z).negative = 1, We = -We), We < 67108864 ? ((this || _global$z).words = [We & 67108863], (this || _global$z).length = 1) : We < 4503599627370496 ? ((this || _global$z).words = [We & 67108863, We / 67108864 & 67108863], (this || _global$z).length = 2) : (Fe(We < 9007199254740992), (this || _global$z).words = [We & 67108863, We / 67108864 & 67108863, 1], (this || _global$z).length = 3), rt === "le" && this._initArray(this.toArray(), Xe, rt);
    }, Ve.prototype._initArray = function(We, Xe, rt) {
      if (Fe(typeof We.length == "number"), We.length <= 0)
        return (this || _global$z).words = [0], (this || _global$z).length = 1, this || _global$z;
      (this || _global$z).length = Math.ceil(We.length / 3), (this || _global$z).words = new Array((this || _global$z).length);
      for (var ot = 0; ot < (this || _global$z).length; ot++)
        (this || _global$z).words[ot] = 0;
      var ft, mt, yt = 0;
      if (rt === "be")
        for (ot = We.length - 1, ft = 0; ot >= 0; ot -= 3)
          mt = We[ot] | We[ot - 1] << 8 | We[ot - 2] << 16, (this || _global$z).words[ft] |= mt << yt & 67108863, (this || _global$z).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      else if (rt === "le")
        for (ot = 0, ft = 0; ot < We.length; ot += 3)
          mt = We[ot] | We[ot + 1] << 8 | We[ot + 2] << 16, (this || _global$z).words[ft] |= mt << yt & 67108863, (this || _global$z).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      return this.strip();
    };
    function Qe(gt, We) {
      var Xe = gt.charCodeAt(We);
      return Xe >= 65 && Xe <= 70 ? Xe - 55 : Xe >= 97 && Xe <= 102 ? Xe - 87 : Xe - 48 & 15;
    }
    function at(gt, We, Xe) {
      var rt = Qe(gt, Xe);
      return Xe - 1 >= We && (rt |= Qe(gt, Xe - 1) << 4), rt;
    }
    Ve.prototype._parseHex = function(We, Xe, rt) {
      (this || _global$z).length = Math.ceil((We.length - Xe) / 6), (this || _global$z).words = new Array((this || _global$z).length);
      for (var ot = 0; ot < (this || _global$z).length; ot++)
        (this || _global$z).words[ot] = 0;
      var ft = 0, mt = 0, yt;
      if (rt === "be")
        for (ot = We.length - 1; ot >= Xe; ot -= 2)
          yt = at(We, Xe, ot) << ft, (this || _global$z).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$z).words[mt] |= yt >>> 26) : ft += 8;
      else {
        var pt = We.length - Xe;
        for (ot = pt % 2 === 0 ? Xe + 1 : Xe; ot < We.length; ot += 2)
          yt = at(We, Xe, ot) << ft, (this || _global$z).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$z).words[mt] |= yt >>> 26) : ft += 8;
      }
      this.strip();
    };
    function ut(gt, We, Xe, rt) {
      for (var ot = 0, ft = Math.min(gt.length, Xe), mt = We; mt < ft; mt++) {
        var yt = gt.charCodeAt(mt) - 48;
        ot *= rt, yt >= 49 ? ot += yt - 49 + 10 : yt >= 17 ? ot += yt - 17 + 10 : ot += yt;
      }
      return ot;
    }
    Ve.prototype._parseBase = function(We, Xe, rt) {
      (this || _global$z).words = [0], (this || _global$z).length = 1;
      for (var ot = 0, ft = 1; ft <= 67108863; ft *= Xe)
        ot++;
      ot--, ft = ft / Xe | 0;
      for (var mt = We.length - rt, yt = mt % ot, pt = Math.min(mt, mt - yt) + rt, Ge = 0, ct = rt; ct < pt; ct += ot)
        Ge = ut(We, ct, ct + ot, Xe), this.imuln(ft), (this || _global$z).words[0] + Ge < 67108864 ? (this || _global$z).words[0] += Ge : this._iaddn(Ge);
      if (yt !== 0) {
        var Mt = 1;
        for (Ge = ut(We, ct, We.length, Xe), ct = 0; ct < yt; ct++)
          Mt *= Xe;
        this.imuln(Mt), (this || _global$z).words[0] + Ge < 67108864 ? (this || _global$z).words[0] += Ge : this._iaddn(Ge);
      }
      this.strip();
    }, Ve.prototype.copy = function(We) {
      We.words = new Array((this || _global$z).length);
      for (var Xe = 0; Xe < (this || _global$z).length; Xe++)
        We.words[Xe] = (this || _global$z).words[Xe];
      We.length = (this || _global$z).length, We.negative = (this || _global$z).negative, We.red = (this || _global$z).red;
    }, Ve.prototype.clone = function() {
      var We = new Ve(null);
      return this.copy(We), We;
    }, Ve.prototype._expand = function(We) {
      for (; (this || _global$z).length < We; )
        (this || _global$z).words[(this || _global$z).length++] = 0;
      return this || _global$z;
    }, Ve.prototype.strip = function() {
      for (; (this || _global$z).length > 1 && (this || _global$z).words[(this || _global$z).length - 1] === 0; )
        (this || _global$z).length--;
      return this._normSign();
    }, Ve.prototype._normSign = function() {
      return (this || _global$z).length === 1 && (this || _global$z).words[0] === 0 && ((this || _global$z).negative = 0), this || _global$z;
    }, Ve.prototype.inspect = function() {
      return ((this || _global$z).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var lt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], dt = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], bt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    Ve.prototype.toString = function(We, Xe) {
      We = We || 10, Xe = Xe | 0 || 1;
      var rt;
      if (We === 16 || We === "hex") {
        rt = "";
        for (var ot = 0, ft = 0, mt = 0; mt < (this || _global$z).length; mt++) {
          var yt = (this || _global$z).words[mt], pt = ((yt << ot | ft) & 16777215).toString(16);
          ft = yt >>> 24 - ot & 16777215, ft !== 0 || mt !== (this || _global$z).length - 1 ? rt = lt[6 - pt.length] + pt + rt : rt = pt + rt, ot += 2, ot >= 26 && (ot -= 26, mt--);
        }
        for (ft !== 0 && (rt = ft.toString(16) + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$z).negative !== 0 && (rt = "-" + rt), rt;
      }
      if (We === (We | 0) && We >= 2 && We <= 36) {
        var Ge = dt[We], ct = bt[We];
        rt = "";
        var Mt = this.clone();
        for (Mt.negative = 0; !Mt.isZero(); ) {
          var St = Mt.modn(ct).toString(We);
          Mt = Mt.idivn(ct), Mt.isZero() ? rt = St + rt : rt = lt[Ge - St.length] + St + rt;
        }
        for (this.isZero() && (rt = "0" + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$z).negative !== 0 && (rt = "-" + rt), rt;
      }
      Fe(!1, "Base should be between 2 and 36");
    }, Ve.prototype.toNumber = function() {
      var We = (this || _global$z).words[0];
      return (this || _global$z).length === 2 ? We += (this || _global$z).words[1] * 67108864 : (this || _global$z).length === 3 && (this || _global$z).words[2] === 1 ? We += 4503599627370496 + (this || _global$z).words[1] * 67108864 : (this || _global$z).length > 2 && Fe(!1, "Number can only safely store up to 53 bits"), (this || _global$z).negative !== 0 ? -We : We;
    }, Ve.prototype.toJSON = function() {
      return this.toString(16);
    }, Ve.prototype.toBuffer = function(We, Xe) {
      return Fe(typeof Je < "u"), this.toArrayLike(Je, We, Xe);
    }, Ve.prototype.toArray = function(We, Xe) {
      return this.toArrayLike(Array, We, Xe);
    }, Ve.prototype.toArrayLike = function(We, Xe, rt) {
      var ot = this.byteLength(), ft = rt || Math.max(1, ot);
      Fe(ot <= ft, "byte array longer than desired length"), Fe(ft > 0, "Requested array length <= 0"), this.strip();
      var mt = Xe === "le", yt = new We(ft), pt, Ge, ct = this.clone();
      if (mt) {
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[Ge] = pt;
        for (; Ge < ft; Ge++)
          yt[Ge] = 0;
      } else {
        for (Ge = 0; Ge < ft - ot; Ge++)
          yt[Ge] = 0;
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[ft - Ge - 1] = pt;
      }
      return yt;
    }, Math.clz32 ? Ve.prototype._countBits = function(We) {
      return 32 - Math.clz32(We);
    } : Ve.prototype._countBits = function(We) {
      var Xe = We, rt = 0;
      return Xe >= 4096 && (rt += 13, Xe >>>= 13), Xe >= 64 && (rt += 7, Xe >>>= 7), Xe >= 8 && (rt += 4, Xe >>>= 4), Xe >= 2 && (rt += 2, Xe >>>= 2), rt + Xe;
    }, Ve.prototype._zeroBits = function(We) {
      if (We === 0)
        return 26;
      var Xe = We, rt = 0;
      return Xe & 8191 || (rt += 13, Xe >>>= 13), Xe & 127 || (rt += 7, Xe >>>= 7), Xe & 15 || (rt += 4, Xe >>>= 4), Xe & 3 || (rt += 2, Xe >>>= 2), Xe & 1 || rt++, rt;
    }, Ve.prototype.bitLength = function() {
      var We = (this || _global$z).words[(this || _global$z).length - 1], Xe = this._countBits(We);
      return ((this || _global$z).length - 1) * 26 + Xe;
    };
    function $t(gt) {
      for (var We = new Array(gt.bitLength()), Xe = 0; Xe < We.length; Xe++) {
        var rt = Xe / 26 | 0, ot = Xe % 26;
        We[Xe] = (gt.words[rt] & 1 << ot) >>> ot;
      }
      return We;
    }
    Ve.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var We = 0, Xe = 0; Xe < (this || _global$z).length; Xe++) {
        var rt = this._zeroBits((this || _global$z).words[Xe]);
        if (We += rt, rt !== 26)
          break;
      }
      return We;
    }, Ve.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Ve.prototype.toTwos = function(We) {
      return (this || _global$z).negative !== 0 ? this.abs().inotn(We).iaddn(1) : this.clone();
    }, Ve.prototype.fromTwos = function(We) {
      return this.testn(We - 1) ? this.notn(We).iaddn(1).ineg() : this.clone();
    }, Ve.prototype.isNeg = function() {
      return (this || _global$z).negative !== 0;
    }, Ve.prototype.neg = function() {
      return this.clone().ineg();
    }, Ve.prototype.ineg = function() {
      return this.isZero() || ((this || _global$z).negative ^= 1), this || _global$z;
    }, Ve.prototype.iuor = function(We) {
      for (; (this || _global$z).length < We.length; )
        (this || _global$z).words[(this || _global$z).length++] = 0;
      for (var Xe = 0; Xe < We.length; Xe++)
        (this || _global$z).words[Xe] = (this || _global$z).words[Xe] | We.words[Xe];
      return this.strip();
    }, Ve.prototype.ior = function(We) {
      return Fe(((this || _global$z).negative | We.negative) === 0), this.iuor(We);
    }, Ve.prototype.or = function(We) {
      return (this || _global$z).length > We.length ? this.clone().ior(We) : We.clone().ior(this || _global$z);
    }, Ve.prototype.uor = function(We) {
      return (this || _global$z).length > We.length ? this.clone().iuor(We) : We.clone().iuor(this || _global$z);
    }, Ve.prototype.iuand = function(We) {
      var Xe;
      (this || _global$z).length > We.length ? Xe = We : Xe = this || _global$z;
      for (var rt = 0; rt < Xe.length; rt++)
        (this || _global$z).words[rt] = (this || _global$z).words[rt] & We.words[rt];
      return (this || _global$z).length = Xe.length, this.strip();
    }, Ve.prototype.iand = function(We) {
      return Fe(((this || _global$z).negative | We.negative) === 0), this.iuand(We);
    }, Ve.prototype.and = function(We) {
      return (this || _global$z).length > We.length ? this.clone().iand(We) : We.clone().iand(this || _global$z);
    }, Ve.prototype.uand = function(We) {
      return (this || _global$z).length > We.length ? this.clone().iuand(We) : We.clone().iuand(this || _global$z);
    }, Ve.prototype.iuxor = function(We) {
      var Xe, rt;
      (this || _global$z).length > We.length ? (Xe = this || _global$z, rt = We) : (Xe = We, rt = this || _global$z);
      for (var ot = 0; ot < rt.length; ot++)
        (this || _global$z).words[ot] = Xe.words[ot] ^ rt.words[ot];
      if ((this || _global$z) !== Xe)
        for (; ot < Xe.length; ot++)
          (this || _global$z).words[ot] = Xe.words[ot];
      return (this || _global$z).length = Xe.length, this.strip();
    }, Ve.prototype.ixor = function(We) {
      return Fe(((this || _global$z).negative | We.negative) === 0), this.iuxor(We);
    }, Ve.prototype.xor = function(We) {
      return (this || _global$z).length > We.length ? this.clone().ixor(We) : We.clone().ixor(this || _global$z);
    }, Ve.prototype.uxor = function(We) {
      return (this || _global$z).length > We.length ? this.clone().iuxor(We) : We.clone().iuxor(this || _global$z);
    }, Ve.prototype.inotn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = Math.ceil(We / 26) | 0, rt = We % 26;
      this._expand(Xe), rt > 0 && Xe--;
      for (var ot = 0; ot < Xe; ot++)
        (this || _global$z).words[ot] = ~(this || _global$z).words[ot] & 67108863;
      return rt > 0 && ((this || _global$z).words[ot] = ~(this || _global$z).words[ot] & 67108863 >> 26 - rt), this.strip();
    }, Ve.prototype.notn = function(We) {
      return this.clone().inotn(We);
    }, Ve.prototype.setn = function(We, Xe) {
      Fe(typeof We == "number" && We >= 0);
      var rt = We / 26 | 0, ot = We % 26;
      return this._expand(rt + 1), Xe ? (this || _global$z).words[rt] = (this || _global$z).words[rt] | 1 << ot : (this || _global$z).words[rt] = (this || _global$z).words[rt] & ~(1 << ot), this.strip();
    }, Ve.prototype.iadd = function(We) {
      var Xe;
      if ((this || _global$z).negative !== 0 && We.negative === 0)
        return (this || _global$z).negative = 0, Xe = this.isub(We), (this || _global$z).negative ^= 1, this._normSign();
      if ((this || _global$z).negative === 0 && We.negative !== 0)
        return We.negative = 0, Xe = this.isub(We), We.negative = 1, Xe._normSign();
      var rt, ot;
      (this || _global$z).length > We.length ? (rt = this || _global$z, ot = We) : (rt = We, ot = this || _global$z);
      for (var ft = 0, mt = 0; mt < ot.length; mt++)
        Xe = (rt.words[mt] | 0) + (ot.words[mt] | 0) + ft, (this || _global$z).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      for (; ft !== 0 && mt < rt.length; mt++)
        Xe = (rt.words[mt] | 0) + ft, (this || _global$z).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      if ((this || _global$z).length = rt.length, ft !== 0)
        (this || _global$z).words[(this || _global$z).length] = ft, (this || _global$z).length++;
      else if (rt !== (this || _global$z))
        for (; mt < rt.length; mt++)
          (this || _global$z).words[mt] = rt.words[mt];
      return this || _global$z;
    }, Ve.prototype.add = function(We) {
      var Xe;
      return We.negative !== 0 && (this || _global$z).negative === 0 ? (We.negative = 0, Xe = this.sub(We), We.negative ^= 1, Xe) : We.negative === 0 && (this || _global$z).negative !== 0 ? ((this || _global$z).negative = 0, Xe = We.sub(this || _global$z), (this || _global$z).negative = 1, Xe) : (this || _global$z).length > We.length ? this.clone().iadd(We) : We.clone().iadd(this || _global$z);
    }, Ve.prototype.isub = function(We) {
      if (We.negative !== 0) {
        We.negative = 0;
        var Xe = this.iadd(We);
        return We.negative = 1, Xe._normSign();
      } else if ((this || _global$z).negative !== 0)
        return (this || _global$z).negative = 0, this.iadd(We), (this || _global$z).negative = 1, this._normSign();
      var rt = this.cmp(We);
      if (rt === 0)
        return (this || _global$z).negative = 0, (this || _global$z).length = 1, (this || _global$z).words[0] = 0, this || _global$z;
      var ot, ft;
      rt > 0 ? (ot = this || _global$z, ft = We) : (ot = We, ft = this || _global$z);
      for (var mt = 0, yt = 0; yt < ft.length; yt++)
        Xe = (ot.words[yt] | 0) - (ft.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$z).words[yt] = Xe & 67108863;
      for (; mt !== 0 && yt < ot.length; yt++)
        Xe = (ot.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$z).words[yt] = Xe & 67108863;
      if (mt === 0 && yt < ot.length && ot !== (this || _global$z))
        for (; yt < ot.length; yt++)
          (this || _global$z).words[yt] = ot.words[yt];
      return (this || _global$z).length = Math.max((this || _global$z).length, yt), ot !== (this || _global$z) && ((this || _global$z).negative = 1), this.strip();
    }, Ve.prototype.sub = function(We) {
      return this.clone().isub(We);
    };
    function vt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative;
      var rt = gt.length + We.length | 0;
      Xe.length = rt, rt = rt - 1 | 0;
      var ot = gt.words[0] | 0, ft = We.words[0] | 0, mt = ot * ft, yt = mt & 67108863, pt = mt / 67108864 | 0;
      Xe.words[0] = yt;
      for (var Ge = 1; Ge < rt; Ge++) {
        for (var ct = pt >>> 26, Mt = pt & 67108863, St = Math.min(Ge, We.length - 1), At = Math.max(0, Ge - gt.length + 1); At <= St; At++) {
          var Nt = Ge - At | 0;
          ot = gt.words[Nt] | 0, ft = We.words[At] | 0, mt = ot * ft + Mt, ct += mt / 67108864 | 0, Mt = mt & 67108863;
        }
        Xe.words[Ge] = Mt | 0, pt = ct | 0;
      }
      return pt !== 0 ? Xe.words[Ge] = pt | 0 : Xe.length--, Xe.strip();
    }
    var wt = function(We, Xe, rt) {
      var ot = We.words, ft = Xe.words, mt = rt.words, yt = 0, pt, Ge, ct, Mt = ot[0] | 0, St = Mt & 8191, At = Mt >>> 13, Nt = ot[1] | 0, qt = Nt & 8191, Qt = Nt >>> 13, Xt = ot[2] | 0, zt = Xt & 8191, Kt = Xt >>> 13, ur = ot[3] | 0, er = ur & 8191, Dt = ur >>> 13, Ht = ot[4] | 0, Gt = Ht & 8191, rr = Ht >>> 13, sr = ot[5] | 0, Jt = sr & 8191, ir = sr >>> 13, Br = ot[6] | 0, or = Br & 8191, lr = Br >>> 13, Nr = ot[7] | 0, dr = Nr & 8191, gr = Nr >>> 13, Zr = ot[8] | 0, Bt = Zr & 8191, kt = Zr >>> 13, It = ot[9] | 0, jt = It & 8191, Vt = It >>> 13, ar = ft[0] | 0, Yt = ar & 8191, hr = ar >>> 13, zr = ft[1] | 0, cr = zr & 8191, _r = zr >>> 13, Lr = ft[2] | 0, br = Lr & 8191, kr = Lr >>> 13, Xr = ft[3] | 0, yr = Xr & 8191, Ir = Xr >>> 13, Yr = ft[4] | 0, wr = Yr & 8191, Cr = Yr >>> 13, Hr = ft[5] | 0, $r = Hr & 8191, Ar = Hr >>> 13, Wr = ft[6] | 0, mr = Wr & 8191, Tr = Wr >>> 13, Kr = ft[7] | 0, vr = Kr & 8191, Rr = Kr >>> 13, Jr = ft[8] | 0, xr = Jr & 8191, tr = Jr >>> 13, Dr = ft[9] | 0, fr = Dr & 8191, Mr = Dr >>> 13;
      rt.negative = We.negative ^ Xe.negative, rt.length = 19, pt = Math.imul(St, Yt), Ge = Math.imul(St, hr), Ge = Ge + Math.imul(At, Yt) | 0, ct = Math.imul(At, hr);
      var Fr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, pt = Math.imul(qt, Yt), Ge = Math.imul(qt, hr), Ge = Ge + Math.imul(Qt, Yt) | 0, ct = Math.imul(Qt, hr), pt = pt + Math.imul(St, cr) | 0, Ge = Ge + Math.imul(St, _r) | 0, Ge = Ge + Math.imul(At, cr) | 0, ct = ct + Math.imul(At, _r) | 0;
      var qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, pt = Math.imul(zt, Yt), Ge = Math.imul(zt, hr), Ge = Ge + Math.imul(Kt, Yt) | 0, ct = Math.imul(Kt, hr), pt = pt + Math.imul(qt, cr) | 0, Ge = Ge + Math.imul(qt, _r) | 0, Ge = Ge + Math.imul(Qt, cr) | 0, ct = ct + Math.imul(Qt, _r) | 0, pt = pt + Math.imul(St, br) | 0, Ge = Ge + Math.imul(St, kr) | 0, Ge = Ge + Math.imul(At, br) | 0, ct = ct + Math.imul(At, kr) | 0;
      var tn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, pt = Math.imul(er, Yt), Ge = Math.imul(er, hr), Ge = Ge + Math.imul(Dt, Yt) | 0, ct = Math.imul(Dt, hr), pt = pt + Math.imul(zt, cr) | 0, Ge = Ge + Math.imul(zt, _r) | 0, Ge = Ge + Math.imul(Kt, cr) | 0, ct = ct + Math.imul(Kt, _r) | 0, pt = pt + Math.imul(qt, br) | 0, Ge = Ge + Math.imul(qt, kr) | 0, Ge = Ge + Math.imul(Qt, br) | 0, ct = ct + Math.imul(Qt, kr) | 0, pt = pt + Math.imul(St, yr) | 0, Ge = Ge + Math.imul(St, Ir) | 0, Ge = Ge + Math.imul(At, yr) | 0, ct = ct + Math.imul(At, Ir) | 0;
      var Qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, pt = Math.imul(Gt, Yt), Ge = Math.imul(Gt, hr), Ge = Ge + Math.imul(rr, Yt) | 0, ct = Math.imul(rr, hr), pt = pt + Math.imul(er, cr) | 0, Ge = Ge + Math.imul(er, _r) | 0, Ge = Ge + Math.imul(Dt, cr) | 0, ct = ct + Math.imul(Dt, _r) | 0, pt = pt + Math.imul(zt, br) | 0, Ge = Ge + Math.imul(zt, kr) | 0, Ge = Ge + Math.imul(Kt, br) | 0, ct = ct + Math.imul(Kt, kr) | 0, pt = pt + Math.imul(qt, yr) | 0, Ge = Ge + Math.imul(qt, Ir) | 0, Ge = Ge + Math.imul(Qt, yr) | 0, ct = ct + Math.imul(Qt, Ir) | 0, pt = pt + Math.imul(St, wr) | 0, Ge = Ge + Math.imul(St, Cr) | 0, Ge = Ge + Math.imul(At, wr) | 0, ct = ct + Math.imul(At, Cr) | 0;
      var nn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, pt = Math.imul(Jt, Yt), Ge = Math.imul(Jt, hr), Ge = Ge + Math.imul(ir, Yt) | 0, ct = Math.imul(ir, hr), pt = pt + Math.imul(Gt, cr) | 0, Ge = Ge + Math.imul(Gt, _r) | 0, Ge = Ge + Math.imul(rr, cr) | 0, ct = ct + Math.imul(rr, _r) | 0, pt = pt + Math.imul(er, br) | 0, Ge = Ge + Math.imul(er, kr) | 0, Ge = Ge + Math.imul(Dt, br) | 0, ct = ct + Math.imul(Dt, kr) | 0, pt = pt + Math.imul(zt, yr) | 0, Ge = Ge + Math.imul(zt, Ir) | 0, Ge = Ge + Math.imul(Kt, yr) | 0, ct = ct + Math.imul(Kt, Ir) | 0, pt = pt + Math.imul(qt, wr) | 0, Ge = Ge + Math.imul(qt, Cr) | 0, Ge = Ge + Math.imul(Qt, wr) | 0, ct = ct + Math.imul(Qt, Cr) | 0, pt = pt + Math.imul(St, $r) | 0, Ge = Ge + Math.imul(St, Ar) | 0, Ge = Ge + Math.imul(At, $r) | 0, ct = ct + Math.imul(At, Ar) | 0;
      var Er = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, pt = Math.imul(or, Yt), Ge = Math.imul(or, hr), Ge = Ge + Math.imul(lr, Yt) | 0, ct = Math.imul(lr, hr), pt = pt + Math.imul(Jt, cr) | 0, Ge = Ge + Math.imul(Jt, _r) | 0, Ge = Ge + Math.imul(ir, cr) | 0, ct = ct + Math.imul(ir, _r) | 0, pt = pt + Math.imul(Gt, br) | 0, Ge = Ge + Math.imul(Gt, kr) | 0, Ge = Ge + Math.imul(rr, br) | 0, ct = ct + Math.imul(rr, kr) | 0, pt = pt + Math.imul(er, yr) | 0, Ge = Ge + Math.imul(er, Ir) | 0, Ge = Ge + Math.imul(Dt, yr) | 0, ct = ct + Math.imul(Dt, Ir) | 0, pt = pt + Math.imul(zt, wr) | 0, Ge = Ge + Math.imul(zt, Cr) | 0, Ge = Ge + Math.imul(Kt, wr) | 0, ct = ct + Math.imul(Kt, Cr) | 0, pt = pt + Math.imul(qt, $r) | 0, Ge = Ge + Math.imul(qt, Ar) | 0, Ge = Ge + Math.imul(Qt, $r) | 0, ct = ct + Math.imul(Qt, Ar) | 0, pt = pt + Math.imul(St, mr) | 0, Ge = Ge + Math.imul(St, Tr) | 0, Ge = Ge + Math.imul(At, mr) | 0, ct = ct + Math.imul(At, Tr) | 0;
      var Wt = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, pt = Math.imul(dr, Yt), Ge = Math.imul(dr, hr), Ge = Ge + Math.imul(gr, Yt) | 0, ct = Math.imul(gr, hr), pt = pt + Math.imul(or, cr) | 0, Ge = Ge + Math.imul(or, _r) | 0, Ge = Ge + Math.imul(lr, cr) | 0, ct = ct + Math.imul(lr, _r) | 0, pt = pt + Math.imul(Jt, br) | 0, Ge = Ge + Math.imul(Jt, kr) | 0, Ge = Ge + Math.imul(ir, br) | 0, ct = ct + Math.imul(ir, kr) | 0, pt = pt + Math.imul(Gt, yr) | 0, Ge = Ge + Math.imul(Gt, Ir) | 0, Ge = Ge + Math.imul(rr, yr) | 0, ct = ct + Math.imul(rr, Ir) | 0, pt = pt + Math.imul(er, wr) | 0, Ge = Ge + Math.imul(er, Cr) | 0, Ge = Ge + Math.imul(Dt, wr) | 0, ct = ct + Math.imul(Dt, Cr) | 0, pt = pt + Math.imul(zt, $r) | 0, Ge = Ge + Math.imul(zt, Ar) | 0, Ge = Ge + Math.imul(Kt, $r) | 0, ct = ct + Math.imul(Kt, Ar) | 0, pt = pt + Math.imul(qt, mr) | 0, Ge = Ge + Math.imul(qt, Tr) | 0, Ge = Ge + Math.imul(Qt, mr) | 0, ct = ct + Math.imul(Qt, Tr) | 0, pt = pt + Math.imul(St, vr) | 0, Ge = Ge + Math.imul(St, Rr) | 0, Ge = Ge + Math.imul(At, vr) | 0, ct = ct + Math.imul(At, Rr) | 0;
      var nr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, pt = Math.imul(Bt, Yt), Ge = Math.imul(Bt, hr), Ge = Ge + Math.imul(kt, Yt) | 0, ct = Math.imul(kt, hr), pt = pt + Math.imul(dr, cr) | 0, Ge = Ge + Math.imul(dr, _r) | 0, Ge = Ge + Math.imul(gr, cr) | 0, ct = ct + Math.imul(gr, _r) | 0, pt = pt + Math.imul(or, br) | 0, Ge = Ge + Math.imul(or, kr) | 0, Ge = Ge + Math.imul(lr, br) | 0, ct = ct + Math.imul(lr, kr) | 0, pt = pt + Math.imul(Jt, yr) | 0, Ge = Ge + Math.imul(Jt, Ir) | 0, Ge = Ge + Math.imul(ir, yr) | 0, ct = ct + Math.imul(ir, Ir) | 0, pt = pt + Math.imul(Gt, wr) | 0, Ge = Ge + Math.imul(Gt, Cr) | 0, Ge = Ge + Math.imul(rr, wr) | 0, ct = ct + Math.imul(rr, Cr) | 0, pt = pt + Math.imul(er, $r) | 0, Ge = Ge + Math.imul(er, Ar) | 0, Ge = Ge + Math.imul(Dt, $r) | 0, ct = ct + Math.imul(Dt, Ar) | 0, pt = pt + Math.imul(zt, mr) | 0, Ge = Ge + Math.imul(zt, Tr) | 0, Ge = Ge + Math.imul(Kt, mr) | 0, ct = ct + Math.imul(Kt, Tr) | 0, pt = pt + Math.imul(qt, vr) | 0, Ge = Ge + Math.imul(qt, Rr) | 0, Ge = Ge + Math.imul(Qt, vr) | 0, ct = ct + Math.imul(Qt, Rr) | 0, pt = pt + Math.imul(St, xr) | 0, Ge = Ge + Math.imul(St, tr) | 0, Ge = Ge + Math.imul(At, xr) | 0, ct = ct + Math.imul(At, tr) | 0;
      var pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, pt = Math.imul(jt, Yt), Ge = Math.imul(jt, hr), Ge = Ge + Math.imul(Vt, Yt) | 0, ct = Math.imul(Vt, hr), pt = pt + Math.imul(Bt, cr) | 0, Ge = Ge + Math.imul(Bt, _r) | 0, Ge = Ge + Math.imul(kt, cr) | 0, ct = ct + Math.imul(kt, _r) | 0, pt = pt + Math.imul(dr, br) | 0, Ge = Ge + Math.imul(dr, kr) | 0, Ge = Ge + Math.imul(gr, br) | 0, ct = ct + Math.imul(gr, kr) | 0, pt = pt + Math.imul(or, yr) | 0, Ge = Ge + Math.imul(or, Ir) | 0, Ge = Ge + Math.imul(lr, yr) | 0, ct = ct + Math.imul(lr, Ir) | 0, pt = pt + Math.imul(Jt, wr) | 0, Ge = Ge + Math.imul(Jt, Cr) | 0, Ge = Ge + Math.imul(ir, wr) | 0, ct = ct + Math.imul(ir, Cr) | 0, pt = pt + Math.imul(Gt, $r) | 0, Ge = Ge + Math.imul(Gt, Ar) | 0, Ge = Ge + Math.imul(rr, $r) | 0, ct = ct + Math.imul(rr, Ar) | 0, pt = pt + Math.imul(er, mr) | 0, Ge = Ge + Math.imul(er, Tr) | 0, Ge = Ge + Math.imul(Dt, mr) | 0, ct = ct + Math.imul(Dt, Tr) | 0, pt = pt + Math.imul(zt, vr) | 0, Ge = Ge + Math.imul(zt, Rr) | 0, Ge = Ge + Math.imul(Kt, vr) | 0, ct = ct + Math.imul(Kt, Rr) | 0, pt = pt + Math.imul(qt, xr) | 0, Ge = Ge + Math.imul(qt, tr) | 0, Ge = Ge + Math.imul(Qt, xr) | 0, ct = ct + Math.imul(Qt, tr) | 0, pt = pt + Math.imul(St, fr) | 0, Ge = Ge + Math.imul(St, Mr) | 0, Ge = Ge + Math.imul(At, fr) | 0, ct = ct + Math.imul(At, Mr) | 0;
      var Pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, pt = Math.imul(jt, cr), Ge = Math.imul(jt, _r), Ge = Ge + Math.imul(Vt, cr) | 0, ct = Math.imul(Vt, _r), pt = pt + Math.imul(Bt, br) | 0, Ge = Ge + Math.imul(Bt, kr) | 0, Ge = Ge + Math.imul(kt, br) | 0, ct = ct + Math.imul(kt, kr) | 0, pt = pt + Math.imul(dr, yr) | 0, Ge = Ge + Math.imul(dr, Ir) | 0, Ge = Ge + Math.imul(gr, yr) | 0, ct = ct + Math.imul(gr, Ir) | 0, pt = pt + Math.imul(or, wr) | 0, Ge = Ge + Math.imul(or, Cr) | 0, Ge = Ge + Math.imul(lr, wr) | 0, ct = ct + Math.imul(lr, Cr) | 0, pt = pt + Math.imul(Jt, $r) | 0, Ge = Ge + Math.imul(Jt, Ar) | 0, Ge = Ge + Math.imul(ir, $r) | 0, ct = ct + Math.imul(ir, Ar) | 0, pt = pt + Math.imul(Gt, mr) | 0, Ge = Ge + Math.imul(Gt, Tr) | 0, Ge = Ge + Math.imul(rr, mr) | 0, ct = ct + Math.imul(rr, Tr) | 0, pt = pt + Math.imul(er, vr) | 0, Ge = Ge + Math.imul(er, Rr) | 0, Ge = Ge + Math.imul(Dt, vr) | 0, ct = ct + Math.imul(Dt, Rr) | 0, pt = pt + Math.imul(zt, xr) | 0, Ge = Ge + Math.imul(zt, tr) | 0, Ge = Ge + Math.imul(Kt, xr) | 0, ct = ct + Math.imul(Kt, tr) | 0, pt = pt + Math.imul(qt, fr) | 0, Ge = Ge + Math.imul(qt, Mr) | 0, Ge = Ge + Math.imul(Qt, fr) | 0, ct = ct + Math.imul(Qt, Mr) | 0;
      var Sr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, pt = Math.imul(jt, br), Ge = Math.imul(jt, kr), Ge = Ge + Math.imul(Vt, br) | 0, ct = Math.imul(Vt, kr), pt = pt + Math.imul(Bt, yr) | 0, Ge = Ge + Math.imul(Bt, Ir) | 0, Ge = Ge + Math.imul(kt, yr) | 0, ct = ct + Math.imul(kt, Ir) | 0, pt = pt + Math.imul(dr, wr) | 0, Ge = Ge + Math.imul(dr, Cr) | 0, Ge = Ge + Math.imul(gr, wr) | 0, ct = ct + Math.imul(gr, Cr) | 0, pt = pt + Math.imul(or, $r) | 0, Ge = Ge + Math.imul(or, Ar) | 0, Ge = Ge + Math.imul(lr, $r) | 0, ct = ct + Math.imul(lr, Ar) | 0, pt = pt + Math.imul(Jt, mr) | 0, Ge = Ge + Math.imul(Jt, Tr) | 0, Ge = Ge + Math.imul(ir, mr) | 0, ct = ct + Math.imul(ir, Tr) | 0, pt = pt + Math.imul(Gt, vr) | 0, Ge = Ge + Math.imul(Gt, Rr) | 0, Ge = Ge + Math.imul(rr, vr) | 0, ct = ct + Math.imul(rr, Rr) | 0, pt = pt + Math.imul(er, xr) | 0, Ge = Ge + Math.imul(er, tr) | 0, Ge = Ge + Math.imul(Dt, xr) | 0, ct = ct + Math.imul(Dt, tr) | 0, pt = pt + Math.imul(zt, fr) | 0, Ge = Ge + Math.imul(zt, Mr) | 0, Ge = Ge + Math.imul(Kt, fr) | 0, ct = ct + Math.imul(Kt, Mr) | 0;
      var Ur = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, pt = Math.imul(jt, yr), Ge = Math.imul(jt, Ir), Ge = Ge + Math.imul(Vt, yr) | 0, ct = Math.imul(Vt, Ir), pt = pt + Math.imul(Bt, wr) | 0, Ge = Ge + Math.imul(Bt, Cr) | 0, Ge = Ge + Math.imul(kt, wr) | 0, ct = ct + Math.imul(kt, Cr) | 0, pt = pt + Math.imul(dr, $r) | 0, Ge = Ge + Math.imul(dr, Ar) | 0, Ge = Ge + Math.imul(gr, $r) | 0, ct = ct + Math.imul(gr, Ar) | 0, pt = pt + Math.imul(or, mr) | 0, Ge = Ge + Math.imul(or, Tr) | 0, Ge = Ge + Math.imul(lr, mr) | 0, ct = ct + Math.imul(lr, Tr) | 0, pt = pt + Math.imul(Jt, vr) | 0, Ge = Ge + Math.imul(Jt, Rr) | 0, Ge = Ge + Math.imul(ir, vr) | 0, ct = ct + Math.imul(ir, Rr) | 0, pt = pt + Math.imul(Gt, xr) | 0, Ge = Ge + Math.imul(Gt, tr) | 0, Ge = Ge + Math.imul(rr, xr) | 0, ct = ct + Math.imul(rr, tr) | 0, pt = pt + Math.imul(er, fr) | 0, Ge = Ge + Math.imul(er, Mr) | 0, Ge = Ge + Math.imul(Dt, fr) | 0, ct = ct + Math.imul(Dt, Mr) | 0;
      var jr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, pt = Math.imul(jt, wr), Ge = Math.imul(jt, Cr), Ge = Ge + Math.imul(Vt, wr) | 0, ct = Math.imul(Vt, Cr), pt = pt + Math.imul(Bt, $r) | 0, Ge = Ge + Math.imul(Bt, Ar) | 0, Ge = Ge + Math.imul(kt, $r) | 0, ct = ct + Math.imul(kt, Ar) | 0, pt = pt + Math.imul(dr, mr) | 0, Ge = Ge + Math.imul(dr, Tr) | 0, Ge = Ge + Math.imul(gr, mr) | 0, ct = ct + Math.imul(gr, Tr) | 0, pt = pt + Math.imul(or, vr) | 0, Ge = Ge + Math.imul(or, Rr) | 0, Ge = Ge + Math.imul(lr, vr) | 0, ct = ct + Math.imul(lr, Rr) | 0, pt = pt + Math.imul(Jt, xr) | 0, Ge = Ge + Math.imul(Jt, tr) | 0, Ge = Ge + Math.imul(ir, xr) | 0, ct = ct + Math.imul(ir, tr) | 0, pt = pt + Math.imul(Gt, fr) | 0, Ge = Ge + Math.imul(Gt, Mr) | 0, Ge = Ge + Math.imul(rr, fr) | 0, ct = ct + Math.imul(rr, Mr) | 0;
      var Gr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, pt = Math.imul(jt, $r), Ge = Math.imul(jt, Ar), Ge = Ge + Math.imul(Vt, $r) | 0, ct = Math.imul(Vt, Ar), pt = pt + Math.imul(Bt, mr) | 0, Ge = Ge + Math.imul(Bt, Tr) | 0, Ge = Ge + Math.imul(kt, mr) | 0, ct = ct + Math.imul(kt, Tr) | 0, pt = pt + Math.imul(dr, vr) | 0, Ge = Ge + Math.imul(dr, Rr) | 0, Ge = Ge + Math.imul(gr, vr) | 0, ct = ct + Math.imul(gr, Rr) | 0, pt = pt + Math.imul(or, xr) | 0, Ge = Ge + Math.imul(or, tr) | 0, Ge = Ge + Math.imul(lr, xr) | 0, ct = ct + Math.imul(lr, tr) | 0, pt = pt + Math.imul(Jt, fr) | 0, Ge = Ge + Math.imul(Jt, Mr) | 0, Ge = Ge + Math.imul(ir, fr) | 0, ct = ct + Math.imul(ir, Mr) | 0;
      var Vr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, pt = Math.imul(jt, mr), Ge = Math.imul(jt, Tr), Ge = Ge + Math.imul(Vt, mr) | 0, ct = Math.imul(Vt, Tr), pt = pt + Math.imul(Bt, vr) | 0, Ge = Ge + Math.imul(Bt, Rr) | 0, Ge = Ge + Math.imul(kt, vr) | 0, ct = ct + Math.imul(kt, Rr) | 0, pt = pt + Math.imul(dr, xr) | 0, Ge = Ge + Math.imul(dr, tr) | 0, Ge = Ge + Math.imul(gr, xr) | 0, ct = ct + Math.imul(gr, tr) | 0, pt = pt + Math.imul(or, fr) | 0, Ge = Ge + Math.imul(or, Mr) | 0, Ge = Ge + Math.imul(lr, fr) | 0, ct = ct + Math.imul(lr, Mr) | 0;
      var rn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, pt = Math.imul(jt, vr), Ge = Math.imul(jt, Rr), Ge = Ge + Math.imul(Vt, vr) | 0, ct = Math.imul(Vt, Rr), pt = pt + Math.imul(Bt, xr) | 0, Ge = Ge + Math.imul(Bt, tr) | 0, Ge = Ge + Math.imul(kt, xr) | 0, ct = ct + Math.imul(kt, tr) | 0, pt = pt + Math.imul(dr, fr) | 0, Ge = Ge + Math.imul(dr, Mr) | 0, Ge = Ge + Math.imul(gr, fr) | 0, ct = ct + Math.imul(gr, Mr) | 0;
      var an = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, pt = Math.imul(jt, xr), Ge = Math.imul(jt, tr), Ge = Ge + Math.imul(Vt, xr) | 0, ct = Math.imul(Vt, tr), pt = pt + Math.imul(Bt, fr) | 0, Ge = Ge + Math.imul(Bt, Mr) | 0, Ge = Ge + Math.imul(kt, fr) | 0, ct = ct + Math.imul(kt, Mr) | 0;
      var ln = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, pt = Math.imul(jt, fr), Ge = Math.imul(jt, Mr), Ge = Ge + Math.imul(Vt, fr) | 0, ct = Math.imul(Vt, Mr);
      var sn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      return yt = (ct + (Ge >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, mt[0] = Fr, mt[1] = qr, mt[2] = tn, mt[3] = Qr, mt[4] = nn, mt[5] = Er, mt[6] = Wt, mt[7] = nr, mt[8] = pr, mt[9] = Pr, mt[10] = Sr, mt[11] = Ur, mt[12] = jr, mt[13] = Gr, mt[14] = Vr, mt[15] = rn, mt[16] = an, mt[17] = ln, mt[18] = sn, yt !== 0 && (mt[19] = yt, rt.length++), rt;
    };
    Math.imul || (wt = vt);
    function xt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative, Xe.length = gt.length + We.length;
      for (var rt = 0, ot = 0, ft = 0; ft < Xe.length - 1; ft++) {
        var mt = ot;
        ot = 0;
        for (var yt = rt & 67108863, pt = Math.min(ft, We.length - 1), Ge = Math.max(0, ft - gt.length + 1); Ge <= pt; Ge++) {
          var ct = ft - Ge, Mt = gt.words[ct] | 0, St = We.words[Ge] | 0, At = Mt * St, Nt = At & 67108863;
          mt = mt + (At / 67108864 | 0) | 0, Nt = Nt + yt | 0, yt = Nt & 67108863, mt = mt + (Nt >>> 26) | 0, ot += mt >>> 26, mt &= 67108863;
        }
        Xe.words[ft] = yt, rt = mt, mt = ot;
      }
      return rt !== 0 ? Xe.words[ft] = rt : Xe.length--, Xe.strip();
    }
    function Et(gt, We, Xe) {
      var rt = new Tt();
      return rt.mulp(gt, We, Xe);
    }
    Ve.prototype.mulTo = function(We, Xe) {
      var rt, ot = (this || _global$z).length + We.length;
      return (this || _global$z).length === 10 && We.length === 10 ? rt = wt(this || _global$z, We, Xe) : ot < 63 ? rt = vt(this || _global$z, We, Xe) : ot < 1024 ? rt = xt(this || _global$z, We, Xe) : rt = Et(this || _global$z, We, Xe), rt;
    };
    function Tt(gt, We) {
      (this || _global$z).x = gt, (this || _global$z).y = We;
    }
    Tt.prototype.makeRBT = function(We) {
      for (var Xe = new Array(We), rt = Ve.prototype._countBits(We) - 1, ot = 0; ot < We; ot++)
        Xe[ot] = this.revBin(ot, rt, We);
      return Xe;
    }, Tt.prototype.revBin = function(We, Xe, rt) {
      if (We === 0 || We === rt - 1)
        return We;
      for (var ot = 0, ft = 0; ft < Xe; ft++)
        ot |= (We & 1) << Xe - ft - 1, We >>= 1;
      return ot;
    }, Tt.prototype.permute = function(We, Xe, rt, ot, ft, mt) {
      for (var yt = 0; yt < mt; yt++)
        ot[yt] = Xe[We[yt]], ft[yt] = rt[We[yt]];
    }, Tt.prototype.transform = function(We, Xe, rt, ot, ft, mt) {
      this.permute(mt, We, Xe, rt, ot, ft);
      for (var yt = 1; yt < ft; yt <<= 1)
        for (var pt = yt << 1, Ge = Math.cos(2 * Math.PI / pt), ct = Math.sin(2 * Math.PI / pt), Mt = 0; Mt < ft; Mt += pt)
          for (var St = Ge, At = ct, Nt = 0; Nt < yt; Nt++) {
            var qt = rt[Mt + Nt], Qt = ot[Mt + Nt], Xt = rt[Mt + Nt + yt], zt = ot[Mt + Nt + yt], Kt = St * Xt - At * zt;
            zt = St * zt + At * Xt, Xt = Kt, rt[Mt + Nt] = qt + Xt, ot[Mt + Nt] = Qt + zt, rt[Mt + Nt + yt] = qt - Xt, ot[Mt + Nt + yt] = Qt - zt, Nt !== pt && (Kt = Ge * St - ct * At, At = Ge * At + ct * St, St = Kt);
          }
    }, Tt.prototype.guessLen13b = function(We, Xe) {
      var rt = Math.max(Xe, We) | 1, ot = rt & 1, ft = 0;
      for (rt = rt / 2 | 0; rt; rt = rt >>> 1)
        ft++;
      return 1 << ft + 1 + ot;
    }, Tt.prototype.conjugate = function(We, Xe, rt) {
      if (!(rt <= 1))
        for (var ot = 0; ot < rt / 2; ot++) {
          var ft = We[ot];
          We[ot] = We[rt - ot - 1], We[rt - ot - 1] = ft, ft = Xe[ot], Xe[ot] = -Xe[rt - ot - 1], Xe[rt - ot - 1] = -ft;
        }
    }, Tt.prototype.normalize13b = function(We, Xe) {
      for (var rt = 0, ot = 0; ot < Xe / 2; ot++) {
        var ft = Math.round(We[2 * ot + 1] / Xe) * 8192 + Math.round(We[2 * ot] / Xe) + rt;
        We[ot] = ft & 67108863, ft < 67108864 ? rt = 0 : rt = ft / 67108864 | 0;
      }
      return We;
    }, Tt.prototype.convert13b = function(We, Xe, rt, ot) {
      for (var ft = 0, mt = 0; mt < Xe; mt++)
        ft = ft + (We[mt] | 0), rt[2 * mt] = ft & 8191, ft = ft >>> 13, rt[2 * mt + 1] = ft & 8191, ft = ft >>> 13;
      for (mt = 2 * Xe; mt < ot; ++mt)
        rt[mt] = 0;
      Fe(ft === 0), Fe((ft & -8192) === 0);
    }, Tt.prototype.stub = function(We) {
      for (var Xe = new Array(We), rt = 0; rt < We; rt++)
        Xe[rt] = 0;
      return Xe;
    }, Tt.prototype.mulp = function(We, Xe, rt) {
      var ot = 2 * this.guessLen13b(We.length, Xe.length), ft = this.makeRBT(ot), mt = this.stub(ot), yt = new Array(ot), pt = new Array(ot), Ge = new Array(ot), ct = new Array(ot), Mt = new Array(ot), St = new Array(ot), At = rt.words;
      At.length = ot, this.convert13b(We.words, We.length, yt, ot), this.convert13b(Xe.words, Xe.length, ct, ot), this.transform(yt, mt, pt, Ge, ot, ft), this.transform(ct, mt, Mt, St, ot, ft);
      for (var Nt = 0; Nt < ot; Nt++) {
        var qt = pt[Nt] * Mt[Nt] - Ge[Nt] * St[Nt];
        Ge[Nt] = pt[Nt] * St[Nt] + Ge[Nt] * Mt[Nt], pt[Nt] = qt;
      }
      return this.conjugate(pt, Ge, ot), this.transform(pt, Ge, At, mt, ot, ft), this.conjugate(At, mt, ot), this.normalize13b(At, ot), rt.negative = We.negative ^ Xe.negative, rt.length = We.length + Xe.length, rt.strip();
    }, Ve.prototype.mul = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$z).length + We.length), this.mulTo(We, Xe);
    }, Ve.prototype.mulf = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$z).length + We.length), Et(this || _global$z, We, Xe);
    }, Ve.prototype.imul = function(We) {
      return this.clone().mulTo(We, this || _global$z);
    }, Ve.prototype.imuln = function(We) {
      Fe(typeof We == "number"), Fe(We < 67108864);
      for (var Xe = 0, rt = 0; rt < (this || _global$z).length; rt++) {
        var ot = ((this || _global$z).words[rt] | 0) * We, ft = (ot & 67108863) + (Xe & 67108863);
        Xe >>= 26, Xe += ot / 67108864 | 0, Xe += ft >>> 26, (this || _global$z).words[rt] = ft & 67108863;
      }
      return Xe !== 0 && ((this || _global$z).words[rt] = Xe, (this || _global$z).length++), this || _global$z;
    }, Ve.prototype.muln = function(We) {
      return this.clone().imuln(We);
    }, Ve.prototype.sqr = function() {
      return this.mul(this || _global$z);
    }, Ve.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Ve.prototype.pow = function(We) {
      var Xe = $t(We);
      if (Xe.length === 0)
        return new Ve(1);
      for (var rt = this || _global$z, ot = 0; ot < Xe.length && Xe[ot] === 0; ot++, rt = rt.sqr())
        ;
      if (++ot < Xe.length)
        for (var ft = rt.sqr(); ot < Xe.length; ot++, ft = ft.sqr())
          Xe[ot] !== 0 && (rt = rt.mul(ft));
      return rt;
    }, Ve.prototype.iushln = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 67108863 >>> 26 - Xe << 26 - Xe, ft;
      if (Xe !== 0) {
        var mt = 0;
        for (ft = 0; ft < (this || _global$z).length; ft++) {
          var yt = (this || _global$z).words[ft] & ot, pt = ((this || _global$z).words[ft] | 0) - yt << Xe;
          (this || _global$z).words[ft] = pt | mt, mt = yt >>> 26 - Xe;
        }
        mt && ((this || _global$z).words[ft] = mt, (this || _global$z).length++);
      }
      if (rt !== 0) {
        for (ft = (this || _global$z).length - 1; ft >= 0; ft--)
          (this || _global$z).words[ft + rt] = (this || _global$z).words[ft];
        for (ft = 0; ft < rt; ft++)
          (this || _global$z).words[ft] = 0;
        (this || _global$z).length += rt;
      }
      return this.strip();
    }, Ve.prototype.ishln = function(We) {
      return Fe((this || _global$z).negative === 0), this.iushln(We);
    }, Ve.prototype.iushrn = function(We, Xe, rt) {
      Fe(typeof We == "number" && We >= 0);
      var ot;
      Xe ? ot = (Xe - Xe % 26) / 26 : ot = 0;
      var ft = We % 26, mt = Math.min((We - ft) / 26, (this || _global$z).length), yt = 67108863 ^ 67108863 >>> ft << ft, pt = rt;
      if (ot -= mt, ot = Math.max(0, ot), pt) {
        for (var Ge = 0; Ge < mt; Ge++)
          pt.words[Ge] = (this || _global$z).words[Ge];
        pt.length = mt;
      }
      if (mt !== 0)
        if ((this || _global$z).length > mt)
          for ((this || _global$z).length -= mt, Ge = 0; Ge < (this || _global$z).length; Ge++)
            (this || _global$z).words[Ge] = (this || _global$z).words[Ge + mt];
        else
          (this || _global$z).words[0] = 0, (this || _global$z).length = 1;
      var ct = 0;
      for (Ge = (this || _global$z).length - 1; Ge >= 0 && (ct !== 0 || Ge >= ot); Ge--) {
        var Mt = (this || _global$z).words[Ge] | 0;
        (this || _global$z).words[Ge] = ct << 26 - ft | Mt >>> ft, ct = Mt & yt;
      }
      return pt && ct !== 0 && (pt.words[pt.length++] = ct), (this || _global$z).length === 0 && ((this || _global$z).words[0] = 0, (this || _global$z).length = 1), this.strip();
    }, Ve.prototype.ishrn = function(We, Xe, rt) {
      return Fe((this || _global$z).negative === 0), this.iushrn(We, Xe, rt);
    }, Ve.prototype.shln = function(We) {
      return this.clone().ishln(We);
    }, Ve.prototype.ushln = function(We) {
      return this.clone().iushln(We);
    }, Ve.prototype.shrn = function(We) {
      return this.clone().ishrn(We);
    }, Ve.prototype.ushrn = function(We) {
      return this.clone().iushrn(We);
    }, Ve.prototype.testn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$z).length <= rt)
        return !1;
      var ft = (this || _global$z).words[rt];
      return !!(ft & ot);
    }, Ve.prototype.imaskn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26;
      if (Fe((this || _global$z).negative === 0, "imaskn works only with positive numbers"), (this || _global$z).length <= rt)
        return this || _global$z;
      if (Xe !== 0 && rt++, (this || _global$z).length = Math.min(rt, (this || _global$z).length), Xe !== 0) {
        var ot = 67108863 ^ 67108863 >>> Xe << Xe;
        (this || _global$z).words[(this || _global$z).length - 1] &= ot;
      }
      return this.strip();
    }, Ve.prototype.maskn = function(We) {
      return this.clone().imaskn(We);
    }, Ve.prototype.iaddn = function(We) {
      return Fe(typeof We == "number"), Fe(We < 67108864), We < 0 ? this.isubn(-We) : (this || _global$z).negative !== 0 ? (this || _global$z).length === 1 && ((this || _global$z).words[0] | 0) < We ? ((this || _global$z).words[0] = We - ((this || _global$z).words[0] | 0), (this || _global$z).negative = 0, this || _global$z) : ((this || _global$z).negative = 0, this.isubn(We), (this || _global$z).negative = 1, this || _global$z) : this._iaddn(We);
    }, Ve.prototype._iaddn = function(We) {
      (this || _global$z).words[0] += We;
      for (var Xe = 0; Xe < (this || _global$z).length && (this || _global$z).words[Xe] >= 67108864; Xe++)
        (this || _global$z).words[Xe] -= 67108864, Xe === (this || _global$z).length - 1 ? (this || _global$z).words[Xe + 1] = 1 : (this || _global$z).words[Xe + 1]++;
      return (this || _global$z).length = Math.max((this || _global$z).length, Xe + 1), this || _global$z;
    }, Ve.prototype.isubn = function(We) {
      if (Fe(typeof We == "number"), Fe(We < 67108864), We < 0)
        return this.iaddn(-We);
      if ((this || _global$z).negative !== 0)
        return (this || _global$z).negative = 0, this.iaddn(We), (this || _global$z).negative = 1, this || _global$z;
      if ((this || _global$z).words[0] -= We, (this || _global$z).length === 1 && (this || _global$z).words[0] < 0)
        (this || _global$z).words[0] = -(this || _global$z).words[0], (this || _global$z).negative = 1;
      else
        for (var Xe = 0; Xe < (this || _global$z).length && (this || _global$z).words[Xe] < 0; Xe++)
          (this || _global$z).words[Xe] += 67108864, (this || _global$z).words[Xe + 1] -= 1;
      return this.strip();
    }, Ve.prototype.addn = function(We) {
      return this.clone().iaddn(We);
    }, Ve.prototype.subn = function(We) {
      return this.clone().isubn(We);
    }, Ve.prototype.iabs = function() {
      return (this || _global$z).negative = 0, this || _global$z;
    }, Ve.prototype.abs = function() {
      return this.clone().iabs();
    }, Ve.prototype._ishlnsubmul = function(We, Xe, rt) {
      var ot = We.length + rt, ft;
      this._expand(ot);
      var mt, yt = 0;
      for (ft = 0; ft < We.length; ft++) {
        mt = ((this || _global$z).words[ft + rt] | 0) + yt;
        var pt = (We.words[ft] | 0) * Xe;
        mt -= pt & 67108863, yt = (mt >> 26) - (pt / 67108864 | 0), (this || _global$z).words[ft + rt] = mt & 67108863;
      }
      for (; ft < (this || _global$z).length - rt; ft++)
        mt = ((this || _global$z).words[ft + rt] | 0) + yt, yt = mt >> 26, (this || _global$z).words[ft + rt] = mt & 67108863;
      if (yt === 0)
        return this.strip();
      for (Fe(yt === -1), yt = 0, ft = 0; ft < (this || _global$z).length; ft++)
        mt = -((this || _global$z).words[ft] | 0) + yt, yt = mt >> 26, (this || _global$z).words[ft] = mt & 67108863;
      return (this || _global$z).negative = 1, this.strip();
    }, Ve.prototype._wordDiv = function(We, Xe) {
      var rt = (this || _global$z).length - We.length, ot = this.clone(), ft = We, mt = ft.words[ft.length - 1] | 0, yt = this._countBits(mt);
      rt = 26 - yt, rt !== 0 && (ft = ft.ushln(rt), ot.iushln(rt), mt = ft.words[ft.length - 1] | 0);
      var pt = ot.length - ft.length, Ge;
      if (Xe !== "mod") {
        Ge = new Ve(null), Ge.length = pt + 1, Ge.words = new Array(Ge.length);
        for (var ct = 0; ct < Ge.length; ct++)
          Ge.words[ct] = 0;
      }
      var Mt = ot.clone()._ishlnsubmul(ft, 1, pt);
      Mt.negative === 0 && (ot = Mt, Ge && (Ge.words[pt] = 1));
      for (var St = pt - 1; St >= 0; St--) {
        var At = (ot.words[ft.length + St] | 0) * 67108864 + (ot.words[ft.length + St - 1] | 0);
        for (At = Math.min(At / mt | 0, 67108863), ot._ishlnsubmul(ft, At, St); ot.negative !== 0; )
          At--, ot.negative = 0, ot._ishlnsubmul(ft, 1, St), ot.isZero() || (ot.negative ^= 1);
        Ge && (Ge.words[St] = At);
      }
      return Ge && Ge.strip(), ot.strip(), Xe !== "div" && rt !== 0 && ot.iushrn(rt), {
        div: Ge || null,
        mod: ot
      };
    }, Ve.prototype.divmod = function(We, Xe, rt) {
      if (Fe(!We.isZero()), this.isZero())
        return {
          div: new Ve(0),
          mod: new Ve(0)
        };
      var ot, ft, mt;
      return (this || _global$z).negative !== 0 && We.negative === 0 ? (mt = this.neg().divmod(We, Xe), Xe !== "mod" && (ot = mt.div.neg()), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.iadd(We)), {
        div: ot,
        mod: ft
      }) : (this || _global$z).negative === 0 && We.negative !== 0 ? (mt = this.divmod(We.neg(), Xe), Xe !== "mod" && (ot = mt.div.neg()), {
        div: ot,
        mod: mt.mod
      }) : (this || _global$z).negative & We.negative ? (mt = this.neg().divmod(We.neg(), Xe), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.isub(We)), {
        div: mt.div,
        mod: ft
      }) : We.length > (this || _global$z).length || this.cmp(We) < 0 ? {
        div: new Ve(0),
        mod: this || _global$z
      } : We.length === 1 ? Xe === "div" ? {
        div: this.divn(We.words[0]),
        mod: null
      } : Xe === "mod" ? {
        div: null,
        mod: new Ve(this.modn(We.words[0]))
      } : {
        div: this.divn(We.words[0]),
        mod: new Ve(this.modn(We.words[0]))
      } : this._wordDiv(We, Xe);
    }, Ve.prototype.div = function(We) {
      return this.divmod(We, "div", !1).div;
    }, Ve.prototype.mod = function(We) {
      return this.divmod(We, "mod", !1).mod;
    }, Ve.prototype.umod = function(We) {
      return this.divmod(We, "mod", !0).mod;
    }, Ve.prototype.divRound = function(We) {
      var Xe = this.divmod(We);
      if (Xe.mod.isZero())
        return Xe.div;
      var rt = Xe.div.negative !== 0 ? Xe.mod.isub(We) : Xe.mod, ot = We.ushrn(1), ft = We.andln(1), mt = rt.cmp(ot);
      return mt < 0 || ft === 1 && mt === 0 ? Xe.div : Xe.div.negative !== 0 ? Xe.div.isubn(1) : Xe.div.iaddn(1);
    }, Ve.prototype.modn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = (1 << 26) % We, rt = 0, ot = (this || _global$z).length - 1; ot >= 0; ot--)
        rt = (Xe * rt + ((this || _global$z).words[ot] | 0)) % We;
      return rt;
    }, Ve.prototype.idivn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = 0, rt = (this || _global$z).length - 1; rt >= 0; rt--) {
        var ot = ((this || _global$z).words[rt] | 0) + Xe * 67108864;
        (this || _global$z).words[rt] = ot / We | 0, Xe = ot % We;
      }
      return this.strip();
    }, Ve.prototype.divn = function(We) {
      return this.clone().idivn(We);
    }, Ve.prototype.egcd = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$z, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = new Ve(0), yt = new Ve(1), pt = 0; Xe.isEven() && rt.isEven(); )
        Xe.iushrn(1), rt.iushrn(1), ++pt;
      for (var Ge = rt.clone(), ct = Xe.clone(); !Xe.isZero(); ) {
        for (var Mt = 0, St = 1; !(Xe.words[0] & St) && Mt < 26; ++Mt, St <<= 1)
          ;
        if (Mt > 0)
          for (Xe.iushrn(Mt); Mt-- > 0; )
            (ot.isOdd() || ft.isOdd()) && (ot.iadd(Ge), ft.isub(ct)), ot.iushrn(1), ft.iushrn(1);
        for (var At = 0, Nt = 1; !(rt.words[0] & Nt) && At < 26; ++At, Nt <<= 1)
          ;
        if (At > 0)
          for (rt.iushrn(At); At-- > 0; )
            (mt.isOdd() || yt.isOdd()) && (mt.iadd(Ge), yt.isub(ct)), mt.iushrn(1), yt.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(mt), ft.isub(yt)) : (rt.isub(Xe), mt.isub(ot), yt.isub(ft));
      }
      return {
        a: mt,
        b: yt,
        gcd: rt.iushln(pt)
      };
    }, Ve.prototype._invmp = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$z, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = rt.clone(); Xe.cmpn(1) > 0 && rt.cmpn(1) > 0; ) {
        for (var yt = 0, pt = 1; !(Xe.words[0] & pt) && yt < 26; ++yt, pt <<= 1)
          ;
        if (yt > 0)
          for (Xe.iushrn(yt); yt-- > 0; )
            ot.isOdd() && ot.iadd(mt), ot.iushrn(1);
        for (var Ge = 0, ct = 1; !(rt.words[0] & ct) && Ge < 26; ++Ge, ct <<= 1)
          ;
        if (Ge > 0)
          for (rt.iushrn(Ge); Ge-- > 0; )
            ft.isOdd() && ft.iadd(mt), ft.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(ft)) : (rt.isub(Xe), ft.isub(ot));
      }
      var Mt;
      return Xe.cmpn(1) === 0 ? Mt = ot : Mt = ft, Mt.cmpn(0) < 0 && Mt.iadd(We), Mt;
    }, Ve.prototype.gcd = function(We) {
      if (this.isZero())
        return We.abs();
      if (We.isZero())
        return this.abs();
      var Xe = this.clone(), rt = We.clone();
      Xe.negative = 0, rt.negative = 0;
      for (var ot = 0; Xe.isEven() && rt.isEven(); ot++)
        Xe.iushrn(1), rt.iushrn(1);
      do {
        for (; Xe.isEven(); )
          Xe.iushrn(1);
        for (; rt.isEven(); )
          rt.iushrn(1);
        var ft = Xe.cmp(rt);
        if (ft < 0) {
          var mt = Xe;
          Xe = rt, rt = mt;
        } else if (ft === 0 || rt.cmpn(1) === 0)
          break;
        Xe.isub(rt);
      } while (!0);
      return rt.iushln(ot);
    }, Ve.prototype.invm = function(We) {
      return this.egcd(We).a.umod(We);
    }, Ve.prototype.isEven = function() {
      return ((this || _global$z).words[0] & 1) === 0;
    }, Ve.prototype.isOdd = function() {
      return ((this || _global$z).words[0] & 1) === 1;
    }, Ve.prototype.andln = function(We) {
      return (this || _global$z).words[0] & We;
    }, Ve.prototype.bincn = function(We) {
      Fe(typeof We == "number");
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$z).length <= rt)
        return this._expand(rt + 1), (this || _global$z).words[rt] |= ot, this || _global$z;
      for (var ft = ot, mt = rt; ft !== 0 && mt < (this || _global$z).length; mt++) {
        var yt = (this || _global$z).words[mt] | 0;
        yt += ft, ft = yt >>> 26, yt &= 67108863, (this || _global$z).words[mt] = yt;
      }
      return ft !== 0 && ((this || _global$z).words[mt] = ft, (this || _global$z).length++), this || _global$z;
    }, Ve.prototype.isZero = function() {
      return (this || _global$z).length === 1 && (this || _global$z).words[0] === 0;
    }, Ve.prototype.cmpn = function(We) {
      var Xe = We < 0;
      if ((this || _global$z).negative !== 0 && !Xe)
        return -1;
      if ((this || _global$z).negative === 0 && Xe)
        return 1;
      this.strip();
      var rt;
      if ((this || _global$z).length > 1)
        rt = 1;
      else {
        Xe && (We = -We), Fe(We <= 67108863, "Number is too big");
        var ot = (this || _global$z).words[0] | 0;
        rt = ot === We ? 0 : ot < We ? -1 : 1;
      }
      return (this || _global$z).negative !== 0 ? -rt | 0 : rt;
    }, Ve.prototype.cmp = function(We) {
      if ((this || _global$z).negative !== 0 && We.negative === 0)
        return -1;
      if ((this || _global$z).negative === 0 && We.negative !== 0)
        return 1;
      var Xe = this.ucmp(We);
      return (this || _global$z).negative !== 0 ? -Xe | 0 : Xe;
    }, Ve.prototype.ucmp = function(We) {
      if ((this || _global$z).length > We.length)
        return 1;
      if ((this || _global$z).length < We.length)
        return -1;
      for (var Xe = 0, rt = (this || _global$z).length - 1; rt >= 0; rt--) {
        var ot = (this || _global$z).words[rt] | 0, ft = We.words[rt] | 0;
        if (ot !== ft) {
          ot < ft ? Xe = -1 : ot > ft && (Xe = 1);
          break;
        }
      }
      return Xe;
    }, Ve.prototype.gtn = function(We) {
      return this.cmpn(We) === 1;
    }, Ve.prototype.gt = function(We) {
      return this.cmp(We) === 1;
    }, Ve.prototype.gten = function(We) {
      return this.cmpn(We) >= 0;
    }, Ve.prototype.gte = function(We) {
      return this.cmp(We) >= 0;
    }, Ve.prototype.ltn = function(We) {
      return this.cmpn(We) === -1;
    }, Ve.prototype.lt = function(We) {
      return this.cmp(We) === -1;
    }, Ve.prototype.lten = function(We) {
      return this.cmpn(We) <= 0;
    }, Ve.prototype.lte = function(We) {
      return this.cmp(We) <= 0;
    }, Ve.prototype.eqn = function(We) {
      return this.cmpn(We) === 0;
    }, Ve.prototype.eq = function(We) {
      return this.cmp(We) === 0;
    }, Ve.red = function(We) {
      return new Ot(We);
    }, Ve.prototype.toRed = function(We) {
      return Fe(!(this || _global$z).red, "Already a number in reduction context"), Fe((this || _global$z).negative === 0, "red works only with positives"), We.convertTo(this || _global$z)._forceRed(We);
    }, Ve.prototype.fromRed = function() {
      return Fe((this || _global$z).red, "fromRed works only with numbers in reduction context"), (this || _global$z).red.convertFrom(this || _global$z);
    }, Ve.prototype._forceRed = function(We) {
      return (this || _global$z).red = We, this || _global$z;
    }, Ve.prototype.forceRed = function(We) {
      return Fe(!(this || _global$z).red, "Already a number in reduction context"), this._forceRed(We);
    }, Ve.prototype.redAdd = function(We) {
      return Fe((this || _global$z).red, "redAdd works only with red numbers"), (this || _global$z).red.add(this || _global$z, We);
    }, Ve.prototype.redIAdd = function(We) {
      return Fe((this || _global$z).red, "redIAdd works only with red numbers"), (this || _global$z).red.iadd(this || _global$z, We);
    }, Ve.prototype.redSub = function(We) {
      return Fe((this || _global$z).red, "redSub works only with red numbers"), (this || _global$z).red.sub(this || _global$z, We);
    }, Ve.prototype.redISub = function(We) {
      return Fe((this || _global$z).red, "redISub works only with red numbers"), (this || _global$z).red.isub(this || _global$z, We);
    }, Ve.prototype.redShl = function(We) {
      return Fe((this || _global$z).red, "redShl works only with red numbers"), (this || _global$z).red.shl(this || _global$z, We);
    }, Ve.prototype.redMul = function(We) {
      return Fe((this || _global$z).red, "redMul works only with red numbers"), (this || _global$z).red._verify2(this || _global$z, We), (this || _global$z).red.mul(this || _global$z, We);
    }, Ve.prototype.redIMul = function(We) {
      return Fe((this || _global$z).red, "redMul works only with red numbers"), (this || _global$z).red._verify2(this || _global$z, We), (this || _global$z).red.imul(this || _global$z, We);
    }, Ve.prototype.redSqr = function() {
      return Fe((this || _global$z).red, "redSqr works only with red numbers"), (this || _global$z).red._verify1(this || _global$z), (this || _global$z).red.sqr(this || _global$z);
    }, Ve.prototype.redISqr = function() {
      return Fe((this || _global$z).red, "redISqr works only with red numbers"), (this || _global$z).red._verify1(this || _global$z), (this || _global$z).red.isqr(this || _global$z);
    }, Ve.prototype.redSqrt = function() {
      return Fe((this || _global$z).red, "redSqrt works only with red numbers"), (this || _global$z).red._verify1(this || _global$z), (this || _global$z).red.sqrt(this || _global$z);
    }, Ve.prototype.redInvm = function() {
      return Fe((this || _global$z).red, "redInvm works only with red numbers"), (this || _global$z).red._verify1(this || _global$z), (this || _global$z).red.invm(this || _global$z);
    }, Ve.prototype.redNeg = function() {
      return Fe((this || _global$z).red, "redNeg works only with red numbers"), (this || _global$z).red._verify1(this || _global$z), (this || _global$z).red.neg(this || _global$z);
    }, Ve.prototype.redPow = function(We) {
      return Fe((this || _global$z).red && !We.red, "redPow(normalNum)"), (this || _global$z).red._verify1(this || _global$z), (this || _global$z).red.pow(this || _global$z, We);
    };
    var Rt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ct(gt, We) {
      (this || _global$z).name = gt, (this || _global$z).p = new Ve(We, 16), (this || _global$z).n = (this || _global$z).p.bitLength(), (this || _global$z).k = new Ve(1).iushln((this || _global$z).n).isub((this || _global$z).p), (this || _global$z).tmp = this._tmp();
    }
    Ct.prototype._tmp = function() {
      var We = new Ve(null);
      return We.words = new Array(Math.ceil((this || _global$z).n / 13)), We;
    }, Ct.prototype.ireduce = function(We) {
      var Xe = We, rt;
      do
        this.split(Xe, (this || _global$z).tmp), Xe = this.imulK(Xe), Xe = Xe.iadd((this || _global$z).tmp), rt = Xe.bitLength();
      while (rt > (this || _global$z).n);
      var ot = rt < (this || _global$z).n ? -1 : Xe.ucmp((this || _global$z).p);
      return ot === 0 ? (Xe.words[0] = 0, Xe.length = 1) : ot > 0 ? Xe.isub((this || _global$z).p) : Xe.strip !== void 0 ? Xe.strip() : Xe._strip(), Xe;
    }, Ct.prototype.split = function(We, Xe) {
      We.iushrn((this || _global$z).n, 0, Xe);
    }, Ct.prototype.imulK = function(We) {
      return We.imul((this || _global$z).k);
    };
    function Zt() {
      Ct.call(this || _global$z, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    Ke(Zt, Ct), Zt.prototype.split = function(We, Xe) {
      for (var rt = 4194303, ot = Math.min(We.length, 9), ft = 0; ft < ot; ft++)
        Xe.words[ft] = We.words[ft];
      if (Xe.length = ot, We.length <= 9) {
        We.words[0] = 0, We.length = 1;
        return;
      }
      var mt = We.words[9];
      for (Xe.words[Xe.length++] = mt & rt, ft = 10; ft < We.length; ft++) {
        var yt = We.words[ft] | 0;
        We.words[ft - 10] = (yt & rt) << 4 | mt >>> 22, mt = yt;
      }
      mt >>>= 22, We.words[ft - 10] = mt, mt === 0 && We.length > 10 ? We.length -= 10 : We.length -= 9;
    }, Zt.prototype.imulK = function(We) {
      We.words[We.length] = 0, We.words[We.length + 1] = 0, We.length += 2;
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = We.words[rt] | 0;
        Xe += ot * 977, We.words[rt] = Xe & 67108863, Xe = ot * 64 + (Xe / 67108864 | 0);
      }
      return We.words[We.length - 1] === 0 && (We.length--, We.words[We.length - 1] === 0 && We.length--), We;
    };
    function Lt() {
      Ct.call(this || _global$z, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    Ke(Lt, Ct);
    function Ut() {
      Ct.call(this || _global$z, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    Ke(Ut, Ct);
    function Pt() {
      Ct.call(this || _global$z, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    Ke(Pt, Ct), Pt.prototype.imulK = function(We) {
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = (We.words[rt] | 0) * 19 + Xe, ft = ot & 67108863;
        ot >>>= 26, We.words[rt] = ft, Xe = ot;
      }
      return Xe !== 0 && (We.words[We.length++] = Xe), We;
    }, Ve._prime = function(We) {
      if (Rt[We])
        return Rt[We];
      var Xe;
      if (We === "k256")
        Xe = new Zt();
      else if (We === "p224")
        Xe = new Lt();
      else if (We === "p192")
        Xe = new Ut();
      else if (We === "p25519")
        Xe = new Pt();
      else
        throw new Error("Unknown prime " + We);
      return Rt[We] = Xe, Xe;
    };
    function Ot(gt) {
      if (typeof gt == "string") {
        var We = Ve._prime(gt);
        (this || _global$z).m = We.p, (this || _global$z).prime = We;
      } else
        Fe(gt.gtn(1), "modulus must be greater than 1"), (this || _global$z).m = gt, (this || _global$z).prime = null;
    }
    Ot.prototype._verify1 = function(We) {
      Fe(We.negative === 0, "red works only with positives"), Fe(We.red, "red works only with red numbers");
    }, Ot.prototype._verify2 = function(We, Xe) {
      Fe((We.negative | Xe.negative) === 0, "red works only with positives"), Fe(We.red && We.red === Xe.red, "red works only with red numbers");
    }, Ot.prototype.imod = function(We) {
      return (this || _global$z).prime ? (this || _global$z).prime.ireduce(We)._forceRed(this || _global$z) : We.umod((this || _global$z).m)._forceRed(this || _global$z);
    }, Ot.prototype.neg = function(We) {
      return We.isZero() ? We.clone() : (this || _global$z).m.sub(We)._forceRed(this || _global$z);
    }, Ot.prototype.add = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.add(Xe);
      return rt.cmp((this || _global$z).m) >= 0 && rt.isub((this || _global$z).m), rt._forceRed(this || _global$z);
    }, Ot.prototype.iadd = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.iadd(Xe);
      return rt.cmp((this || _global$z).m) >= 0 && rt.isub((this || _global$z).m), rt;
    }, Ot.prototype.sub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.sub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$z).m), rt._forceRed(this || _global$z);
    }, Ot.prototype.isub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.isub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$z).m), rt;
    }, Ot.prototype.shl = function(We, Xe) {
      return this._verify1(We), this.imod(We.ushln(Xe));
    }, Ot.prototype.imul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.imul(Xe));
    }, Ot.prototype.mul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.mul(Xe));
    }, Ot.prototype.isqr = function(We) {
      return this.imul(We, We.clone());
    }, Ot.prototype.sqr = function(We) {
      return this.mul(We, We);
    }, Ot.prototype.sqrt = function(We) {
      if (We.isZero())
        return We.clone();
      var Xe = (this || _global$z).m.andln(3);
      if (Fe(Xe % 2 === 1), Xe === 3) {
        var rt = (this || _global$z).m.add(new Ve(1)).iushrn(2);
        return this.pow(We, rt);
      }
      for (var ot = (this || _global$z).m.subn(1), ft = 0; !ot.isZero() && ot.andln(1) === 0; )
        ft++, ot.iushrn(1);
      Fe(!ot.isZero());
      var mt = new Ve(1).toRed(this || _global$z), yt = mt.redNeg(), pt = (this || _global$z).m.subn(1).iushrn(1), Ge = (this || _global$z).m.bitLength();
      for (Ge = new Ve(2 * Ge * Ge).toRed(this || _global$z); this.pow(Ge, pt).cmp(yt) !== 0; )
        Ge.redIAdd(yt);
      for (var ct = this.pow(Ge, ot), Mt = this.pow(We, ot.addn(1).iushrn(1)), St = this.pow(We, ot), At = ft; St.cmp(mt) !== 0; ) {
        for (var Nt = St, qt = 0; Nt.cmp(mt) !== 0; qt++)
          Nt = Nt.redSqr();
        Fe(qt < At);
        var Qt = this.pow(ct, new Ve(1).iushln(At - qt - 1));
        Mt = Mt.redMul(Qt), ct = Qt.redSqr(), St = St.redMul(ct), At = qt;
      }
      return Mt;
    }, Ot.prototype.invm = function(We) {
      var Xe = We._invmp((this || _global$z).m);
      return Xe.negative !== 0 ? (Xe.negative = 0, this.imod(Xe).redNeg()) : this.imod(Xe);
    }, Ot.prototype.pow = function(We, Xe) {
      if (Xe.isZero())
        return new Ve(1).toRed(this || _global$z);
      if (Xe.cmpn(1) === 0)
        return We.clone();
      var rt = 4, ot = new Array(1 << rt);
      ot[0] = new Ve(1).toRed(this || _global$z), ot[1] = We;
      for (var ft = 2; ft < ot.length; ft++)
        ot[ft] = this.mul(ot[ft - 1], We);
      var mt = ot[0], yt = 0, pt = 0, Ge = Xe.bitLength() % 26;
      for (Ge === 0 && (Ge = 26), ft = Xe.length - 1; ft >= 0; ft--) {
        for (var ct = Xe.words[ft], Mt = Ge - 1; Mt >= 0; Mt--) {
          var St = ct >> Mt & 1;
          if (mt !== ot[0] && (mt = this.sqr(mt)), St === 0 && yt === 0) {
            pt = 0;
            continue;
          }
          yt <<= 1, yt |= St, pt++, !(pt !== rt && (ft !== 0 || Mt !== 0)) && (mt = this.mul(mt, ot[yt]), pt = 0, yt = 0);
        }
        Ge = 26;
      }
      return mt;
    }, Ot.prototype.convertTo = function(We) {
      var Xe = We.umod((this || _global$z).m);
      return Xe === We ? Xe.clone() : Xe;
    }, Ot.prototype.convertFrom = function(We) {
      var Xe = We.clone();
      return Xe.red = null, Xe;
    }, Ve.mont = function(We) {
      return new Ft(We);
    };
    function Ft(gt) {
      Ot.call(this || _global$z, gt), (this || _global$z).shift = (this || _global$z).m.bitLength(), (this || _global$z).shift % 26 !== 0 && ((this || _global$z).shift += 26 - (this || _global$z).shift % 26), (this || _global$z).r = new Ve(1).iushln((this || _global$z).shift), (this || _global$z).r2 = this.imod((this || _global$z).r.sqr()), (this || _global$z).rinv = (this || _global$z).r._invmp((this || _global$z).m), (this || _global$z).minv = (this || _global$z).rinv.mul((this || _global$z).r).isubn(1).div((this || _global$z).m), (this || _global$z).minv = (this || _global$z).minv.umod((this || _global$z).r), (this || _global$z).minv = (this || _global$z).r.sub((this || _global$z).minv);
    }
    Ke(Ft, Ot), Ft.prototype.convertTo = function(We) {
      return this.imod(We.ushln((this || _global$z).shift));
    }, Ft.prototype.convertFrom = function(We) {
      var Xe = this.imod(We.mul((this || _global$z).rinv));
      return Xe.red = null, Xe;
    }, Ft.prototype.imul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return We.words[0] = 0, We.length = 1, We;
      var rt = We.imul(Xe), ot = rt.maskn((this || _global$z).shift).mul((this || _global$z).minv).imaskn((this || _global$z).shift).mul((this || _global$z).m), ft = rt.isub(ot).iushrn((this || _global$z).shift), mt = ft;
      return ft.cmp((this || _global$z).m) >= 0 ? mt = ft.isub((this || _global$z).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$z).m)), mt._forceRed(this || _global$z);
    }, Ft.prototype.mul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return new Ve(0)._forceRed(this || _global$z);
      var rt = We.mul(Xe), ot = rt.maskn((this || _global$z).shift).mul((this || _global$z).minv).imaskn((this || _global$z).shift).mul((this || _global$z).m), ft = rt.isub(ot).iushrn((this || _global$z).shift), mt = ft;
      return ft.cmp((this || _global$z).m) >= 0 ? mt = ft.isub((this || _global$z).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$z).m)), mt._forceRed(this || _global$z);
    }, Ft.prototype.invm = function(We) {
      var Xe = this.imod(We._invmp((this || _global$z).m).mul((this || _global$z).r2));
      return Xe._forceRed(this || _global$z);
    };
  }(module$a, exports$1Y)), module$a.exports;
}
var exports$1X = {}, _dewExec$1W = !1, module$9 = {
  exports: exports$1X
}, _global$y = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1W() {
  return _dewExec$1W || (_dewExec$1W = !0, function($e, Ze) {
    function Fe(gt, We) {
      if (!gt)
        throw new Error(We || "Assertion failed");
    }
    function Ke(gt, We) {
      gt.super_ = We;
      var Xe = function() {
      };
      Xe.prototype = We.prototype, gt.prototype = new Xe(), gt.prototype.constructor = gt;
    }
    function Ve(gt, We, Xe) {
      if (Ve.isBN(gt))
        return gt;
      (this || _global$y).negative = 0, (this || _global$y).words = null, (this || _global$y).length = 0, (this || _global$y).red = null, gt !== null && ((We === "le" || We === "be") && (Xe = We, We = 10), this._init(gt || 0, We || 10, Xe || "be"));
    }
    typeof $e == "object" ? $e.exports = Ve : Ze.BN = Ve, Ve.BN = Ve, Ve.wordSize = 26;
    var Je;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Je = window.Buffer : Je = buffer.Buffer;
    } catch {
    }
    Ve.isBN = function(We) {
      return We instanceof Ve ? !0 : We !== null && typeof We == "object" && We.constructor.wordSize === Ve.wordSize && Array.isArray(We.words);
    }, Ve.max = function(We, Xe) {
      return We.cmp(Xe) > 0 ? We : Xe;
    }, Ve.min = function(We, Xe) {
      return We.cmp(Xe) < 0 ? We : Xe;
    }, Ve.prototype._init = function(We, Xe, rt) {
      if (typeof We == "number")
        return this._initNumber(We, Xe, rt);
      if (typeof We == "object")
        return this._initArray(We, Xe, rt);
      Xe === "hex" && (Xe = 16), Fe(Xe === (Xe | 0) && Xe >= 2 && Xe <= 36), We = We.toString().replace(/\s+/g, "");
      var ot = 0;
      We[0] === "-" && (ot++, (this || _global$y).negative = 1), ot < We.length && (Xe === 16 ? this._parseHex(We, ot, rt) : (this._parseBase(We, Xe, ot), rt === "le" && this._initArray(this.toArray(), Xe, rt)));
    }, Ve.prototype._initNumber = function(We, Xe, rt) {
      We < 0 && ((this || _global$y).negative = 1, We = -We), We < 67108864 ? ((this || _global$y).words = [We & 67108863], (this || _global$y).length = 1) : We < 4503599627370496 ? ((this || _global$y).words = [We & 67108863, We / 67108864 & 67108863], (this || _global$y).length = 2) : (Fe(We < 9007199254740992), (this || _global$y).words = [We & 67108863, We / 67108864 & 67108863, 1], (this || _global$y).length = 3), rt === "le" && this._initArray(this.toArray(), Xe, rt);
    }, Ve.prototype._initArray = function(We, Xe, rt) {
      if (Fe(typeof We.length == "number"), We.length <= 0)
        return (this || _global$y).words = [0], (this || _global$y).length = 1, this || _global$y;
      (this || _global$y).length = Math.ceil(We.length / 3), (this || _global$y).words = new Array((this || _global$y).length);
      for (var ot = 0; ot < (this || _global$y).length; ot++)
        (this || _global$y).words[ot] = 0;
      var ft, mt, yt = 0;
      if (rt === "be")
        for (ot = We.length - 1, ft = 0; ot >= 0; ot -= 3)
          mt = We[ot] | We[ot - 1] << 8 | We[ot - 2] << 16, (this || _global$y).words[ft] |= mt << yt & 67108863, (this || _global$y).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      else if (rt === "le")
        for (ot = 0, ft = 0; ot < We.length; ot += 3)
          mt = We[ot] | We[ot + 1] << 8 | We[ot + 2] << 16, (this || _global$y).words[ft] |= mt << yt & 67108863, (this || _global$y).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      return this.strip();
    };
    function Qe(gt, We) {
      var Xe = gt.charCodeAt(We);
      return Xe >= 65 && Xe <= 70 ? Xe - 55 : Xe >= 97 && Xe <= 102 ? Xe - 87 : Xe - 48 & 15;
    }
    function at(gt, We, Xe) {
      var rt = Qe(gt, Xe);
      return Xe - 1 >= We && (rt |= Qe(gt, Xe - 1) << 4), rt;
    }
    Ve.prototype._parseHex = function(We, Xe, rt) {
      (this || _global$y).length = Math.ceil((We.length - Xe) / 6), (this || _global$y).words = new Array((this || _global$y).length);
      for (var ot = 0; ot < (this || _global$y).length; ot++)
        (this || _global$y).words[ot] = 0;
      var ft = 0, mt = 0, yt;
      if (rt === "be")
        for (ot = We.length - 1; ot >= Xe; ot -= 2)
          yt = at(We, Xe, ot) << ft, (this || _global$y).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$y).words[mt] |= yt >>> 26) : ft += 8;
      else {
        var pt = We.length - Xe;
        for (ot = pt % 2 === 0 ? Xe + 1 : Xe; ot < We.length; ot += 2)
          yt = at(We, Xe, ot) << ft, (this || _global$y).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$y).words[mt] |= yt >>> 26) : ft += 8;
      }
      this.strip();
    };
    function ut(gt, We, Xe, rt) {
      for (var ot = 0, ft = Math.min(gt.length, Xe), mt = We; mt < ft; mt++) {
        var yt = gt.charCodeAt(mt) - 48;
        ot *= rt, yt >= 49 ? ot += yt - 49 + 10 : yt >= 17 ? ot += yt - 17 + 10 : ot += yt;
      }
      return ot;
    }
    Ve.prototype._parseBase = function(We, Xe, rt) {
      (this || _global$y).words = [0], (this || _global$y).length = 1;
      for (var ot = 0, ft = 1; ft <= 67108863; ft *= Xe)
        ot++;
      ot--, ft = ft / Xe | 0;
      for (var mt = We.length - rt, yt = mt % ot, pt = Math.min(mt, mt - yt) + rt, Ge = 0, ct = rt; ct < pt; ct += ot)
        Ge = ut(We, ct, ct + ot, Xe), this.imuln(ft), (this || _global$y).words[0] + Ge < 67108864 ? (this || _global$y).words[0] += Ge : this._iaddn(Ge);
      if (yt !== 0) {
        var Mt = 1;
        for (Ge = ut(We, ct, We.length, Xe), ct = 0; ct < yt; ct++)
          Mt *= Xe;
        this.imuln(Mt), (this || _global$y).words[0] + Ge < 67108864 ? (this || _global$y).words[0] += Ge : this._iaddn(Ge);
      }
      this.strip();
    }, Ve.prototype.copy = function(We) {
      We.words = new Array((this || _global$y).length);
      for (var Xe = 0; Xe < (this || _global$y).length; Xe++)
        We.words[Xe] = (this || _global$y).words[Xe];
      We.length = (this || _global$y).length, We.negative = (this || _global$y).negative, We.red = (this || _global$y).red;
    }, Ve.prototype.clone = function() {
      var We = new Ve(null);
      return this.copy(We), We;
    }, Ve.prototype._expand = function(We) {
      for (; (this || _global$y).length < We; )
        (this || _global$y).words[(this || _global$y).length++] = 0;
      return this || _global$y;
    }, Ve.prototype.strip = function() {
      for (; (this || _global$y).length > 1 && (this || _global$y).words[(this || _global$y).length - 1] === 0; )
        (this || _global$y).length--;
      return this._normSign();
    }, Ve.prototype._normSign = function() {
      return (this || _global$y).length === 1 && (this || _global$y).words[0] === 0 && ((this || _global$y).negative = 0), this || _global$y;
    }, Ve.prototype.inspect = function() {
      return ((this || _global$y).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var lt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], dt = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], bt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    Ve.prototype.toString = function(We, Xe) {
      We = We || 10, Xe = Xe | 0 || 1;
      var rt;
      if (We === 16 || We === "hex") {
        rt = "";
        for (var ot = 0, ft = 0, mt = 0; mt < (this || _global$y).length; mt++) {
          var yt = (this || _global$y).words[mt], pt = ((yt << ot | ft) & 16777215).toString(16);
          ft = yt >>> 24 - ot & 16777215, ft !== 0 || mt !== (this || _global$y).length - 1 ? rt = lt[6 - pt.length] + pt + rt : rt = pt + rt, ot += 2, ot >= 26 && (ot -= 26, mt--);
        }
        for (ft !== 0 && (rt = ft.toString(16) + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$y).negative !== 0 && (rt = "-" + rt), rt;
      }
      if (We === (We | 0) && We >= 2 && We <= 36) {
        var Ge = dt[We], ct = bt[We];
        rt = "";
        var Mt = this.clone();
        for (Mt.negative = 0; !Mt.isZero(); ) {
          var St = Mt.modn(ct).toString(We);
          Mt = Mt.idivn(ct), Mt.isZero() ? rt = St + rt : rt = lt[Ge - St.length] + St + rt;
        }
        for (this.isZero() && (rt = "0" + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$y).negative !== 0 && (rt = "-" + rt), rt;
      }
      Fe(!1, "Base should be between 2 and 36");
    }, Ve.prototype.toNumber = function() {
      var We = (this || _global$y).words[0];
      return (this || _global$y).length === 2 ? We += (this || _global$y).words[1] * 67108864 : (this || _global$y).length === 3 && (this || _global$y).words[2] === 1 ? We += 4503599627370496 + (this || _global$y).words[1] * 67108864 : (this || _global$y).length > 2 && Fe(!1, "Number can only safely store up to 53 bits"), (this || _global$y).negative !== 0 ? -We : We;
    }, Ve.prototype.toJSON = function() {
      return this.toString(16);
    }, Ve.prototype.toBuffer = function(We, Xe) {
      return Fe(typeof Je < "u"), this.toArrayLike(Je, We, Xe);
    }, Ve.prototype.toArray = function(We, Xe) {
      return this.toArrayLike(Array, We, Xe);
    }, Ve.prototype.toArrayLike = function(We, Xe, rt) {
      var ot = this.byteLength(), ft = rt || Math.max(1, ot);
      Fe(ot <= ft, "byte array longer than desired length"), Fe(ft > 0, "Requested array length <= 0"), this.strip();
      var mt = Xe === "le", yt = new We(ft), pt, Ge, ct = this.clone();
      if (mt) {
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[Ge] = pt;
        for (; Ge < ft; Ge++)
          yt[Ge] = 0;
      } else {
        for (Ge = 0; Ge < ft - ot; Ge++)
          yt[Ge] = 0;
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[ft - Ge - 1] = pt;
      }
      return yt;
    }, Math.clz32 ? Ve.prototype._countBits = function(We) {
      return 32 - Math.clz32(We);
    } : Ve.prototype._countBits = function(We) {
      var Xe = We, rt = 0;
      return Xe >= 4096 && (rt += 13, Xe >>>= 13), Xe >= 64 && (rt += 7, Xe >>>= 7), Xe >= 8 && (rt += 4, Xe >>>= 4), Xe >= 2 && (rt += 2, Xe >>>= 2), rt + Xe;
    }, Ve.prototype._zeroBits = function(We) {
      if (We === 0)
        return 26;
      var Xe = We, rt = 0;
      return Xe & 8191 || (rt += 13, Xe >>>= 13), Xe & 127 || (rt += 7, Xe >>>= 7), Xe & 15 || (rt += 4, Xe >>>= 4), Xe & 3 || (rt += 2, Xe >>>= 2), Xe & 1 || rt++, rt;
    }, Ve.prototype.bitLength = function() {
      var We = (this || _global$y).words[(this || _global$y).length - 1], Xe = this._countBits(We);
      return ((this || _global$y).length - 1) * 26 + Xe;
    };
    function $t(gt) {
      for (var We = new Array(gt.bitLength()), Xe = 0; Xe < We.length; Xe++) {
        var rt = Xe / 26 | 0, ot = Xe % 26;
        We[Xe] = (gt.words[rt] & 1 << ot) >>> ot;
      }
      return We;
    }
    Ve.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var We = 0, Xe = 0; Xe < (this || _global$y).length; Xe++) {
        var rt = this._zeroBits((this || _global$y).words[Xe]);
        if (We += rt, rt !== 26)
          break;
      }
      return We;
    }, Ve.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Ve.prototype.toTwos = function(We) {
      return (this || _global$y).negative !== 0 ? this.abs().inotn(We).iaddn(1) : this.clone();
    }, Ve.prototype.fromTwos = function(We) {
      return this.testn(We - 1) ? this.notn(We).iaddn(1).ineg() : this.clone();
    }, Ve.prototype.isNeg = function() {
      return (this || _global$y).negative !== 0;
    }, Ve.prototype.neg = function() {
      return this.clone().ineg();
    }, Ve.prototype.ineg = function() {
      return this.isZero() || ((this || _global$y).negative ^= 1), this || _global$y;
    }, Ve.prototype.iuor = function(We) {
      for (; (this || _global$y).length < We.length; )
        (this || _global$y).words[(this || _global$y).length++] = 0;
      for (var Xe = 0; Xe < We.length; Xe++)
        (this || _global$y).words[Xe] = (this || _global$y).words[Xe] | We.words[Xe];
      return this.strip();
    }, Ve.prototype.ior = function(We) {
      return Fe(((this || _global$y).negative | We.negative) === 0), this.iuor(We);
    }, Ve.prototype.or = function(We) {
      return (this || _global$y).length > We.length ? this.clone().ior(We) : We.clone().ior(this || _global$y);
    }, Ve.prototype.uor = function(We) {
      return (this || _global$y).length > We.length ? this.clone().iuor(We) : We.clone().iuor(this || _global$y);
    }, Ve.prototype.iuand = function(We) {
      var Xe;
      (this || _global$y).length > We.length ? Xe = We : Xe = this || _global$y;
      for (var rt = 0; rt < Xe.length; rt++)
        (this || _global$y).words[rt] = (this || _global$y).words[rt] & We.words[rt];
      return (this || _global$y).length = Xe.length, this.strip();
    }, Ve.prototype.iand = function(We) {
      return Fe(((this || _global$y).negative | We.negative) === 0), this.iuand(We);
    }, Ve.prototype.and = function(We) {
      return (this || _global$y).length > We.length ? this.clone().iand(We) : We.clone().iand(this || _global$y);
    }, Ve.prototype.uand = function(We) {
      return (this || _global$y).length > We.length ? this.clone().iuand(We) : We.clone().iuand(this || _global$y);
    }, Ve.prototype.iuxor = function(We) {
      var Xe, rt;
      (this || _global$y).length > We.length ? (Xe = this || _global$y, rt = We) : (Xe = We, rt = this || _global$y);
      for (var ot = 0; ot < rt.length; ot++)
        (this || _global$y).words[ot] = Xe.words[ot] ^ rt.words[ot];
      if ((this || _global$y) !== Xe)
        for (; ot < Xe.length; ot++)
          (this || _global$y).words[ot] = Xe.words[ot];
      return (this || _global$y).length = Xe.length, this.strip();
    }, Ve.prototype.ixor = function(We) {
      return Fe(((this || _global$y).negative | We.negative) === 0), this.iuxor(We);
    }, Ve.prototype.xor = function(We) {
      return (this || _global$y).length > We.length ? this.clone().ixor(We) : We.clone().ixor(this || _global$y);
    }, Ve.prototype.uxor = function(We) {
      return (this || _global$y).length > We.length ? this.clone().iuxor(We) : We.clone().iuxor(this || _global$y);
    }, Ve.prototype.inotn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = Math.ceil(We / 26) | 0, rt = We % 26;
      this._expand(Xe), rt > 0 && Xe--;
      for (var ot = 0; ot < Xe; ot++)
        (this || _global$y).words[ot] = ~(this || _global$y).words[ot] & 67108863;
      return rt > 0 && ((this || _global$y).words[ot] = ~(this || _global$y).words[ot] & 67108863 >> 26 - rt), this.strip();
    }, Ve.prototype.notn = function(We) {
      return this.clone().inotn(We);
    }, Ve.prototype.setn = function(We, Xe) {
      Fe(typeof We == "number" && We >= 0);
      var rt = We / 26 | 0, ot = We % 26;
      return this._expand(rt + 1), Xe ? (this || _global$y).words[rt] = (this || _global$y).words[rt] | 1 << ot : (this || _global$y).words[rt] = (this || _global$y).words[rt] & ~(1 << ot), this.strip();
    }, Ve.prototype.iadd = function(We) {
      var Xe;
      if ((this || _global$y).negative !== 0 && We.negative === 0)
        return (this || _global$y).negative = 0, Xe = this.isub(We), (this || _global$y).negative ^= 1, this._normSign();
      if ((this || _global$y).negative === 0 && We.negative !== 0)
        return We.negative = 0, Xe = this.isub(We), We.negative = 1, Xe._normSign();
      var rt, ot;
      (this || _global$y).length > We.length ? (rt = this || _global$y, ot = We) : (rt = We, ot = this || _global$y);
      for (var ft = 0, mt = 0; mt < ot.length; mt++)
        Xe = (rt.words[mt] | 0) + (ot.words[mt] | 0) + ft, (this || _global$y).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      for (; ft !== 0 && mt < rt.length; mt++)
        Xe = (rt.words[mt] | 0) + ft, (this || _global$y).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      if ((this || _global$y).length = rt.length, ft !== 0)
        (this || _global$y).words[(this || _global$y).length] = ft, (this || _global$y).length++;
      else if (rt !== (this || _global$y))
        for (; mt < rt.length; mt++)
          (this || _global$y).words[mt] = rt.words[mt];
      return this || _global$y;
    }, Ve.prototype.add = function(We) {
      var Xe;
      return We.negative !== 0 && (this || _global$y).negative === 0 ? (We.negative = 0, Xe = this.sub(We), We.negative ^= 1, Xe) : We.negative === 0 && (this || _global$y).negative !== 0 ? ((this || _global$y).negative = 0, Xe = We.sub(this || _global$y), (this || _global$y).negative = 1, Xe) : (this || _global$y).length > We.length ? this.clone().iadd(We) : We.clone().iadd(this || _global$y);
    }, Ve.prototype.isub = function(We) {
      if (We.negative !== 0) {
        We.negative = 0;
        var Xe = this.iadd(We);
        return We.negative = 1, Xe._normSign();
      } else if ((this || _global$y).negative !== 0)
        return (this || _global$y).negative = 0, this.iadd(We), (this || _global$y).negative = 1, this._normSign();
      var rt = this.cmp(We);
      if (rt === 0)
        return (this || _global$y).negative = 0, (this || _global$y).length = 1, (this || _global$y).words[0] = 0, this || _global$y;
      var ot, ft;
      rt > 0 ? (ot = this || _global$y, ft = We) : (ot = We, ft = this || _global$y);
      for (var mt = 0, yt = 0; yt < ft.length; yt++)
        Xe = (ot.words[yt] | 0) - (ft.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$y).words[yt] = Xe & 67108863;
      for (; mt !== 0 && yt < ot.length; yt++)
        Xe = (ot.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$y).words[yt] = Xe & 67108863;
      if (mt === 0 && yt < ot.length && ot !== (this || _global$y))
        for (; yt < ot.length; yt++)
          (this || _global$y).words[yt] = ot.words[yt];
      return (this || _global$y).length = Math.max((this || _global$y).length, yt), ot !== (this || _global$y) && ((this || _global$y).negative = 1), this.strip();
    }, Ve.prototype.sub = function(We) {
      return this.clone().isub(We);
    };
    function vt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative;
      var rt = gt.length + We.length | 0;
      Xe.length = rt, rt = rt - 1 | 0;
      var ot = gt.words[0] | 0, ft = We.words[0] | 0, mt = ot * ft, yt = mt & 67108863, pt = mt / 67108864 | 0;
      Xe.words[0] = yt;
      for (var Ge = 1; Ge < rt; Ge++) {
        for (var ct = pt >>> 26, Mt = pt & 67108863, St = Math.min(Ge, We.length - 1), At = Math.max(0, Ge - gt.length + 1); At <= St; At++) {
          var Nt = Ge - At | 0;
          ot = gt.words[Nt] | 0, ft = We.words[At] | 0, mt = ot * ft + Mt, ct += mt / 67108864 | 0, Mt = mt & 67108863;
        }
        Xe.words[Ge] = Mt | 0, pt = ct | 0;
      }
      return pt !== 0 ? Xe.words[Ge] = pt | 0 : Xe.length--, Xe.strip();
    }
    var wt = function(We, Xe, rt) {
      var ot = We.words, ft = Xe.words, mt = rt.words, yt = 0, pt, Ge, ct, Mt = ot[0] | 0, St = Mt & 8191, At = Mt >>> 13, Nt = ot[1] | 0, qt = Nt & 8191, Qt = Nt >>> 13, Xt = ot[2] | 0, zt = Xt & 8191, Kt = Xt >>> 13, ur = ot[3] | 0, er = ur & 8191, Dt = ur >>> 13, Ht = ot[4] | 0, Gt = Ht & 8191, rr = Ht >>> 13, sr = ot[5] | 0, Jt = sr & 8191, ir = sr >>> 13, Br = ot[6] | 0, or = Br & 8191, lr = Br >>> 13, Nr = ot[7] | 0, dr = Nr & 8191, gr = Nr >>> 13, Zr = ot[8] | 0, Bt = Zr & 8191, kt = Zr >>> 13, It = ot[9] | 0, jt = It & 8191, Vt = It >>> 13, ar = ft[0] | 0, Yt = ar & 8191, hr = ar >>> 13, zr = ft[1] | 0, cr = zr & 8191, _r = zr >>> 13, Lr = ft[2] | 0, br = Lr & 8191, kr = Lr >>> 13, Xr = ft[3] | 0, yr = Xr & 8191, Ir = Xr >>> 13, Yr = ft[4] | 0, wr = Yr & 8191, Cr = Yr >>> 13, Hr = ft[5] | 0, $r = Hr & 8191, Ar = Hr >>> 13, Wr = ft[6] | 0, mr = Wr & 8191, Tr = Wr >>> 13, Kr = ft[7] | 0, vr = Kr & 8191, Rr = Kr >>> 13, Jr = ft[8] | 0, xr = Jr & 8191, tr = Jr >>> 13, Dr = ft[9] | 0, fr = Dr & 8191, Mr = Dr >>> 13;
      rt.negative = We.negative ^ Xe.negative, rt.length = 19, pt = Math.imul(St, Yt), Ge = Math.imul(St, hr), Ge = Ge + Math.imul(At, Yt) | 0, ct = Math.imul(At, hr);
      var Fr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, pt = Math.imul(qt, Yt), Ge = Math.imul(qt, hr), Ge = Ge + Math.imul(Qt, Yt) | 0, ct = Math.imul(Qt, hr), pt = pt + Math.imul(St, cr) | 0, Ge = Ge + Math.imul(St, _r) | 0, Ge = Ge + Math.imul(At, cr) | 0, ct = ct + Math.imul(At, _r) | 0;
      var qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, pt = Math.imul(zt, Yt), Ge = Math.imul(zt, hr), Ge = Ge + Math.imul(Kt, Yt) | 0, ct = Math.imul(Kt, hr), pt = pt + Math.imul(qt, cr) | 0, Ge = Ge + Math.imul(qt, _r) | 0, Ge = Ge + Math.imul(Qt, cr) | 0, ct = ct + Math.imul(Qt, _r) | 0, pt = pt + Math.imul(St, br) | 0, Ge = Ge + Math.imul(St, kr) | 0, Ge = Ge + Math.imul(At, br) | 0, ct = ct + Math.imul(At, kr) | 0;
      var tn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, pt = Math.imul(er, Yt), Ge = Math.imul(er, hr), Ge = Ge + Math.imul(Dt, Yt) | 0, ct = Math.imul(Dt, hr), pt = pt + Math.imul(zt, cr) | 0, Ge = Ge + Math.imul(zt, _r) | 0, Ge = Ge + Math.imul(Kt, cr) | 0, ct = ct + Math.imul(Kt, _r) | 0, pt = pt + Math.imul(qt, br) | 0, Ge = Ge + Math.imul(qt, kr) | 0, Ge = Ge + Math.imul(Qt, br) | 0, ct = ct + Math.imul(Qt, kr) | 0, pt = pt + Math.imul(St, yr) | 0, Ge = Ge + Math.imul(St, Ir) | 0, Ge = Ge + Math.imul(At, yr) | 0, ct = ct + Math.imul(At, Ir) | 0;
      var Qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, pt = Math.imul(Gt, Yt), Ge = Math.imul(Gt, hr), Ge = Ge + Math.imul(rr, Yt) | 0, ct = Math.imul(rr, hr), pt = pt + Math.imul(er, cr) | 0, Ge = Ge + Math.imul(er, _r) | 0, Ge = Ge + Math.imul(Dt, cr) | 0, ct = ct + Math.imul(Dt, _r) | 0, pt = pt + Math.imul(zt, br) | 0, Ge = Ge + Math.imul(zt, kr) | 0, Ge = Ge + Math.imul(Kt, br) | 0, ct = ct + Math.imul(Kt, kr) | 0, pt = pt + Math.imul(qt, yr) | 0, Ge = Ge + Math.imul(qt, Ir) | 0, Ge = Ge + Math.imul(Qt, yr) | 0, ct = ct + Math.imul(Qt, Ir) | 0, pt = pt + Math.imul(St, wr) | 0, Ge = Ge + Math.imul(St, Cr) | 0, Ge = Ge + Math.imul(At, wr) | 0, ct = ct + Math.imul(At, Cr) | 0;
      var nn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, pt = Math.imul(Jt, Yt), Ge = Math.imul(Jt, hr), Ge = Ge + Math.imul(ir, Yt) | 0, ct = Math.imul(ir, hr), pt = pt + Math.imul(Gt, cr) | 0, Ge = Ge + Math.imul(Gt, _r) | 0, Ge = Ge + Math.imul(rr, cr) | 0, ct = ct + Math.imul(rr, _r) | 0, pt = pt + Math.imul(er, br) | 0, Ge = Ge + Math.imul(er, kr) | 0, Ge = Ge + Math.imul(Dt, br) | 0, ct = ct + Math.imul(Dt, kr) | 0, pt = pt + Math.imul(zt, yr) | 0, Ge = Ge + Math.imul(zt, Ir) | 0, Ge = Ge + Math.imul(Kt, yr) | 0, ct = ct + Math.imul(Kt, Ir) | 0, pt = pt + Math.imul(qt, wr) | 0, Ge = Ge + Math.imul(qt, Cr) | 0, Ge = Ge + Math.imul(Qt, wr) | 0, ct = ct + Math.imul(Qt, Cr) | 0, pt = pt + Math.imul(St, $r) | 0, Ge = Ge + Math.imul(St, Ar) | 0, Ge = Ge + Math.imul(At, $r) | 0, ct = ct + Math.imul(At, Ar) | 0;
      var Er = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, pt = Math.imul(or, Yt), Ge = Math.imul(or, hr), Ge = Ge + Math.imul(lr, Yt) | 0, ct = Math.imul(lr, hr), pt = pt + Math.imul(Jt, cr) | 0, Ge = Ge + Math.imul(Jt, _r) | 0, Ge = Ge + Math.imul(ir, cr) | 0, ct = ct + Math.imul(ir, _r) | 0, pt = pt + Math.imul(Gt, br) | 0, Ge = Ge + Math.imul(Gt, kr) | 0, Ge = Ge + Math.imul(rr, br) | 0, ct = ct + Math.imul(rr, kr) | 0, pt = pt + Math.imul(er, yr) | 0, Ge = Ge + Math.imul(er, Ir) | 0, Ge = Ge + Math.imul(Dt, yr) | 0, ct = ct + Math.imul(Dt, Ir) | 0, pt = pt + Math.imul(zt, wr) | 0, Ge = Ge + Math.imul(zt, Cr) | 0, Ge = Ge + Math.imul(Kt, wr) | 0, ct = ct + Math.imul(Kt, Cr) | 0, pt = pt + Math.imul(qt, $r) | 0, Ge = Ge + Math.imul(qt, Ar) | 0, Ge = Ge + Math.imul(Qt, $r) | 0, ct = ct + Math.imul(Qt, Ar) | 0, pt = pt + Math.imul(St, mr) | 0, Ge = Ge + Math.imul(St, Tr) | 0, Ge = Ge + Math.imul(At, mr) | 0, ct = ct + Math.imul(At, Tr) | 0;
      var Wt = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, pt = Math.imul(dr, Yt), Ge = Math.imul(dr, hr), Ge = Ge + Math.imul(gr, Yt) | 0, ct = Math.imul(gr, hr), pt = pt + Math.imul(or, cr) | 0, Ge = Ge + Math.imul(or, _r) | 0, Ge = Ge + Math.imul(lr, cr) | 0, ct = ct + Math.imul(lr, _r) | 0, pt = pt + Math.imul(Jt, br) | 0, Ge = Ge + Math.imul(Jt, kr) | 0, Ge = Ge + Math.imul(ir, br) | 0, ct = ct + Math.imul(ir, kr) | 0, pt = pt + Math.imul(Gt, yr) | 0, Ge = Ge + Math.imul(Gt, Ir) | 0, Ge = Ge + Math.imul(rr, yr) | 0, ct = ct + Math.imul(rr, Ir) | 0, pt = pt + Math.imul(er, wr) | 0, Ge = Ge + Math.imul(er, Cr) | 0, Ge = Ge + Math.imul(Dt, wr) | 0, ct = ct + Math.imul(Dt, Cr) | 0, pt = pt + Math.imul(zt, $r) | 0, Ge = Ge + Math.imul(zt, Ar) | 0, Ge = Ge + Math.imul(Kt, $r) | 0, ct = ct + Math.imul(Kt, Ar) | 0, pt = pt + Math.imul(qt, mr) | 0, Ge = Ge + Math.imul(qt, Tr) | 0, Ge = Ge + Math.imul(Qt, mr) | 0, ct = ct + Math.imul(Qt, Tr) | 0, pt = pt + Math.imul(St, vr) | 0, Ge = Ge + Math.imul(St, Rr) | 0, Ge = Ge + Math.imul(At, vr) | 0, ct = ct + Math.imul(At, Rr) | 0;
      var nr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, pt = Math.imul(Bt, Yt), Ge = Math.imul(Bt, hr), Ge = Ge + Math.imul(kt, Yt) | 0, ct = Math.imul(kt, hr), pt = pt + Math.imul(dr, cr) | 0, Ge = Ge + Math.imul(dr, _r) | 0, Ge = Ge + Math.imul(gr, cr) | 0, ct = ct + Math.imul(gr, _r) | 0, pt = pt + Math.imul(or, br) | 0, Ge = Ge + Math.imul(or, kr) | 0, Ge = Ge + Math.imul(lr, br) | 0, ct = ct + Math.imul(lr, kr) | 0, pt = pt + Math.imul(Jt, yr) | 0, Ge = Ge + Math.imul(Jt, Ir) | 0, Ge = Ge + Math.imul(ir, yr) | 0, ct = ct + Math.imul(ir, Ir) | 0, pt = pt + Math.imul(Gt, wr) | 0, Ge = Ge + Math.imul(Gt, Cr) | 0, Ge = Ge + Math.imul(rr, wr) | 0, ct = ct + Math.imul(rr, Cr) | 0, pt = pt + Math.imul(er, $r) | 0, Ge = Ge + Math.imul(er, Ar) | 0, Ge = Ge + Math.imul(Dt, $r) | 0, ct = ct + Math.imul(Dt, Ar) | 0, pt = pt + Math.imul(zt, mr) | 0, Ge = Ge + Math.imul(zt, Tr) | 0, Ge = Ge + Math.imul(Kt, mr) | 0, ct = ct + Math.imul(Kt, Tr) | 0, pt = pt + Math.imul(qt, vr) | 0, Ge = Ge + Math.imul(qt, Rr) | 0, Ge = Ge + Math.imul(Qt, vr) | 0, ct = ct + Math.imul(Qt, Rr) | 0, pt = pt + Math.imul(St, xr) | 0, Ge = Ge + Math.imul(St, tr) | 0, Ge = Ge + Math.imul(At, xr) | 0, ct = ct + Math.imul(At, tr) | 0;
      var pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, pt = Math.imul(jt, Yt), Ge = Math.imul(jt, hr), Ge = Ge + Math.imul(Vt, Yt) | 0, ct = Math.imul(Vt, hr), pt = pt + Math.imul(Bt, cr) | 0, Ge = Ge + Math.imul(Bt, _r) | 0, Ge = Ge + Math.imul(kt, cr) | 0, ct = ct + Math.imul(kt, _r) | 0, pt = pt + Math.imul(dr, br) | 0, Ge = Ge + Math.imul(dr, kr) | 0, Ge = Ge + Math.imul(gr, br) | 0, ct = ct + Math.imul(gr, kr) | 0, pt = pt + Math.imul(or, yr) | 0, Ge = Ge + Math.imul(or, Ir) | 0, Ge = Ge + Math.imul(lr, yr) | 0, ct = ct + Math.imul(lr, Ir) | 0, pt = pt + Math.imul(Jt, wr) | 0, Ge = Ge + Math.imul(Jt, Cr) | 0, Ge = Ge + Math.imul(ir, wr) | 0, ct = ct + Math.imul(ir, Cr) | 0, pt = pt + Math.imul(Gt, $r) | 0, Ge = Ge + Math.imul(Gt, Ar) | 0, Ge = Ge + Math.imul(rr, $r) | 0, ct = ct + Math.imul(rr, Ar) | 0, pt = pt + Math.imul(er, mr) | 0, Ge = Ge + Math.imul(er, Tr) | 0, Ge = Ge + Math.imul(Dt, mr) | 0, ct = ct + Math.imul(Dt, Tr) | 0, pt = pt + Math.imul(zt, vr) | 0, Ge = Ge + Math.imul(zt, Rr) | 0, Ge = Ge + Math.imul(Kt, vr) | 0, ct = ct + Math.imul(Kt, Rr) | 0, pt = pt + Math.imul(qt, xr) | 0, Ge = Ge + Math.imul(qt, tr) | 0, Ge = Ge + Math.imul(Qt, xr) | 0, ct = ct + Math.imul(Qt, tr) | 0, pt = pt + Math.imul(St, fr) | 0, Ge = Ge + Math.imul(St, Mr) | 0, Ge = Ge + Math.imul(At, fr) | 0, ct = ct + Math.imul(At, Mr) | 0;
      var Pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, pt = Math.imul(jt, cr), Ge = Math.imul(jt, _r), Ge = Ge + Math.imul(Vt, cr) | 0, ct = Math.imul(Vt, _r), pt = pt + Math.imul(Bt, br) | 0, Ge = Ge + Math.imul(Bt, kr) | 0, Ge = Ge + Math.imul(kt, br) | 0, ct = ct + Math.imul(kt, kr) | 0, pt = pt + Math.imul(dr, yr) | 0, Ge = Ge + Math.imul(dr, Ir) | 0, Ge = Ge + Math.imul(gr, yr) | 0, ct = ct + Math.imul(gr, Ir) | 0, pt = pt + Math.imul(or, wr) | 0, Ge = Ge + Math.imul(or, Cr) | 0, Ge = Ge + Math.imul(lr, wr) | 0, ct = ct + Math.imul(lr, Cr) | 0, pt = pt + Math.imul(Jt, $r) | 0, Ge = Ge + Math.imul(Jt, Ar) | 0, Ge = Ge + Math.imul(ir, $r) | 0, ct = ct + Math.imul(ir, Ar) | 0, pt = pt + Math.imul(Gt, mr) | 0, Ge = Ge + Math.imul(Gt, Tr) | 0, Ge = Ge + Math.imul(rr, mr) | 0, ct = ct + Math.imul(rr, Tr) | 0, pt = pt + Math.imul(er, vr) | 0, Ge = Ge + Math.imul(er, Rr) | 0, Ge = Ge + Math.imul(Dt, vr) | 0, ct = ct + Math.imul(Dt, Rr) | 0, pt = pt + Math.imul(zt, xr) | 0, Ge = Ge + Math.imul(zt, tr) | 0, Ge = Ge + Math.imul(Kt, xr) | 0, ct = ct + Math.imul(Kt, tr) | 0, pt = pt + Math.imul(qt, fr) | 0, Ge = Ge + Math.imul(qt, Mr) | 0, Ge = Ge + Math.imul(Qt, fr) | 0, ct = ct + Math.imul(Qt, Mr) | 0;
      var Sr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, pt = Math.imul(jt, br), Ge = Math.imul(jt, kr), Ge = Ge + Math.imul(Vt, br) | 0, ct = Math.imul(Vt, kr), pt = pt + Math.imul(Bt, yr) | 0, Ge = Ge + Math.imul(Bt, Ir) | 0, Ge = Ge + Math.imul(kt, yr) | 0, ct = ct + Math.imul(kt, Ir) | 0, pt = pt + Math.imul(dr, wr) | 0, Ge = Ge + Math.imul(dr, Cr) | 0, Ge = Ge + Math.imul(gr, wr) | 0, ct = ct + Math.imul(gr, Cr) | 0, pt = pt + Math.imul(or, $r) | 0, Ge = Ge + Math.imul(or, Ar) | 0, Ge = Ge + Math.imul(lr, $r) | 0, ct = ct + Math.imul(lr, Ar) | 0, pt = pt + Math.imul(Jt, mr) | 0, Ge = Ge + Math.imul(Jt, Tr) | 0, Ge = Ge + Math.imul(ir, mr) | 0, ct = ct + Math.imul(ir, Tr) | 0, pt = pt + Math.imul(Gt, vr) | 0, Ge = Ge + Math.imul(Gt, Rr) | 0, Ge = Ge + Math.imul(rr, vr) | 0, ct = ct + Math.imul(rr, Rr) | 0, pt = pt + Math.imul(er, xr) | 0, Ge = Ge + Math.imul(er, tr) | 0, Ge = Ge + Math.imul(Dt, xr) | 0, ct = ct + Math.imul(Dt, tr) | 0, pt = pt + Math.imul(zt, fr) | 0, Ge = Ge + Math.imul(zt, Mr) | 0, Ge = Ge + Math.imul(Kt, fr) | 0, ct = ct + Math.imul(Kt, Mr) | 0;
      var Ur = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, pt = Math.imul(jt, yr), Ge = Math.imul(jt, Ir), Ge = Ge + Math.imul(Vt, yr) | 0, ct = Math.imul(Vt, Ir), pt = pt + Math.imul(Bt, wr) | 0, Ge = Ge + Math.imul(Bt, Cr) | 0, Ge = Ge + Math.imul(kt, wr) | 0, ct = ct + Math.imul(kt, Cr) | 0, pt = pt + Math.imul(dr, $r) | 0, Ge = Ge + Math.imul(dr, Ar) | 0, Ge = Ge + Math.imul(gr, $r) | 0, ct = ct + Math.imul(gr, Ar) | 0, pt = pt + Math.imul(or, mr) | 0, Ge = Ge + Math.imul(or, Tr) | 0, Ge = Ge + Math.imul(lr, mr) | 0, ct = ct + Math.imul(lr, Tr) | 0, pt = pt + Math.imul(Jt, vr) | 0, Ge = Ge + Math.imul(Jt, Rr) | 0, Ge = Ge + Math.imul(ir, vr) | 0, ct = ct + Math.imul(ir, Rr) | 0, pt = pt + Math.imul(Gt, xr) | 0, Ge = Ge + Math.imul(Gt, tr) | 0, Ge = Ge + Math.imul(rr, xr) | 0, ct = ct + Math.imul(rr, tr) | 0, pt = pt + Math.imul(er, fr) | 0, Ge = Ge + Math.imul(er, Mr) | 0, Ge = Ge + Math.imul(Dt, fr) | 0, ct = ct + Math.imul(Dt, Mr) | 0;
      var jr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, pt = Math.imul(jt, wr), Ge = Math.imul(jt, Cr), Ge = Ge + Math.imul(Vt, wr) | 0, ct = Math.imul(Vt, Cr), pt = pt + Math.imul(Bt, $r) | 0, Ge = Ge + Math.imul(Bt, Ar) | 0, Ge = Ge + Math.imul(kt, $r) | 0, ct = ct + Math.imul(kt, Ar) | 0, pt = pt + Math.imul(dr, mr) | 0, Ge = Ge + Math.imul(dr, Tr) | 0, Ge = Ge + Math.imul(gr, mr) | 0, ct = ct + Math.imul(gr, Tr) | 0, pt = pt + Math.imul(or, vr) | 0, Ge = Ge + Math.imul(or, Rr) | 0, Ge = Ge + Math.imul(lr, vr) | 0, ct = ct + Math.imul(lr, Rr) | 0, pt = pt + Math.imul(Jt, xr) | 0, Ge = Ge + Math.imul(Jt, tr) | 0, Ge = Ge + Math.imul(ir, xr) | 0, ct = ct + Math.imul(ir, tr) | 0, pt = pt + Math.imul(Gt, fr) | 0, Ge = Ge + Math.imul(Gt, Mr) | 0, Ge = Ge + Math.imul(rr, fr) | 0, ct = ct + Math.imul(rr, Mr) | 0;
      var Gr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, pt = Math.imul(jt, $r), Ge = Math.imul(jt, Ar), Ge = Ge + Math.imul(Vt, $r) | 0, ct = Math.imul(Vt, Ar), pt = pt + Math.imul(Bt, mr) | 0, Ge = Ge + Math.imul(Bt, Tr) | 0, Ge = Ge + Math.imul(kt, mr) | 0, ct = ct + Math.imul(kt, Tr) | 0, pt = pt + Math.imul(dr, vr) | 0, Ge = Ge + Math.imul(dr, Rr) | 0, Ge = Ge + Math.imul(gr, vr) | 0, ct = ct + Math.imul(gr, Rr) | 0, pt = pt + Math.imul(or, xr) | 0, Ge = Ge + Math.imul(or, tr) | 0, Ge = Ge + Math.imul(lr, xr) | 0, ct = ct + Math.imul(lr, tr) | 0, pt = pt + Math.imul(Jt, fr) | 0, Ge = Ge + Math.imul(Jt, Mr) | 0, Ge = Ge + Math.imul(ir, fr) | 0, ct = ct + Math.imul(ir, Mr) | 0;
      var Vr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, pt = Math.imul(jt, mr), Ge = Math.imul(jt, Tr), Ge = Ge + Math.imul(Vt, mr) | 0, ct = Math.imul(Vt, Tr), pt = pt + Math.imul(Bt, vr) | 0, Ge = Ge + Math.imul(Bt, Rr) | 0, Ge = Ge + Math.imul(kt, vr) | 0, ct = ct + Math.imul(kt, Rr) | 0, pt = pt + Math.imul(dr, xr) | 0, Ge = Ge + Math.imul(dr, tr) | 0, Ge = Ge + Math.imul(gr, xr) | 0, ct = ct + Math.imul(gr, tr) | 0, pt = pt + Math.imul(or, fr) | 0, Ge = Ge + Math.imul(or, Mr) | 0, Ge = Ge + Math.imul(lr, fr) | 0, ct = ct + Math.imul(lr, Mr) | 0;
      var rn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, pt = Math.imul(jt, vr), Ge = Math.imul(jt, Rr), Ge = Ge + Math.imul(Vt, vr) | 0, ct = Math.imul(Vt, Rr), pt = pt + Math.imul(Bt, xr) | 0, Ge = Ge + Math.imul(Bt, tr) | 0, Ge = Ge + Math.imul(kt, xr) | 0, ct = ct + Math.imul(kt, tr) | 0, pt = pt + Math.imul(dr, fr) | 0, Ge = Ge + Math.imul(dr, Mr) | 0, Ge = Ge + Math.imul(gr, fr) | 0, ct = ct + Math.imul(gr, Mr) | 0;
      var an = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, pt = Math.imul(jt, xr), Ge = Math.imul(jt, tr), Ge = Ge + Math.imul(Vt, xr) | 0, ct = Math.imul(Vt, tr), pt = pt + Math.imul(Bt, fr) | 0, Ge = Ge + Math.imul(Bt, Mr) | 0, Ge = Ge + Math.imul(kt, fr) | 0, ct = ct + Math.imul(kt, Mr) | 0;
      var ln = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, pt = Math.imul(jt, fr), Ge = Math.imul(jt, Mr), Ge = Ge + Math.imul(Vt, fr) | 0, ct = Math.imul(Vt, Mr);
      var sn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      return yt = (ct + (Ge >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, mt[0] = Fr, mt[1] = qr, mt[2] = tn, mt[3] = Qr, mt[4] = nn, mt[5] = Er, mt[6] = Wt, mt[7] = nr, mt[8] = pr, mt[9] = Pr, mt[10] = Sr, mt[11] = Ur, mt[12] = jr, mt[13] = Gr, mt[14] = Vr, mt[15] = rn, mt[16] = an, mt[17] = ln, mt[18] = sn, yt !== 0 && (mt[19] = yt, rt.length++), rt;
    };
    Math.imul || (wt = vt);
    function xt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative, Xe.length = gt.length + We.length;
      for (var rt = 0, ot = 0, ft = 0; ft < Xe.length - 1; ft++) {
        var mt = ot;
        ot = 0;
        for (var yt = rt & 67108863, pt = Math.min(ft, We.length - 1), Ge = Math.max(0, ft - gt.length + 1); Ge <= pt; Ge++) {
          var ct = ft - Ge, Mt = gt.words[ct] | 0, St = We.words[Ge] | 0, At = Mt * St, Nt = At & 67108863;
          mt = mt + (At / 67108864 | 0) | 0, Nt = Nt + yt | 0, yt = Nt & 67108863, mt = mt + (Nt >>> 26) | 0, ot += mt >>> 26, mt &= 67108863;
        }
        Xe.words[ft] = yt, rt = mt, mt = ot;
      }
      return rt !== 0 ? Xe.words[ft] = rt : Xe.length--, Xe.strip();
    }
    function Et(gt, We, Xe) {
      var rt = new Tt();
      return rt.mulp(gt, We, Xe);
    }
    Ve.prototype.mulTo = function(We, Xe) {
      var rt, ot = (this || _global$y).length + We.length;
      return (this || _global$y).length === 10 && We.length === 10 ? rt = wt(this || _global$y, We, Xe) : ot < 63 ? rt = vt(this || _global$y, We, Xe) : ot < 1024 ? rt = xt(this || _global$y, We, Xe) : rt = Et(this || _global$y, We, Xe), rt;
    };
    function Tt(gt, We) {
      (this || _global$y).x = gt, (this || _global$y).y = We;
    }
    Tt.prototype.makeRBT = function(We) {
      for (var Xe = new Array(We), rt = Ve.prototype._countBits(We) - 1, ot = 0; ot < We; ot++)
        Xe[ot] = this.revBin(ot, rt, We);
      return Xe;
    }, Tt.prototype.revBin = function(We, Xe, rt) {
      if (We === 0 || We === rt - 1)
        return We;
      for (var ot = 0, ft = 0; ft < Xe; ft++)
        ot |= (We & 1) << Xe - ft - 1, We >>= 1;
      return ot;
    }, Tt.prototype.permute = function(We, Xe, rt, ot, ft, mt) {
      for (var yt = 0; yt < mt; yt++)
        ot[yt] = Xe[We[yt]], ft[yt] = rt[We[yt]];
    }, Tt.prototype.transform = function(We, Xe, rt, ot, ft, mt) {
      this.permute(mt, We, Xe, rt, ot, ft);
      for (var yt = 1; yt < ft; yt <<= 1)
        for (var pt = yt << 1, Ge = Math.cos(2 * Math.PI / pt), ct = Math.sin(2 * Math.PI / pt), Mt = 0; Mt < ft; Mt += pt)
          for (var St = Ge, At = ct, Nt = 0; Nt < yt; Nt++) {
            var qt = rt[Mt + Nt], Qt = ot[Mt + Nt], Xt = rt[Mt + Nt + yt], zt = ot[Mt + Nt + yt], Kt = St * Xt - At * zt;
            zt = St * zt + At * Xt, Xt = Kt, rt[Mt + Nt] = qt + Xt, ot[Mt + Nt] = Qt + zt, rt[Mt + Nt + yt] = qt - Xt, ot[Mt + Nt + yt] = Qt - zt, Nt !== pt && (Kt = Ge * St - ct * At, At = Ge * At + ct * St, St = Kt);
          }
    }, Tt.prototype.guessLen13b = function(We, Xe) {
      var rt = Math.max(Xe, We) | 1, ot = rt & 1, ft = 0;
      for (rt = rt / 2 | 0; rt; rt = rt >>> 1)
        ft++;
      return 1 << ft + 1 + ot;
    }, Tt.prototype.conjugate = function(We, Xe, rt) {
      if (!(rt <= 1))
        for (var ot = 0; ot < rt / 2; ot++) {
          var ft = We[ot];
          We[ot] = We[rt - ot - 1], We[rt - ot - 1] = ft, ft = Xe[ot], Xe[ot] = -Xe[rt - ot - 1], Xe[rt - ot - 1] = -ft;
        }
    }, Tt.prototype.normalize13b = function(We, Xe) {
      for (var rt = 0, ot = 0; ot < Xe / 2; ot++) {
        var ft = Math.round(We[2 * ot + 1] / Xe) * 8192 + Math.round(We[2 * ot] / Xe) + rt;
        We[ot] = ft & 67108863, ft < 67108864 ? rt = 0 : rt = ft / 67108864 | 0;
      }
      return We;
    }, Tt.prototype.convert13b = function(We, Xe, rt, ot) {
      for (var ft = 0, mt = 0; mt < Xe; mt++)
        ft = ft + (We[mt] | 0), rt[2 * mt] = ft & 8191, ft = ft >>> 13, rt[2 * mt + 1] = ft & 8191, ft = ft >>> 13;
      for (mt = 2 * Xe; mt < ot; ++mt)
        rt[mt] = 0;
      Fe(ft === 0), Fe((ft & -8192) === 0);
    }, Tt.prototype.stub = function(We) {
      for (var Xe = new Array(We), rt = 0; rt < We; rt++)
        Xe[rt] = 0;
      return Xe;
    }, Tt.prototype.mulp = function(We, Xe, rt) {
      var ot = 2 * this.guessLen13b(We.length, Xe.length), ft = this.makeRBT(ot), mt = this.stub(ot), yt = new Array(ot), pt = new Array(ot), Ge = new Array(ot), ct = new Array(ot), Mt = new Array(ot), St = new Array(ot), At = rt.words;
      At.length = ot, this.convert13b(We.words, We.length, yt, ot), this.convert13b(Xe.words, Xe.length, ct, ot), this.transform(yt, mt, pt, Ge, ot, ft), this.transform(ct, mt, Mt, St, ot, ft);
      for (var Nt = 0; Nt < ot; Nt++) {
        var qt = pt[Nt] * Mt[Nt] - Ge[Nt] * St[Nt];
        Ge[Nt] = pt[Nt] * St[Nt] + Ge[Nt] * Mt[Nt], pt[Nt] = qt;
      }
      return this.conjugate(pt, Ge, ot), this.transform(pt, Ge, At, mt, ot, ft), this.conjugate(At, mt, ot), this.normalize13b(At, ot), rt.negative = We.negative ^ Xe.negative, rt.length = We.length + Xe.length, rt.strip();
    }, Ve.prototype.mul = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$y).length + We.length), this.mulTo(We, Xe);
    }, Ve.prototype.mulf = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$y).length + We.length), Et(this || _global$y, We, Xe);
    }, Ve.prototype.imul = function(We) {
      return this.clone().mulTo(We, this || _global$y);
    }, Ve.prototype.imuln = function(We) {
      Fe(typeof We == "number"), Fe(We < 67108864);
      for (var Xe = 0, rt = 0; rt < (this || _global$y).length; rt++) {
        var ot = ((this || _global$y).words[rt] | 0) * We, ft = (ot & 67108863) + (Xe & 67108863);
        Xe >>= 26, Xe += ot / 67108864 | 0, Xe += ft >>> 26, (this || _global$y).words[rt] = ft & 67108863;
      }
      return Xe !== 0 && ((this || _global$y).words[rt] = Xe, (this || _global$y).length++), this || _global$y;
    }, Ve.prototype.muln = function(We) {
      return this.clone().imuln(We);
    }, Ve.prototype.sqr = function() {
      return this.mul(this || _global$y);
    }, Ve.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Ve.prototype.pow = function(We) {
      var Xe = $t(We);
      if (Xe.length === 0)
        return new Ve(1);
      for (var rt = this || _global$y, ot = 0; ot < Xe.length && Xe[ot] === 0; ot++, rt = rt.sqr())
        ;
      if (++ot < Xe.length)
        for (var ft = rt.sqr(); ot < Xe.length; ot++, ft = ft.sqr())
          Xe[ot] !== 0 && (rt = rt.mul(ft));
      return rt;
    }, Ve.prototype.iushln = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 67108863 >>> 26 - Xe << 26 - Xe, ft;
      if (Xe !== 0) {
        var mt = 0;
        for (ft = 0; ft < (this || _global$y).length; ft++) {
          var yt = (this || _global$y).words[ft] & ot, pt = ((this || _global$y).words[ft] | 0) - yt << Xe;
          (this || _global$y).words[ft] = pt | mt, mt = yt >>> 26 - Xe;
        }
        mt && ((this || _global$y).words[ft] = mt, (this || _global$y).length++);
      }
      if (rt !== 0) {
        for (ft = (this || _global$y).length - 1; ft >= 0; ft--)
          (this || _global$y).words[ft + rt] = (this || _global$y).words[ft];
        for (ft = 0; ft < rt; ft++)
          (this || _global$y).words[ft] = 0;
        (this || _global$y).length += rt;
      }
      return this.strip();
    }, Ve.prototype.ishln = function(We) {
      return Fe((this || _global$y).negative === 0), this.iushln(We);
    }, Ve.prototype.iushrn = function(We, Xe, rt) {
      Fe(typeof We == "number" && We >= 0);
      var ot;
      Xe ? ot = (Xe - Xe % 26) / 26 : ot = 0;
      var ft = We % 26, mt = Math.min((We - ft) / 26, (this || _global$y).length), yt = 67108863 ^ 67108863 >>> ft << ft, pt = rt;
      if (ot -= mt, ot = Math.max(0, ot), pt) {
        for (var Ge = 0; Ge < mt; Ge++)
          pt.words[Ge] = (this || _global$y).words[Ge];
        pt.length = mt;
      }
      if (mt !== 0)
        if ((this || _global$y).length > mt)
          for ((this || _global$y).length -= mt, Ge = 0; Ge < (this || _global$y).length; Ge++)
            (this || _global$y).words[Ge] = (this || _global$y).words[Ge + mt];
        else
          (this || _global$y).words[0] = 0, (this || _global$y).length = 1;
      var ct = 0;
      for (Ge = (this || _global$y).length - 1; Ge >= 0 && (ct !== 0 || Ge >= ot); Ge--) {
        var Mt = (this || _global$y).words[Ge] | 0;
        (this || _global$y).words[Ge] = ct << 26 - ft | Mt >>> ft, ct = Mt & yt;
      }
      return pt && ct !== 0 && (pt.words[pt.length++] = ct), (this || _global$y).length === 0 && ((this || _global$y).words[0] = 0, (this || _global$y).length = 1), this.strip();
    }, Ve.prototype.ishrn = function(We, Xe, rt) {
      return Fe((this || _global$y).negative === 0), this.iushrn(We, Xe, rt);
    }, Ve.prototype.shln = function(We) {
      return this.clone().ishln(We);
    }, Ve.prototype.ushln = function(We) {
      return this.clone().iushln(We);
    }, Ve.prototype.shrn = function(We) {
      return this.clone().ishrn(We);
    }, Ve.prototype.ushrn = function(We) {
      return this.clone().iushrn(We);
    }, Ve.prototype.testn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$y).length <= rt)
        return !1;
      var ft = (this || _global$y).words[rt];
      return !!(ft & ot);
    }, Ve.prototype.imaskn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26;
      if (Fe((this || _global$y).negative === 0, "imaskn works only with positive numbers"), (this || _global$y).length <= rt)
        return this || _global$y;
      if (Xe !== 0 && rt++, (this || _global$y).length = Math.min(rt, (this || _global$y).length), Xe !== 0) {
        var ot = 67108863 ^ 67108863 >>> Xe << Xe;
        (this || _global$y).words[(this || _global$y).length - 1] &= ot;
      }
      return this.strip();
    }, Ve.prototype.maskn = function(We) {
      return this.clone().imaskn(We);
    }, Ve.prototype.iaddn = function(We) {
      return Fe(typeof We == "number"), Fe(We < 67108864), We < 0 ? this.isubn(-We) : (this || _global$y).negative !== 0 ? (this || _global$y).length === 1 && ((this || _global$y).words[0] | 0) < We ? ((this || _global$y).words[0] = We - ((this || _global$y).words[0] | 0), (this || _global$y).negative = 0, this || _global$y) : ((this || _global$y).negative = 0, this.isubn(We), (this || _global$y).negative = 1, this || _global$y) : this._iaddn(We);
    }, Ve.prototype._iaddn = function(We) {
      (this || _global$y).words[0] += We;
      for (var Xe = 0; Xe < (this || _global$y).length && (this || _global$y).words[Xe] >= 67108864; Xe++)
        (this || _global$y).words[Xe] -= 67108864, Xe === (this || _global$y).length - 1 ? (this || _global$y).words[Xe + 1] = 1 : (this || _global$y).words[Xe + 1]++;
      return (this || _global$y).length = Math.max((this || _global$y).length, Xe + 1), this || _global$y;
    }, Ve.prototype.isubn = function(We) {
      if (Fe(typeof We == "number"), Fe(We < 67108864), We < 0)
        return this.iaddn(-We);
      if ((this || _global$y).negative !== 0)
        return (this || _global$y).negative = 0, this.iaddn(We), (this || _global$y).negative = 1, this || _global$y;
      if ((this || _global$y).words[0] -= We, (this || _global$y).length === 1 && (this || _global$y).words[0] < 0)
        (this || _global$y).words[0] = -(this || _global$y).words[0], (this || _global$y).negative = 1;
      else
        for (var Xe = 0; Xe < (this || _global$y).length && (this || _global$y).words[Xe] < 0; Xe++)
          (this || _global$y).words[Xe] += 67108864, (this || _global$y).words[Xe + 1] -= 1;
      return this.strip();
    }, Ve.prototype.addn = function(We) {
      return this.clone().iaddn(We);
    }, Ve.prototype.subn = function(We) {
      return this.clone().isubn(We);
    }, Ve.prototype.iabs = function() {
      return (this || _global$y).negative = 0, this || _global$y;
    }, Ve.prototype.abs = function() {
      return this.clone().iabs();
    }, Ve.prototype._ishlnsubmul = function(We, Xe, rt) {
      var ot = We.length + rt, ft;
      this._expand(ot);
      var mt, yt = 0;
      for (ft = 0; ft < We.length; ft++) {
        mt = ((this || _global$y).words[ft + rt] | 0) + yt;
        var pt = (We.words[ft] | 0) * Xe;
        mt -= pt & 67108863, yt = (mt >> 26) - (pt / 67108864 | 0), (this || _global$y).words[ft + rt] = mt & 67108863;
      }
      for (; ft < (this || _global$y).length - rt; ft++)
        mt = ((this || _global$y).words[ft + rt] | 0) + yt, yt = mt >> 26, (this || _global$y).words[ft + rt] = mt & 67108863;
      if (yt === 0)
        return this.strip();
      for (Fe(yt === -1), yt = 0, ft = 0; ft < (this || _global$y).length; ft++)
        mt = -((this || _global$y).words[ft] | 0) + yt, yt = mt >> 26, (this || _global$y).words[ft] = mt & 67108863;
      return (this || _global$y).negative = 1, this.strip();
    }, Ve.prototype._wordDiv = function(We, Xe) {
      var rt = (this || _global$y).length - We.length, ot = this.clone(), ft = We, mt = ft.words[ft.length - 1] | 0, yt = this._countBits(mt);
      rt = 26 - yt, rt !== 0 && (ft = ft.ushln(rt), ot.iushln(rt), mt = ft.words[ft.length - 1] | 0);
      var pt = ot.length - ft.length, Ge;
      if (Xe !== "mod") {
        Ge = new Ve(null), Ge.length = pt + 1, Ge.words = new Array(Ge.length);
        for (var ct = 0; ct < Ge.length; ct++)
          Ge.words[ct] = 0;
      }
      var Mt = ot.clone()._ishlnsubmul(ft, 1, pt);
      Mt.negative === 0 && (ot = Mt, Ge && (Ge.words[pt] = 1));
      for (var St = pt - 1; St >= 0; St--) {
        var At = (ot.words[ft.length + St] | 0) * 67108864 + (ot.words[ft.length + St - 1] | 0);
        for (At = Math.min(At / mt | 0, 67108863), ot._ishlnsubmul(ft, At, St); ot.negative !== 0; )
          At--, ot.negative = 0, ot._ishlnsubmul(ft, 1, St), ot.isZero() || (ot.negative ^= 1);
        Ge && (Ge.words[St] = At);
      }
      return Ge && Ge.strip(), ot.strip(), Xe !== "div" && rt !== 0 && ot.iushrn(rt), {
        div: Ge || null,
        mod: ot
      };
    }, Ve.prototype.divmod = function(We, Xe, rt) {
      if (Fe(!We.isZero()), this.isZero())
        return {
          div: new Ve(0),
          mod: new Ve(0)
        };
      var ot, ft, mt;
      return (this || _global$y).negative !== 0 && We.negative === 0 ? (mt = this.neg().divmod(We, Xe), Xe !== "mod" && (ot = mt.div.neg()), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.iadd(We)), {
        div: ot,
        mod: ft
      }) : (this || _global$y).negative === 0 && We.negative !== 0 ? (mt = this.divmod(We.neg(), Xe), Xe !== "mod" && (ot = mt.div.neg()), {
        div: ot,
        mod: mt.mod
      }) : (this || _global$y).negative & We.negative ? (mt = this.neg().divmod(We.neg(), Xe), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.isub(We)), {
        div: mt.div,
        mod: ft
      }) : We.length > (this || _global$y).length || this.cmp(We) < 0 ? {
        div: new Ve(0),
        mod: this || _global$y
      } : We.length === 1 ? Xe === "div" ? {
        div: this.divn(We.words[0]),
        mod: null
      } : Xe === "mod" ? {
        div: null,
        mod: new Ve(this.modn(We.words[0]))
      } : {
        div: this.divn(We.words[0]),
        mod: new Ve(this.modn(We.words[0]))
      } : this._wordDiv(We, Xe);
    }, Ve.prototype.div = function(We) {
      return this.divmod(We, "div", !1).div;
    }, Ve.prototype.mod = function(We) {
      return this.divmod(We, "mod", !1).mod;
    }, Ve.prototype.umod = function(We) {
      return this.divmod(We, "mod", !0).mod;
    }, Ve.prototype.divRound = function(We) {
      var Xe = this.divmod(We);
      if (Xe.mod.isZero())
        return Xe.div;
      var rt = Xe.div.negative !== 0 ? Xe.mod.isub(We) : Xe.mod, ot = We.ushrn(1), ft = We.andln(1), mt = rt.cmp(ot);
      return mt < 0 || ft === 1 && mt === 0 ? Xe.div : Xe.div.negative !== 0 ? Xe.div.isubn(1) : Xe.div.iaddn(1);
    }, Ve.prototype.modn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = (1 << 26) % We, rt = 0, ot = (this || _global$y).length - 1; ot >= 0; ot--)
        rt = (Xe * rt + ((this || _global$y).words[ot] | 0)) % We;
      return rt;
    }, Ve.prototype.idivn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = 0, rt = (this || _global$y).length - 1; rt >= 0; rt--) {
        var ot = ((this || _global$y).words[rt] | 0) + Xe * 67108864;
        (this || _global$y).words[rt] = ot / We | 0, Xe = ot % We;
      }
      return this.strip();
    }, Ve.prototype.divn = function(We) {
      return this.clone().idivn(We);
    }, Ve.prototype.egcd = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$y, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = new Ve(0), yt = new Ve(1), pt = 0; Xe.isEven() && rt.isEven(); )
        Xe.iushrn(1), rt.iushrn(1), ++pt;
      for (var Ge = rt.clone(), ct = Xe.clone(); !Xe.isZero(); ) {
        for (var Mt = 0, St = 1; !(Xe.words[0] & St) && Mt < 26; ++Mt, St <<= 1)
          ;
        if (Mt > 0)
          for (Xe.iushrn(Mt); Mt-- > 0; )
            (ot.isOdd() || ft.isOdd()) && (ot.iadd(Ge), ft.isub(ct)), ot.iushrn(1), ft.iushrn(1);
        for (var At = 0, Nt = 1; !(rt.words[0] & Nt) && At < 26; ++At, Nt <<= 1)
          ;
        if (At > 0)
          for (rt.iushrn(At); At-- > 0; )
            (mt.isOdd() || yt.isOdd()) && (mt.iadd(Ge), yt.isub(ct)), mt.iushrn(1), yt.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(mt), ft.isub(yt)) : (rt.isub(Xe), mt.isub(ot), yt.isub(ft));
      }
      return {
        a: mt,
        b: yt,
        gcd: rt.iushln(pt)
      };
    }, Ve.prototype._invmp = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$y, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = rt.clone(); Xe.cmpn(1) > 0 && rt.cmpn(1) > 0; ) {
        for (var yt = 0, pt = 1; !(Xe.words[0] & pt) && yt < 26; ++yt, pt <<= 1)
          ;
        if (yt > 0)
          for (Xe.iushrn(yt); yt-- > 0; )
            ot.isOdd() && ot.iadd(mt), ot.iushrn(1);
        for (var Ge = 0, ct = 1; !(rt.words[0] & ct) && Ge < 26; ++Ge, ct <<= 1)
          ;
        if (Ge > 0)
          for (rt.iushrn(Ge); Ge-- > 0; )
            ft.isOdd() && ft.iadd(mt), ft.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(ft)) : (rt.isub(Xe), ft.isub(ot));
      }
      var Mt;
      return Xe.cmpn(1) === 0 ? Mt = ot : Mt = ft, Mt.cmpn(0) < 0 && Mt.iadd(We), Mt;
    }, Ve.prototype.gcd = function(We) {
      if (this.isZero())
        return We.abs();
      if (We.isZero())
        return this.abs();
      var Xe = this.clone(), rt = We.clone();
      Xe.negative = 0, rt.negative = 0;
      for (var ot = 0; Xe.isEven() && rt.isEven(); ot++)
        Xe.iushrn(1), rt.iushrn(1);
      do {
        for (; Xe.isEven(); )
          Xe.iushrn(1);
        for (; rt.isEven(); )
          rt.iushrn(1);
        var ft = Xe.cmp(rt);
        if (ft < 0) {
          var mt = Xe;
          Xe = rt, rt = mt;
        } else if (ft === 0 || rt.cmpn(1) === 0)
          break;
        Xe.isub(rt);
      } while (!0);
      return rt.iushln(ot);
    }, Ve.prototype.invm = function(We) {
      return this.egcd(We).a.umod(We);
    }, Ve.prototype.isEven = function() {
      return ((this || _global$y).words[0] & 1) === 0;
    }, Ve.prototype.isOdd = function() {
      return ((this || _global$y).words[0] & 1) === 1;
    }, Ve.prototype.andln = function(We) {
      return (this || _global$y).words[0] & We;
    }, Ve.prototype.bincn = function(We) {
      Fe(typeof We == "number");
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$y).length <= rt)
        return this._expand(rt + 1), (this || _global$y).words[rt] |= ot, this || _global$y;
      for (var ft = ot, mt = rt; ft !== 0 && mt < (this || _global$y).length; mt++) {
        var yt = (this || _global$y).words[mt] | 0;
        yt += ft, ft = yt >>> 26, yt &= 67108863, (this || _global$y).words[mt] = yt;
      }
      return ft !== 0 && ((this || _global$y).words[mt] = ft, (this || _global$y).length++), this || _global$y;
    }, Ve.prototype.isZero = function() {
      return (this || _global$y).length === 1 && (this || _global$y).words[0] === 0;
    }, Ve.prototype.cmpn = function(We) {
      var Xe = We < 0;
      if ((this || _global$y).negative !== 0 && !Xe)
        return -1;
      if ((this || _global$y).negative === 0 && Xe)
        return 1;
      this.strip();
      var rt;
      if ((this || _global$y).length > 1)
        rt = 1;
      else {
        Xe && (We = -We), Fe(We <= 67108863, "Number is too big");
        var ot = (this || _global$y).words[0] | 0;
        rt = ot === We ? 0 : ot < We ? -1 : 1;
      }
      return (this || _global$y).negative !== 0 ? -rt | 0 : rt;
    }, Ve.prototype.cmp = function(We) {
      if ((this || _global$y).negative !== 0 && We.negative === 0)
        return -1;
      if ((this || _global$y).negative === 0 && We.negative !== 0)
        return 1;
      var Xe = this.ucmp(We);
      return (this || _global$y).negative !== 0 ? -Xe | 0 : Xe;
    }, Ve.prototype.ucmp = function(We) {
      if ((this || _global$y).length > We.length)
        return 1;
      if ((this || _global$y).length < We.length)
        return -1;
      for (var Xe = 0, rt = (this || _global$y).length - 1; rt >= 0; rt--) {
        var ot = (this || _global$y).words[rt] | 0, ft = We.words[rt] | 0;
        if (ot !== ft) {
          ot < ft ? Xe = -1 : ot > ft && (Xe = 1);
          break;
        }
      }
      return Xe;
    }, Ve.prototype.gtn = function(We) {
      return this.cmpn(We) === 1;
    }, Ve.prototype.gt = function(We) {
      return this.cmp(We) === 1;
    }, Ve.prototype.gten = function(We) {
      return this.cmpn(We) >= 0;
    }, Ve.prototype.gte = function(We) {
      return this.cmp(We) >= 0;
    }, Ve.prototype.ltn = function(We) {
      return this.cmpn(We) === -1;
    }, Ve.prototype.lt = function(We) {
      return this.cmp(We) === -1;
    }, Ve.prototype.lten = function(We) {
      return this.cmpn(We) <= 0;
    }, Ve.prototype.lte = function(We) {
      return this.cmp(We) <= 0;
    }, Ve.prototype.eqn = function(We) {
      return this.cmpn(We) === 0;
    }, Ve.prototype.eq = function(We) {
      return this.cmp(We) === 0;
    }, Ve.red = function(We) {
      return new Ot(We);
    }, Ve.prototype.toRed = function(We) {
      return Fe(!(this || _global$y).red, "Already a number in reduction context"), Fe((this || _global$y).negative === 0, "red works only with positives"), We.convertTo(this || _global$y)._forceRed(We);
    }, Ve.prototype.fromRed = function() {
      return Fe((this || _global$y).red, "fromRed works only with numbers in reduction context"), (this || _global$y).red.convertFrom(this || _global$y);
    }, Ve.prototype._forceRed = function(We) {
      return (this || _global$y).red = We, this || _global$y;
    }, Ve.prototype.forceRed = function(We) {
      return Fe(!(this || _global$y).red, "Already a number in reduction context"), this._forceRed(We);
    }, Ve.prototype.redAdd = function(We) {
      return Fe((this || _global$y).red, "redAdd works only with red numbers"), (this || _global$y).red.add(this || _global$y, We);
    }, Ve.prototype.redIAdd = function(We) {
      return Fe((this || _global$y).red, "redIAdd works only with red numbers"), (this || _global$y).red.iadd(this || _global$y, We);
    }, Ve.prototype.redSub = function(We) {
      return Fe((this || _global$y).red, "redSub works only with red numbers"), (this || _global$y).red.sub(this || _global$y, We);
    }, Ve.prototype.redISub = function(We) {
      return Fe((this || _global$y).red, "redISub works only with red numbers"), (this || _global$y).red.isub(this || _global$y, We);
    }, Ve.prototype.redShl = function(We) {
      return Fe((this || _global$y).red, "redShl works only with red numbers"), (this || _global$y).red.shl(this || _global$y, We);
    }, Ve.prototype.redMul = function(We) {
      return Fe((this || _global$y).red, "redMul works only with red numbers"), (this || _global$y).red._verify2(this || _global$y, We), (this || _global$y).red.mul(this || _global$y, We);
    }, Ve.prototype.redIMul = function(We) {
      return Fe((this || _global$y).red, "redMul works only with red numbers"), (this || _global$y).red._verify2(this || _global$y, We), (this || _global$y).red.imul(this || _global$y, We);
    }, Ve.prototype.redSqr = function() {
      return Fe((this || _global$y).red, "redSqr works only with red numbers"), (this || _global$y).red._verify1(this || _global$y), (this || _global$y).red.sqr(this || _global$y);
    }, Ve.prototype.redISqr = function() {
      return Fe((this || _global$y).red, "redISqr works only with red numbers"), (this || _global$y).red._verify1(this || _global$y), (this || _global$y).red.isqr(this || _global$y);
    }, Ve.prototype.redSqrt = function() {
      return Fe((this || _global$y).red, "redSqrt works only with red numbers"), (this || _global$y).red._verify1(this || _global$y), (this || _global$y).red.sqrt(this || _global$y);
    }, Ve.prototype.redInvm = function() {
      return Fe((this || _global$y).red, "redInvm works only with red numbers"), (this || _global$y).red._verify1(this || _global$y), (this || _global$y).red.invm(this || _global$y);
    }, Ve.prototype.redNeg = function() {
      return Fe((this || _global$y).red, "redNeg works only with red numbers"), (this || _global$y).red._verify1(this || _global$y), (this || _global$y).red.neg(this || _global$y);
    }, Ve.prototype.redPow = function(We) {
      return Fe((this || _global$y).red && !We.red, "redPow(normalNum)"), (this || _global$y).red._verify1(this || _global$y), (this || _global$y).red.pow(this || _global$y, We);
    };
    var Rt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ct(gt, We) {
      (this || _global$y).name = gt, (this || _global$y).p = new Ve(We, 16), (this || _global$y).n = (this || _global$y).p.bitLength(), (this || _global$y).k = new Ve(1).iushln((this || _global$y).n).isub((this || _global$y).p), (this || _global$y).tmp = this._tmp();
    }
    Ct.prototype._tmp = function() {
      var We = new Ve(null);
      return We.words = new Array(Math.ceil((this || _global$y).n / 13)), We;
    }, Ct.prototype.ireduce = function(We) {
      var Xe = We, rt;
      do
        this.split(Xe, (this || _global$y).tmp), Xe = this.imulK(Xe), Xe = Xe.iadd((this || _global$y).tmp), rt = Xe.bitLength();
      while (rt > (this || _global$y).n);
      var ot = rt < (this || _global$y).n ? -1 : Xe.ucmp((this || _global$y).p);
      return ot === 0 ? (Xe.words[0] = 0, Xe.length = 1) : ot > 0 ? Xe.isub((this || _global$y).p) : Xe.strip !== void 0 ? Xe.strip() : Xe._strip(), Xe;
    }, Ct.prototype.split = function(We, Xe) {
      We.iushrn((this || _global$y).n, 0, Xe);
    }, Ct.prototype.imulK = function(We) {
      return We.imul((this || _global$y).k);
    };
    function Zt() {
      Ct.call(this || _global$y, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    Ke(Zt, Ct), Zt.prototype.split = function(We, Xe) {
      for (var rt = 4194303, ot = Math.min(We.length, 9), ft = 0; ft < ot; ft++)
        Xe.words[ft] = We.words[ft];
      if (Xe.length = ot, We.length <= 9) {
        We.words[0] = 0, We.length = 1;
        return;
      }
      var mt = We.words[9];
      for (Xe.words[Xe.length++] = mt & rt, ft = 10; ft < We.length; ft++) {
        var yt = We.words[ft] | 0;
        We.words[ft - 10] = (yt & rt) << 4 | mt >>> 22, mt = yt;
      }
      mt >>>= 22, We.words[ft - 10] = mt, mt === 0 && We.length > 10 ? We.length -= 10 : We.length -= 9;
    }, Zt.prototype.imulK = function(We) {
      We.words[We.length] = 0, We.words[We.length + 1] = 0, We.length += 2;
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = We.words[rt] | 0;
        Xe += ot * 977, We.words[rt] = Xe & 67108863, Xe = ot * 64 + (Xe / 67108864 | 0);
      }
      return We.words[We.length - 1] === 0 && (We.length--, We.words[We.length - 1] === 0 && We.length--), We;
    };
    function Lt() {
      Ct.call(this || _global$y, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    Ke(Lt, Ct);
    function Ut() {
      Ct.call(this || _global$y, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    Ke(Ut, Ct);
    function Pt() {
      Ct.call(this || _global$y, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    Ke(Pt, Ct), Pt.prototype.imulK = function(We) {
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = (We.words[rt] | 0) * 19 + Xe, ft = ot & 67108863;
        ot >>>= 26, We.words[rt] = ft, Xe = ot;
      }
      return Xe !== 0 && (We.words[We.length++] = Xe), We;
    }, Ve._prime = function(We) {
      if (Rt[We])
        return Rt[We];
      var Xe;
      if (We === "k256")
        Xe = new Zt();
      else if (We === "p224")
        Xe = new Lt();
      else if (We === "p192")
        Xe = new Ut();
      else if (We === "p25519")
        Xe = new Pt();
      else
        throw new Error("Unknown prime " + We);
      return Rt[We] = Xe, Xe;
    };
    function Ot(gt) {
      if (typeof gt == "string") {
        var We = Ve._prime(gt);
        (this || _global$y).m = We.p, (this || _global$y).prime = We;
      } else
        Fe(gt.gtn(1), "modulus must be greater than 1"), (this || _global$y).m = gt, (this || _global$y).prime = null;
    }
    Ot.prototype._verify1 = function(We) {
      Fe(We.negative === 0, "red works only with positives"), Fe(We.red, "red works only with red numbers");
    }, Ot.prototype._verify2 = function(We, Xe) {
      Fe((We.negative | Xe.negative) === 0, "red works only with positives"), Fe(We.red && We.red === Xe.red, "red works only with red numbers");
    }, Ot.prototype.imod = function(We) {
      return (this || _global$y).prime ? (this || _global$y).prime.ireduce(We)._forceRed(this || _global$y) : We.umod((this || _global$y).m)._forceRed(this || _global$y);
    }, Ot.prototype.neg = function(We) {
      return We.isZero() ? We.clone() : (this || _global$y).m.sub(We)._forceRed(this || _global$y);
    }, Ot.prototype.add = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.add(Xe);
      return rt.cmp((this || _global$y).m) >= 0 && rt.isub((this || _global$y).m), rt._forceRed(this || _global$y);
    }, Ot.prototype.iadd = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.iadd(Xe);
      return rt.cmp((this || _global$y).m) >= 0 && rt.isub((this || _global$y).m), rt;
    }, Ot.prototype.sub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.sub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$y).m), rt._forceRed(this || _global$y);
    }, Ot.prototype.isub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.isub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$y).m), rt;
    }, Ot.prototype.shl = function(We, Xe) {
      return this._verify1(We), this.imod(We.ushln(Xe));
    }, Ot.prototype.imul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.imul(Xe));
    }, Ot.prototype.mul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.mul(Xe));
    }, Ot.prototype.isqr = function(We) {
      return this.imul(We, We.clone());
    }, Ot.prototype.sqr = function(We) {
      return this.mul(We, We);
    }, Ot.prototype.sqrt = function(We) {
      if (We.isZero())
        return We.clone();
      var Xe = (this || _global$y).m.andln(3);
      if (Fe(Xe % 2 === 1), Xe === 3) {
        var rt = (this || _global$y).m.add(new Ve(1)).iushrn(2);
        return this.pow(We, rt);
      }
      for (var ot = (this || _global$y).m.subn(1), ft = 0; !ot.isZero() && ot.andln(1) === 0; )
        ft++, ot.iushrn(1);
      Fe(!ot.isZero());
      var mt = new Ve(1).toRed(this || _global$y), yt = mt.redNeg(), pt = (this || _global$y).m.subn(1).iushrn(1), Ge = (this || _global$y).m.bitLength();
      for (Ge = new Ve(2 * Ge * Ge).toRed(this || _global$y); this.pow(Ge, pt).cmp(yt) !== 0; )
        Ge.redIAdd(yt);
      for (var ct = this.pow(Ge, ot), Mt = this.pow(We, ot.addn(1).iushrn(1)), St = this.pow(We, ot), At = ft; St.cmp(mt) !== 0; ) {
        for (var Nt = St, qt = 0; Nt.cmp(mt) !== 0; qt++)
          Nt = Nt.redSqr();
        Fe(qt < At);
        var Qt = this.pow(ct, new Ve(1).iushln(At - qt - 1));
        Mt = Mt.redMul(Qt), ct = Qt.redSqr(), St = St.redMul(ct), At = qt;
      }
      return Mt;
    }, Ot.prototype.invm = function(We) {
      var Xe = We._invmp((this || _global$y).m);
      return Xe.negative !== 0 ? (Xe.negative = 0, this.imod(Xe).redNeg()) : this.imod(Xe);
    }, Ot.prototype.pow = function(We, Xe) {
      if (Xe.isZero())
        return new Ve(1).toRed(this || _global$y);
      if (Xe.cmpn(1) === 0)
        return We.clone();
      var rt = 4, ot = new Array(1 << rt);
      ot[0] = new Ve(1).toRed(this || _global$y), ot[1] = We;
      for (var ft = 2; ft < ot.length; ft++)
        ot[ft] = this.mul(ot[ft - 1], We);
      var mt = ot[0], yt = 0, pt = 0, Ge = Xe.bitLength() % 26;
      for (Ge === 0 && (Ge = 26), ft = Xe.length - 1; ft >= 0; ft--) {
        for (var ct = Xe.words[ft], Mt = Ge - 1; Mt >= 0; Mt--) {
          var St = ct >> Mt & 1;
          if (mt !== ot[0] && (mt = this.sqr(mt)), St === 0 && yt === 0) {
            pt = 0;
            continue;
          }
          yt <<= 1, yt |= St, pt++, !(pt !== rt && (ft !== 0 || Mt !== 0)) && (mt = this.mul(mt, ot[yt]), pt = 0, yt = 0);
        }
        Ge = 26;
      }
      return mt;
    }, Ot.prototype.convertTo = function(We) {
      var Xe = We.umod((this || _global$y).m);
      return Xe === We ? Xe.clone() : Xe;
    }, Ot.prototype.convertFrom = function(We) {
      var Xe = We.clone();
      return Xe.red = null, Xe;
    }, Ve.mont = function(We) {
      return new Ft(We);
    };
    function Ft(gt) {
      Ot.call(this || _global$y, gt), (this || _global$y).shift = (this || _global$y).m.bitLength(), (this || _global$y).shift % 26 !== 0 && ((this || _global$y).shift += 26 - (this || _global$y).shift % 26), (this || _global$y).r = new Ve(1).iushln((this || _global$y).shift), (this || _global$y).r2 = this.imod((this || _global$y).r.sqr()), (this || _global$y).rinv = (this || _global$y).r._invmp((this || _global$y).m), (this || _global$y).minv = (this || _global$y).rinv.mul((this || _global$y).r).isubn(1).div((this || _global$y).m), (this || _global$y).minv = (this || _global$y).minv.umod((this || _global$y).r), (this || _global$y).minv = (this || _global$y).r.sub((this || _global$y).minv);
    }
    Ke(Ft, Ot), Ft.prototype.convertTo = function(We) {
      return this.imod(We.ushln((this || _global$y).shift));
    }, Ft.prototype.convertFrom = function(We) {
      var Xe = this.imod(We.mul((this || _global$y).rinv));
      return Xe.red = null, Xe;
    }, Ft.prototype.imul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return We.words[0] = 0, We.length = 1, We;
      var rt = We.imul(Xe), ot = rt.maskn((this || _global$y).shift).mul((this || _global$y).minv).imaskn((this || _global$y).shift).mul((this || _global$y).m), ft = rt.isub(ot).iushrn((this || _global$y).shift), mt = ft;
      return ft.cmp((this || _global$y).m) >= 0 ? mt = ft.isub((this || _global$y).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$y).m)), mt._forceRed(this || _global$y);
    }, Ft.prototype.mul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return new Ve(0)._forceRed(this || _global$y);
      var rt = We.mul(Xe), ot = rt.maskn((this || _global$y).shift).mul((this || _global$y).minv).imaskn((this || _global$y).shift).mul((this || _global$y).m), ft = rt.isub(ot).iushrn((this || _global$y).shift), mt = ft;
      return ft.cmp((this || _global$y).m) >= 0 ? mt = ft.isub((this || _global$y).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$y).m)), mt._forceRed(this || _global$y);
    }, Ft.prototype.invm = function(We) {
      var Xe = this.imod(We._invmp((this || _global$y).m).mul((this || _global$y).r2));
      return Xe._forceRed(this || _global$y);
    };
  }(module$9, exports$1X)), module$9.exports;
}
var exports$1W = {}, _dewExec$1V = !1;
function dew$1V() {
  return _dewExec$1V || (_dewExec$1V = !0, exports$1W = exports$1W = dew$3$2(), exports$1W.Stream = exports$1W, exports$1W.Readable = exports$1W, exports$1W.Writable = dew$8$2(), exports$1W.Duplex = dew$7$2(), exports$1W.Transform = dew$2$2(), exports$1W.PassThrough = dew$1$2(), exports$1W.finished = dew$6$2(), exports$1W.pipeline = dew$2B()), exports$1W;
}
var exports$1U = {}, _dewExec$1T = !1;
function dew$1T() {
  if (_dewExec$1T)
    return exports$1U;
  _dewExec$1T = !0;
  var $e = e$1$1$1, Ze = $e.Buffer;
  function Fe(Ve, Je) {
    for (var Qe in Ve)
      Je[Qe] = Ve[Qe];
  }
  Ze.from && Ze.alloc && Ze.allocUnsafe && Ze.allocUnsafeSlow ? exports$1U = $e : (Fe($e, exports$1U), exports$1U.Buffer = Ke);
  function Ke(Ve, Je, Qe) {
    return Ze(Ve, Je, Qe);
  }
  return Ke.prototype = Object.create(Ze.prototype), Fe(Ze, Ke), Ke.from = function(Ve, Je, Qe) {
    if (typeof Ve == "number")
      throw new TypeError("Argument must not be a number");
    return Ze(Ve, Je, Qe);
  }, Ke.alloc = function(Ve, Je, Qe) {
    if (typeof Ve != "number")
      throw new TypeError("Argument must be a number");
    var at = Ze(Ve);
    return Je !== void 0 ? typeof Qe == "string" ? at.fill(Je, Qe) : at.fill(Je) : at.fill(0), at;
  }, Ke.allocUnsafe = function(Ve) {
    if (typeof Ve != "number")
      throw new TypeError("Argument must be a number");
    return Ze(Ve);
  }, Ke.allocUnsafeSlow = function(Ve) {
    if (typeof Ve != "number")
      throw new TypeError("Argument must be a number");
    return $e.SlowBuffer(Ve);
  }, exports$1U;
}
var exports$1T = {}, _dewExec$1S = !1, _global$w = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1S() {
  if (_dewExec$1S)
    return exports$1T;
  _dewExec$1S = !0;
  var $e = T, Ze = 65536, Fe = 4294967295;
  function Ke() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var Ve = dew$1T().Buffer, Je = _global$w.crypto || _global$w.msCrypto;
  Je && Je.getRandomValues ? exports$1T = Qe : exports$1T = Ke;
  function Qe(at, ut) {
    if (at > Fe)
      throw new RangeError("requested too many random bytes");
    var lt = Ve.allocUnsafe(at);
    if (at > 0)
      if (at > Ze)
        for (var dt = 0; dt < at; dt += Ze)
          Je.getRandomValues(lt.slice(dt, dt + Ze));
      else
        Je.getRandomValues(lt);
    return typeof ut == "function" ? $e.nextTick(function() {
      ut(null, lt);
    }) : lt;
  }
  return exports$1T;
}
var exports$1S = {}, _dewExec$1R = !1;
function dew$1R() {
  if (_dewExec$1R)
    return exports$1S;
  _dewExec$1R = !0;
  var $e = dew$1T().Buffer, Ze = dew$1V().Transform, Fe = dew$f$2();
  function Ke(Je, Qe) {
    if (!$e.isBuffer(Je) && typeof Je != "string")
      throw new TypeError(Qe + " must be a string or a buffer");
  }
  function Ve(Je) {
    Ze.call(this), this._block = $e.allocUnsafe(Je), this._blockSize = Je, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return Fe(Ve, Ze), Ve.prototype._transform = function(Je, Qe, at) {
    var ut = null;
    try {
      this.update(Je, Qe);
    } catch (lt) {
      ut = lt;
    }
    at(ut);
  }, Ve.prototype._flush = function(Je) {
    var Qe = null;
    try {
      this.push(this.digest());
    } catch (at) {
      Qe = at;
    }
    Je(Qe);
  }, Ve.prototype.update = function(Je, Qe) {
    if (Ke(Je, "Data"), this._finalized)
      throw new Error("Digest already called");
    $e.isBuffer(Je) || (Je = $e.from(Je, Qe));
    for (var at = this._block, ut = 0; this._blockOffset + Je.length - ut >= this._blockSize; ) {
      for (var lt = this._blockOffset; lt < this._blockSize; )
        at[lt++] = Je[ut++];
      this._update(), this._blockOffset = 0;
    }
    for (; ut < Je.length; )
      at[this._blockOffset++] = Je[ut++];
    for (var dt = 0, bt = Je.length * 8; bt > 0; ++dt)
      this._length[dt] += bt, bt = this._length[dt] / 4294967296 | 0, bt > 0 && (this._length[dt] -= 4294967296 * bt);
    return this;
  }, Ve.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, Ve.prototype.digest = function(Je) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = !0;
    var Qe = this._digest();
    Je !== void 0 && (Qe = Qe.toString(Je)), this._block.fill(0), this._blockOffset = 0;
    for (var at = 0; at < 4; ++at)
      this._length[at] = 0;
    return Qe;
  }, Ve.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, exports$1S = Ve, exports$1S;
}
var exports$1R = {}, _dewExec$1Q = !1;
function dew$1Q() {
  if (_dewExec$1Q)
    return exports$1R;
  _dewExec$1Q = !0;
  var $e = dew$f$2(), Ze = dew$1R(), Fe = dew$1T().Buffer, Ke = new Array(16);
  function Ve() {
    Ze.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  $e(Ve, Ze), Ve.prototype._update = function() {
    for (var dt = Ke, bt = 0; bt < 16; ++bt)
      dt[bt] = this._block.readInt32LE(bt * 4);
    var $t = this._a, vt = this._b, wt = this._c, xt = this._d;
    $t = Qe($t, vt, wt, xt, dt[0], 3614090360, 7), xt = Qe(xt, $t, vt, wt, dt[1], 3905402710, 12), wt = Qe(wt, xt, $t, vt, dt[2], 606105819, 17), vt = Qe(vt, wt, xt, $t, dt[3], 3250441966, 22), $t = Qe($t, vt, wt, xt, dt[4], 4118548399, 7), xt = Qe(xt, $t, vt, wt, dt[5], 1200080426, 12), wt = Qe(wt, xt, $t, vt, dt[6], 2821735955, 17), vt = Qe(vt, wt, xt, $t, dt[7], 4249261313, 22), $t = Qe($t, vt, wt, xt, dt[8], 1770035416, 7), xt = Qe(xt, $t, vt, wt, dt[9], 2336552879, 12), wt = Qe(wt, xt, $t, vt, dt[10], 4294925233, 17), vt = Qe(vt, wt, xt, $t, dt[11], 2304563134, 22), $t = Qe($t, vt, wt, xt, dt[12], 1804603682, 7), xt = Qe(xt, $t, vt, wt, dt[13], 4254626195, 12), wt = Qe(wt, xt, $t, vt, dt[14], 2792965006, 17), vt = Qe(vt, wt, xt, $t, dt[15], 1236535329, 22), $t = at($t, vt, wt, xt, dt[1], 4129170786, 5), xt = at(xt, $t, vt, wt, dt[6], 3225465664, 9), wt = at(wt, xt, $t, vt, dt[11], 643717713, 14), vt = at(vt, wt, xt, $t, dt[0], 3921069994, 20), $t = at($t, vt, wt, xt, dt[5], 3593408605, 5), xt = at(xt, $t, vt, wt, dt[10], 38016083, 9), wt = at(wt, xt, $t, vt, dt[15], 3634488961, 14), vt = at(vt, wt, xt, $t, dt[4], 3889429448, 20), $t = at($t, vt, wt, xt, dt[9], 568446438, 5), xt = at(xt, $t, vt, wt, dt[14], 3275163606, 9), wt = at(wt, xt, $t, vt, dt[3], 4107603335, 14), vt = at(vt, wt, xt, $t, dt[8], 1163531501, 20), $t = at($t, vt, wt, xt, dt[13], 2850285829, 5), xt = at(xt, $t, vt, wt, dt[2], 4243563512, 9), wt = at(wt, xt, $t, vt, dt[7], 1735328473, 14), vt = at(vt, wt, xt, $t, dt[12], 2368359562, 20), $t = ut($t, vt, wt, xt, dt[5], 4294588738, 4), xt = ut(xt, $t, vt, wt, dt[8], 2272392833, 11), wt = ut(wt, xt, $t, vt, dt[11], 1839030562, 16), vt = ut(vt, wt, xt, $t, dt[14], 4259657740, 23), $t = ut($t, vt, wt, xt, dt[1], 2763975236, 4), xt = ut(xt, $t, vt, wt, dt[4], 1272893353, 11), wt = ut(wt, xt, $t, vt, dt[7], 4139469664, 16), vt = ut(vt, wt, xt, $t, dt[10], 3200236656, 23), $t = ut($t, vt, wt, xt, dt[13], 681279174, 4), xt = ut(xt, $t, vt, wt, dt[0], 3936430074, 11), wt = ut(wt, xt, $t, vt, dt[3], 3572445317, 16), vt = ut(vt, wt, xt, $t, dt[6], 76029189, 23), $t = ut($t, vt, wt, xt, dt[9], 3654602809, 4), xt = ut(xt, $t, vt, wt, dt[12], 3873151461, 11), wt = ut(wt, xt, $t, vt, dt[15], 530742520, 16), vt = ut(vt, wt, xt, $t, dt[2], 3299628645, 23), $t = lt($t, vt, wt, xt, dt[0], 4096336452, 6), xt = lt(xt, $t, vt, wt, dt[7], 1126891415, 10), wt = lt(wt, xt, $t, vt, dt[14], 2878612391, 15), vt = lt(vt, wt, xt, $t, dt[5], 4237533241, 21), $t = lt($t, vt, wt, xt, dt[12], 1700485571, 6), xt = lt(xt, $t, vt, wt, dt[3], 2399980690, 10), wt = lt(wt, xt, $t, vt, dt[10], 4293915773, 15), vt = lt(vt, wt, xt, $t, dt[1], 2240044497, 21), $t = lt($t, vt, wt, xt, dt[8], 1873313359, 6), xt = lt(xt, $t, vt, wt, dt[15], 4264355552, 10), wt = lt(wt, xt, $t, vt, dt[6], 2734768916, 15), vt = lt(vt, wt, xt, $t, dt[13], 1309151649, 21), $t = lt($t, vt, wt, xt, dt[4], 4149444226, 6), xt = lt(xt, $t, vt, wt, dt[11], 3174756917, 10), wt = lt(wt, xt, $t, vt, dt[2], 718787259, 15), vt = lt(vt, wt, xt, $t, dt[9], 3951481745, 21), this._a = this._a + $t | 0, this._b = this._b + vt | 0, this._c = this._c + wt | 0, this._d = this._d + xt | 0;
  }, Ve.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var dt = Fe.allocUnsafe(16);
    return dt.writeInt32LE(this._a, 0), dt.writeInt32LE(this._b, 4), dt.writeInt32LE(this._c, 8), dt.writeInt32LE(this._d, 12), dt;
  };
  function Je(dt, bt) {
    return dt << bt | dt >>> 32 - bt;
  }
  function Qe(dt, bt, $t, vt, wt, xt, Et) {
    return Je(dt + (bt & $t | ~bt & vt) + wt + xt | 0, Et) + bt | 0;
  }
  function at(dt, bt, $t, vt, wt, xt, Et) {
    return Je(dt + (bt & vt | $t & ~vt) + wt + xt | 0, Et) + bt | 0;
  }
  function ut(dt, bt, $t, vt, wt, xt, Et) {
    return Je(dt + (bt ^ $t ^ vt) + wt + xt | 0, Et) + bt | 0;
  }
  function lt(dt, bt, $t, vt, wt, xt, Et) {
    return Je(dt + ($t ^ (bt | ~vt)) + wt + xt | 0, Et) + bt | 0;
  }
  return exports$1R = Ve, exports$1R;
}
var exports$1Q = {}, _dewExec$1P = !1;
function dew$1P() {
  if (_dewExec$1P)
    return exports$1Q;
  _dewExec$1P = !0;
  var $e = e$1$1$1.Buffer, Ze = dew$f$2(), Fe = dew$1R(), Ke = new Array(16), Ve = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], Je = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], Qe = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], at = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], ut = [0, 1518500249, 1859775393, 2400959708, 2840853838], lt = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function dt() {
    Fe.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  Ze(dt, Fe), dt.prototype._update = function() {
    for (var Tt = Ke, Rt = 0; Rt < 16; ++Rt)
      Tt[Rt] = this._block.readInt32LE(Rt * 4);
    for (var Ct = this._a | 0, Zt = this._b | 0, Lt = this._c | 0, Ut = this._d | 0, Pt = this._e | 0, Ot = this._a | 0, Ft = this._b | 0, gt = this._c | 0, We = this._d | 0, Xe = this._e | 0, rt = 0; rt < 80; rt += 1) {
      var ot, ft;
      rt < 16 ? (ot = $t(Ct, Zt, Lt, Ut, Pt, Tt[Ve[rt]], ut[0], Qe[rt]), ft = Et(Ot, Ft, gt, We, Xe, Tt[Je[rt]], lt[0], at[rt])) : rt < 32 ? (ot = vt(Ct, Zt, Lt, Ut, Pt, Tt[Ve[rt]], ut[1], Qe[rt]), ft = xt(Ot, Ft, gt, We, Xe, Tt[Je[rt]], lt[1], at[rt])) : rt < 48 ? (ot = wt(Ct, Zt, Lt, Ut, Pt, Tt[Ve[rt]], ut[2], Qe[rt]), ft = wt(Ot, Ft, gt, We, Xe, Tt[Je[rt]], lt[2], at[rt])) : rt < 64 ? (ot = xt(Ct, Zt, Lt, Ut, Pt, Tt[Ve[rt]], ut[3], Qe[rt]), ft = vt(Ot, Ft, gt, We, Xe, Tt[Je[rt]], lt[3], at[rt])) : (ot = Et(Ct, Zt, Lt, Ut, Pt, Tt[Ve[rt]], ut[4], Qe[rt]), ft = $t(Ot, Ft, gt, We, Xe, Tt[Je[rt]], lt[4], at[rt])), Ct = Pt, Pt = Ut, Ut = bt(Lt, 10), Lt = Zt, Zt = ot, Ot = Xe, Xe = We, We = bt(gt, 10), gt = Ft, Ft = ft;
    }
    var mt = this._b + Lt + We | 0;
    this._b = this._c + Ut + Xe | 0, this._c = this._d + Pt + Ot | 0, this._d = this._e + Ct + Ft | 0, this._e = this._a + Zt + gt | 0, this._a = mt;
  }, dt.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var Tt = $e.alloc ? $e.alloc(20) : new $e(20);
    return Tt.writeInt32LE(this._a, 0), Tt.writeInt32LE(this._b, 4), Tt.writeInt32LE(this._c, 8), Tt.writeInt32LE(this._d, 12), Tt.writeInt32LE(this._e, 16), Tt;
  };
  function bt(Tt, Rt) {
    return Tt << Rt | Tt >>> 32 - Rt;
  }
  function $t(Tt, Rt, Ct, Zt, Lt, Ut, Pt, Ot) {
    return bt(Tt + (Rt ^ Ct ^ Zt) + Ut + Pt | 0, Ot) + Lt | 0;
  }
  function vt(Tt, Rt, Ct, Zt, Lt, Ut, Pt, Ot) {
    return bt(Tt + (Rt & Ct | ~Rt & Zt) + Ut + Pt | 0, Ot) + Lt | 0;
  }
  function wt(Tt, Rt, Ct, Zt, Lt, Ut, Pt, Ot) {
    return bt(Tt + ((Rt | ~Ct) ^ Zt) + Ut + Pt | 0, Ot) + Lt | 0;
  }
  function xt(Tt, Rt, Ct, Zt, Lt, Ut, Pt, Ot) {
    return bt(Tt + (Rt & Zt | Ct & ~Zt) + Ut + Pt | 0, Ot) + Lt | 0;
  }
  function Et(Tt, Rt, Ct, Zt, Lt, Ut, Pt, Ot) {
    return bt(Tt + (Rt ^ (Ct | ~Zt)) + Ut + Pt | 0, Ot) + Lt | 0;
  }
  return exports$1Q = dt, exports$1Q;
}
var exports$1P = {}, _dewExec$1O = !1, _global$v = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1O() {
  if (_dewExec$1O)
    return exports$1P;
  _dewExec$1O = !0;
  var $e = dew$1T().Buffer;
  function Ze(Fe, Ke) {
    (this || _global$v)._block = $e.alloc(Fe), (this || _global$v)._finalSize = Ke, (this || _global$v)._blockSize = Fe, (this || _global$v)._len = 0;
  }
  return Ze.prototype.update = function(Fe, Ke) {
    typeof Fe == "string" && (Ke = Ke || "utf8", Fe = $e.from(Fe, Ke));
    for (var Ve = (this || _global$v)._block, Je = (this || _global$v)._blockSize, Qe = Fe.length, at = (this || _global$v)._len, ut = 0; ut < Qe; ) {
      for (var lt = at % Je, dt = Math.min(Qe - ut, Je - lt), bt = 0; bt < dt; bt++)
        Ve[lt + bt] = Fe[ut + bt];
      at += dt, ut += dt, at % Je === 0 && this._update(Ve);
    }
    return (this || _global$v)._len += Qe, this || _global$v;
  }, Ze.prototype.digest = function(Fe) {
    var Ke = (this || _global$v)._len % (this || _global$v)._blockSize;
    (this || _global$v)._block[Ke] = 128, (this || _global$v)._block.fill(0, Ke + 1), Ke >= (this || _global$v)._finalSize && (this._update((this || _global$v)._block), (this || _global$v)._block.fill(0));
    var Ve = (this || _global$v)._len * 8;
    if (Ve <= 4294967295)
      (this || _global$v)._block.writeUInt32BE(Ve, (this || _global$v)._blockSize - 4);
    else {
      var Je = (Ve & 4294967295) >>> 0, Qe = (Ve - Je) / 4294967296;
      (this || _global$v)._block.writeUInt32BE(Qe, (this || _global$v)._blockSize - 8), (this || _global$v)._block.writeUInt32BE(Je, (this || _global$v)._blockSize - 4);
    }
    this._update((this || _global$v)._block);
    var at = this._hash();
    return Fe ? at.toString(Fe) : at;
  }, Ze.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, exports$1P = Ze, exports$1P;
}
var exports$1O = {}, _dewExec$1N = !1, _global$u = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1N() {
  if (_dewExec$1N)
    return exports$1O;
  _dewExec$1N = !0;
  var $e = dew$f$2(), Ze = dew$1O(), Fe = dew$1T().Buffer, Ke = [1518500249, 1859775393, -1894007588, -899497514], Ve = new Array(80);
  function Je() {
    this.init(), (this || _global$u)._w = Ve, Ze.call(this || _global$u, 64, 56);
  }
  $e(Je, Ze), Je.prototype.init = function() {
    return (this || _global$u)._a = 1732584193, (this || _global$u)._b = 4023233417, (this || _global$u)._c = 2562383102, (this || _global$u)._d = 271733878, (this || _global$u)._e = 3285377520, this || _global$u;
  };
  function Qe(lt) {
    return lt << 5 | lt >>> 27;
  }
  function at(lt) {
    return lt << 30 | lt >>> 2;
  }
  function ut(lt, dt, bt, $t) {
    return lt === 0 ? dt & bt | ~dt & $t : lt === 2 ? dt & bt | dt & $t | bt & $t : dt ^ bt ^ $t;
  }
  return Je.prototype._update = function(lt) {
    for (var dt = (this || _global$u)._w, bt = (this || _global$u)._a | 0, $t = (this || _global$u)._b | 0, vt = (this || _global$u)._c | 0, wt = (this || _global$u)._d | 0, xt = (this || _global$u)._e | 0, Et = 0; Et < 16; ++Et)
      dt[Et] = lt.readInt32BE(Et * 4);
    for (; Et < 80; ++Et)
      dt[Et] = dt[Et - 3] ^ dt[Et - 8] ^ dt[Et - 14] ^ dt[Et - 16];
    for (var Tt = 0; Tt < 80; ++Tt) {
      var Rt = ~~(Tt / 20), Ct = Qe(bt) + ut(Rt, $t, vt, wt) + xt + dt[Tt] + Ke[Rt] | 0;
      xt = wt, wt = vt, vt = at($t), $t = bt, bt = Ct;
    }
    (this || _global$u)._a = bt + (this || _global$u)._a | 0, (this || _global$u)._b = $t + (this || _global$u)._b | 0, (this || _global$u)._c = vt + (this || _global$u)._c | 0, (this || _global$u)._d = wt + (this || _global$u)._d | 0, (this || _global$u)._e = xt + (this || _global$u)._e | 0;
  }, Je.prototype._hash = function() {
    var lt = Fe.allocUnsafe(20);
    return lt.writeInt32BE((this || _global$u)._a | 0, 0), lt.writeInt32BE((this || _global$u)._b | 0, 4), lt.writeInt32BE((this || _global$u)._c | 0, 8), lt.writeInt32BE((this || _global$u)._d | 0, 12), lt.writeInt32BE((this || _global$u)._e | 0, 16), lt;
  }, exports$1O = Je, exports$1O;
}
var exports$1N = {}, _dewExec$1M = !1, _global$t = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1M() {
  if (_dewExec$1M)
    return exports$1N;
  _dewExec$1M = !0;
  var $e = dew$f$2(), Ze = dew$1O(), Fe = dew$1T().Buffer, Ke = [1518500249, 1859775393, -1894007588, -899497514], Ve = new Array(80);
  function Je() {
    this.init(), (this || _global$t)._w = Ve, Ze.call(this || _global$t, 64, 56);
  }
  $e(Je, Ze), Je.prototype.init = function() {
    return (this || _global$t)._a = 1732584193, (this || _global$t)._b = 4023233417, (this || _global$t)._c = 2562383102, (this || _global$t)._d = 271733878, (this || _global$t)._e = 3285377520, this || _global$t;
  };
  function Qe(dt) {
    return dt << 1 | dt >>> 31;
  }
  function at(dt) {
    return dt << 5 | dt >>> 27;
  }
  function ut(dt) {
    return dt << 30 | dt >>> 2;
  }
  function lt(dt, bt, $t, vt) {
    return dt === 0 ? bt & $t | ~bt & vt : dt === 2 ? bt & $t | bt & vt | $t & vt : bt ^ $t ^ vt;
  }
  return Je.prototype._update = function(dt) {
    for (var bt = (this || _global$t)._w, $t = (this || _global$t)._a | 0, vt = (this || _global$t)._b | 0, wt = (this || _global$t)._c | 0, xt = (this || _global$t)._d | 0, Et = (this || _global$t)._e | 0, Tt = 0; Tt < 16; ++Tt)
      bt[Tt] = dt.readInt32BE(Tt * 4);
    for (; Tt < 80; ++Tt)
      bt[Tt] = Qe(bt[Tt - 3] ^ bt[Tt - 8] ^ bt[Tt - 14] ^ bt[Tt - 16]);
    for (var Rt = 0; Rt < 80; ++Rt) {
      var Ct = ~~(Rt / 20), Zt = at($t) + lt(Ct, vt, wt, xt) + Et + bt[Rt] + Ke[Ct] | 0;
      Et = xt, xt = wt, wt = ut(vt), vt = $t, $t = Zt;
    }
    (this || _global$t)._a = $t + (this || _global$t)._a | 0, (this || _global$t)._b = vt + (this || _global$t)._b | 0, (this || _global$t)._c = wt + (this || _global$t)._c | 0, (this || _global$t)._d = xt + (this || _global$t)._d | 0, (this || _global$t)._e = Et + (this || _global$t)._e | 0;
  }, Je.prototype._hash = function() {
    var dt = Fe.allocUnsafe(20);
    return dt.writeInt32BE((this || _global$t)._a | 0, 0), dt.writeInt32BE((this || _global$t)._b | 0, 4), dt.writeInt32BE((this || _global$t)._c | 0, 8), dt.writeInt32BE((this || _global$t)._d | 0, 12), dt.writeInt32BE((this || _global$t)._e | 0, 16), dt;
  }, exports$1N = Je, exports$1N;
}
var exports$1M = {}, _dewExec$1L = !1, _global$s = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1L() {
  if (_dewExec$1L)
    return exports$1M;
  _dewExec$1L = !0;
  var $e = dew$f$2(), Ze = dew$1O(), Fe = dew$1T().Buffer, Ke = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], Ve = new Array(64);
  function Je() {
    this.init(), (this || _global$s)._w = Ve, Ze.call(this || _global$s, 64, 56);
  }
  $e(Je, Ze), Je.prototype.init = function() {
    return (this || _global$s)._a = 1779033703, (this || _global$s)._b = 3144134277, (this || _global$s)._c = 1013904242, (this || _global$s)._d = 2773480762, (this || _global$s)._e = 1359893119, (this || _global$s)._f = 2600822924, (this || _global$s)._g = 528734635, (this || _global$s)._h = 1541459225, this || _global$s;
  };
  function Qe($t, vt, wt) {
    return wt ^ $t & (vt ^ wt);
  }
  function at($t, vt, wt) {
    return $t & vt | wt & ($t | vt);
  }
  function ut($t) {
    return ($t >>> 2 | $t << 30) ^ ($t >>> 13 | $t << 19) ^ ($t >>> 22 | $t << 10);
  }
  function lt($t) {
    return ($t >>> 6 | $t << 26) ^ ($t >>> 11 | $t << 21) ^ ($t >>> 25 | $t << 7);
  }
  function dt($t) {
    return ($t >>> 7 | $t << 25) ^ ($t >>> 18 | $t << 14) ^ $t >>> 3;
  }
  function bt($t) {
    return ($t >>> 17 | $t << 15) ^ ($t >>> 19 | $t << 13) ^ $t >>> 10;
  }
  return Je.prototype._update = function($t) {
    for (var vt = (this || _global$s)._w, wt = (this || _global$s)._a | 0, xt = (this || _global$s)._b | 0, Et = (this || _global$s)._c | 0, Tt = (this || _global$s)._d | 0, Rt = (this || _global$s)._e | 0, Ct = (this || _global$s)._f | 0, Zt = (this || _global$s)._g | 0, Lt = (this || _global$s)._h | 0, Ut = 0; Ut < 16; ++Ut)
      vt[Ut] = $t.readInt32BE(Ut * 4);
    for (; Ut < 64; ++Ut)
      vt[Ut] = bt(vt[Ut - 2]) + vt[Ut - 7] + dt(vt[Ut - 15]) + vt[Ut - 16] | 0;
    for (var Pt = 0; Pt < 64; ++Pt) {
      var Ot = Lt + lt(Rt) + Qe(Rt, Ct, Zt) + Ke[Pt] + vt[Pt] | 0, Ft = ut(wt) + at(wt, xt, Et) | 0;
      Lt = Zt, Zt = Ct, Ct = Rt, Rt = Tt + Ot | 0, Tt = Et, Et = xt, xt = wt, wt = Ot + Ft | 0;
    }
    (this || _global$s)._a = wt + (this || _global$s)._a | 0, (this || _global$s)._b = xt + (this || _global$s)._b | 0, (this || _global$s)._c = Et + (this || _global$s)._c | 0, (this || _global$s)._d = Tt + (this || _global$s)._d | 0, (this || _global$s)._e = Rt + (this || _global$s)._e | 0, (this || _global$s)._f = Ct + (this || _global$s)._f | 0, (this || _global$s)._g = Zt + (this || _global$s)._g | 0, (this || _global$s)._h = Lt + (this || _global$s)._h | 0;
  }, Je.prototype._hash = function() {
    var $t = Fe.allocUnsafe(32);
    return $t.writeInt32BE((this || _global$s)._a, 0), $t.writeInt32BE((this || _global$s)._b, 4), $t.writeInt32BE((this || _global$s)._c, 8), $t.writeInt32BE((this || _global$s)._d, 12), $t.writeInt32BE((this || _global$s)._e, 16), $t.writeInt32BE((this || _global$s)._f, 20), $t.writeInt32BE((this || _global$s)._g, 24), $t.writeInt32BE((this || _global$s)._h, 28), $t;
  }, exports$1M = Je, exports$1M;
}
var exports$1L = {}, _dewExec$1K = !1, _global$r = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1K() {
  if (_dewExec$1K)
    return exports$1L;
  _dewExec$1K = !0;
  var $e = dew$f$2(), Ze = dew$1L(), Fe = dew$1O(), Ke = dew$1T().Buffer, Ve = new Array(64);
  function Je() {
    this.init(), (this || _global$r)._w = Ve, Fe.call(this || _global$r, 64, 56);
  }
  return $e(Je, Ze), Je.prototype.init = function() {
    return (this || _global$r)._a = 3238371032, (this || _global$r)._b = 914150663, (this || _global$r)._c = 812702999, (this || _global$r)._d = 4144912697, (this || _global$r)._e = 4290775857, (this || _global$r)._f = 1750603025, (this || _global$r)._g = 1694076839, (this || _global$r)._h = 3204075428, this || _global$r;
  }, Je.prototype._hash = function() {
    var Qe = Ke.allocUnsafe(28);
    return Qe.writeInt32BE((this || _global$r)._a, 0), Qe.writeInt32BE((this || _global$r)._b, 4), Qe.writeInt32BE((this || _global$r)._c, 8), Qe.writeInt32BE((this || _global$r)._d, 12), Qe.writeInt32BE((this || _global$r)._e, 16), Qe.writeInt32BE((this || _global$r)._f, 20), Qe.writeInt32BE((this || _global$r)._g, 24), Qe;
  }, exports$1L = Je, exports$1L;
}
var exports$1K = {}, _dewExec$1J = !1, _global$q = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1J() {
  if (_dewExec$1J)
    return exports$1K;
  _dewExec$1J = !0;
  var $e = dew$f$2(), Ze = dew$1O(), Fe = dew$1T().Buffer, Ke = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], Ve = new Array(160);
  function Je() {
    this.init(), (this || _global$q)._w = Ve, Ze.call(this || _global$q, 128, 112);
  }
  $e(Je, Ze), Je.prototype.init = function() {
    return (this || _global$q)._ah = 1779033703, (this || _global$q)._bh = 3144134277, (this || _global$q)._ch = 1013904242, (this || _global$q)._dh = 2773480762, (this || _global$q)._eh = 1359893119, (this || _global$q)._fh = 2600822924, (this || _global$q)._gh = 528734635, (this || _global$q)._hh = 1541459225, (this || _global$q)._al = 4089235720, (this || _global$q)._bl = 2227873595, (this || _global$q)._cl = 4271175723, (this || _global$q)._dl = 1595750129, (this || _global$q)._el = 2917565137, (this || _global$q)._fl = 725511199, (this || _global$q)._gl = 4215389547, (this || _global$q)._hl = 327033209, this || _global$q;
  };
  function Qe(xt, Et, Tt) {
    return Tt ^ xt & (Et ^ Tt);
  }
  function at(xt, Et, Tt) {
    return xt & Et | Tt & (xt | Et);
  }
  function ut(xt, Et) {
    return (xt >>> 28 | Et << 4) ^ (Et >>> 2 | xt << 30) ^ (Et >>> 7 | xt << 25);
  }
  function lt(xt, Et) {
    return (xt >>> 14 | Et << 18) ^ (xt >>> 18 | Et << 14) ^ (Et >>> 9 | xt << 23);
  }
  function dt(xt, Et) {
    return (xt >>> 1 | Et << 31) ^ (xt >>> 8 | Et << 24) ^ xt >>> 7;
  }
  function bt(xt, Et) {
    return (xt >>> 1 | Et << 31) ^ (xt >>> 8 | Et << 24) ^ (xt >>> 7 | Et << 25);
  }
  function $t(xt, Et) {
    return (xt >>> 19 | Et << 13) ^ (Et >>> 29 | xt << 3) ^ xt >>> 6;
  }
  function vt(xt, Et) {
    return (xt >>> 19 | Et << 13) ^ (Et >>> 29 | xt << 3) ^ (xt >>> 6 | Et << 26);
  }
  function wt(xt, Et) {
    return xt >>> 0 < Et >>> 0 ? 1 : 0;
  }
  return Je.prototype._update = function(xt) {
    for (var Et = (this || _global$q)._w, Tt = (this || _global$q)._ah | 0, Rt = (this || _global$q)._bh | 0, Ct = (this || _global$q)._ch | 0, Zt = (this || _global$q)._dh | 0, Lt = (this || _global$q)._eh | 0, Ut = (this || _global$q)._fh | 0, Pt = (this || _global$q)._gh | 0, Ot = (this || _global$q)._hh | 0, Ft = (this || _global$q)._al | 0, gt = (this || _global$q)._bl | 0, We = (this || _global$q)._cl | 0, Xe = (this || _global$q)._dl | 0, rt = (this || _global$q)._el | 0, ot = (this || _global$q)._fl | 0, ft = (this || _global$q)._gl | 0, mt = (this || _global$q)._hl | 0, yt = 0; yt < 32; yt += 2)
      Et[yt] = xt.readInt32BE(yt * 4), Et[yt + 1] = xt.readInt32BE(yt * 4 + 4);
    for (; yt < 160; yt += 2) {
      var pt = Et[yt - 30], Ge = Et[yt - 15 * 2 + 1], ct = dt(pt, Ge), Mt = bt(Ge, pt);
      pt = Et[yt - 2 * 2], Ge = Et[yt - 2 * 2 + 1];
      var St = $t(pt, Ge), At = vt(Ge, pt), Nt = Et[yt - 7 * 2], qt = Et[yt - 7 * 2 + 1], Qt = Et[yt - 16 * 2], Xt = Et[yt - 16 * 2 + 1], zt = Mt + qt | 0, Kt = ct + Nt + wt(zt, Mt) | 0;
      zt = zt + At | 0, Kt = Kt + St + wt(zt, At) | 0, zt = zt + Xt | 0, Kt = Kt + Qt + wt(zt, Xt) | 0, Et[yt] = Kt, Et[yt + 1] = zt;
    }
    for (var ur = 0; ur < 160; ur += 2) {
      Kt = Et[ur], zt = Et[ur + 1];
      var er = at(Tt, Rt, Ct), Dt = at(Ft, gt, We), Ht = ut(Tt, Ft), Gt = ut(Ft, Tt), rr = lt(Lt, rt), sr = lt(rt, Lt), Jt = Ke[ur], ir = Ke[ur + 1], Br = Qe(Lt, Ut, Pt), or = Qe(rt, ot, ft), lr = mt + sr | 0, Nr = Ot + rr + wt(lr, mt) | 0;
      lr = lr + or | 0, Nr = Nr + Br + wt(lr, or) | 0, lr = lr + ir | 0, Nr = Nr + Jt + wt(lr, ir) | 0, lr = lr + zt | 0, Nr = Nr + Kt + wt(lr, zt) | 0;
      var dr = Gt + Dt | 0, gr = Ht + er + wt(dr, Gt) | 0;
      Ot = Pt, mt = ft, Pt = Ut, ft = ot, Ut = Lt, ot = rt, rt = Xe + lr | 0, Lt = Zt + Nr + wt(rt, Xe) | 0, Zt = Ct, Xe = We, Ct = Rt, We = gt, Rt = Tt, gt = Ft, Ft = lr + dr | 0, Tt = Nr + gr + wt(Ft, lr) | 0;
    }
    (this || _global$q)._al = (this || _global$q)._al + Ft | 0, (this || _global$q)._bl = (this || _global$q)._bl + gt | 0, (this || _global$q)._cl = (this || _global$q)._cl + We | 0, (this || _global$q)._dl = (this || _global$q)._dl + Xe | 0, (this || _global$q)._el = (this || _global$q)._el + rt | 0, (this || _global$q)._fl = (this || _global$q)._fl + ot | 0, (this || _global$q)._gl = (this || _global$q)._gl + ft | 0, (this || _global$q)._hl = (this || _global$q)._hl + mt | 0, (this || _global$q)._ah = (this || _global$q)._ah + Tt + wt((this || _global$q)._al, Ft) | 0, (this || _global$q)._bh = (this || _global$q)._bh + Rt + wt((this || _global$q)._bl, gt) | 0, (this || _global$q)._ch = (this || _global$q)._ch + Ct + wt((this || _global$q)._cl, We) | 0, (this || _global$q)._dh = (this || _global$q)._dh + Zt + wt((this || _global$q)._dl, Xe) | 0, (this || _global$q)._eh = (this || _global$q)._eh + Lt + wt((this || _global$q)._el, rt) | 0, (this || _global$q)._fh = (this || _global$q)._fh + Ut + wt((this || _global$q)._fl, ot) | 0, (this || _global$q)._gh = (this || _global$q)._gh + Pt + wt((this || _global$q)._gl, ft) | 0, (this || _global$q)._hh = (this || _global$q)._hh + Ot + wt((this || _global$q)._hl, mt) | 0;
  }, Je.prototype._hash = function() {
    var xt = Fe.allocUnsafe(64);
    function Et(Tt, Rt, Ct) {
      xt.writeInt32BE(Tt, Ct), xt.writeInt32BE(Rt, Ct + 4);
    }
    return Et((this || _global$q)._ah, (this || _global$q)._al, 0), Et((this || _global$q)._bh, (this || _global$q)._bl, 8), Et((this || _global$q)._ch, (this || _global$q)._cl, 16), Et((this || _global$q)._dh, (this || _global$q)._dl, 24), Et((this || _global$q)._eh, (this || _global$q)._el, 32), Et((this || _global$q)._fh, (this || _global$q)._fl, 40), Et((this || _global$q)._gh, (this || _global$q)._gl, 48), Et((this || _global$q)._hh, (this || _global$q)._hl, 56), xt;
  }, exports$1K = Je, exports$1K;
}
var exports$1J = {}, _dewExec$1I = !1, _global$p = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1I() {
  if (_dewExec$1I)
    return exports$1J;
  _dewExec$1I = !0;
  var $e = dew$f$2(), Ze = dew$1J(), Fe = dew$1O(), Ke = dew$1T().Buffer, Ve = new Array(160);
  function Je() {
    this.init(), (this || _global$p)._w = Ve, Fe.call(this || _global$p, 128, 112);
  }
  return $e(Je, Ze), Je.prototype.init = function() {
    return (this || _global$p)._ah = 3418070365, (this || _global$p)._bh = 1654270250, (this || _global$p)._ch = 2438529370, (this || _global$p)._dh = 355462360, (this || _global$p)._eh = 1731405415, (this || _global$p)._fh = 2394180231, (this || _global$p)._gh = 3675008525, (this || _global$p)._hh = 1203062813, (this || _global$p)._al = 3238371032, (this || _global$p)._bl = 914150663, (this || _global$p)._cl = 812702999, (this || _global$p)._dl = 4144912697, (this || _global$p)._el = 4290775857, (this || _global$p)._fl = 1750603025, (this || _global$p)._gl = 1694076839, (this || _global$p)._hl = 3204075428, this || _global$p;
  }, Je.prototype._hash = function() {
    var Qe = Ke.allocUnsafe(48);
    function at(ut, lt, dt) {
      Qe.writeInt32BE(ut, dt), Qe.writeInt32BE(lt, dt + 4);
    }
    return at((this || _global$p)._ah, (this || _global$p)._al, 0), at((this || _global$p)._bh, (this || _global$p)._bl, 8), at((this || _global$p)._ch, (this || _global$p)._cl, 16), at((this || _global$p)._dh, (this || _global$p)._dl, 24), at((this || _global$p)._eh, (this || _global$p)._el, 32), at((this || _global$p)._fh, (this || _global$p)._fl, 40), Qe;
  }, exports$1J = Je, exports$1J;
}
var exports$1I = {}, _dewExec$1H = !1, module$7 = {
  exports: exports$1I
};
function dew$1H() {
  if (_dewExec$1H)
    return module$7.exports;
  _dewExec$1H = !0;
  var $e = module$7.exports = function(Fe) {
    Fe = Fe.toLowerCase();
    var Ke = $e[Fe];
    if (!Ke)
      throw new Error(Fe + " is not supported (we accept pull requests)");
    return new Ke();
  };
  return $e.sha = dew$1N(), $e.sha1 = dew$1M(), $e.sha224 = dew$1K(), $e.sha256 = dew$1L(), $e.sha384 = dew$1I(), $e.sha512 = dew$1J(), module$7.exports;
}
var e$g = y.EventEmitter, e$1$12 = {}, t$c = {};
function n$q($e, Ze, Fe) {
  Fe || (Fe = Error);
  class Ke extends Fe {
    constructor(Je, Qe, at) {
      super(function(ut, lt, dt) {
        return typeof Ze == "string" ? Ze : Ze(ut, lt, dt);
      }(Je, Qe, at));
    }
  }
  Ke.prototype.name = Fe.name, Ke.prototype.code = $e, t$c[$e] = Ke;
}
function r$h($e, Ze) {
  if (Array.isArray($e)) {
    const Fe = $e.length;
    return $e = $e.map((Ke) => String(Ke)), Fe > 2 ? `one of ${Ze} ${$e.slice(0, Fe - 1).join(", ")}, or ` + $e[Fe - 1] : Fe === 2 ? `one of ${Ze} ${$e[0]} or ${$e[1]}` : `of ${Ze} ${$e[0]}`;
  }
  return `of ${Ze} ${String($e)}`;
}
n$q("ERR_INVALID_OPT_VALUE", function($e, Ze) {
  return 'The value "' + Ze + '" is invalid for option "' + $e + '"';
}, TypeError), n$q("ERR_INVALID_ARG_TYPE", function($e, Ze, Fe) {
  let Ke;
  var Ve;
  let Je;
  return typeof Ze == "string" && (Ve = "not ", Ze.substr(0, Ve.length) === Ve) ? (Ke = "must not be", Ze = Ze.replace(/^not /, "")) : Ke = "must be", function(Qe, at, ut) {
    return (ut === void 0 || ut > Qe.length) && (ut = Qe.length), Qe.substring(ut - at.length, ut) === at;
  }($e, " argument") ? Je = `The ${$e} ${Ke} ${r$h(Ze, "type")}` : Je = `The "${$e}" ${function(Qe, at, ut) {
    return typeof ut != "number" && (ut = 0), !(ut + at.length > Qe.length) && Qe.indexOf(at, ut) !== -1;
  }($e, ".") ? "property" : "argument"} ${Ke} ${r$h(Ze, "type")}`, Je += `. Received type ${typeof Fe}`, Je;
}, TypeError), n$q("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), n$q("ERR_METHOD_NOT_IMPLEMENTED", function($e) {
  return "The " + $e + " method is not implemented";
}), n$q("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), n$q("ERR_STREAM_DESTROYED", function($e) {
  return "Cannot call " + $e + " after a stream was destroyed";
}), n$q("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), n$q("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), n$q("ERR_STREAM_WRITE_AFTER_END", "write after end"), n$q("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), n$q("ERR_UNKNOWN_ENCODING", function($e) {
  return "Unknown encoding: " + $e;
}, TypeError), n$q("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), e$1$12.codes = t$c;
var r$1$1$1 = function() {
  throw new Error("Readable.from is not available in the browser");
}, r$2$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function e$2$1($e) {
  try {
    if (!r$2$1.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var Ze = r$2$1.localStorage[$e];
  return Ze != null && String(Ze).toLowerCase() === "true";
}
var t$1$1$1 = function($e, Ze) {
  if (e$2$1("noDeprecation"))
    return $e;
  var Fe = !1;
  return function() {
    if (!Fe) {
      if (e$2$1("throwDeprecation"))
        throw new Error(Ze);
      e$2$1("traceDeprecation") ? console.trace(Ze) : console.warn(Ze), Fe = !0;
    }
    return $e.apply(this || r$2$1, arguments);
  };
};
function u$p($e, Ze) {
  var Fe = Object.keys($e);
  if (Object.getOwnPropertySymbols) {
    var Ke = Object.getOwnPropertySymbols($e);
    Ze && (Ke = Ke.filter(function(Ve) {
      return Object.getOwnPropertyDescriptor($e, Ve).enumerable;
    })), Fe.push.apply(Fe, Ke);
  }
  return Fe;
}
function f$v($e, Ze, Fe) {
  return Ze in $e ? Object.defineProperty($e, Ze, { value: Fe, enumerable: !0, configurable: !0, writable: !0 }) : $e[Ze] = Fe, $e;
}
function h$l($e, Ze) {
  for (var Fe = 0; Fe < Ze.length; Fe++) {
    var Ke = Ze[Fe];
    Ke.enumerable = Ke.enumerable || !1, Ke.configurable = !0, "value" in Ke && (Ke.writable = !0), Object.defineProperty($e, Ke.key, Ke);
  }
}
var c$n = e$1$1$1.Buffer, b$j = X.inspect, p$s = b$j && b$j.custom || "inspect", g$h = function() {
  function $e() {
    (function(Ke, Ve) {
      if (!(Ke instanceof Ve))
        throw new TypeError("Cannot call a class as a function");
    })(this, $e), this.head = null, this.tail = null, this.length = 0;
  }
  var Ze, Fe;
  return Ze = $e, (Fe = [{ key: "push", value: function(Ke) {
    var Ve = { data: Ke, next: null };
    this.length > 0 ? this.tail.next = Ve : this.head = Ve, this.tail = Ve, ++this.length;
  } }, { key: "unshift", value: function(Ke) {
    var Ve = { data: Ke, next: this.head };
    this.length === 0 && (this.tail = Ve), this.head = Ve, ++this.length;
  } }, { key: "shift", value: function() {
    if (this.length !== 0) {
      var Ke = this.head.data;
      return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Ke;
    }
  } }, { key: "clear", value: function() {
    this.head = this.tail = null, this.length = 0;
  } }, { key: "join", value: function(Ke) {
    if (this.length === 0)
      return "";
    for (var Ve = this.head, Je = "" + Ve.data; Ve = Ve.next; )
      Je += Ke + Ve.data;
    return Je;
  } }, { key: "concat", value: function(Ke) {
    if (this.length === 0)
      return c$n.alloc(0);
    for (var Ve, Je, Qe, at = c$n.allocUnsafe(Ke >>> 0), ut = this.head, lt = 0; ut; )
      Ve = ut.data, Je = at, Qe = lt, c$n.prototype.copy.call(Ve, Je, Qe), lt += ut.data.length, ut = ut.next;
    return at;
  } }, { key: "consume", value: function(Ke, Ve) {
    var Je;
    return Ke < this.head.data.length ? (Je = this.head.data.slice(0, Ke), this.head.data = this.head.data.slice(Ke)) : Je = Ke === this.head.data.length ? this.shift() : Ve ? this._getString(Ke) : this._getBuffer(Ke), Je;
  } }, { key: "first", value: function() {
    return this.head.data;
  } }, { key: "_getString", value: function(Ke) {
    var Ve = this.head, Je = 1, Qe = Ve.data;
    for (Ke -= Qe.length; Ve = Ve.next; ) {
      var at = Ve.data, ut = Ke > at.length ? at.length : Ke;
      if (ut === at.length ? Qe += at : Qe += at.slice(0, Ke), (Ke -= ut) == 0) {
        ut === at.length ? (++Je, Ve.next ? this.head = Ve.next : this.head = this.tail = null) : (this.head = Ve, Ve.data = at.slice(ut));
        break;
      }
      ++Je;
    }
    return this.length -= Je, Qe;
  } }, { key: "_getBuffer", value: function(Ke) {
    var Ve = c$n.allocUnsafe(Ke), Je = this.head, Qe = 1;
    for (Je.data.copy(Ve), Ke -= Je.data.length; Je = Je.next; ) {
      var at = Je.data, ut = Ke > at.length ? at.length : Ke;
      if (at.copy(Ve, Ve.length - Ke, 0, ut), (Ke -= ut) == 0) {
        ut === at.length ? (++Qe, Je.next ? this.head = Je.next : this.head = this.tail = null) : (this.head = Je, Je.data = at.slice(ut));
        break;
      }
      ++Qe;
    }
    return this.length -= Qe, Ve;
  } }, { key: p$s, value: function(Ke, Ve) {
    return b$j(this, function(Je) {
      for (var Qe = 1; Qe < arguments.length; Qe++) {
        var at = arguments[Qe] != null ? arguments[Qe] : {};
        Qe % 2 ? u$p(Object(at), !0).forEach(function(ut) {
          f$v(Je, ut, at[ut]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Je, Object.getOwnPropertyDescriptors(at)) : u$p(Object(at)).forEach(function(ut) {
          Object.defineProperty(Je, ut, Object.getOwnPropertyDescriptor(at, ut));
        });
      }
      return Je;
    }({}, Ve, { depth: 0, customInspect: !1 }));
  } }]) && h$l(Ze.prototype, Fe), $e;
}(), y$n = T;
function w$j($e, Ze) {
  _$h($e, Ze), v$k($e);
}
function v$k($e) {
  $e._writableState && !$e._writableState.emitClose || $e._readableState && !$e._readableState.emitClose || $e.emit("close");
}
function _$h($e, Ze) {
  $e.emit("error", Ze);
}
var m$m = { destroy: function($e, Ze) {
  var Fe = this, Ke = this._readableState && this._readableState.destroyed, Ve = this._writableState && this._writableState.destroyed;
  return Ke || Ve ? (Ze ? Ze($e) : $e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, y$n.nextTick(_$h, this, $e)) : y$n.nextTick(_$h, this, $e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy($e || null, function(Je) {
    !Ze && Je ? Fe._writableState ? Fe._writableState.errorEmitted ? y$n.nextTick(v$k, Fe) : (Fe._writableState.errorEmitted = !0, y$n.nextTick(w$j, Fe, Je)) : y$n.nextTick(w$j, Fe, Je) : Ze ? (y$n.nextTick(v$k, Fe), Ze(Je)) : y$n.nextTick(v$k, Fe);
  }), this);
}, undestroy: function() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}, errorOrDestroy: function($e, Ze) {
  var Fe = $e._readableState, Ke = $e._writableState;
  Fe && Fe.autoDestroy || Ke && Ke.autoDestroy ? $e.destroy(Ze) : $e.emit("error", Ze);
} }, S$e = e$1$12.codes.ERR_INVALID_OPT_VALUE, R$7 = { getHighWaterMark: function($e, Ze, Fe, Ke) {
  var Ve = function(Je, Qe, at) {
    return Je.highWaterMark != null ? Je.highWaterMark : Qe ? Je[at] : null;
  }(Ze, Ke, Fe);
  if (Ve != null) {
    if (!isFinite(Ve) || Math.floor(Ve) !== Ve || Ve < 0)
      throw new S$e(Ke ? Fe : "highWaterMark", Ve);
    return Math.floor(Ve);
  }
  return $e.objectMode ? 16 : 16384;
} }, k$g = e$1$12.codes.ERR_STREAM_PREMATURE_CLOSE;
function E$e() {
}
var M$a, j$a = function $e(Ze, Fe, Ke) {
  if (typeof Fe == "function")
    return $e(Ze, null, Fe);
  Fe || (Fe = {}), Ke = function(wt) {
    var xt = !1;
    return function() {
      if (!xt) {
        xt = !0;
        for (var Et = arguments.length, Tt = new Array(Et), Rt = 0; Rt < Et; Rt++)
          Tt[Rt] = arguments[Rt];
        wt.apply(this, Tt);
      }
    };
  }(Ke || E$e);
  var Ve = Fe.readable || Fe.readable !== !1 && Ze.readable, Je = Fe.writable || Fe.writable !== !1 && Ze.writable, Qe = function() {
    Ze.writable || ut();
  }, at = Ze._writableState && Ze._writableState.finished, ut = function() {
    Je = !1, at = !0, Ve || Ke.call(Ze);
  }, lt = Ze._readableState && Ze._readableState.endEmitted, dt = function() {
    Ve = !1, lt = !0, Je || Ke.call(Ze);
  }, bt = function(wt) {
    Ke.call(Ze, wt);
  }, $t = function() {
    var wt;
    return Ve && !lt ? (Ze._readableState && Ze._readableState.ended || (wt = new k$g()), Ke.call(Ze, wt)) : Je && !at ? (Ze._writableState && Ze._writableState.ended || (wt = new k$g()), Ke.call(Ze, wt)) : void 0;
  }, vt = function() {
    Ze.req.on("finish", ut);
  };
  return function(wt) {
    return wt.setHeader && typeof wt.abort == "function";
  }(Ze) ? (Ze.on("complete", ut), Ze.on("abort", $t), Ze.req ? vt() : Ze.on("request", vt)) : Je && !Ze._writableState && (Ze.on("end", Qe), Ze.on("close", Qe)), Ze.on("end", dt), Ze.on("finish", ut), Fe.error !== !1 && Ze.on("error", bt), Ze.on("close", $t), function() {
    Ze.removeListener("complete", ut), Ze.removeListener("abort", $t), Ze.removeListener("request", vt), Ze.req && Ze.req.removeListener("finish", ut), Ze.removeListener("end", Qe), Ze.removeListener("close", Qe), Ze.removeListener("finish", ut), Ze.removeListener("end", dt), Ze.removeListener("error", bt), Ze.removeListener("close", $t);
  };
}, O$8 = T;
function T$8($e, Ze, Fe) {
  return Ze in $e ? Object.defineProperty($e, Ze, { value: Fe, enumerable: !0, configurable: !0, writable: !0 }) : $e[Ze] = Fe, $e;
}
var P$8 = j$a, x$a = Symbol("lastResolve"), L$8 = Symbol("lastReject"), D$9 = Symbol("error"), C$9 = Symbol("ended"), A$c = Symbol("lastPromise"), q$8 = Symbol("handlePromise"), W$5 = Symbol("stream");
function B$c($e, Ze) {
  return { value: $e, done: Ze };
}
function I$b($e) {
  var Ze = $e[x$a];
  if (Ze !== null) {
    var Fe = $e[W$5].read();
    Fe !== null && ($e[A$c] = null, $e[x$a] = null, $e[L$8] = null, Ze(B$c(Fe, !1)));
  }
}
function N$7($e) {
  O$8.nextTick(I$b, $e);
}
var U$a = Object.getPrototypeOf(function() {
}), H$7 = Object.setPrototypeOf((T$8(M$a = { get stream() {
  return this[W$5];
}, next: function() {
  var $e = this, Ze = this[D$9];
  if (Ze !== null)
    return Promise.reject(Ze);
  if (this[C$9])
    return Promise.resolve(B$c(void 0, !0));
  if (this[W$5].destroyed)
    return new Promise(function(Je, Qe) {
      O$8.nextTick(function() {
        $e[D$9] ? Qe($e[D$9]) : Je(B$c(void 0, !0));
      });
    });
  var Fe, Ke = this[A$c];
  if (Ke)
    Fe = new Promise(function(Je, Qe) {
      return function(at, ut) {
        Je.then(function() {
          if (Qe[C$9])
            return at(B$c(void 0, !0)), void 0;
          Qe[q$8](at, ut);
        }, ut);
      };
    }(Ke, this));
  else {
    var Ve = this[W$5].read();
    if (Ve !== null)
      return Promise.resolve(B$c(Ve, !1));
    Fe = new Promise(this[q$8]);
  }
  return this[A$c] = Fe, Fe;
} }, Symbol.asyncIterator, function() {
  return this;
}), T$8(M$a, "return", function() {
  var $e = this;
  return new Promise(function(Ze, Fe) {
    $e[W$5].destroy(null, function(Ke) {
      if (Ke)
        return Fe(Ke), void 0;
      Ze(B$c(void 0, !0));
    });
  });
}), M$a), U$a), F$8 = function($e) {
  var Ze, Fe = Object.create(H$7, (T$8(Ze = {}, W$5, { value: $e, writable: !0 }), T$8(Ze, x$a, { value: null, writable: !0 }), T$8(Ze, L$8, { value: null, writable: !0 }), T$8(Ze, D$9, { value: null, writable: !0 }), T$8(Ze, C$9, { value: $e._readableState.endEmitted, writable: !0 }), T$8(Ze, q$8, { value: function(Ke, Ve) {
    var Je = Fe[W$5].read();
    Je ? (Fe[A$c] = null, Fe[x$a] = null, Fe[L$8] = null, Ke(B$c(Je, !1))) : (Fe[x$a] = Ke, Fe[L$8] = Ve);
  }, writable: !0 }), Ze));
  return Fe[A$c] = null, P$8($e, function(Ke) {
    if (Ke && Ke.code !== "ERR_STREAM_PREMATURE_CLOSE") {
      var Ve = Fe[L$8];
      return Ve !== null && (Fe[A$c] = null, Fe[x$a] = null, Fe[L$8] = null, Ve(Ke)), Fe[D$9] = Ke, void 0;
    }
    var Je = Fe[x$a];
    Je !== null && (Fe[A$c] = null, Fe[x$a] = null, Fe[L$8] = null, Je(B$c(void 0, !0))), Fe[C$9] = !0;
  }), $e.on("readable", N$7.bind(null, Fe)), Fe;
}, V$6 = {}, G$5 = !1, Y$4 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function K$8() {
  if (G$5)
    return V$6;
  G$5 = !0;
  var $e, Ze = T;
  V$6 = Ut, Ut.ReadableState = Lt, y.EventEmitter;
  var Fe = function(St, At) {
    return St.listeners(At).length;
  }, Ke = e$g, Ve = e$1$1$1.Buffer, Je = Y$4.Uint8Array || function() {
  }, Qe, at = X;
  Qe = at && at.debuglog ? at.debuglog("stream") : function() {
  };
  var ut, lt, dt, bt = g$h, $t = m$m, vt = R$7.getHighWaterMark, wt = e$1$12.codes, xt = wt.ERR_INVALID_ARG_TYPE, Et = wt.ERR_STREAM_PUSH_AFTER_EOF, Tt = wt.ERR_METHOD_NOT_IMPLEMENTED, Rt = wt.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  t$2(Ut, Ke);
  var Ct = $t.errorOrDestroy, Zt = ["error", "close", "destroy", "pause", "resume"];
  function Lt(St, At, Nt) {
    $e = $e || ee$1(), St = St || {}, typeof Nt != "boolean" && (Nt = At instanceof $e), this.objectMode = !!St.objectMode, Nt && (this.objectMode = this.objectMode || !!St.readableObjectMode), this.highWaterMark = vt(this, St, "readableHighWaterMark", Nt), this.buffer = new bt(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = St.emitClose !== !1, this.autoDestroy = !!St.autoDestroy, this.destroyed = !1, this.defaultEncoding = St.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, St.encoding && (ut || (ut = e$12.StringDecoder), this.decoder = new ut(St.encoding), this.encoding = St.encoding);
  }
  function Ut(St) {
    if ($e = $e || ee$1(), !(this instanceof Ut))
      return new Ut(St);
    var At = this instanceof $e;
    this._readableState = new Lt(St, this, At), this.readable = !0, St && (typeof St.read == "function" && (this._read = St.read), typeof St.destroy == "function" && (this._destroy = St.destroy)), Ke.call(this);
  }
  function Pt(St, At, Nt, qt, Qt) {
    Qe("readableAddChunk", At);
    var Xt, zt = St._readableState;
    if (At === null)
      zt.reading = !1, function(Kt, ur) {
        if (Qe("onEofChunk"), !ur.ended) {
          if (ur.decoder) {
            var er = ur.decoder.end();
            er && er.length && (ur.buffer.push(er), ur.length += ur.objectMode ? 1 : er.length);
          }
          ur.ended = !0, ur.sync ? gt(Kt) : (ur.needReadable = !1, ur.emittedReadable || (ur.emittedReadable = !0, We(Kt)));
        }
      }(St, zt);
    else if (Qt || (Xt = function(Kt, ur) {
      var er;
      Dt = ur, Ve.isBuffer(Dt) || Dt instanceof Je || typeof ur == "string" || ur === void 0 || Kt.objectMode || (er = new xt("chunk", ["string", "Buffer", "Uint8Array"], ur));
      var Dt;
      return er;
    }(zt, At)), Xt)
      Ct(St, Xt);
    else if (zt.objectMode || At && At.length > 0)
      if (typeof At == "string" || zt.objectMode || Object.getPrototypeOf(At) === Ve.prototype || (At = function(Kt) {
        return Ve.from(Kt);
      }(At)), qt)
        zt.endEmitted ? Ct(St, new Rt()) : Ot(St, zt, At, !0);
      else if (zt.ended)
        Ct(St, new Et());
      else {
        if (zt.destroyed)
          return !1;
        zt.reading = !1, zt.decoder && !Nt ? (At = zt.decoder.write(At), zt.objectMode || At.length !== 0 ? Ot(St, zt, At, !1) : Xe(St, zt)) : Ot(St, zt, At, !1);
      }
    else
      qt || (zt.reading = !1, Xe(St, zt));
    return !zt.ended && (zt.length < zt.highWaterMark || zt.length === 0);
  }
  function Ot(St, At, Nt, qt) {
    At.flowing && At.length === 0 && !At.sync ? (At.awaitDrain = 0, St.emit("data", Nt)) : (At.length += At.objectMode ? 1 : Nt.length, qt ? At.buffer.unshift(Nt) : At.buffer.push(Nt), At.needReadable && gt(St)), Xe(St, At);
  }
  Object.defineProperty(Ut.prototype, "destroyed", { enumerable: !1, get: function() {
    return this._readableState !== void 0 && this._readableState.destroyed;
  }, set: function(St) {
    this._readableState && (this._readableState.destroyed = St);
  } }), Ut.prototype.destroy = $t.destroy, Ut.prototype._undestroy = $t.undestroy, Ut.prototype._destroy = function(St, At) {
    At(St);
  }, Ut.prototype.push = function(St, At) {
    var Nt, qt = this._readableState;
    return qt.objectMode ? Nt = !0 : typeof St == "string" && ((At = At || qt.defaultEncoding) !== qt.encoding && (St = Ve.from(St, At), At = ""), Nt = !0), Pt(this, St, At, !1, Nt);
  }, Ut.prototype.unshift = function(St) {
    return Pt(this, St, null, !0, !1);
  }, Ut.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Ut.prototype.setEncoding = function(St) {
    ut || (ut = e$12.StringDecoder);
    var At = new ut(St);
    this._readableState.decoder = At, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Nt = this._readableState.buffer.head, qt = ""; Nt !== null; )
      qt += At.write(Nt.data), Nt = Nt.next;
    return this._readableState.buffer.clear(), qt !== "" && this._readableState.buffer.push(qt), this._readableState.length = qt.length, this;
  };
  function Ft(St, At) {
    return St <= 0 || At.length === 0 && At.ended ? 0 : At.objectMode ? 1 : St != St ? At.flowing && At.length ? At.buffer.head.data.length : At.length : (St > At.highWaterMark && (At.highWaterMark = function(Nt) {
      return Nt >= 1073741824 ? Nt = 1073741824 : (Nt--, Nt |= Nt >>> 1, Nt |= Nt >>> 2, Nt |= Nt >>> 4, Nt |= Nt >>> 8, Nt |= Nt >>> 16, Nt++), Nt;
    }(St)), St <= At.length ? St : At.ended ? At.length : (At.needReadable = !0, 0));
  }
  function gt(St) {
    var At = St._readableState;
    Qe("emitReadable", At.needReadable, At.emittedReadable), At.needReadable = !1, At.emittedReadable || (Qe("emitReadable", At.flowing), At.emittedReadable = !0, Ze.nextTick(We, St));
  }
  function We(St) {
    var At = St._readableState;
    Qe("emitReadable_", At.destroyed, At.length, At.ended), At.destroyed || !At.length && !At.ended || (St.emit("readable"), At.emittedReadable = !1), At.needReadable = !At.flowing && !At.ended && At.length <= At.highWaterMark, yt(St);
  }
  function Xe(St, At) {
    At.readingMore || (At.readingMore = !0, Ze.nextTick(rt, St, At));
  }
  function rt(St, At) {
    for (; !At.reading && !At.ended && (At.length < At.highWaterMark || At.flowing && At.length === 0); ) {
      var Nt = At.length;
      if (Qe("maybeReadMore read 0"), St.read(0), Nt === At.length)
        break;
    }
    At.readingMore = !1;
  }
  function ot(St) {
    var At = St._readableState;
    At.readableListening = St.listenerCount("readable") > 0, At.resumeScheduled && !At.paused ? At.flowing = !0 : St.listenerCount("data") > 0 && St.resume();
  }
  function ft(St) {
    Qe("readable nexttick read 0"), St.read(0);
  }
  function mt(St, At) {
    Qe("resume", At.reading), At.reading || St.read(0), At.resumeScheduled = !1, St.emit("resume"), yt(St), At.flowing && !At.reading && St.read(0);
  }
  function yt(St) {
    var At = St._readableState;
    for (Qe("flow", At.flowing); At.flowing && St.read() !== null; )
      ;
  }
  function pt(St, At) {
    return At.length === 0 ? null : (At.objectMode ? Nt = At.buffer.shift() : !St || St >= At.length ? (Nt = At.decoder ? At.buffer.join("") : At.buffer.length === 1 ? At.buffer.first() : At.buffer.concat(At.length), At.buffer.clear()) : Nt = At.buffer.consume(St, At.decoder), Nt);
    var Nt;
  }
  function Ge(St) {
    var At = St._readableState;
    Qe("endReadable", At.endEmitted), At.endEmitted || (At.ended = !0, Ze.nextTick(ct, At, St));
  }
  function ct(St, At) {
    if (Qe("endReadableNT", St.endEmitted, St.length), !St.endEmitted && St.length === 0 && (St.endEmitted = !0, At.readable = !1, At.emit("end"), St.autoDestroy)) {
      var Nt = At._writableState;
      (!Nt || Nt.autoDestroy && Nt.finished) && At.destroy();
    }
  }
  function Mt(St, At) {
    for (var Nt = 0, qt = St.length; Nt < qt; Nt++)
      if (St[Nt] === At)
        return Nt;
    return -1;
  }
  return Ut.prototype.read = function(St) {
    Qe("read", St), St = parseInt(St, 10);
    var At = this._readableState, Nt = St;
    if (St !== 0 && (At.emittedReadable = !1), St === 0 && At.needReadable && ((At.highWaterMark !== 0 ? At.length >= At.highWaterMark : At.length > 0) || At.ended))
      return Qe("read: emitReadable", At.length, At.ended), At.length === 0 && At.ended ? Ge(this) : gt(this), null;
    if ((St = Ft(St, At)) === 0 && At.ended)
      return At.length === 0 && Ge(this), null;
    var qt, Qt = At.needReadable;
    return Qe("need readable", Qt), (At.length === 0 || At.length - St < At.highWaterMark) && Qe("length less than watermark", Qt = !0), At.ended || At.reading ? Qe("reading or ended", Qt = !1) : Qt && (Qe("do read"), At.reading = !0, At.sync = !0, At.length === 0 && (At.needReadable = !0), this._read(At.highWaterMark), At.sync = !1, At.reading || (St = Ft(Nt, At))), (qt = St > 0 ? pt(St, At) : null) === null ? (At.needReadable = At.length <= At.highWaterMark, St = 0) : (At.length -= St, At.awaitDrain = 0), At.length === 0 && (At.ended || (At.needReadable = !0), Nt !== St && At.ended && Ge(this)), qt !== null && this.emit("data", qt), qt;
  }, Ut.prototype._read = function(St) {
    Ct(this, new Tt("_read()"));
  }, Ut.prototype.pipe = function(St, At) {
    var Nt = this, qt = this._readableState;
    switch (qt.pipesCount) {
      case 0:
        qt.pipes = St;
        break;
      case 1:
        qt.pipes = [qt.pipes, St];
        break;
      default:
        qt.pipes.push(St);
    }
    qt.pipesCount += 1, Qe("pipe count=%d opts=%j", qt.pipesCount, At);
    var Qt = (!At || At.end !== !1) && St !== Ze.stdout && St !== Ze.stderr ? zt : rr;
    function Xt(sr, Jt) {
      Qe("onunpipe"), sr === Nt && Jt && Jt.hasUnpiped === !1 && (Jt.hasUnpiped = !0, Qe("cleanup"), St.removeListener("close", Ht), St.removeListener("finish", Gt), St.removeListener("drain", Kt), St.removeListener("error", Dt), St.removeListener("unpipe", Xt), Nt.removeListener("end", zt), Nt.removeListener("end", rr), Nt.removeListener("data", er), ur = !0, !qt.awaitDrain || St._writableState && !St._writableState.needDrain || Kt());
    }
    function zt() {
      Qe("onend"), St.end();
    }
    qt.endEmitted ? Ze.nextTick(Qt) : Nt.once("end", Qt), St.on("unpipe", Xt);
    var Kt = function(sr) {
      return function() {
        var Jt = sr._readableState;
        Qe("pipeOnDrain", Jt.awaitDrain), Jt.awaitDrain && Jt.awaitDrain--, Jt.awaitDrain === 0 && Fe(sr, "data") && (Jt.flowing = !0, yt(sr));
      };
    }(Nt);
    St.on("drain", Kt);
    var ur = !1;
    function er(sr) {
      Qe("ondata");
      var Jt = St.write(sr);
      Qe("dest.write", Jt), Jt === !1 && ((qt.pipesCount === 1 && qt.pipes === St || qt.pipesCount > 1 && Mt(qt.pipes, St) !== -1) && !ur && (Qe("false write response, pause", qt.awaitDrain), qt.awaitDrain++), Nt.pause());
    }
    function Dt(sr) {
      Qe("onerror", sr), rr(), St.removeListener("error", Dt), Fe(St, "error") === 0 && Ct(St, sr);
    }
    function Ht() {
      St.removeListener("finish", Gt), rr();
    }
    function Gt() {
      Qe("onfinish"), St.removeListener("close", Ht), rr();
    }
    function rr() {
      Qe("unpipe"), Nt.unpipe(St);
    }
    return Nt.on("data", er), function(sr, Jt, ir) {
      if (typeof sr.prependListener == "function")
        return sr.prependListener(Jt, ir);
      sr._events && sr._events[Jt] ? Array.isArray(sr._events[Jt]) ? sr._events[Jt].unshift(ir) : sr._events[Jt] = [ir, sr._events[Jt]] : sr.on(Jt, ir);
    }(St, "error", Dt), St.once("close", Ht), St.once("finish", Gt), St.emit("pipe", Nt), qt.flowing || (Qe("pipe resume"), Nt.resume()), St;
  }, Ut.prototype.unpipe = function(St) {
    var At = this._readableState, Nt = { hasUnpiped: !1 };
    if (At.pipesCount === 0)
      return this;
    if (At.pipesCount === 1)
      return St && St !== At.pipes || (St || (St = At.pipes), At.pipes = null, At.pipesCount = 0, At.flowing = !1, St && St.emit("unpipe", this, Nt)), this;
    if (!St) {
      var qt = At.pipes, Qt = At.pipesCount;
      At.pipes = null, At.pipesCount = 0, At.flowing = !1;
      for (var Xt = 0; Xt < Qt; Xt++)
        qt[Xt].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var zt = Mt(At.pipes, St);
    return zt === -1 || (At.pipes.splice(zt, 1), At.pipesCount -= 1, At.pipesCount === 1 && (At.pipes = At.pipes[0]), St.emit("unpipe", this, Nt)), this;
  }, Ut.prototype.on = function(St, At) {
    var Nt = Ke.prototype.on.call(this, St, At), qt = this._readableState;
    return St === "data" ? (qt.readableListening = this.listenerCount("readable") > 0, qt.flowing !== !1 && this.resume()) : St === "readable" && (qt.endEmitted || qt.readableListening || (qt.readableListening = qt.needReadable = !0, qt.flowing = !1, qt.emittedReadable = !1, Qe("on readable", qt.length, qt.reading), qt.length ? gt(this) : qt.reading || Ze.nextTick(ft, this))), Nt;
  }, Ut.prototype.addListener = Ut.prototype.on, Ut.prototype.removeListener = function(St, At) {
    var Nt = Ke.prototype.removeListener.call(this, St, At);
    return St === "readable" && Ze.nextTick(ot, this), Nt;
  }, Ut.prototype.removeAllListeners = function(St) {
    var At = Ke.prototype.removeAllListeners.apply(this, arguments);
    return St !== "readable" && St !== void 0 || Ze.nextTick(ot, this), At;
  }, Ut.prototype.resume = function() {
    var St = this._readableState;
    return St.flowing || (Qe("resume"), St.flowing = !St.readableListening, function(At, Nt) {
      Nt.resumeScheduled || (Nt.resumeScheduled = !0, Ze.nextTick(mt, At, Nt));
    }(this, St)), St.paused = !1, this;
  }, Ut.prototype.pause = function() {
    return Qe("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (Qe("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  }, Ut.prototype.wrap = function(St) {
    var At = this, Nt = this._readableState, qt = !1;
    for (var Qt in St.on("end", function() {
      if (Qe("wrapped end"), Nt.decoder && !Nt.ended) {
        var zt = Nt.decoder.end();
        zt && zt.length && At.push(zt);
      }
      At.push(null);
    }), St.on("data", function(zt) {
      Qe("wrapped data"), Nt.decoder && (zt = Nt.decoder.write(zt)), Nt.objectMode && zt == null || (Nt.objectMode || zt && zt.length) && (At.push(zt) || (qt = !0, St.pause()));
    }), St)
      this[Qt] === void 0 && typeof St[Qt] == "function" && (this[Qt] = function(zt) {
        return function() {
          return St[zt].apply(St, arguments);
        };
      }(Qt));
    for (var Xt = 0; Xt < Zt.length; Xt++)
      St.on(Zt[Xt], this.emit.bind(this, Zt[Xt]));
    return this._read = function(zt) {
      Qe("wrapped _read", zt), qt && (qt = !1, St.resume());
    }, this;
  }, typeof Symbol == "function" && (Ut.prototype[Symbol.asyncIterator] = function() {
    return lt === void 0 && (lt = F$8), lt(this);
  }), Object.defineProperty(Ut.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
    return this._readableState.highWaterMark;
  } }), Object.defineProperty(Ut.prototype, "readableBuffer", { enumerable: !1, get: function() {
    return this._readableState && this._readableState.buffer;
  } }), Object.defineProperty(Ut.prototype, "readableFlowing", { enumerable: !1, get: function() {
    return this._readableState.flowing;
  }, set: function(St) {
    this._readableState && (this._readableState.flowing = St);
  } }), Ut._fromList = pt, Object.defineProperty(Ut.prototype, "readableLength", { enumerable: !1, get: function() {
    return this._readableState.length;
  } }), typeof Symbol == "function" && (Ut.from = function(St, At) {
    return dt === void 0 && (dt = r$1$1$1), dt(Ut, St, At);
  }), V$6;
}
var z$9 = {}, J$5 = !1, Q$4 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function X$4() {
  if (J$5)
    return z$9;
  J$5 = !0;
  var $e, Ze = T;
  function Fe(rt) {
    var ot = this;
    this.next = null, this.entry = null, this.finish = function() {
      (function(ft, mt, yt) {
        var pt = ft.entry;
        for (ft.entry = null; pt; ) {
          var Ge = pt.callback;
          mt.pendingcb--, Ge(yt), pt = pt.next;
        }
        mt.corkedRequestsFree.next = ft;
      })(ot, rt);
    };
  }
  z$9 = Ut, Ut.WritableState = Lt;
  var Ke = { deprecate: t$1$1$1 }, Ve = e$g, Je = e$1$1$1.Buffer, Qe = Q$4.Uint8Array || function() {
  }, at, ut = m$m, lt = R$7.getHighWaterMark, dt = e$1$12.codes, bt = dt.ERR_INVALID_ARG_TYPE, $t = dt.ERR_METHOD_NOT_IMPLEMENTED, vt = dt.ERR_MULTIPLE_CALLBACK, wt = dt.ERR_STREAM_CANNOT_PIPE, xt = dt.ERR_STREAM_DESTROYED, Et = dt.ERR_STREAM_NULL_VALUES, Tt = dt.ERR_STREAM_WRITE_AFTER_END, Rt = dt.ERR_UNKNOWN_ENCODING, Ct = ut.errorOrDestroy;
  function Zt() {
  }
  function Lt(rt, ot, ft) {
    $e = $e || ee$1(), rt = rt || {}, typeof ft != "boolean" && (ft = ot instanceof $e), this.objectMode = !!rt.objectMode, ft && (this.objectMode = this.objectMode || !!rt.writableObjectMode), this.highWaterMark = lt(this, rt, "writableHighWaterMark", ft), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var mt = rt.decodeStrings === !1;
    this.decodeStrings = !mt, this.defaultEncoding = rt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(yt) {
      (function(pt, Ge) {
        var ct = pt._writableState, Mt = ct.sync, St = ct.writecb;
        if (typeof St != "function")
          throw new vt();
        if (function(Nt) {
          Nt.writing = !1, Nt.writecb = null, Nt.length -= Nt.writelen, Nt.writelen = 0;
        }(ct), Ge)
          (function(Nt, qt, Qt, Xt, zt) {
            --qt.pendingcb, Qt ? (Ze.nextTick(zt, Xt), Ze.nextTick(Xe, Nt, qt), Nt._writableState.errorEmitted = !0, Ct(Nt, Xt)) : (zt(Xt), Nt._writableState.errorEmitted = !0, Ct(Nt, Xt), Xe(Nt, qt));
          })(pt, ct, Mt, Ge, St);
        else {
          var At = gt(ct) || pt.destroyed;
          At || ct.corked || ct.bufferProcessing || !ct.bufferedRequest || Ft(pt, ct), Mt ? Ze.nextTick(Ot, pt, ct, At, St) : Ot(pt, ct, At, St);
        }
      })(ot, yt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = rt.emitClose !== !1, this.autoDestroy = !!rt.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Fe(this);
  }
  function Ut(rt) {
    var ot = this instanceof ($e = $e || ee$1());
    if (!ot && !at.call(Ut, this))
      return new Ut(rt);
    this._writableState = new Lt(rt, this, ot), this.writable = !0, rt && (typeof rt.write == "function" && (this._write = rt.write), typeof rt.writev == "function" && (this._writev = rt.writev), typeof rt.destroy == "function" && (this._destroy = rt.destroy), typeof rt.final == "function" && (this._final = rt.final)), Ve.call(this);
  }
  function Pt(rt, ot, ft, mt, yt, pt, Ge) {
    ot.writelen = mt, ot.writecb = Ge, ot.writing = !0, ot.sync = !0, ot.destroyed ? ot.onwrite(new xt("write")) : ft ? rt._writev(yt, ot.onwrite) : rt._write(yt, pt, ot.onwrite), ot.sync = !1;
  }
  function Ot(rt, ot, ft, mt) {
    ft || function(yt, pt) {
      pt.length === 0 && pt.needDrain && (pt.needDrain = !1, yt.emit("drain"));
    }(rt, ot), ot.pendingcb--, mt(), Xe(rt, ot);
  }
  function Ft(rt, ot) {
    ot.bufferProcessing = !0;
    var ft = ot.bufferedRequest;
    if (rt._writev && ft && ft.next) {
      var mt = ot.bufferedRequestCount, yt = new Array(mt), pt = ot.corkedRequestsFree;
      pt.entry = ft;
      for (var Ge = 0, ct = !0; ft; )
        yt[Ge] = ft, ft.isBuf || (ct = !1), ft = ft.next, Ge += 1;
      yt.allBuffers = ct, Pt(rt, ot, !0, ot.length, yt, "", pt.finish), ot.pendingcb++, ot.lastBufferedRequest = null, pt.next ? (ot.corkedRequestsFree = pt.next, pt.next = null) : ot.corkedRequestsFree = new Fe(ot), ot.bufferedRequestCount = 0;
    } else {
      for (; ft; ) {
        var Mt = ft.chunk, St = ft.encoding, At = ft.callback;
        if (Pt(rt, ot, !1, ot.objectMode ? 1 : Mt.length, Mt, St, At), ft = ft.next, ot.bufferedRequestCount--, ot.writing)
          break;
      }
      ft === null && (ot.lastBufferedRequest = null);
    }
    ot.bufferedRequest = ft, ot.bufferProcessing = !1;
  }
  function gt(rt) {
    return rt.ending && rt.length === 0 && rt.bufferedRequest === null && !rt.finished && !rt.writing;
  }
  function We(rt, ot) {
    rt._final(function(ft) {
      ot.pendingcb--, ft && Ct(rt, ft), ot.prefinished = !0, rt.emit("prefinish"), Xe(rt, ot);
    });
  }
  function Xe(rt, ot) {
    var ft = gt(ot);
    if (ft && (function(yt, pt) {
      pt.prefinished || pt.finalCalled || (typeof yt._final != "function" || pt.destroyed ? (pt.prefinished = !0, yt.emit("prefinish")) : (pt.pendingcb++, pt.finalCalled = !0, Ze.nextTick(We, yt, pt)));
    }(rt, ot), ot.pendingcb === 0 && (ot.finished = !0, rt.emit("finish"), ot.autoDestroy))) {
      var mt = rt._readableState;
      (!mt || mt.autoDestroy && mt.endEmitted) && rt.destroy();
    }
    return ft;
  }
  return t$2(Ut, Ve), Lt.prototype.getBuffer = function() {
    for (var rt = this.bufferedRequest, ot = []; rt; )
      ot.push(rt), rt = rt.next;
    return ot;
  }, function() {
    try {
      Object.defineProperty(Lt.prototype, "buffer", { get: Ke.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch {
    }
  }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (at = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ut, Symbol.hasInstance, { value: function(rt) {
    return !!at.call(this, rt) || this === Ut && rt && rt._writableState instanceof Lt;
  } })) : at = function(rt) {
    return rt instanceof this;
  }, Ut.prototype.pipe = function() {
    Ct(this, new wt());
  }, Ut.prototype.write = function(rt, ot, ft) {
    var mt, yt = this._writableState, pt = !1, Ge = !yt.objectMode && (mt = rt, Je.isBuffer(mt) || mt instanceof Qe);
    return Ge && !Je.isBuffer(rt) && (rt = function(ct) {
      return Je.from(ct);
    }(rt)), typeof ot == "function" && (ft = ot, ot = null), Ge ? ot = "buffer" : ot || (ot = yt.defaultEncoding), typeof ft != "function" && (ft = Zt), yt.ending ? function(ct, Mt) {
      var St = new Tt();
      Ct(ct, St), Ze.nextTick(Mt, St);
    }(this, ft) : (Ge || function(ct, Mt, St, At) {
      var Nt;
      return St === null ? Nt = new Et() : typeof St == "string" || Mt.objectMode || (Nt = new bt("chunk", ["string", "Buffer"], St)), !Nt || (Ct(ct, Nt), Ze.nextTick(At, Nt), !1);
    }(this, yt, rt, ft)) && (yt.pendingcb++, pt = function(ct, Mt, St, At, Nt, qt) {
      if (!St) {
        var Qt = function(ur, er, Dt) {
          return ur.objectMode || ur.decodeStrings === !1 || typeof er != "string" || (er = Je.from(er, Dt)), er;
        }(Mt, At, Nt);
        At !== Qt && (St = !0, Nt = "buffer", At = Qt);
      }
      var Xt = Mt.objectMode ? 1 : At.length;
      Mt.length += Xt;
      var zt = Mt.length < Mt.highWaterMark;
      if (zt || (Mt.needDrain = !0), Mt.writing || Mt.corked) {
        var Kt = Mt.lastBufferedRequest;
        Mt.lastBufferedRequest = { chunk: At, encoding: Nt, isBuf: St, callback: qt, next: null }, Kt ? Kt.next = Mt.lastBufferedRequest : Mt.bufferedRequest = Mt.lastBufferedRequest, Mt.bufferedRequestCount += 1;
      } else
        Pt(ct, Mt, !1, Xt, At, Nt, qt);
      return zt;
    }(this, yt, Ge, rt, ot, ft)), pt;
  }, Ut.prototype.cork = function() {
    this._writableState.corked++;
  }, Ut.prototype.uncork = function() {
    var rt = this._writableState;
    rt.corked && (rt.corked--, rt.writing || rt.corked || rt.bufferProcessing || !rt.bufferedRequest || Ft(this, rt));
  }, Ut.prototype.setDefaultEncoding = function(rt) {
    if (typeof rt == "string" && (rt = rt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((rt + "").toLowerCase()) > -1))
      throw new Rt(rt);
    return this._writableState.defaultEncoding = rt, this;
  }, Object.defineProperty(Ut.prototype, "writableBuffer", { enumerable: !1, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(Ut.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
    return this._writableState.highWaterMark;
  } }), Ut.prototype._write = function(rt, ot, ft) {
    ft(new $t("_write()"));
  }, Ut.prototype._writev = null, Ut.prototype.end = function(rt, ot, ft) {
    var mt = this._writableState;
    return typeof rt == "function" ? (ft = rt, rt = null, ot = null) : typeof ot == "function" && (ft = ot, ot = null), rt != null && this.write(rt, ot), mt.corked && (mt.corked = 1, this.uncork()), mt.ending || function(yt, pt, Ge) {
      pt.ending = !0, Xe(yt, pt), Ge && (pt.finished ? Ze.nextTick(Ge) : yt.once("finish", Ge)), pt.ended = !0, yt.writable = !1;
    }(this, mt, ft), this;
  }, Object.defineProperty(Ut.prototype, "writableLength", { enumerable: !1, get: function() {
    return this._writableState.length;
  } }), Object.defineProperty(Ut.prototype, "destroyed", { enumerable: !1, get: function() {
    return this._writableState !== void 0 && this._writableState.destroyed;
  }, set: function(rt) {
    this._writableState && (this._writableState.destroyed = rt);
  } }), Ut.prototype.destroy = ut.destroy, Ut.prototype._undestroy = ut.undestroy, Ut.prototype._destroy = function(rt, ot) {
    ot(rt);
  }, z$9;
}
var Z$3 = {}, $$3 = !1;
function ee$1() {
  if ($$3)
    return Z$3;
  $$3 = !0;
  var $e = T, Ze = Object.keys || function(dt) {
    var bt = [];
    for (var $t in dt)
      bt.push($t);
    return bt;
  };
  Z$3 = at;
  var Fe = K$8(), Ke = X$4();
  t$2(at, Fe);
  for (var Ve = Ze(Ke.prototype), Je = 0; Je < Ve.length; Je++) {
    var Qe = Ve[Je];
    at.prototype[Qe] || (at.prototype[Qe] = Ke.prototype[Qe]);
  }
  function at(dt) {
    if (!(this instanceof at))
      return new at(dt);
    Fe.call(this, dt), Ke.call(this, dt), this.allowHalfOpen = !0, dt && (dt.readable === !1 && (this.readable = !1), dt.writable === !1 && (this.writable = !1), dt.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", ut)));
  }
  function ut() {
    this._writableState.ended || $e.nextTick(lt, this);
  }
  function lt(dt) {
    dt.end();
  }
  return Object.defineProperty(at.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
    return this._writableState.highWaterMark;
  } }), Object.defineProperty(at.prototype, "writableBuffer", { enumerable: !1, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(at.prototype, "writableLength", { enumerable: !1, get: function() {
    return this._writableState.length;
  } }), Object.defineProperty(at.prototype, "destroyed", { enumerable: !1, get: function() {
    return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
  }, set: function(dt) {
    this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = dt, this._writableState.destroyed = dt);
  } }), Z$3;
}
var t$2$1 = K$8(), r$3$1 = e$1$12.codes.ERR_STREAM_PREMATURE_CLOSE;
function t$3$1() {
}
var n$1$12 = function $e(Ze, Fe, Ke) {
  if (typeof Fe == "function")
    return $e(Ze, null, Fe);
  Fe || (Fe = {}), Ke = function(wt) {
    var xt = !1;
    return function() {
      if (!xt) {
        xt = !0;
        for (var Et = arguments.length, Tt = new Array(Et), Rt = 0; Rt < Et; Rt++)
          Tt[Rt] = arguments[Rt];
        wt.apply(this, Tt);
      }
    };
  }(Ke || t$3$1);
  var Ve = Fe.readable || Fe.readable !== !1 && Ze.readable, Je = Fe.writable || Fe.writable !== !1 && Ze.writable, Qe = function() {
    Ze.writable || ut();
  }, at = Ze._writableState && Ze._writableState.finished, ut = function() {
    Je = !1, at = !0, Ve || Ke.call(Ze);
  }, lt = Ze._readableState && Ze._readableState.endEmitted, dt = function() {
    Ve = !1, lt = !0, Je || Ke.call(Ze);
  }, bt = function(wt) {
    Ke.call(Ze, wt);
  }, $t = function() {
    var wt;
    return Ve && !lt ? (Ze._readableState && Ze._readableState.ended || (wt = new r$3$1()), Ke.call(Ze, wt)) : Je && !at ? (Ze._writableState && Ze._writableState.ended || (wt = new r$3$1()), Ke.call(Ze, wt)) : void 0;
  }, vt = function() {
    Ze.req.on("finish", ut);
  };
  return function(wt) {
    return wt.setHeader && typeof wt.abort == "function";
  }(Ze) ? (Ze.on("complete", ut), Ze.on("abort", $t), Ze.req ? vt() : Ze.on("request", vt)) : Je && !Ze._writableState && (Ze.on("end", Qe), Ze.on("close", Qe)), Ze.on("end", dt), Ze.on("finish", ut), Fe.error !== !1 && Ze.on("error", bt), Ze.on("close", $t), function() {
    Ze.removeListener("complete", ut), Ze.removeListener("abort", $t), Ze.removeListener("request", vt), Ze.req && Ze.req.removeListener("finish", ut), Ze.removeListener("end", Qe), Ze.removeListener("close", Qe), Ze.removeListener("finish", ut), Ze.removeListener("end", dt), Ze.removeListener("error", bt), Ze.removeListener("close", $t);
  };
};
function f$1$1$1($e, Ze) {
  var Fe = Object.keys($e);
  if (Object.getOwnPropertySymbols) {
    var Ke = Object.getOwnPropertySymbols($e);
    Ze && (Ke = Ke.filter(function(Ve) {
      return Object.getOwnPropertyDescriptor($e, Ve).enumerable;
    })), Fe.push.apply(Fe, Ke);
  }
  return Fe;
}
function h$1$12($e, Ze, Fe) {
  return Ze in $e ? Object.defineProperty($e, Ze, { value: Fe, enumerable: !0, configurable: !0, writable: !0 }) : $e[Ze] = Fe, $e;
}
function c$1$12($e, Ze) {
  for (var Fe = 0; Fe < Ze.length; Fe++) {
    var Ke = Ze[Fe];
    Ke.enumerable = Ke.enumerable || !1, Ke.configurable = !0, "value" in Ke && (Ke.writable = !0), Object.defineProperty($e, Ke.key, Ke);
  }
}
var b$1$1 = e$1$1$1.Buffer, p$1$1 = X.inspect, g$1$1 = p$1$1 && p$1$1.custom || "inspect", y$1$1 = function() {
  function $e() {
    (function(Ke, Ve) {
      if (!(Ke instanceof Ve))
        throw new TypeError("Cannot call a class as a function");
    })(this, $e), this.head = null, this.tail = null, this.length = 0;
  }
  var Ze, Fe;
  return Ze = $e, (Fe = [{ key: "push", value: function(Ke) {
    var Ve = { data: Ke, next: null };
    this.length > 0 ? this.tail.next = Ve : this.head = Ve, this.tail = Ve, ++this.length;
  } }, { key: "unshift", value: function(Ke) {
    var Ve = { data: Ke, next: this.head };
    this.length === 0 && (this.tail = Ve), this.head = Ve, ++this.length;
  } }, { key: "shift", value: function() {
    if (this.length !== 0) {
      var Ke = this.head.data;
      return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Ke;
    }
  } }, { key: "clear", value: function() {
    this.head = this.tail = null, this.length = 0;
  } }, { key: "join", value: function(Ke) {
    if (this.length === 0)
      return "";
    for (var Ve = this.head, Je = "" + Ve.data; Ve = Ve.next; )
      Je += Ke + Ve.data;
    return Je;
  } }, { key: "concat", value: function(Ke) {
    if (this.length === 0)
      return b$1$1.alloc(0);
    for (var Ve, Je, Qe, at = b$1$1.allocUnsafe(Ke >>> 0), ut = this.head, lt = 0; ut; )
      Ve = ut.data, Je = at, Qe = lt, b$1$1.prototype.copy.call(Ve, Je, Qe), lt += ut.data.length, ut = ut.next;
    return at;
  } }, { key: "consume", value: function(Ke, Ve) {
    var Je;
    return Ke < this.head.data.length ? (Je = this.head.data.slice(0, Ke), this.head.data = this.head.data.slice(Ke)) : Je = Ke === this.head.data.length ? this.shift() : Ve ? this._getString(Ke) : this._getBuffer(Ke), Je;
  } }, { key: "first", value: function() {
    return this.head.data;
  } }, { key: "_getString", value: function(Ke) {
    var Ve = this.head, Je = 1, Qe = Ve.data;
    for (Ke -= Qe.length; Ve = Ve.next; ) {
      var at = Ve.data, ut = Ke > at.length ? at.length : Ke;
      if (ut === at.length ? Qe += at : Qe += at.slice(0, Ke), (Ke -= ut) == 0) {
        ut === at.length ? (++Je, Ve.next ? this.head = Ve.next : this.head = this.tail = null) : (this.head = Ve, Ve.data = at.slice(ut));
        break;
      }
      ++Je;
    }
    return this.length -= Je, Qe;
  } }, { key: "_getBuffer", value: function(Ke) {
    var Ve = b$1$1.allocUnsafe(Ke), Je = this.head, Qe = 1;
    for (Je.data.copy(Ve), Ke -= Je.data.length; Je = Je.next; ) {
      var at = Je.data, ut = Ke > at.length ? at.length : Ke;
      if (at.copy(Ve, Ve.length - Ke, 0, ut), (Ke -= ut) == 0) {
        ut === at.length ? (++Qe, Je.next ? this.head = Je.next : this.head = this.tail = null) : (this.head = Je, Je.data = at.slice(ut));
        break;
      }
      ++Qe;
    }
    return this.length -= Qe, Ve;
  } }, { key: g$1$1, value: function(Ke, Ve) {
    return p$1$1(this, function(Je) {
      for (var Qe = 1; Qe < arguments.length; Qe++) {
        var at = arguments[Qe] != null ? arguments[Qe] : {};
        Qe % 2 ? f$1$1$1(Object(at), !0).forEach(function(ut) {
          h$1$12(Je, ut, at[ut]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Je, Object.getOwnPropertyDescriptors(at)) : f$1$1$1(Object(at)).forEach(function(ut) {
          Object.defineProperty(Je, ut, Object.getOwnPropertyDescriptor(at, ut));
        });
      }
      return Je;
    }({}, Ve, { depth: 0, customInspect: !1 }));
  } }]) && c$1$12(Ze.prototype, Fe), $e;
}(), w$1$1 = T;
function _$1$1($e, Ze) {
  m$1$1($e, Ze), v$1$1($e);
}
function v$1$1($e) {
  $e._writableState && !$e._writableState.emitClose || $e._readableState && !$e._readableState.emitClose || $e.emit("close");
}
function m$1$1($e, Ze) {
  $e.emit("error", Ze);
}
var S$1$1 = { destroy: function($e, Ze) {
  var Fe = this, Ke = this._readableState && this._readableState.destroyed, Ve = this._writableState && this._writableState.destroyed;
  return Ke || Ve ? (Ze ? Ze($e) : $e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, w$1$1.nextTick(m$1$1, this, $e)) : w$1$1.nextTick(m$1$1, this, $e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy($e || null, function(Je) {
    !Ze && Je ? Fe._writableState ? Fe._writableState.errorEmitted ? w$1$1.nextTick(v$1$1, Fe) : (Fe._writableState.errorEmitted = !0, w$1$1.nextTick(_$1$1, Fe, Je)) : w$1$1.nextTick(_$1$1, Fe, Je) : Ze ? (w$1$1.nextTick(v$1$1, Fe), Ze(Je)) : w$1$1.nextTick(v$1$1, Fe);
  }), this);
}, undestroy: function() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}, errorOrDestroy: function($e, Ze) {
  var Fe = $e._readableState, Ke = $e._writableState;
  Fe && Fe.autoDestroy || Ke && Ke.autoDestroy ? $e.destroy(Ze) : $e.emit("error", Ze);
} }, R$1$1 = e$1$12.codes.ERR_INVALID_OPT_VALUE, k$1$1, E$1$1 = { getHighWaterMark: function($e, Ze, Fe, Ke) {
  var Ve = function(Je, Qe, at) {
    return Je.highWaterMark != null ? Je.highWaterMark : Qe ? Je[at] : null;
  }(Ze, Ke, Fe);
  if (Ve != null) {
    if (!isFinite(Ve) || Math.floor(Ve) !== Ve || Ve < 0)
      throw new R$1$1(Ke ? Fe : "highWaterMark", Ve);
    return Math.floor(Ve);
  }
  return $e.objectMode ? 16 : 16384;
} }, M$1$1 = T;
function j$1$1($e, Ze, Fe) {
  return Ze in $e ? Object.defineProperty($e, Ze, { value: Fe, enumerable: !0, configurable: !0, writable: !0 }) : $e[Ze] = Fe, $e;
}
var O$1$1 = n$1$12, T$1$1 = Symbol("lastResolve"), x$1$1 = Symbol("lastReject"), P$1$1 = Symbol("error"), D$1$1 = Symbol("ended"), L$1$1 = Symbol("lastPromise"), C$1$1 = Symbol("handlePromise"), A$1$1 = Symbol("stream");
function W$1$1($e, Ze) {
  return { value: $e, done: Ze };
}
function B$1$1($e) {
  var Ze = $e[T$1$1];
  if (Ze !== null) {
    var Fe = $e[A$1$1].read();
    Fe !== null && ($e[L$1$1] = null, $e[T$1$1] = null, $e[x$1$1] = null, Ze(W$1$1(Fe, !1)));
  }
}
function q$1$1($e) {
  M$1$1.nextTick(B$1$1, $e);
}
var I$1$1 = Object.getPrototypeOf(function() {
}), N$1$1 = Object.setPrototypeOf((j$1$1(k$1$1 = { get stream() {
  return this[A$1$1];
}, next: function() {
  var $e = this, Ze = this[P$1$1];
  if (Ze !== null)
    return Promise.reject(Ze);
  if (this[D$1$1])
    return Promise.resolve(W$1$1(void 0, !0));
  if (this[A$1$1].destroyed)
    return new Promise(function(Je, Qe) {
      M$1$1.nextTick(function() {
        $e[P$1$1] ? Qe($e[P$1$1]) : Je(W$1$1(void 0, !0));
      });
    });
  var Fe, Ke = this[L$1$1];
  if (Ke)
    Fe = new Promise(function(Je, Qe) {
      return function(at, ut) {
        Je.then(function() {
          if (Qe[D$1$1])
            return at(W$1$1(void 0, !0)), void 0;
          Qe[C$1$1](at, ut);
        }, ut);
      };
    }(Ke, this));
  else {
    var Ve = this[A$1$1].read();
    if (Ve !== null)
      return Promise.resolve(W$1$1(Ve, !1));
    Fe = new Promise(this[C$1$1]);
  }
  return this[L$1$1] = Fe, Fe;
} }, Symbol.asyncIterator, function() {
  return this;
}), j$1$1(k$1$1, "return", function() {
  var $e = this;
  return new Promise(function(Ze, Fe) {
    $e[A$1$1].destroy(null, function(Ke) {
      if (Ke)
        return Fe(Ke), void 0;
      Ze(W$1$1(void 0, !0));
    });
  });
}), k$1$1), I$1$1), U$1$1 = function($e) {
  var Ze, Fe = Object.create(N$1$1, (j$1$1(Ze = {}, A$1$1, { value: $e, writable: !0 }), j$1$1(Ze, T$1$1, { value: null, writable: !0 }), j$1$1(Ze, x$1$1, { value: null, writable: !0 }), j$1$1(Ze, P$1$1, { value: null, writable: !0 }), j$1$1(Ze, D$1$1, { value: $e._readableState.endEmitted, writable: !0 }), j$1$1(Ze, C$1$1, { value: function(Ke, Ve) {
    var Je = Fe[A$1$1].read();
    Je ? (Fe[L$1$1] = null, Fe[T$1$1] = null, Fe[x$1$1] = null, Ke(W$1$1(Je, !1))) : (Fe[T$1$1] = Ke, Fe[x$1$1] = Ve);
  }, writable: !0 }), Ze));
  return Fe[L$1$1] = null, O$1$1($e, function(Ke) {
    if (Ke && Ke.code !== "ERR_STREAM_PREMATURE_CLOSE") {
      var Ve = Fe[x$1$1];
      return Ve !== null && (Fe[L$1$1] = null, Fe[T$1$1] = null, Fe[x$1$1] = null, Ve(Ke)), Fe[P$1$1] = Ke, void 0;
    }
    var Je = Fe[T$1$1];
    Je !== null && (Fe[L$1$1] = null, Fe[T$1$1] = null, Fe[x$1$1] = null, Je(W$1$1(void 0, !0))), Fe[D$1$1] = !0;
  }), $e.on("readable", q$1$1.bind(null, Fe)), Fe;
}, H$1$1 = {}, F$1$1 = !1, V$1$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function G$1$1() {
  if (F$1$1)
    return H$1$1;
  F$1$1 = !0;
  var $e, Ze = T;
  H$1$1 = Ut, Ut.ReadableState = Lt, y.EventEmitter;
  var Fe = function(St, At) {
    return St.listeners(At).length;
  }, Ke = e$g, Ve = e$1$1$1.Buffer, Je = V$1$1.Uint8Array || function() {
  }, Qe, at = X;
  Qe = at && at.debuglog ? at.debuglog("stream") : function() {
  };
  var ut, lt, dt, bt = y$1$1, $t = S$1$1, vt = E$1$1.getHighWaterMark, wt = e$1$12.codes, xt = wt.ERR_INVALID_ARG_TYPE, Et = wt.ERR_STREAM_PUSH_AFTER_EOF, Tt = wt.ERR_METHOD_NOT_IMPLEMENTED, Rt = wt.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  t$2(Ut, Ke);
  var Ct = $t.errorOrDestroy, Zt = ["error", "close", "destroy", "pause", "resume"];
  function Lt(St, At, Nt) {
    $e = $e || Z$1$1(), St = St || {}, typeof Nt != "boolean" && (Nt = At instanceof $e), this.objectMode = !!St.objectMode, Nt && (this.objectMode = this.objectMode || !!St.readableObjectMode), this.highWaterMark = vt(this, St, "readableHighWaterMark", Nt), this.buffer = new bt(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = St.emitClose !== !1, this.autoDestroy = !!St.autoDestroy, this.destroyed = !1, this.defaultEncoding = St.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, St.encoding && (ut || (ut = e$12.StringDecoder), this.decoder = new ut(St.encoding), this.encoding = St.encoding);
  }
  function Ut(St) {
    if ($e = $e || Z$1$1(), !(this instanceof Ut))
      return new Ut(St);
    var At = this instanceof $e;
    this._readableState = new Lt(St, this, At), this.readable = !0, St && (typeof St.read == "function" && (this._read = St.read), typeof St.destroy == "function" && (this._destroy = St.destroy)), Ke.call(this);
  }
  function Pt(St, At, Nt, qt, Qt) {
    Qe("readableAddChunk", At);
    var Xt, zt = St._readableState;
    if (At === null)
      zt.reading = !1, function(Kt, ur) {
        if (Qe("onEofChunk"), !ur.ended) {
          if (ur.decoder) {
            var er = ur.decoder.end();
            er && er.length && (ur.buffer.push(er), ur.length += ur.objectMode ? 1 : er.length);
          }
          ur.ended = !0, ur.sync ? gt(Kt) : (ur.needReadable = !1, ur.emittedReadable || (ur.emittedReadable = !0, We(Kt)));
        }
      }(St, zt);
    else if (Qt || (Xt = function(Kt, ur) {
      var er;
      Dt = ur, Ve.isBuffer(Dt) || Dt instanceof Je || typeof ur == "string" || ur === void 0 || Kt.objectMode || (er = new xt("chunk", ["string", "Buffer", "Uint8Array"], ur));
      var Dt;
      return er;
    }(zt, At)), Xt)
      Ct(St, Xt);
    else if (zt.objectMode || At && At.length > 0)
      if (typeof At == "string" || zt.objectMode || Object.getPrototypeOf(At) === Ve.prototype || (At = function(Kt) {
        return Ve.from(Kt);
      }(At)), qt)
        zt.endEmitted ? Ct(St, new Rt()) : Ot(St, zt, At, !0);
      else if (zt.ended)
        Ct(St, new Et());
      else {
        if (zt.destroyed)
          return !1;
        zt.reading = !1, zt.decoder && !Nt ? (At = zt.decoder.write(At), zt.objectMode || At.length !== 0 ? Ot(St, zt, At, !1) : Xe(St, zt)) : Ot(St, zt, At, !1);
      }
    else
      qt || (zt.reading = !1, Xe(St, zt));
    return !zt.ended && (zt.length < zt.highWaterMark || zt.length === 0);
  }
  function Ot(St, At, Nt, qt) {
    At.flowing && At.length === 0 && !At.sync ? (At.awaitDrain = 0, St.emit("data", Nt)) : (At.length += At.objectMode ? 1 : Nt.length, qt ? At.buffer.unshift(Nt) : At.buffer.push(Nt), At.needReadable && gt(St)), Xe(St, At);
  }
  Object.defineProperty(Ut.prototype, "destroyed", { enumerable: !1, get: function() {
    return this._readableState !== void 0 && this._readableState.destroyed;
  }, set: function(St) {
    this._readableState && (this._readableState.destroyed = St);
  } }), Ut.prototype.destroy = $t.destroy, Ut.prototype._undestroy = $t.undestroy, Ut.prototype._destroy = function(St, At) {
    At(St);
  }, Ut.prototype.push = function(St, At) {
    var Nt, qt = this._readableState;
    return qt.objectMode ? Nt = !0 : typeof St == "string" && ((At = At || qt.defaultEncoding) !== qt.encoding && (St = Ve.from(St, At), At = ""), Nt = !0), Pt(this, St, At, !1, Nt);
  }, Ut.prototype.unshift = function(St) {
    return Pt(this, St, null, !0, !1);
  }, Ut.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Ut.prototype.setEncoding = function(St) {
    ut || (ut = e$12.StringDecoder);
    var At = new ut(St);
    this._readableState.decoder = At, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Nt = this._readableState.buffer.head, qt = ""; Nt !== null; )
      qt += At.write(Nt.data), Nt = Nt.next;
    return this._readableState.buffer.clear(), qt !== "" && this._readableState.buffer.push(qt), this._readableState.length = qt.length, this;
  };
  function Ft(St, At) {
    return St <= 0 || At.length === 0 && At.ended ? 0 : At.objectMode ? 1 : St != St ? At.flowing && At.length ? At.buffer.head.data.length : At.length : (St > At.highWaterMark && (At.highWaterMark = function(Nt) {
      return Nt >= 1073741824 ? Nt = 1073741824 : (Nt--, Nt |= Nt >>> 1, Nt |= Nt >>> 2, Nt |= Nt >>> 4, Nt |= Nt >>> 8, Nt |= Nt >>> 16, Nt++), Nt;
    }(St)), St <= At.length ? St : At.ended ? At.length : (At.needReadable = !0, 0));
  }
  function gt(St) {
    var At = St._readableState;
    Qe("emitReadable", At.needReadable, At.emittedReadable), At.needReadable = !1, At.emittedReadable || (Qe("emitReadable", At.flowing), At.emittedReadable = !0, Ze.nextTick(We, St));
  }
  function We(St) {
    var At = St._readableState;
    Qe("emitReadable_", At.destroyed, At.length, At.ended), At.destroyed || !At.length && !At.ended || (St.emit("readable"), At.emittedReadable = !1), At.needReadable = !At.flowing && !At.ended && At.length <= At.highWaterMark, yt(St);
  }
  function Xe(St, At) {
    At.readingMore || (At.readingMore = !0, Ze.nextTick(rt, St, At));
  }
  function rt(St, At) {
    for (; !At.reading && !At.ended && (At.length < At.highWaterMark || At.flowing && At.length === 0); ) {
      var Nt = At.length;
      if (Qe("maybeReadMore read 0"), St.read(0), Nt === At.length)
        break;
    }
    At.readingMore = !1;
  }
  function ot(St) {
    var At = St._readableState;
    At.readableListening = St.listenerCount("readable") > 0, At.resumeScheduled && !At.paused ? At.flowing = !0 : St.listenerCount("data") > 0 && St.resume();
  }
  function ft(St) {
    Qe("readable nexttick read 0"), St.read(0);
  }
  function mt(St, At) {
    Qe("resume", At.reading), At.reading || St.read(0), At.resumeScheduled = !1, St.emit("resume"), yt(St), At.flowing && !At.reading && St.read(0);
  }
  function yt(St) {
    var At = St._readableState;
    for (Qe("flow", At.flowing); At.flowing && St.read() !== null; )
      ;
  }
  function pt(St, At) {
    return At.length === 0 ? null : (At.objectMode ? Nt = At.buffer.shift() : !St || St >= At.length ? (Nt = At.decoder ? At.buffer.join("") : At.buffer.length === 1 ? At.buffer.first() : At.buffer.concat(At.length), At.buffer.clear()) : Nt = At.buffer.consume(St, At.decoder), Nt);
    var Nt;
  }
  function Ge(St) {
    var At = St._readableState;
    Qe("endReadable", At.endEmitted), At.endEmitted || (At.ended = !0, Ze.nextTick(ct, At, St));
  }
  function ct(St, At) {
    if (Qe("endReadableNT", St.endEmitted, St.length), !St.endEmitted && St.length === 0 && (St.endEmitted = !0, At.readable = !1, At.emit("end"), St.autoDestroy)) {
      var Nt = At._writableState;
      (!Nt || Nt.autoDestroy && Nt.finished) && At.destroy();
    }
  }
  function Mt(St, At) {
    for (var Nt = 0, qt = St.length; Nt < qt; Nt++)
      if (St[Nt] === At)
        return Nt;
    return -1;
  }
  return Ut.prototype.read = function(St) {
    Qe("read", St), St = parseInt(St, 10);
    var At = this._readableState, Nt = St;
    if (St !== 0 && (At.emittedReadable = !1), St === 0 && At.needReadable && ((At.highWaterMark !== 0 ? At.length >= At.highWaterMark : At.length > 0) || At.ended))
      return Qe("read: emitReadable", At.length, At.ended), At.length === 0 && At.ended ? Ge(this) : gt(this), null;
    if ((St = Ft(St, At)) === 0 && At.ended)
      return At.length === 0 && Ge(this), null;
    var qt, Qt = At.needReadable;
    return Qe("need readable", Qt), (At.length === 0 || At.length - St < At.highWaterMark) && Qe("length less than watermark", Qt = !0), At.ended || At.reading ? Qe("reading or ended", Qt = !1) : Qt && (Qe("do read"), At.reading = !0, At.sync = !0, At.length === 0 && (At.needReadable = !0), this._read(At.highWaterMark), At.sync = !1, At.reading || (St = Ft(Nt, At))), (qt = St > 0 ? pt(St, At) : null) === null ? (At.needReadable = At.length <= At.highWaterMark, St = 0) : (At.length -= St, At.awaitDrain = 0), At.length === 0 && (At.ended || (At.needReadable = !0), Nt !== St && At.ended && Ge(this)), qt !== null && this.emit("data", qt), qt;
  }, Ut.prototype._read = function(St) {
    Ct(this, new Tt("_read()"));
  }, Ut.prototype.pipe = function(St, At) {
    var Nt = this, qt = this._readableState;
    switch (qt.pipesCount) {
      case 0:
        qt.pipes = St;
        break;
      case 1:
        qt.pipes = [qt.pipes, St];
        break;
      default:
        qt.pipes.push(St);
    }
    qt.pipesCount += 1, Qe("pipe count=%d opts=%j", qt.pipesCount, At);
    var Qt = (!At || At.end !== !1) && St !== Ze.stdout && St !== Ze.stderr ? zt : rr;
    function Xt(sr, Jt) {
      Qe("onunpipe"), sr === Nt && Jt && Jt.hasUnpiped === !1 && (Jt.hasUnpiped = !0, Qe("cleanup"), St.removeListener("close", Ht), St.removeListener("finish", Gt), St.removeListener("drain", Kt), St.removeListener("error", Dt), St.removeListener("unpipe", Xt), Nt.removeListener("end", zt), Nt.removeListener("end", rr), Nt.removeListener("data", er), ur = !0, !qt.awaitDrain || St._writableState && !St._writableState.needDrain || Kt());
    }
    function zt() {
      Qe("onend"), St.end();
    }
    qt.endEmitted ? Ze.nextTick(Qt) : Nt.once("end", Qt), St.on("unpipe", Xt);
    var Kt = function(sr) {
      return function() {
        var Jt = sr._readableState;
        Qe("pipeOnDrain", Jt.awaitDrain), Jt.awaitDrain && Jt.awaitDrain--, Jt.awaitDrain === 0 && Fe(sr, "data") && (Jt.flowing = !0, yt(sr));
      };
    }(Nt);
    St.on("drain", Kt);
    var ur = !1;
    function er(sr) {
      Qe("ondata");
      var Jt = St.write(sr);
      Qe("dest.write", Jt), Jt === !1 && ((qt.pipesCount === 1 && qt.pipes === St || qt.pipesCount > 1 && Mt(qt.pipes, St) !== -1) && !ur && (Qe("false write response, pause", qt.awaitDrain), qt.awaitDrain++), Nt.pause());
    }
    function Dt(sr) {
      Qe("onerror", sr), rr(), St.removeListener("error", Dt), Fe(St, "error") === 0 && Ct(St, sr);
    }
    function Ht() {
      St.removeListener("finish", Gt), rr();
    }
    function Gt() {
      Qe("onfinish"), St.removeListener("close", Ht), rr();
    }
    function rr() {
      Qe("unpipe"), Nt.unpipe(St);
    }
    return Nt.on("data", er), function(sr, Jt, ir) {
      if (typeof sr.prependListener == "function")
        return sr.prependListener(Jt, ir);
      sr._events && sr._events[Jt] ? Array.isArray(sr._events[Jt]) ? sr._events[Jt].unshift(ir) : sr._events[Jt] = [ir, sr._events[Jt]] : sr.on(Jt, ir);
    }(St, "error", Dt), St.once("close", Ht), St.once("finish", Gt), St.emit("pipe", Nt), qt.flowing || (Qe("pipe resume"), Nt.resume()), St;
  }, Ut.prototype.unpipe = function(St) {
    var At = this._readableState, Nt = { hasUnpiped: !1 };
    if (At.pipesCount === 0)
      return this;
    if (At.pipesCount === 1)
      return St && St !== At.pipes || (St || (St = At.pipes), At.pipes = null, At.pipesCount = 0, At.flowing = !1, St && St.emit("unpipe", this, Nt)), this;
    if (!St) {
      var qt = At.pipes, Qt = At.pipesCount;
      At.pipes = null, At.pipesCount = 0, At.flowing = !1;
      for (var Xt = 0; Xt < Qt; Xt++)
        qt[Xt].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var zt = Mt(At.pipes, St);
    return zt === -1 || (At.pipes.splice(zt, 1), At.pipesCount -= 1, At.pipesCount === 1 && (At.pipes = At.pipes[0]), St.emit("unpipe", this, Nt)), this;
  }, Ut.prototype.on = function(St, At) {
    var Nt = Ke.prototype.on.call(this, St, At), qt = this._readableState;
    return St === "data" ? (qt.readableListening = this.listenerCount("readable") > 0, qt.flowing !== !1 && this.resume()) : St === "readable" && (qt.endEmitted || qt.readableListening || (qt.readableListening = qt.needReadable = !0, qt.flowing = !1, qt.emittedReadable = !1, Qe("on readable", qt.length, qt.reading), qt.length ? gt(this) : qt.reading || Ze.nextTick(ft, this))), Nt;
  }, Ut.prototype.addListener = Ut.prototype.on, Ut.prototype.removeListener = function(St, At) {
    var Nt = Ke.prototype.removeListener.call(this, St, At);
    return St === "readable" && Ze.nextTick(ot, this), Nt;
  }, Ut.prototype.removeAllListeners = function(St) {
    var At = Ke.prototype.removeAllListeners.apply(this, arguments);
    return St !== "readable" && St !== void 0 || Ze.nextTick(ot, this), At;
  }, Ut.prototype.resume = function() {
    var St = this._readableState;
    return St.flowing || (Qe("resume"), St.flowing = !St.readableListening, function(At, Nt) {
      Nt.resumeScheduled || (Nt.resumeScheduled = !0, Ze.nextTick(mt, At, Nt));
    }(this, St)), St.paused = !1, this;
  }, Ut.prototype.pause = function() {
    return Qe("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (Qe("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  }, Ut.prototype.wrap = function(St) {
    var At = this, Nt = this._readableState, qt = !1;
    for (var Qt in St.on("end", function() {
      if (Qe("wrapped end"), Nt.decoder && !Nt.ended) {
        var zt = Nt.decoder.end();
        zt && zt.length && At.push(zt);
      }
      At.push(null);
    }), St.on("data", function(zt) {
      Qe("wrapped data"), Nt.decoder && (zt = Nt.decoder.write(zt)), Nt.objectMode && zt == null || (Nt.objectMode || zt && zt.length) && (At.push(zt) || (qt = !0, St.pause()));
    }), St)
      this[Qt] === void 0 && typeof St[Qt] == "function" && (this[Qt] = function(zt) {
        return function() {
          return St[zt].apply(St, arguments);
        };
      }(Qt));
    for (var Xt = 0; Xt < Zt.length; Xt++)
      St.on(Zt[Xt], this.emit.bind(this, Zt[Xt]));
    return this._read = function(zt) {
      Qe("wrapped _read", zt), qt && (qt = !1, St.resume());
    }, this;
  }, typeof Symbol == "function" && (Ut.prototype[Symbol.asyncIterator] = function() {
    return lt === void 0 && (lt = U$1$1), lt(this);
  }), Object.defineProperty(Ut.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
    return this._readableState.highWaterMark;
  } }), Object.defineProperty(Ut.prototype, "readableBuffer", { enumerable: !1, get: function() {
    return this._readableState && this._readableState.buffer;
  } }), Object.defineProperty(Ut.prototype, "readableFlowing", { enumerable: !1, get: function() {
    return this._readableState.flowing;
  }, set: function(St) {
    this._readableState && (this._readableState.flowing = St);
  } }), Ut._fromList = pt, Object.defineProperty(Ut.prototype, "readableLength", { enumerable: !1, get: function() {
    return this._readableState.length;
  } }), typeof Symbol == "function" && (Ut.from = function(St, At) {
    return dt === void 0 && (dt = r$1$1$1), dt(Ut, St, At);
  }), H$1$1;
}
var Y$1$1 = {}, K$1$1 = !1, z$1$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function J$1$1() {
  if (K$1$1)
    return Y$1$1;
  K$1$1 = !0;
  var $e, Ze = T;
  function Fe(rt) {
    var ot = this;
    this.next = null, this.entry = null, this.finish = function() {
      (function(ft, mt, yt) {
        var pt = ft.entry;
        for (ft.entry = null; pt; ) {
          var Ge = pt.callback;
          mt.pendingcb--, Ge(yt), pt = pt.next;
        }
        mt.corkedRequestsFree.next = ft;
      })(ot, rt);
    };
  }
  Y$1$1 = Ut, Ut.WritableState = Lt;
  var Ke = { deprecate: t$1$1$1 }, Ve = e$g, Je = e$1$1$1.Buffer, Qe = z$1$1.Uint8Array || function() {
  }, at, ut = S$1$1, lt = E$1$1.getHighWaterMark, dt = e$1$12.codes, bt = dt.ERR_INVALID_ARG_TYPE, $t = dt.ERR_METHOD_NOT_IMPLEMENTED, vt = dt.ERR_MULTIPLE_CALLBACK, wt = dt.ERR_STREAM_CANNOT_PIPE, xt = dt.ERR_STREAM_DESTROYED, Et = dt.ERR_STREAM_NULL_VALUES, Tt = dt.ERR_STREAM_WRITE_AFTER_END, Rt = dt.ERR_UNKNOWN_ENCODING, Ct = ut.errorOrDestroy;
  function Zt() {
  }
  function Lt(rt, ot, ft) {
    $e = $e || Z$1$1(), rt = rt || {}, typeof ft != "boolean" && (ft = ot instanceof $e), this.objectMode = !!rt.objectMode, ft && (this.objectMode = this.objectMode || !!rt.writableObjectMode), this.highWaterMark = lt(this, rt, "writableHighWaterMark", ft), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var mt = rt.decodeStrings === !1;
    this.decodeStrings = !mt, this.defaultEncoding = rt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(yt) {
      (function(pt, Ge) {
        var ct = pt._writableState, Mt = ct.sync, St = ct.writecb;
        if (typeof St != "function")
          throw new vt();
        if (function(Nt) {
          Nt.writing = !1, Nt.writecb = null, Nt.length -= Nt.writelen, Nt.writelen = 0;
        }(ct), Ge)
          (function(Nt, qt, Qt, Xt, zt) {
            --qt.pendingcb, Qt ? (Ze.nextTick(zt, Xt), Ze.nextTick(Xe, Nt, qt), Nt._writableState.errorEmitted = !0, Ct(Nt, Xt)) : (zt(Xt), Nt._writableState.errorEmitted = !0, Ct(Nt, Xt), Xe(Nt, qt));
          })(pt, ct, Mt, Ge, St);
        else {
          var At = gt(ct) || pt.destroyed;
          At || ct.corked || ct.bufferProcessing || !ct.bufferedRequest || Ft(pt, ct), Mt ? Ze.nextTick(Ot, pt, ct, At, St) : Ot(pt, ct, At, St);
        }
      })(ot, yt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = rt.emitClose !== !1, this.autoDestroy = !!rt.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Fe(this);
  }
  function Ut(rt) {
    var ot = this instanceof ($e = $e || Z$1$1());
    if (!ot && !at.call(Ut, this))
      return new Ut(rt);
    this._writableState = new Lt(rt, this, ot), this.writable = !0, rt && (typeof rt.write == "function" && (this._write = rt.write), typeof rt.writev == "function" && (this._writev = rt.writev), typeof rt.destroy == "function" && (this._destroy = rt.destroy), typeof rt.final == "function" && (this._final = rt.final)), Ve.call(this);
  }
  function Pt(rt, ot, ft, mt, yt, pt, Ge) {
    ot.writelen = mt, ot.writecb = Ge, ot.writing = !0, ot.sync = !0, ot.destroyed ? ot.onwrite(new xt("write")) : ft ? rt._writev(yt, ot.onwrite) : rt._write(yt, pt, ot.onwrite), ot.sync = !1;
  }
  function Ot(rt, ot, ft, mt) {
    ft || function(yt, pt) {
      pt.length === 0 && pt.needDrain && (pt.needDrain = !1, yt.emit("drain"));
    }(rt, ot), ot.pendingcb--, mt(), Xe(rt, ot);
  }
  function Ft(rt, ot) {
    ot.bufferProcessing = !0;
    var ft = ot.bufferedRequest;
    if (rt._writev && ft && ft.next) {
      var mt = ot.bufferedRequestCount, yt = new Array(mt), pt = ot.corkedRequestsFree;
      pt.entry = ft;
      for (var Ge = 0, ct = !0; ft; )
        yt[Ge] = ft, ft.isBuf || (ct = !1), ft = ft.next, Ge += 1;
      yt.allBuffers = ct, Pt(rt, ot, !0, ot.length, yt, "", pt.finish), ot.pendingcb++, ot.lastBufferedRequest = null, pt.next ? (ot.corkedRequestsFree = pt.next, pt.next = null) : ot.corkedRequestsFree = new Fe(ot), ot.bufferedRequestCount = 0;
    } else {
      for (; ft; ) {
        var Mt = ft.chunk, St = ft.encoding, At = ft.callback;
        if (Pt(rt, ot, !1, ot.objectMode ? 1 : Mt.length, Mt, St, At), ft = ft.next, ot.bufferedRequestCount--, ot.writing)
          break;
      }
      ft === null && (ot.lastBufferedRequest = null);
    }
    ot.bufferedRequest = ft, ot.bufferProcessing = !1;
  }
  function gt(rt) {
    return rt.ending && rt.length === 0 && rt.bufferedRequest === null && !rt.finished && !rt.writing;
  }
  function We(rt, ot) {
    rt._final(function(ft) {
      ot.pendingcb--, ft && Ct(rt, ft), ot.prefinished = !0, rt.emit("prefinish"), Xe(rt, ot);
    });
  }
  function Xe(rt, ot) {
    var ft = gt(ot);
    if (ft && (function(yt, pt) {
      pt.prefinished || pt.finalCalled || (typeof yt._final != "function" || pt.destroyed ? (pt.prefinished = !0, yt.emit("prefinish")) : (pt.pendingcb++, pt.finalCalled = !0, Ze.nextTick(We, yt, pt)));
    }(rt, ot), ot.pendingcb === 0 && (ot.finished = !0, rt.emit("finish"), ot.autoDestroy))) {
      var mt = rt._readableState;
      (!mt || mt.autoDestroy && mt.endEmitted) && rt.destroy();
    }
    return ft;
  }
  return t$2(Ut, Ve), Lt.prototype.getBuffer = function() {
    for (var rt = this.bufferedRequest, ot = []; rt; )
      ot.push(rt), rt = rt.next;
    return ot;
  }, function() {
    try {
      Object.defineProperty(Lt.prototype, "buffer", { get: Ke.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch {
    }
  }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (at = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ut, Symbol.hasInstance, { value: function(rt) {
    return !!at.call(this, rt) || this === Ut && rt && rt._writableState instanceof Lt;
  } })) : at = function(rt) {
    return rt instanceof this;
  }, Ut.prototype.pipe = function() {
    Ct(this, new wt());
  }, Ut.prototype.write = function(rt, ot, ft) {
    var mt, yt = this._writableState, pt = !1, Ge = !yt.objectMode && (mt = rt, Je.isBuffer(mt) || mt instanceof Qe);
    return Ge && !Je.isBuffer(rt) && (rt = function(ct) {
      return Je.from(ct);
    }(rt)), typeof ot == "function" && (ft = ot, ot = null), Ge ? ot = "buffer" : ot || (ot = yt.defaultEncoding), typeof ft != "function" && (ft = Zt), yt.ending ? function(ct, Mt) {
      var St = new Tt();
      Ct(ct, St), Ze.nextTick(Mt, St);
    }(this, ft) : (Ge || function(ct, Mt, St, At) {
      var Nt;
      return St === null ? Nt = new Et() : typeof St == "string" || Mt.objectMode || (Nt = new bt("chunk", ["string", "Buffer"], St)), !Nt || (Ct(ct, Nt), Ze.nextTick(At, Nt), !1);
    }(this, yt, rt, ft)) && (yt.pendingcb++, pt = function(ct, Mt, St, At, Nt, qt) {
      if (!St) {
        var Qt = function(ur, er, Dt) {
          return ur.objectMode || ur.decodeStrings === !1 || typeof er != "string" || (er = Je.from(er, Dt)), er;
        }(Mt, At, Nt);
        At !== Qt && (St = !0, Nt = "buffer", At = Qt);
      }
      var Xt = Mt.objectMode ? 1 : At.length;
      Mt.length += Xt;
      var zt = Mt.length < Mt.highWaterMark;
      if (zt || (Mt.needDrain = !0), Mt.writing || Mt.corked) {
        var Kt = Mt.lastBufferedRequest;
        Mt.lastBufferedRequest = { chunk: At, encoding: Nt, isBuf: St, callback: qt, next: null }, Kt ? Kt.next = Mt.lastBufferedRequest : Mt.bufferedRequest = Mt.lastBufferedRequest, Mt.bufferedRequestCount += 1;
      } else
        Pt(ct, Mt, !1, Xt, At, Nt, qt);
      return zt;
    }(this, yt, Ge, rt, ot, ft)), pt;
  }, Ut.prototype.cork = function() {
    this._writableState.corked++;
  }, Ut.prototype.uncork = function() {
    var rt = this._writableState;
    rt.corked && (rt.corked--, rt.writing || rt.corked || rt.bufferProcessing || !rt.bufferedRequest || Ft(this, rt));
  }, Ut.prototype.setDefaultEncoding = function(rt) {
    if (typeof rt == "string" && (rt = rt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((rt + "").toLowerCase()) > -1))
      throw new Rt(rt);
    return this._writableState.defaultEncoding = rt, this;
  }, Object.defineProperty(Ut.prototype, "writableBuffer", { enumerable: !1, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(Ut.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
    return this._writableState.highWaterMark;
  } }), Ut.prototype._write = function(rt, ot, ft) {
    ft(new $t("_write()"));
  }, Ut.prototype._writev = null, Ut.prototype.end = function(rt, ot, ft) {
    var mt = this._writableState;
    return typeof rt == "function" ? (ft = rt, rt = null, ot = null) : typeof ot == "function" && (ft = ot, ot = null), rt != null && this.write(rt, ot), mt.corked && (mt.corked = 1, this.uncork()), mt.ending || function(yt, pt, Ge) {
      pt.ending = !0, Xe(yt, pt), Ge && (pt.finished ? Ze.nextTick(Ge) : yt.once("finish", Ge)), pt.ended = !0, yt.writable = !1;
    }(this, mt, ft), this;
  }, Object.defineProperty(Ut.prototype, "writableLength", { enumerable: !1, get: function() {
    return this._writableState.length;
  } }), Object.defineProperty(Ut.prototype, "destroyed", { enumerable: !1, get: function() {
    return this._writableState !== void 0 && this._writableState.destroyed;
  }, set: function(rt) {
    this._writableState && (this._writableState.destroyed = rt);
  } }), Ut.prototype.destroy = ut.destroy, Ut.prototype._undestroy = ut.undestroy, Ut.prototype._destroy = function(rt, ot) {
    ot(rt);
  }, Y$1$1;
}
var Q$1$1 = {}, X$1$1 = !1;
function Z$1$1() {
  if (X$1$1)
    return Q$1$1;
  X$1$1 = !0;
  var $e = T, Ze = Object.keys || function(dt) {
    var bt = [];
    for (var $t in dt)
      bt.push($t);
    return bt;
  };
  Q$1$1 = at;
  var Fe = G$1$1(), Ke = J$1$1();
  t$2(at, Fe);
  for (var Ve = Ze(Ke.prototype), Je = 0; Je < Ve.length; Je++) {
    var Qe = Ve[Je];
    at.prototype[Qe] || (at.prototype[Qe] = Ke.prototype[Qe]);
  }
  function at(dt) {
    if (!(this instanceof at))
      return new at(dt);
    Fe.call(this, dt), Ke.call(this, dt), this.allowHalfOpen = !0, dt && (dt.readable === !1 && (this.readable = !1), dt.writable === !1 && (this.writable = !1), dt.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", ut)));
  }
  function ut() {
    this._writableState.ended || $e.nextTick(lt, this);
  }
  function lt(dt) {
    dt.end();
  }
  return Object.defineProperty(at.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
    return this._writableState.highWaterMark;
  } }), Object.defineProperty(at.prototype, "writableBuffer", { enumerable: !1, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(at.prototype, "writableLength", { enumerable: !1, get: function() {
    return this._writableState.length;
  } }), Object.defineProperty(at.prototype, "destroyed", { enumerable: !1, get: function() {
    return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
  }, set: function(dt) {
    this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = dt, this._writableState.destroyed = dt);
  } }), Q$1$1;
}
var t$4$1 = J$1$1(), t$5$1 = ee$1(), n$2$1;
n$2$1 = u$1$12;
var i$e = e$1$12.codes, a$p = i$e.ERR_METHOD_NOT_IMPLEMENTED, o$s = i$e.ERR_MULTIPLE_CALLBACK, s$q = i$e.ERR_TRANSFORM_ALREADY_TRANSFORMING, f$2$1$1 = i$e.ERR_TRANSFORM_WITH_LENGTH_0, h$2$1 = t$5$1;
function l$s($e, Ze) {
  var Fe = this._transformState;
  Fe.transforming = !1;
  var Ke = Fe.writecb;
  if (Ke === null)
    return this.emit("error", new o$s());
  Fe.writechunk = null, Fe.writecb = null, Ze != null && this.push(Ze), Ke($e);
  var Ve = this._readableState;
  Ve.reading = !1, (Ve.needReadable || Ve.length < Ve.highWaterMark) && this._read(Ve.highWaterMark);
}
function u$1$12($e) {
  if (!(this instanceof u$1$12))
    return new u$1$12($e);
  h$2$1.call(this, $e), this._transformState = { afterTransform: l$s.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, $e && (typeof $e.transform == "function" && (this._transform = $e.transform), typeof $e.flush == "function" && (this._flush = $e.flush)), this.on("prefinish", m$2$1);
}
function m$2$1() {
  var $e = this;
  typeof this._flush != "function" || this._readableState.destroyed ? _$2$1(this, null, null) : this._flush(function(Ze, Fe) {
    _$2$1($e, Ze, Fe);
  });
}
function _$2$1($e, Ze, Fe) {
  if (Ze)
    return $e.emit("error", Ze);
  if (Fe != null && $e.push(Fe), $e._writableState.length)
    throw new f$2$1$1();
  if ($e._transformState.transforming)
    throw new s$q();
  return $e.push(null);
}
t$2(u$1$12, h$2$1), u$1$12.prototype.push = function($e, Ze) {
  return this._transformState.needTransform = !1, h$2$1.prototype.push.call(this, $e, Ze);
}, u$1$12.prototype._transform = function($e, Ze, Fe) {
  Fe(new a$p("_transform()"));
}, u$1$12.prototype._write = function($e, Ze, Fe) {
  var Ke = this._transformState;
  if (Ke.writecb = Fe, Ke.writechunk = $e, Ke.writeencoding = Ze, !Ke.transforming) {
    var Ve = this._readableState;
    (Ke.needTransform || Ve.needReadable || Ve.length < Ve.highWaterMark) && this._read(Ve.highWaterMark);
  }
}, u$1$12.prototype._read = function($e) {
  var Ze = this._transformState;
  Ze.writechunk === null || Ze.transforming ? Ze.needTransform = !0 : (Ze.transforming = !0, this._transform(Ze.writechunk, Ze.writeencoding, Ze.afterTransform));
}, u$1$12.prototype._destroy = function($e, Ze) {
  h$2$1.prototype._destroy.call(this, $e, function(Fe) {
    Ze(Fe);
  });
};
var p$2$1 = n$2$1, o$1$12;
o$1$12 = i$1$1$1;
var e$3$1 = p$2$1;
function i$1$1$1($e) {
  if (!(this instanceof i$1$1$1))
    return new i$1$1$1($e);
  e$3$1.call(this, $e);
}
t$2(i$1$1$1, e$3$1), i$1$1$1.prototype._transform = function($e, Ze, Fe) {
  Fe(null, $e);
};
var s$1$1 = o$1$12, t$6$1, o$2$1 = e$1$12.codes, e$4$1 = o$2$1.ERR_MISSING_ARGS, f$3$1 = o$2$1.ERR_STREAM_DESTROYED;
function i$2$1($e) {
  if ($e)
    throw $e;
}
function u$2$1($e, Ze, Fe, Ke) {
  Ke = function(Qe) {
    var at = !1;
    return function() {
      at || (at = !0, Qe.apply(void 0, arguments));
    };
  }(Ke);
  var Ve = !1;
  $e.on("close", function() {
    Ve = !0;
  }), t$6$1 === void 0 && (t$6$1 = n$1$12), t$6$1($e, { readable: Ze, writable: Fe }, function(Qe) {
    if (Qe)
      return Ke(Qe);
    Ve = !0, Ke();
  });
  var Je = !1;
  return function(Qe) {
    if (!Ve && !Je)
      return Je = !0, function(at) {
        return at.setHeader && typeof at.abort == "function";
      }($e) ? $e.abort() : typeof $e.destroy == "function" ? $e.destroy() : (Ke(Qe || new f$3$1("pipe")), void 0);
  };
}
function a$1$12($e) {
  $e();
}
function c$2$1($e, Ze) {
  return $e.pipe(Ze);
}
function p$3$1($e) {
  return $e.length ? typeof $e[$e.length - 1] != "function" ? i$2$1 : $e.pop() : i$2$1;
}
var v$2$1 = function() {
  for (var $e = arguments.length, Ze = new Array($e), Fe = 0; Fe < $e; Fe++)
    Ze[Fe] = arguments[Fe];
  var Ke, Ve = p$3$1(Ze);
  if (Array.isArray(Ze[0]) && (Ze = Ze[0]), Ze.length < 2)
    throw new e$4$1("streams");
  var Je = Ze.map(function(Qe, at) {
    var ut = at < Ze.length - 1;
    return u$2$1(Qe, ut, at > 0, function(lt) {
      Ke || (Ke = lt), lt && Je.forEach(a$1$12), ut || (Je.forEach(a$1$12), Ve(Ke));
    });
  });
  return Ze.reduce(c$2$1);
}, l$r, d$n = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
l$r = p$r;
var f$u = y.EventEmitter;
function p$r() {
  f$u.call(this || d$n);
}
t$2(p$r, f$u), p$r.Readable = t$2$1, p$r.Writable = t$4$1, p$r.Duplex = t$5$1, p$r.Transform = p$2$1, p$r.PassThrough = s$1$1, p$r.finished = n$1$12, p$r.pipeline = v$2$1, p$r.Stream = p$r, p$r.prototype.pipe = function($e, Ze) {
  var Fe = this || d$n;
  function Ke(dt) {
    $e.writable && $e.write(dt) === !1 && Fe.pause && Fe.pause();
  }
  function Ve() {
    Fe.readable && Fe.resume && Fe.resume();
  }
  Fe.on("data", Ke), $e.on("drain", Ve), $e._isStdio || Ze && Ze.end === !1 || (Fe.on("end", Qe), Fe.on("close", at));
  var Je = !1;
  function Qe() {
    Je || (Je = !0, $e.end());
  }
  function at() {
    Je || (Je = !0, typeof $e.destroy == "function" && $e.destroy());
  }
  function ut(dt) {
    if (lt(), f$u.listenerCount(this || d$n, "error") === 0)
      throw dt;
  }
  function lt() {
    Fe.removeListener("data", Ke), $e.removeListener("drain", Ve), Fe.removeListener("end", Qe), Fe.removeListener("close", at), Fe.removeListener("error", ut), $e.removeListener("error", ut), Fe.removeListener("end", lt), Fe.removeListener("close", lt), $e.removeListener("close", lt);
  }
  return Fe.on("error", ut), $e.on("error", ut), Fe.on("end", lt), Fe.on("close", lt), $e.on("close", lt), $e.emit("pipe", Fe), $e;
};
var b$i = l$r;
b$i.Readable;
b$i.Writable;
b$i.Duplex;
b$i.Transform;
b$i.PassThrough;
b$i.finished;
b$i.pipeline;
b$i.Stream;
var exports$1H = {}, _dewExec$1G = !1, _global$o = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1G() {
  if (_dewExec$1G)
    return exports$1H;
  _dewExec$1G = !0;
  var $e = dew$1T().Buffer, Ze = b$i.Transform, Fe = e$12.StringDecoder, Ke = dew$f$2();
  function Ve(Je) {
    Ze.call(this || _global$o), (this || _global$o).hashMode = typeof Je == "string", (this || _global$o).hashMode ? (this || _global$o)[Je] = (this || _global$o)._finalOrDigest : (this || _global$o).final = (this || _global$o)._finalOrDigest, (this || _global$o)._final && ((this || _global$o).__final = (this || _global$o)._final, (this || _global$o)._final = null), (this || _global$o)._decoder = null, (this || _global$o)._encoding = null;
  }
  return Ke(Ve, Ze), Ve.prototype.update = function(Je, Qe, at) {
    typeof Je == "string" && (Je = $e.from(Je, Qe));
    var ut = this._update(Je);
    return (this || _global$o).hashMode ? this || _global$o : (at && (ut = this._toString(ut, at)), ut);
  }, Ve.prototype.setAutoPadding = function() {
  }, Ve.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, Ve.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, Ve.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, Ve.prototype._transform = function(Je, Qe, at) {
    var ut;
    try {
      (this || _global$o).hashMode ? this._update(Je) : this.push(this._update(Je));
    } catch (lt) {
      ut = lt;
    } finally {
      at(ut);
    }
  }, Ve.prototype._flush = function(Je) {
    var Qe;
    try {
      this.push(this.__final());
    } catch (at) {
      Qe = at;
    }
    Je(Qe);
  }, Ve.prototype._finalOrDigest = function(Je) {
    var Qe = this.__final() || $e.alloc(0);
    return Je && (Qe = this._toString(Qe, Je, !0)), Qe;
  }, Ve.prototype._toString = function(Je, Qe, at) {
    if ((this || _global$o)._decoder || ((this || _global$o)._decoder = new Fe(Qe), (this || _global$o)._encoding = Qe), (this || _global$o)._encoding !== Qe)
      throw new Error("can't switch encodings");
    var ut = (this || _global$o)._decoder.write(Je);
    return at && (ut += (this || _global$o)._decoder.end()), ut;
  }, exports$1H = Ve, exports$1H;
}
var exports$1G = {}, _dewExec$1F = !1;
function dew$1F() {
  if (_dewExec$1F)
    return exports$1G;
  _dewExec$1F = !0;
  var $e = dew$f$2(), Ze = dew$1Q(), Fe = dew$1P(), Ke = dew$1H(), Ve = dew$1G();
  function Je(Qe) {
    Ve.call(this, "digest"), this._hash = Qe;
  }
  return $e(Je, Ve), Je.prototype._update = function(Qe) {
    this._hash.update(Qe);
  }, Je.prototype._final = function() {
    return this._hash.digest();
  }, exports$1G = function(at) {
    return at = at.toLowerCase(), at === "md5" ? new Ze() : at === "rmd160" || at === "ripemd160" ? new Fe() : new Je(Ke(at));
  }, exports$1G;
}
var exports$1F = {}, _dewExec$1E = !1;
function dew$1E() {
  if (_dewExec$1E)
    return exports$1F;
  _dewExec$1E = !0;
  var $e = dew$f$2(), Ze = dew$1T().Buffer, Fe = dew$1G(), Ke = Ze.alloc(128), Ve = 64;
  function Je(Qe, at) {
    Fe.call(this, "digest"), typeof at == "string" && (at = Ze.from(at)), this._alg = Qe, this._key = at, at.length > Ve ? at = Qe(at) : at.length < Ve && (at = Ze.concat([at, Ke], Ve));
    for (var ut = this._ipad = Ze.allocUnsafe(Ve), lt = this._opad = Ze.allocUnsafe(Ve), dt = 0; dt < Ve; dt++)
      ut[dt] = at[dt] ^ 54, lt[dt] = at[dt] ^ 92;
    this._hash = [ut];
  }
  return $e(Je, Fe), Je.prototype._update = function(Qe) {
    this._hash.push(Qe);
  }, Je.prototype._final = function() {
    var Qe = this._alg(Ze.concat(this._hash));
    return this._alg(Ze.concat([this._opad, Qe]));
  }, exports$1F = Je, exports$1F;
}
var exports$1E = {}, _dewExec$1D = !1;
function dew$1D() {
  if (_dewExec$1D)
    return exports$1E;
  _dewExec$1D = !0;
  var $e = dew$1Q();
  return exports$1E = function(Ze) {
    return new $e().update(Ze).digest();
  }, exports$1E;
}
var exports$1D = {}, _dewExec$1C = !1;
function dew$1C() {
  if (_dewExec$1C)
    return exports$1D;
  _dewExec$1C = !0;
  var $e = dew$f$2(), Ze = dew$1E(), Fe = dew$1G(), Ke = dew$1T().Buffer, Ve = dew$1D(), Je = dew$1P(), Qe = dew$1H(), at = Ke.alloc(128);
  function ut(lt, dt) {
    Fe.call(this, "digest"), typeof dt == "string" && (dt = Ke.from(dt));
    var bt = lt === "sha512" || lt === "sha384" ? 128 : 64;
    if (this._alg = lt, this._key = dt, dt.length > bt) {
      var $t = lt === "rmd160" ? new Je() : Qe(lt);
      dt = $t.update(dt).digest();
    } else
      dt.length < bt && (dt = Ke.concat([dt, at], bt));
    for (var vt = this._ipad = Ke.allocUnsafe(bt), wt = this._opad = Ke.allocUnsafe(bt), xt = 0; xt < bt; xt++)
      vt[xt] = dt[xt] ^ 54, wt[xt] = dt[xt] ^ 92;
    this._hash = lt === "rmd160" ? new Je() : Qe(lt), this._hash.update(vt);
  }
  return $e(ut, Fe), ut.prototype._update = function(lt) {
    this._hash.update(lt);
  }, ut.prototype._final = function() {
    var lt = this._hash.digest(), dt = this._alg === "rmd160" ? new Je() : Qe(this._alg);
    return dt.update(this._opad).update(lt).digest();
  }, exports$1D = function(dt, bt) {
    return dt = dt.toLowerCase(), dt === "rmd160" || dt === "ripemd160" ? new ut("rmd160", bt) : dt === "md5" ? new Ze(Ve, bt) : new ut(dt, bt);
  }, exports$1D;
}
var _algorithms = {
  sha224WithRSAEncryption: {
    sign: "rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption: {
    sign: "rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption: {
    sign: "rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption: {
    sign: "rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: {
    sign: "ecdsa",
    hash: "sha256",
    id: ""
  },
  sha224: {
    sign: "ecdsa",
    hash: "sha224",
    id: ""
  },
  sha384: {
    sign: "ecdsa",
    hash: "sha384",
    id: ""
  },
  sha512: {
    sign: "ecdsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA: {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA: {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption: {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  },
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
}, exports$1C = {}, _dewExec$1B = !1;
function dew$1B() {
  return _dewExec$1B || (_dewExec$1B = !0, exports$1C = _algorithms), exports$1C;
}
var exports$1B = {}, _dewExec$1A = !1;
function dew$1A() {
  if (_dewExec$1A)
    return exports$1B;
  _dewExec$1A = !0;
  var $e = Math.pow(2, 30) - 1;
  return exports$1B = function(Ze, Fe) {
    if (typeof Ze != "number")
      throw new TypeError("Iterations not a number");
    if (Ze < 0)
      throw new TypeError("Bad iterations");
    if (typeof Fe != "number")
      throw new TypeError("Key length not a number");
    if (Fe < 0 || Fe > $e || Fe !== Fe)
      throw new TypeError("Bad key length");
  }, exports$1B;
}
var exports$1A = {}, _dewExec$1z = !1, _global$n = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1z() {
  if (_dewExec$1z)
    return exports$1A;
  _dewExec$1z = !0;
  var $e = T, Ze;
  if (_global$n.process && _global$n.process.browser)
    Ze = "utf-8";
  else if (_global$n.process && _global$n.process.version) {
    var Fe = parseInt($e.version.split(".")[0].slice(1), 10);
    Ze = Fe >= 6 ? "utf-8" : "binary";
  } else
    Ze = "utf-8";
  return exports$1A = Ze, exports$1A;
}
var exports$1z = {}, _dewExec$1y = !1;
function dew$1y() {
  if (_dewExec$1y)
    return exports$1z;
  _dewExec$1y = !0;
  var $e = dew$1T().Buffer;
  return exports$1z = function(Ze, Fe, Ke) {
    if ($e.isBuffer(Ze))
      return Ze;
    if (typeof Ze == "string")
      return $e.from(Ze, Fe);
    if (ArrayBuffer.isView(Ze))
      return $e.from(Ze.buffer);
    throw new TypeError(Ke + " must be a string, a Buffer, a typed array or a DataView");
  }, exports$1z;
}
var exports$1y = {}, _dewExec$1x = !1, _global$m = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1x() {
  if (_dewExec$1x)
    return exports$1y;
  _dewExec$1x = !0;
  var $e = dew$1D(), Ze = dew$1P(), Fe = dew$1H(), Ke = dew$1T().Buffer, Ve = dew$1A(), Je = dew$1z(), Qe = dew$1y(), at = Ke.alloc(128), ut = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function lt($t, vt, wt) {
    var xt = dt($t), Et = $t === "sha512" || $t === "sha384" ? 128 : 64;
    vt.length > Et ? vt = xt(vt) : vt.length < Et && (vt = Ke.concat([vt, at], Et));
    for (var Tt = Ke.allocUnsafe(Et + ut[$t]), Rt = Ke.allocUnsafe(Et + ut[$t]), Ct = 0; Ct < Et; Ct++)
      Tt[Ct] = vt[Ct] ^ 54, Rt[Ct] = vt[Ct] ^ 92;
    var Zt = Ke.allocUnsafe(Et + wt + 4);
    Tt.copy(Zt, 0, 0, Et), (this || _global$m).ipad1 = Zt, (this || _global$m).ipad2 = Tt, (this || _global$m).opad = Rt, (this || _global$m).alg = $t, (this || _global$m).blocksize = Et, (this || _global$m).hash = xt, (this || _global$m).size = ut[$t];
  }
  lt.prototype.run = function($t, vt) {
    $t.copy(vt, (this || _global$m).blocksize);
    var wt = this.hash(vt);
    return wt.copy((this || _global$m).opad, (this || _global$m).blocksize), this.hash((this || _global$m).opad);
  };
  function dt($t) {
    function vt(xt) {
      return Fe($t).update(xt).digest();
    }
    function wt(xt) {
      return new Ze().update(xt).digest();
    }
    return $t === "rmd160" || $t === "ripemd160" ? wt : $t === "md5" ? $e : vt;
  }
  function bt($t, vt, wt, xt, Et) {
    Ve(wt, xt), $t = Qe($t, Je, "Password"), vt = Qe(vt, Je, "Salt"), Et = Et || "sha1";
    var Tt = new lt(Et, $t, vt.length), Rt = Ke.allocUnsafe(xt), Ct = Ke.allocUnsafe(vt.length + 4);
    vt.copy(Ct, 0, 0, vt.length);
    for (var Zt = 0, Lt = ut[Et], Ut = Math.ceil(xt / Lt), Pt = 1; Pt <= Ut; Pt++) {
      Ct.writeUInt32BE(Pt, vt.length);
      for (var Ot = Tt.run(Ct, Tt.ipad1), Ft = Ot, gt = 1; gt < wt; gt++) {
        Ft = Tt.run(Ft, Tt.ipad2);
        for (var We = 0; We < Lt; We++)
          Ot[We] ^= Ft[We];
      }
      Ot.copy(Rt, Zt), Zt += Lt;
    }
    return Rt;
  }
  return exports$1y = bt, exports$1y;
}
var exports$1x = {}, _dewExec$1w = !1, _global$l = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1w() {
  if (_dewExec$1w)
    return exports$1x;
  _dewExec$1w = !0;
  var $e = dew$1T().Buffer, Ze = dew$1A(), Fe = dew$1z(), Ke = dew$1x(), Ve = dew$1y(), Je, Qe = _global$l.crypto && _global$l.crypto.subtle, at = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, ut = [];
  function lt(wt) {
    if (_global$l.process && !_global$l.process.browser || !Qe || !Qe.importKey || !Qe.deriveBits)
      return Promise.resolve(!1);
    if (ut[wt] !== void 0)
      return ut[wt];
    Je = Je || $e.alloc(8);
    var xt = $t(Je, Je, 10, 128, wt).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return ut[wt] = xt, xt;
  }
  var dt;
  function bt() {
    return dt || (_global$l.process && _global$l.process.nextTick ? dt = _global$l.process.nextTick : _global$l.queueMicrotask ? dt = _global$l.queueMicrotask : _global$l.setImmediate ? dt = _global$l.setImmediate : dt = _global$l.setTimeout, dt);
  }
  function $t(wt, xt, Et, Tt, Rt) {
    return Qe.importKey("raw", wt, {
      name: "PBKDF2"
    }, !1, ["deriveBits"]).then(function(Ct) {
      return Qe.deriveBits({
        name: "PBKDF2",
        salt: xt,
        iterations: Et,
        hash: {
          name: Rt
        }
      }, Ct, Tt << 3);
    }).then(function(Ct) {
      return $e.from(Ct);
    });
  }
  function vt(wt, xt) {
    wt.then(function(Et) {
      bt()(function() {
        xt(null, Et);
      });
    }, function(Et) {
      bt()(function() {
        xt(Et);
      });
    });
  }
  return exports$1x = function(wt, xt, Et, Tt, Rt, Ct) {
    typeof Rt == "function" && (Ct = Rt, Rt = void 0), Rt = Rt || "sha1";
    var Zt = at[Rt.toLowerCase()];
    if (!Zt || typeof _global$l.Promise != "function") {
      bt()(function() {
        var Lt;
        try {
          Lt = Ke(wt, xt, Et, Tt, Rt);
        } catch (Ut) {
          return Ct(Ut);
        }
        Ct(null, Lt);
      });
      return;
    }
    if (Ze(Et, Tt), wt = Ve(wt, Fe, "Password"), xt = Ve(xt, Fe, "Salt"), typeof Ct != "function")
      throw new Error("No callback provided to pbkdf2");
    vt(lt(Zt).then(function(Lt) {
      return Lt ? $t(wt, xt, Et, Tt, Zt) : Ke(wt, xt, Et, Tt, Rt);
    }), Ct);
  }, exports$1x;
}
var exports$1w = {}, _dewExec$1v = !1;
function dew$1v() {
  return _dewExec$1v || (_dewExec$1v = !0, exports$1w.pbkdf2 = dew$1w(), exports$1w.pbkdf2Sync = dew$1x()), exports$1w;
}
var exports$1v = {}, _dewExec$1u = !1;
function dew$1u() {
  if (_dewExec$1u)
    return exports$1v;
  _dewExec$1u = !0, exports$1v.readUInt32BE = function(Ve, Je) {
    var Qe = Ve[0 + Je] << 24 | Ve[1 + Je] << 16 | Ve[2 + Je] << 8 | Ve[3 + Je];
    return Qe >>> 0;
  }, exports$1v.writeUInt32BE = function(Ve, Je, Qe) {
    Ve[0 + Qe] = Je >>> 24, Ve[1 + Qe] = Je >>> 16 & 255, Ve[2 + Qe] = Je >>> 8 & 255, Ve[3 + Qe] = Je & 255;
  }, exports$1v.ip = function(Ve, Je, Qe, at) {
    for (var ut = 0, lt = 0, dt = 6; dt >= 0; dt -= 2) {
      for (var bt = 0; bt <= 24; bt += 8)
        ut <<= 1, ut |= Je >>> bt + dt & 1;
      for (var bt = 0; bt <= 24; bt += 8)
        ut <<= 1, ut |= Ve >>> bt + dt & 1;
    }
    for (var dt = 6; dt >= 0; dt -= 2) {
      for (var bt = 1; bt <= 25; bt += 8)
        lt <<= 1, lt |= Je >>> bt + dt & 1;
      for (var bt = 1; bt <= 25; bt += 8)
        lt <<= 1, lt |= Ve >>> bt + dt & 1;
    }
    Qe[at + 0] = ut >>> 0, Qe[at + 1] = lt >>> 0;
  }, exports$1v.rip = function(Ve, Je, Qe, at) {
    for (var ut = 0, lt = 0, dt = 0; dt < 4; dt++)
      for (var bt = 24; bt >= 0; bt -= 8)
        ut <<= 1, ut |= Je >>> bt + dt & 1, ut <<= 1, ut |= Ve >>> bt + dt & 1;
    for (var dt = 4; dt < 8; dt++)
      for (var bt = 24; bt >= 0; bt -= 8)
        lt <<= 1, lt |= Je >>> bt + dt & 1, lt <<= 1, lt |= Ve >>> bt + dt & 1;
    Qe[at + 0] = ut >>> 0, Qe[at + 1] = lt >>> 0;
  }, exports$1v.pc1 = function(Ve, Je, Qe, at) {
    for (var ut = 0, lt = 0, dt = 7; dt >= 5; dt--) {
      for (var bt = 0; bt <= 24; bt += 8)
        ut <<= 1, ut |= Je >> bt + dt & 1;
      for (var bt = 0; bt <= 24; bt += 8)
        ut <<= 1, ut |= Ve >> bt + dt & 1;
    }
    for (var bt = 0; bt <= 24; bt += 8)
      ut <<= 1, ut |= Je >> bt + dt & 1;
    for (var dt = 1; dt <= 3; dt++) {
      for (var bt = 0; bt <= 24; bt += 8)
        lt <<= 1, lt |= Je >> bt + dt & 1;
      for (var bt = 0; bt <= 24; bt += 8)
        lt <<= 1, lt |= Ve >> bt + dt & 1;
    }
    for (var bt = 0; bt <= 24; bt += 8)
      lt <<= 1, lt |= Ve >> bt + dt & 1;
    Qe[at + 0] = ut >>> 0, Qe[at + 1] = lt >>> 0;
  }, exports$1v.r28shl = function(Ve, Je) {
    return Ve << Je & 268435455 | Ve >>> 28 - Je;
  };
  var $e = [
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  exports$1v.pc2 = function(Ve, Je, Qe, at) {
    for (var ut = 0, lt = 0, dt = $e.length >>> 1, bt = 0; bt < dt; bt++)
      ut <<= 1, ut |= Ve >>> $e[bt] & 1;
    for (var bt = dt; bt < $e.length; bt++)
      lt <<= 1, lt |= Je >>> $e[bt] & 1;
    Qe[at + 0] = ut >>> 0, Qe[at + 1] = lt >>> 0;
  }, exports$1v.expand = function(Ve, Je, Qe) {
    var at = 0, ut = 0;
    at = (Ve & 1) << 5 | Ve >>> 27;
    for (var lt = 23; lt >= 15; lt -= 4)
      at <<= 6, at |= Ve >>> lt & 63;
    for (var lt = 11; lt >= 3; lt -= 4)
      ut |= Ve >>> lt & 63, ut <<= 6;
    ut |= (Ve & 31) << 1 | Ve >>> 31, Je[Qe + 0] = at >>> 0, Je[Qe + 1] = ut >>> 0;
  };
  var Ze = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
  exports$1v.substitute = function(Ve, Je) {
    for (var Qe = 0, at = 0; at < 4; at++) {
      var ut = Ve >>> 18 - at * 6 & 63, lt = Ze[at * 64 + ut];
      Qe <<= 4, Qe |= lt;
    }
    for (var at = 0; at < 4; at++) {
      var ut = Je >>> 18 - at * 6 & 63, lt = Ze[4 * 64 + at * 64 + ut];
      Qe <<= 4, Qe |= lt;
    }
    return Qe >>> 0;
  };
  var Fe = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
  return exports$1v.permute = function(Ve) {
    for (var Je = 0, Qe = 0; Qe < Fe.length; Qe++)
      Je <<= 1, Je |= Ve >>> Fe[Qe] & 1;
    return Je >>> 0;
  }, exports$1v.padSplit = function(Ve, Je, Qe) {
    for (var at = Ve.toString(2); at.length < Je; )
      at = "0" + at;
    for (var ut = [], lt = 0; lt < Je; lt += Qe)
      ut.push(at.slice(lt, lt + Qe));
    return ut.join(" ");
  }, exports$1v;
}
var exports$1u = {}, _dewExec$1t = !1;
function dew$1t() {
  if (_dewExec$1t)
    return exports$1u;
  _dewExec$1t = !0, exports$1u = $e;
  function $e(Ze, Fe) {
    if (!Ze)
      throw new Error(Fe || "Assertion failed");
  }
  return $e.equal = function(Fe, Ke, Ve) {
    if (Fe != Ke)
      throw new Error(Ve || "Assertion failed: " + Fe + " != " + Ke);
  }, exports$1u;
}
var exports$1t = {}, _dewExec$1s = !1;
function dew$1s() {
  if (_dewExec$1s)
    return exports$1t;
  _dewExec$1s = !0;
  var $e = dew$1t();
  function Ze(Fe) {
    this.options = Fe, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
  }
  return exports$1t = Ze, Ze.prototype._init = function() {
  }, Ze.prototype.update = function(Ke) {
    return Ke.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(Ke) : this._updateEncrypt(Ke);
  }, Ze.prototype._buffer = function(Ke, Ve) {
    for (var Je = Math.min(this.buffer.length - this.bufferOff, Ke.length - Ve), Qe = 0; Qe < Je; Qe++)
      this.buffer[this.bufferOff + Qe] = Ke[Ve + Qe];
    return this.bufferOff += Je, Je;
  }, Ze.prototype._flushBuffer = function(Ke, Ve) {
    return this._update(this.buffer, 0, Ke, Ve), this.bufferOff = 0, this.blockSize;
  }, Ze.prototype._updateEncrypt = function(Ke) {
    var Ve = 0, Je = 0, Qe = (this.bufferOff + Ke.length) / this.blockSize | 0, at = new Array(Qe * this.blockSize);
    this.bufferOff !== 0 && (Ve += this._buffer(Ke, Ve), this.bufferOff === this.buffer.length && (Je += this._flushBuffer(at, Je)));
    for (var ut = Ke.length - (Ke.length - Ve) % this.blockSize; Ve < ut; Ve += this.blockSize)
      this._update(Ke, Ve, at, Je), Je += this.blockSize;
    for (; Ve < Ke.length; Ve++, this.bufferOff++)
      this.buffer[this.bufferOff] = Ke[Ve];
    return at;
  }, Ze.prototype._updateDecrypt = function(Ke) {
    for (var Ve = 0, Je = 0, Qe = Math.ceil((this.bufferOff + Ke.length) / this.blockSize) - 1, at = new Array(Qe * this.blockSize); Qe > 0; Qe--)
      Ve += this._buffer(Ke, Ve), Je += this._flushBuffer(at, Je);
    return Ve += this._buffer(Ke, Ve), at;
  }, Ze.prototype.final = function(Ke) {
    var Ve;
    Ke && (Ve = this.update(Ke));
    var Je;
    return this.type === "encrypt" ? Je = this._finalEncrypt() : Je = this._finalDecrypt(), Ve ? Ve.concat(Je) : Je;
  }, Ze.prototype._pad = function(Ke, Ve) {
    if (Ve === 0)
      return !1;
    for (; Ve < Ke.length; )
      Ke[Ve++] = 0;
    return !0;
  }, Ze.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var Ke = new Array(this.blockSize);
    return this._update(this.buffer, 0, Ke, 0), Ke;
  }, Ze.prototype._unpad = function(Ke) {
    return Ke;
  }, Ze.prototype._finalDecrypt = function() {
    $e.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var Ke = new Array(this.blockSize);
    return this._flushBuffer(Ke, 0), this._unpad(Ke);
  }, exports$1t;
}
var exports$1s = {}, _dewExec$1r = !1;
function dew$1r() {
  if (_dewExec$1r)
    return exports$1s;
  _dewExec$1r = !0;
  var $e = dew$1t(), Ze = dew$f$2(), Fe = dew$1u(), Ke = dew$1s();
  function Ve() {
    this.tmp = new Array(2), this.keys = null;
  }
  function Je(at) {
    Ke.call(this, at);
    var ut = new Ve();
    this._desState = ut, this.deriveKeys(ut, at.key);
  }
  Ze(Je, Ke), exports$1s = Je, Je.create = function(ut) {
    return new Je(ut);
  };
  var Qe = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
  return Je.prototype.deriveKeys = function(ut, lt) {
    ut.keys = new Array(16 * 2), $e.equal(lt.length, this.blockSize, "Invalid key length");
    var dt = Fe.readUInt32BE(lt, 0), bt = Fe.readUInt32BE(lt, 4);
    Fe.pc1(dt, bt, ut.tmp, 0), dt = ut.tmp[0], bt = ut.tmp[1];
    for (var $t = 0; $t < ut.keys.length; $t += 2) {
      var vt = Qe[$t >>> 1];
      dt = Fe.r28shl(dt, vt), bt = Fe.r28shl(bt, vt), Fe.pc2(dt, bt, ut.keys, $t);
    }
  }, Je.prototype._update = function(ut, lt, dt, bt) {
    var $t = this._desState, vt = Fe.readUInt32BE(ut, lt), wt = Fe.readUInt32BE(ut, lt + 4);
    Fe.ip(vt, wt, $t.tmp, 0), vt = $t.tmp[0], wt = $t.tmp[1], this.type === "encrypt" ? this._encrypt($t, vt, wt, $t.tmp, 0) : this._decrypt($t, vt, wt, $t.tmp, 0), vt = $t.tmp[0], wt = $t.tmp[1], Fe.writeUInt32BE(dt, vt, bt), Fe.writeUInt32BE(dt, wt, bt + 4);
  }, Je.prototype._pad = function(ut, lt) {
    for (var dt = ut.length - lt, bt = lt; bt < ut.length; bt++)
      ut[bt] = dt;
    return !0;
  }, Je.prototype._unpad = function(ut) {
    for (var lt = ut[ut.length - 1], dt = ut.length - lt; dt < ut.length; dt++)
      $e.equal(ut[dt], lt);
    return ut.slice(0, ut.length - lt);
  }, Je.prototype._encrypt = function(ut, lt, dt, bt, $t) {
    for (var vt = lt, wt = dt, xt = 0; xt < ut.keys.length; xt += 2) {
      var Et = ut.keys[xt], Tt = ut.keys[xt + 1];
      Fe.expand(wt, ut.tmp, 0), Et ^= ut.tmp[0], Tt ^= ut.tmp[1];
      var Rt = Fe.substitute(Et, Tt), Ct = Fe.permute(Rt), Zt = wt;
      wt = (vt ^ Ct) >>> 0, vt = Zt;
    }
    Fe.rip(wt, vt, bt, $t);
  }, Je.prototype._decrypt = function(ut, lt, dt, bt, $t) {
    for (var vt = dt, wt = lt, xt = ut.keys.length - 2; xt >= 0; xt -= 2) {
      var Et = ut.keys[xt], Tt = ut.keys[xt + 1];
      Fe.expand(vt, ut.tmp, 0), Et ^= ut.tmp[0], Tt ^= ut.tmp[1];
      var Rt = Fe.substitute(Et, Tt), Ct = Fe.permute(Rt), Zt = vt;
      vt = (wt ^ Ct) >>> 0, wt = Zt;
    }
    Fe.rip(vt, wt, bt, $t);
  }, exports$1s;
}
var exports$1r = {}, _dewExec$1q = !1;
function dew$1q() {
  if (_dewExec$1q)
    return exports$1r;
  _dewExec$1q = !0;
  var $e = dew$1t(), Ze = dew$f$2(), Fe = {};
  function Ke(Je) {
    $e.equal(Je.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var Qe = 0; Qe < this.iv.length; Qe++)
      this.iv[Qe] = Je[Qe];
  }
  function Ve(Je) {
    function Qe(dt) {
      Je.call(this, dt), this._cbcInit();
    }
    Ze(Qe, Je);
    for (var at = Object.keys(Fe), ut = 0; ut < at.length; ut++) {
      var lt = at[ut];
      Qe.prototype[lt] = Fe[lt];
    }
    return Qe.create = function(bt) {
      return new Qe(bt);
    }, Qe;
  }
  return exports$1r.instantiate = Ve, Fe._cbcInit = function() {
    var Qe = new Ke(this.options.iv);
    this._cbcState = Qe;
  }, Fe._update = function(Qe, at, ut, lt) {
    var dt = this._cbcState, bt = this.constructor.super_.prototype, $t = dt.iv;
    if (this.type === "encrypt") {
      for (var vt = 0; vt < this.blockSize; vt++)
        $t[vt] ^= Qe[at + vt];
      bt._update.call(this, $t, 0, ut, lt);
      for (var vt = 0; vt < this.blockSize; vt++)
        $t[vt] = ut[lt + vt];
    } else {
      bt._update.call(this, Qe, at, ut, lt);
      for (var vt = 0; vt < this.blockSize; vt++)
        ut[lt + vt] ^= $t[vt];
      for (var vt = 0; vt < this.blockSize; vt++)
        $t[vt] = Qe[at + vt];
    }
  }, exports$1r;
}
var exports$1q = {}, _dewExec$1p = !1;
function dew$1p() {
  if (_dewExec$1p)
    return exports$1q;
  _dewExec$1p = !0;
  var $e = dew$1t(), Ze = dew$f$2(), Fe = dew$1s(), Ke = dew$1r();
  function Ve(Qe, at) {
    $e.equal(at.length, 24, "Invalid key length");
    var ut = at.slice(0, 8), lt = at.slice(8, 16), dt = at.slice(16, 24);
    Qe === "encrypt" ? this.ciphers = [Ke.create({
      type: "encrypt",
      key: ut
    }), Ke.create({
      type: "decrypt",
      key: lt
    }), Ke.create({
      type: "encrypt",
      key: dt
    })] : this.ciphers = [Ke.create({
      type: "decrypt",
      key: dt
    }), Ke.create({
      type: "encrypt",
      key: lt
    }), Ke.create({
      type: "decrypt",
      key: ut
    })];
  }
  function Je(Qe) {
    Fe.call(this, Qe);
    var at = new Ve(this.type, this.options.key);
    this._edeState = at;
  }
  return Ze(Je, Fe), exports$1q = Je, Je.create = function(at) {
    return new Je(at);
  }, Je.prototype._update = function(at, ut, lt, dt) {
    var bt = this._edeState;
    bt.ciphers[0]._update(at, ut, lt, dt), bt.ciphers[1]._update(lt, dt, lt, dt), bt.ciphers[2]._update(lt, dt, lt, dt);
  }, Je.prototype._pad = Ke.prototype._pad, Je.prototype._unpad = Ke.prototype._unpad, exports$1q;
}
var exports$1p = {}, _dewExec$1o = !1;
function dew$1o() {
  return _dewExec$1o || (_dewExec$1o = !0, exports$1p.utils = dew$1u(), exports$1p.Cipher = dew$1s(), exports$1p.DES = dew$1r(), exports$1p.CBC = dew$1q(), exports$1p.EDE = dew$1p()), exports$1p;
}
var exports$1o = {}, _dewExec$1n = !1, _global$k = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1n() {
  if (_dewExec$1n)
    return exports$1o;
  _dewExec$1n = !0;
  var $e = dew$1G(), Ze = dew$1o(), Fe = dew$f$2(), Ke = dew$1T().Buffer, Ve = {
    "des-ede3-cbc": Ze.CBC.instantiate(Ze.EDE),
    "des-ede3": Ze.EDE,
    "des-ede-cbc": Ze.CBC.instantiate(Ze.EDE),
    "des-ede": Ze.EDE,
    "des-cbc": Ze.CBC.instantiate(Ze.DES),
    "des-ecb": Ze.DES
  };
  Ve.des = Ve["des-cbc"], Ve.des3 = Ve["des-ede3-cbc"], exports$1o = Je, Fe(Je, $e);
  function Je(Qe) {
    $e.call(this || _global$k);
    var at = Qe.mode.toLowerCase(), ut = Ve[at], lt;
    Qe.decrypt ? lt = "decrypt" : lt = "encrypt";
    var dt = Qe.key;
    Ke.isBuffer(dt) || (dt = Ke.from(dt)), (at === "des-ede" || at === "des-ede-cbc") && (dt = Ke.concat([dt, dt.slice(0, 8)]));
    var bt = Qe.iv;
    Ke.isBuffer(bt) || (bt = Ke.from(bt)), (this || _global$k)._des = ut.create({
      key: dt,
      iv: bt,
      type: lt
    });
  }
  return Je.prototype._update = function(Qe) {
    return Ke.from((this || _global$k)._des.update(Qe));
  }, Je.prototype._final = function() {
    return Ke.from((this || _global$k)._des.final());
  }, exports$1o;
}
var exports$1n = {}, _dewExec$1m = !1;
function dew$1m() {
  return _dewExec$1m || (_dewExec$1m = !0, exports$1n.encrypt = function($e, Ze) {
    return $e._cipher.encryptBlock(Ze);
  }, exports$1n.decrypt = function($e, Ze) {
    return $e._cipher.decryptBlock(Ze);
  }), exports$1n;
}
var exports$1m = {}, _dewExec$1l = !1;
function dew$1l() {
  if (_dewExec$1l)
    return exports$1m;
  _dewExec$1l = !0;
  var $e = e$1$1$1.Buffer;
  return exports$1m = function(Fe, Ke) {
    for (var Ve = Math.min(Fe.length, Ke.length), Je = new $e(Ve), Qe = 0; Qe < Ve; ++Qe)
      Je[Qe] = Fe[Qe] ^ Ke[Qe];
    return Je;
  }, exports$1m;
}
var exports$1l = {}, _dewExec$1k = !1;
function dew$1k() {
  if (_dewExec$1k)
    return exports$1l;
  _dewExec$1k = !0;
  var $e = dew$1l();
  return exports$1l.encrypt = function(Ze, Fe) {
    var Ke = $e(Fe, Ze._prev);
    return Ze._prev = Ze._cipher.encryptBlock(Ke), Ze._prev;
  }, exports$1l.decrypt = function(Ze, Fe) {
    var Ke = Ze._prev;
    Ze._prev = Fe;
    var Ve = Ze._cipher.decryptBlock(Fe);
    return $e(Ve, Ke);
  }, exports$1l;
}
var exports$1k = {}, _dewExec$1j = !1;
function dew$1j() {
  if (_dewExec$1j)
    return exports$1k;
  _dewExec$1j = !0;
  var $e = dew$1T().Buffer, Ze = dew$1l();
  function Fe(Ke, Ve, Je) {
    var Qe = Ve.length, at = Ze(Ve, Ke._cache);
    return Ke._cache = Ke._cache.slice(Qe), Ke._prev = $e.concat([Ke._prev, Je ? Ve : at]), at;
  }
  return exports$1k.encrypt = function(Ke, Ve, Je) {
    for (var Qe = $e.allocUnsafe(0), at; Ve.length; )
      if (Ke._cache.length === 0 && (Ke._cache = Ke._cipher.encryptBlock(Ke._prev), Ke._prev = $e.allocUnsafe(0)), Ke._cache.length <= Ve.length)
        at = Ke._cache.length, Qe = $e.concat([Qe, Fe(Ke, Ve.slice(0, at), Je)]), Ve = Ve.slice(at);
      else {
        Qe = $e.concat([Qe, Fe(Ke, Ve, Je)]);
        break;
      }
    return Qe;
  }, exports$1k;
}
var exports$1j = {}, _dewExec$1i = !1;
function dew$1i() {
  if (_dewExec$1i)
    return exports$1j;
  _dewExec$1i = !0;
  var $e = dew$1T().Buffer;
  function Ze(Fe, Ke, Ve) {
    var Je = Fe._cipher.encryptBlock(Fe._prev), Qe = Je[0] ^ Ke;
    return Fe._prev = $e.concat([Fe._prev.slice(1), $e.from([Ve ? Ke : Qe])]), Qe;
  }
  return exports$1j.encrypt = function(Fe, Ke, Ve) {
    for (var Je = Ke.length, Qe = $e.allocUnsafe(Je), at = -1; ++at < Je; )
      Qe[at] = Ze(Fe, Ke[at], Ve);
    return Qe;
  }, exports$1j;
}
var exports$1i = {}, _dewExec$1h = !1;
function dew$1h() {
  if (_dewExec$1h)
    return exports$1i;
  _dewExec$1h = !0;
  var $e = dew$1T().Buffer;
  function Ze(Ke, Ve, Je) {
    for (var Qe, at = -1, ut = 8, lt = 0, dt, bt; ++at < ut; )
      Qe = Ke._cipher.encryptBlock(Ke._prev), dt = Ve & 1 << 7 - at ? 128 : 0, bt = Qe[0] ^ dt, lt += (bt & 128) >> at % 8, Ke._prev = Fe(Ke._prev, Je ? dt : bt);
    return lt;
  }
  function Fe(Ke, Ve) {
    var Je = Ke.length, Qe = -1, at = $e.allocUnsafe(Ke.length);
    for (Ke = $e.concat([Ke, $e.from([Ve])]); ++Qe < Je; )
      at[Qe] = Ke[Qe] << 1 | Ke[Qe + 1] >> 7;
    return at;
  }
  return exports$1i.encrypt = function(Ke, Ve, Je) {
    for (var Qe = Ve.length, at = $e.allocUnsafe(Qe), ut = -1; ++ut < Qe; )
      at[ut] = Ze(Ke, Ve[ut], Je);
    return at;
  }, exports$1i;
}
var exports$1h = {}, _dewExec$1g = !1;
function dew$1g() {
  if (_dewExec$1g)
    return exports$1h;
  _dewExec$1g = !0;
  var $e = e$1$1$1.Buffer, Ze = dew$1l();
  function Fe(Ke) {
    return Ke._prev = Ke._cipher.encryptBlock(Ke._prev), Ke._prev;
  }
  return exports$1h.encrypt = function(Ke, Ve) {
    for (; Ke._cache.length < Ve.length; )
      Ke._cache = $e.concat([Ke._cache, Fe(Ke)]);
    var Je = Ke._cache.slice(0, Ve.length);
    return Ke._cache = Ke._cache.slice(Ve.length), Ze(Ve, Je);
  }, exports$1h;
}
var exports$1g = {}, _dewExec$1f = !1;
function dew$1f() {
  if (_dewExec$1f)
    return exports$1g;
  _dewExec$1f = !0;
  function $e(Ze) {
    for (var Fe = Ze.length, Ke; Fe--; )
      if (Ke = Ze.readUInt8(Fe), Ke === 255)
        Ze.writeUInt8(0, Fe);
      else {
        Ke++, Ze.writeUInt8(Ke, Fe);
        break;
      }
  }
  return exports$1g = $e, exports$1g;
}
var exports$1f = {}, _dewExec$1e = !1;
function dew$1e() {
  if (_dewExec$1e)
    return exports$1f;
  _dewExec$1e = !0;
  var $e = dew$1l(), Ze = dew$1T().Buffer, Fe = dew$1f();
  function Ke(Je) {
    var Qe = Je._cipher.encryptBlockRaw(Je._prev);
    return Fe(Je._prev), Qe;
  }
  var Ve = 16;
  return exports$1f.encrypt = function(Je, Qe) {
    var at = Math.ceil(Qe.length / Ve), ut = Je._cache.length;
    Je._cache = Ze.concat([Je._cache, Ze.allocUnsafe(at * Ve)]);
    for (var lt = 0; lt < at; lt++) {
      var dt = Ke(Je), bt = ut + lt * Ve;
      Je._cache.writeUInt32BE(dt[0], bt + 0), Je._cache.writeUInt32BE(dt[1], bt + 4), Je._cache.writeUInt32BE(dt[2], bt + 8), Je._cache.writeUInt32BE(dt[3], bt + 12);
    }
    var $t = Je._cache.slice(0, Qe.length);
    return Je._cache = Je._cache.slice(Qe.length), $e(Qe, $t);
  }, exports$1f;
}
var _list = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128: {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes192: {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes256: {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
}, exports$1e = {}, _dewExec$1d = !1;
function dew$1d() {
  if (_dewExec$1d)
    return exports$1e;
  _dewExec$1d = !0;
  var $e = {
    ECB: dew$1m(),
    CBC: dew$1k(),
    CFB: dew$1j(),
    CFB8: dew$1i(),
    CFB1: dew$1h(),
    OFB: dew$1g(),
    CTR: dew$1e(),
    GCM: dew$1e()
  }, Ze = _list;
  for (var Fe in Ze)
    Ze[Fe].module = $e[Ze[Fe].mode];
  return exports$1e = Ze, exports$1e;
}
var exports$1d = {}, _dewExec$1c = !1, _global$j = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1c() {
  if (_dewExec$1c)
    return exports$1d;
  _dewExec$1c = !0;
  var $e = dew$1T().Buffer;
  function Ze(at) {
    $e.isBuffer(at) || (at = $e.from(at));
    for (var ut = at.length / 4 | 0, lt = new Array(ut), dt = 0; dt < ut; dt++)
      lt[dt] = at.readUInt32BE(dt * 4);
    return lt;
  }
  function Fe(at) {
    for (var ut = 0; ut < at.length; at++)
      at[ut] = 0;
  }
  function Ke(at, ut, lt, dt, bt) {
    for (var $t = lt[0], vt = lt[1], wt = lt[2], xt = lt[3], Et = at[0] ^ ut[0], Tt = at[1] ^ ut[1], Rt = at[2] ^ ut[2], Ct = at[3] ^ ut[3], Zt, Lt, Ut, Pt, Ot = 4, Ft = 1; Ft < bt; Ft++)
      Zt = $t[Et >>> 24] ^ vt[Tt >>> 16 & 255] ^ wt[Rt >>> 8 & 255] ^ xt[Ct & 255] ^ ut[Ot++], Lt = $t[Tt >>> 24] ^ vt[Rt >>> 16 & 255] ^ wt[Ct >>> 8 & 255] ^ xt[Et & 255] ^ ut[Ot++], Ut = $t[Rt >>> 24] ^ vt[Ct >>> 16 & 255] ^ wt[Et >>> 8 & 255] ^ xt[Tt & 255] ^ ut[Ot++], Pt = $t[Ct >>> 24] ^ vt[Et >>> 16 & 255] ^ wt[Tt >>> 8 & 255] ^ xt[Rt & 255] ^ ut[Ot++], Et = Zt, Tt = Lt, Rt = Ut, Ct = Pt;
    return Zt = (dt[Et >>> 24] << 24 | dt[Tt >>> 16 & 255] << 16 | dt[Rt >>> 8 & 255] << 8 | dt[Ct & 255]) ^ ut[Ot++], Lt = (dt[Tt >>> 24] << 24 | dt[Rt >>> 16 & 255] << 16 | dt[Ct >>> 8 & 255] << 8 | dt[Et & 255]) ^ ut[Ot++], Ut = (dt[Rt >>> 24] << 24 | dt[Ct >>> 16 & 255] << 16 | dt[Et >>> 8 & 255] << 8 | dt[Tt & 255]) ^ ut[Ot++], Pt = (dt[Ct >>> 24] << 24 | dt[Et >>> 16 & 255] << 16 | dt[Tt >>> 8 & 255] << 8 | dt[Rt & 255]) ^ ut[Ot++], Zt = Zt >>> 0, Lt = Lt >>> 0, Ut = Ut >>> 0, Pt = Pt >>> 0, [Zt, Lt, Ut, Pt];
  }
  var Ve = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], Je = function() {
    for (var at = new Array(256), ut = 0; ut < 256; ut++)
      ut < 128 ? at[ut] = ut << 1 : at[ut] = ut << 1 ^ 283;
    for (var lt = [], dt = [], bt = [[], [], [], []], $t = [[], [], [], []], vt = 0, wt = 0, xt = 0; xt < 256; ++xt) {
      var Et = wt ^ wt << 1 ^ wt << 2 ^ wt << 3 ^ wt << 4;
      Et = Et >>> 8 ^ Et & 255 ^ 99, lt[vt] = Et, dt[Et] = vt;
      var Tt = at[vt], Rt = at[Tt], Ct = at[Rt], Zt = at[Et] * 257 ^ Et * 16843008;
      bt[0][vt] = Zt << 24 | Zt >>> 8, bt[1][vt] = Zt << 16 | Zt >>> 16, bt[2][vt] = Zt << 8 | Zt >>> 24, bt[3][vt] = Zt, Zt = Ct * 16843009 ^ Rt * 65537 ^ Tt * 257 ^ vt * 16843008, $t[0][Et] = Zt << 24 | Zt >>> 8, $t[1][Et] = Zt << 16 | Zt >>> 16, $t[2][Et] = Zt << 8 | Zt >>> 24, $t[3][Et] = Zt, vt === 0 ? vt = wt = 1 : (vt = Tt ^ at[at[at[Ct ^ Tt]]], wt ^= at[at[wt]]);
    }
    return {
      SBOX: lt,
      INV_SBOX: dt,
      SUB_MIX: bt,
      INV_SUB_MIX: $t
    };
  }();
  function Qe(at) {
    (this || _global$j)._key = Ze(at), this._reset();
  }
  return Qe.blockSize = 4 * 4, Qe.keySize = 256 / 8, Qe.prototype.blockSize = Qe.blockSize, Qe.prototype.keySize = Qe.keySize, Qe.prototype._reset = function() {
    for (var at = (this || _global$j)._key, ut = at.length, lt = ut + 6, dt = (lt + 1) * 4, bt = [], $t = 0; $t < ut; $t++)
      bt[$t] = at[$t];
    for ($t = ut; $t < dt; $t++) {
      var vt = bt[$t - 1];
      $t % ut === 0 ? (vt = vt << 8 | vt >>> 24, vt = Je.SBOX[vt >>> 24] << 24 | Je.SBOX[vt >>> 16 & 255] << 16 | Je.SBOX[vt >>> 8 & 255] << 8 | Je.SBOX[vt & 255], vt ^= Ve[$t / ut | 0] << 24) : ut > 6 && $t % ut === 4 && (vt = Je.SBOX[vt >>> 24] << 24 | Je.SBOX[vt >>> 16 & 255] << 16 | Je.SBOX[vt >>> 8 & 255] << 8 | Je.SBOX[vt & 255]), bt[$t] = bt[$t - ut] ^ vt;
    }
    for (var wt = [], xt = 0; xt < dt; xt++) {
      var Et = dt - xt, Tt = bt[Et - (xt % 4 ? 0 : 4)];
      xt < 4 || Et <= 4 ? wt[xt] = Tt : wt[xt] = Je.INV_SUB_MIX[0][Je.SBOX[Tt >>> 24]] ^ Je.INV_SUB_MIX[1][Je.SBOX[Tt >>> 16 & 255]] ^ Je.INV_SUB_MIX[2][Je.SBOX[Tt >>> 8 & 255]] ^ Je.INV_SUB_MIX[3][Je.SBOX[Tt & 255]];
    }
    (this || _global$j)._nRounds = lt, (this || _global$j)._keySchedule = bt, (this || _global$j)._invKeySchedule = wt;
  }, Qe.prototype.encryptBlockRaw = function(at) {
    return at = Ze(at), Ke(at, (this || _global$j)._keySchedule, Je.SUB_MIX, Je.SBOX, (this || _global$j)._nRounds);
  }, Qe.prototype.encryptBlock = function(at) {
    var ut = this.encryptBlockRaw(at), lt = $e.allocUnsafe(16);
    return lt.writeUInt32BE(ut[0], 0), lt.writeUInt32BE(ut[1], 4), lt.writeUInt32BE(ut[2], 8), lt.writeUInt32BE(ut[3], 12), lt;
  }, Qe.prototype.decryptBlock = function(at) {
    at = Ze(at);
    var ut = at[1];
    at[1] = at[3], at[3] = ut;
    var lt = Ke(at, (this || _global$j)._invKeySchedule, Je.INV_SUB_MIX, Je.INV_SBOX, (this || _global$j)._nRounds), dt = $e.allocUnsafe(16);
    return dt.writeUInt32BE(lt[0], 0), dt.writeUInt32BE(lt[3], 4), dt.writeUInt32BE(lt[2], 8), dt.writeUInt32BE(lt[1], 12), dt;
  }, Qe.prototype.scrub = function() {
    Fe((this || _global$j)._keySchedule), Fe((this || _global$j)._invKeySchedule), Fe((this || _global$j)._key);
  }, exports$1d.AES = Qe, exports$1d;
}
var exports$1c = {}, _dewExec$1b = !1, _global$i = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1b() {
  if (_dewExec$1b)
    return exports$1c;
  _dewExec$1b = !0;
  var $e = dew$1T().Buffer, Ze = $e.alloc(16, 0);
  function Fe(Je) {
    return [Je.readUInt32BE(0), Je.readUInt32BE(4), Je.readUInt32BE(8), Je.readUInt32BE(12)];
  }
  function Ke(Je) {
    var Qe = $e.allocUnsafe(16);
    return Qe.writeUInt32BE(Je[0] >>> 0, 0), Qe.writeUInt32BE(Je[1] >>> 0, 4), Qe.writeUInt32BE(Je[2] >>> 0, 8), Qe.writeUInt32BE(Je[3] >>> 0, 12), Qe;
  }
  function Ve(Je) {
    (this || _global$i).h = Je, (this || _global$i).state = $e.alloc(16, 0), (this || _global$i).cache = $e.allocUnsafe(0);
  }
  return Ve.prototype.ghash = function(Je) {
    for (var Qe = -1; ++Qe < Je.length; )
      (this || _global$i).state[Qe] ^= Je[Qe];
    this._multiply();
  }, Ve.prototype._multiply = function() {
    for (var Je = Fe((this || _global$i).h), Qe = [0, 0, 0, 0], at, ut, lt, dt = -1; ++dt < 128; ) {
      for (ut = ((this || _global$i).state[~~(dt / 8)] & 1 << 7 - dt % 8) !== 0, ut && (Qe[0] ^= Je[0], Qe[1] ^= Je[1], Qe[2] ^= Je[2], Qe[3] ^= Je[3]), lt = (Je[3] & 1) !== 0, at = 3; at > 0; at--)
        Je[at] = Je[at] >>> 1 | (Je[at - 1] & 1) << 31;
      Je[0] = Je[0] >>> 1, lt && (Je[0] = Je[0] ^ 225 << 24);
    }
    (this || _global$i).state = Ke(Qe);
  }, Ve.prototype.update = function(Je) {
    (this || _global$i).cache = $e.concat([(this || _global$i).cache, Je]);
    for (var Qe; (this || _global$i).cache.length >= 16; )
      Qe = (this || _global$i).cache.slice(0, 16), (this || _global$i).cache = (this || _global$i).cache.slice(16), this.ghash(Qe);
  }, Ve.prototype.final = function(Je, Qe) {
    return (this || _global$i).cache.length && this.ghash($e.concat([(this || _global$i).cache, Ze], 16)), this.ghash(Ke([0, Je, 0, Qe])), (this || _global$i).state;
  }, exports$1c = Ve, exports$1c;
}
var exports$1b = {}, _dewExec$1a = !1, _global$h = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1a() {
  if (_dewExec$1a)
    return exports$1b;
  _dewExec$1a = !0;
  var $e = dew$1c(), Ze = dew$1T().Buffer, Fe = dew$1G(), Ke = dew$f$2(), Ve = dew$1b(), Je = dew$1l(), Qe = dew$1f();
  function at(dt, bt) {
    var $t = 0;
    dt.length !== bt.length && $t++;
    for (var vt = Math.min(dt.length, bt.length), wt = 0; wt < vt; ++wt)
      $t += dt[wt] ^ bt[wt];
    return $t;
  }
  function ut(dt, bt, $t) {
    if (bt.length === 12)
      return dt._finID = Ze.concat([bt, Ze.from([0, 0, 0, 1])]), Ze.concat([bt, Ze.from([0, 0, 0, 2])]);
    var vt = new Ve($t), wt = bt.length, xt = wt % 16;
    vt.update(bt), xt && (xt = 16 - xt, vt.update(Ze.alloc(xt, 0))), vt.update(Ze.alloc(8, 0));
    var Et = wt * 8, Tt = Ze.alloc(8);
    Tt.writeUIntBE(Et, 0, 8), vt.update(Tt), dt._finID = vt.state;
    var Rt = Ze.from(dt._finID);
    return Qe(Rt), Rt;
  }
  function lt(dt, bt, $t, vt) {
    Fe.call(this || _global$h);
    var wt = Ze.alloc(4, 0);
    (this || _global$h)._cipher = new $e.AES(bt);
    var xt = (this || _global$h)._cipher.encryptBlock(wt);
    (this || _global$h)._ghash = new Ve(xt), $t = ut(this || _global$h, $t, xt), (this || _global$h)._prev = Ze.from($t), (this || _global$h)._cache = Ze.allocUnsafe(0), (this || _global$h)._secCache = Ze.allocUnsafe(0), (this || _global$h)._decrypt = vt, (this || _global$h)._alen = 0, (this || _global$h)._len = 0, (this || _global$h)._mode = dt, (this || _global$h)._authTag = null, (this || _global$h)._called = !1;
  }
  return Ke(lt, Fe), lt.prototype._update = function(dt) {
    if (!(this || _global$h)._called && (this || _global$h)._alen) {
      var bt = 16 - (this || _global$h)._alen % 16;
      bt < 16 && (bt = Ze.alloc(bt, 0), (this || _global$h)._ghash.update(bt));
    }
    (this || _global$h)._called = !0;
    var $t = (this || _global$h)._mode.encrypt(this || _global$h, dt);
    return (this || _global$h)._decrypt ? (this || _global$h)._ghash.update(dt) : (this || _global$h)._ghash.update($t), (this || _global$h)._len += dt.length, $t;
  }, lt.prototype._final = function() {
    if ((this || _global$h)._decrypt && !(this || _global$h)._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var dt = Je((this || _global$h)._ghash.final((this || _global$h)._alen * 8, (this || _global$h)._len * 8), (this || _global$h)._cipher.encryptBlock((this || _global$h)._finID));
    if ((this || _global$h)._decrypt && at(dt, (this || _global$h)._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    (this || _global$h)._authTag = dt, (this || _global$h)._cipher.scrub();
  }, lt.prototype.getAuthTag = function() {
    if ((this || _global$h)._decrypt || !Ze.isBuffer((this || _global$h)._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return (this || _global$h)._authTag;
  }, lt.prototype.setAuthTag = function(bt) {
    if (!(this || _global$h)._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    (this || _global$h)._authTag = bt;
  }, lt.prototype.setAAD = function(bt) {
    if ((this || _global$h)._called)
      throw new Error("Attempting to set AAD in unsupported state");
    (this || _global$h)._ghash.update(bt), (this || _global$h)._alen += bt.length;
  }, exports$1b = lt, exports$1b;
}
var exports$1a = {}, _dewExec$19 = !1, _global$g = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$19() {
  if (_dewExec$19)
    return exports$1a;
  _dewExec$19 = !0;
  var $e = dew$1c(), Ze = dew$1T().Buffer, Fe = dew$1G(), Ke = dew$f$2();
  function Ve(Je, Qe, at, ut) {
    Fe.call(this || _global$g), (this || _global$g)._cipher = new $e.AES(Qe), (this || _global$g)._prev = Ze.from(at), (this || _global$g)._cache = Ze.allocUnsafe(0), (this || _global$g)._secCache = Ze.allocUnsafe(0), (this || _global$g)._decrypt = ut, (this || _global$g)._mode = Je;
  }
  return Ke(Ve, Fe), Ve.prototype._update = function(Je) {
    return (this || _global$g)._mode.encrypt(this || _global$g, Je, (this || _global$g)._decrypt);
  }, Ve.prototype._final = function() {
    (this || _global$g)._cipher.scrub();
  }, exports$1a = Ve, exports$1a;
}
var exports$19 = {}, _dewExec$18 = !1;
function dew$18() {
  if (_dewExec$18)
    return exports$19;
  _dewExec$18 = !0;
  var $e = dew$1T().Buffer, Ze = dew$1Q();
  function Fe(Ke, Ve, Je, Qe) {
    if ($e.isBuffer(Ke) || (Ke = $e.from(Ke, "binary")), Ve && ($e.isBuffer(Ve) || (Ve = $e.from(Ve, "binary")), Ve.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var at = Je / 8, ut = $e.alloc(at), lt = $e.alloc(Qe || 0), dt = $e.alloc(0); at > 0 || Qe > 0; ) {
      var bt = new Ze();
      bt.update(dt), bt.update(Ke), Ve && bt.update(Ve), dt = bt.digest();
      var $t = 0;
      if (at > 0) {
        var vt = ut.length - at;
        $t = Math.min(at, dt.length), dt.copy(ut, vt, 0, $t), at -= $t;
      }
      if ($t < dt.length && Qe > 0) {
        var wt = lt.length - Qe, xt = Math.min(Qe, dt.length - $t);
        dt.copy(lt, wt, $t, $t + xt), Qe -= xt;
      }
    }
    return dt.fill(0), {
      key: ut,
      iv: lt
    };
  }
  return exports$19 = Fe, exports$19;
}
var exports$18 = {}, _dewExec$17 = !1, _global$f = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$17() {
  if (_dewExec$17)
    return exports$18;
  _dewExec$17 = !0;
  var $e = dew$1d(), Ze = dew$1a(), Fe = dew$1T().Buffer, Ke = dew$19(), Ve = dew$1G(), Je = dew$1c(), Qe = dew$18(), at = dew$f$2();
  function ut(vt, wt, xt) {
    Ve.call(this || _global$f), (this || _global$f)._cache = new dt(), (this || _global$f)._cipher = new Je.AES(wt), (this || _global$f)._prev = Fe.from(xt), (this || _global$f)._mode = vt, (this || _global$f)._autopadding = !0;
  }
  at(ut, Ve), ut.prototype._update = function(vt) {
    (this || _global$f)._cache.add(vt);
    for (var wt, xt, Et = []; wt = (this || _global$f)._cache.get(); )
      xt = (this || _global$f)._mode.encrypt(this || _global$f, wt), Et.push(xt);
    return Fe.concat(Et);
  };
  var lt = Fe.alloc(16, 16);
  ut.prototype._final = function() {
    var vt = (this || _global$f)._cache.flush();
    if ((this || _global$f)._autopadding)
      return vt = (this || _global$f)._mode.encrypt(this || _global$f, vt), (this || _global$f)._cipher.scrub(), vt;
    if (!vt.equals(lt))
      throw (this || _global$f)._cipher.scrub(), new Error("data not multiple of block length");
  }, ut.prototype.setAutoPadding = function(vt) {
    return (this || _global$f)._autopadding = !!vt, this || _global$f;
  };
  function dt() {
    (this || _global$f).cache = Fe.allocUnsafe(0);
  }
  dt.prototype.add = function(vt) {
    (this || _global$f).cache = Fe.concat([(this || _global$f).cache, vt]);
  }, dt.prototype.get = function() {
    if ((this || _global$f).cache.length > 15) {
      var vt = (this || _global$f).cache.slice(0, 16);
      return (this || _global$f).cache = (this || _global$f).cache.slice(16), vt;
    }
    return null;
  }, dt.prototype.flush = function() {
    for (var vt = 16 - (this || _global$f).cache.length, wt = Fe.allocUnsafe(vt), xt = -1; ++xt < vt; )
      wt.writeUInt8(vt, xt);
    return Fe.concat([(this || _global$f).cache, wt]);
  };
  function bt(vt, wt, xt) {
    var Et = $e[vt.toLowerCase()];
    if (!Et)
      throw new TypeError("invalid suite type");
    if (typeof wt == "string" && (wt = Fe.from(wt)), wt.length !== Et.key / 8)
      throw new TypeError("invalid key length " + wt.length);
    if (typeof xt == "string" && (xt = Fe.from(xt)), Et.mode !== "GCM" && xt.length !== Et.iv)
      throw new TypeError("invalid iv length " + xt.length);
    return Et.type === "stream" ? new Ke(Et.module, wt, xt) : Et.type === "auth" ? new Ze(Et.module, wt, xt) : new ut(Et.module, wt, xt);
  }
  function $t(vt, wt) {
    var xt = $e[vt.toLowerCase()];
    if (!xt)
      throw new TypeError("invalid suite type");
    var Et = Qe(wt, !1, xt.key, xt.iv);
    return bt(vt, Et.key, Et.iv);
  }
  return exports$18.createCipheriv = bt, exports$18.createCipher = $t, exports$18;
}
var exports$17 = {}, _dewExec$16 = !1, _global$e = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$16() {
  if (_dewExec$16)
    return exports$17;
  _dewExec$16 = !0;
  var $e = dew$1a(), Ze = dew$1T().Buffer, Fe = dew$1d(), Ke = dew$19(), Ve = dew$1G(), Je = dew$1c(), Qe = dew$18(), at = dew$f$2();
  function ut(vt, wt, xt) {
    Ve.call(this || _global$e), (this || _global$e)._cache = new lt(), (this || _global$e)._last = void 0, (this || _global$e)._cipher = new Je.AES(wt), (this || _global$e)._prev = Ze.from(xt), (this || _global$e)._mode = vt, (this || _global$e)._autopadding = !0;
  }
  at(ut, Ve), ut.prototype._update = function(vt) {
    (this || _global$e)._cache.add(vt);
    for (var wt, xt, Et = []; wt = (this || _global$e)._cache.get((this || _global$e)._autopadding); )
      xt = (this || _global$e)._mode.decrypt(this || _global$e, wt), Et.push(xt);
    return Ze.concat(Et);
  }, ut.prototype._final = function() {
    var vt = (this || _global$e)._cache.flush();
    if ((this || _global$e)._autopadding)
      return dt((this || _global$e)._mode.decrypt(this || _global$e, vt));
    if (vt)
      throw new Error("data not multiple of block length");
  }, ut.prototype.setAutoPadding = function(vt) {
    return (this || _global$e)._autopadding = !!vt, this || _global$e;
  };
  function lt() {
    (this || _global$e).cache = Ze.allocUnsafe(0);
  }
  lt.prototype.add = function(vt) {
    (this || _global$e).cache = Ze.concat([(this || _global$e).cache, vt]);
  }, lt.prototype.get = function(vt) {
    var wt;
    if (vt) {
      if ((this || _global$e).cache.length > 16)
        return wt = (this || _global$e).cache.slice(0, 16), (this || _global$e).cache = (this || _global$e).cache.slice(16), wt;
    } else if ((this || _global$e).cache.length >= 16)
      return wt = (this || _global$e).cache.slice(0, 16), (this || _global$e).cache = (this || _global$e).cache.slice(16), wt;
    return null;
  }, lt.prototype.flush = function() {
    if ((this || _global$e).cache.length)
      return (this || _global$e).cache;
  };
  function dt(vt) {
    var wt = vt[15];
    if (wt < 1 || wt > 16)
      throw new Error("unable to decrypt data");
    for (var xt = -1; ++xt < wt; )
      if (vt[xt + (16 - wt)] !== wt)
        throw new Error("unable to decrypt data");
    if (wt !== 16)
      return vt.slice(0, 16 - wt);
  }
  function bt(vt, wt, xt) {
    var Et = Fe[vt.toLowerCase()];
    if (!Et)
      throw new TypeError("invalid suite type");
    if (typeof xt == "string" && (xt = Ze.from(xt)), Et.mode !== "GCM" && xt.length !== Et.iv)
      throw new TypeError("invalid iv length " + xt.length);
    if (typeof wt == "string" && (wt = Ze.from(wt)), wt.length !== Et.key / 8)
      throw new TypeError("invalid key length " + wt.length);
    return Et.type === "stream" ? new Ke(Et.module, wt, xt, !0) : Et.type === "auth" ? new $e(Et.module, wt, xt, !0) : new ut(Et.module, wt, xt);
  }
  function $t(vt, wt) {
    var xt = Fe[vt.toLowerCase()];
    if (!xt)
      throw new TypeError("invalid suite type");
    var Et = Qe(wt, !1, xt.key, xt.iv);
    return bt(vt, Et.key, Et.iv);
  }
  return exports$17.createDecipher = $t, exports$17.createDecipheriv = bt, exports$17;
}
var exports$16 = {}, _dewExec$15 = !1;
function dew$15() {
  if (_dewExec$15)
    return exports$16;
  _dewExec$15 = !0;
  var $e = dew$17(), Ze = dew$16(), Fe = _list;
  function Ke() {
    return Object.keys(Fe);
  }
  return exports$16.createCipher = exports$16.Cipher = $e.createCipher, exports$16.createCipheriv = exports$16.Cipheriv = $e.createCipheriv, exports$16.createDecipher = exports$16.Decipher = Ze.createDecipher, exports$16.createDecipheriv = exports$16.Decipheriv = Ze.createDecipheriv, exports$16.listCiphers = exports$16.getCiphers = Ke, exports$16;
}
var exports$15 = {}, _dewExec$14 = !1;
function dew$14() {
  return _dewExec$14 || (_dewExec$14 = !0, exports$15["des-ecb"] = {
    key: 8,
    iv: 0
  }, exports$15["des-cbc"] = exports$15.des = {
    key: 8,
    iv: 8
  }, exports$15["des-ede3-cbc"] = exports$15.des3 = {
    key: 24,
    iv: 8
  }, exports$15["des-ede3"] = {
    key: 24,
    iv: 0
  }, exports$15["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, exports$15["des-ede"] = {
    key: 16,
    iv: 0
  }), exports$15;
}
var exports$14 = {}, _dewExec$13 = !1;
function dew$13() {
  if (_dewExec$13)
    return exports$14;
  _dewExec$13 = !0;
  var $e = dew$1n(), Ze = dew$15(), Fe = dew$1d(), Ke = dew$14(), Ve = dew$18();
  function Je(dt, bt) {
    dt = dt.toLowerCase();
    var $t, vt;
    if (Fe[dt])
      $t = Fe[dt].key, vt = Fe[dt].iv;
    else if (Ke[dt])
      $t = Ke[dt].key * 8, vt = Ke[dt].iv;
    else
      throw new TypeError("invalid suite type");
    var wt = Ve(bt, !1, $t, vt);
    return at(dt, wt.key, wt.iv);
  }
  function Qe(dt, bt) {
    dt = dt.toLowerCase();
    var $t, vt;
    if (Fe[dt])
      $t = Fe[dt].key, vt = Fe[dt].iv;
    else if (Ke[dt])
      $t = Ke[dt].key * 8, vt = Ke[dt].iv;
    else
      throw new TypeError("invalid suite type");
    var wt = Ve(bt, !1, $t, vt);
    return ut(dt, wt.key, wt.iv);
  }
  function at(dt, bt, $t) {
    if (dt = dt.toLowerCase(), Fe[dt])
      return Ze.createCipheriv(dt, bt, $t);
    if (Ke[dt])
      return new $e({
        key: bt,
        iv: $t,
        mode: dt
      });
    throw new TypeError("invalid suite type");
  }
  function ut(dt, bt, $t) {
    if (dt = dt.toLowerCase(), Fe[dt])
      return Ze.createDecipheriv(dt, bt, $t);
    if (Ke[dt])
      return new $e({
        key: bt,
        iv: $t,
        mode: dt,
        decrypt: !0
      });
    throw new TypeError("invalid suite type");
  }
  function lt() {
    return Object.keys(Ke).concat(Ze.getCiphers());
  }
  return exports$14.createCipher = exports$14.Cipher = Je, exports$14.createCipheriv = exports$14.Cipheriv = at, exports$14.createDecipher = exports$14.Decipher = Qe, exports$14.createDecipheriv = exports$14.Decipheriv = ut, exports$14.listCiphers = exports$14.getCiphers = lt, exports$14;
}
var exports$13 = {}, _dewExec$122 = !1, module$6 = {
  exports: exports$13
}, _global$d = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$122() {
  return _dewExec$122 || (_dewExec$122 = !0, function($e, Ze) {
    function Fe(gt, We) {
      if (!gt)
        throw new Error(We || "Assertion failed");
    }
    function Ke(gt, We) {
      gt.super_ = We;
      var Xe = function() {
      };
      Xe.prototype = We.prototype, gt.prototype = new Xe(), gt.prototype.constructor = gt;
    }
    function Ve(gt, We, Xe) {
      if (Ve.isBN(gt))
        return gt;
      (this || _global$d).negative = 0, (this || _global$d).words = null, (this || _global$d).length = 0, (this || _global$d).red = null, gt !== null && ((We === "le" || We === "be") && (Xe = We, We = 10), this._init(gt || 0, We || 10, Xe || "be"));
    }
    typeof $e == "object" ? $e.exports = Ve : Ze.BN = Ve, Ve.BN = Ve, Ve.wordSize = 26;
    var Je;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Je = window.Buffer : Je = e$1$1$1.Buffer;
    } catch {
    }
    Ve.isBN = function(We) {
      return We instanceof Ve ? !0 : We !== null && typeof We == "object" && We.constructor.wordSize === Ve.wordSize && Array.isArray(We.words);
    }, Ve.max = function(We, Xe) {
      return We.cmp(Xe) > 0 ? We : Xe;
    }, Ve.min = function(We, Xe) {
      return We.cmp(Xe) < 0 ? We : Xe;
    }, Ve.prototype._init = function(We, Xe, rt) {
      if (typeof We == "number")
        return this._initNumber(We, Xe, rt);
      if (typeof We == "object")
        return this._initArray(We, Xe, rt);
      Xe === "hex" && (Xe = 16), Fe(Xe === (Xe | 0) && Xe >= 2 && Xe <= 36), We = We.toString().replace(/\s+/g, "");
      var ot = 0;
      We[0] === "-" && (ot++, (this || _global$d).negative = 1), ot < We.length && (Xe === 16 ? this._parseHex(We, ot, rt) : (this._parseBase(We, Xe, ot), rt === "le" && this._initArray(this.toArray(), Xe, rt)));
    }, Ve.prototype._initNumber = function(We, Xe, rt) {
      We < 0 && ((this || _global$d).negative = 1, We = -We), We < 67108864 ? ((this || _global$d).words = [We & 67108863], (this || _global$d).length = 1) : We < 4503599627370496 ? ((this || _global$d).words = [We & 67108863, We / 67108864 & 67108863], (this || _global$d).length = 2) : (Fe(We < 9007199254740992), (this || _global$d).words = [We & 67108863, We / 67108864 & 67108863, 1], (this || _global$d).length = 3), rt === "le" && this._initArray(this.toArray(), Xe, rt);
    }, Ve.prototype._initArray = function(We, Xe, rt) {
      if (Fe(typeof We.length == "number"), We.length <= 0)
        return (this || _global$d).words = [0], (this || _global$d).length = 1, this || _global$d;
      (this || _global$d).length = Math.ceil(We.length / 3), (this || _global$d).words = new Array((this || _global$d).length);
      for (var ot = 0; ot < (this || _global$d).length; ot++)
        (this || _global$d).words[ot] = 0;
      var ft, mt, yt = 0;
      if (rt === "be")
        for (ot = We.length - 1, ft = 0; ot >= 0; ot -= 3)
          mt = We[ot] | We[ot - 1] << 8 | We[ot - 2] << 16, (this || _global$d).words[ft] |= mt << yt & 67108863, (this || _global$d).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      else if (rt === "le")
        for (ot = 0, ft = 0; ot < We.length; ot += 3)
          mt = We[ot] | We[ot + 1] << 8 | We[ot + 2] << 16, (this || _global$d).words[ft] |= mt << yt & 67108863, (this || _global$d).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      return this.strip();
    };
    function Qe(gt, We) {
      var Xe = gt.charCodeAt(We);
      return Xe >= 65 && Xe <= 70 ? Xe - 55 : Xe >= 97 && Xe <= 102 ? Xe - 87 : Xe - 48 & 15;
    }
    function at(gt, We, Xe) {
      var rt = Qe(gt, Xe);
      return Xe - 1 >= We && (rt |= Qe(gt, Xe - 1) << 4), rt;
    }
    Ve.prototype._parseHex = function(We, Xe, rt) {
      (this || _global$d).length = Math.ceil((We.length - Xe) / 6), (this || _global$d).words = new Array((this || _global$d).length);
      for (var ot = 0; ot < (this || _global$d).length; ot++)
        (this || _global$d).words[ot] = 0;
      var ft = 0, mt = 0, yt;
      if (rt === "be")
        for (ot = We.length - 1; ot >= Xe; ot -= 2)
          yt = at(We, Xe, ot) << ft, (this || _global$d).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$d).words[mt] |= yt >>> 26) : ft += 8;
      else {
        var pt = We.length - Xe;
        for (ot = pt % 2 === 0 ? Xe + 1 : Xe; ot < We.length; ot += 2)
          yt = at(We, Xe, ot) << ft, (this || _global$d).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$d).words[mt] |= yt >>> 26) : ft += 8;
      }
      this.strip();
    };
    function ut(gt, We, Xe, rt) {
      for (var ot = 0, ft = Math.min(gt.length, Xe), mt = We; mt < ft; mt++) {
        var yt = gt.charCodeAt(mt) - 48;
        ot *= rt, yt >= 49 ? ot += yt - 49 + 10 : yt >= 17 ? ot += yt - 17 + 10 : ot += yt;
      }
      return ot;
    }
    Ve.prototype._parseBase = function(We, Xe, rt) {
      (this || _global$d).words = [0], (this || _global$d).length = 1;
      for (var ot = 0, ft = 1; ft <= 67108863; ft *= Xe)
        ot++;
      ot--, ft = ft / Xe | 0;
      for (var mt = We.length - rt, yt = mt % ot, pt = Math.min(mt, mt - yt) + rt, Ge = 0, ct = rt; ct < pt; ct += ot)
        Ge = ut(We, ct, ct + ot, Xe), this.imuln(ft), (this || _global$d).words[0] + Ge < 67108864 ? (this || _global$d).words[0] += Ge : this._iaddn(Ge);
      if (yt !== 0) {
        var Mt = 1;
        for (Ge = ut(We, ct, We.length, Xe), ct = 0; ct < yt; ct++)
          Mt *= Xe;
        this.imuln(Mt), (this || _global$d).words[0] + Ge < 67108864 ? (this || _global$d).words[0] += Ge : this._iaddn(Ge);
      }
      this.strip();
    }, Ve.prototype.copy = function(We) {
      We.words = new Array((this || _global$d).length);
      for (var Xe = 0; Xe < (this || _global$d).length; Xe++)
        We.words[Xe] = (this || _global$d).words[Xe];
      We.length = (this || _global$d).length, We.negative = (this || _global$d).negative, We.red = (this || _global$d).red;
    }, Ve.prototype.clone = function() {
      var We = new Ve(null);
      return this.copy(We), We;
    }, Ve.prototype._expand = function(We) {
      for (; (this || _global$d).length < We; )
        (this || _global$d).words[(this || _global$d).length++] = 0;
      return this || _global$d;
    }, Ve.prototype.strip = function() {
      for (; (this || _global$d).length > 1 && (this || _global$d).words[(this || _global$d).length - 1] === 0; )
        (this || _global$d).length--;
      return this._normSign();
    }, Ve.prototype._normSign = function() {
      return (this || _global$d).length === 1 && (this || _global$d).words[0] === 0 && ((this || _global$d).negative = 0), this || _global$d;
    }, Ve.prototype.inspect = function() {
      return ((this || _global$d).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var lt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], dt = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], bt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    Ve.prototype.toString = function(We, Xe) {
      We = We || 10, Xe = Xe | 0 || 1;
      var rt;
      if (We === 16 || We === "hex") {
        rt = "";
        for (var ot = 0, ft = 0, mt = 0; mt < (this || _global$d).length; mt++) {
          var yt = (this || _global$d).words[mt], pt = ((yt << ot | ft) & 16777215).toString(16);
          ft = yt >>> 24 - ot & 16777215, ft !== 0 || mt !== (this || _global$d).length - 1 ? rt = lt[6 - pt.length] + pt + rt : rt = pt + rt, ot += 2, ot >= 26 && (ot -= 26, mt--);
        }
        for (ft !== 0 && (rt = ft.toString(16) + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$d).negative !== 0 && (rt = "-" + rt), rt;
      }
      if (We === (We | 0) && We >= 2 && We <= 36) {
        var Ge = dt[We], ct = bt[We];
        rt = "";
        var Mt = this.clone();
        for (Mt.negative = 0; !Mt.isZero(); ) {
          var St = Mt.modn(ct).toString(We);
          Mt = Mt.idivn(ct), Mt.isZero() ? rt = St + rt : rt = lt[Ge - St.length] + St + rt;
        }
        for (this.isZero() && (rt = "0" + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$d).negative !== 0 && (rt = "-" + rt), rt;
      }
      Fe(!1, "Base should be between 2 and 36");
    }, Ve.prototype.toNumber = function() {
      var We = (this || _global$d).words[0];
      return (this || _global$d).length === 2 ? We += (this || _global$d).words[1] * 67108864 : (this || _global$d).length === 3 && (this || _global$d).words[2] === 1 ? We += 4503599627370496 + (this || _global$d).words[1] * 67108864 : (this || _global$d).length > 2 && Fe(!1, "Number can only safely store up to 53 bits"), (this || _global$d).negative !== 0 ? -We : We;
    }, Ve.prototype.toJSON = function() {
      return this.toString(16);
    }, Ve.prototype.toBuffer = function(We, Xe) {
      return Fe(typeof Je < "u"), this.toArrayLike(Je, We, Xe);
    }, Ve.prototype.toArray = function(We, Xe) {
      return this.toArrayLike(Array, We, Xe);
    }, Ve.prototype.toArrayLike = function(We, Xe, rt) {
      var ot = this.byteLength(), ft = rt || Math.max(1, ot);
      Fe(ot <= ft, "byte array longer than desired length"), Fe(ft > 0, "Requested array length <= 0"), this.strip();
      var mt = Xe === "le", yt = new We(ft), pt, Ge, ct = this.clone();
      if (mt) {
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[Ge] = pt;
        for (; Ge < ft; Ge++)
          yt[Ge] = 0;
      } else {
        for (Ge = 0; Ge < ft - ot; Ge++)
          yt[Ge] = 0;
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[ft - Ge - 1] = pt;
      }
      return yt;
    }, Math.clz32 ? Ve.prototype._countBits = function(We) {
      return 32 - Math.clz32(We);
    } : Ve.prototype._countBits = function(We) {
      var Xe = We, rt = 0;
      return Xe >= 4096 && (rt += 13, Xe >>>= 13), Xe >= 64 && (rt += 7, Xe >>>= 7), Xe >= 8 && (rt += 4, Xe >>>= 4), Xe >= 2 && (rt += 2, Xe >>>= 2), rt + Xe;
    }, Ve.prototype._zeroBits = function(We) {
      if (We === 0)
        return 26;
      var Xe = We, rt = 0;
      return Xe & 8191 || (rt += 13, Xe >>>= 13), Xe & 127 || (rt += 7, Xe >>>= 7), Xe & 15 || (rt += 4, Xe >>>= 4), Xe & 3 || (rt += 2, Xe >>>= 2), Xe & 1 || rt++, rt;
    }, Ve.prototype.bitLength = function() {
      var We = (this || _global$d).words[(this || _global$d).length - 1], Xe = this._countBits(We);
      return ((this || _global$d).length - 1) * 26 + Xe;
    };
    function $t(gt) {
      for (var We = new Array(gt.bitLength()), Xe = 0; Xe < We.length; Xe++) {
        var rt = Xe / 26 | 0, ot = Xe % 26;
        We[Xe] = (gt.words[rt] & 1 << ot) >>> ot;
      }
      return We;
    }
    Ve.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var We = 0, Xe = 0; Xe < (this || _global$d).length; Xe++) {
        var rt = this._zeroBits((this || _global$d).words[Xe]);
        if (We += rt, rt !== 26)
          break;
      }
      return We;
    }, Ve.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Ve.prototype.toTwos = function(We) {
      return (this || _global$d).negative !== 0 ? this.abs().inotn(We).iaddn(1) : this.clone();
    }, Ve.prototype.fromTwos = function(We) {
      return this.testn(We - 1) ? this.notn(We).iaddn(1).ineg() : this.clone();
    }, Ve.prototype.isNeg = function() {
      return (this || _global$d).negative !== 0;
    }, Ve.prototype.neg = function() {
      return this.clone().ineg();
    }, Ve.prototype.ineg = function() {
      return this.isZero() || ((this || _global$d).negative ^= 1), this || _global$d;
    }, Ve.prototype.iuor = function(We) {
      for (; (this || _global$d).length < We.length; )
        (this || _global$d).words[(this || _global$d).length++] = 0;
      for (var Xe = 0; Xe < We.length; Xe++)
        (this || _global$d).words[Xe] = (this || _global$d).words[Xe] | We.words[Xe];
      return this.strip();
    }, Ve.prototype.ior = function(We) {
      return Fe(((this || _global$d).negative | We.negative) === 0), this.iuor(We);
    }, Ve.prototype.or = function(We) {
      return (this || _global$d).length > We.length ? this.clone().ior(We) : We.clone().ior(this || _global$d);
    }, Ve.prototype.uor = function(We) {
      return (this || _global$d).length > We.length ? this.clone().iuor(We) : We.clone().iuor(this || _global$d);
    }, Ve.prototype.iuand = function(We) {
      var Xe;
      (this || _global$d).length > We.length ? Xe = We : Xe = this || _global$d;
      for (var rt = 0; rt < Xe.length; rt++)
        (this || _global$d).words[rt] = (this || _global$d).words[rt] & We.words[rt];
      return (this || _global$d).length = Xe.length, this.strip();
    }, Ve.prototype.iand = function(We) {
      return Fe(((this || _global$d).negative | We.negative) === 0), this.iuand(We);
    }, Ve.prototype.and = function(We) {
      return (this || _global$d).length > We.length ? this.clone().iand(We) : We.clone().iand(this || _global$d);
    }, Ve.prototype.uand = function(We) {
      return (this || _global$d).length > We.length ? this.clone().iuand(We) : We.clone().iuand(this || _global$d);
    }, Ve.prototype.iuxor = function(We) {
      var Xe, rt;
      (this || _global$d).length > We.length ? (Xe = this || _global$d, rt = We) : (Xe = We, rt = this || _global$d);
      for (var ot = 0; ot < rt.length; ot++)
        (this || _global$d).words[ot] = Xe.words[ot] ^ rt.words[ot];
      if ((this || _global$d) !== Xe)
        for (; ot < Xe.length; ot++)
          (this || _global$d).words[ot] = Xe.words[ot];
      return (this || _global$d).length = Xe.length, this.strip();
    }, Ve.prototype.ixor = function(We) {
      return Fe(((this || _global$d).negative | We.negative) === 0), this.iuxor(We);
    }, Ve.prototype.xor = function(We) {
      return (this || _global$d).length > We.length ? this.clone().ixor(We) : We.clone().ixor(this || _global$d);
    }, Ve.prototype.uxor = function(We) {
      return (this || _global$d).length > We.length ? this.clone().iuxor(We) : We.clone().iuxor(this || _global$d);
    }, Ve.prototype.inotn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = Math.ceil(We / 26) | 0, rt = We % 26;
      this._expand(Xe), rt > 0 && Xe--;
      for (var ot = 0; ot < Xe; ot++)
        (this || _global$d).words[ot] = ~(this || _global$d).words[ot] & 67108863;
      return rt > 0 && ((this || _global$d).words[ot] = ~(this || _global$d).words[ot] & 67108863 >> 26 - rt), this.strip();
    }, Ve.prototype.notn = function(We) {
      return this.clone().inotn(We);
    }, Ve.prototype.setn = function(We, Xe) {
      Fe(typeof We == "number" && We >= 0);
      var rt = We / 26 | 0, ot = We % 26;
      return this._expand(rt + 1), Xe ? (this || _global$d).words[rt] = (this || _global$d).words[rt] | 1 << ot : (this || _global$d).words[rt] = (this || _global$d).words[rt] & ~(1 << ot), this.strip();
    }, Ve.prototype.iadd = function(We) {
      var Xe;
      if ((this || _global$d).negative !== 0 && We.negative === 0)
        return (this || _global$d).negative = 0, Xe = this.isub(We), (this || _global$d).negative ^= 1, this._normSign();
      if ((this || _global$d).negative === 0 && We.negative !== 0)
        return We.negative = 0, Xe = this.isub(We), We.negative = 1, Xe._normSign();
      var rt, ot;
      (this || _global$d).length > We.length ? (rt = this || _global$d, ot = We) : (rt = We, ot = this || _global$d);
      for (var ft = 0, mt = 0; mt < ot.length; mt++)
        Xe = (rt.words[mt] | 0) + (ot.words[mt] | 0) + ft, (this || _global$d).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      for (; ft !== 0 && mt < rt.length; mt++)
        Xe = (rt.words[mt] | 0) + ft, (this || _global$d).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      if ((this || _global$d).length = rt.length, ft !== 0)
        (this || _global$d).words[(this || _global$d).length] = ft, (this || _global$d).length++;
      else if (rt !== (this || _global$d))
        for (; mt < rt.length; mt++)
          (this || _global$d).words[mt] = rt.words[mt];
      return this || _global$d;
    }, Ve.prototype.add = function(We) {
      var Xe;
      return We.negative !== 0 && (this || _global$d).negative === 0 ? (We.negative = 0, Xe = this.sub(We), We.negative ^= 1, Xe) : We.negative === 0 && (this || _global$d).negative !== 0 ? ((this || _global$d).negative = 0, Xe = We.sub(this || _global$d), (this || _global$d).negative = 1, Xe) : (this || _global$d).length > We.length ? this.clone().iadd(We) : We.clone().iadd(this || _global$d);
    }, Ve.prototype.isub = function(We) {
      if (We.negative !== 0) {
        We.negative = 0;
        var Xe = this.iadd(We);
        return We.negative = 1, Xe._normSign();
      } else if ((this || _global$d).negative !== 0)
        return (this || _global$d).negative = 0, this.iadd(We), (this || _global$d).negative = 1, this._normSign();
      var rt = this.cmp(We);
      if (rt === 0)
        return (this || _global$d).negative = 0, (this || _global$d).length = 1, (this || _global$d).words[0] = 0, this || _global$d;
      var ot, ft;
      rt > 0 ? (ot = this || _global$d, ft = We) : (ot = We, ft = this || _global$d);
      for (var mt = 0, yt = 0; yt < ft.length; yt++)
        Xe = (ot.words[yt] | 0) - (ft.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$d).words[yt] = Xe & 67108863;
      for (; mt !== 0 && yt < ot.length; yt++)
        Xe = (ot.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$d).words[yt] = Xe & 67108863;
      if (mt === 0 && yt < ot.length && ot !== (this || _global$d))
        for (; yt < ot.length; yt++)
          (this || _global$d).words[yt] = ot.words[yt];
      return (this || _global$d).length = Math.max((this || _global$d).length, yt), ot !== (this || _global$d) && ((this || _global$d).negative = 1), this.strip();
    }, Ve.prototype.sub = function(We) {
      return this.clone().isub(We);
    };
    function vt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative;
      var rt = gt.length + We.length | 0;
      Xe.length = rt, rt = rt - 1 | 0;
      var ot = gt.words[0] | 0, ft = We.words[0] | 0, mt = ot * ft, yt = mt & 67108863, pt = mt / 67108864 | 0;
      Xe.words[0] = yt;
      for (var Ge = 1; Ge < rt; Ge++) {
        for (var ct = pt >>> 26, Mt = pt & 67108863, St = Math.min(Ge, We.length - 1), At = Math.max(0, Ge - gt.length + 1); At <= St; At++) {
          var Nt = Ge - At | 0;
          ot = gt.words[Nt] | 0, ft = We.words[At] | 0, mt = ot * ft + Mt, ct += mt / 67108864 | 0, Mt = mt & 67108863;
        }
        Xe.words[Ge] = Mt | 0, pt = ct | 0;
      }
      return pt !== 0 ? Xe.words[Ge] = pt | 0 : Xe.length--, Xe.strip();
    }
    var wt = function(We, Xe, rt) {
      var ot = We.words, ft = Xe.words, mt = rt.words, yt = 0, pt, Ge, ct, Mt = ot[0] | 0, St = Mt & 8191, At = Mt >>> 13, Nt = ot[1] | 0, qt = Nt & 8191, Qt = Nt >>> 13, Xt = ot[2] | 0, zt = Xt & 8191, Kt = Xt >>> 13, ur = ot[3] | 0, er = ur & 8191, Dt = ur >>> 13, Ht = ot[4] | 0, Gt = Ht & 8191, rr = Ht >>> 13, sr = ot[5] | 0, Jt = sr & 8191, ir = sr >>> 13, Br = ot[6] | 0, or = Br & 8191, lr = Br >>> 13, Nr = ot[7] | 0, dr = Nr & 8191, gr = Nr >>> 13, Zr = ot[8] | 0, Bt = Zr & 8191, kt = Zr >>> 13, It = ot[9] | 0, jt = It & 8191, Vt = It >>> 13, ar = ft[0] | 0, Yt = ar & 8191, hr = ar >>> 13, zr = ft[1] | 0, cr = zr & 8191, _r = zr >>> 13, Lr = ft[2] | 0, br = Lr & 8191, kr = Lr >>> 13, Xr = ft[3] | 0, yr = Xr & 8191, Ir = Xr >>> 13, Yr = ft[4] | 0, wr = Yr & 8191, Cr = Yr >>> 13, Hr = ft[5] | 0, $r = Hr & 8191, Ar = Hr >>> 13, Wr = ft[6] | 0, mr = Wr & 8191, Tr = Wr >>> 13, Kr = ft[7] | 0, vr = Kr & 8191, Rr = Kr >>> 13, Jr = ft[8] | 0, xr = Jr & 8191, tr = Jr >>> 13, Dr = ft[9] | 0, fr = Dr & 8191, Mr = Dr >>> 13;
      rt.negative = We.negative ^ Xe.negative, rt.length = 19, pt = Math.imul(St, Yt), Ge = Math.imul(St, hr), Ge = Ge + Math.imul(At, Yt) | 0, ct = Math.imul(At, hr);
      var Fr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, pt = Math.imul(qt, Yt), Ge = Math.imul(qt, hr), Ge = Ge + Math.imul(Qt, Yt) | 0, ct = Math.imul(Qt, hr), pt = pt + Math.imul(St, cr) | 0, Ge = Ge + Math.imul(St, _r) | 0, Ge = Ge + Math.imul(At, cr) | 0, ct = ct + Math.imul(At, _r) | 0;
      var qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, pt = Math.imul(zt, Yt), Ge = Math.imul(zt, hr), Ge = Ge + Math.imul(Kt, Yt) | 0, ct = Math.imul(Kt, hr), pt = pt + Math.imul(qt, cr) | 0, Ge = Ge + Math.imul(qt, _r) | 0, Ge = Ge + Math.imul(Qt, cr) | 0, ct = ct + Math.imul(Qt, _r) | 0, pt = pt + Math.imul(St, br) | 0, Ge = Ge + Math.imul(St, kr) | 0, Ge = Ge + Math.imul(At, br) | 0, ct = ct + Math.imul(At, kr) | 0;
      var tn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, pt = Math.imul(er, Yt), Ge = Math.imul(er, hr), Ge = Ge + Math.imul(Dt, Yt) | 0, ct = Math.imul(Dt, hr), pt = pt + Math.imul(zt, cr) | 0, Ge = Ge + Math.imul(zt, _r) | 0, Ge = Ge + Math.imul(Kt, cr) | 0, ct = ct + Math.imul(Kt, _r) | 0, pt = pt + Math.imul(qt, br) | 0, Ge = Ge + Math.imul(qt, kr) | 0, Ge = Ge + Math.imul(Qt, br) | 0, ct = ct + Math.imul(Qt, kr) | 0, pt = pt + Math.imul(St, yr) | 0, Ge = Ge + Math.imul(St, Ir) | 0, Ge = Ge + Math.imul(At, yr) | 0, ct = ct + Math.imul(At, Ir) | 0;
      var Qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, pt = Math.imul(Gt, Yt), Ge = Math.imul(Gt, hr), Ge = Ge + Math.imul(rr, Yt) | 0, ct = Math.imul(rr, hr), pt = pt + Math.imul(er, cr) | 0, Ge = Ge + Math.imul(er, _r) | 0, Ge = Ge + Math.imul(Dt, cr) | 0, ct = ct + Math.imul(Dt, _r) | 0, pt = pt + Math.imul(zt, br) | 0, Ge = Ge + Math.imul(zt, kr) | 0, Ge = Ge + Math.imul(Kt, br) | 0, ct = ct + Math.imul(Kt, kr) | 0, pt = pt + Math.imul(qt, yr) | 0, Ge = Ge + Math.imul(qt, Ir) | 0, Ge = Ge + Math.imul(Qt, yr) | 0, ct = ct + Math.imul(Qt, Ir) | 0, pt = pt + Math.imul(St, wr) | 0, Ge = Ge + Math.imul(St, Cr) | 0, Ge = Ge + Math.imul(At, wr) | 0, ct = ct + Math.imul(At, Cr) | 0;
      var nn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, pt = Math.imul(Jt, Yt), Ge = Math.imul(Jt, hr), Ge = Ge + Math.imul(ir, Yt) | 0, ct = Math.imul(ir, hr), pt = pt + Math.imul(Gt, cr) | 0, Ge = Ge + Math.imul(Gt, _r) | 0, Ge = Ge + Math.imul(rr, cr) | 0, ct = ct + Math.imul(rr, _r) | 0, pt = pt + Math.imul(er, br) | 0, Ge = Ge + Math.imul(er, kr) | 0, Ge = Ge + Math.imul(Dt, br) | 0, ct = ct + Math.imul(Dt, kr) | 0, pt = pt + Math.imul(zt, yr) | 0, Ge = Ge + Math.imul(zt, Ir) | 0, Ge = Ge + Math.imul(Kt, yr) | 0, ct = ct + Math.imul(Kt, Ir) | 0, pt = pt + Math.imul(qt, wr) | 0, Ge = Ge + Math.imul(qt, Cr) | 0, Ge = Ge + Math.imul(Qt, wr) | 0, ct = ct + Math.imul(Qt, Cr) | 0, pt = pt + Math.imul(St, $r) | 0, Ge = Ge + Math.imul(St, Ar) | 0, Ge = Ge + Math.imul(At, $r) | 0, ct = ct + Math.imul(At, Ar) | 0;
      var Er = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, pt = Math.imul(or, Yt), Ge = Math.imul(or, hr), Ge = Ge + Math.imul(lr, Yt) | 0, ct = Math.imul(lr, hr), pt = pt + Math.imul(Jt, cr) | 0, Ge = Ge + Math.imul(Jt, _r) | 0, Ge = Ge + Math.imul(ir, cr) | 0, ct = ct + Math.imul(ir, _r) | 0, pt = pt + Math.imul(Gt, br) | 0, Ge = Ge + Math.imul(Gt, kr) | 0, Ge = Ge + Math.imul(rr, br) | 0, ct = ct + Math.imul(rr, kr) | 0, pt = pt + Math.imul(er, yr) | 0, Ge = Ge + Math.imul(er, Ir) | 0, Ge = Ge + Math.imul(Dt, yr) | 0, ct = ct + Math.imul(Dt, Ir) | 0, pt = pt + Math.imul(zt, wr) | 0, Ge = Ge + Math.imul(zt, Cr) | 0, Ge = Ge + Math.imul(Kt, wr) | 0, ct = ct + Math.imul(Kt, Cr) | 0, pt = pt + Math.imul(qt, $r) | 0, Ge = Ge + Math.imul(qt, Ar) | 0, Ge = Ge + Math.imul(Qt, $r) | 0, ct = ct + Math.imul(Qt, Ar) | 0, pt = pt + Math.imul(St, mr) | 0, Ge = Ge + Math.imul(St, Tr) | 0, Ge = Ge + Math.imul(At, mr) | 0, ct = ct + Math.imul(At, Tr) | 0;
      var Wt = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, pt = Math.imul(dr, Yt), Ge = Math.imul(dr, hr), Ge = Ge + Math.imul(gr, Yt) | 0, ct = Math.imul(gr, hr), pt = pt + Math.imul(or, cr) | 0, Ge = Ge + Math.imul(or, _r) | 0, Ge = Ge + Math.imul(lr, cr) | 0, ct = ct + Math.imul(lr, _r) | 0, pt = pt + Math.imul(Jt, br) | 0, Ge = Ge + Math.imul(Jt, kr) | 0, Ge = Ge + Math.imul(ir, br) | 0, ct = ct + Math.imul(ir, kr) | 0, pt = pt + Math.imul(Gt, yr) | 0, Ge = Ge + Math.imul(Gt, Ir) | 0, Ge = Ge + Math.imul(rr, yr) | 0, ct = ct + Math.imul(rr, Ir) | 0, pt = pt + Math.imul(er, wr) | 0, Ge = Ge + Math.imul(er, Cr) | 0, Ge = Ge + Math.imul(Dt, wr) | 0, ct = ct + Math.imul(Dt, Cr) | 0, pt = pt + Math.imul(zt, $r) | 0, Ge = Ge + Math.imul(zt, Ar) | 0, Ge = Ge + Math.imul(Kt, $r) | 0, ct = ct + Math.imul(Kt, Ar) | 0, pt = pt + Math.imul(qt, mr) | 0, Ge = Ge + Math.imul(qt, Tr) | 0, Ge = Ge + Math.imul(Qt, mr) | 0, ct = ct + Math.imul(Qt, Tr) | 0, pt = pt + Math.imul(St, vr) | 0, Ge = Ge + Math.imul(St, Rr) | 0, Ge = Ge + Math.imul(At, vr) | 0, ct = ct + Math.imul(At, Rr) | 0;
      var nr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, pt = Math.imul(Bt, Yt), Ge = Math.imul(Bt, hr), Ge = Ge + Math.imul(kt, Yt) | 0, ct = Math.imul(kt, hr), pt = pt + Math.imul(dr, cr) | 0, Ge = Ge + Math.imul(dr, _r) | 0, Ge = Ge + Math.imul(gr, cr) | 0, ct = ct + Math.imul(gr, _r) | 0, pt = pt + Math.imul(or, br) | 0, Ge = Ge + Math.imul(or, kr) | 0, Ge = Ge + Math.imul(lr, br) | 0, ct = ct + Math.imul(lr, kr) | 0, pt = pt + Math.imul(Jt, yr) | 0, Ge = Ge + Math.imul(Jt, Ir) | 0, Ge = Ge + Math.imul(ir, yr) | 0, ct = ct + Math.imul(ir, Ir) | 0, pt = pt + Math.imul(Gt, wr) | 0, Ge = Ge + Math.imul(Gt, Cr) | 0, Ge = Ge + Math.imul(rr, wr) | 0, ct = ct + Math.imul(rr, Cr) | 0, pt = pt + Math.imul(er, $r) | 0, Ge = Ge + Math.imul(er, Ar) | 0, Ge = Ge + Math.imul(Dt, $r) | 0, ct = ct + Math.imul(Dt, Ar) | 0, pt = pt + Math.imul(zt, mr) | 0, Ge = Ge + Math.imul(zt, Tr) | 0, Ge = Ge + Math.imul(Kt, mr) | 0, ct = ct + Math.imul(Kt, Tr) | 0, pt = pt + Math.imul(qt, vr) | 0, Ge = Ge + Math.imul(qt, Rr) | 0, Ge = Ge + Math.imul(Qt, vr) | 0, ct = ct + Math.imul(Qt, Rr) | 0, pt = pt + Math.imul(St, xr) | 0, Ge = Ge + Math.imul(St, tr) | 0, Ge = Ge + Math.imul(At, xr) | 0, ct = ct + Math.imul(At, tr) | 0;
      var pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, pt = Math.imul(jt, Yt), Ge = Math.imul(jt, hr), Ge = Ge + Math.imul(Vt, Yt) | 0, ct = Math.imul(Vt, hr), pt = pt + Math.imul(Bt, cr) | 0, Ge = Ge + Math.imul(Bt, _r) | 0, Ge = Ge + Math.imul(kt, cr) | 0, ct = ct + Math.imul(kt, _r) | 0, pt = pt + Math.imul(dr, br) | 0, Ge = Ge + Math.imul(dr, kr) | 0, Ge = Ge + Math.imul(gr, br) | 0, ct = ct + Math.imul(gr, kr) | 0, pt = pt + Math.imul(or, yr) | 0, Ge = Ge + Math.imul(or, Ir) | 0, Ge = Ge + Math.imul(lr, yr) | 0, ct = ct + Math.imul(lr, Ir) | 0, pt = pt + Math.imul(Jt, wr) | 0, Ge = Ge + Math.imul(Jt, Cr) | 0, Ge = Ge + Math.imul(ir, wr) | 0, ct = ct + Math.imul(ir, Cr) | 0, pt = pt + Math.imul(Gt, $r) | 0, Ge = Ge + Math.imul(Gt, Ar) | 0, Ge = Ge + Math.imul(rr, $r) | 0, ct = ct + Math.imul(rr, Ar) | 0, pt = pt + Math.imul(er, mr) | 0, Ge = Ge + Math.imul(er, Tr) | 0, Ge = Ge + Math.imul(Dt, mr) | 0, ct = ct + Math.imul(Dt, Tr) | 0, pt = pt + Math.imul(zt, vr) | 0, Ge = Ge + Math.imul(zt, Rr) | 0, Ge = Ge + Math.imul(Kt, vr) | 0, ct = ct + Math.imul(Kt, Rr) | 0, pt = pt + Math.imul(qt, xr) | 0, Ge = Ge + Math.imul(qt, tr) | 0, Ge = Ge + Math.imul(Qt, xr) | 0, ct = ct + Math.imul(Qt, tr) | 0, pt = pt + Math.imul(St, fr) | 0, Ge = Ge + Math.imul(St, Mr) | 0, Ge = Ge + Math.imul(At, fr) | 0, ct = ct + Math.imul(At, Mr) | 0;
      var Pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, pt = Math.imul(jt, cr), Ge = Math.imul(jt, _r), Ge = Ge + Math.imul(Vt, cr) | 0, ct = Math.imul(Vt, _r), pt = pt + Math.imul(Bt, br) | 0, Ge = Ge + Math.imul(Bt, kr) | 0, Ge = Ge + Math.imul(kt, br) | 0, ct = ct + Math.imul(kt, kr) | 0, pt = pt + Math.imul(dr, yr) | 0, Ge = Ge + Math.imul(dr, Ir) | 0, Ge = Ge + Math.imul(gr, yr) | 0, ct = ct + Math.imul(gr, Ir) | 0, pt = pt + Math.imul(or, wr) | 0, Ge = Ge + Math.imul(or, Cr) | 0, Ge = Ge + Math.imul(lr, wr) | 0, ct = ct + Math.imul(lr, Cr) | 0, pt = pt + Math.imul(Jt, $r) | 0, Ge = Ge + Math.imul(Jt, Ar) | 0, Ge = Ge + Math.imul(ir, $r) | 0, ct = ct + Math.imul(ir, Ar) | 0, pt = pt + Math.imul(Gt, mr) | 0, Ge = Ge + Math.imul(Gt, Tr) | 0, Ge = Ge + Math.imul(rr, mr) | 0, ct = ct + Math.imul(rr, Tr) | 0, pt = pt + Math.imul(er, vr) | 0, Ge = Ge + Math.imul(er, Rr) | 0, Ge = Ge + Math.imul(Dt, vr) | 0, ct = ct + Math.imul(Dt, Rr) | 0, pt = pt + Math.imul(zt, xr) | 0, Ge = Ge + Math.imul(zt, tr) | 0, Ge = Ge + Math.imul(Kt, xr) | 0, ct = ct + Math.imul(Kt, tr) | 0, pt = pt + Math.imul(qt, fr) | 0, Ge = Ge + Math.imul(qt, Mr) | 0, Ge = Ge + Math.imul(Qt, fr) | 0, ct = ct + Math.imul(Qt, Mr) | 0;
      var Sr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, pt = Math.imul(jt, br), Ge = Math.imul(jt, kr), Ge = Ge + Math.imul(Vt, br) | 0, ct = Math.imul(Vt, kr), pt = pt + Math.imul(Bt, yr) | 0, Ge = Ge + Math.imul(Bt, Ir) | 0, Ge = Ge + Math.imul(kt, yr) | 0, ct = ct + Math.imul(kt, Ir) | 0, pt = pt + Math.imul(dr, wr) | 0, Ge = Ge + Math.imul(dr, Cr) | 0, Ge = Ge + Math.imul(gr, wr) | 0, ct = ct + Math.imul(gr, Cr) | 0, pt = pt + Math.imul(or, $r) | 0, Ge = Ge + Math.imul(or, Ar) | 0, Ge = Ge + Math.imul(lr, $r) | 0, ct = ct + Math.imul(lr, Ar) | 0, pt = pt + Math.imul(Jt, mr) | 0, Ge = Ge + Math.imul(Jt, Tr) | 0, Ge = Ge + Math.imul(ir, mr) | 0, ct = ct + Math.imul(ir, Tr) | 0, pt = pt + Math.imul(Gt, vr) | 0, Ge = Ge + Math.imul(Gt, Rr) | 0, Ge = Ge + Math.imul(rr, vr) | 0, ct = ct + Math.imul(rr, Rr) | 0, pt = pt + Math.imul(er, xr) | 0, Ge = Ge + Math.imul(er, tr) | 0, Ge = Ge + Math.imul(Dt, xr) | 0, ct = ct + Math.imul(Dt, tr) | 0, pt = pt + Math.imul(zt, fr) | 0, Ge = Ge + Math.imul(zt, Mr) | 0, Ge = Ge + Math.imul(Kt, fr) | 0, ct = ct + Math.imul(Kt, Mr) | 0;
      var Ur = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, pt = Math.imul(jt, yr), Ge = Math.imul(jt, Ir), Ge = Ge + Math.imul(Vt, yr) | 0, ct = Math.imul(Vt, Ir), pt = pt + Math.imul(Bt, wr) | 0, Ge = Ge + Math.imul(Bt, Cr) | 0, Ge = Ge + Math.imul(kt, wr) | 0, ct = ct + Math.imul(kt, Cr) | 0, pt = pt + Math.imul(dr, $r) | 0, Ge = Ge + Math.imul(dr, Ar) | 0, Ge = Ge + Math.imul(gr, $r) | 0, ct = ct + Math.imul(gr, Ar) | 0, pt = pt + Math.imul(or, mr) | 0, Ge = Ge + Math.imul(or, Tr) | 0, Ge = Ge + Math.imul(lr, mr) | 0, ct = ct + Math.imul(lr, Tr) | 0, pt = pt + Math.imul(Jt, vr) | 0, Ge = Ge + Math.imul(Jt, Rr) | 0, Ge = Ge + Math.imul(ir, vr) | 0, ct = ct + Math.imul(ir, Rr) | 0, pt = pt + Math.imul(Gt, xr) | 0, Ge = Ge + Math.imul(Gt, tr) | 0, Ge = Ge + Math.imul(rr, xr) | 0, ct = ct + Math.imul(rr, tr) | 0, pt = pt + Math.imul(er, fr) | 0, Ge = Ge + Math.imul(er, Mr) | 0, Ge = Ge + Math.imul(Dt, fr) | 0, ct = ct + Math.imul(Dt, Mr) | 0;
      var jr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, pt = Math.imul(jt, wr), Ge = Math.imul(jt, Cr), Ge = Ge + Math.imul(Vt, wr) | 0, ct = Math.imul(Vt, Cr), pt = pt + Math.imul(Bt, $r) | 0, Ge = Ge + Math.imul(Bt, Ar) | 0, Ge = Ge + Math.imul(kt, $r) | 0, ct = ct + Math.imul(kt, Ar) | 0, pt = pt + Math.imul(dr, mr) | 0, Ge = Ge + Math.imul(dr, Tr) | 0, Ge = Ge + Math.imul(gr, mr) | 0, ct = ct + Math.imul(gr, Tr) | 0, pt = pt + Math.imul(or, vr) | 0, Ge = Ge + Math.imul(or, Rr) | 0, Ge = Ge + Math.imul(lr, vr) | 0, ct = ct + Math.imul(lr, Rr) | 0, pt = pt + Math.imul(Jt, xr) | 0, Ge = Ge + Math.imul(Jt, tr) | 0, Ge = Ge + Math.imul(ir, xr) | 0, ct = ct + Math.imul(ir, tr) | 0, pt = pt + Math.imul(Gt, fr) | 0, Ge = Ge + Math.imul(Gt, Mr) | 0, Ge = Ge + Math.imul(rr, fr) | 0, ct = ct + Math.imul(rr, Mr) | 0;
      var Gr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, pt = Math.imul(jt, $r), Ge = Math.imul(jt, Ar), Ge = Ge + Math.imul(Vt, $r) | 0, ct = Math.imul(Vt, Ar), pt = pt + Math.imul(Bt, mr) | 0, Ge = Ge + Math.imul(Bt, Tr) | 0, Ge = Ge + Math.imul(kt, mr) | 0, ct = ct + Math.imul(kt, Tr) | 0, pt = pt + Math.imul(dr, vr) | 0, Ge = Ge + Math.imul(dr, Rr) | 0, Ge = Ge + Math.imul(gr, vr) | 0, ct = ct + Math.imul(gr, Rr) | 0, pt = pt + Math.imul(or, xr) | 0, Ge = Ge + Math.imul(or, tr) | 0, Ge = Ge + Math.imul(lr, xr) | 0, ct = ct + Math.imul(lr, tr) | 0, pt = pt + Math.imul(Jt, fr) | 0, Ge = Ge + Math.imul(Jt, Mr) | 0, Ge = Ge + Math.imul(ir, fr) | 0, ct = ct + Math.imul(ir, Mr) | 0;
      var Vr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, pt = Math.imul(jt, mr), Ge = Math.imul(jt, Tr), Ge = Ge + Math.imul(Vt, mr) | 0, ct = Math.imul(Vt, Tr), pt = pt + Math.imul(Bt, vr) | 0, Ge = Ge + Math.imul(Bt, Rr) | 0, Ge = Ge + Math.imul(kt, vr) | 0, ct = ct + Math.imul(kt, Rr) | 0, pt = pt + Math.imul(dr, xr) | 0, Ge = Ge + Math.imul(dr, tr) | 0, Ge = Ge + Math.imul(gr, xr) | 0, ct = ct + Math.imul(gr, tr) | 0, pt = pt + Math.imul(or, fr) | 0, Ge = Ge + Math.imul(or, Mr) | 0, Ge = Ge + Math.imul(lr, fr) | 0, ct = ct + Math.imul(lr, Mr) | 0;
      var rn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, pt = Math.imul(jt, vr), Ge = Math.imul(jt, Rr), Ge = Ge + Math.imul(Vt, vr) | 0, ct = Math.imul(Vt, Rr), pt = pt + Math.imul(Bt, xr) | 0, Ge = Ge + Math.imul(Bt, tr) | 0, Ge = Ge + Math.imul(kt, xr) | 0, ct = ct + Math.imul(kt, tr) | 0, pt = pt + Math.imul(dr, fr) | 0, Ge = Ge + Math.imul(dr, Mr) | 0, Ge = Ge + Math.imul(gr, fr) | 0, ct = ct + Math.imul(gr, Mr) | 0;
      var an = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, pt = Math.imul(jt, xr), Ge = Math.imul(jt, tr), Ge = Ge + Math.imul(Vt, xr) | 0, ct = Math.imul(Vt, tr), pt = pt + Math.imul(Bt, fr) | 0, Ge = Ge + Math.imul(Bt, Mr) | 0, Ge = Ge + Math.imul(kt, fr) | 0, ct = ct + Math.imul(kt, Mr) | 0;
      var ln = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, pt = Math.imul(jt, fr), Ge = Math.imul(jt, Mr), Ge = Ge + Math.imul(Vt, fr) | 0, ct = Math.imul(Vt, Mr);
      var sn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      return yt = (ct + (Ge >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, mt[0] = Fr, mt[1] = qr, mt[2] = tn, mt[3] = Qr, mt[4] = nn, mt[5] = Er, mt[6] = Wt, mt[7] = nr, mt[8] = pr, mt[9] = Pr, mt[10] = Sr, mt[11] = Ur, mt[12] = jr, mt[13] = Gr, mt[14] = Vr, mt[15] = rn, mt[16] = an, mt[17] = ln, mt[18] = sn, yt !== 0 && (mt[19] = yt, rt.length++), rt;
    };
    Math.imul || (wt = vt);
    function xt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative, Xe.length = gt.length + We.length;
      for (var rt = 0, ot = 0, ft = 0; ft < Xe.length - 1; ft++) {
        var mt = ot;
        ot = 0;
        for (var yt = rt & 67108863, pt = Math.min(ft, We.length - 1), Ge = Math.max(0, ft - gt.length + 1); Ge <= pt; Ge++) {
          var ct = ft - Ge, Mt = gt.words[ct] | 0, St = We.words[Ge] | 0, At = Mt * St, Nt = At & 67108863;
          mt = mt + (At / 67108864 | 0) | 0, Nt = Nt + yt | 0, yt = Nt & 67108863, mt = mt + (Nt >>> 26) | 0, ot += mt >>> 26, mt &= 67108863;
        }
        Xe.words[ft] = yt, rt = mt, mt = ot;
      }
      return rt !== 0 ? Xe.words[ft] = rt : Xe.length--, Xe.strip();
    }
    function Et(gt, We, Xe) {
      var rt = new Tt();
      return rt.mulp(gt, We, Xe);
    }
    Ve.prototype.mulTo = function(We, Xe) {
      var rt, ot = (this || _global$d).length + We.length;
      return (this || _global$d).length === 10 && We.length === 10 ? rt = wt(this || _global$d, We, Xe) : ot < 63 ? rt = vt(this || _global$d, We, Xe) : ot < 1024 ? rt = xt(this || _global$d, We, Xe) : rt = Et(this || _global$d, We, Xe), rt;
    };
    function Tt(gt, We) {
      (this || _global$d).x = gt, (this || _global$d).y = We;
    }
    Tt.prototype.makeRBT = function(We) {
      for (var Xe = new Array(We), rt = Ve.prototype._countBits(We) - 1, ot = 0; ot < We; ot++)
        Xe[ot] = this.revBin(ot, rt, We);
      return Xe;
    }, Tt.prototype.revBin = function(We, Xe, rt) {
      if (We === 0 || We === rt - 1)
        return We;
      for (var ot = 0, ft = 0; ft < Xe; ft++)
        ot |= (We & 1) << Xe - ft - 1, We >>= 1;
      return ot;
    }, Tt.prototype.permute = function(We, Xe, rt, ot, ft, mt) {
      for (var yt = 0; yt < mt; yt++)
        ot[yt] = Xe[We[yt]], ft[yt] = rt[We[yt]];
    }, Tt.prototype.transform = function(We, Xe, rt, ot, ft, mt) {
      this.permute(mt, We, Xe, rt, ot, ft);
      for (var yt = 1; yt < ft; yt <<= 1)
        for (var pt = yt << 1, Ge = Math.cos(2 * Math.PI / pt), ct = Math.sin(2 * Math.PI / pt), Mt = 0; Mt < ft; Mt += pt)
          for (var St = Ge, At = ct, Nt = 0; Nt < yt; Nt++) {
            var qt = rt[Mt + Nt], Qt = ot[Mt + Nt], Xt = rt[Mt + Nt + yt], zt = ot[Mt + Nt + yt], Kt = St * Xt - At * zt;
            zt = St * zt + At * Xt, Xt = Kt, rt[Mt + Nt] = qt + Xt, ot[Mt + Nt] = Qt + zt, rt[Mt + Nt + yt] = qt - Xt, ot[Mt + Nt + yt] = Qt - zt, Nt !== pt && (Kt = Ge * St - ct * At, At = Ge * At + ct * St, St = Kt);
          }
    }, Tt.prototype.guessLen13b = function(We, Xe) {
      var rt = Math.max(Xe, We) | 1, ot = rt & 1, ft = 0;
      for (rt = rt / 2 | 0; rt; rt = rt >>> 1)
        ft++;
      return 1 << ft + 1 + ot;
    }, Tt.prototype.conjugate = function(We, Xe, rt) {
      if (!(rt <= 1))
        for (var ot = 0; ot < rt / 2; ot++) {
          var ft = We[ot];
          We[ot] = We[rt - ot - 1], We[rt - ot - 1] = ft, ft = Xe[ot], Xe[ot] = -Xe[rt - ot - 1], Xe[rt - ot - 1] = -ft;
        }
    }, Tt.prototype.normalize13b = function(We, Xe) {
      for (var rt = 0, ot = 0; ot < Xe / 2; ot++) {
        var ft = Math.round(We[2 * ot + 1] / Xe) * 8192 + Math.round(We[2 * ot] / Xe) + rt;
        We[ot] = ft & 67108863, ft < 67108864 ? rt = 0 : rt = ft / 67108864 | 0;
      }
      return We;
    }, Tt.prototype.convert13b = function(We, Xe, rt, ot) {
      for (var ft = 0, mt = 0; mt < Xe; mt++)
        ft = ft + (We[mt] | 0), rt[2 * mt] = ft & 8191, ft = ft >>> 13, rt[2 * mt + 1] = ft & 8191, ft = ft >>> 13;
      for (mt = 2 * Xe; mt < ot; ++mt)
        rt[mt] = 0;
      Fe(ft === 0), Fe((ft & -8192) === 0);
    }, Tt.prototype.stub = function(We) {
      for (var Xe = new Array(We), rt = 0; rt < We; rt++)
        Xe[rt] = 0;
      return Xe;
    }, Tt.prototype.mulp = function(We, Xe, rt) {
      var ot = 2 * this.guessLen13b(We.length, Xe.length), ft = this.makeRBT(ot), mt = this.stub(ot), yt = new Array(ot), pt = new Array(ot), Ge = new Array(ot), ct = new Array(ot), Mt = new Array(ot), St = new Array(ot), At = rt.words;
      At.length = ot, this.convert13b(We.words, We.length, yt, ot), this.convert13b(Xe.words, Xe.length, ct, ot), this.transform(yt, mt, pt, Ge, ot, ft), this.transform(ct, mt, Mt, St, ot, ft);
      for (var Nt = 0; Nt < ot; Nt++) {
        var qt = pt[Nt] * Mt[Nt] - Ge[Nt] * St[Nt];
        Ge[Nt] = pt[Nt] * St[Nt] + Ge[Nt] * Mt[Nt], pt[Nt] = qt;
      }
      return this.conjugate(pt, Ge, ot), this.transform(pt, Ge, At, mt, ot, ft), this.conjugate(At, mt, ot), this.normalize13b(At, ot), rt.negative = We.negative ^ Xe.negative, rt.length = We.length + Xe.length, rt.strip();
    }, Ve.prototype.mul = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$d).length + We.length), this.mulTo(We, Xe);
    }, Ve.prototype.mulf = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$d).length + We.length), Et(this || _global$d, We, Xe);
    }, Ve.prototype.imul = function(We) {
      return this.clone().mulTo(We, this || _global$d);
    }, Ve.prototype.imuln = function(We) {
      Fe(typeof We == "number"), Fe(We < 67108864);
      for (var Xe = 0, rt = 0; rt < (this || _global$d).length; rt++) {
        var ot = ((this || _global$d).words[rt] | 0) * We, ft = (ot & 67108863) + (Xe & 67108863);
        Xe >>= 26, Xe += ot / 67108864 | 0, Xe += ft >>> 26, (this || _global$d).words[rt] = ft & 67108863;
      }
      return Xe !== 0 && ((this || _global$d).words[rt] = Xe, (this || _global$d).length++), this || _global$d;
    }, Ve.prototype.muln = function(We) {
      return this.clone().imuln(We);
    }, Ve.prototype.sqr = function() {
      return this.mul(this || _global$d);
    }, Ve.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Ve.prototype.pow = function(We) {
      var Xe = $t(We);
      if (Xe.length === 0)
        return new Ve(1);
      for (var rt = this || _global$d, ot = 0; ot < Xe.length && Xe[ot] === 0; ot++, rt = rt.sqr())
        ;
      if (++ot < Xe.length)
        for (var ft = rt.sqr(); ot < Xe.length; ot++, ft = ft.sqr())
          Xe[ot] !== 0 && (rt = rt.mul(ft));
      return rt;
    }, Ve.prototype.iushln = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 67108863 >>> 26 - Xe << 26 - Xe, ft;
      if (Xe !== 0) {
        var mt = 0;
        for (ft = 0; ft < (this || _global$d).length; ft++) {
          var yt = (this || _global$d).words[ft] & ot, pt = ((this || _global$d).words[ft] | 0) - yt << Xe;
          (this || _global$d).words[ft] = pt | mt, mt = yt >>> 26 - Xe;
        }
        mt && ((this || _global$d).words[ft] = mt, (this || _global$d).length++);
      }
      if (rt !== 0) {
        for (ft = (this || _global$d).length - 1; ft >= 0; ft--)
          (this || _global$d).words[ft + rt] = (this || _global$d).words[ft];
        for (ft = 0; ft < rt; ft++)
          (this || _global$d).words[ft] = 0;
        (this || _global$d).length += rt;
      }
      return this.strip();
    }, Ve.prototype.ishln = function(We) {
      return Fe((this || _global$d).negative === 0), this.iushln(We);
    }, Ve.prototype.iushrn = function(We, Xe, rt) {
      Fe(typeof We == "number" && We >= 0);
      var ot;
      Xe ? ot = (Xe - Xe % 26) / 26 : ot = 0;
      var ft = We % 26, mt = Math.min((We - ft) / 26, (this || _global$d).length), yt = 67108863 ^ 67108863 >>> ft << ft, pt = rt;
      if (ot -= mt, ot = Math.max(0, ot), pt) {
        for (var Ge = 0; Ge < mt; Ge++)
          pt.words[Ge] = (this || _global$d).words[Ge];
        pt.length = mt;
      }
      if (mt !== 0)
        if ((this || _global$d).length > mt)
          for ((this || _global$d).length -= mt, Ge = 0; Ge < (this || _global$d).length; Ge++)
            (this || _global$d).words[Ge] = (this || _global$d).words[Ge + mt];
        else
          (this || _global$d).words[0] = 0, (this || _global$d).length = 1;
      var ct = 0;
      for (Ge = (this || _global$d).length - 1; Ge >= 0 && (ct !== 0 || Ge >= ot); Ge--) {
        var Mt = (this || _global$d).words[Ge] | 0;
        (this || _global$d).words[Ge] = ct << 26 - ft | Mt >>> ft, ct = Mt & yt;
      }
      return pt && ct !== 0 && (pt.words[pt.length++] = ct), (this || _global$d).length === 0 && ((this || _global$d).words[0] = 0, (this || _global$d).length = 1), this.strip();
    }, Ve.prototype.ishrn = function(We, Xe, rt) {
      return Fe((this || _global$d).negative === 0), this.iushrn(We, Xe, rt);
    }, Ve.prototype.shln = function(We) {
      return this.clone().ishln(We);
    }, Ve.prototype.ushln = function(We) {
      return this.clone().iushln(We);
    }, Ve.prototype.shrn = function(We) {
      return this.clone().ishrn(We);
    }, Ve.prototype.ushrn = function(We) {
      return this.clone().iushrn(We);
    }, Ve.prototype.testn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$d).length <= rt)
        return !1;
      var ft = (this || _global$d).words[rt];
      return !!(ft & ot);
    }, Ve.prototype.imaskn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26;
      if (Fe((this || _global$d).negative === 0, "imaskn works only with positive numbers"), (this || _global$d).length <= rt)
        return this || _global$d;
      if (Xe !== 0 && rt++, (this || _global$d).length = Math.min(rt, (this || _global$d).length), Xe !== 0) {
        var ot = 67108863 ^ 67108863 >>> Xe << Xe;
        (this || _global$d).words[(this || _global$d).length - 1] &= ot;
      }
      return this.strip();
    }, Ve.prototype.maskn = function(We) {
      return this.clone().imaskn(We);
    }, Ve.prototype.iaddn = function(We) {
      return Fe(typeof We == "number"), Fe(We < 67108864), We < 0 ? this.isubn(-We) : (this || _global$d).negative !== 0 ? (this || _global$d).length === 1 && ((this || _global$d).words[0] | 0) < We ? ((this || _global$d).words[0] = We - ((this || _global$d).words[0] | 0), (this || _global$d).negative = 0, this || _global$d) : ((this || _global$d).negative = 0, this.isubn(We), (this || _global$d).negative = 1, this || _global$d) : this._iaddn(We);
    }, Ve.prototype._iaddn = function(We) {
      (this || _global$d).words[0] += We;
      for (var Xe = 0; Xe < (this || _global$d).length && (this || _global$d).words[Xe] >= 67108864; Xe++)
        (this || _global$d).words[Xe] -= 67108864, Xe === (this || _global$d).length - 1 ? (this || _global$d).words[Xe + 1] = 1 : (this || _global$d).words[Xe + 1]++;
      return (this || _global$d).length = Math.max((this || _global$d).length, Xe + 1), this || _global$d;
    }, Ve.prototype.isubn = function(We) {
      if (Fe(typeof We == "number"), Fe(We < 67108864), We < 0)
        return this.iaddn(-We);
      if ((this || _global$d).negative !== 0)
        return (this || _global$d).negative = 0, this.iaddn(We), (this || _global$d).negative = 1, this || _global$d;
      if ((this || _global$d).words[0] -= We, (this || _global$d).length === 1 && (this || _global$d).words[0] < 0)
        (this || _global$d).words[0] = -(this || _global$d).words[0], (this || _global$d).negative = 1;
      else
        for (var Xe = 0; Xe < (this || _global$d).length && (this || _global$d).words[Xe] < 0; Xe++)
          (this || _global$d).words[Xe] += 67108864, (this || _global$d).words[Xe + 1] -= 1;
      return this.strip();
    }, Ve.prototype.addn = function(We) {
      return this.clone().iaddn(We);
    }, Ve.prototype.subn = function(We) {
      return this.clone().isubn(We);
    }, Ve.prototype.iabs = function() {
      return (this || _global$d).negative = 0, this || _global$d;
    }, Ve.prototype.abs = function() {
      return this.clone().iabs();
    }, Ve.prototype._ishlnsubmul = function(We, Xe, rt) {
      var ot = We.length + rt, ft;
      this._expand(ot);
      var mt, yt = 0;
      for (ft = 0; ft < We.length; ft++) {
        mt = ((this || _global$d).words[ft + rt] | 0) + yt;
        var pt = (We.words[ft] | 0) * Xe;
        mt -= pt & 67108863, yt = (mt >> 26) - (pt / 67108864 | 0), (this || _global$d).words[ft + rt] = mt & 67108863;
      }
      for (; ft < (this || _global$d).length - rt; ft++)
        mt = ((this || _global$d).words[ft + rt] | 0) + yt, yt = mt >> 26, (this || _global$d).words[ft + rt] = mt & 67108863;
      if (yt === 0)
        return this.strip();
      for (Fe(yt === -1), yt = 0, ft = 0; ft < (this || _global$d).length; ft++)
        mt = -((this || _global$d).words[ft] | 0) + yt, yt = mt >> 26, (this || _global$d).words[ft] = mt & 67108863;
      return (this || _global$d).negative = 1, this.strip();
    }, Ve.prototype._wordDiv = function(We, Xe) {
      var rt = (this || _global$d).length - We.length, ot = this.clone(), ft = We, mt = ft.words[ft.length - 1] | 0, yt = this._countBits(mt);
      rt = 26 - yt, rt !== 0 && (ft = ft.ushln(rt), ot.iushln(rt), mt = ft.words[ft.length - 1] | 0);
      var pt = ot.length - ft.length, Ge;
      if (Xe !== "mod") {
        Ge = new Ve(null), Ge.length = pt + 1, Ge.words = new Array(Ge.length);
        for (var ct = 0; ct < Ge.length; ct++)
          Ge.words[ct] = 0;
      }
      var Mt = ot.clone()._ishlnsubmul(ft, 1, pt);
      Mt.negative === 0 && (ot = Mt, Ge && (Ge.words[pt] = 1));
      for (var St = pt - 1; St >= 0; St--) {
        var At = (ot.words[ft.length + St] | 0) * 67108864 + (ot.words[ft.length + St - 1] | 0);
        for (At = Math.min(At / mt | 0, 67108863), ot._ishlnsubmul(ft, At, St); ot.negative !== 0; )
          At--, ot.negative = 0, ot._ishlnsubmul(ft, 1, St), ot.isZero() || (ot.negative ^= 1);
        Ge && (Ge.words[St] = At);
      }
      return Ge && Ge.strip(), ot.strip(), Xe !== "div" && rt !== 0 && ot.iushrn(rt), {
        div: Ge || null,
        mod: ot
      };
    }, Ve.prototype.divmod = function(We, Xe, rt) {
      if (Fe(!We.isZero()), this.isZero())
        return {
          div: new Ve(0),
          mod: new Ve(0)
        };
      var ot, ft, mt;
      return (this || _global$d).negative !== 0 && We.negative === 0 ? (mt = this.neg().divmod(We, Xe), Xe !== "mod" && (ot = mt.div.neg()), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.iadd(We)), {
        div: ot,
        mod: ft
      }) : (this || _global$d).negative === 0 && We.negative !== 0 ? (mt = this.divmod(We.neg(), Xe), Xe !== "mod" && (ot = mt.div.neg()), {
        div: ot,
        mod: mt.mod
      }) : (this || _global$d).negative & We.negative ? (mt = this.neg().divmod(We.neg(), Xe), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.isub(We)), {
        div: mt.div,
        mod: ft
      }) : We.length > (this || _global$d).length || this.cmp(We) < 0 ? {
        div: new Ve(0),
        mod: this || _global$d
      } : We.length === 1 ? Xe === "div" ? {
        div: this.divn(We.words[0]),
        mod: null
      } : Xe === "mod" ? {
        div: null,
        mod: new Ve(this.modn(We.words[0]))
      } : {
        div: this.divn(We.words[0]),
        mod: new Ve(this.modn(We.words[0]))
      } : this._wordDiv(We, Xe);
    }, Ve.prototype.div = function(We) {
      return this.divmod(We, "div", !1).div;
    }, Ve.prototype.mod = function(We) {
      return this.divmod(We, "mod", !1).mod;
    }, Ve.prototype.umod = function(We) {
      return this.divmod(We, "mod", !0).mod;
    }, Ve.prototype.divRound = function(We) {
      var Xe = this.divmod(We);
      if (Xe.mod.isZero())
        return Xe.div;
      var rt = Xe.div.negative !== 0 ? Xe.mod.isub(We) : Xe.mod, ot = We.ushrn(1), ft = We.andln(1), mt = rt.cmp(ot);
      return mt < 0 || ft === 1 && mt === 0 ? Xe.div : Xe.div.negative !== 0 ? Xe.div.isubn(1) : Xe.div.iaddn(1);
    }, Ve.prototype.modn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = (1 << 26) % We, rt = 0, ot = (this || _global$d).length - 1; ot >= 0; ot--)
        rt = (Xe * rt + ((this || _global$d).words[ot] | 0)) % We;
      return rt;
    }, Ve.prototype.idivn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = 0, rt = (this || _global$d).length - 1; rt >= 0; rt--) {
        var ot = ((this || _global$d).words[rt] | 0) + Xe * 67108864;
        (this || _global$d).words[rt] = ot / We | 0, Xe = ot % We;
      }
      return this.strip();
    }, Ve.prototype.divn = function(We) {
      return this.clone().idivn(We);
    }, Ve.prototype.egcd = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$d, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = new Ve(0), yt = new Ve(1), pt = 0; Xe.isEven() && rt.isEven(); )
        Xe.iushrn(1), rt.iushrn(1), ++pt;
      for (var Ge = rt.clone(), ct = Xe.clone(); !Xe.isZero(); ) {
        for (var Mt = 0, St = 1; !(Xe.words[0] & St) && Mt < 26; ++Mt, St <<= 1)
          ;
        if (Mt > 0)
          for (Xe.iushrn(Mt); Mt-- > 0; )
            (ot.isOdd() || ft.isOdd()) && (ot.iadd(Ge), ft.isub(ct)), ot.iushrn(1), ft.iushrn(1);
        for (var At = 0, Nt = 1; !(rt.words[0] & Nt) && At < 26; ++At, Nt <<= 1)
          ;
        if (At > 0)
          for (rt.iushrn(At); At-- > 0; )
            (mt.isOdd() || yt.isOdd()) && (mt.iadd(Ge), yt.isub(ct)), mt.iushrn(1), yt.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(mt), ft.isub(yt)) : (rt.isub(Xe), mt.isub(ot), yt.isub(ft));
      }
      return {
        a: mt,
        b: yt,
        gcd: rt.iushln(pt)
      };
    }, Ve.prototype._invmp = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$d, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = rt.clone(); Xe.cmpn(1) > 0 && rt.cmpn(1) > 0; ) {
        for (var yt = 0, pt = 1; !(Xe.words[0] & pt) && yt < 26; ++yt, pt <<= 1)
          ;
        if (yt > 0)
          for (Xe.iushrn(yt); yt-- > 0; )
            ot.isOdd() && ot.iadd(mt), ot.iushrn(1);
        for (var Ge = 0, ct = 1; !(rt.words[0] & ct) && Ge < 26; ++Ge, ct <<= 1)
          ;
        if (Ge > 0)
          for (rt.iushrn(Ge); Ge-- > 0; )
            ft.isOdd() && ft.iadd(mt), ft.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(ft)) : (rt.isub(Xe), ft.isub(ot));
      }
      var Mt;
      return Xe.cmpn(1) === 0 ? Mt = ot : Mt = ft, Mt.cmpn(0) < 0 && Mt.iadd(We), Mt;
    }, Ve.prototype.gcd = function(We) {
      if (this.isZero())
        return We.abs();
      if (We.isZero())
        return this.abs();
      var Xe = this.clone(), rt = We.clone();
      Xe.negative = 0, rt.negative = 0;
      for (var ot = 0; Xe.isEven() && rt.isEven(); ot++)
        Xe.iushrn(1), rt.iushrn(1);
      do {
        for (; Xe.isEven(); )
          Xe.iushrn(1);
        for (; rt.isEven(); )
          rt.iushrn(1);
        var ft = Xe.cmp(rt);
        if (ft < 0) {
          var mt = Xe;
          Xe = rt, rt = mt;
        } else if (ft === 0 || rt.cmpn(1) === 0)
          break;
        Xe.isub(rt);
      } while (!0);
      return rt.iushln(ot);
    }, Ve.prototype.invm = function(We) {
      return this.egcd(We).a.umod(We);
    }, Ve.prototype.isEven = function() {
      return ((this || _global$d).words[0] & 1) === 0;
    }, Ve.prototype.isOdd = function() {
      return ((this || _global$d).words[0] & 1) === 1;
    }, Ve.prototype.andln = function(We) {
      return (this || _global$d).words[0] & We;
    }, Ve.prototype.bincn = function(We) {
      Fe(typeof We == "number");
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$d).length <= rt)
        return this._expand(rt + 1), (this || _global$d).words[rt] |= ot, this || _global$d;
      for (var ft = ot, mt = rt; ft !== 0 && mt < (this || _global$d).length; mt++) {
        var yt = (this || _global$d).words[mt] | 0;
        yt += ft, ft = yt >>> 26, yt &= 67108863, (this || _global$d).words[mt] = yt;
      }
      return ft !== 0 && ((this || _global$d).words[mt] = ft, (this || _global$d).length++), this || _global$d;
    }, Ve.prototype.isZero = function() {
      return (this || _global$d).length === 1 && (this || _global$d).words[0] === 0;
    }, Ve.prototype.cmpn = function(We) {
      var Xe = We < 0;
      if ((this || _global$d).negative !== 0 && !Xe)
        return -1;
      if ((this || _global$d).negative === 0 && Xe)
        return 1;
      this.strip();
      var rt;
      if ((this || _global$d).length > 1)
        rt = 1;
      else {
        Xe && (We = -We), Fe(We <= 67108863, "Number is too big");
        var ot = (this || _global$d).words[0] | 0;
        rt = ot === We ? 0 : ot < We ? -1 : 1;
      }
      return (this || _global$d).negative !== 0 ? -rt | 0 : rt;
    }, Ve.prototype.cmp = function(We) {
      if ((this || _global$d).negative !== 0 && We.negative === 0)
        return -1;
      if ((this || _global$d).negative === 0 && We.negative !== 0)
        return 1;
      var Xe = this.ucmp(We);
      return (this || _global$d).negative !== 0 ? -Xe | 0 : Xe;
    }, Ve.prototype.ucmp = function(We) {
      if ((this || _global$d).length > We.length)
        return 1;
      if ((this || _global$d).length < We.length)
        return -1;
      for (var Xe = 0, rt = (this || _global$d).length - 1; rt >= 0; rt--) {
        var ot = (this || _global$d).words[rt] | 0, ft = We.words[rt] | 0;
        if (ot !== ft) {
          ot < ft ? Xe = -1 : ot > ft && (Xe = 1);
          break;
        }
      }
      return Xe;
    }, Ve.prototype.gtn = function(We) {
      return this.cmpn(We) === 1;
    }, Ve.prototype.gt = function(We) {
      return this.cmp(We) === 1;
    }, Ve.prototype.gten = function(We) {
      return this.cmpn(We) >= 0;
    }, Ve.prototype.gte = function(We) {
      return this.cmp(We) >= 0;
    }, Ve.prototype.ltn = function(We) {
      return this.cmpn(We) === -1;
    }, Ve.prototype.lt = function(We) {
      return this.cmp(We) === -1;
    }, Ve.prototype.lten = function(We) {
      return this.cmpn(We) <= 0;
    }, Ve.prototype.lte = function(We) {
      return this.cmp(We) <= 0;
    }, Ve.prototype.eqn = function(We) {
      return this.cmpn(We) === 0;
    }, Ve.prototype.eq = function(We) {
      return this.cmp(We) === 0;
    }, Ve.red = function(We) {
      return new Ot(We);
    }, Ve.prototype.toRed = function(We) {
      return Fe(!(this || _global$d).red, "Already a number in reduction context"), Fe((this || _global$d).negative === 0, "red works only with positives"), We.convertTo(this || _global$d)._forceRed(We);
    }, Ve.prototype.fromRed = function() {
      return Fe((this || _global$d).red, "fromRed works only with numbers in reduction context"), (this || _global$d).red.convertFrom(this || _global$d);
    }, Ve.prototype._forceRed = function(We) {
      return (this || _global$d).red = We, this || _global$d;
    }, Ve.prototype.forceRed = function(We) {
      return Fe(!(this || _global$d).red, "Already a number in reduction context"), this._forceRed(We);
    }, Ve.prototype.redAdd = function(We) {
      return Fe((this || _global$d).red, "redAdd works only with red numbers"), (this || _global$d).red.add(this || _global$d, We);
    }, Ve.prototype.redIAdd = function(We) {
      return Fe((this || _global$d).red, "redIAdd works only with red numbers"), (this || _global$d).red.iadd(this || _global$d, We);
    }, Ve.prototype.redSub = function(We) {
      return Fe((this || _global$d).red, "redSub works only with red numbers"), (this || _global$d).red.sub(this || _global$d, We);
    }, Ve.prototype.redISub = function(We) {
      return Fe((this || _global$d).red, "redISub works only with red numbers"), (this || _global$d).red.isub(this || _global$d, We);
    }, Ve.prototype.redShl = function(We) {
      return Fe((this || _global$d).red, "redShl works only with red numbers"), (this || _global$d).red.shl(this || _global$d, We);
    }, Ve.prototype.redMul = function(We) {
      return Fe((this || _global$d).red, "redMul works only with red numbers"), (this || _global$d).red._verify2(this || _global$d, We), (this || _global$d).red.mul(this || _global$d, We);
    }, Ve.prototype.redIMul = function(We) {
      return Fe((this || _global$d).red, "redMul works only with red numbers"), (this || _global$d).red._verify2(this || _global$d, We), (this || _global$d).red.imul(this || _global$d, We);
    }, Ve.prototype.redSqr = function() {
      return Fe((this || _global$d).red, "redSqr works only with red numbers"), (this || _global$d).red._verify1(this || _global$d), (this || _global$d).red.sqr(this || _global$d);
    }, Ve.prototype.redISqr = function() {
      return Fe((this || _global$d).red, "redISqr works only with red numbers"), (this || _global$d).red._verify1(this || _global$d), (this || _global$d).red.isqr(this || _global$d);
    }, Ve.prototype.redSqrt = function() {
      return Fe((this || _global$d).red, "redSqrt works only with red numbers"), (this || _global$d).red._verify1(this || _global$d), (this || _global$d).red.sqrt(this || _global$d);
    }, Ve.prototype.redInvm = function() {
      return Fe((this || _global$d).red, "redInvm works only with red numbers"), (this || _global$d).red._verify1(this || _global$d), (this || _global$d).red.invm(this || _global$d);
    }, Ve.prototype.redNeg = function() {
      return Fe((this || _global$d).red, "redNeg works only with red numbers"), (this || _global$d).red._verify1(this || _global$d), (this || _global$d).red.neg(this || _global$d);
    }, Ve.prototype.redPow = function(We) {
      return Fe((this || _global$d).red && !We.red, "redPow(normalNum)"), (this || _global$d).red._verify1(this || _global$d), (this || _global$d).red.pow(this || _global$d, We);
    };
    var Rt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ct(gt, We) {
      (this || _global$d).name = gt, (this || _global$d).p = new Ve(We, 16), (this || _global$d).n = (this || _global$d).p.bitLength(), (this || _global$d).k = new Ve(1).iushln((this || _global$d).n).isub((this || _global$d).p), (this || _global$d).tmp = this._tmp();
    }
    Ct.prototype._tmp = function() {
      var We = new Ve(null);
      return We.words = new Array(Math.ceil((this || _global$d).n / 13)), We;
    }, Ct.prototype.ireduce = function(We) {
      var Xe = We, rt;
      do
        this.split(Xe, (this || _global$d).tmp), Xe = this.imulK(Xe), Xe = Xe.iadd((this || _global$d).tmp), rt = Xe.bitLength();
      while (rt > (this || _global$d).n);
      var ot = rt < (this || _global$d).n ? -1 : Xe.ucmp((this || _global$d).p);
      return ot === 0 ? (Xe.words[0] = 0, Xe.length = 1) : ot > 0 ? Xe.isub((this || _global$d).p) : Xe.strip !== void 0 ? Xe.strip() : Xe._strip(), Xe;
    }, Ct.prototype.split = function(We, Xe) {
      We.iushrn((this || _global$d).n, 0, Xe);
    }, Ct.prototype.imulK = function(We) {
      return We.imul((this || _global$d).k);
    };
    function Zt() {
      Ct.call(this || _global$d, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    Ke(Zt, Ct), Zt.prototype.split = function(We, Xe) {
      for (var rt = 4194303, ot = Math.min(We.length, 9), ft = 0; ft < ot; ft++)
        Xe.words[ft] = We.words[ft];
      if (Xe.length = ot, We.length <= 9) {
        We.words[0] = 0, We.length = 1;
        return;
      }
      var mt = We.words[9];
      for (Xe.words[Xe.length++] = mt & rt, ft = 10; ft < We.length; ft++) {
        var yt = We.words[ft] | 0;
        We.words[ft - 10] = (yt & rt) << 4 | mt >>> 22, mt = yt;
      }
      mt >>>= 22, We.words[ft - 10] = mt, mt === 0 && We.length > 10 ? We.length -= 10 : We.length -= 9;
    }, Zt.prototype.imulK = function(We) {
      We.words[We.length] = 0, We.words[We.length + 1] = 0, We.length += 2;
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = We.words[rt] | 0;
        Xe += ot * 977, We.words[rt] = Xe & 67108863, Xe = ot * 64 + (Xe / 67108864 | 0);
      }
      return We.words[We.length - 1] === 0 && (We.length--, We.words[We.length - 1] === 0 && We.length--), We;
    };
    function Lt() {
      Ct.call(this || _global$d, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    Ke(Lt, Ct);
    function Ut() {
      Ct.call(this || _global$d, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    Ke(Ut, Ct);
    function Pt() {
      Ct.call(this || _global$d, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    Ke(Pt, Ct), Pt.prototype.imulK = function(We) {
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = (We.words[rt] | 0) * 19 + Xe, ft = ot & 67108863;
        ot >>>= 26, We.words[rt] = ft, Xe = ot;
      }
      return Xe !== 0 && (We.words[We.length++] = Xe), We;
    }, Ve._prime = function(We) {
      if (Rt[We])
        return Rt[We];
      var Xe;
      if (We === "k256")
        Xe = new Zt();
      else if (We === "p224")
        Xe = new Lt();
      else if (We === "p192")
        Xe = new Ut();
      else if (We === "p25519")
        Xe = new Pt();
      else
        throw new Error("Unknown prime " + We);
      return Rt[We] = Xe, Xe;
    };
    function Ot(gt) {
      if (typeof gt == "string") {
        var We = Ve._prime(gt);
        (this || _global$d).m = We.p, (this || _global$d).prime = We;
      } else
        Fe(gt.gtn(1), "modulus must be greater than 1"), (this || _global$d).m = gt, (this || _global$d).prime = null;
    }
    Ot.prototype._verify1 = function(We) {
      Fe(We.negative === 0, "red works only with positives"), Fe(We.red, "red works only with red numbers");
    }, Ot.prototype._verify2 = function(We, Xe) {
      Fe((We.negative | Xe.negative) === 0, "red works only with positives"), Fe(We.red && We.red === Xe.red, "red works only with red numbers");
    }, Ot.prototype.imod = function(We) {
      return (this || _global$d).prime ? (this || _global$d).prime.ireduce(We)._forceRed(this || _global$d) : We.umod((this || _global$d).m)._forceRed(this || _global$d);
    }, Ot.prototype.neg = function(We) {
      return We.isZero() ? We.clone() : (this || _global$d).m.sub(We)._forceRed(this || _global$d);
    }, Ot.prototype.add = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.add(Xe);
      return rt.cmp((this || _global$d).m) >= 0 && rt.isub((this || _global$d).m), rt._forceRed(this || _global$d);
    }, Ot.prototype.iadd = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.iadd(Xe);
      return rt.cmp((this || _global$d).m) >= 0 && rt.isub((this || _global$d).m), rt;
    }, Ot.prototype.sub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.sub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$d).m), rt._forceRed(this || _global$d);
    }, Ot.prototype.isub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.isub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$d).m), rt;
    }, Ot.prototype.shl = function(We, Xe) {
      return this._verify1(We), this.imod(We.ushln(Xe));
    }, Ot.prototype.imul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.imul(Xe));
    }, Ot.prototype.mul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.mul(Xe));
    }, Ot.prototype.isqr = function(We) {
      return this.imul(We, We.clone());
    }, Ot.prototype.sqr = function(We) {
      return this.mul(We, We);
    }, Ot.prototype.sqrt = function(We) {
      if (We.isZero())
        return We.clone();
      var Xe = (this || _global$d).m.andln(3);
      if (Fe(Xe % 2 === 1), Xe === 3) {
        var rt = (this || _global$d).m.add(new Ve(1)).iushrn(2);
        return this.pow(We, rt);
      }
      for (var ot = (this || _global$d).m.subn(1), ft = 0; !ot.isZero() && ot.andln(1) === 0; )
        ft++, ot.iushrn(1);
      Fe(!ot.isZero());
      var mt = new Ve(1).toRed(this || _global$d), yt = mt.redNeg(), pt = (this || _global$d).m.subn(1).iushrn(1), Ge = (this || _global$d).m.bitLength();
      for (Ge = new Ve(2 * Ge * Ge).toRed(this || _global$d); this.pow(Ge, pt).cmp(yt) !== 0; )
        Ge.redIAdd(yt);
      for (var ct = this.pow(Ge, ot), Mt = this.pow(We, ot.addn(1).iushrn(1)), St = this.pow(We, ot), At = ft; St.cmp(mt) !== 0; ) {
        for (var Nt = St, qt = 0; Nt.cmp(mt) !== 0; qt++)
          Nt = Nt.redSqr();
        Fe(qt < At);
        var Qt = this.pow(ct, new Ve(1).iushln(At - qt - 1));
        Mt = Mt.redMul(Qt), ct = Qt.redSqr(), St = St.redMul(ct), At = qt;
      }
      return Mt;
    }, Ot.prototype.invm = function(We) {
      var Xe = We._invmp((this || _global$d).m);
      return Xe.negative !== 0 ? (Xe.negative = 0, this.imod(Xe).redNeg()) : this.imod(Xe);
    }, Ot.prototype.pow = function(We, Xe) {
      if (Xe.isZero())
        return new Ve(1).toRed(this || _global$d);
      if (Xe.cmpn(1) === 0)
        return We.clone();
      var rt = 4, ot = new Array(1 << rt);
      ot[0] = new Ve(1).toRed(this || _global$d), ot[1] = We;
      for (var ft = 2; ft < ot.length; ft++)
        ot[ft] = this.mul(ot[ft - 1], We);
      var mt = ot[0], yt = 0, pt = 0, Ge = Xe.bitLength() % 26;
      for (Ge === 0 && (Ge = 26), ft = Xe.length - 1; ft >= 0; ft--) {
        for (var ct = Xe.words[ft], Mt = Ge - 1; Mt >= 0; Mt--) {
          var St = ct >> Mt & 1;
          if (mt !== ot[0] && (mt = this.sqr(mt)), St === 0 && yt === 0) {
            pt = 0;
            continue;
          }
          yt <<= 1, yt |= St, pt++, !(pt !== rt && (ft !== 0 || Mt !== 0)) && (mt = this.mul(mt, ot[yt]), pt = 0, yt = 0);
        }
        Ge = 26;
      }
      return mt;
    }, Ot.prototype.convertTo = function(We) {
      var Xe = We.umod((this || _global$d).m);
      return Xe === We ? Xe.clone() : Xe;
    }, Ot.prototype.convertFrom = function(We) {
      var Xe = We.clone();
      return Xe.red = null, Xe;
    }, Ve.mont = function(We) {
      return new Ft(We);
    };
    function Ft(gt) {
      Ot.call(this || _global$d, gt), (this || _global$d).shift = (this || _global$d).m.bitLength(), (this || _global$d).shift % 26 !== 0 && ((this || _global$d).shift += 26 - (this || _global$d).shift % 26), (this || _global$d).r = new Ve(1).iushln((this || _global$d).shift), (this || _global$d).r2 = this.imod((this || _global$d).r.sqr()), (this || _global$d).rinv = (this || _global$d).r._invmp((this || _global$d).m), (this || _global$d).minv = (this || _global$d).rinv.mul((this || _global$d).r).isubn(1).div((this || _global$d).m), (this || _global$d).minv = (this || _global$d).minv.umod((this || _global$d).r), (this || _global$d).minv = (this || _global$d).r.sub((this || _global$d).minv);
    }
    Ke(Ft, Ot), Ft.prototype.convertTo = function(We) {
      return this.imod(We.ushln((this || _global$d).shift));
    }, Ft.prototype.convertFrom = function(We) {
      var Xe = this.imod(We.mul((this || _global$d).rinv));
      return Xe.red = null, Xe;
    }, Ft.prototype.imul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return We.words[0] = 0, We.length = 1, We;
      var rt = We.imul(Xe), ot = rt.maskn((this || _global$d).shift).mul((this || _global$d).minv).imaskn((this || _global$d).shift).mul((this || _global$d).m), ft = rt.isub(ot).iushrn((this || _global$d).shift), mt = ft;
      return ft.cmp((this || _global$d).m) >= 0 ? mt = ft.isub((this || _global$d).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$d).m)), mt._forceRed(this || _global$d);
    }, Ft.prototype.mul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return new Ve(0)._forceRed(this || _global$d);
      var rt = We.mul(Xe), ot = rt.maskn((this || _global$d).shift).mul((this || _global$d).minv).imaskn((this || _global$d).shift).mul((this || _global$d).m), ft = rt.isub(ot).iushrn((this || _global$d).shift), mt = ft;
      return ft.cmp((this || _global$d).m) >= 0 ? mt = ft.isub((this || _global$d).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$d).m)), mt._forceRed(this || _global$d);
    }, Ft.prototype.invm = function(We) {
      var Xe = this.imod(We._invmp((this || _global$d).m).mul((this || _global$d).r2));
      return Xe._forceRed(this || _global$d);
    };
  }(module$6, exports$13)), module$6.exports;
}
var exports$12$1 = {}, _dewExec$11$1 = !1, module$5 = {
  exports: exports$12$1
}, _global$c = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$11$1() {
  return _dewExec$11$1 || (_dewExec$11$1 = !0, function($e, Ze) {
    function Fe(gt, We) {
      if (!gt)
        throw new Error(We || "Assertion failed");
    }
    function Ke(gt, We) {
      gt.super_ = We;
      var Xe = function() {
      };
      Xe.prototype = We.prototype, gt.prototype = new Xe(), gt.prototype.constructor = gt;
    }
    function Ve(gt, We, Xe) {
      if (Ve.isBN(gt))
        return gt;
      (this || _global$c).negative = 0, (this || _global$c).words = null, (this || _global$c).length = 0, (this || _global$c).red = null, gt !== null && ((We === "le" || We === "be") && (Xe = We, We = 10), this._init(gt || 0, We || 10, Xe || "be"));
    }
    typeof $e == "object" ? $e.exports = Ve : Ze.BN = Ve, Ve.BN = Ve, Ve.wordSize = 26;
    var Je;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Je = window.Buffer : Je = e$1$1$1.Buffer;
    } catch {
    }
    Ve.isBN = function(We) {
      return We instanceof Ve ? !0 : We !== null && typeof We == "object" && We.constructor.wordSize === Ve.wordSize && Array.isArray(We.words);
    }, Ve.max = function(We, Xe) {
      return We.cmp(Xe) > 0 ? We : Xe;
    }, Ve.min = function(We, Xe) {
      return We.cmp(Xe) < 0 ? We : Xe;
    }, Ve.prototype._init = function(We, Xe, rt) {
      if (typeof We == "number")
        return this._initNumber(We, Xe, rt);
      if (typeof We == "object")
        return this._initArray(We, Xe, rt);
      Xe === "hex" && (Xe = 16), Fe(Xe === (Xe | 0) && Xe >= 2 && Xe <= 36), We = We.toString().replace(/\s+/g, "");
      var ot = 0;
      We[0] === "-" && (ot++, (this || _global$c).negative = 1), ot < We.length && (Xe === 16 ? this._parseHex(We, ot, rt) : (this._parseBase(We, Xe, ot), rt === "le" && this._initArray(this.toArray(), Xe, rt)));
    }, Ve.prototype._initNumber = function(We, Xe, rt) {
      We < 0 && ((this || _global$c).negative = 1, We = -We), We < 67108864 ? ((this || _global$c).words = [We & 67108863], (this || _global$c).length = 1) : We < 4503599627370496 ? ((this || _global$c).words = [We & 67108863, We / 67108864 & 67108863], (this || _global$c).length = 2) : (Fe(We < 9007199254740992), (this || _global$c).words = [We & 67108863, We / 67108864 & 67108863, 1], (this || _global$c).length = 3), rt === "le" && this._initArray(this.toArray(), Xe, rt);
    }, Ve.prototype._initArray = function(We, Xe, rt) {
      if (Fe(typeof We.length == "number"), We.length <= 0)
        return (this || _global$c).words = [0], (this || _global$c).length = 1, this || _global$c;
      (this || _global$c).length = Math.ceil(We.length / 3), (this || _global$c).words = new Array((this || _global$c).length);
      for (var ot = 0; ot < (this || _global$c).length; ot++)
        (this || _global$c).words[ot] = 0;
      var ft, mt, yt = 0;
      if (rt === "be")
        for (ot = We.length - 1, ft = 0; ot >= 0; ot -= 3)
          mt = We[ot] | We[ot - 1] << 8 | We[ot - 2] << 16, (this || _global$c).words[ft] |= mt << yt & 67108863, (this || _global$c).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      else if (rt === "le")
        for (ot = 0, ft = 0; ot < We.length; ot += 3)
          mt = We[ot] | We[ot + 1] << 8 | We[ot + 2] << 16, (this || _global$c).words[ft] |= mt << yt & 67108863, (this || _global$c).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      return this.strip();
    };
    function Qe(gt, We) {
      var Xe = gt.charCodeAt(We);
      return Xe >= 65 && Xe <= 70 ? Xe - 55 : Xe >= 97 && Xe <= 102 ? Xe - 87 : Xe - 48 & 15;
    }
    function at(gt, We, Xe) {
      var rt = Qe(gt, Xe);
      return Xe - 1 >= We && (rt |= Qe(gt, Xe - 1) << 4), rt;
    }
    Ve.prototype._parseHex = function(We, Xe, rt) {
      (this || _global$c).length = Math.ceil((We.length - Xe) / 6), (this || _global$c).words = new Array((this || _global$c).length);
      for (var ot = 0; ot < (this || _global$c).length; ot++)
        (this || _global$c).words[ot] = 0;
      var ft = 0, mt = 0, yt;
      if (rt === "be")
        for (ot = We.length - 1; ot >= Xe; ot -= 2)
          yt = at(We, Xe, ot) << ft, (this || _global$c).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$c).words[mt] |= yt >>> 26) : ft += 8;
      else {
        var pt = We.length - Xe;
        for (ot = pt % 2 === 0 ? Xe + 1 : Xe; ot < We.length; ot += 2)
          yt = at(We, Xe, ot) << ft, (this || _global$c).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$c).words[mt] |= yt >>> 26) : ft += 8;
      }
      this.strip();
    };
    function ut(gt, We, Xe, rt) {
      for (var ot = 0, ft = Math.min(gt.length, Xe), mt = We; mt < ft; mt++) {
        var yt = gt.charCodeAt(mt) - 48;
        ot *= rt, yt >= 49 ? ot += yt - 49 + 10 : yt >= 17 ? ot += yt - 17 + 10 : ot += yt;
      }
      return ot;
    }
    Ve.prototype._parseBase = function(We, Xe, rt) {
      (this || _global$c).words = [0], (this || _global$c).length = 1;
      for (var ot = 0, ft = 1; ft <= 67108863; ft *= Xe)
        ot++;
      ot--, ft = ft / Xe | 0;
      for (var mt = We.length - rt, yt = mt % ot, pt = Math.min(mt, mt - yt) + rt, Ge = 0, ct = rt; ct < pt; ct += ot)
        Ge = ut(We, ct, ct + ot, Xe), this.imuln(ft), (this || _global$c).words[0] + Ge < 67108864 ? (this || _global$c).words[0] += Ge : this._iaddn(Ge);
      if (yt !== 0) {
        var Mt = 1;
        for (Ge = ut(We, ct, We.length, Xe), ct = 0; ct < yt; ct++)
          Mt *= Xe;
        this.imuln(Mt), (this || _global$c).words[0] + Ge < 67108864 ? (this || _global$c).words[0] += Ge : this._iaddn(Ge);
      }
      this.strip();
    }, Ve.prototype.copy = function(We) {
      We.words = new Array((this || _global$c).length);
      for (var Xe = 0; Xe < (this || _global$c).length; Xe++)
        We.words[Xe] = (this || _global$c).words[Xe];
      We.length = (this || _global$c).length, We.negative = (this || _global$c).negative, We.red = (this || _global$c).red;
    }, Ve.prototype.clone = function() {
      var We = new Ve(null);
      return this.copy(We), We;
    }, Ve.prototype._expand = function(We) {
      for (; (this || _global$c).length < We; )
        (this || _global$c).words[(this || _global$c).length++] = 0;
      return this || _global$c;
    }, Ve.prototype.strip = function() {
      for (; (this || _global$c).length > 1 && (this || _global$c).words[(this || _global$c).length - 1] === 0; )
        (this || _global$c).length--;
      return this._normSign();
    }, Ve.prototype._normSign = function() {
      return (this || _global$c).length === 1 && (this || _global$c).words[0] === 0 && ((this || _global$c).negative = 0), this || _global$c;
    }, Ve.prototype.inspect = function() {
      return ((this || _global$c).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var lt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], dt = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], bt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    Ve.prototype.toString = function(We, Xe) {
      We = We || 10, Xe = Xe | 0 || 1;
      var rt;
      if (We === 16 || We === "hex") {
        rt = "";
        for (var ot = 0, ft = 0, mt = 0; mt < (this || _global$c).length; mt++) {
          var yt = (this || _global$c).words[mt], pt = ((yt << ot | ft) & 16777215).toString(16);
          ft = yt >>> 24 - ot & 16777215, ft !== 0 || mt !== (this || _global$c).length - 1 ? rt = lt[6 - pt.length] + pt + rt : rt = pt + rt, ot += 2, ot >= 26 && (ot -= 26, mt--);
        }
        for (ft !== 0 && (rt = ft.toString(16) + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$c).negative !== 0 && (rt = "-" + rt), rt;
      }
      if (We === (We | 0) && We >= 2 && We <= 36) {
        var Ge = dt[We], ct = bt[We];
        rt = "";
        var Mt = this.clone();
        for (Mt.negative = 0; !Mt.isZero(); ) {
          var St = Mt.modn(ct).toString(We);
          Mt = Mt.idivn(ct), Mt.isZero() ? rt = St + rt : rt = lt[Ge - St.length] + St + rt;
        }
        for (this.isZero() && (rt = "0" + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$c).negative !== 0 && (rt = "-" + rt), rt;
      }
      Fe(!1, "Base should be between 2 and 36");
    }, Ve.prototype.toNumber = function() {
      var We = (this || _global$c).words[0];
      return (this || _global$c).length === 2 ? We += (this || _global$c).words[1] * 67108864 : (this || _global$c).length === 3 && (this || _global$c).words[2] === 1 ? We += 4503599627370496 + (this || _global$c).words[1] * 67108864 : (this || _global$c).length > 2 && Fe(!1, "Number can only safely store up to 53 bits"), (this || _global$c).negative !== 0 ? -We : We;
    }, Ve.prototype.toJSON = function() {
      return this.toString(16);
    }, Ve.prototype.toBuffer = function(We, Xe) {
      return Fe(typeof Je < "u"), this.toArrayLike(Je, We, Xe);
    }, Ve.prototype.toArray = function(We, Xe) {
      return this.toArrayLike(Array, We, Xe);
    }, Ve.prototype.toArrayLike = function(We, Xe, rt) {
      var ot = this.byteLength(), ft = rt || Math.max(1, ot);
      Fe(ot <= ft, "byte array longer than desired length"), Fe(ft > 0, "Requested array length <= 0"), this.strip();
      var mt = Xe === "le", yt = new We(ft), pt, Ge, ct = this.clone();
      if (mt) {
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[Ge] = pt;
        for (; Ge < ft; Ge++)
          yt[Ge] = 0;
      } else {
        for (Ge = 0; Ge < ft - ot; Ge++)
          yt[Ge] = 0;
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[ft - Ge - 1] = pt;
      }
      return yt;
    }, Math.clz32 ? Ve.prototype._countBits = function(We) {
      return 32 - Math.clz32(We);
    } : Ve.prototype._countBits = function(We) {
      var Xe = We, rt = 0;
      return Xe >= 4096 && (rt += 13, Xe >>>= 13), Xe >= 64 && (rt += 7, Xe >>>= 7), Xe >= 8 && (rt += 4, Xe >>>= 4), Xe >= 2 && (rt += 2, Xe >>>= 2), rt + Xe;
    }, Ve.prototype._zeroBits = function(We) {
      if (We === 0)
        return 26;
      var Xe = We, rt = 0;
      return Xe & 8191 || (rt += 13, Xe >>>= 13), Xe & 127 || (rt += 7, Xe >>>= 7), Xe & 15 || (rt += 4, Xe >>>= 4), Xe & 3 || (rt += 2, Xe >>>= 2), Xe & 1 || rt++, rt;
    }, Ve.prototype.bitLength = function() {
      var We = (this || _global$c).words[(this || _global$c).length - 1], Xe = this._countBits(We);
      return ((this || _global$c).length - 1) * 26 + Xe;
    };
    function $t(gt) {
      for (var We = new Array(gt.bitLength()), Xe = 0; Xe < We.length; Xe++) {
        var rt = Xe / 26 | 0, ot = Xe % 26;
        We[Xe] = (gt.words[rt] & 1 << ot) >>> ot;
      }
      return We;
    }
    Ve.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var We = 0, Xe = 0; Xe < (this || _global$c).length; Xe++) {
        var rt = this._zeroBits((this || _global$c).words[Xe]);
        if (We += rt, rt !== 26)
          break;
      }
      return We;
    }, Ve.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Ve.prototype.toTwos = function(We) {
      return (this || _global$c).negative !== 0 ? this.abs().inotn(We).iaddn(1) : this.clone();
    }, Ve.prototype.fromTwos = function(We) {
      return this.testn(We - 1) ? this.notn(We).iaddn(1).ineg() : this.clone();
    }, Ve.prototype.isNeg = function() {
      return (this || _global$c).negative !== 0;
    }, Ve.prototype.neg = function() {
      return this.clone().ineg();
    }, Ve.prototype.ineg = function() {
      return this.isZero() || ((this || _global$c).negative ^= 1), this || _global$c;
    }, Ve.prototype.iuor = function(We) {
      for (; (this || _global$c).length < We.length; )
        (this || _global$c).words[(this || _global$c).length++] = 0;
      for (var Xe = 0; Xe < We.length; Xe++)
        (this || _global$c).words[Xe] = (this || _global$c).words[Xe] | We.words[Xe];
      return this.strip();
    }, Ve.prototype.ior = function(We) {
      return Fe(((this || _global$c).negative | We.negative) === 0), this.iuor(We);
    }, Ve.prototype.or = function(We) {
      return (this || _global$c).length > We.length ? this.clone().ior(We) : We.clone().ior(this || _global$c);
    }, Ve.prototype.uor = function(We) {
      return (this || _global$c).length > We.length ? this.clone().iuor(We) : We.clone().iuor(this || _global$c);
    }, Ve.prototype.iuand = function(We) {
      var Xe;
      (this || _global$c).length > We.length ? Xe = We : Xe = this || _global$c;
      for (var rt = 0; rt < Xe.length; rt++)
        (this || _global$c).words[rt] = (this || _global$c).words[rt] & We.words[rt];
      return (this || _global$c).length = Xe.length, this.strip();
    }, Ve.prototype.iand = function(We) {
      return Fe(((this || _global$c).negative | We.negative) === 0), this.iuand(We);
    }, Ve.prototype.and = function(We) {
      return (this || _global$c).length > We.length ? this.clone().iand(We) : We.clone().iand(this || _global$c);
    }, Ve.prototype.uand = function(We) {
      return (this || _global$c).length > We.length ? this.clone().iuand(We) : We.clone().iuand(this || _global$c);
    }, Ve.prototype.iuxor = function(We) {
      var Xe, rt;
      (this || _global$c).length > We.length ? (Xe = this || _global$c, rt = We) : (Xe = We, rt = this || _global$c);
      for (var ot = 0; ot < rt.length; ot++)
        (this || _global$c).words[ot] = Xe.words[ot] ^ rt.words[ot];
      if ((this || _global$c) !== Xe)
        for (; ot < Xe.length; ot++)
          (this || _global$c).words[ot] = Xe.words[ot];
      return (this || _global$c).length = Xe.length, this.strip();
    }, Ve.prototype.ixor = function(We) {
      return Fe(((this || _global$c).negative | We.negative) === 0), this.iuxor(We);
    }, Ve.prototype.xor = function(We) {
      return (this || _global$c).length > We.length ? this.clone().ixor(We) : We.clone().ixor(this || _global$c);
    }, Ve.prototype.uxor = function(We) {
      return (this || _global$c).length > We.length ? this.clone().iuxor(We) : We.clone().iuxor(this || _global$c);
    }, Ve.prototype.inotn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = Math.ceil(We / 26) | 0, rt = We % 26;
      this._expand(Xe), rt > 0 && Xe--;
      for (var ot = 0; ot < Xe; ot++)
        (this || _global$c).words[ot] = ~(this || _global$c).words[ot] & 67108863;
      return rt > 0 && ((this || _global$c).words[ot] = ~(this || _global$c).words[ot] & 67108863 >> 26 - rt), this.strip();
    }, Ve.prototype.notn = function(We) {
      return this.clone().inotn(We);
    }, Ve.prototype.setn = function(We, Xe) {
      Fe(typeof We == "number" && We >= 0);
      var rt = We / 26 | 0, ot = We % 26;
      return this._expand(rt + 1), Xe ? (this || _global$c).words[rt] = (this || _global$c).words[rt] | 1 << ot : (this || _global$c).words[rt] = (this || _global$c).words[rt] & ~(1 << ot), this.strip();
    }, Ve.prototype.iadd = function(We) {
      var Xe;
      if ((this || _global$c).negative !== 0 && We.negative === 0)
        return (this || _global$c).negative = 0, Xe = this.isub(We), (this || _global$c).negative ^= 1, this._normSign();
      if ((this || _global$c).negative === 0 && We.negative !== 0)
        return We.negative = 0, Xe = this.isub(We), We.negative = 1, Xe._normSign();
      var rt, ot;
      (this || _global$c).length > We.length ? (rt = this || _global$c, ot = We) : (rt = We, ot = this || _global$c);
      for (var ft = 0, mt = 0; mt < ot.length; mt++)
        Xe = (rt.words[mt] | 0) + (ot.words[mt] | 0) + ft, (this || _global$c).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      for (; ft !== 0 && mt < rt.length; mt++)
        Xe = (rt.words[mt] | 0) + ft, (this || _global$c).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      if ((this || _global$c).length = rt.length, ft !== 0)
        (this || _global$c).words[(this || _global$c).length] = ft, (this || _global$c).length++;
      else if (rt !== (this || _global$c))
        for (; mt < rt.length; mt++)
          (this || _global$c).words[mt] = rt.words[mt];
      return this || _global$c;
    }, Ve.prototype.add = function(We) {
      var Xe;
      return We.negative !== 0 && (this || _global$c).negative === 0 ? (We.negative = 0, Xe = this.sub(We), We.negative ^= 1, Xe) : We.negative === 0 && (this || _global$c).negative !== 0 ? ((this || _global$c).negative = 0, Xe = We.sub(this || _global$c), (this || _global$c).negative = 1, Xe) : (this || _global$c).length > We.length ? this.clone().iadd(We) : We.clone().iadd(this || _global$c);
    }, Ve.prototype.isub = function(We) {
      if (We.negative !== 0) {
        We.negative = 0;
        var Xe = this.iadd(We);
        return We.negative = 1, Xe._normSign();
      } else if ((this || _global$c).negative !== 0)
        return (this || _global$c).negative = 0, this.iadd(We), (this || _global$c).negative = 1, this._normSign();
      var rt = this.cmp(We);
      if (rt === 0)
        return (this || _global$c).negative = 0, (this || _global$c).length = 1, (this || _global$c).words[0] = 0, this || _global$c;
      var ot, ft;
      rt > 0 ? (ot = this || _global$c, ft = We) : (ot = We, ft = this || _global$c);
      for (var mt = 0, yt = 0; yt < ft.length; yt++)
        Xe = (ot.words[yt] | 0) - (ft.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$c).words[yt] = Xe & 67108863;
      for (; mt !== 0 && yt < ot.length; yt++)
        Xe = (ot.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$c).words[yt] = Xe & 67108863;
      if (mt === 0 && yt < ot.length && ot !== (this || _global$c))
        for (; yt < ot.length; yt++)
          (this || _global$c).words[yt] = ot.words[yt];
      return (this || _global$c).length = Math.max((this || _global$c).length, yt), ot !== (this || _global$c) && ((this || _global$c).negative = 1), this.strip();
    }, Ve.prototype.sub = function(We) {
      return this.clone().isub(We);
    };
    function vt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative;
      var rt = gt.length + We.length | 0;
      Xe.length = rt, rt = rt - 1 | 0;
      var ot = gt.words[0] | 0, ft = We.words[0] | 0, mt = ot * ft, yt = mt & 67108863, pt = mt / 67108864 | 0;
      Xe.words[0] = yt;
      for (var Ge = 1; Ge < rt; Ge++) {
        for (var ct = pt >>> 26, Mt = pt & 67108863, St = Math.min(Ge, We.length - 1), At = Math.max(0, Ge - gt.length + 1); At <= St; At++) {
          var Nt = Ge - At | 0;
          ot = gt.words[Nt] | 0, ft = We.words[At] | 0, mt = ot * ft + Mt, ct += mt / 67108864 | 0, Mt = mt & 67108863;
        }
        Xe.words[Ge] = Mt | 0, pt = ct | 0;
      }
      return pt !== 0 ? Xe.words[Ge] = pt | 0 : Xe.length--, Xe.strip();
    }
    var wt = function(We, Xe, rt) {
      var ot = We.words, ft = Xe.words, mt = rt.words, yt = 0, pt, Ge, ct, Mt = ot[0] | 0, St = Mt & 8191, At = Mt >>> 13, Nt = ot[1] | 0, qt = Nt & 8191, Qt = Nt >>> 13, Xt = ot[2] | 0, zt = Xt & 8191, Kt = Xt >>> 13, ur = ot[3] | 0, er = ur & 8191, Dt = ur >>> 13, Ht = ot[4] | 0, Gt = Ht & 8191, rr = Ht >>> 13, sr = ot[5] | 0, Jt = sr & 8191, ir = sr >>> 13, Br = ot[6] | 0, or = Br & 8191, lr = Br >>> 13, Nr = ot[7] | 0, dr = Nr & 8191, gr = Nr >>> 13, Zr = ot[8] | 0, Bt = Zr & 8191, kt = Zr >>> 13, It = ot[9] | 0, jt = It & 8191, Vt = It >>> 13, ar = ft[0] | 0, Yt = ar & 8191, hr = ar >>> 13, zr = ft[1] | 0, cr = zr & 8191, _r = zr >>> 13, Lr = ft[2] | 0, br = Lr & 8191, kr = Lr >>> 13, Xr = ft[3] | 0, yr = Xr & 8191, Ir = Xr >>> 13, Yr = ft[4] | 0, wr = Yr & 8191, Cr = Yr >>> 13, Hr = ft[5] | 0, $r = Hr & 8191, Ar = Hr >>> 13, Wr = ft[6] | 0, mr = Wr & 8191, Tr = Wr >>> 13, Kr = ft[7] | 0, vr = Kr & 8191, Rr = Kr >>> 13, Jr = ft[8] | 0, xr = Jr & 8191, tr = Jr >>> 13, Dr = ft[9] | 0, fr = Dr & 8191, Mr = Dr >>> 13;
      rt.negative = We.negative ^ Xe.negative, rt.length = 19, pt = Math.imul(St, Yt), Ge = Math.imul(St, hr), Ge = Ge + Math.imul(At, Yt) | 0, ct = Math.imul(At, hr);
      var Fr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, pt = Math.imul(qt, Yt), Ge = Math.imul(qt, hr), Ge = Ge + Math.imul(Qt, Yt) | 0, ct = Math.imul(Qt, hr), pt = pt + Math.imul(St, cr) | 0, Ge = Ge + Math.imul(St, _r) | 0, Ge = Ge + Math.imul(At, cr) | 0, ct = ct + Math.imul(At, _r) | 0;
      var qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, pt = Math.imul(zt, Yt), Ge = Math.imul(zt, hr), Ge = Ge + Math.imul(Kt, Yt) | 0, ct = Math.imul(Kt, hr), pt = pt + Math.imul(qt, cr) | 0, Ge = Ge + Math.imul(qt, _r) | 0, Ge = Ge + Math.imul(Qt, cr) | 0, ct = ct + Math.imul(Qt, _r) | 0, pt = pt + Math.imul(St, br) | 0, Ge = Ge + Math.imul(St, kr) | 0, Ge = Ge + Math.imul(At, br) | 0, ct = ct + Math.imul(At, kr) | 0;
      var tn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, pt = Math.imul(er, Yt), Ge = Math.imul(er, hr), Ge = Ge + Math.imul(Dt, Yt) | 0, ct = Math.imul(Dt, hr), pt = pt + Math.imul(zt, cr) | 0, Ge = Ge + Math.imul(zt, _r) | 0, Ge = Ge + Math.imul(Kt, cr) | 0, ct = ct + Math.imul(Kt, _r) | 0, pt = pt + Math.imul(qt, br) | 0, Ge = Ge + Math.imul(qt, kr) | 0, Ge = Ge + Math.imul(Qt, br) | 0, ct = ct + Math.imul(Qt, kr) | 0, pt = pt + Math.imul(St, yr) | 0, Ge = Ge + Math.imul(St, Ir) | 0, Ge = Ge + Math.imul(At, yr) | 0, ct = ct + Math.imul(At, Ir) | 0;
      var Qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, pt = Math.imul(Gt, Yt), Ge = Math.imul(Gt, hr), Ge = Ge + Math.imul(rr, Yt) | 0, ct = Math.imul(rr, hr), pt = pt + Math.imul(er, cr) | 0, Ge = Ge + Math.imul(er, _r) | 0, Ge = Ge + Math.imul(Dt, cr) | 0, ct = ct + Math.imul(Dt, _r) | 0, pt = pt + Math.imul(zt, br) | 0, Ge = Ge + Math.imul(zt, kr) | 0, Ge = Ge + Math.imul(Kt, br) | 0, ct = ct + Math.imul(Kt, kr) | 0, pt = pt + Math.imul(qt, yr) | 0, Ge = Ge + Math.imul(qt, Ir) | 0, Ge = Ge + Math.imul(Qt, yr) | 0, ct = ct + Math.imul(Qt, Ir) | 0, pt = pt + Math.imul(St, wr) | 0, Ge = Ge + Math.imul(St, Cr) | 0, Ge = Ge + Math.imul(At, wr) | 0, ct = ct + Math.imul(At, Cr) | 0;
      var nn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, pt = Math.imul(Jt, Yt), Ge = Math.imul(Jt, hr), Ge = Ge + Math.imul(ir, Yt) | 0, ct = Math.imul(ir, hr), pt = pt + Math.imul(Gt, cr) | 0, Ge = Ge + Math.imul(Gt, _r) | 0, Ge = Ge + Math.imul(rr, cr) | 0, ct = ct + Math.imul(rr, _r) | 0, pt = pt + Math.imul(er, br) | 0, Ge = Ge + Math.imul(er, kr) | 0, Ge = Ge + Math.imul(Dt, br) | 0, ct = ct + Math.imul(Dt, kr) | 0, pt = pt + Math.imul(zt, yr) | 0, Ge = Ge + Math.imul(zt, Ir) | 0, Ge = Ge + Math.imul(Kt, yr) | 0, ct = ct + Math.imul(Kt, Ir) | 0, pt = pt + Math.imul(qt, wr) | 0, Ge = Ge + Math.imul(qt, Cr) | 0, Ge = Ge + Math.imul(Qt, wr) | 0, ct = ct + Math.imul(Qt, Cr) | 0, pt = pt + Math.imul(St, $r) | 0, Ge = Ge + Math.imul(St, Ar) | 0, Ge = Ge + Math.imul(At, $r) | 0, ct = ct + Math.imul(At, Ar) | 0;
      var Er = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, pt = Math.imul(or, Yt), Ge = Math.imul(or, hr), Ge = Ge + Math.imul(lr, Yt) | 0, ct = Math.imul(lr, hr), pt = pt + Math.imul(Jt, cr) | 0, Ge = Ge + Math.imul(Jt, _r) | 0, Ge = Ge + Math.imul(ir, cr) | 0, ct = ct + Math.imul(ir, _r) | 0, pt = pt + Math.imul(Gt, br) | 0, Ge = Ge + Math.imul(Gt, kr) | 0, Ge = Ge + Math.imul(rr, br) | 0, ct = ct + Math.imul(rr, kr) | 0, pt = pt + Math.imul(er, yr) | 0, Ge = Ge + Math.imul(er, Ir) | 0, Ge = Ge + Math.imul(Dt, yr) | 0, ct = ct + Math.imul(Dt, Ir) | 0, pt = pt + Math.imul(zt, wr) | 0, Ge = Ge + Math.imul(zt, Cr) | 0, Ge = Ge + Math.imul(Kt, wr) | 0, ct = ct + Math.imul(Kt, Cr) | 0, pt = pt + Math.imul(qt, $r) | 0, Ge = Ge + Math.imul(qt, Ar) | 0, Ge = Ge + Math.imul(Qt, $r) | 0, ct = ct + Math.imul(Qt, Ar) | 0, pt = pt + Math.imul(St, mr) | 0, Ge = Ge + Math.imul(St, Tr) | 0, Ge = Ge + Math.imul(At, mr) | 0, ct = ct + Math.imul(At, Tr) | 0;
      var Wt = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, pt = Math.imul(dr, Yt), Ge = Math.imul(dr, hr), Ge = Ge + Math.imul(gr, Yt) | 0, ct = Math.imul(gr, hr), pt = pt + Math.imul(or, cr) | 0, Ge = Ge + Math.imul(or, _r) | 0, Ge = Ge + Math.imul(lr, cr) | 0, ct = ct + Math.imul(lr, _r) | 0, pt = pt + Math.imul(Jt, br) | 0, Ge = Ge + Math.imul(Jt, kr) | 0, Ge = Ge + Math.imul(ir, br) | 0, ct = ct + Math.imul(ir, kr) | 0, pt = pt + Math.imul(Gt, yr) | 0, Ge = Ge + Math.imul(Gt, Ir) | 0, Ge = Ge + Math.imul(rr, yr) | 0, ct = ct + Math.imul(rr, Ir) | 0, pt = pt + Math.imul(er, wr) | 0, Ge = Ge + Math.imul(er, Cr) | 0, Ge = Ge + Math.imul(Dt, wr) | 0, ct = ct + Math.imul(Dt, Cr) | 0, pt = pt + Math.imul(zt, $r) | 0, Ge = Ge + Math.imul(zt, Ar) | 0, Ge = Ge + Math.imul(Kt, $r) | 0, ct = ct + Math.imul(Kt, Ar) | 0, pt = pt + Math.imul(qt, mr) | 0, Ge = Ge + Math.imul(qt, Tr) | 0, Ge = Ge + Math.imul(Qt, mr) | 0, ct = ct + Math.imul(Qt, Tr) | 0, pt = pt + Math.imul(St, vr) | 0, Ge = Ge + Math.imul(St, Rr) | 0, Ge = Ge + Math.imul(At, vr) | 0, ct = ct + Math.imul(At, Rr) | 0;
      var nr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, pt = Math.imul(Bt, Yt), Ge = Math.imul(Bt, hr), Ge = Ge + Math.imul(kt, Yt) | 0, ct = Math.imul(kt, hr), pt = pt + Math.imul(dr, cr) | 0, Ge = Ge + Math.imul(dr, _r) | 0, Ge = Ge + Math.imul(gr, cr) | 0, ct = ct + Math.imul(gr, _r) | 0, pt = pt + Math.imul(or, br) | 0, Ge = Ge + Math.imul(or, kr) | 0, Ge = Ge + Math.imul(lr, br) | 0, ct = ct + Math.imul(lr, kr) | 0, pt = pt + Math.imul(Jt, yr) | 0, Ge = Ge + Math.imul(Jt, Ir) | 0, Ge = Ge + Math.imul(ir, yr) | 0, ct = ct + Math.imul(ir, Ir) | 0, pt = pt + Math.imul(Gt, wr) | 0, Ge = Ge + Math.imul(Gt, Cr) | 0, Ge = Ge + Math.imul(rr, wr) | 0, ct = ct + Math.imul(rr, Cr) | 0, pt = pt + Math.imul(er, $r) | 0, Ge = Ge + Math.imul(er, Ar) | 0, Ge = Ge + Math.imul(Dt, $r) | 0, ct = ct + Math.imul(Dt, Ar) | 0, pt = pt + Math.imul(zt, mr) | 0, Ge = Ge + Math.imul(zt, Tr) | 0, Ge = Ge + Math.imul(Kt, mr) | 0, ct = ct + Math.imul(Kt, Tr) | 0, pt = pt + Math.imul(qt, vr) | 0, Ge = Ge + Math.imul(qt, Rr) | 0, Ge = Ge + Math.imul(Qt, vr) | 0, ct = ct + Math.imul(Qt, Rr) | 0, pt = pt + Math.imul(St, xr) | 0, Ge = Ge + Math.imul(St, tr) | 0, Ge = Ge + Math.imul(At, xr) | 0, ct = ct + Math.imul(At, tr) | 0;
      var pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, pt = Math.imul(jt, Yt), Ge = Math.imul(jt, hr), Ge = Ge + Math.imul(Vt, Yt) | 0, ct = Math.imul(Vt, hr), pt = pt + Math.imul(Bt, cr) | 0, Ge = Ge + Math.imul(Bt, _r) | 0, Ge = Ge + Math.imul(kt, cr) | 0, ct = ct + Math.imul(kt, _r) | 0, pt = pt + Math.imul(dr, br) | 0, Ge = Ge + Math.imul(dr, kr) | 0, Ge = Ge + Math.imul(gr, br) | 0, ct = ct + Math.imul(gr, kr) | 0, pt = pt + Math.imul(or, yr) | 0, Ge = Ge + Math.imul(or, Ir) | 0, Ge = Ge + Math.imul(lr, yr) | 0, ct = ct + Math.imul(lr, Ir) | 0, pt = pt + Math.imul(Jt, wr) | 0, Ge = Ge + Math.imul(Jt, Cr) | 0, Ge = Ge + Math.imul(ir, wr) | 0, ct = ct + Math.imul(ir, Cr) | 0, pt = pt + Math.imul(Gt, $r) | 0, Ge = Ge + Math.imul(Gt, Ar) | 0, Ge = Ge + Math.imul(rr, $r) | 0, ct = ct + Math.imul(rr, Ar) | 0, pt = pt + Math.imul(er, mr) | 0, Ge = Ge + Math.imul(er, Tr) | 0, Ge = Ge + Math.imul(Dt, mr) | 0, ct = ct + Math.imul(Dt, Tr) | 0, pt = pt + Math.imul(zt, vr) | 0, Ge = Ge + Math.imul(zt, Rr) | 0, Ge = Ge + Math.imul(Kt, vr) | 0, ct = ct + Math.imul(Kt, Rr) | 0, pt = pt + Math.imul(qt, xr) | 0, Ge = Ge + Math.imul(qt, tr) | 0, Ge = Ge + Math.imul(Qt, xr) | 0, ct = ct + Math.imul(Qt, tr) | 0, pt = pt + Math.imul(St, fr) | 0, Ge = Ge + Math.imul(St, Mr) | 0, Ge = Ge + Math.imul(At, fr) | 0, ct = ct + Math.imul(At, Mr) | 0;
      var Pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, pt = Math.imul(jt, cr), Ge = Math.imul(jt, _r), Ge = Ge + Math.imul(Vt, cr) | 0, ct = Math.imul(Vt, _r), pt = pt + Math.imul(Bt, br) | 0, Ge = Ge + Math.imul(Bt, kr) | 0, Ge = Ge + Math.imul(kt, br) | 0, ct = ct + Math.imul(kt, kr) | 0, pt = pt + Math.imul(dr, yr) | 0, Ge = Ge + Math.imul(dr, Ir) | 0, Ge = Ge + Math.imul(gr, yr) | 0, ct = ct + Math.imul(gr, Ir) | 0, pt = pt + Math.imul(or, wr) | 0, Ge = Ge + Math.imul(or, Cr) | 0, Ge = Ge + Math.imul(lr, wr) | 0, ct = ct + Math.imul(lr, Cr) | 0, pt = pt + Math.imul(Jt, $r) | 0, Ge = Ge + Math.imul(Jt, Ar) | 0, Ge = Ge + Math.imul(ir, $r) | 0, ct = ct + Math.imul(ir, Ar) | 0, pt = pt + Math.imul(Gt, mr) | 0, Ge = Ge + Math.imul(Gt, Tr) | 0, Ge = Ge + Math.imul(rr, mr) | 0, ct = ct + Math.imul(rr, Tr) | 0, pt = pt + Math.imul(er, vr) | 0, Ge = Ge + Math.imul(er, Rr) | 0, Ge = Ge + Math.imul(Dt, vr) | 0, ct = ct + Math.imul(Dt, Rr) | 0, pt = pt + Math.imul(zt, xr) | 0, Ge = Ge + Math.imul(zt, tr) | 0, Ge = Ge + Math.imul(Kt, xr) | 0, ct = ct + Math.imul(Kt, tr) | 0, pt = pt + Math.imul(qt, fr) | 0, Ge = Ge + Math.imul(qt, Mr) | 0, Ge = Ge + Math.imul(Qt, fr) | 0, ct = ct + Math.imul(Qt, Mr) | 0;
      var Sr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, pt = Math.imul(jt, br), Ge = Math.imul(jt, kr), Ge = Ge + Math.imul(Vt, br) | 0, ct = Math.imul(Vt, kr), pt = pt + Math.imul(Bt, yr) | 0, Ge = Ge + Math.imul(Bt, Ir) | 0, Ge = Ge + Math.imul(kt, yr) | 0, ct = ct + Math.imul(kt, Ir) | 0, pt = pt + Math.imul(dr, wr) | 0, Ge = Ge + Math.imul(dr, Cr) | 0, Ge = Ge + Math.imul(gr, wr) | 0, ct = ct + Math.imul(gr, Cr) | 0, pt = pt + Math.imul(or, $r) | 0, Ge = Ge + Math.imul(or, Ar) | 0, Ge = Ge + Math.imul(lr, $r) | 0, ct = ct + Math.imul(lr, Ar) | 0, pt = pt + Math.imul(Jt, mr) | 0, Ge = Ge + Math.imul(Jt, Tr) | 0, Ge = Ge + Math.imul(ir, mr) | 0, ct = ct + Math.imul(ir, Tr) | 0, pt = pt + Math.imul(Gt, vr) | 0, Ge = Ge + Math.imul(Gt, Rr) | 0, Ge = Ge + Math.imul(rr, vr) | 0, ct = ct + Math.imul(rr, Rr) | 0, pt = pt + Math.imul(er, xr) | 0, Ge = Ge + Math.imul(er, tr) | 0, Ge = Ge + Math.imul(Dt, xr) | 0, ct = ct + Math.imul(Dt, tr) | 0, pt = pt + Math.imul(zt, fr) | 0, Ge = Ge + Math.imul(zt, Mr) | 0, Ge = Ge + Math.imul(Kt, fr) | 0, ct = ct + Math.imul(Kt, Mr) | 0;
      var Ur = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, pt = Math.imul(jt, yr), Ge = Math.imul(jt, Ir), Ge = Ge + Math.imul(Vt, yr) | 0, ct = Math.imul(Vt, Ir), pt = pt + Math.imul(Bt, wr) | 0, Ge = Ge + Math.imul(Bt, Cr) | 0, Ge = Ge + Math.imul(kt, wr) | 0, ct = ct + Math.imul(kt, Cr) | 0, pt = pt + Math.imul(dr, $r) | 0, Ge = Ge + Math.imul(dr, Ar) | 0, Ge = Ge + Math.imul(gr, $r) | 0, ct = ct + Math.imul(gr, Ar) | 0, pt = pt + Math.imul(or, mr) | 0, Ge = Ge + Math.imul(or, Tr) | 0, Ge = Ge + Math.imul(lr, mr) | 0, ct = ct + Math.imul(lr, Tr) | 0, pt = pt + Math.imul(Jt, vr) | 0, Ge = Ge + Math.imul(Jt, Rr) | 0, Ge = Ge + Math.imul(ir, vr) | 0, ct = ct + Math.imul(ir, Rr) | 0, pt = pt + Math.imul(Gt, xr) | 0, Ge = Ge + Math.imul(Gt, tr) | 0, Ge = Ge + Math.imul(rr, xr) | 0, ct = ct + Math.imul(rr, tr) | 0, pt = pt + Math.imul(er, fr) | 0, Ge = Ge + Math.imul(er, Mr) | 0, Ge = Ge + Math.imul(Dt, fr) | 0, ct = ct + Math.imul(Dt, Mr) | 0;
      var jr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, pt = Math.imul(jt, wr), Ge = Math.imul(jt, Cr), Ge = Ge + Math.imul(Vt, wr) | 0, ct = Math.imul(Vt, Cr), pt = pt + Math.imul(Bt, $r) | 0, Ge = Ge + Math.imul(Bt, Ar) | 0, Ge = Ge + Math.imul(kt, $r) | 0, ct = ct + Math.imul(kt, Ar) | 0, pt = pt + Math.imul(dr, mr) | 0, Ge = Ge + Math.imul(dr, Tr) | 0, Ge = Ge + Math.imul(gr, mr) | 0, ct = ct + Math.imul(gr, Tr) | 0, pt = pt + Math.imul(or, vr) | 0, Ge = Ge + Math.imul(or, Rr) | 0, Ge = Ge + Math.imul(lr, vr) | 0, ct = ct + Math.imul(lr, Rr) | 0, pt = pt + Math.imul(Jt, xr) | 0, Ge = Ge + Math.imul(Jt, tr) | 0, Ge = Ge + Math.imul(ir, xr) | 0, ct = ct + Math.imul(ir, tr) | 0, pt = pt + Math.imul(Gt, fr) | 0, Ge = Ge + Math.imul(Gt, Mr) | 0, Ge = Ge + Math.imul(rr, fr) | 0, ct = ct + Math.imul(rr, Mr) | 0;
      var Gr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, pt = Math.imul(jt, $r), Ge = Math.imul(jt, Ar), Ge = Ge + Math.imul(Vt, $r) | 0, ct = Math.imul(Vt, Ar), pt = pt + Math.imul(Bt, mr) | 0, Ge = Ge + Math.imul(Bt, Tr) | 0, Ge = Ge + Math.imul(kt, mr) | 0, ct = ct + Math.imul(kt, Tr) | 0, pt = pt + Math.imul(dr, vr) | 0, Ge = Ge + Math.imul(dr, Rr) | 0, Ge = Ge + Math.imul(gr, vr) | 0, ct = ct + Math.imul(gr, Rr) | 0, pt = pt + Math.imul(or, xr) | 0, Ge = Ge + Math.imul(or, tr) | 0, Ge = Ge + Math.imul(lr, xr) | 0, ct = ct + Math.imul(lr, tr) | 0, pt = pt + Math.imul(Jt, fr) | 0, Ge = Ge + Math.imul(Jt, Mr) | 0, Ge = Ge + Math.imul(ir, fr) | 0, ct = ct + Math.imul(ir, Mr) | 0;
      var Vr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, pt = Math.imul(jt, mr), Ge = Math.imul(jt, Tr), Ge = Ge + Math.imul(Vt, mr) | 0, ct = Math.imul(Vt, Tr), pt = pt + Math.imul(Bt, vr) | 0, Ge = Ge + Math.imul(Bt, Rr) | 0, Ge = Ge + Math.imul(kt, vr) | 0, ct = ct + Math.imul(kt, Rr) | 0, pt = pt + Math.imul(dr, xr) | 0, Ge = Ge + Math.imul(dr, tr) | 0, Ge = Ge + Math.imul(gr, xr) | 0, ct = ct + Math.imul(gr, tr) | 0, pt = pt + Math.imul(or, fr) | 0, Ge = Ge + Math.imul(or, Mr) | 0, Ge = Ge + Math.imul(lr, fr) | 0, ct = ct + Math.imul(lr, Mr) | 0;
      var rn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, pt = Math.imul(jt, vr), Ge = Math.imul(jt, Rr), Ge = Ge + Math.imul(Vt, vr) | 0, ct = Math.imul(Vt, Rr), pt = pt + Math.imul(Bt, xr) | 0, Ge = Ge + Math.imul(Bt, tr) | 0, Ge = Ge + Math.imul(kt, xr) | 0, ct = ct + Math.imul(kt, tr) | 0, pt = pt + Math.imul(dr, fr) | 0, Ge = Ge + Math.imul(dr, Mr) | 0, Ge = Ge + Math.imul(gr, fr) | 0, ct = ct + Math.imul(gr, Mr) | 0;
      var an = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, pt = Math.imul(jt, xr), Ge = Math.imul(jt, tr), Ge = Ge + Math.imul(Vt, xr) | 0, ct = Math.imul(Vt, tr), pt = pt + Math.imul(Bt, fr) | 0, Ge = Ge + Math.imul(Bt, Mr) | 0, Ge = Ge + Math.imul(kt, fr) | 0, ct = ct + Math.imul(kt, Mr) | 0;
      var ln = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, pt = Math.imul(jt, fr), Ge = Math.imul(jt, Mr), Ge = Ge + Math.imul(Vt, fr) | 0, ct = Math.imul(Vt, Mr);
      var sn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      return yt = (ct + (Ge >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, mt[0] = Fr, mt[1] = qr, mt[2] = tn, mt[3] = Qr, mt[4] = nn, mt[5] = Er, mt[6] = Wt, mt[7] = nr, mt[8] = pr, mt[9] = Pr, mt[10] = Sr, mt[11] = Ur, mt[12] = jr, mt[13] = Gr, mt[14] = Vr, mt[15] = rn, mt[16] = an, mt[17] = ln, mt[18] = sn, yt !== 0 && (mt[19] = yt, rt.length++), rt;
    };
    Math.imul || (wt = vt);
    function xt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative, Xe.length = gt.length + We.length;
      for (var rt = 0, ot = 0, ft = 0; ft < Xe.length - 1; ft++) {
        var mt = ot;
        ot = 0;
        for (var yt = rt & 67108863, pt = Math.min(ft, We.length - 1), Ge = Math.max(0, ft - gt.length + 1); Ge <= pt; Ge++) {
          var ct = ft - Ge, Mt = gt.words[ct] | 0, St = We.words[Ge] | 0, At = Mt * St, Nt = At & 67108863;
          mt = mt + (At / 67108864 | 0) | 0, Nt = Nt + yt | 0, yt = Nt & 67108863, mt = mt + (Nt >>> 26) | 0, ot += mt >>> 26, mt &= 67108863;
        }
        Xe.words[ft] = yt, rt = mt, mt = ot;
      }
      return rt !== 0 ? Xe.words[ft] = rt : Xe.length--, Xe.strip();
    }
    function Et(gt, We, Xe) {
      var rt = new Tt();
      return rt.mulp(gt, We, Xe);
    }
    Ve.prototype.mulTo = function(We, Xe) {
      var rt, ot = (this || _global$c).length + We.length;
      return (this || _global$c).length === 10 && We.length === 10 ? rt = wt(this || _global$c, We, Xe) : ot < 63 ? rt = vt(this || _global$c, We, Xe) : ot < 1024 ? rt = xt(this || _global$c, We, Xe) : rt = Et(this || _global$c, We, Xe), rt;
    };
    function Tt(gt, We) {
      (this || _global$c).x = gt, (this || _global$c).y = We;
    }
    Tt.prototype.makeRBT = function(We) {
      for (var Xe = new Array(We), rt = Ve.prototype._countBits(We) - 1, ot = 0; ot < We; ot++)
        Xe[ot] = this.revBin(ot, rt, We);
      return Xe;
    }, Tt.prototype.revBin = function(We, Xe, rt) {
      if (We === 0 || We === rt - 1)
        return We;
      for (var ot = 0, ft = 0; ft < Xe; ft++)
        ot |= (We & 1) << Xe - ft - 1, We >>= 1;
      return ot;
    }, Tt.prototype.permute = function(We, Xe, rt, ot, ft, mt) {
      for (var yt = 0; yt < mt; yt++)
        ot[yt] = Xe[We[yt]], ft[yt] = rt[We[yt]];
    }, Tt.prototype.transform = function(We, Xe, rt, ot, ft, mt) {
      this.permute(mt, We, Xe, rt, ot, ft);
      for (var yt = 1; yt < ft; yt <<= 1)
        for (var pt = yt << 1, Ge = Math.cos(2 * Math.PI / pt), ct = Math.sin(2 * Math.PI / pt), Mt = 0; Mt < ft; Mt += pt)
          for (var St = Ge, At = ct, Nt = 0; Nt < yt; Nt++) {
            var qt = rt[Mt + Nt], Qt = ot[Mt + Nt], Xt = rt[Mt + Nt + yt], zt = ot[Mt + Nt + yt], Kt = St * Xt - At * zt;
            zt = St * zt + At * Xt, Xt = Kt, rt[Mt + Nt] = qt + Xt, ot[Mt + Nt] = Qt + zt, rt[Mt + Nt + yt] = qt - Xt, ot[Mt + Nt + yt] = Qt - zt, Nt !== pt && (Kt = Ge * St - ct * At, At = Ge * At + ct * St, St = Kt);
          }
    }, Tt.prototype.guessLen13b = function(We, Xe) {
      var rt = Math.max(Xe, We) | 1, ot = rt & 1, ft = 0;
      for (rt = rt / 2 | 0; rt; rt = rt >>> 1)
        ft++;
      return 1 << ft + 1 + ot;
    }, Tt.prototype.conjugate = function(We, Xe, rt) {
      if (!(rt <= 1))
        for (var ot = 0; ot < rt / 2; ot++) {
          var ft = We[ot];
          We[ot] = We[rt - ot - 1], We[rt - ot - 1] = ft, ft = Xe[ot], Xe[ot] = -Xe[rt - ot - 1], Xe[rt - ot - 1] = -ft;
        }
    }, Tt.prototype.normalize13b = function(We, Xe) {
      for (var rt = 0, ot = 0; ot < Xe / 2; ot++) {
        var ft = Math.round(We[2 * ot + 1] / Xe) * 8192 + Math.round(We[2 * ot] / Xe) + rt;
        We[ot] = ft & 67108863, ft < 67108864 ? rt = 0 : rt = ft / 67108864 | 0;
      }
      return We;
    }, Tt.prototype.convert13b = function(We, Xe, rt, ot) {
      for (var ft = 0, mt = 0; mt < Xe; mt++)
        ft = ft + (We[mt] | 0), rt[2 * mt] = ft & 8191, ft = ft >>> 13, rt[2 * mt + 1] = ft & 8191, ft = ft >>> 13;
      for (mt = 2 * Xe; mt < ot; ++mt)
        rt[mt] = 0;
      Fe(ft === 0), Fe((ft & -8192) === 0);
    }, Tt.prototype.stub = function(We) {
      for (var Xe = new Array(We), rt = 0; rt < We; rt++)
        Xe[rt] = 0;
      return Xe;
    }, Tt.prototype.mulp = function(We, Xe, rt) {
      var ot = 2 * this.guessLen13b(We.length, Xe.length), ft = this.makeRBT(ot), mt = this.stub(ot), yt = new Array(ot), pt = new Array(ot), Ge = new Array(ot), ct = new Array(ot), Mt = new Array(ot), St = new Array(ot), At = rt.words;
      At.length = ot, this.convert13b(We.words, We.length, yt, ot), this.convert13b(Xe.words, Xe.length, ct, ot), this.transform(yt, mt, pt, Ge, ot, ft), this.transform(ct, mt, Mt, St, ot, ft);
      for (var Nt = 0; Nt < ot; Nt++) {
        var qt = pt[Nt] * Mt[Nt] - Ge[Nt] * St[Nt];
        Ge[Nt] = pt[Nt] * St[Nt] + Ge[Nt] * Mt[Nt], pt[Nt] = qt;
      }
      return this.conjugate(pt, Ge, ot), this.transform(pt, Ge, At, mt, ot, ft), this.conjugate(At, mt, ot), this.normalize13b(At, ot), rt.negative = We.negative ^ Xe.negative, rt.length = We.length + Xe.length, rt.strip();
    }, Ve.prototype.mul = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$c).length + We.length), this.mulTo(We, Xe);
    }, Ve.prototype.mulf = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$c).length + We.length), Et(this || _global$c, We, Xe);
    }, Ve.prototype.imul = function(We) {
      return this.clone().mulTo(We, this || _global$c);
    }, Ve.prototype.imuln = function(We) {
      Fe(typeof We == "number"), Fe(We < 67108864);
      for (var Xe = 0, rt = 0; rt < (this || _global$c).length; rt++) {
        var ot = ((this || _global$c).words[rt] | 0) * We, ft = (ot & 67108863) + (Xe & 67108863);
        Xe >>= 26, Xe += ot / 67108864 | 0, Xe += ft >>> 26, (this || _global$c).words[rt] = ft & 67108863;
      }
      return Xe !== 0 && ((this || _global$c).words[rt] = Xe, (this || _global$c).length++), this || _global$c;
    }, Ve.prototype.muln = function(We) {
      return this.clone().imuln(We);
    }, Ve.prototype.sqr = function() {
      return this.mul(this || _global$c);
    }, Ve.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Ve.prototype.pow = function(We) {
      var Xe = $t(We);
      if (Xe.length === 0)
        return new Ve(1);
      for (var rt = this || _global$c, ot = 0; ot < Xe.length && Xe[ot] === 0; ot++, rt = rt.sqr())
        ;
      if (++ot < Xe.length)
        for (var ft = rt.sqr(); ot < Xe.length; ot++, ft = ft.sqr())
          Xe[ot] !== 0 && (rt = rt.mul(ft));
      return rt;
    }, Ve.prototype.iushln = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 67108863 >>> 26 - Xe << 26 - Xe, ft;
      if (Xe !== 0) {
        var mt = 0;
        for (ft = 0; ft < (this || _global$c).length; ft++) {
          var yt = (this || _global$c).words[ft] & ot, pt = ((this || _global$c).words[ft] | 0) - yt << Xe;
          (this || _global$c).words[ft] = pt | mt, mt = yt >>> 26 - Xe;
        }
        mt && ((this || _global$c).words[ft] = mt, (this || _global$c).length++);
      }
      if (rt !== 0) {
        for (ft = (this || _global$c).length - 1; ft >= 0; ft--)
          (this || _global$c).words[ft + rt] = (this || _global$c).words[ft];
        for (ft = 0; ft < rt; ft++)
          (this || _global$c).words[ft] = 0;
        (this || _global$c).length += rt;
      }
      return this.strip();
    }, Ve.prototype.ishln = function(We) {
      return Fe((this || _global$c).negative === 0), this.iushln(We);
    }, Ve.prototype.iushrn = function(We, Xe, rt) {
      Fe(typeof We == "number" && We >= 0);
      var ot;
      Xe ? ot = (Xe - Xe % 26) / 26 : ot = 0;
      var ft = We % 26, mt = Math.min((We - ft) / 26, (this || _global$c).length), yt = 67108863 ^ 67108863 >>> ft << ft, pt = rt;
      if (ot -= mt, ot = Math.max(0, ot), pt) {
        for (var Ge = 0; Ge < mt; Ge++)
          pt.words[Ge] = (this || _global$c).words[Ge];
        pt.length = mt;
      }
      if (mt !== 0)
        if ((this || _global$c).length > mt)
          for ((this || _global$c).length -= mt, Ge = 0; Ge < (this || _global$c).length; Ge++)
            (this || _global$c).words[Ge] = (this || _global$c).words[Ge + mt];
        else
          (this || _global$c).words[0] = 0, (this || _global$c).length = 1;
      var ct = 0;
      for (Ge = (this || _global$c).length - 1; Ge >= 0 && (ct !== 0 || Ge >= ot); Ge--) {
        var Mt = (this || _global$c).words[Ge] | 0;
        (this || _global$c).words[Ge] = ct << 26 - ft | Mt >>> ft, ct = Mt & yt;
      }
      return pt && ct !== 0 && (pt.words[pt.length++] = ct), (this || _global$c).length === 0 && ((this || _global$c).words[0] = 0, (this || _global$c).length = 1), this.strip();
    }, Ve.prototype.ishrn = function(We, Xe, rt) {
      return Fe((this || _global$c).negative === 0), this.iushrn(We, Xe, rt);
    }, Ve.prototype.shln = function(We) {
      return this.clone().ishln(We);
    }, Ve.prototype.ushln = function(We) {
      return this.clone().iushln(We);
    }, Ve.prototype.shrn = function(We) {
      return this.clone().ishrn(We);
    }, Ve.prototype.ushrn = function(We) {
      return this.clone().iushrn(We);
    }, Ve.prototype.testn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$c).length <= rt)
        return !1;
      var ft = (this || _global$c).words[rt];
      return !!(ft & ot);
    }, Ve.prototype.imaskn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26;
      if (Fe((this || _global$c).negative === 0, "imaskn works only with positive numbers"), (this || _global$c).length <= rt)
        return this || _global$c;
      if (Xe !== 0 && rt++, (this || _global$c).length = Math.min(rt, (this || _global$c).length), Xe !== 0) {
        var ot = 67108863 ^ 67108863 >>> Xe << Xe;
        (this || _global$c).words[(this || _global$c).length - 1] &= ot;
      }
      return this.strip();
    }, Ve.prototype.maskn = function(We) {
      return this.clone().imaskn(We);
    }, Ve.prototype.iaddn = function(We) {
      return Fe(typeof We == "number"), Fe(We < 67108864), We < 0 ? this.isubn(-We) : (this || _global$c).negative !== 0 ? (this || _global$c).length === 1 && ((this || _global$c).words[0] | 0) < We ? ((this || _global$c).words[0] = We - ((this || _global$c).words[0] | 0), (this || _global$c).negative = 0, this || _global$c) : ((this || _global$c).negative = 0, this.isubn(We), (this || _global$c).negative = 1, this || _global$c) : this._iaddn(We);
    }, Ve.prototype._iaddn = function(We) {
      (this || _global$c).words[0] += We;
      for (var Xe = 0; Xe < (this || _global$c).length && (this || _global$c).words[Xe] >= 67108864; Xe++)
        (this || _global$c).words[Xe] -= 67108864, Xe === (this || _global$c).length - 1 ? (this || _global$c).words[Xe + 1] = 1 : (this || _global$c).words[Xe + 1]++;
      return (this || _global$c).length = Math.max((this || _global$c).length, Xe + 1), this || _global$c;
    }, Ve.prototype.isubn = function(We) {
      if (Fe(typeof We == "number"), Fe(We < 67108864), We < 0)
        return this.iaddn(-We);
      if ((this || _global$c).negative !== 0)
        return (this || _global$c).negative = 0, this.iaddn(We), (this || _global$c).negative = 1, this || _global$c;
      if ((this || _global$c).words[0] -= We, (this || _global$c).length === 1 && (this || _global$c).words[0] < 0)
        (this || _global$c).words[0] = -(this || _global$c).words[0], (this || _global$c).negative = 1;
      else
        for (var Xe = 0; Xe < (this || _global$c).length && (this || _global$c).words[Xe] < 0; Xe++)
          (this || _global$c).words[Xe] += 67108864, (this || _global$c).words[Xe + 1] -= 1;
      return this.strip();
    }, Ve.prototype.addn = function(We) {
      return this.clone().iaddn(We);
    }, Ve.prototype.subn = function(We) {
      return this.clone().isubn(We);
    }, Ve.prototype.iabs = function() {
      return (this || _global$c).negative = 0, this || _global$c;
    }, Ve.prototype.abs = function() {
      return this.clone().iabs();
    }, Ve.prototype._ishlnsubmul = function(We, Xe, rt) {
      var ot = We.length + rt, ft;
      this._expand(ot);
      var mt, yt = 0;
      for (ft = 0; ft < We.length; ft++) {
        mt = ((this || _global$c).words[ft + rt] | 0) + yt;
        var pt = (We.words[ft] | 0) * Xe;
        mt -= pt & 67108863, yt = (mt >> 26) - (pt / 67108864 | 0), (this || _global$c).words[ft + rt] = mt & 67108863;
      }
      for (; ft < (this || _global$c).length - rt; ft++)
        mt = ((this || _global$c).words[ft + rt] | 0) + yt, yt = mt >> 26, (this || _global$c).words[ft + rt] = mt & 67108863;
      if (yt === 0)
        return this.strip();
      for (Fe(yt === -1), yt = 0, ft = 0; ft < (this || _global$c).length; ft++)
        mt = -((this || _global$c).words[ft] | 0) + yt, yt = mt >> 26, (this || _global$c).words[ft] = mt & 67108863;
      return (this || _global$c).negative = 1, this.strip();
    }, Ve.prototype._wordDiv = function(We, Xe) {
      var rt = (this || _global$c).length - We.length, ot = this.clone(), ft = We, mt = ft.words[ft.length - 1] | 0, yt = this._countBits(mt);
      rt = 26 - yt, rt !== 0 && (ft = ft.ushln(rt), ot.iushln(rt), mt = ft.words[ft.length - 1] | 0);
      var pt = ot.length - ft.length, Ge;
      if (Xe !== "mod") {
        Ge = new Ve(null), Ge.length = pt + 1, Ge.words = new Array(Ge.length);
        for (var ct = 0; ct < Ge.length; ct++)
          Ge.words[ct] = 0;
      }
      var Mt = ot.clone()._ishlnsubmul(ft, 1, pt);
      Mt.negative === 0 && (ot = Mt, Ge && (Ge.words[pt] = 1));
      for (var St = pt - 1; St >= 0; St--) {
        var At = (ot.words[ft.length + St] | 0) * 67108864 + (ot.words[ft.length + St - 1] | 0);
        for (At = Math.min(At / mt | 0, 67108863), ot._ishlnsubmul(ft, At, St); ot.negative !== 0; )
          At--, ot.negative = 0, ot._ishlnsubmul(ft, 1, St), ot.isZero() || (ot.negative ^= 1);
        Ge && (Ge.words[St] = At);
      }
      return Ge && Ge.strip(), ot.strip(), Xe !== "div" && rt !== 0 && ot.iushrn(rt), {
        div: Ge || null,
        mod: ot
      };
    }, Ve.prototype.divmod = function(We, Xe, rt) {
      if (Fe(!We.isZero()), this.isZero())
        return {
          div: new Ve(0),
          mod: new Ve(0)
        };
      var ot, ft, mt;
      return (this || _global$c).negative !== 0 && We.negative === 0 ? (mt = this.neg().divmod(We, Xe), Xe !== "mod" && (ot = mt.div.neg()), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.iadd(We)), {
        div: ot,
        mod: ft
      }) : (this || _global$c).negative === 0 && We.negative !== 0 ? (mt = this.divmod(We.neg(), Xe), Xe !== "mod" && (ot = mt.div.neg()), {
        div: ot,
        mod: mt.mod
      }) : (this || _global$c).negative & We.negative ? (mt = this.neg().divmod(We.neg(), Xe), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.isub(We)), {
        div: mt.div,
        mod: ft
      }) : We.length > (this || _global$c).length || this.cmp(We) < 0 ? {
        div: new Ve(0),
        mod: this || _global$c
      } : We.length === 1 ? Xe === "div" ? {
        div: this.divn(We.words[0]),
        mod: null
      } : Xe === "mod" ? {
        div: null,
        mod: new Ve(this.modn(We.words[0]))
      } : {
        div: this.divn(We.words[0]),
        mod: new Ve(this.modn(We.words[0]))
      } : this._wordDiv(We, Xe);
    }, Ve.prototype.div = function(We) {
      return this.divmod(We, "div", !1).div;
    }, Ve.prototype.mod = function(We) {
      return this.divmod(We, "mod", !1).mod;
    }, Ve.prototype.umod = function(We) {
      return this.divmod(We, "mod", !0).mod;
    }, Ve.prototype.divRound = function(We) {
      var Xe = this.divmod(We);
      if (Xe.mod.isZero())
        return Xe.div;
      var rt = Xe.div.negative !== 0 ? Xe.mod.isub(We) : Xe.mod, ot = We.ushrn(1), ft = We.andln(1), mt = rt.cmp(ot);
      return mt < 0 || ft === 1 && mt === 0 ? Xe.div : Xe.div.negative !== 0 ? Xe.div.isubn(1) : Xe.div.iaddn(1);
    }, Ve.prototype.modn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = (1 << 26) % We, rt = 0, ot = (this || _global$c).length - 1; ot >= 0; ot--)
        rt = (Xe * rt + ((this || _global$c).words[ot] | 0)) % We;
      return rt;
    }, Ve.prototype.idivn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = 0, rt = (this || _global$c).length - 1; rt >= 0; rt--) {
        var ot = ((this || _global$c).words[rt] | 0) + Xe * 67108864;
        (this || _global$c).words[rt] = ot / We | 0, Xe = ot % We;
      }
      return this.strip();
    }, Ve.prototype.divn = function(We) {
      return this.clone().idivn(We);
    }, Ve.prototype.egcd = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$c, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = new Ve(0), yt = new Ve(1), pt = 0; Xe.isEven() && rt.isEven(); )
        Xe.iushrn(1), rt.iushrn(1), ++pt;
      for (var Ge = rt.clone(), ct = Xe.clone(); !Xe.isZero(); ) {
        for (var Mt = 0, St = 1; !(Xe.words[0] & St) && Mt < 26; ++Mt, St <<= 1)
          ;
        if (Mt > 0)
          for (Xe.iushrn(Mt); Mt-- > 0; )
            (ot.isOdd() || ft.isOdd()) && (ot.iadd(Ge), ft.isub(ct)), ot.iushrn(1), ft.iushrn(1);
        for (var At = 0, Nt = 1; !(rt.words[0] & Nt) && At < 26; ++At, Nt <<= 1)
          ;
        if (At > 0)
          for (rt.iushrn(At); At-- > 0; )
            (mt.isOdd() || yt.isOdd()) && (mt.iadd(Ge), yt.isub(ct)), mt.iushrn(1), yt.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(mt), ft.isub(yt)) : (rt.isub(Xe), mt.isub(ot), yt.isub(ft));
      }
      return {
        a: mt,
        b: yt,
        gcd: rt.iushln(pt)
      };
    }, Ve.prototype._invmp = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$c, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = rt.clone(); Xe.cmpn(1) > 0 && rt.cmpn(1) > 0; ) {
        for (var yt = 0, pt = 1; !(Xe.words[0] & pt) && yt < 26; ++yt, pt <<= 1)
          ;
        if (yt > 0)
          for (Xe.iushrn(yt); yt-- > 0; )
            ot.isOdd() && ot.iadd(mt), ot.iushrn(1);
        for (var Ge = 0, ct = 1; !(rt.words[0] & ct) && Ge < 26; ++Ge, ct <<= 1)
          ;
        if (Ge > 0)
          for (rt.iushrn(Ge); Ge-- > 0; )
            ft.isOdd() && ft.iadd(mt), ft.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(ft)) : (rt.isub(Xe), ft.isub(ot));
      }
      var Mt;
      return Xe.cmpn(1) === 0 ? Mt = ot : Mt = ft, Mt.cmpn(0) < 0 && Mt.iadd(We), Mt;
    }, Ve.prototype.gcd = function(We) {
      if (this.isZero())
        return We.abs();
      if (We.isZero())
        return this.abs();
      var Xe = this.clone(), rt = We.clone();
      Xe.negative = 0, rt.negative = 0;
      for (var ot = 0; Xe.isEven() && rt.isEven(); ot++)
        Xe.iushrn(1), rt.iushrn(1);
      do {
        for (; Xe.isEven(); )
          Xe.iushrn(1);
        for (; rt.isEven(); )
          rt.iushrn(1);
        var ft = Xe.cmp(rt);
        if (ft < 0) {
          var mt = Xe;
          Xe = rt, rt = mt;
        } else if (ft === 0 || rt.cmpn(1) === 0)
          break;
        Xe.isub(rt);
      } while (!0);
      return rt.iushln(ot);
    }, Ve.prototype.invm = function(We) {
      return this.egcd(We).a.umod(We);
    }, Ve.prototype.isEven = function() {
      return ((this || _global$c).words[0] & 1) === 0;
    }, Ve.prototype.isOdd = function() {
      return ((this || _global$c).words[0] & 1) === 1;
    }, Ve.prototype.andln = function(We) {
      return (this || _global$c).words[0] & We;
    }, Ve.prototype.bincn = function(We) {
      Fe(typeof We == "number");
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$c).length <= rt)
        return this._expand(rt + 1), (this || _global$c).words[rt] |= ot, this || _global$c;
      for (var ft = ot, mt = rt; ft !== 0 && mt < (this || _global$c).length; mt++) {
        var yt = (this || _global$c).words[mt] | 0;
        yt += ft, ft = yt >>> 26, yt &= 67108863, (this || _global$c).words[mt] = yt;
      }
      return ft !== 0 && ((this || _global$c).words[mt] = ft, (this || _global$c).length++), this || _global$c;
    }, Ve.prototype.isZero = function() {
      return (this || _global$c).length === 1 && (this || _global$c).words[0] === 0;
    }, Ve.prototype.cmpn = function(We) {
      var Xe = We < 0;
      if ((this || _global$c).negative !== 0 && !Xe)
        return -1;
      if ((this || _global$c).negative === 0 && Xe)
        return 1;
      this.strip();
      var rt;
      if ((this || _global$c).length > 1)
        rt = 1;
      else {
        Xe && (We = -We), Fe(We <= 67108863, "Number is too big");
        var ot = (this || _global$c).words[0] | 0;
        rt = ot === We ? 0 : ot < We ? -1 : 1;
      }
      return (this || _global$c).negative !== 0 ? -rt | 0 : rt;
    }, Ve.prototype.cmp = function(We) {
      if ((this || _global$c).negative !== 0 && We.negative === 0)
        return -1;
      if ((this || _global$c).negative === 0 && We.negative !== 0)
        return 1;
      var Xe = this.ucmp(We);
      return (this || _global$c).negative !== 0 ? -Xe | 0 : Xe;
    }, Ve.prototype.ucmp = function(We) {
      if ((this || _global$c).length > We.length)
        return 1;
      if ((this || _global$c).length < We.length)
        return -1;
      for (var Xe = 0, rt = (this || _global$c).length - 1; rt >= 0; rt--) {
        var ot = (this || _global$c).words[rt] | 0, ft = We.words[rt] | 0;
        if (ot !== ft) {
          ot < ft ? Xe = -1 : ot > ft && (Xe = 1);
          break;
        }
      }
      return Xe;
    }, Ve.prototype.gtn = function(We) {
      return this.cmpn(We) === 1;
    }, Ve.prototype.gt = function(We) {
      return this.cmp(We) === 1;
    }, Ve.prototype.gten = function(We) {
      return this.cmpn(We) >= 0;
    }, Ve.prototype.gte = function(We) {
      return this.cmp(We) >= 0;
    }, Ve.prototype.ltn = function(We) {
      return this.cmpn(We) === -1;
    }, Ve.prototype.lt = function(We) {
      return this.cmp(We) === -1;
    }, Ve.prototype.lten = function(We) {
      return this.cmpn(We) <= 0;
    }, Ve.prototype.lte = function(We) {
      return this.cmp(We) <= 0;
    }, Ve.prototype.eqn = function(We) {
      return this.cmpn(We) === 0;
    }, Ve.prototype.eq = function(We) {
      return this.cmp(We) === 0;
    }, Ve.red = function(We) {
      return new Ot(We);
    }, Ve.prototype.toRed = function(We) {
      return Fe(!(this || _global$c).red, "Already a number in reduction context"), Fe((this || _global$c).negative === 0, "red works only with positives"), We.convertTo(this || _global$c)._forceRed(We);
    }, Ve.prototype.fromRed = function() {
      return Fe((this || _global$c).red, "fromRed works only with numbers in reduction context"), (this || _global$c).red.convertFrom(this || _global$c);
    }, Ve.prototype._forceRed = function(We) {
      return (this || _global$c).red = We, this || _global$c;
    }, Ve.prototype.forceRed = function(We) {
      return Fe(!(this || _global$c).red, "Already a number in reduction context"), this._forceRed(We);
    }, Ve.prototype.redAdd = function(We) {
      return Fe((this || _global$c).red, "redAdd works only with red numbers"), (this || _global$c).red.add(this || _global$c, We);
    }, Ve.prototype.redIAdd = function(We) {
      return Fe((this || _global$c).red, "redIAdd works only with red numbers"), (this || _global$c).red.iadd(this || _global$c, We);
    }, Ve.prototype.redSub = function(We) {
      return Fe((this || _global$c).red, "redSub works only with red numbers"), (this || _global$c).red.sub(this || _global$c, We);
    }, Ve.prototype.redISub = function(We) {
      return Fe((this || _global$c).red, "redISub works only with red numbers"), (this || _global$c).red.isub(this || _global$c, We);
    }, Ve.prototype.redShl = function(We) {
      return Fe((this || _global$c).red, "redShl works only with red numbers"), (this || _global$c).red.shl(this || _global$c, We);
    }, Ve.prototype.redMul = function(We) {
      return Fe((this || _global$c).red, "redMul works only with red numbers"), (this || _global$c).red._verify2(this || _global$c, We), (this || _global$c).red.mul(this || _global$c, We);
    }, Ve.prototype.redIMul = function(We) {
      return Fe((this || _global$c).red, "redMul works only with red numbers"), (this || _global$c).red._verify2(this || _global$c, We), (this || _global$c).red.imul(this || _global$c, We);
    }, Ve.prototype.redSqr = function() {
      return Fe((this || _global$c).red, "redSqr works only with red numbers"), (this || _global$c).red._verify1(this || _global$c), (this || _global$c).red.sqr(this || _global$c);
    }, Ve.prototype.redISqr = function() {
      return Fe((this || _global$c).red, "redISqr works only with red numbers"), (this || _global$c).red._verify1(this || _global$c), (this || _global$c).red.isqr(this || _global$c);
    }, Ve.prototype.redSqrt = function() {
      return Fe((this || _global$c).red, "redSqrt works only with red numbers"), (this || _global$c).red._verify1(this || _global$c), (this || _global$c).red.sqrt(this || _global$c);
    }, Ve.prototype.redInvm = function() {
      return Fe((this || _global$c).red, "redInvm works only with red numbers"), (this || _global$c).red._verify1(this || _global$c), (this || _global$c).red.invm(this || _global$c);
    }, Ve.prototype.redNeg = function() {
      return Fe((this || _global$c).red, "redNeg works only with red numbers"), (this || _global$c).red._verify1(this || _global$c), (this || _global$c).red.neg(this || _global$c);
    }, Ve.prototype.redPow = function(We) {
      return Fe((this || _global$c).red && !We.red, "redPow(normalNum)"), (this || _global$c).red._verify1(this || _global$c), (this || _global$c).red.pow(this || _global$c, We);
    };
    var Rt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ct(gt, We) {
      (this || _global$c).name = gt, (this || _global$c).p = new Ve(We, 16), (this || _global$c).n = (this || _global$c).p.bitLength(), (this || _global$c).k = new Ve(1).iushln((this || _global$c).n).isub((this || _global$c).p), (this || _global$c).tmp = this._tmp();
    }
    Ct.prototype._tmp = function() {
      var We = new Ve(null);
      return We.words = new Array(Math.ceil((this || _global$c).n / 13)), We;
    }, Ct.prototype.ireduce = function(We) {
      var Xe = We, rt;
      do
        this.split(Xe, (this || _global$c).tmp), Xe = this.imulK(Xe), Xe = Xe.iadd((this || _global$c).tmp), rt = Xe.bitLength();
      while (rt > (this || _global$c).n);
      var ot = rt < (this || _global$c).n ? -1 : Xe.ucmp((this || _global$c).p);
      return ot === 0 ? (Xe.words[0] = 0, Xe.length = 1) : ot > 0 ? Xe.isub((this || _global$c).p) : Xe.strip !== void 0 ? Xe.strip() : Xe._strip(), Xe;
    }, Ct.prototype.split = function(We, Xe) {
      We.iushrn((this || _global$c).n, 0, Xe);
    }, Ct.prototype.imulK = function(We) {
      return We.imul((this || _global$c).k);
    };
    function Zt() {
      Ct.call(this || _global$c, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    Ke(Zt, Ct), Zt.prototype.split = function(We, Xe) {
      for (var rt = 4194303, ot = Math.min(We.length, 9), ft = 0; ft < ot; ft++)
        Xe.words[ft] = We.words[ft];
      if (Xe.length = ot, We.length <= 9) {
        We.words[0] = 0, We.length = 1;
        return;
      }
      var mt = We.words[9];
      for (Xe.words[Xe.length++] = mt & rt, ft = 10; ft < We.length; ft++) {
        var yt = We.words[ft] | 0;
        We.words[ft - 10] = (yt & rt) << 4 | mt >>> 22, mt = yt;
      }
      mt >>>= 22, We.words[ft - 10] = mt, mt === 0 && We.length > 10 ? We.length -= 10 : We.length -= 9;
    }, Zt.prototype.imulK = function(We) {
      We.words[We.length] = 0, We.words[We.length + 1] = 0, We.length += 2;
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = We.words[rt] | 0;
        Xe += ot * 977, We.words[rt] = Xe & 67108863, Xe = ot * 64 + (Xe / 67108864 | 0);
      }
      return We.words[We.length - 1] === 0 && (We.length--, We.words[We.length - 1] === 0 && We.length--), We;
    };
    function Lt() {
      Ct.call(this || _global$c, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    Ke(Lt, Ct);
    function Ut() {
      Ct.call(this || _global$c, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    Ke(Ut, Ct);
    function Pt() {
      Ct.call(this || _global$c, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    Ke(Pt, Ct), Pt.prototype.imulK = function(We) {
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = (We.words[rt] | 0) * 19 + Xe, ft = ot & 67108863;
        ot >>>= 26, We.words[rt] = ft, Xe = ot;
      }
      return Xe !== 0 && (We.words[We.length++] = Xe), We;
    }, Ve._prime = function(We) {
      if (Rt[We])
        return Rt[We];
      var Xe;
      if (We === "k256")
        Xe = new Zt();
      else if (We === "p224")
        Xe = new Lt();
      else if (We === "p192")
        Xe = new Ut();
      else if (We === "p25519")
        Xe = new Pt();
      else
        throw new Error("Unknown prime " + We);
      return Rt[We] = Xe, Xe;
    };
    function Ot(gt) {
      if (typeof gt == "string") {
        var We = Ve._prime(gt);
        (this || _global$c).m = We.p, (this || _global$c).prime = We;
      } else
        Fe(gt.gtn(1), "modulus must be greater than 1"), (this || _global$c).m = gt, (this || _global$c).prime = null;
    }
    Ot.prototype._verify1 = function(We) {
      Fe(We.negative === 0, "red works only with positives"), Fe(We.red, "red works only with red numbers");
    }, Ot.prototype._verify2 = function(We, Xe) {
      Fe((We.negative | Xe.negative) === 0, "red works only with positives"), Fe(We.red && We.red === Xe.red, "red works only with red numbers");
    }, Ot.prototype.imod = function(We) {
      return (this || _global$c).prime ? (this || _global$c).prime.ireduce(We)._forceRed(this || _global$c) : We.umod((this || _global$c).m)._forceRed(this || _global$c);
    }, Ot.prototype.neg = function(We) {
      return We.isZero() ? We.clone() : (this || _global$c).m.sub(We)._forceRed(this || _global$c);
    }, Ot.prototype.add = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.add(Xe);
      return rt.cmp((this || _global$c).m) >= 0 && rt.isub((this || _global$c).m), rt._forceRed(this || _global$c);
    }, Ot.prototype.iadd = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.iadd(Xe);
      return rt.cmp((this || _global$c).m) >= 0 && rt.isub((this || _global$c).m), rt;
    }, Ot.prototype.sub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.sub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$c).m), rt._forceRed(this || _global$c);
    }, Ot.prototype.isub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.isub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$c).m), rt;
    }, Ot.prototype.shl = function(We, Xe) {
      return this._verify1(We), this.imod(We.ushln(Xe));
    }, Ot.prototype.imul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.imul(Xe));
    }, Ot.prototype.mul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.mul(Xe));
    }, Ot.prototype.isqr = function(We) {
      return this.imul(We, We.clone());
    }, Ot.prototype.sqr = function(We) {
      return this.mul(We, We);
    }, Ot.prototype.sqrt = function(We) {
      if (We.isZero())
        return We.clone();
      var Xe = (this || _global$c).m.andln(3);
      if (Fe(Xe % 2 === 1), Xe === 3) {
        var rt = (this || _global$c).m.add(new Ve(1)).iushrn(2);
        return this.pow(We, rt);
      }
      for (var ot = (this || _global$c).m.subn(1), ft = 0; !ot.isZero() && ot.andln(1) === 0; )
        ft++, ot.iushrn(1);
      Fe(!ot.isZero());
      var mt = new Ve(1).toRed(this || _global$c), yt = mt.redNeg(), pt = (this || _global$c).m.subn(1).iushrn(1), Ge = (this || _global$c).m.bitLength();
      for (Ge = new Ve(2 * Ge * Ge).toRed(this || _global$c); this.pow(Ge, pt).cmp(yt) !== 0; )
        Ge.redIAdd(yt);
      for (var ct = this.pow(Ge, ot), Mt = this.pow(We, ot.addn(1).iushrn(1)), St = this.pow(We, ot), At = ft; St.cmp(mt) !== 0; ) {
        for (var Nt = St, qt = 0; Nt.cmp(mt) !== 0; qt++)
          Nt = Nt.redSqr();
        Fe(qt < At);
        var Qt = this.pow(ct, new Ve(1).iushln(At - qt - 1));
        Mt = Mt.redMul(Qt), ct = Qt.redSqr(), St = St.redMul(ct), At = qt;
      }
      return Mt;
    }, Ot.prototype.invm = function(We) {
      var Xe = We._invmp((this || _global$c).m);
      return Xe.negative !== 0 ? (Xe.negative = 0, this.imod(Xe).redNeg()) : this.imod(Xe);
    }, Ot.prototype.pow = function(We, Xe) {
      if (Xe.isZero())
        return new Ve(1).toRed(this || _global$c);
      if (Xe.cmpn(1) === 0)
        return We.clone();
      var rt = 4, ot = new Array(1 << rt);
      ot[0] = new Ve(1).toRed(this || _global$c), ot[1] = We;
      for (var ft = 2; ft < ot.length; ft++)
        ot[ft] = this.mul(ot[ft - 1], We);
      var mt = ot[0], yt = 0, pt = 0, Ge = Xe.bitLength() % 26;
      for (Ge === 0 && (Ge = 26), ft = Xe.length - 1; ft >= 0; ft--) {
        for (var ct = Xe.words[ft], Mt = Ge - 1; Mt >= 0; Mt--) {
          var St = ct >> Mt & 1;
          if (mt !== ot[0] && (mt = this.sqr(mt)), St === 0 && yt === 0) {
            pt = 0;
            continue;
          }
          yt <<= 1, yt |= St, pt++, !(pt !== rt && (ft !== 0 || Mt !== 0)) && (mt = this.mul(mt, ot[yt]), pt = 0, yt = 0);
        }
        Ge = 26;
      }
      return mt;
    }, Ot.prototype.convertTo = function(We) {
      var Xe = We.umod((this || _global$c).m);
      return Xe === We ? Xe.clone() : Xe;
    }, Ot.prototype.convertFrom = function(We) {
      var Xe = We.clone();
      return Xe.red = null, Xe;
    }, Ve.mont = function(We) {
      return new Ft(We);
    };
    function Ft(gt) {
      Ot.call(this || _global$c, gt), (this || _global$c).shift = (this || _global$c).m.bitLength(), (this || _global$c).shift % 26 !== 0 && ((this || _global$c).shift += 26 - (this || _global$c).shift % 26), (this || _global$c).r = new Ve(1).iushln((this || _global$c).shift), (this || _global$c).r2 = this.imod((this || _global$c).r.sqr()), (this || _global$c).rinv = (this || _global$c).r._invmp((this || _global$c).m), (this || _global$c).minv = (this || _global$c).rinv.mul((this || _global$c).r).isubn(1).div((this || _global$c).m), (this || _global$c).minv = (this || _global$c).minv.umod((this || _global$c).r), (this || _global$c).minv = (this || _global$c).r.sub((this || _global$c).minv);
    }
    Ke(Ft, Ot), Ft.prototype.convertTo = function(We) {
      return this.imod(We.ushln((this || _global$c).shift));
    }, Ft.prototype.convertFrom = function(We) {
      var Xe = this.imod(We.mul((this || _global$c).rinv));
      return Xe.red = null, Xe;
    }, Ft.prototype.imul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return We.words[0] = 0, We.length = 1, We;
      var rt = We.imul(Xe), ot = rt.maskn((this || _global$c).shift).mul((this || _global$c).minv).imaskn((this || _global$c).shift).mul((this || _global$c).m), ft = rt.isub(ot).iushrn((this || _global$c).shift), mt = ft;
      return ft.cmp((this || _global$c).m) >= 0 ? mt = ft.isub((this || _global$c).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$c).m)), mt._forceRed(this || _global$c);
    }, Ft.prototype.mul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return new Ve(0)._forceRed(this || _global$c);
      var rt = We.mul(Xe), ot = rt.maskn((this || _global$c).shift).mul((this || _global$c).minv).imaskn((this || _global$c).shift).mul((this || _global$c).m), ft = rt.isub(ot).iushrn((this || _global$c).shift), mt = ft;
      return ft.cmp((this || _global$c).m) >= 0 ? mt = ft.isub((this || _global$c).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$c).m)), mt._forceRed(this || _global$c);
    }, Ft.prototype.invm = function(We) {
      var Xe = this.imod(We._invmp((this || _global$c).m).mul((this || _global$c).r2));
      return Xe._forceRed(this || _global$c);
    };
  }(module$5, exports$12$1)), module$5.exports;
}
var _global$b = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, exports$11$1 = {}, indexOf = function($e, Ze) {
  if ($e.indexOf)
    return $e.indexOf(Ze);
  for (var Fe = 0; Fe < $e.length; Fe++)
    if ($e[Fe] === Ze)
      return Fe;
  return -1;
}, Object_keys = function($e) {
  if (Object.keys)
    return Object.keys($e);
  var Ze = [];
  for (var Fe in $e)
    Ze.push(Fe);
  return Ze;
}, forEach2 = function($e, Ze) {
  if ($e.forEach)
    return $e.forEach(Ze);
  for (var Fe = 0; Fe < $e.length; Fe++)
    Ze($e[Fe], Fe, $e);
}, defineProp = function() {
  try {
    return Object.defineProperty({}, "_", {}), function($e, Ze, Fe) {
      Object.defineProperty($e, Ze, { writable: !0, enumerable: !1, configurable: !0, value: Fe });
    };
  } catch {
    return function(Ze, Fe, Ke) {
      Ze[Fe] = Ke;
    };
  }
}(), globals = ["Array", "Boolean", "Date", "Error", "EvalError", "Function", "Infinity", "JSON", "Math", "NaN", "Number", "Object", "RangeError", "ReferenceError", "RegExp", "String", "SyntaxError", "TypeError", "URIError", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "undefined", "unescape"];
function Context() {
}
Context.prototype = {};
var Script = exports$11$1.Script = function($e) {
  if (!((this || _global$b) instanceof Script))
    return new Script($e);
  (this || _global$b).code = $e;
};
Script.prototype.runInContext = function($e) {
  if (!($e instanceof Context))
    throw new TypeError("needs a 'context' argument.");
  var Ze = document.createElement("iframe");
  Ze.style || (Ze.style = {}), Ze.style.display = "none", document.body.appendChild(Ze);
  var Fe = Ze.contentWindow, Ke = Fe.eval, Ve = Fe.execScript;
  !Ke && Ve && (Ve.call(Fe, "null"), Ke = Fe.eval), forEach2(Object_keys($e), function(at) {
    Fe[at] = $e[at];
  }), forEach2(globals, function(at) {
    $e[at] && (Fe[at] = $e[at]);
  });
  var Je = Object_keys(Fe), Qe = Ke.call(Fe, (this || _global$b).code);
  return forEach2(Object_keys(Fe), function(at) {
    (at in $e || indexOf(Je, at) === -1) && ($e[at] = Fe[at]);
  }), forEach2(globals, function(at) {
    at in $e || defineProp($e, at, Fe[at]);
  }), document.body.removeChild(Ze), Qe;
}, Script.prototype.runInThisContext = function() {
  return eval((this || _global$b).code);
}, Script.prototype.runInNewContext = function($e) {
  var Ze = Script.createContext($e), Fe = this.runInContext(Ze);
  return $e && forEach2(Object_keys(Ze), function(Ke) {
    $e[Ke] = Ze[Ke];
  }), Fe;
}, forEach2(Object_keys(Script.prototype), function($e) {
  exports$11$1[$e] = Script[$e] = function(Ze) {
    var Fe = Script(Ze);
    return Fe[$e].apply(Fe, [].slice.call(arguments, 1));
  };
}), exports$11$1.isContext = function($e) {
  return $e instanceof Context;
}, exports$11$1.createScript = function($e) {
  return exports$11$1.Script($e);
}, exports$11$1.createContext = Script.createContext = function($e) {
  var Ze = new Context();
  return typeof $e == "object" && forEach2(Object_keys($e), function(Fe) {
    Ze[Fe] = $e[Fe];
  }), Ze;
};
exports$11$1.Script;
exports$11$1.createContext;
exports$11$1.createScript;
exports$11$1.isContext;
exports$11$1.runInContext;
exports$11$1.runInNewContext;
exports$11$1.runInThisContext;
var o5 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, n5 = T, t5 = u4.Buffer, f5 = o5.crypto || o5.msCrypto, a5 = f5 && f5.getRandomValues ? function($e, Ze) {
  if ($e > 4294967295)
    throw new RangeError("requested too many random bytes");
  var Fe = t5.allocUnsafe($e);
  if ($e > 0)
    if ($e > 65536)
      for (var Ke = 0; Ke < $e; Ke += 65536)
        f5.getRandomValues(Fe.slice(Ke, Ke + 65536));
    else
      f5.getRandomValues(Fe);
  return typeof Ze == "function" ? n5.nextTick(function() {
    Ze(null, Fe);
  }) : Fe;
} : function() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}, e7 = u4.Buffer, o$13 = b$i.Transform;
function s5($e) {
  o$13.call(this), this._block = e7.allocUnsafe($e), this._blockSize = $e, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
t$2(s5, o$13), s5.prototype._transform = function($e, Ze, Fe) {
  var Ke = null;
  try {
    this.update($e, Ze);
  } catch (Ve) {
    Ke = Ve;
  }
  Fe(Ke);
}, s5.prototype._flush = function($e) {
  var Ze = null;
  try {
    this.push(this.digest());
  } catch (Fe) {
    Ze = Fe;
  }
  $e(Ze);
}, s5.prototype.update = function($e, Ze) {
  if (function(at, ut) {
    if (!e7.isBuffer(at) && typeof at != "string")
      throw new TypeError(ut + " must be a string or a buffer");
  }($e, "Data"), this._finalized)
    throw new Error("Digest already called");
  e7.isBuffer($e) || ($e = e7.from($e, Ze));
  for (var Fe = this._block, Ke = 0; this._blockOffset + $e.length - Ke >= this._blockSize; ) {
    for (var Ve = this._blockOffset; Ve < this._blockSize; )
      Fe[Ve++] = $e[Ke++];
    this._update(), this._blockOffset = 0;
  }
  for (; Ke < $e.length; )
    Fe[this._blockOffset++] = $e[Ke++];
  for (var Je = 0, Qe = 8 * $e.length; Qe > 0; ++Je)
    this._length[Je] += Qe, (Qe = this._length[Je] / 4294967296 | 0) > 0 && (this._length[Je] -= 4294967296 * Qe);
  return this;
}, s5.prototype._update = function() {
  throw new Error("_update is not implemented");
}, s5.prototype.digest = function($e) {
  if (this._finalized)
    throw new Error("Digest already called");
  this._finalized = !0;
  var Ze = this._digest();
  $e !== void 0 && (Ze = Ze.toString($e)), this._block.fill(0), this._blockOffset = 0;
  for (var Fe = 0; Fe < 4; ++Fe)
    this._length[Fe] = 0;
  return Ze;
}, s5.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var f$12 = s5, h5 = t$2, r5 = f$12, _3 = u4.Buffer, e$13 = new Array(16);
function n$13() {
  r5.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
function o$22($e, Ze) {
  return $e << Ze | $e >>> 32 - Ze;
}
function f$22($e, Ze, Fe, Ke, Ve, Je, Qe) {
  return o$22($e + (Ze & Fe | ~Ze & Ke) + Ve + Je | 0, Qe) + Ze | 0;
}
function c5($e, Ze, Fe, Ke, Ve, Je, Qe) {
  return o$22($e + (Ze & Ke | Fe & ~Ke) + Ve + Je | 0, Qe) + Ze | 0;
}
function a$1$2($e, Ze, Fe, Ke, Ve, Je, Qe) {
  return o$22($e + (Ze ^ Fe ^ Ke) + Ve + Je | 0, Qe) + Ze | 0;
}
function l5($e, Ze, Fe, Ke, Ve, Je, Qe) {
  return o$22($e + (Fe ^ (Ze | ~Ke)) + Ve + Je | 0, Qe) + Ze | 0;
}
h5(n$13, r5), n$13.prototype._update = function() {
  for (var $e = e$13, Ze = 0; Ze < 16; ++Ze)
    $e[Ze] = this._block.readInt32LE(4 * Ze);
  var Fe = this._a, Ke = this._b, Ve = this._c, Je = this._d;
  Fe = f$22(Fe, Ke, Ve, Je, $e[0], 3614090360, 7), Je = f$22(Je, Fe, Ke, Ve, $e[1], 3905402710, 12), Ve = f$22(Ve, Je, Fe, Ke, $e[2], 606105819, 17), Ke = f$22(Ke, Ve, Je, Fe, $e[3], 3250441966, 22), Fe = f$22(Fe, Ke, Ve, Je, $e[4], 4118548399, 7), Je = f$22(Je, Fe, Ke, Ve, $e[5], 1200080426, 12), Ve = f$22(Ve, Je, Fe, Ke, $e[6], 2821735955, 17), Ke = f$22(Ke, Ve, Je, Fe, $e[7], 4249261313, 22), Fe = f$22(Fe, Ke, Ve, Je, $e[8], 1770035416, 7), Je = f$22(Je, Fe, Ke, Ve, $e[9], 2336552879, 12), Ve = f$22(Ve, Je, Fe, Ke, $e[10], 4294925233, 17), Ke = f$22(Ke, Ve, Je, Fe, $e[11], 2304563134, 22), Fe = f$22(Fe, Ke, Ve, Je, $e[12], 1804603682, 7), Je = f$22(Je, Fe, Ke, Ve, $e[13], 4254626195, 12), Ve = f$22(Ve, Je, Fe, Ke, $e[14], 2792965006, 17), Fe = c5(Fe, Ke = f$22(Ke, Ve, Je, Fe, $e[15], 1236535329, 22), Ve, Je, $e[1], 4129170786, 5), Je = c5(Je, Fe, Ke, Ve, $e[6], 3225465664, 9), Ve = c5(Ve, Je, Fe, Ke, $e[11], 643717713, 14), Ke = c5(Ke, Ve, Je, Fe, $e[0], 3921069994, 20), Fe = c5(Fe, Ke, Ve, Je, $e[5], 3593408605, 5), Je = c5(Je, Fe, Ke, Ve, $e[10], 38016083, 9), Ve = c5(Ve, Je, Fe, Ke, $e[15], 3634488961, 14), Ke = c5(Ke, Ve, Je, Fe, $e[4], 3889429448, 20), Fe = c5(Fe, Ke, Ve, Je, $e[9], 568446438, 5), Je = c5(Je, Fe, Ke, Ve, $e[14], 3275163606, 9), Ve = c5(Ve, Je, Fe, Ke, $e[3], 4107603335, 14), Ke = c5(Ke, Ve, Je, Fe, $e[8], 1163531501, 20), Fe = c5(Fe, Ke, Ve, Je, $e[13], 2850285829, 5), Je = c5(Je, Fe, Ke, Ve, $e[2], 4243563512, 9), Ve = c5(Ve, Je, Fe, Ke, $e[7], 1735328473, 14), Fe = a$1$2(Fe, Ke = c5(Ke, Ve, Je, Fe, $e[12], 2368359562, 20), Ve, Je, $e[5], 4294588738, 4), Je = a$1$2(Je, Fe, Ke, Ve, $e[8], 2272392833, 11), Ve = a$1$2(Ve, Je, Fe, Ke, $e[11], 1839030562, 16), Ke = a$1$2(Ke, Ve, Je, Fe, $e[14], 4259657740, 23), Fe = a$1$2(Fe, Ke, Ve, Je, $e[1], 2763975236, 4), Je = a$1$2(Je, Fe, Ke, Ve, $e[4], 1272893353, 11), Ve = a$1$2(Ve, Je, Fe, Ke, $e[7], 4139469664, 16), Ke = a$1$2(Ke, Ve, Je, Fe, $e[10], 3200236656, 23), Fe = a$1$2(Fe, Ke, Ve, Je, $e[13], 681279174, 4), Je = a$1$2(Je, Fe, Ke, Ve, $e[0], 3936430074, 11), Ve = a$1$2(Ve, Je, Fe, Ke, $e[3], 3572445317, 16), Ke = a$1$2(Ke, Ve, Je, Fe, $e[6], 76029189, 23), Fe = a$1$2(Fe, Ke, Ve, Je, $e[9], 3654602809, 4), Je = a$1$2(Je, Fe, Ke, Ve, $e[12], 3873151461, 11), Ve = a$1$2(Ve, Je, Fe, Ke, $e[15], 530742520, 16), Fe = l5(Fe, Ke = a$1$2(Ke, Ve, Je, Fe, $e[2], 3299628645, 23), Ve, Je, $e[0], 4096336452, 6), Je = l5(Je, Fe, Ke, Ve, $e[7], 1126891415, 10), Ve = l5(Ve, Je, Fe, Ke, $e[14], 2878612391, 15), Ke = l5(Ke, Ve, Je, Fe, $e[5], 4237533241, 21), Fe = l5(Fe, Ke, Ve, Je, $e[12], 1700485571, 6), Je = l5(Je, Fe, Ke, Ve, $e[3], 2399980690, 10), Ve = l5(Ve, Je, Fe, Ke, $e[10], 4293915773, 15), Ke = l5(Ke, Ve, Je, Fe, $e[1], 2240044497, 21), Fe = l5(Fe, Ke, Ve, Je, $e[8], 1873313359, 6), Je = l5(Je, Fe, Ke, Ve, $e[15], 4264355552, 10), Ve = l5(Ve, Je, Fe, Ke, $e[6], 2734768916, 15), Ke = l5(Ke, Ve, Je, Fe, $e[13], 1309151649, 21), Fe = l5(Fe, Ke, Ve, Je, $e[4], 4149444226, 6), Je = l5(Je, Fe, Ke, Ve, $e[11], 3174756917, 10), Ve = l5(Ve, Je, Fe, Ke, $e[2], 718787259, 15), Ke = l5(Ke, Ve, Je, Fe, $e[9], 3951481745, 21), this._a = this._a + Fe | 0, this._b = this._b + Ke | 0, this._c = this._c + Ve | 0, this._d = this._d + Je | 0;
}, n$13.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var $e = _3.allocUnsafe(16);
  return $e.writeInt32LE(this._a, 0), $e.writeInt32LE(this._b, 4), $e.writeInt32LE(this._c, 8), $e.writeInt32LE(this._d, 12), $e;
};
var u5 = n$13, h$1 = e$1$1$1.Buffer, _$1 = t$2, r$12 = f$12, e$2$2 = new Array(16), n$2$2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], o$3 = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], f$3 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], c$13 = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], a$22 = [0, 1518500249, 1859775393, 2400959708, 2840853838], l$13 = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function u$13() {
  r$12.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
function b3($e, Ze) {
  return $e << Ze | $e >>> 32 - Ze;
}
function d4($e, Ze, Fe, Ke, Ve, Je, Qe, at) {
  return b3($e + (Ze ^ Fe ^ Ke) + Je + Qe | 0, at) + Ve | 0;
}
function k3($e, Ze, Fe, Ke, Ve, Je, Qe, at) {
  return b3($e + (Ze & Fe | ~Ze & Ke) + Je + Qe | 0, at) + Ve | 0;
}
function p5($e, Ze, Fe, Ke, Ve, Je, Qe, at) {
  return b3($e + ((Ze | ~Fe) ^ Ke) + Je + Qe | 0, at) + Ve | 0;
}
function w3($e, Ze, Fe, Ke, Ve, Je, Qe, at) {
  return b3($e + (Ze & Ke | Fe & ~Ke) + Je + Qe | 0, at) + Ve | 0;
}
function E3($e, Ze, Fe, Ke, Ve, Je, Qe, at) {
  return b3($e + (Ze ^ (Fe | ~Ke)) + Je + Qe | 0, at) + Ve | 0;
}
_$1(u$13, r$12), u$13.prototype._update = function() {
  for (var $e = e$2$2, Ze = 0; Ze < 16; ++Ze)
    $e[Ze] = this._block.readInt32LE(4 * Ze);
  for (var Fe = 0 | this._a, Ke = 0 | this._b, Ve = 0 | this._c, Je = 0 | this._d, Qe = 0 | this._e, at = 0 | this._a, ut = 0 | this._b, lt = 0 | this._c, dt = 0 | this._d, bt = 0 | this._e, $t = 0; $t < 80; $t += 1) {
    var vt, wt;
    $t < 16 ? (vt = d4(Fe, Ke, Ve, Je, Qe, $e[n$2$2[$t]], a$22[0], f$3[$t]), wt = E3(at, ut, lt, dt, bt, $e[o$3[$t]], l$13[0], c$13[$t])) : $t < 32 ? (vt = k3(Fe, Ke, Ve, Je, Qe, $e[n$2$2[$t]], a$22[1], f$3[$t]), wt = w3(at, ut, lt, dt, bt, $e[o$3[$t]], l$13[1], c$13[$t])) : $t < 48 ? (vt = p5(Fe, Ke, Ve, Je, Qe, $e[n$2$2[$t]], a$22[2], f$3[$t]), wt = p5(at, ut, lt, dt, bt, $e[o$3[$t]], l$13[2], c$13[$t])) : $t < 64 ? (vt = w3(Fe, Ke, Ve, Je, Qe, $e[n$2$2[$t]], a$22[3], f$3[$t]), wt = k3(at, ut, lt, dt, bt, $e[o$3[$t]], l$13[3], c$13[$t])) : (vt = E3(Fe, Ke, Ve, Je, Qe, $e[n$2$2[$t]], a$22[4], f$3[$t]), wt = d4(at, ut, lt, dt, bt, $e[o$3[$t]], l$13[4], c$13[$t])), Fe = Qe, Qe = Je, Je = b3(Ve, 10), Ve = Ke, Ke = vt, at = bt, bt = dt, dt = b3(lt, 10), lt = ut, ut = wt;
  }
  var xt = this._b + Ve + dt | 0;
  this._b = this._c + Je + bt | 0, this._c = this._d + Qe + at | 0, this._d = this._e + Fe + ut | 0, this._e = this._a + Ke + lt | 0, this._a = xt;
}, u$13.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var $e = h$1.alloc ? h$1.alloc(20) : new h$1(20);
  return $e.writeInt32LE(this._a, 0), $e.writeInt32LE(this._b, 4), $e.writeInt32LE(this._c, 8), $e.writeInt32LE(this._d, 12), $e.writeInt32LE(this._e, 16), $e;
};
var I3 = u$13, s$12 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, h$2 = u4.Buffer;
function e$3($e, Ze) {
  (this || s$12)._block = h$2.alloc($e), (this || s$12)._finalSize = Ze, (this || s$12)._blockSize = $e, (this || s$12)._len = 0;
}
e$3.prototype.update = function($e, Ze) {
  typeof $e == "string" && (Ze = Ze || "utf8", $e = h$2.from($e, Ze));
  for (var Fe = (this || s$12)._block, Ke = (this || s$12)._blockSize, Ve = $e.length, Je = (this || s$12)._len, Qe = 0; Qe < Ve; ) {
    for (var at = Je % Ke, ut = Math.min(Ve - Qe, Ke - at), lt = 0; lt < ut; lt++)
      Fe[at + lt] = $e[Qe + lt];
    Qe += ut, (Je += ut) % Ke == 0 && this._update(Fe);
  }
  return (this || s$12)._len += Ve, this || s$12;
}, e$3.prototype.digest = function($e) {
  var Ze = (this || s$12)._len % (this || s$12)._blockSize;
  (this || s$12)._block[Ze] = 128, (this || s$12)._block.fill(0, Ze + 1), Ze >= (this || s$12)._finalSize && (this._update((this || s$12)._block), (this || s$12)._block.fill(0));
  var Fe = 8 * (this || s$12)._len;
  if (Fe <= 4294967295)
    (this || s$12)._block.writeUInt32BE(Fe, (this || s$12)._blockSize - 4);
  else {
    var Ke = (4294967295 & Fe) >>> 0, Ve = (Fe - Ke) / 4294967296;
    (this || s$12)._block.writeUInt32BE(Ve, (this || s$12)._blockSize - 8), (this || s$12)._block.writeUInt32BE(Ke, (this || s$12)._blockSize - 4);
  }
  this._update((this || s$12)._block);
  var Je = this._hash();
  return $e ? Je.toString($e) : Je;
}, e$3.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var _$2 = e$3, n$3 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, r$2$2 = t$2, o$4 = _$2, f$4 = u4.Buffer, l$2 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], a$3 = new Array(64);
function u$22() {
  this.init(), (this || n$3)._w = a$3, o$4.call(this || n$3, 64, 56);
}
function c$2($e, Ze, Fe) {
  return Fe ^ $e & (Ze ^ Fe);
}
function b$1($e, Ze, Fe) {
  return $e & Ze | Fe & ($e | Ze);
}
function p$1$2($e) {
  return ($e >>> 2 | $e << 30) ^ ($e >>> 13 | $e << 19) ^ ($e >>> 22 | $e << 10);
}
function d$1($e) {
  return ($e >>> 6 | $e << 26) ^ ($e >>> 11 | $e << 21) ^ ($e >>> 25 | $e << 7);
}
function k$1$2($e) {
  return ($e >>> 7 | $e << 25) ^ ($e >>> 18 | $e << 14) ^ $e >>> 3;
}
r$2$2(u$22, o$4), u$22.prototype.init = function() {
  return (this || n$3)._a = 1779033703, (this || n$3)._b = 3144134277, (this || n$3)._c = 1013904242, (this || n$3)._d = 2773480762, (this || n$3)._e = 1359893119, (this || n$3)._f = 2600822924, (this || n$3)._g = 528734635, (this || n$3)._h = 1541459225, this || n$3;
}, u$22.prototype._update = function($e) {
  for (var Ze, Fe = (this || n$3)._w, Ke = 0 | (this || n$3)._a, Ve = 0 | (this || n$3)._b, Je = 0 | (this || n$3)._c, Qe = 0 | (this || n$3)._d, at = 0 | (this || n$3)._e, ut = 0 | (this || n$3)._f, lt = 0 | (this || n$3)._g, dt = 0 | (this || n$3)._h, bt = 0; bt < 16; ++bt)
    Fe[bt] = $e.readInt32BE(4 * bt);
  for (; bt < 64; ++bt)
    Fe[bt] = 0 | (((Ze = Fe[bt - 2]) >>> 17 | Ze << 15) ^ (Ze >>> 19 | Ze << 13) ^ Ze >>> 10) + Fe[bt - 7] + k$1$2(Fe[bt - 15]) + Fe[bt - 16];
  for (var $t = 0; $t < 64; ++$t) {
    var vt = dt + d$1(at) + c$2(at, ut, lt) + l$2[$t] + Fe[$t] | 0, wt = p$1$2(Ke) + b$1(Ke, Ve, Je) | 0;
    dt = lt, lt = ut, ut = at, at = Qe + vt | 0, Qe = Je, Je = Ve, Ve = Ke, Ke = vt + wt | 0;
  }
  (this || n$3)._a = Ke + (this || n$3)._a | 0, (this || n$3)._b = Ve + (this || n$3)._b | 0, (this || n$3)._c = Je + (this || n$3)._c | 0, (this || n$3)._d = Qe + (this || n$3)._d | 0, (this || n$3)._e = at + (this || n$3)._e | 0, (this || n$3)._f = ut + (this || n$3)._f | 0, (this || n$3)._g = lt + (this || n$3)._g | 0, (this || n$3)._h = dt + (this || n$3)._h | 0;
}, u$22.prototype._hash = function() {
  var $e = f$4.allocUnsafe(32);
  return $e.writeInt32BE((this || n$3)._a, 0), $e.writeInt32BE((this || n$3)._b, 4), $e.writeInt32BE((this || n$3)._c, 8), $e.writeInt32BE((this || n$3)._d, 12), $e.writeInt32BE((this || n$3)._e, 16), $e.writeInt32BE((this || n$3)._f, 20), $e.writeInt32BE((this || n$3)._g, 24), $e.writeInt32BE((this || n$3)._h, 28), $e;
};
var w$1 = u$22, _$3 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, e$4 = t$2, n$4 = _$2, r$3 = u4.Buffer, l$3 = [1518500249, 1859775393, -1894007588, -899497514], o$5 = new Array(80);
function f$5() {
  this.init(), (this || _$3)._w = o$5, n$4.call(this || _$3, 64, 56);
}
function a$4($e) {
  return $e << 30 | $e >>> 2;
}
function u$3($e, Ze, Fe, Ke) {
  return $e === 0 ? Ze & Fe | ~Ze & Ke : $e === 2 ? Ze & Fe | Ze & Ke | Fe & Ke : Ze ^ Fe ^ Ke;
}
e$4(f$5, n$4), f$5.prototype.init = function() {
  return (this || _$3)._a = 1732584193, (this || _$3)._b = 4023233417, (this || _$3)._c = 2562383102, (this || _$3)._d = 271733878, (this || _$3)._e = 3285377520, this || _$3;
}, f$5.prototype._update = function($e) {
  for (var Ze, Fe = (this || _$3)._w, Ke = 0 | (this || _$3)._a, Ve = 0 | (this || _$3)._b, Je = 0 | (this || _$3)._c, Qe = 0 | (this || _$3)._d, at = 0 | (this || _$3)._e, ut = 0; ut < 16; ++ut)
    Fe[ut] = $e.readInt32BE(4 * ut);
  for (; ut < 80; ++ut)
    Fe[ut] = Fe[ut - 3] ^ Fe[ut - 8] ^ Fe[ut - 14] ^ Fe[ut - 16];
  for (var lt = 0; lt < 80; ++lt) {
    var dt = ~~(lt / 20), bt = 0 | ((Ze = Ke) << 5 | Ze >>> 27) + u$3(dt, Ve, Je, Qe) + at + Fe[lt] + l$3[dt];
    at = Qe, Qe = Je, Je = a$4(Ve), Ve = Ke, Ke = bt;
  }
  (this || _$3)._a = Ke + (this || _$3)._a | 0, (this || _$3)._b = Ve + (this || _$3)._b | 0, (this || _$3)._c = Je + (this || _$3)._c | 0, (this || _$3)._d = Qe + (this || _$3)._d | 0, (this || _$3)._e = at + (this || _$3)._e | 0;
}, f$5.prototype._hash = function() {
  var $e = r$3.allocUnsafe(20);
  return $e.writeInt32BE(0 | (this || _$3)._a, 0), $e.writeInt32BE(0 | (this || _$3)._b, 4), $e.writeInt32BE(0 | (this || _$3)._c, 8), $e.writeInt32BE(0 | (this || _$3)._d, 12), $e.writeInt32BE(0 | (this || _$3)._e, 16), $e;
};
var c$3 = f$5, d$2 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, p$2$2 = t$2, b$2 = _$2, w$2 = u4.Buffer, g3 = [1518500249, 1859775393, -1894007588, -899497514], B3 = new Array(80);
function y4() {
  this.init(), (this || d$2)._w = B3, b$2.call(this || d$2, 64, 56);
}
function E$1($e) {
  return $e << 5 | $e >>> 27;
}
function I$1($e) {
  return $e << 30 | $e >>> 2;
}
function v4($e, Ze, Fe, Ke) {
  return $e === 0 ? Ze & Fe | ~Ze & Ke : $e === 2 ? Ze & Fe | Ze & Ke | Fe & Ke : Ze ^ Fe ^ Ke;
}
p$2$2(y4, b$2), y4.prototype.init = function() {
  return (this || d$2)._a = 1732584193, (this || d$2)._b = 4023233417, (this || d$2)._c = 2562383102, (this || d$2)._d = 271733878, (this || d$2)._e = 3285377520, this || d$2;
}, y4.prototype._update = function($e) {
  for (var Ze, Fe = (this || d$2)._w, Ke = 0 | (this || d$2)._a, Ve = 0 | (this || d$2)._b, Je = 0 | (this || d$2)._c, Qe = 0 | (this || d$2)._d, at = 0 | (this || d$2)._e, ut = 0; ut < 16; ++ut)
    Fe[ut] = $e.readInt32BE(4 * ut);
  for (; ut < 80; ++ut)
    Fe[ut] = (Ze = Fe[ut - 3] ^ Fe[ut - 8] ^ Fe[ut - 14] ^ Fe[ut - 16]) << 1 | Ze >>> 31;
  for (var lt = 0; lt < 80; ++lt) {
    var dt = ~~(lt / 20), bt = E$1(Ke) + v4(dt, Ve, Je, Qe) + at + Fe[lt] + g3[dt] | 0;
    at = Qe, Qe = Je, Je = I$1(Ve), Ve = Ke, Ke = bt;
  }
  (this || d$2)._a = Ke + (this || d$2)._a | 0, (this || d$2)._b = Ve + (this || d$2)._b | 0, (this || d$2)._c = Je + (this || d$2)._c | 0, (this || d$2)._d = Qe + (this || d$2)._d | 0, (this || d$2)._e = at + (this || d$2)._e | 0;
}, y4.prototype._hash = function() {
  var $e = w$2.allocUnsafe(20);
  return $e.writeInt32BE(0 | (this || d$2)._a, 0), $e.writeInt32BE(0 | (this || d$2)._b, 4), $e.writeInt32BE(0 | (this || d$2)._c, 8), $e.writeInt32BE(0 | (this || d$2)._d, 12), $e.writeInt32BE(0 | (this || d$2)._e, 16), $e;
};
var T4 = y4, m4 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, A3 = t$2, U3 = w$1, x3 = _$2, j3 = u4.Buffer, q2 = new Array(64);
function C3() {
  this.init(), (this || m4)._w = q2, x3.call(this || m4, 64, 56);
}
A3(C3, U3), C3.prototype.init = function() {
  return (this || m4)._a = 3238371032, (this || m4)._b = 914150663, (this || m4)._c = 812702999, (this || m4)._d = 4144912697, (this || m4)._e = 4290775857, (this || m4)._f = 1750603025, (this || m4)._g = 1694076839, (this || m4)._h = 3204075428, this || m4;
}, C3.prototype._hash = function() {
  var $e = j3.allocUnsafe(28);
  return $e.writeInt32BE((this || m4)._a, 0), $e.writeInt32BE((this || m4)._b, 4), $e.writeInt32BE((this || m4)._c, 8), $e.writeInt32BE((this || m4)._d, 12), $e.writeInt32BE((this || m4)._e, 16), $e.writeInt32BE((this || m4)._f, 20), $e.writeInt32BE((this || m4)._g, 24), $e;
};
var L3 = C3, k$2$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, z3 = t$2, D3 = _$2, F3 = u4.Buffer, G2 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], H2 = new Array(160);
function J2() {
  this.init(), (this || k$2$1)._w = H2, D3.call(this || k$2$1, 128, 112);
}
function K2($e, Ze, Fe) {
  return Fe ^ $e & (Ze ^ Fe);
}
function M3($e, Ze, Fe) {
  return $e & Ze | Fe & ($e | Ze);
}
function N3($e, Ze) {
  return ($e >>> 28 | Ze << 4) ^ (Ze >>> 2 | $e << 30) ^ (Ze >>> 7 | $e << 25);
}
function O3($e, Ze) {
  return ($e >>> 14 | Ze << 18) ^ ($e >>> 18 | Ze << 14) ^ (Ze >>> 9 | $e << 23);
}
function P3($e, Ze) {
  return ($e >>> 1 | Ze << 31) ^ ($e >>> 8 | Ze << 24) ^ $e >>> 7;
}
function Q2($e, Ze) {
  return ($e >>> 1 | Ze << 31) ^ ($e >>> 8 | Ze << 24) ^ ($e >>> 7 | Ze << 25);
}
function R3($e, Ze) {
  return ($e >>> 19 | Ze << 13) ^ (Ze >>> 29 | $e << 3) ^ $e >>> 6;
}
function S3($e, Ze) {
  return ($e >>> 19 | Ze << 13) ^ (Ze >>> 29 | $e << 3) ^ ($e >>> 6 | Ze << 26);
}
function V2($e, Ze) {
  return $e >>> 0 < Ze >>> 0 ? 1 : 0;
}
z3(J2, D3), J2.prototype.init = function() {
  return (this || k$2$1)._ah = 1779033703, (this || k$2$1)._bh = 3144134277, (this || k$2$1)._ch = 1013904242, (this || k$2$1)._dh = 2773480762, (this || k$2$1)._eh = 1359893119, (this || k$2$1)._fh = 2600822924, (this || k$2$1)._gh = 528734635, (this || k$2$1)._hh = 1541459225, (this || k$2$1)._al = 4089235720, (this || k$2$1)._bl = 2227873595, (this || k$2$1)._cl = 4271175723, (this || k$2$1)._dl = 1595750129, (this || k$2$1)._el = 2917565137, (this || k$2$1)._fl = 725511199, (this || k$2$1)._gl = 4215389547, (this || k$2$1)._hl = 327033209, this || k$2$1;
}, J2.prototype._update = function($e) {
  for (var Ze = (this || k$2$1)._w, Fe = 0 | (this || k$2$1)._ah, Ke = 0 | (this || k$2$1)._bh, Ve = 0 | (this || k$2$1)._ch, Je = 0 | (this || k$2$1)._dh, Qe = 0 | (this || k$2$1)._eh, at = 0 | (this || k$2$1)._fh, ut = 0 | (this || k$2$1)._gh, lt = 0 | (this || k$2$1)._hh, dt = 0 | (this || k$2$1)._al, bt = 0 | (this || k$2$1)._bl, $t = 0 | (this || k$2$1)._cl, vt = 0 | (this || k$2$1)._dl, wt = 0 | (this || k$2$1)._el, xt = 0 | (this || k$2$1)._fl, Et = 0 | (this || k$2$1)._gl, Tt = 0 | (this || k$2$1)._hl, Rt = 0; Rt < 32; Rt += 2)
    Ze[Rt] = $e.readInt32BE(4 * Rt), Ze[Rt + 1] = $e.readInt32BE(4 * Rt + 4);
  for (; Rt < 160; Rt += 2) {
    var Ct = Ze[Rt - 30], Zt = Ze[Rt - 30 + 1], Lt = P3(Ct, Zt), Ut = Q2(Zt, Ct), Pt = R3(Ct = Ze[Rt - 4], Zt = Ze[Rt - 4 + 1]), Ot = S3(Zt, Ct), Ft = Ze[Rt - 14], gt = Ze[Rt - 14 + 1], We = Ze[Rt - 32], Xe = Ze[Rt - 32 + 1], rt = Ut + gt | 0, ot = Lt + Ft + V2(rt, Ut) | 0;
    ot = (ot = ot + Pt + V2(rt = rt + Ot | 0, Ot) | 0) + We + V2(rt = rt + Xe | 0, Xe) | 0, Ze[Rt] = ot, Ze[Rt + 1] = rt;
  }
  for (var ft = 0; ft < 160; ft += 2) {
    ot = Ze[ft], rt = Ze[ft + 1];
    var mt = M3(Fe, Ke, Ve), yt = M3(dt, bt, $t), pt = N3(Fe, dt), Ge = N3(dt, Fe), ct = O3(Qe, wt), Mt = O3(wt, Qe), St = G2[ft], At = G2[ft + 1], Nt = K2(Qe, at, ut), qt = K2(wt, xt, Et), Qt = Tt + Mt | 0, Xt = lt + ct + V2(Qt, Tt) | 0;
    Xt = (Xt = (Xt = Xt + Nt + V2(Qt = Qt + qt | 0, qt) | 0) + St + V2(Qt = Qt + At | 0, At) | 0) + ot + V2(Qt = Qt + rt | 0, rt) | 0;
    var zt = Ge + yt | 0, Kt = pt + mt + V2(zt, Ge) | 0;
    lt = ut, Tt = Et, ut = at, Et = xt, at = Qe, xt = wt, Qe = Je + Xt + V2(wt = vt + Qt | 0, vt) | 0, Je = Ve, vt = $t, Ve = Ke, $t = bt, Ke = Fe, bt = dt, Fe = Xt + Kt + V2(dt = Qt + zt | 0, Qt) | 0;
  }
  (this || k$2$1)._al = (this || k$2$1)._al + dt | 0, (this || k$2$1)._bl = (this || k$2$1)._bl + bt | 0, (this || k$2$1)._cl = (this || k$2$1)._cl + $t | 0, (this || k$2$1)._dl = (this || k$2$1)._dl + vt | 0, (this || k$2$1)._el = (this || k$2$1)._el + wt | 0, (this || k$2$1)._fl = (this || k$2$1)._fl + xt | 0, (this || k$2$1)._gl = (this || k$2$1)._gl + Et | 0, (this || k$2$1)._hl = (this || k$2$1)._hl + Tt | 0, (this || k$2$1)._ah = (this || k$2$1)._ah + Fe + V2((this || k$2$1)._al, dt) | 0, (this || k$2$1)._bh = (this || k$2$1)._bh + Ke + V2((this || k$2$1)._bl, bt) | 0, (this || k$2$1)._ch = (this || k$2$1)._ch + Ve + V2((this || k$2$1)._cl, $t) | 0, (this || k$2$1)._dh = (this || k$2$1)._dh + Je + V2((this || k$2$1)._dl, vt) | 0, (this || k$2$1)._eh = (this || k$2$1)._eh + Qe + V2((this || k$2$1)._el, wt) | 0, (this || k$2$1)._fh = (this || k$2$1)._fh + at + V2((this || k$2$1)._fl, xt) | 0, (this || k$2$1)._gh = (this || k$2$1)._gh + ut + V2((this || k$2$1)._gl, Et) | 0, (this || k$2$1)._hh = (this || k$2$1)._hh + lt + V2((this || k$2$1)._hl, Tt) | 0;
}, J2.prototype._hash = function() {
  var $e = F3.allocUnsafe(64);
  function Ze(Fe, Ke, Ve) {
    $e.writeInt32BE(Fe, Ve), $e.writeInt32BE(Ke, Ve + 4);
  }
  return Ze((this || k$2$1)._ah, (this || k$2$1)._al, 0), Ze((this || k$2$1)._bh, (this || k$2$1)._bl, 8), Ze((this || k$2$1)._ch, (this || k$2$1)._cl, 16), Ze((this || k$2$1)._dh, (this || k$2$1)._dl, 24), Ze((this || k$2$1)._eh, (this || k$2$1)._el, 32), Ze((this || k$2$1)._fh, (this || k$2$1)._fl, 40), Ze((this || k$2$1)._gh, (this || k$2$1)._gl, 48), Ze((this || k$2$1)._hh, (this || k$2$1)._hl, 56), $e;
};
var W2 = J2, X2 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, Y3 = t$2, Z2 = W2, $2 = _$2, tt = u4.Buffer, it = new Array(160);
function ht() {
  this.init(), (this || X2)._w = it, $2.call(this || X2, 128, 112);
}
Y3(ht, Z2), ht.prototype.init = function() {
  return (this || X2)._ah = 3418070365, (this || X2)._bh = 1654270250, (this || X2)._ch = 2438529370, (this || X2)._dh = 355462360, (this || X2)._eh = 1731405415, (this || X2)._fh = 2394180231, (this || X2)._gh = 3675008525, (this || X2)._hh = 1203062813, (this || X2)._al = 3238371032, (this || X2)._bl = 914150663, (this || X2)._cl = 812702999, (this || X2)._dl = 4144912697, (this || X2)._el = 4290775857, (this || X2)._fl = 1750603025, (this || X2)._gl = 1694076839, (this || X2)._hl = 3204075428, this || X2;
}, ht.prototype._hash = function() {
  var $e = tt.allocUnsafe(48);
  function Ze(Fe, Ke, Ve) {
    $e.writeInt32BE(Fe, Ve), $e.writeInt32BE(Ke, Ve + 4);
  }
  return Ze((this || X2)._ah, (this || X2)._al, 0), Ze((this || X2)._bh, (this || X2)._bl, 8), Ze((this || X2)._ch, (this || X2)._cl, 16), Ze((this || X2)._dh, (this || X2)._dl, 24), Ze((this || X2)._eh, (this || X2)._el, 32), Ze((this || X2)._fh, (this || X2)._fl, 40), $e;
};
var st, _t = ht, et = { exports: st = {} };
(st = et.exports = function($e) {
  $e = $e.toLowerCase();
  var Ze = st[$e];
  if (!Ze)
    throw new Error($e + " is not supported (we accept pull requests)");
  return new Ze();
}).sha = c$3, st.sha1 = T4, st.sha224 = L3, st.sha256 = w$1, st.sha384 = _t, st.sha512 = W2;
var nt = et.exports, e$5 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, n$5 = u4.Buffer, s$2 = b$i.Transform, h$3 = e$12.StringDecoder;
function a$5($e) {
  s$2.call(this || e$5), (this || e$5).hashMode = typeof $e == "string", (this || e$5).hashMode ? (this || e$5)[$e] = (this || e$5)._finalOrDigest : (this || e$5).final = (this || e$5)._finalOrDigest, (this || e$5)._final && ((this || e$5).__final = (this || e$5)._final, (this || e$5)._final = null), (this || e$5)._decoder = null, (this || e$5)._encoding = null;
}
t$2(a$5, s$2), a$5.prototype.update = function($e, Ze, Fe) {
  typeof $e == "string" && ($e = n$5.from($e, Ze));
  var Ke = this._update($e);
  return (this || e$5).hashMode ? this || e$5 : (Fe && (Ke = this._toString(Ke, Fe)), Ke);
}, a$5.prototype.setAutoPadding = function() {
}, a$5.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
}, a$5.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
}, a$5.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
}, a$5.prototype._transform = function($e, Ze, Fe) {
  var Ke;
  try {
    (this || e$5).hashMode ? this._update($e) : this.push(this._update($e));
  } catch (Ve) {
    Ke = Ve;
  } finally {
    Fe(Ke);
  }
}, a$5.prototype._flush = function($e) {
  var Ze;
  try {
    this.push(this.__final());
  } catch (Fe) {
    Ze = Fe;
  }
  $e(Ze);
}, a$5.prototype._finalOrDigest = function($e) {
  var Ze = this.__final() || n$5.alloc(0);
  return $e && (Ze = this._toString(Ze, $e, !0)), Ze;
}, a$5.prototype._toString = function($e, Ze, Fe) {
  if ((this || e$5)._decoder || ((this || e$5)._decoder = new h$3(Ze), (this || e$5)._encoding = Ze), (this || e$5)._encoding !== Ze)
    throw new Error("can't switch encodings");
  var Ke = (this || e$5)._decoder.write($e);
  return Fe && (Ke += (this || e$5)._decoder.end()), Ke;
};
var f$6 = a$5, m$1 = u5, n$6 = I3, p$3 = nt, s$3 = f$6;
function a$6($e) {
  s$3.call(this, "digest"), this._hash = $e;
}
t$2(a$6, s$3), a$6.prototype._update = function($e) {
  this._hash.update($e);
}, a$6.prototype._final = function() {
  return this._hash.digest();
};
var h$4 = function($e) {
  return ($e = $e.toLowerCase()) === "md5" ? new m$1() : $e === "rmd160" || $e === "ripemd160" ? new n$6() : new a$6(p$3($e));
}, e$6 = u5, r$4 = function($e) {
  return new e$6().update($e).digest();
}, o$6 = t$2, h$5 = u4.Buffer, n$7 = f$6, p$4 = h$5.alloc(128);
function f$7($e, Ze) {
  n$7.call(this, "digest"), typeof Ze == "string" && (Ze = h$5.from(Ze)), this._alg = $e, this._key = Ze, Ze.length > 64 ? Ze = $e(Ze) : Ze.length < 64 && (Ze = h$5.concat([Ze, p$4], 64));
  for (var Fe = this._ipad = h$5.allocUnsafe(64), Ke = this._opad = h$5.allocUnsafe(64), Ve = 0; Ve < 64; Ve++)
    Fe[Ve] = 54 ^ Ze[Ve], Ke[Ve] = 92 ^ Ze[Ve];
  this._hash = [Fe];
}
o$6(f$7, n$7), f$7.prototype._update = function($e) {
  this._hash.push($e);
}, f$7.prototype._final = function() {
  var $e = this._alg(h$5.concat(this._hash));
  return this._alg(h$5.concat([this._opad, $e]));
};
var l$4 = t$2, d$3 = f$7, c$4 = f$6, _$4 = u4.Buffer, m$2 = r$4, u$4 = I3, g$1 = nt, v$1 = _$4.alloc(128);
function y$1($e, Ze) {
  c$4.call(this, "digest"), typeof Ze == "string" && (Ze = _$4.from(Ze));
  var Fe = $e === "sha512" || $e === "sha384" ? 128 : 64;
  this._alg = $e, this._key = Ze, Ze.length > Fe ? Ze = ($e === "rmd160" ? new u$4() : g$1($e)).update(Ze).digest() : Ze.length < Fe && (Ze = _$4.concat([Ze, v$1], Fe));
  for (var Ke = this._ipad = _$4.allocUnsafe(Fe), Ve = this._opad = _$4.allocUnsafe(Fe), Je = 0; Je < Fe; Je++)
    Ke[Je] = 54 ^ Ze[Je], Ve[Je] = 92 ^ Ze[Je];
  this._hash = $e === "rmd160" ? new u$4() : g$1($e), this._hash.update(Ke);
}
l$4(y$1, c$4), y$1.prototype._update = function($e) {
  this._hash.update($e);
}, y$1.prototype._final = function() {
  var $e = this._hash.digest();
  return (this._alg === "rmd160" ? new u$4() : g$1(this._alg)).update(this._opad).update($e).digest();
};
var w$3 = function($e, Ze) {
  return ($e = $e.toLowerCase()) === "rmd160" || $e === "ripemd160" ? new y$1("rmd160", Ze) : $e === "md5" ? new d$3(m$2, Ze) : new y$1($e, Ze);
}, s$4 = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } }, f$8 = e$1$1$1.Buffer, a$7 = Math.pow(2, 30) - 1;
function s$5($e, Ze) {
  if (typeof $e != "string" && !f$8.isBuffer($e))
    throw new TypeError(Ze + " must be a buffer or string");
}
var u$5, h$6 = function($e, Ze, Fe, Ke) {
  if (s$5($e, "Password"), s$5(Ze, "Salt"), typeof Fe != "number")
    throw new TypeError("Iterations not a number");
  if (Fe < 0)
    throw new TypeError("Bad iterations");
  if (typeof Ke != "number")
    throw new TypeError("Key length not a number");
  if (Ke < 0 || Ke > a$7 || Ke != Ke)
    throw new TypeError("Bad key length");
}, c$5 = T;
c$5.browser ? u$5 = "utf-8" : u$5 = parseInt(c$5.version.split(".")[0].slice(1), 10) >= 6 ? "utf-8" : "binary";
var l$5 = u$5, p$5 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, d$4 = r$4, m$3 = I3, y$2 = nt, b$3 = h$6, v$2 = l$5, w$4 = u4.Buffer, g$2 = w$4.alloc(128), B$1 = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
function T$1($e, Ze, Fe) {
  var Ke = function(lt) {
    function dt(bt) {
      return y$2(lt).update(bt).digest();
    }
    return lt === "rmd160" || lt === "ripemd160" ? function(bt) {
      return new m$3().update(bt).digest();
    } : lt === "md5" ? d$4 : dt;
  }($e), Ve = $e === "sha512" || $e === "sha384" ? 128 : 64;
  Ze.length > Ve ? Ze = Ke(Ze) : Ze.length < Ve && (Ze = w$4.concat([Ze, g$2], Ve));
  for (var Je = w$4.allocUnsafe(Ve + B$1[$e]), Qe = w$4.allocUnsafe(Ve + B$1[$e]), at = 0; at < Ve; at++)
    Je[at] = 54 ^ Ze[at], Qe[at] = 92 ^ Ze[at];
  var ut = w$4.allocUnsafe(Ve + Fe + 4);
  Je.copy(ut, 0, 0, Ve), (this || p$5).ipad1 = ut, (this || p$5).ipad2 = Je, (this || p$5).opad = Qe, (this || p$5).alg = $e, (this || p$5).blocksize = Ve, (this || p$5).hash = Ke, (this || p$5).size = B$1[$e];
}
T$1.prototype.run = function($e, Ze) {
  return $e.copy(Ze, (this || p$5).blocksize), this.hash(Ze).copy((this || p$5).opad, (this || p$5).blocksize), this.hash((this || p$5).opad);
};
var k$3, S$1 = function($e, Ze, Fe, Ke, Ve) {
  b$3($e, Ze, Fe, Ke), w$4.isBuffer($e) || ($e = w$4.from($e, v$2)), w$4.isBuffer(Ze) || (Ze = w$4.from(Ze, v$2));
  var Je = new T$1(Ve = Ve || "sha1", $e, Ze.length), Qe = w$4.allocUnsafe(Ke), at = w$4.allocUnsafe(Ze.length + 4);
  Ze.copy(at, 0, 0, Ze.length);
  for (var ut = 0, lt = B$1[Ve], dt = Math.ceil(Ke / lt), bt = 1; bt <= dt; bt++) {
    at.writeUInt32BE(bt, Ze.length);
    for (var $t = Je.run(at, Je.ipad1), vt = $t, wt = 1; wt < Fe; wt++) {
      vt = Je.run(vt, Je.ipad2);
      for (var xt = 0; xt < lt; xt++)
        $t[xt] ^= vt[xt];
    }
    $t.copy(Qe, ut), ut += lt;
  }
  return Qe;
}, A$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, H$1 = T, E$2 = h$6, P$1 = l$5, U$1 = S$1, K$1 = u4.Buffer, x$1 = A$1.crypto && A$1.crypto.subtle, z$1 = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, I$2 = [];
function D$1($e, Ze, Fe, Ke, Ve) {
  return x$1.importKey("raw", $e, { name: "PBKDF2" }, !1, ["deriveBits"]).then(function(Je) {
    return x$1.deriveBits({ name: "PBKDF2", salt: Ze, iterations: Fe, hash: { name: Ve } }, Je, Ke << 3);
  }).then(function(Je) {
    return K$1.from(Je);
  });
}
var F$1 = function($e, Ze, Fe, Ke, Ve, Je) {
  typeof Ve == "function" && (Je = Ve, Ve = void 0);
  var Qe = z$1[(Ve = Ve || "sha1").toLowerCase()];
  if (!Qe || typeof A$1.Promise != "function")
    return H$1.nextTick(function() {
      var at;
      try {
        at = U$1($e, Ze, Fe, Ke, Ve);
      } catch (ut) {
        return Je(ut);
      }
      Je(null, at);
    });
  if (E$2($e, Ze, Fe, Ke), typeof Je != "function")
    throw new Error("No callback provided to pbkdf2");
  K$1.isBuffer($e) || ($e = K$1.from($e, P$1)), K$1.isBuffer(Ze) || (Ze = K$1.from(Ze, P$1)), function(at, ut) {
    at.then(function(lt) {
      H$1.nextTick(function() {
        ut(null, lt);
      });
    }, function(lt) {
      H$1.nextTick(function() {
        ut(lt);
      });
    });
  }(function(at) {
    if (A$1.process && !A$1.process.browser || !x$1 || !x$1.importKey || !x$1.deriveBits)
      return Promise.resolve(!1);
    if (I$2[at] !== void 0)
      return I$2[at];
    var ut = D$1(k$3 = k$3 || K$1.alloc(8), k$3, 10, 128, at).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return I$2[at] = ut, ut;
  }(Qe).then(function(at) {
    return at ? D$1($e, Ze, Fe, Ke, Qe) : U$1($e, Ze, Fe, Ke, Ve);
  }), Je);
}, M$1$2 = {};
M$1$2.pbkdf2 = F$1, M$1$2.pbkdf2Sync = S$1;
var r$5;
function e$7($e, Ze) {
  if (!$e)
    throw new Error(Ze || "Assertion failed");
}
r$5 = e$7, e$7.equal = function($e, Ze, Fe) {
  if ($e != Ze)
    throw new Error(Fe || "Assertion failed: " + $e + " != " + Ze);
};
var o$7 = r$5, r$6 = { readUInt32BE: function($e, Ze) {
  return ($e[0 + Ze] << 24 | $e[1 + Ze] << 16 | $e[2 + Ze] << 8 | $e[3 + Ze]) >>> 0;
}, writeUInt32BE: function($e, Ze, Fe) {
  $e[0 + Fe] = Ze >>> 24, $e[1 + Fe] = Ze >>> 16 & 255, $e[2 + Fe] = Ze >>> 8 & 255, $e[3 + Fe] = 255 & Ze;
}, ip: function($e, Ze, Fe, Ke) {
  for (var Ve = 0, Je = 0, Qe = 6; Qe >= 0; Qe -= 2) {
    for (var at = 0; at <= 24; at += 8)
      Ve <<= 1, Ve |= Ze >>> at + Qe & 1;
    for (at = 0; at <= 24; at += 8)
      Ve <<= 1, Ve |= $e >>> at + Qe & 1;
  }
  for (Qe = 6; Qe >= 0; Qe -= 2) {
    for (at = 1; at <= 25; at += 8)
      Je <<= 1, Je |= Ze >>> at + Qe & 1;
    for (at = 1; at <= 25; at += 8)
      Je <<= 1, Je |= $e >>> at + Qe & 1;
  }
  Fe[Ke + 0] = Ve >>> 0, Fe[Ke + 1] = Je >>> 0;
}, rip: function($e, Ze, Fe, Ke) {
  for (var Ve = 0, Je = 0, Qe = 0; Qe < 4; Qe++)
    for (var at = 24; at >= 0; at -= 8)
      Ve <<= 1, Ve |= Ze >>> at + Qe & 1, Ve <<= 1, Ve |= $e >>> at + Qe & 1;
  for (Qe = 4; Qe < 8; Qe++)
    for (at = 24; at >= 0; at -= 8)
      Je <<= 1, Je |= Ze >>> at + Qe & 1, Je <<= 1, Je |= $e >>> at + Qe & 1;
  Fe[Ke + 0] = Ve >>> 0, Fe[Ke + 1] = Je >>> 0;
}, pc1: function($e, Ze, Fe, Ke) {
  for (var Ve = 0, Je = 0, Qe = 7; Qe >= 5; Qe--) {
    for (var at = 0; at <= 24; at += 8)
      Ve <<= 1, Ve |= Ze >> at + Qe & 1;
    for (at = 0; at <= 24; at += 8)
      Ve <<= 1, Ve |= $e >> at + Qe & 1;
  }
  for (at = 0; at <= 24; at += 8)
    Ve <<= 1, Ve |= Ze >> at + Qe & 1;
  for (Qe = 1; Qe <= 3; Qe++) {
    for (at = 0; at <= 24; at += 8)
      Je <<= 1, Je |= Ze >> at + Qe & 1;
    for (at = 0; at <= 24; at += 8)
      Je <<= 1, Je |= $e >> at + Qe & 1;
  }
  for (at = 0; at <= 24; at += 8)
    Je <<= 1, Je |= $e >> at + Qe & 1;
  Fe[Ke + 0] = Ve >>> 0, Fe[Ke + 1] = Je >>> 0;
}, r28shl: function($e, Ze) {
  return $e << Ze & 268435455 | $e >>> 28 - Ze;
} }, i5 = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
r$6.pc2 = function($e, Ze, Fe, Ke) {
  for (var Ve = 0, Je = 0, Qe = i5.length >>> 1, at = 0; at < Qe; at++)
    Ve <<= 1, Ve |= $e >>> i5[at] & 1;
  for (at = Qe; at < i5.length; at++)
    Je <<= 1, Je |= Ze >>> i5[at] & 1;
  Fe[Ke + 0] = Ve >>> 0, Fe[Ke + 1] = Je >>> 0;
}, r$6.expand = function($e, Ze, Fe) {
  var Ke = 0, Ve = 0;
  Ke = (1 & $e) << 5 | $e >>> 27;
  for (var Je = 23; Je >= 15; Je -= 4)
    Ke <<= 6, Ke |= $e >>> Je & 63;
  for (Je = 11; Je >= 3; Je -= 4)
    Ve |= $e >>> Je & 63, Ve <<= 6;
  Ve |= (31 & $e) << 1 | $e >>> 31, Ze[Fe + 0] = Ke >>> 0, Ze[Fe + 1] = Ve >>> 0;
};
var n$8 = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
r$6.substitute = function($e, Ze) {
  for (var Fe = 0, Ke = 0; Ke < 4; Ke++)
    Fe <<= 4, Fe |= n$8[64 * Ke + ($e >>> 18 - 6 * Ke & 63)];
  for (Ke = 0; Ke < 4; Ke++)
    Fe <<= 4, Fe |= n$8[256 + 64 * Ke + (Ze >>> 18 - 6 * Ke & 63)];
  return Fe >>> 0;
};
var f$9 = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
r$6.permute = function($e) {
  for (var Ze = 0, Fe = 0; Fe < f$9.length; Fe++)
    Ze <<= 1, Ze |= $e >>> f$9[Fe] & 1;
  return Ze >>> 0;
}, r$6.padSplit = function($e, Ze, Fe) {
  for (var Ke = $e.toString(2); Ke.length < Ze; )
    Ke = "0" + Ke;
  for (var Ve = [], Je = 0; Je < Ze; Je += Fe)
    Ve.push(Ke.slice(Je, Je + Fe));
  return Ve.join(" ");
};
var o$8, p$6 = o$7;
function u$6($e) {
  this.options = $e, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
}
o$8 = u$6, u$6.prototype._init = function() {
}, u$6.prototype.update = function($e) {
  return $e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt($e) : this._updateEncrypt($e);
}, u$6.prototype._buffer = function($e, Ze) {
  for (var Fe = Math.min(this.buffer.length - this.bufferOff, $e.length - Ze), Ke = 0; Ke < Fe; Ke++)
    this.buffer[this.bufferOff + Ke] = $e[Ze + Ke];
  return this.bufferOff += Fe, Fe;
}, u$6.prototype._flushBuffer = function($e, Ze) {
  return this._update(this.buffer, 0, $e, Ze), this.bufferOff = 0, this.blockSize;
}, u$6.prototype._updateEncrypt = function($e) {
  var Ze = 0, Fe = 0, Ke = (this.bufferOff + $e.length) / this.blockSize | 0, Ve = new Array(Ke * this.blockSize);
  this.bufferOff !== 0 && (Ze += this._buffer($e, Ze), this.bufferOff === this.buffer.length && (Fe += this._flushBuffer(Ve, Fe)));
  for (var Je = $e.length - ($e.length - Ze) % this.blockSize; Ze < Je; Ze += this.blockSize)
    this._update($e, Ze, Ve, Fe), Fe += this.blockSize;
  for (; Ze < $e.length; Ze++, this.bufferOff++)
    this.buffer[this.bufferOff] = $e[Ze];
  return Ve;
}, u$6.prototype._updateDecrypt = function($e) {
  for (var Ze = 0, Fe = 0, Ke = Math.ceil((this.bufferOff + $e.length) / this.blockSize) - 1, Ve = new Array(Ke * this.blockSize); Ke > 0; Ke--)
    Ze += this._buffer($e, Ze), Fe += this._flushBuffer(Ve, Fe);
  return Ze += this._buffer($e, Ze), Ve;
}, u$6.prototype.final = function($e) {
  var Ze, Fe;
  return $e && (Ze = this.update($e)), Fe = this.type === "encrypt" ? this._finalEncrypt() : this._finalDecrypt(), Ze ? Ze.concat(Fe) : Fe;
}, u$6.prototype._pad = function($e, Ze) {
  if (Ze === 0)
    return !1;
  for (; Ze < $e.length; )
    $e[Ze++] = 0;
  return !0;
}, u$6.prototype._finalEncrypt = function() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var $e = new Array(this.blockSize);
  return this._update(this.buffer, 0, $e, 0), $e;
}, u$6.prototype._unpad = function($e) {
  return $e;
}, u$6.prototype._finalDecrypt = function() {
  p$6.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var $e = new Array(this.blockSize);
  return this._flushBuffer($e, 0), this._unpad($e);
};
var s$6, a$8 = o$8, h$7 = o$7, c$6 = r$6, l$6 = a$8;
function y$3() {
  this.tmp = new Array(2), this.keys = null;
}
function v$3($e) {
  l$6.call(this, $e);
  var Ze = new y$3();
  this._desState = Ze, this.deriveKeys(Ze, $e.key);
}
t$2(v$3, l$6), s$6 = v$3, v$3.create = function($e) {
  return new v$3($e);
};
var d$5 = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
v$3.prototype.deriveKeys = function($e, Ze) {
  $e.keys = new Array(32), h$7.equal(Ze.length, this.blockSize, "Invalid key length");
  var Fe = c$6.readUInt32BE(Ze, 0), Ke = c$6.readUInt32BE(Ze, 4);
  c$6.pc1(Fe, Ke, $e.tmp, 0), Fe = $e.tmp[0], Ke = $e.tmp[1];
  for (var Ve = 0; Ve < $e.keys.length; Ve += 2) {
    var Je = d$5[Ve >>> 1];
    Fe = c$6.r28shl(Fe, Je), Ke = c$6.r28shl(Ke, Je), c$6.pc2(Fe, Ke, $e.keys, Ve);
  }
}, v$3.prototype._update = function($e, Ze, Fe, Ke) {
  var Ve = this._desState, Je = c$6.readUInt32BE($e, Ze), Qe = c$6.readUInt32BE($e, Ze + 4);
  c$6.ip(Je, Qe, Ve.tmp, 0), Je = Ve.tmp[0], Qe = Ve.tmp[1], this.type === "encrypt" ? this._encrypt(Ve, Je, Qe, Ve.tmp, 0) : this._decrypt(Ve, Je, Qe, Ve.tmp, 0), Je = Ve.tmp[0], Qe = Ve.tmp[1], c$6.writeUInt32BE(Fe, Je, Ke), c$6.writeUInt32BE(Fe, Qe, Ke + 4);
}, v$3.prototype._pad = function($e, Ze) {
  for (var Fe = $e.length - Ze, Ke = Ze; Ke < $e.length; Ke++)
    $e[Ke] = Fe;
  return !0;
}, v$3.prototype._unpad = function($e) {
  for (var Ze = $e[$e.length - 1], Fe = $e.length - Ze; Fe < $e.length; Fe++)
    h$7.equal($e[Fe], Ze);
  return $e.slice(0, $e.length - Ze);
}, v$3.prototype._encrypt = function($e, Ze, Fe, Ke, Ve) {
  for (var Je = Ze, Qe = Fe, at = 0; at < $e.keys.length; at += 2) {
    var ut = $e.keys[at], lt = $e.keys[at + 1];
    c$6.expand(Qe, $e.tmp, 0), ut ^= $e.tmp[0], lt ^= $e.tmp[1];
    var dt = c$6.substitute(ut, lt), bt = Qe;
    Qe = (Je ^ c$6.permute(dt)) >>> 0, Je = bt;
  }
  c$6.rip(Qe, Je, Ke, Ve);
}, v$3.prototype._decrypt = function($e, Ze, Fe, Ke, Ve) {
  for (var Je = Fe, Qe = Ze, at = $e.keys.length - 2; at >= 0; at -= 2) {
    var ut = $e.keys[at], lt = $e.keys[at + 1];
    c$6.expand(Je, $e.tmp, 0), ut ^= $e.tmp[0], lt ^= $e.tmp[1];
    var dt = c$6.substitute(ut, lt), bt = Je;
    Je = (Qe ^ c$6.permute(dt)) >>> 0, Qe = bt;
  }
  c$6.rip(Je, Qe, Ke, Ve);
};
var _$5 = s$6, b$4 = {}, k$4 = o$7, g$3 = t$2, m$4 = {};
function S$2($e) {
  k$4.equal($e.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var Ze = 0; Ze < this.iv.length; Ze++)
    this.iv[Ze] = $e[Ze];
}
b$4.instantiate = function($e) {
  function Ze(Je) {
    $e.call(this, Je), this._cbcInit();
  }
  g$3(Ze, $e);
  for (var Fe = Object.keys(m$4), Ke = 0; Ke < Fe.length; Ke++) {
    var Ve = Fe[Ke];
    Ze.prototype[Ve] = m$4[Ve];
  }
  return Ze.create = function(Je) {
    return new Ze(Je);
  }, Ze;
}, m$4._cbcInit = function() {
  var $e = new S$2(this.options.iv);
  this._cbcState = $e;
}, m$4._update = function($e, Ze, Fe, Ke) {
  var Ve = this._cbcState, Je = this.constructor.super_.prototype, Qe = Ve.iv;
  if (this.type === "encrypt") {
    for (var at = 0; at < this.blockSize; at++)
      Qe[at] ^= $e[Ze + at];
    for (Je._update.call(this, Qe, 0, Fe, Ke), at = 0; at < this.blockSize; at++)
      Qe[at] = Fe[Ke + at];
  } else {
    for (Je._update.call(this, $e, Ze, Fe, Ke), at = 0; at < this.blockSize; at++)
      Fe[Ke + at] ^= Qe[at];
    for (at = 0; at < this.blockSize; at++)
      Qe[at] = $e[Ze + at];
  }
};
var z$2, w$5 = o$7, E$3 = a$8, I$3 = _$5;
function O$1($e, Ze) {
  w$5.equal(Ze.length, 24, "Invalid key length");
  var Fe = Ze.slice(0, 8), Ke = Ze.slice(8, 16), Ve = Ze.slice(16, 24);
  this.ciphers = $e === "encrypt" ? [I$3.create({ type: "encrypt", key: Fe }), I$3.create({ type: "decrypt", key: Ke }), I$3.create({ type: "encrypt", key: Ve })] : [I$3.create({ type: "decrypt", key: Ve }), I$3.create({ type: "encrypt", key: Ke }), I$3.create({ type: "decrypt", key: Fe })];
}
function B$2($e) {
  E$3.call(this, $e);
  var Ze = new O$1(this.type, this.options.key);
  this._edeState = Ze;
}
t$2(B$2, E$3), z$2 = B$2, B$2.create = function($e) {
  return new B$2($e);
}, B$2.prototype._update = function($e, Ze, Fe, Ke) {
  var Ve = this._edeState;
  Ve.ciphers[0]._update($e, Ze, Fe, Ke), Ve.ciphers[1]._update(Fe, Ke, Fe, Ke), Ve.ciphers[2]._update(Fe, Ke, Fe, Ke);
}, B$2.prototype._pad = I$3.prototype._pad, B$2.prototype._unpad = I$3.prototype._unpad;
var A$2 = z$2, U$2 = {};
U$2.utils = r$6, U$2.Cipher = a$8, U$2.DES = _$5, U$2.CBC = b$4, U$2.EDE = A$2;
var d$6, i$13 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, f$a = f$6, o$9 = U$2, a$9 = t$2, c$7 = u4.Buffer, n$9 = { "des-ede3-cbc": o$9.CBC.instantiate(o$9.EDE), "des-ede3": o$9.EDE, "des-ede-cbc": o$9.CBC.instantiate(o$9.EDE), "des-ede": o$9.EDE, "des-cbc": o$9.CBC.instantiate(o$9.DES), "des-ecb": o$9.DES };
function p$7($e) {
  f$a.call(this || i$13);
  var Ze, Fe = $e.mode.toLowerCase(), Ke = n$9[Fe];
  Ze = $e.decrypt ? "decrypt" : "encrypt";
  var Ve = $e.key;
  c$7.isBuffer(Ve) || (Ve = c$7.from(Ve)), Fe !== "des-ede" && Fe !== "des-ede-cbc" || (Ve = c$7.concat([Ve, Ve.slice(0, 8)]));
  var Je = $e.iv;
  c$7.isBuffer(Je) || (Je = c$7.from(Je)), (this || i$13)._des = Ke.create({ key: Ve, iv: Je, type: Ze });
}
n$9.des = n$9["des-cbc"], n$9.des3 = n$9["des-ede3-cbc"], d$6 = p$7, a$9(p$7, f$a), p$7.prototype._update = function($e) {
  return c$7.from((this || i$13)._des.update($e));
}, p$7.prototype._final = function() {
  return c$7.from((this || i$13)._des.final());
};
var l$7 = d$6, e$8 = e$1$1$1.Buffer, f$b = function($e, Ze) {
  for (var Fe = Math.min($e.length, Ze.length), Ke = new e$8(Fe), Ve = 0; Ve < Fe; ++Ve)
    Ke[Ve] = $e[Ve] ^ Ze[Ve];
  return Ke;
}, t$12 = function($e) {
  for (var Ze, Fe = $e.length; Fe--; ) {
    if ((Ze = $e.readUInt8(Fe)) !== 255) {
      Ze++, $e.writeUInt8(Ze, Fe);
      break;
    }
    $e.writeUInt8(0, Fe);
  }
}, a$a = { encrypt: function($e, Ze) {
  return $e._cipher.encryptBlock(Ze);
}, decrypt: function($e, Ze) {
  return $e._cipher.decryptBlock(Ze);
} }, p$8 = {}, n$a = f$b;
p$8.encrypt = function($e, Ze) {
  var Fe = n$a(Ze, $e._prev);
  return $e._prev = $e._cipher.encryptBlock(Fe), $e._prev;
}, p$8.decrypt = function($e, Ze) {
  var Fe = $e._prev;
  $e._prev = Ze;
  var Ke = $e._cipher.decryptBlock(Ze);
  return n$a(Ke, Fe);
};
var i$2 = {}, o$a = u4.Buffer, h$8 = f$b;
function v$4($e, Ze, Fe) {
  var Ke = Ze.length, Ve = h$8(Ze, $e._cache);
  return $e._cache = $e._cache.slice(Ke), $e._prev = o$a.concat([$e._prev, Fe ? Ze : Ve]), Ve;
}
i$2.encrypt = function($e, Ze, Fe) {
  for (var Ke, Ve = o$a.allocUnsafe(0); Ze.length; ) {
    if ($e._cache.length === 0 && ($e._cache = $e._cipher.encryptBlock($e._prev), $e._prev = o$a.allocUnsafe(0)), !($e._cache.length <= Ze.length)) {
      Ve = o$a.concat([Ve, v$4($e, Ze, Fe)]);
      break;
    }
    Ke = $e._cache.length, Ve = o$a.concat([Ve, v$4($e, Ze.slice(0, Ke), Fe)]), Ze = Ze.slice(Ke);
  }
  return Ve;
};
var y$4 = {}, f$c = u4.Buffer;
function s$7($e, Ze, Fe) {
  var Ke = $e._cipher.encryptBlock($e._prev)[0] ^ Ze;
  return $e._prev = f$c.concat([$e._prev.slice(1), f$c.from([Fe ? Ze : Ke])]), Ke;
}
y$4.encrypt = function($e, Ze, Fe) {
  for (var Ke = Ze.length, Ve = f$c.allocUnsafe(Ke), Je = -1; ++Je < Ke; )
    Ve[Je] = s$7($e, Ze[Je], Fe);
  return Ve;
};
var l$8 = {}, m$5 = u4.Buffer;
function _$6($e, Ze, Fe) {
  for (var Ke, Ve, Je = -1, Qe = 0; ++Je < 8; )
    Ke = Ze & 1 << 7 - Je ? 128 : 0, Qe += (128 & (Ve = $e._cipher.encryptBlock($e._prev)[0] ^ Ke)) >> Je % 8, $e._prev = k$5($e._prev, Fe ? Ke : Ve);
  return Qe;
}
function k$5($e, Ze) {
  var Fe = $e.length, Ke = -1, Ve = m$5.allocUnsafe($e.length);
  for ($e = m$5.concat([$e, m$5.from([Ze])]); ++Ke < Fe; )
    Ve[Ke] = $e[Ke] << 1 | $e[Ke + 1] >> 7;
  return Ve;
}
l$8.encrypt = function($e, Ze, Fe) {
  for (var Ke = Ze.length, Ve = m$5.allocUnsafe(Ke), Je = -1; ++Je < Ke; )
    Ve[Je] = _$6($e, Ze[Je], Fe);
  return Ve;
};
var B$3 = {}, u$7 = e$1$1$1.Buffer, C$1 = f$b;
function E$4($e) {
  return $e._prev = $e._cipher.encryptBlock($e._prev), $e._prev;
}
B$3.encrypt = function($e, Ze) {
  for (; $e._cache.length < Ze.length; )
    $e._cache = u$7.concat([$e._cache, E$4($e)]);
  var Fe = $e._cache.slice(0, Ze.length);
  return $e._cache = $e._cache.slice(Ze.length), C$1(Ze, Fe);
};
var d$7 = {}, b$5 = f$b, A$3 = u4.Buffer, S$3 = t$12;
function g$4($e) {
  var Ze = $e._cipher.encryptBlockRaw($e._prev);
  return S$3($e._prev), Ze;
}
d$7.encrypt = function($e, Ze) {
  var Fe = Math.ceil(Ze.length / 16), Ke = $e._cache.length;
  $e._cache = A$3.concat([$e._cache, A$3.allocUnsafe(16 * Fe)]);
  for (var Ve = 0; Ve < Fe; Ve++) {
    var Je = g$4($e), Qe = Ke + 16 * Ve;
    $e._cache.writeUInt32BE(Je[0], Qe + 0), $e._cache.writeUInt32BE(Je[1], Qe + 4), $e._cache.writeUInt32BE(Je[2], Qe + 8), $e._cache.writeUInt32BE(Je[3], Qe + 12);
  }
  var at = $e._cache.slice(0, Ze.length);
  return $e._cache = $e._cache.slice(Ze.length), b$5(Ze, at);
};
var F$2 = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } }, U$3 = { ECB: a$a, CBC: p$8, CFB: i$2, CFB8: y$4, CFB1: l$8, OFB: B$3, CTR: d$7, GCM: d$7 }, w$6 = F$2;
for (I$4 in w$6)
  w$6[I$4].module = U$3[w$6[I$4].mode];
var I$4, M$2 = w$6, a$b = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, h$9 = {}, o$b = u4.Buffer;
function s$8($e) {
  o$b.isBuffer($e) || ($e = o$b.from($e));
  for (var Ze = $e.length / 4 | 0, Fe = new Array(Ze), Ke = 0; Ke < Ze; Ke++)
    Fe[Ke] = $e.readUInt32BE(4 * Ke);
  return Fe;
}
function c$8($e) {
  for (; 0 < $e.length; $e++)
    $e[0] = 0;
}
function l$9($e, Ze, Fe, Ke, Ve) {
  for (var Je, Qe, at, ut, lt = Fe[0], dt = Fe[1], bt = Fe[2], $t = Fe[3], vt = $e[0] ^ Ze[0], wt = $e[1] ^ Ze[1], xt = $e[2] ^ Ze[2], Et = $e[3] ^ Ze[3], Tt = 4, Rt = 1; Rt < Ve; Rt++)
    Je = lt[vt >>> 24] ^ dt[wt >>> 16 & 255] ^ bt[xt >>> 8 & 255] ^ $t[255 & Et] ^ Ze[Tt++], Qe = lt[wt >>> 24] ^ dt[xt >>> 16 & 255] ^ bt[Et >>> 8 & 255] ^ $t[255 & vt] ^ Ze[Tt++], at = lt[xt >>> 24] ^ dt[Et >>> 16 & 255] ^ bt[vt >>> 8 & 255] ^ $t[255 & wt] ^ Ze[Tt++], ut = lt[Et >>> 24] ^ dt[vt >>> 16 & 255] ^ bt[wt >>> 8 & 255] ^ $t[255 & xt] ^ Ze[Tt++], vt = Je, wt = Qe, xt = at, Et = ut;
  return Je = (Ke[vt >>> 24] << 24 | Ke[wt >>> 16 & 255] << 16 | Ke[xt >>> 8 & 255] << 8 | Ke[255 & Et]) ^ Ze[Tt++], Qe = (Ke[wt >>> 24] << 24 | Ke[xt >>> 16 & 255] << 16 | Ke[Et >>> 8 & 255] << 8 | Ke[255 & vt]) ^ Ze[Tt++], at = (Ke[xt >>> 24] << 24 | Ke[Et >>> 16 & 255] << 16 | Ke[vt >>> 8 & 255] << 8 | Ke[255 & wt]) ^ Ze[Tt++], ut = (Ke[Et >>> 24] << 24 | Ke[vt >>> 16 & 255] << 16 | Ke[wt >>> 8 & 255] << 8 | Ke[255 & xt]) ^ Ze[Tt++], [Je >>>= 0, Qe >>>= 0, at >>>= 0, ut >>>= 0];
}
var f$d = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], u$8 = function() {
  for (var $e = new Array(256), Ze = 0; Ze < 256; Ze++)
    $e[Ze] = Ze < 128 ? Ze << 1 : Ze << 1 ^ 283;
  for (var Fe = [], Ke = [], Ve = [[], [], [], []], Je = [[], [], [], []], Qe = 0, at = 0, ut = 0; ut < 256; ++ut) {
    var lt = at ^ at << 1 ^ at << 2 ^ at << 3 ^ at << 4;
    lt = lt >>> 8 ^ 255 & lt ^ 99, Fe[Qe] = lt, Ke[lt] = Qe;
    var dt = $e[Qe], bt = $e[dt], $t = $e[bt], vt = 257 * $e[lt] ^ 16843008 * lt;
    Ve[0][Qe] = vt << 24 | vt >>> 8, Ve[1][Qe] = vt << 16 | vt >>> 16, Ve[2][Qe] = vt << 8 | vt >>> 24, Ve[3][Qe] = vt, vt = 16843009 * $t ^ 65537 * bt ^ 257 * dt ^ 16843008 * Qe, Je[0][lt] = vt << 24 | vt >>> 8, Je[1][lt] = vt << 16 | vt >>> 16, Je[2][lt] = vt << 8 | vt >>> 24, Je[3][lt] = vt, Qe === 0 ? Qe = at = 1 : (Qe = dt ^ $e[$e[$e[$t ^ dt]]], at ^= $e[$e[at]]);
  }
  return { SBOX: Fe, INV_SBOX: Ke, SUB_MIX: Ve, INV_SUB_MIX: Je };
}();
function p$9($e) {
  (this || a$b)._key = s$8($e), this._reset();
}
p$9.blockSize = 16, p$9.keySize = 32, p$9.prototype.blockSize = p$9.blockSize, p$9.prototype.keySize = p$9.keySize, p$9.prototype._reset = function() {
  for (var $e = (this || a$b)._key, Ze = $e.length, Fe = Ze + 6, Ke = 4 * (Fe + 1), Ve = [], Je = 0; Je < Ze; Je++)
    Ve[Je] = $e[Je];
  for (Je = Ze; Je < Ke; Je++) {
    var Qe = Ve[Je - 1];
    Je % Ze == 0 ? (Qe = Qe << 8 | Qe >>> 24, Qe = u$8.SBOX[Qe >>> 24] << 24 | u$8.SBOX[Qe >>> 16 & 255] << 16 | u$8.SBOX[Qe >>> 8 & 255] << 8 | u$8.SBOX[255 & Qe], Qe ^= f$d[Je / Ze | 0] << 24) : Ze > 6 && Je % Ze == 4 && (Qe = u$8.SBOX[Qe >>> 24] << 24 | u$8.SBOX[Qe >>> 16 & 255] << 16 | u$8.SBOX[Qe >>> 8 & 255] << 8 | u$8.SBOX[255 & Qe]), Ve[Je] = Ve[Je - Ze] ^ Qe;
  }
  for (var at = [], ut = 0; ut < Ke; ut++) {
    var lt = Ke - ut, dt = Ve[lt - (ut % 4 ? 0 : 4)];
    at[ut] = ut < 4 || lt <= 4 ? dt : u$8.INV_SUB_MIX[0][u$8.SBOX[dt >>> 24]] ^ u$8.INV_SUB_MIX[1][u$8.SBOX[dt >>> 16 & 255]] ^ u$8.INV_SUB_MIX[2][u$8.SBOX[dt >>> 8 & 255]] ^ u$8.INV_SUB_MIX[3][u$8.SBOX[255 & dt]];
  }
  (this || a$b)._nRounds = Fe, (this || a$b)._keySchedule = Ve, (this || a$b)._invKeySchedule = at;
}, p$9.prototype.encryptBlockRaw = function($e) {
  return l$9($e = s$8($e), (this || a$b)._keySchedule, u$8.SUB_MIX, u$8.SBOX, (this || a$b)._nRounds);
}, p$9.prototype.encryptBlock = function($e) {
  var Ze = this.encryptBlockRaw($e), Fe = o$b.allocUnsafe(16);
  return Fe.writeUInt32BE(Ze[0], 0), Fe.writeUInt32BE(Ze[1], 4), Fe.writeUInt32BE(Ze[2], 8), Fe.writeUInt32BE(Ze[3], 12), Fe;
}, p$9.prototype.decryptBlock = function($e) {
  var Ze = ($e = s$8($e))[1];
  $e[1] = $e[3], $e[3] = Ze;
  var Fe = l$9($e, (this || a$b)._invKeySchedule, u$8.INV_SUB_MIX, u$8.INV_SBOX, (this || a$b)._nRounds), Ke = o$b.allocUnsafe(16);
  return Ke.writeUInt32BE(Fe[0], 0), Ke.writeUInt32BE(Fe[3], 4), Ke.writeUInt32BE(Fe[2], 8), Ke.writeUInt32BE(Fe[1], 12), Ke;
}, p$9.prototype.scrub = function() {
  c$8((this || a$b)._keySchedule), c$8((this || a$b)._invKeySchedule), c$8((this || a$b)._key);
}, h$9.AES = p$9;
var _$7 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, d$8 = u4.Buffer, y$5 = d$8.alloc(16, 0);
function B$4($e) {
  var Ze = d$8.allocUnsafe(16);
  return Ze.writeUInt32BE($e[0] >>> 0, 0), Ze.writeUInt32BE($e[1] >>> 0, 4), Ze.writeUInt32BE($e[2] >>> 0, 8), Ze.writeUInt32BE($e[3] >>> 0, 12), Ze;
}
function g$5($e) {
  (this || _$7).h = $e, (this || _$7).state = d$8.alloc(16, 0), (this || _$7).cache = d$8.allocUnsafe(0);
}
g$5.prototype.ghash = function($e) {
  for (var Ze = -1; ++Ze < $e.length; )
    (this || _$7).state[Ze] ^= $e[Ze];
  this._multiply();
}, g$5.prototype._multiply = function() {
  for (var $e, Ze, Fe, Ke = [($e = (this || _$7).h).readUInt32BE(0), $e.readUInt32BE(4), $e.readUInt32BE(8), $e.readUInt32BE(12)], Ve = [0, 0, 0, 0], Je = -1; ++Je < 128; ) {
    for ((this || _$7).state[~~(Je / 8)] & 1 << 7 - Je % 8 && (Ve[0] ^= Ke[0], Ve[1] ^= Ke[1], Ve[2] ^= Ke[2], Ve[3] ^= Ke[3]), Fe = (1 & Ke[3]) != 0, Ze = 3; Ze > 0; Ze--)
      Ke[Ze] = Ke[Ze] >>> 1 | (1 & Ke[Ze - 1]) << 31;
    Ke[0] = Ke[0] >>> 1, Fe && (Ke[0] = Ke[0] ^ 225 << 24);
  }
  (this || _$7).state = B$4(Ve);
}, g$5.prototype.update = function($e) {
  var Ze;
  for ((this || _$7).cache = d$8.concat([(this || _$7).cache, $e]); (this || _$7).cache.length >= 16; )
    Ze = (this || _$7).cache.slice(0, 16), (this || _$7).cache = (this || _$7).cache.slice(16), this.ghash(Ze);
}, g$5.prototype.final = function($e, Ze) {
  return (this || _$7).cache.length && this.ghash(d$8.concat([(this || _$7).cache, y$5], 16)), this.ghash(B$4([0, $e, 0, Ze])), (this || _$7).state;
};
var S$4 = g$5, v$5 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, I$5 = h$9, U$4 = u4.Buffer, w$7 = f$6, m$6 = S$4, E$5 = f$b, b$6 = t$12;
function X$1($e, Ze, Fe, Ke) {
  w$7.call(this || v$5);
  var Ve = U$4.alloc(4, 0);
  (this || v$5)._cipher = new I$5.AES(Ze);
  var Je = (this || v$5)._cipher.encryptBlock(Ve);
  (this || v$5)._ghash = new m$6(Je), Fe = function(Qe, at, ut) {
    if (at.length === 12)
      return Qe._finID = U$4.concat([at, U$4.from([0, 0, 0, 1])]), U$4.concat([at, U$4.from([0, 0, 0, 2])]);
    var lt = new m$6(ut), dt = at.length, bt = dt % 16;
    lt.update(at), bt && (bt = 16 - bt, lt.update(U$4.alloc(bt, 0))), lt.update(U$4.alloc(8, 0));
    var $t = 8 * dt, vt = U$4.alloc(8);
    vt.writeUIntBE($t, 0, 8), lt.update(vt), Qe._finID = lt.state;
    var wt = U$4.from(Qe._finID);
    return b$6(wt), wt;
  }(this || v$5, Fe, Je), (this || v$5)._prev = U$4.from(Fe), (this || v$5)._cache = U$4.allocUnsafe(0), (this || v$5)._secCache = U$4.allocUnsafe(0), (this || v$5)._decrypt = Ke, (this || v$5)._alen = 0, (this || v$5)._len = 0, (this || v$5)._mode = $e, (this || v$5)._authTag = null, (this || v$5)._called = !1;
}
t$2(X$1, w$7), X$1.prototype._update = function($e) {
  if (!(this || v$5)._called && (this || v$5)._alen) {
    var Ze = 16 - (this || v$5)._alen % 16;
    Ze < 16 && (Ze = U$4.alloc(Ze, 0), (this || v$5)._ghash.update(Ze));
  }
  (this || v$5)._called = !0;
  var Fe = (this || v$5)._mode.encrypt(this || v$5, $e);
  return (this || v$5)._decrypt ? (this || v$5)._ghash.update($e) : (this || v$5)._ghash.update(Fe), (this || v$5)._len += $e.length, Fe;
}, X$1.prototype._final = function() {
  if ((this || v$5)._decrypt && !(this || v$5)._authTag)
    throw new Error("Unsupported state or unable to authenticate data");
  var $e = E$5((this || v$5)._ghash.final(8 * (this || v$5)._alen, 8 * (this || v$5)._len), (this || v$5)._cipher.encryptBlock((this || v$5)._finID));
  if ((this || v$5)._decrypt && function(Ze, Fe) {
    var Ke = 0;
    Ze.length !== Fe.length && Ke++;
    for (var Ve = Math.min(Ze.length, Fe.length), Je = 0; Je < Ve; ++Je)
      Ke += Ze[Je] ^ Fe[Je];
    return Ke;
  }($e, (this || v$5)._authTag))
    throw new Error("Unsupported state or unable to authenticate data");
  (this || v$5)._authTag = $e, (this || v$5)._cipher.scrub();
}, X$1.prototype.getAuthTag = function() {
  if ((this || v$5)._decrypt || !U$4.isBuffer((this || v$5)._authTag))
    throw new Error("Attempting to get auth tag in unsupported state");
  return (this || v$5)._authTag;
}, X$1.prototype.setAuthTag = function($e) {
  if (!(this || v$5)._decrypt)
    throw new Error("Attempting to set auth tag in unsupported state");
  (this || v$5)._authTag = $e;
}, X$1.prototype.setAAD = function($e) {
  if ((this || v$5)._called)
    throw new Error("Attempting to set AAD in unsupported state");
  (this || v$5)._ghash.update($e), (this || v$5)._alen += $e.length;
};
var k$6 = X$1, T$2 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, O$2 = h$9, A$4 = u4.Buffer, M$3 = f$6;
function N$1($e, Ze, Fe, Ke) {
  M$3.call(this || T$2), (this || T$2)._cipher = new O$2.AES(Ze), (this || T$2)._prev = A$4.from(Fe), (this || T$2)._cache = A$4.allocUnsafe(0), (this || T$2)._secCache = A$4.allocUnsafe(0), (this || T$2)._decrypt = Ke, (this || T$2)._mode = $e;
}
t$2(N$1, M$3), N$1.prototype._update = function($e) {
  return (this || T$2)._mode.encrypt(this || T$2, $e, (this || T$2)._decrypt);
}, N$1.prototype._final = function() {
  (this || T$2)._cipher.scrub();
};
var V$1 = N$1, t$22 = u4.Buffer, f$e = u5, a$c = function($e, Ze, Fe, Ke) {
  if (t$22.isBuffer($e) || ($e = t$22.from($e, "binary")), Ze && (t$22.isBuffer(Ze) || (Ze = t$22.from(Ze, "binary")), Ze.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var Ve = Fe / 8, Je = t$22.alloc(Ve), Qe = t$22.alloc(Ke || 0), at = t$22.alloc(0); Ve > 0 || Ke > 0; ) {
    var ut = new f$e();
    ut.update(at), ut.update($e), Ze && ut.update(Ze), at = ut.digest();
    var lt = 0;
    if (Ve > 0) {
      var dt = Je.length - Ve;
      lt = Math.min(Ve, at.length), at.copy(Je, dt, 0, lt), Ve -= lt;
    }
    if (lt < at.length && Ke > 0) {
      var bt = Qe.length - Ke, $t = Math.min(Ke, at.length - lt);
      at.copy(Qe, bt, lt, lt + $t), Ke -= $t;
    }
  }
  return at.fill(0), { key: Je, iv: Qe };
}, c$9 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, s$9 = {}, f$f = k$6, p$a = u4.Buffer, u$9 = M$2, l$a = V$1, d$9 = f$6, y$6 = h$9, m$7 = a$c;
function g$6($e, Ze, Fe) {
  d$9.call(this || c$9), (this || c$9)._cache = new v$6(), (this || c$9)._last = void 0, (this || c$9)._cipher = new y$6.AES(Ze), (this || c$9)._prev = p$a.from(Fe), (this || c$9)._mode = $e, (this || c$9)._autopadding = !0;
}
function v$6() {
  (this || c$9).cache = p$a.allocUnsafe(0);
}
function w$8($e, Ze, Fe) {
  var Ke = u$9[$e.toLowerCase()];
  if (!Ke)
    throw new TypeError("invalid suite type");
  if (typeof Fe == "string" && (Fe = p$a.from(Fe)), Ke.mode !== "GCM" && Fe.length !== Ke.iv)
    throw new TypeError("invalid iv length " + Fe.length);
  if (typeof Ze == "string" && (Ze = p$a.from(Ze)), Ze.length !== Ke.key / 8)
    throw new TypeError("invalid key length " + Ze.length);
  return Ke.type === "stream" ? new l$a(Ke.module, Ze, Fe, !0) : Ke.type === "auth" ? new f$f(Ke.module, Ze, Fe, !0) : new g$6(Ke.module, Ze, Fe);
}
t$2(g$6, d$9), g$6.prototype._update = function($e) {
  var Ze, Fe;
  (this || c$9)._cache.add($e);
  for (var Ke = []; Ze = (this || c$9)._cache.get((this || c$9)._autopadding); )
    Fe = (this || c$9)._mode.decrypt(this || c$9, Ze), Ke.push(Fe);
  return p$a.concat(Ke);
}, g$6.prototype._final = function() {
  var $e = (this || c$9)._cache.flush();
  if ((this || c$9)._autopadding)
    return function(Ze) {
      var Fe = Ze[15];
      if (Fe < 1 || Fe > 16)
        throw new Error("unable to decrypt data");
      for (var Ke = -1; ++Ke < Fe; )
        if (Ze[Ke + (16 - Fe)] !== Fe)
          throw new Error("unable to decrypt data");
      if (Fe !== 16)
        return Ze.slice(0, 16 - Fe);
    }((this || c$9)._mode.decrypt(this || c$9, $e));
  if ($e)
    throw new Error("data not multiple of block length");
}, g$6.prototype.setAutoPadding = function($e) {
  return (this || c$9)._autopadding = !!$e, this || c$9;
}, v$6.prototype.add = function($e) {
  (this || c$9).cache = p$a.concat([(this || c$9).cache, $e]);
}, v$6.prototype.get = function($e) {
  var Ze;
  if ($e) {
    if ((this || c$9).cache.length > 16)
      return Ze = (this || c$9).cache.slice(0, 16), (this || c$9).cache = (this || c$9).cache.slice(16), Ze;
  } else if ((this || c$9).cache.length >= 16)
    return Ze = (this || c$9).cache.slice(0, 16), (this || c$9).cache = (this || c$9).cache.slice(16), Ze;
  return null;
}, v$6.prototype.flush = function() {
  if ((this || c$9).cache.length)
    return (this || c$9).cache;
}, s$9.createDecipher = function($e, Ze) {
  var Fe = u$9[$e.toLowerCase()];
  if (!Fe)
    throw new TypeError("invalid suite type");
  var Ke = m$7(Ze, !1, Fe.key, Fe.iv);
  return w$8($e, Ke.key, Ke.iv);
}, s$9.createDecipheriv = w$8;
var c$a = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, s$a = {}, f$g = M$2, p$b = k$6, l$b = u4.Buffer, u$a = V$1, d$a = f$6, m$8 = h$9, y$7 = a$c;
function v$7($e, Ze, Fe) {
  d$a.call(this || c$a), (this || c$a)._cache = new g$7(), (this || c$a)._cipher = new m$8.AES(Ze), (this || c$a)._prev = l$b.from(Fe), (this || c$a)._mode = $e, (this || c$a)._autopadding = !0;
}
t$2(v$7, d$a), v$7.prototype._update = function($e) {
  var Ze, Fe;
  (this || c$a)._cache.add($e);
  for (var Ke = []; Ze = (this || c$a)._cache.get(); )
    Fe = (this || c$a)._mode.encrypt(this || c$a, Ze), Ke.push(Fe);
  return l$b.concat(Ke);
};
var _$8 = l$b.alloc(16, 16);
function g$7() {
  (this || c$a).cache = l$b.allocUnsafe(0);
}
function w$9($e, Ze, Fe) {
  var Ke = f$g[$e.toLowerCase()];
  if (!Ke)
    throw new TypeError("invalid suite type");
  if (typeof Ze == "string" && (Ze = l$b.from(Ze)), Ze.length !== Ke.key / 8)
    throw new TypeError("invalid key length " + Ze.length);
  if (typeof Fe == "string" && (Fe = l$b.from(Fe)), Ke.mode !== "GCM" && Fe.length !== Ke.iv)
    throw new TypeError("invalid iv length " + Fe.length);
  return Ke.type === "stream" ? new u$a(Ke.module, Ze, Fe) : Ke.type === "auth" ? new p$b(Ke.module, Ze, Fe) : new v$7(Ke.module, Ze, Fe);
}
v$7.prototype._final = function() {
  var $e = (this || c$a)._cache.flush();
  if ((this || c$a)._autopadding)
    return $e = (this || c$a)._mode.encrypt(this || c$a, $e), (this || c$a)._cipher.scrub(), $e;
  if (!$e.equals(_$8))
    throw (this || c$a)._cipher.scrub(), new Error("data not multiple of block length");
}, v$7.prototype.setAutoPadding = function($e) {
  return (this || c$a)._autopadding = !!$e, this || c$a;
}, g$7.prototype.add = function($e) {
  (this || c$a).cache = l$b.concat([(this || c$a).cache, $e]);
}, g$7.prototype.get = function() {
  if ((this || c$a).cache.length > 15) {
    var $e = (this || c$a).cache.slice(0, 16);
    return (this || c$a).cache = (this || c$a).cache.slice(16), $e;
  }
  return null;
}, g$7.prototype.flush = function() {
  for (var $e = 16 - (this || c$a).cache.length, Ze = l$b.allocUnsafe($e), Fe = -1; ++Fe < $e; )
    Ze.writeUInt8($e, Fe);
  return l$b.concat([(this || c$a).cache, Ze]);
}, s$a.createCipheriv = w$9, s$a.createCipher = function($e, Ze) {
  var Fe = f$g[$e.toLowerCase()];
  if (!Fe)
    throw new TypeError("invalid suite type");
  var Ke = y$7(Ze, !1, Fe.key, Fe.iv);
  return w$9($e, Ke.key, Ke.iv);
};
var t$3 = {}, p$c = s$a, c$b = s$9, o$c = F$2;
t$3.createCipher = t$3.Cipher = p$c.createCipher, t$3.createCipheriv = t$3.Cipheriv = p$c.createCipheriv, t$3.createDecipher = t$3.Decipher = c$b.createDecipher, t$3.createDecipheriv = t$3.Decipheriv = c$b.createDecipheriv, t$3.listCiphers = t$3.getCiphers = function() {
  return Object.keys(o$c);
};
var e$9 = { "des-ecb": { key: 8, iv: 0 } };
e$9["des-cbc"] = e$9.des = { key: 8, iv: 8 }, e$9["des-ede3-cbc"] = e$9.des3 = { key: 24, iv: 8 }, e$9["des-ede3"] = { key: 24, iv: 0 }, e$9["des-ede-cbc"] = { key: 16, iv: 8 }, e$9["des-ede"] = { key: 16, iv: 0 };
var p$d = {}, n$b = l$7, s$b = t$3, v$8 = M$2, y$8 = e$9, a$d = a$c;
function f$h($e, Ze, Fe) {
  if ($e = $e.toLowerCase(), v$8[$e])
    return s$b.createCipheriv($e, Ze, Fe);
  if (y$8[$e])
    return new n$b({ key: Ze, iv: Fe, mode: $e });
  throw new TypeError("invalid suite type");
}
function c$c($e, Ze, Fe) {
  if ($e = $e.toLowerCase(), v$8[$e])
    return s$b.createDecipheriv($e, Ze, Fe);
  if (y$8[$e])
    return new n$b({ key: Ze, iv: Fe, mode: $e, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
p$d.createCipher = p$d.Cipher = function($e, Ze) {
  var Fe, Ke;
  if ($e = $e.toLowerCase(), v$8[$e])
    Fe = v$8[$e].key, Ke = v$8[$e].iv;
  else {
    if (!y$8[$e])
      throw new TypeError("invalid suite type");
    Fe = 8 * y$8[$e].key, Ke = y$8[$e].iv;
  }
  var Ve = a$d(Ze, !1, Fe, Ke);
  return f$h($e, Ve.key, Ve.iv);
}, p$d.createCipheriv = p$d.Cipheriv = f$h, p$d.createDecipher = p$d.Decipher = function($e, Ze) {
  var Fe, Ke;
  if ($e = $e.toLowerCase(), v$8[$e])
    Fe = v$8[$e].key, Ke = v$8[$e].iv;
  else {
    if (!y$8[$e])
      throw new TypeError("invalid suite type");
    Fe = 8 * y$8[$e].key, Ke = y$8[$e].iv;
  }
  var Ve = a$d(Ze, !1, Fe, Ke);
  return c$c($e, Ve.key, Ve.iv);
}, p$d.createDecipheriv = p$d.Decipheriv = c$c, p$d.listCiphers = p$d.getCiphers = function() {
  return Object.keys(y$8).concat(s$b.getCiphers());
};
var t$4 = Object.freeze({}), i$3 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, r$7 = {}, h$a = { exports: r$7 };
(function($e, Ze) {
  function Fe(Pt, Ot) {
    if (!Pt)
      throw new Error(Ot || "Assertion failed");
  }
  function Ke(Pt, Ot) {
    Pt.super_ = Ot;
    var Ft = function() {
    };
    Ft.prototype = Ot.prototype, Pt.prototype = new Ft(), Pt.prototype.constructor = Pt;
  }
  function Ve(Pt, Ot, Ft) {
    if (Ve.isBN(Pt))
      return Pt;
    (this || i$3).negative = 0, (this || i$3).words = null, (this || i$3).length = 0, (this || i$3).red = null, Pt !== null && (Ot !== "le" && Ot !== "be" || (Ft = Ot, Ot = 10), this._init(Pt || 0, Ot || 10, Ft || "be"));
  }
  var Je;
  typeof $e == "object" ? $e.exports = Ve : Ze.BN = Ve, Ve.BN = Ve, Ve.wordSize = 26;
  try {
    Je = t$4.Buffer;
  } catch {
  }
  function Qe(Pt, Ot, Ft) {
    for (var gt = 0, We = Math.min(Pt.length, Ft), Xe = Ot; Xe < We; Xe++) {
      var rt = Pt.charCodeAt(Xe) - 48;
      gt <<= 4, gt |= rt >= 49 && rt <= 54 ? rt - 49 + 10 : rt >= 17 && rt <= 22 ? rt - 17 + 10 : 15 & rt;
    }
    return gt;
  }
  function at(Pt, Ot, Ft, gt) {
    for (var We = 0, Xe = Math.min(Pt.length, Ft), rt = Ot; rt < Xe; rt++) {
      var ot = Pt.charCodeAt(rt) - 48;
      We *= gt, We += ot >= 49 ? ot - 49 + 10 : ot >= 17 ? ot - 17 + 10 : ot;
    }
    return We;
  }
  Ve.isBN = function(Pt) {
    return Pt instanceof Ve || Pt !== null && typeof Pt == "object" && Pt.constructor.wordSize === Ve.wordSize && Array.isArray(Pt.words);
  }, Ve.max = function(Pt, Ot) {
    return Pt.cmp(Ot) > 0 ? Pt : Ot;
  }, Ve.min = function(Pt, Ot) {
    return Pt.cmp(Ot) < 0 ? Pt : Ot;
  }, Ve.prototype._init = function(Pt, Ot, Ft) {
    if (typeof Pt == "number")
      return this._initNumber(Pt, Ot, Ft);
    if (typeof Pt == "object")
      return this._initArray(Pt, Ot, Ft);
    Ot === "hex" && (Ot = 16), Fe(Ot === (0 | Ot) && Ot >= 2 && Ot <= 36);
    var gt = 0;
    (Pt = Pt.toString().replace(/\s+/g, ""))[0] === "-" && gt++, Ot === 16 ? this._parseHex(Pt, gt) : this._parseBase(Pt, Ot, gt), Pt[0] === "-" && ((this || i$3).negative = 1), this.strip(), Ft === "le" && this._initArray(this.toArray(), Ot, Ft);
  }, Ve.prototype._initNumber = function(Pt, Ot, Ft) {
    Pt < 0 && ((this || i$3).negative = 1, Pt = -Pt), Pt < 67108864 ? ((this || i$3).words = [67108863 & Pt], (this || i$3).length = 1) : Pt < 4503599627370496 ? ((this || i$3).words = [67108863 & Pt, Pt / 67108864 & 67108863], (this || i$3).length = 2) : (Fe(Pt < 9007199254740992), (this || i$3).words = [67108863 & Pt, Pt / 67108864 & 67108863, 1], (this || i$3).length = 3), Ft === "le" && this._initArray(this.toArray(), Ot, Ft);
  }, Ve.prototype._initArray = function(Pt, Ot, Ft) {
    if (Fe(typeof Pt.length == "number"), Pt.length <= 0)
      return (this || i$3).words = [0], (this || i$3).length = 1, this || i$3;
    (this || i$3).length = Math.ceil(Pt.length / 3), (this || i$3).words = new Array((this || i$3).length);
    for (var gt = 0; gt < (this || i$3).length; gt++)
      (this || i$3).words[gt] = 0;
    var We, Xe, rt = 0;
    if (Ft === "be")
      for (gt = Pt.length - 1, We = 0; gt >= 0; gt -= 3)
        Xe = Pt[gt] | Pt[gt - 1] << 8 | Pt[gt - 2] << 16, (this || i$3).words[We] |= Xe << rt & 67108863, (this || i$3).words[We + 1] = Xe >>> 26 - rt & 67108863, (rt += 24) >= 26 && (rt -= 26, We++);
    else if (Ft === "le")
      for (gt = 0, We = 0; gt < Pt.length; gt += 3)
        Xe = Pt[gt] | Pt[gt + 1] << 8 | Pt[gt + 2] << 16, (this || i$3).words[We] |= Xe << rt & 67108863, (this || i$3).words[We + 1] = Xe >>> 26 - rt & 67108863, (rt += 24) >= 26 && (rt -= 26, We++);
    return this.strip();
  }, Ve.prototype._parseHex = function(Pt, Ot) {
    (this || i$3).length = Math.ceil((Pt.length - Ot) / 6), (this || i$3).words = new Array((this || i$3).length);
    for (var Ft = 0; Ft < (this || i$3).length; Ft++)
      (this || i$3).words[Ft] = 0;
    var gt, We, Xe = 0;
    for (Ft = Pt.length - 6, gt = 0; Ft >= Ot; Ft -= 6)
      We = Qe(Pt, Ft, Ft + 6), (this || i$3).words[gt] |= We << Xe & 67108863, (this || i$3).words[gt + 1] |= We >>> 26 - Xe & 4194303, (Xe += 24) >= 26 && (Xe -= 26, gt++);
    Ft + 6 !== Ot && (We = Qe(Pt, Ot, Ft + 6), (this || i$3).words[gt] |= We << Xe & 67108863, (this || i$3).words[gt + 1] |= We >>> 26 - Xe & 4194303), this.strip();
  }, Ve.prototype._parseBase = function(Pt, Ot, Ft) {
    (this || i$3).words = [0], (this || i$3).length = 1;
    for (var gt = 0, We = 1; We <= 67108863; We *= Ot)
      gt++;
    gt--, We = We / Ot | 0;
    for (var Xe = Pt.length - Ft, rt = Xe % gt, ot = Math.min(Xe, Xe - rt) + Ft, ft = 0, mt = Ft; mt < ot; mt += gt)
      ft = at(Pt, mt, mt + gt, Ot), this.imuln(We), (this || i$3).words[0] + ft < 67108864 ? (this || i$3).words[0] += ft : this._iaddn(ft);
    if (rt !== 0) {
      var yt = 1;
      for (ft = at(Pt, mt, Pt.length, Ot), mt = 0; mt < rt; mt++)
        yt *= Ot;
      this.imuln(yt), (this || i$3).words[0] + ft < 67108864 ? (this || i$3).words[0] += ft : this._iaddn(ft);
    }
  }, Ve.prototype.copy = function(Pt) {
    Pt.words = new Array((this || i$3).length);
    for (var Ot = 0; Ot < (this || i$3).length; Ot++)
      Pt.words[Ot] = (this || i$3).words[Ot];
    Pt.length = (this || i$3).length, Pt.negative = (this || i$3).negative, Pt.red = (this || i$3).red;
  }, Ve.prototype.clone = function() {
    var Pt = new Ve(null);
    return this.copy(Pt), Pt;
  }, Ve.prototype._expand = function(Pt) {
    for (; (this || i$3).length < Pt; )
      (this || i$3).words[(this || i$3).length++] = 0;
    return this || i$3;
  }, Ve.prototype.strip = function() {
    for (; (this || i$3).length > 1 && (this || i$3).words[(this || i$3).length - 1] === 0; )
      (this || i$3).length--;
    return this._normSign();
  }, Ve.prototype._normSign = function() {
    return (this || i$3).length === 1 && (this || i$3).words[0] === 0 && ((this || i$3).negative = 0), this || i$3;
  }, Ve.prototype.inspect = function() {
    return ((this || i$3).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
  };
  var ut = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], lt = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], dt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
  function bt(Pt, Ot, Ft) {
    Ft.negative = Ot.negative ^ Pt.negative;
    var gt = Pt.length + Ot.length | 0;
    Ft.length = gt, gt = gt - 1 | 0;
    var We = 0 | Pt.words[0], Xe = 0 | Ot.words[0], rt = We * Xe, ot = 67108863 & rt, ft = rt / 67108864 | 0;
    Ft.words[0] = ot;
    for (var mt = 1; mt < gt; mt++) {
      for (var yt = ft >>> 26, pt = 67108863 & ft, Ge = Math.min(mt, Ot.length - 1), ct = Math.max(0, mt - Pt.length + 1); ct <= Ge; ct++) {
        var Mt = mt - ct | 0;
        yt += (rt = (We = 0 | Pt.words[Mt]) * (Xe = 0 | Ot.words[ct]) + pt) / 67108864 | 0, pt = 67108863 & rt;
      }
      Ft.words[mt] = 0 | pt, ft = 0 | yt;
    }
    return ft !== 0 ? Ft.words[mt] = 0 | ft : Ft.length--, Ft.strip();
  }
  Ve.prototype.toString = function(Pt, Ot) {
    var Ft;
    if (Ot = 0 | Ot || 1, (Pt = Pt || 10) === 16 || Pt === "hex") {
      Ft = "";
      for (var gt = 0, We = 0, Xe = 0; Xe < (this || i$3).length; Xe++) {
        var rt = (this || i$3).words[Xe], ot = (16777215 & (rt << gt | We)).toString(16);
        Ft = (We = rt >>> 24 - gt & 16777215) !== 0 || Xe !== (this || i$3).length - 1 ? ut[6 - ot.length] + ot + Ft : ot + Ft, (gt += 2) >= 26 && (gt -= 26, Xe--);
      }
      for (We !== 0 && (Ft = We.toString(16) + Ft); Ft.length % Ot != 0; )
        Ft = "0" + Ft;
      return (this || i$3).negative !== 0 && (Ft = "-" + Ft), Ft;
    }
    if (Pt === (0 | Pt) && Pt >= 2 && Pt <= 36) {
      var ft = lt[Pt], mt = dt[Pt];
      Ft = "";
      var yt = this.clone();
      for (yt.negative = 0; !yt.isZero(); ) {
        var pt = yt.modn(mt).toString(Pt);
        Ft = (yt = yt.idivn(mt)).isZero() ? pt + Ft : ut[ft - pt.length] + pt + Ft;
      }
      for (this.isZero() && (Ft = "0" + Ft); Ft.length % Ot != 0; )
        Ft = "0" + Ft;
      return (this || i$3).negative !== 0 && (Ft = "-" + Ft), Ft;
    }
    Fe(!1, "Base should be between 2 and 36");
  }, Ve.prototype.toNumber = function() {
    var Pt = (this || i$3).words[0];
    return (this || i$3).length === 2 ? Pt += 67108864 * (this || i$3).words[1] : (this || i$3).length === 3 && (this || i$3).words[2] === 1 ? Pt += 4503599627370496 + 67108864 * (this || i$3).words[1] : (this || i$3).length > 2 && Fe(!1, "Number can only safely store up to 53 bits"), (this || i$3).negative !== 0 ? -Pt : Pt;
  }, Ve.prototype.toJSON = function() {
    return this.toString(16);
  }, Ve.prototype.toBuffer = function(Pt, Ot) {
    return Fe(Je !== void 0), this.toArrayLike(Je, Pt, Ot);
  }, Ve.prototype.toArray = function(Pt, Ot) {
    return this.toArrayLike(Array, Pt, Ot);
  }, Ve.prototype.toArrayLike = function(Pt, Ot, Ft) {
    var gt = this.byteLength(), We = Ft || Math.max(1, gt);
    Fe(gt <= We, "byte array longer than desired length"), Fe(We > 0, "Requested array length <= 0"), this.strip();
    var Xe, rt, ot = Ot === "le", ft = new Pt(We), mt = this.clone();
    if (ot) {
      for (rt = 0; !mt.isZero(); rt++)
        Xe = mt.andln(255), mt.iushrn(8), ft[rt] = Xe;
      for (; rt < We; rt++)
        ft[rt] = 0;
    } else {
      for (rt = 0; rt < We - gt; rt++)
        ft[rt] = 0;
      for (rt = 0; !mt.isZero(); rt++)
        Xe = mt.andln(255), mt.iushrn(8), ft[We - rt - 1] = Xe;
    }
    return ft;
  }, Math.clz32 ? Ve.prototype._countBits = function(Pt) {
    return 32 - Math.clz32(Pt);
  } : Ve.prototype._countBits = function(Pt) {
    var Ot = Pt, Ft = 0;
    return Ot >= 4096 && (Ft += 13, Ot >>>= 13), Ot >= 64 && (Ft += 7, Ot >>>= 7), Ot >= 8 && (Ft += 4, Ot >>>= 4), Ot >= 2 && (Ft += 2, Ot >>>= 2), Ft + Ot;
  }, Ve.prototype._zeroBits = function(Pt) {
    if (Pt === 0)
      return 26;
    var Ot = Pt, Ft = 0;
    return !(8191 & Ot) && (Ft += 13, Ot >>>= 13), !(127 & Ot) && (Ft += 7, Ot >>>= 7), !(15 & Ot) && (Ft += 4, Ot >>>= 4), !(3 & Ot) && (Ft += 2, Ot >>>= 2), !(1 & Ot) && Ft++, Ft;
  }, Ve.prototype.bitLength = function() {
    var Pt = (this || i$3).words[(this || i$3).length - 1], Ot = this._countBits(Pt);
    return 26 * ((this || i$3).length - 1) + Ot;
  }, Ve.prototype.zeroBits = function() {
    if (this.isZero())
      return 0;
    for (var Pt = 0, Ot = 0; Ot < (this || i$3).length; Ot++) {
      var Ft = this._zeroBits((this || i$3).words[Ot]);
      if (Pt += Ft, Ft !== 26)
        break;
    }
    return Pt;
  }, Ve.prototype.byteLength = function() {
    return Math.ceil(this.bitLength() / 8);
  }, Ve.prototype.toTwos = function(Pt) {
    return (this || i$3).negative !== 0 ? this.abs().inotn(Pt).iaddn(1) : this.clone();
  }, Ve.prototype.fromTwos = function(Pt) {
    return this.testn(Pt - 1) ? this.notn(Pt).iaddn(1).ineg() : this.clone();
  }, Ve.prototype.isNeg = function() {
    return (this || i$3).negative !== 0;
  }, Ve.prototype.neg = function() {
    return this.clone().ineg();
  }, Ve.prototype.ineg = function() {
    return this.isZero() || ((this || i$3).negative ^= 1), this || i$3;
  }, Ve.prototype.iuor = function(Pt) {
    for (; (this || i$3).length < Pt.length; )
      (this || i$3).words[(this || i$3).length++] = 0;
    for (var Ot = 0; Ot < Pt.length; Ot++)
      (this || i$3).words[Ot] = (this || i$3).words[Ot] | Pt.words[Ot];
    return this.strip();
  }, Ve.prototype.ior = function(Pt) {
    return Fe(((this || i$3).negative | Pt.negative) == 0), this.iuor(Pt);
  }, Ve.prototype.or = function(Pt) {
    return (this || i$3).length > Pt.length ? this.clone().ior(Pt) : Pt.clone().ior(this || i$3);
  }, Ve.prototype.uor = function(Pt) {
    return (this || i$3).length > Pt.length ? this.clone().iuor(Pt) : Pt.clone().iuor(this || i$3);
  }, Ve.prototype.iuand = function(Pt) {
    var Ot;
    Ot = (this || i$3).length > Pt.length ? Pt : this || i$3;
    for (var Ft = 0; Ft < Ot.length; Ft++)
      (this || i$3).words[Ft] = (this || i$3).words[Ft] & Pt.words[Ft];
    return (this || i$3).length = Ot.length, this.strip();
  }, Ve.prototype.iand = function(Pt) {
    return Fe(((this || i$3).negative | Pt.negative) == 0), this.iuand(Pt);
  }, Ve.prototype.and = function(Pt) {
    return (this || i$3).length > Pt.length ? this.clone().iand(Pt) : Pt.clone().iand(this || i$3);
  }, Ve.prototype.uand = function(Pt) {
    return (this || i$3).length > Pt.length ? this.clone().iuand(Pt) : Pt.clone().iuand(this || i$3);
  }, Ve.prototype.iuxor = function(Pt) {
    var Ot, Ft;
    (this || i$3).length > Pt.length ? (Ot = this || i$3, Ft = Pt) : (Ot = Pt, Ft = this || i$3);
    for (var gt = 0; gt < Ft.length; gt++)
      (this || i$3).words[gt] = Ot.words[gt] ^ Ft.words[gt];
    if ((this || i$3) !== Ot)
      for (; gt < Ot.length; gt++)
        (this || i$3).words[gt] = Ot.words[gt];
    return (this || i$3).length = Ot.length, this.strip();
  }, Ve.prototype.ixor = function(Pt) {
    return Fe(((this || i$3).negative | Pt.negative) == 0), this.iuxor(Pt);
  }, Ve.prototype.xor = function(Pt) {
    return (this || i$3).length > Pt.length ? this.clone().ixor(Pt) : Pt.clone().ixor(this || i$3);
  }, Ve.prototype.uxor = function(Pt) {
    return (this || i$3).length > Pt.length ? this.clone().iuxor(Pt) : Pt.clone().iuxor(this || i$3);
  }, Ve.prototype.inotn = function(Pt) {
    Fe(typeof Pt == "number" && Pt >= 0);
    var Ot = 0 | Math.ceil(Pt / 26), Ft = Pt % 26;
    this._expand(Ot), Ft > 0 && Ot--;
    for (var gt = 0; gt < Ot; gt++)
      (this || i$3).words[gt] = 67108863 & ~(this || i$3).words[gt];
    return Ft > 0 && ((this || i$3).words[gt] = ~(this || i$3).words[gt] & 67108863 >> 26 - Ft), this.strip();
  }, Ve.prototype.notn = function(Pt) {
    return this.clone().inotn(Pt);
  }, Ve.prototype.setn = function(Pt, Ot) {
    Fe(typeof Pt == "number" && Pt >= 0);
    var Ft = Pt / 26 | 0, gt = Pt % 26;
    return this._expand(Ft + 1), (this || i$3).words[Ft] = Ot ? (this || i$3).words[Ft] | 1 << gt : (this || i$3).words[Ft] & ~(1 << gt), this.strip();
  }, Ve.prototype.iadd = function(Pt) {
    var Ot, Ft, gt;
    if ((this || i$3).negative !== 0 && Pt.negative === 0)
      return (this || i$3).negative = 0, Ot = this.isub(Pt), (this || i$3).negative ^= 1, this._normSign();
    if ((this || i$3).negative === 0 && Pt.negative !== 0)
      return Pt.negative = 0, Ot = this.isub(Pt), Pt.negative = 1, Ot._normSign();
    (this || i$3).length > Pt.length ? (Ft = this || i$3, gt = Pt) : (Ft = Pt, gt = this || i$3);
    for (var We = 0, Xe = 0; Xe < gt.length; Xe++)
      Ot = (0 | Ft.words[Xe]) + (0 | gt.words[Xe]) + We, (this || i$3).words[Xe] = 67108863 & Ot, We = Ot >>> 26;
    for (; We !== 0 && Xe < Ft.length; Xe++)
      Ot = (0 | Ft.words[Xe]) + We, (this || i$3).words[Xe] = 67108863 & Ot, We = Ot >>> 26;
    if ((this || i$3).length = Ft.length, We !== 0)
      (this || i$3).words[(this || i$3).length] = We, (this || i$3).length++;
    else if (Ft !== (this || i$3))
      for (; Xe < Ft.length; Xe++)
        (this || i$3).words[Xe] = Ft.words[Xe];
    return this || i$3;
  }, Ve.prototype.add = function(Pt) {
    var Ot;
    return Pt.negative !== 0 && (this || i$3).negative === 0 ? (Pt.negative = 0, Ot = this.sub(Pt), Pt.negative ^= 1, Ot) : Pt.negative === 0 && (this || i$3).negative !== 0 ? ((this || i$3).negative = 0, Ot = Pt.sub(this || i$3), (this || i$3).negative = 1, Ot) : (this || i$3).length > Pt.length ? this.clone().iadd(Pt) : Pt.clone().iadd(this || i$3);
  }, Ve.prototype.isub = function(Pt) {
    if (Pt.negative !== 0) {
      Pt.negative = 0;
      var Ot = this.iadd(Pt);
      return Pt.negative = 1, Ot._normSign();
    }
    if ((this || i$3).negative !== 0)
      return (this || i$3).negative = 0, this.iadd(Pt), (this || i$3).negative = 1, this._normSign();
    var Ft, gt, We = this.cmp(Pt);
    if (We === 0)
      return (this || i$3).negative = 0, (this || i$3).length = 1, (this || i$3).words[0] = 0, this || i$3;
    We > 0 ? (Ft = this || i$3, gt = Pt) : (Ft = Pt, gt = this || i$3);
    for (var Xe = 0, rt = 0; rt < gt.length; rt++)
      Xe = (Ot = (0 | Ft.words[rt]) - (0 | gt.words[rt]) + Xe) >> 26, (this || i$3).words[rt] = 67108863 & Ot;
    for (; Xe !== 0 && rt < Ft.length; rt++)
      Xe = (Ot = (0 | Ft.words[rt]) + Xe) >> 26, (this || i$3).words[rt] = 67108863 & Ot;
    if (Xe === 0 && rt < Ft.length && Ft !== (this || i$3))
      for (; rt < Ft.length; rt++)
        (this || i$3).words[rt] = Ft.words[rt];
    return (this || i$3).length = Math.max((this || i$3).length, rt), Ft !== (this || i$3) && ((this || i$3).negative = 1), this.strip();
  }, Ve.prototype.sub = function(Pt) {
    return this.clone().isub(Pt);
  };
  var $t = function(Pt, Ot, Ft) {
    var gt, We, Xe, rt = Pt.words, ot = Ot.words, ft = Ft.words, mt = 0, yt = 0 | rt[0], pt = 8191 & yt, Ge = yt >>> 13, ct = 0 | rt[1], Mt = 8191 & ct, St = ct >>> 13, At = 0 | rt[2], Nt = 8191 & At, qt = At >>> 13, Qt = 0 | rt[3], Xt = 8191 & Qt, zt = Qt >>> 13, Kt = 0 | rt[4], ur = 8191 & Kt, er = Kt >>> 13, Dt = 0 | rt[5], Ht = 8191 & Dt, Gt = Dt >>> 13, rr = 0 | rt[6], sr = 8191 & rr, Jt = rr >>> 13, ir = 0 | rt[7], Br = 8191 & ir, or = ir >>> 13, lr = 0 | rt[8], Nr = 8191 & lr, dr = lr >>> 13, gr = 0 | rt[9], Zr = 8191 & gr, Bt = gr >>> 13, kt = 0 | ot[0], It = 8191 & kt, jt = kt >>> 13, Vt = 0 | ot[1], ar = 8191 & Vt, Yt = Vt >>> 13, hr = 0 | ot[2], zr = 8191 & hr, cr = hr >>> 13, _r = 0 | ot[3], Lr = 8191 & _r, br = _r >>> 13, kr = 0 | ot[4], Xr = 8191 & kr, yr = kr >>> 13, Ir = 0 | ot[5], Yr = 8191 & Ir, wr = Ir >>> 13, Cr = 0 | ot[6], Hr = 8191 & Cr, $r = Cr >>> 13, Ar = 0 | ot[7], Wr = 8191 & Ar, mr = Ar >>> 13, Tr = 0 | ot[8], Kr = 8191 & Tr, vr = Tr >>> 13, Rr = 0 | ot[9], Jr = 8191 & Rr, xr = Rr >>> 13;
    Ft.negative = Pt.negative ^ Ot.negative, Ft.length = 19;
    var tr = (mt + (gt = Math.imul(pt, It)) | 0) + ((8191 & (We = (We = Math.imul(pt, jt)) + Math.imul(Ge, It) | 0)) << 13) | 0;
    mt = ((Xe = Math.imul(Ge, jt)) + (We >>> 13) | 0) + (tr >>> 26) | 0, tr &= 67108863, gt = Math.imul(Mt, It), We = (We = Math.imul(Mt, jt)) + Math.imul(St, It) | 0, Xe = Math.imul(St, jt);
    var Dr = (mt + (gt = gt + Math.imul(pt, ar) | 0) | 0) + ((8191 & (We = (We = We + Math.imul(pt, Yt) | 0) + Math.imul(Ge, ar) | 0)) << 13) | 0;
    mt = ((Xe = Xe + Math.imul(Ge, Yt) | 0) + (We >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, gt = Math.imul(Nt, It), We = (We = Math.imul(Nt, jt)) + Math.imul(qt, It) | 0, Xe = Math.imul(qt, jt), gt = gt + Math.imul(Mt, ar) | 0, We = (We = We + Math.imul(Mt, Yt) | 0) + Math.imul(St, ar) | 0, Xe = Xe + Math.imul(St, Yt) | 0;
    var fr = (mt + (gt = gt + Math.imul(pt, zr) | 0) | 0) + ((8191 & (We = (We = We + Math.imul(pt, cr) | 0) + Math.imul(Ge, zr) | 0)) << 13) | 0;
    mt = ((Xe = Xe + Math.imul(Ge, cr) | 0) + (We >>> 13) | 0) + (fr >>> 26) | 0, fr &= 67108863, gt = Math.imul(Xt, It), We = (We = Math.imul(Xt, jt)) + Math.imul(zt, It) | 0, Xe = Math.imul(zt, jt), gt = gt + Math.imul(Nt, ar) | 0, We = (We = We + Math.imul(Nt, Yt) | 0) + Math.imul(qt, ar) | 0, Xe = Xe + Math.imul(qt, Yt) | 0, gt = gt + Math.imul(Mt, zr) | 0, We = (We = We + Math.imul(Mt, cr) | 0) + Math.imul(St, zr) | 0, Xe = Xe + Math.imul(St, cr) | 0;
    var Mr = (mt + (gt = gt + Math.imul(pt, Lr) | 0) | 0) + ((8191 & (We = (We = We + Math.imul(pt, br) | 0) + Math.imul(Ge, Lr) | 0)) << 13) | 0;
    mt = ((Xe = Xe + Math.imul(Ge, br) | 0) + (We >>> 13) | 0) + (Mr >>> 26) | 0, Mr &= 67108863, gt = Math.imul(ur, It), We = (We = Math.imul(ur, jt)) + Math.imul(er, It) | 0, Xe = Math.imul(er, jt), gt = gt + Math.imul(Xt, ar) | 0, We = (We = We + Math.imul(Xt, Yt) | 0) + Math.imul(zt, ar) | 0, Xe = Xe + Math.imul(zt, Yt) | 0, gt = gt + Math.imul(Nt, zr) | 0, We = (We = We + Math.imul(Nt, cr) | 0) + Math.imul(qt, zr) | 0, Xe = Xe + Math.imul(qt, cr) | 0, gt = gt + Math.imul(Mt, Lr) | 0, We = (We = We + Math.imul(Mt, br) | 0) + Math.imul(St, Lr) | 0, Xe = Xe + Math.imul(St, br) | 0;
    var Fr = (mt + (gt = gt + Math.imul(pt, Xr) | 0) | 0) + ((8191 & (We = (We = We + Math.imul(pt, yr) | 0) + Math.imul(Ge, Xr) | 0)) << 13) | 0;
    mt = ((Xe = Xe + Math.imul(Ge, yr) | 0) + (We >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, gt = Math.imul(Ht, It), We = (We = Math.imul(Ht, jt)) + Math.imul(Gt, It) | 0, Xe = Math.imul(Gt, jt), gt = gt + Math.imul(ur, ar) | 0, We = (We = We + Math.imul(ur, Yt) | 0) + Math.imul(er, ar) | 0, Xe = Xe + Math.imul(er, Yt) | 0, gt = gt + Math.imul(Xt, zr) | 0, We = (We = We + Math.imul(Xt, cr) | 0) + Math.imul(zt, zr) | 0, Xe = Xe + Math.imul(zt, cr) | 0, gt = gt + Math.imul(Nt, Lr) | 0, We = (We = We + Math.imul(Nt, br) | 0) + Math.imul(qt, Lr) | 0, Xe = Xe + Math.imul(qt, br) | 0, gt = gt + Math.imul(Mt, Xr) | 0, We = (We = We + Math.imul(Mt, yr) | 0) + Math.imul(St, Xr) | 0, Xe = Xe + Math.imul(St, yr) | 0;
    var qr = (mt + (gt = gt + Math.imul(pt, Yr) | 0) | 0) + ((8191 & (We = (We = We + Math.imul(pt, wr) | 0) + Math.imul(Ge, Yr) | 0)) << 13) | 0;
    mt = ((Xe = Xe + Math.imul(Ge, wr) | 0) + (We >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, gt = Math.imul(sr, It), We = (We = Math.imul(sr, jt)) + Math.imul(Jt, It) | 0, Xe = Math.imul(Jt, jt), gt = gt + Math.imul(Ht, ar) | 0, We = (We = We + Math.imul(Ht, Yt) | 0) + Math.imul(Gt, ar) | 0, Xe = Xe + Math.imul(Gt, Yt) | 0, gt = gt + Math.imul(ur, zr) | 0, We = (We = We + Math.imul(ur, cr) | 0) + Math.imul(er, zr) | 0, Xe = Xe + Math.imul(er, cr) | 0, gt = gt + Math.imul(Xt, Lr) | 0, We = (We = We + Math.imul(Xt, br) | 0) + Math.imul(zt, Lr) | 0, Xe = Xe + Math.imul(zt, br) | 0, gt = gt + Math.imul(Nt, Xr) | 0, We = (We = We + Math.imul(Nt, yr) | 0) + Math.imul(qt, Xr) | 0, Xe = Xe + Math.imul(qt, yr) | 0, gt = gt + Math.imul(Mt, Yr) | 0, We = (We = We + Math.imul(Mt, wr) | 0) + Math.imul(St, Yr) | 0, Xe = Xe + Math.imul(St, wr) | 0;
    var tn = (mt + (gt = gt + Math.imul(pt, Hr) | 0) | 0) + ((8191 & (We = (We = We + Math.imul(pt, $r) | 0) + Math.imul(Ge, Hr) | 0)) << 13) | 0;
    mt = ((Xe = Xe + Math.imul(Ge, $r) | 0) + (We >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, gt = Math.imul(Br, It), We = (We = Math.imul(Br, jt)) + Math.imul(or, It) | 0, Xe = Math.imul(or, jt), gt = gt + Math.imul(sr, ar) | 0, We = (We = We + Math.imul(sr, Yt) | 0) + Math.imul(Jt, ar) | 0, Xe = Xe + Math.imul(Jt, Yt) | 0, gt = gt + Math.imul(Ht, zr) | 0, We = (We = We + Math.imul(Ht, cr) | 0) + Math.imul(Gt, zr) | 0, Xe = Xe + Math.imul(Gt, cr) | 0, gt = gt + Math.imul(ur, Lr) | 0, We = (We = We + Math.imul(ur, br) | 0) + Math.imul(er, Lr) | 0, Xe = Xe + Math.imul(er, br) | 0, gt = gt + Math.imul(Xt, Xr) | 0, We = (We = We + Math.imul(Xt, yr) | 0) + Math.imul(zt, Xr) | 0, Xe = Xe + Math.imul(zt, yr) | 0, gt = gt + Math.imul(Nt, Yr) | 0, We = (We = We + Math.imul(Nt, wr) | 0) + Math.imul(qt, Yr) | 0, Xe = Xe + Math.imul(qt, wr) | 0, gt = gt + Math.imul(Mt, Hr) | 0, We = (We = We + Math.imul(Mt, $r) | 0) + Math.imul(St, Hr) | 0, Xe = Xe + Math.imul(St, $r) | 0;
    var Qr = (mt + (gt = gt + Math.imul(pt, Wr) | 0) | 0) + ((8191 & (We = (We = We + Math.imul(pt, mr) | 0) + Math.imul(Ge, Wr) | 0)) << 13) | 0;
    mt = ((Xe = Xe + Math.imul(Ge, mr) | 0) + (We >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, gt = Math.imul(Nr, It), We = (We = Math.imul(Nr, jt)) + Math.imul(dr, It) | 0, Xe = Math.imul(dr, jt), gt = gt + Math.imul(Br, ar) | 0, We = (We = We + Math.imul(Br, Yt) | 0) + Math.imul(or, ar) | 0, Xe = Xe + Math.imul(or, Yt) | 0, gt = gt + Math.imul(sr, zr) | 0, We = (We = We + Math.imul(sr, cr) | 0) + Math.imul(Jt, zr) | 0, Xe = Xe + Math.imul(Jt, cr) | 0, gt = gt + Math.imul(Ht, Lr) | 0, We = (We = We + Math.imul(Ht, br) | 0) + Math.imul(Gt, Lr) | 0, Xe = Xe + Math.imul(Gt, br) | 0, gt = gt + Math.imul(ur, Xr) | 0, We = (We = We + Math.imul(ur, yr) | 0) + Math.imul(er, Xr) | 0, Xe = Xe + Math.imul(er, yr) | 0, gt = gt + Math.imul(Xt, Yr) | 0, We = (We = We + Math.imul(Xt, wr) | 0) + Math.imul(zt, Yr) | 0, Xe = Xe + Math.imul(zt, wr) | 0, gt = gt + Math.imul(Nt, Hr) | 0, We = (We = We + Math.imul(Nt, $r) | 0) + Math.imul(qt, Hr) | 0, Xe = Xe + Math.imul(qt, $r) | 0, gt = gt + Math.imul(Mt, Wr) | 0, We = (We = We + Math.imul(Mt, mr) | 0) + Math.imul(St, Wr) | 0, Xe = Xe + Math.imul(St, mr) | 0;
    var nn = (mt + (gt = gt + Math.imul(pt, Kr) | 0) | 0) + ((8191 & (We = (We = We + Math.imul(pt, vr) | 0) + Math.imul(Ge, Kr) | 0)) << 13) | 0;
    mt = ((Xe = Xe + Math.imul(Ge, vr) | 0) + (We >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, gt = Math.imul(Zr, It), We = (We = Math.imul(Zr, jt)) + Math.imul(Bt, It) | 0, Xe = Math.imul(Bt, jt), gt = gt + Math.imul(Nr, ar) | 0, We = (We = We + Math.imul(Nr, Yt) | 0) + Math.imul(dr, ar) | 0, Xe = Xe + Math.imul(dr, Yt) | 0, gt = gt + Math.imul(Br, zr) | 0, We = (We = We + Math.imul(Br, cr) | 0) + Math.imul(or, zr) | 0, Xe = Xe + Math.imul(or, cr) | 0, gt = gt + Math.imul(sr, Lr) | 0, We = (We = We + Math.imul(sr, br) | 0) + Math.imul(Jt, Lr) | 0, Xe = Xe + Math.imul(Jt, br) | 0, gt = gt + Math.imul(Ht, Xr) | 0, We = (We = We + Math.imul(Ht, yr) | 0) + Math.imul(Gt, Xr) | 0, Xe = Xe + Math.imul(Gt, yr) | 0, gt = gt + Math.imul(ur, Yr) | 0, We = (We = We + Math.imul(ur, wr) | 0) + Math.imul(er, Yr) | 0, Xe = Xe + Math.imul(er, wr) | 0, gt = gt + Math.imul(Xt, Hr) | 0, We = (We = We + Math.imul(Xt, $r) | 0) + Math.imul(zt, Hr) | 0, Xe = Xe + Math.imul(zt, $r) | 0, gt = gt + Math.imul(Nt, Wr) | 0, We = (We = We + Math.imul(Nt, mr) | 0) + Math.imul(qt, Wr) | 0, Xe = Xe + Math.imul(qt, mr) | 0, gt = gt + Math.imul(Mt, Kr) | 0, We = (We = We + Math.imul(Mt, vr) | 0) + Math.imul(St, Kr) | 0, Xe = Xe + Math.imul(St, vr) | 0;
    var Er = (mt + (gt = gt + Math.imul(pt, Jr) | 0) | 0) + ((8191 & (We = (We = We + Math.imul(pt, xr) | 0) + Math.imul(Ge, Jr) | 0)) << 13) | 0;
    mt = ((Xe = Xe + Math.imul(Ge, xr) | 0) + (We >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, gt = Math.imul(Zr, ar), We = (We = Math.imul(Zr, Yt)) + Math.imul(Bt, ar) | 0, Xe = Math.imul(Bt, Yt), gt = gt + Math.imul(Nr, zr) | 0, We = (We = We + Math.imul(Nr, cr) | 0) + Math.imul(dr, zr) | 0, Xe = Xe + Math.imul(dr, cr) | 0, gt = gt + Math.imul(Br, Lr) | 0, We = (We = We + Math.imul(Br, br) | 0) + Math.imul(or, Lr) | 0, Xe = Xe + Math.imul(or, br) | 0, gt = gt + Math.imul(sr, Xr) | 0, We = (We = We + Math.imul(sr, yr) | 0) + Math.imul(Jt, Xr) | 0, Xe = Xe + Math.imul(Jt, yr) | 0, gt = gt + Math.imul(Ht, Yr) | 0, We = (We = We + Math.imul(Ht, wr) | 0) + Math.imul(Gt, Yr) | 0, Xe = Xe + Math.imul(Gt, wr) | 0, gt = gt + Math.imul(ur, Hr) | 0, We = (We = We + Math.imul(ur, $r) | 0) + Math.imul(er, Hr) | 0, Xe = Xe + Math.imul(er, $r) | 0, gt = gt + Math.imul(Xt, Wr) | 0, We = (We = We + Math.imul(Xt, mr) | 0) + Math.imul(zt, Wr) | 0, Xe = Xe + Math.imul(zt, mr) | 0, gt = gt + Math.imul(Nt, Kr) | 0, We = (We = We + Math.imul(Nt, vr) | 0) + Math.imul(qt, Kr) | 0, Xe = Xe + Math.imul(qt, vr) | 0;
    var Wt = (mt + (gt = gt + Math.imul(Mt, Jr) | 0) | 0) + ((8191 & (We = (We = We + Math.imul(Mt, xr) | 0) + Math.imul(St, Jr) | 0)) << 13) | 0;
    mt = ((Xe = Xe + Math.imul(St, xr) | 0) + (We >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, gt = Math.imul(Zr, zr), We = (We = Math.imul(Zr, cr)) + Math.imul(Bt, zr) | 0, Xe = Math.imul(Bt, cr), gt = gt + Math.imul(Nr, Lr) | 0, We = (We = We + Math.imul(Nr, br) | 0) + Math.imul(dr, Lr) | 0, Xe = Xe + Math.imul(dr, br) | 0, gt = gt + Math.imul(Br, Xr) | 0, We = (We = We + Math.imul(Br, yr) | 0) + Math.imul(or, Xr) | 0, Xe = Xe + Math.imul(or, yr) | 0, gt = gt + Math.imul(sr, Yr) | 0, We = (We = We + Math.imul(sr, wr) | 0) + Math.imul(Jt, Yr) | 0, Xe = Xe + Math.imul(Jt, wr) | 0, gt = gt + Math.imul(Ht, Hr) | 0, We = (We = We + Math.imul(Ht, $r) | 0) + Math.imul(Gt, Hr) | 0, Xe = Xe + Math.imul(Gt, $r) | 0, gt = gt + Math.imul(ur, Wr) | 0, We = (We = We + Math.imul(ur, mr) | 0) + Math.imul(er, Wr) | 0, Xe = Xe + Math.imul(er, mr) | 0, gt = gt + Math.imul(Xt, Kr) | 0, We = (We = We + Math.imul(Xt, vr) | 0) + Math.imul(zt, Kr) | 0, Xe = Xe + Math.imul(zt, vr) | 0;
    var nr = (mt + (gt = gt + Math.imul(Nt, Jr) | 0) | 0) + ((8191 & (We = (We = We + Math.imul(Nt, xr) | 0) + Math.imul(qt, Jr) | 0)) << 13) | 0;
    mt = ((Xe = Xe + Math.imul(qt, xr) | 0) + (We >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, gt = Math.imul(Zr, Lr), We = (We = Math.imul(Zr, br)) + Math.imul(Bt, Lr) | 0, Xe = Math.imul(Bt, br), gt = gt + Math.imul(Nr, Xr) | 0, We = (We = We + Math.imul(Nr, yr) | 0) + Math.imul(dr, Xr) | 0, Xe = Xe + Math.imul(dr, yr) | 0, gt = gt + Math.imul(Br, Yr) | 0, We = (We = We + Math.imul(Br, wr) | 0) + Math.imul(or, Yr) | 0, Xe = Xe + Math.imul(or, wr) | 0, gt = gt + Math.imul(sr, Hr) | 0, We = (We = We + Math.imul(sr, $r) | 0) + Math.imul(Jt, Hr) | 0, Xe = Xe + Math.imul(Jt, $r) | 0, gt = gt + Math.imul(Ht, Wr) | 0, We = (We = We + Math.imul(Ht, mr) | 0) + Math.imul(Gt, Wr) | 0, Xe = Xe + Math.imul(Gt, mr) | 0, gt = gt + Math.imul(ur, Kr) | 0, We = (We = We + Math.imul(ur, vr) | 0) + Math.imul(er, Kr) | 0, Xe = Xe + Math.imul(er, vr) | 0;
    var pr = (mt + (gt = gt + Math.imul(Xt, Jr) | 0) | 0) + ((8191 & (We = (We = We + Math.imul(Xt, xr) | 0) + Math.imul(zt, Jr) | 0)) << 13) | 0;
    mt = ((Xe = Xe + Math.imul(zt, xr) | 0) + (We >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, gt = Math.imul(Zr, Xr), We = (We = Math.imul(Zr, yr)) + Math.imul(Bt, Xr) | 0, Xe = Math.imul(Bt, yr), gt = gt + Math.imul(Nr, Yr) | 0, We = (We = We + Math.imul(Nr, wr) | 0) + Math.imul(dr, Yr) | 0, Xe = Xe + Math.imul(dr, wr) | 0, gt = gt + Math.imul(Br, Hr) | 0, We = (We = We + Math.imul(Br, $r) | 0) + Math.imul(or, Hr) | 0, Xe = Xe + Math.imul(or, $r) | 0, gt = gt + Math.imul(sr, Wr) | 0, We = (We = We + Math.imul(sr, mr) | 0) + Math.imul(Jt, Wr) | 0, Xe = Xe + Math.imul(Jt, mr) | 0, gt = gt + Math.imul(Ht, Kr) | 0, We = (We = We + Math.imul(Ht, vr) | 0) + Math.imul(Gt, Kr) | 0, Xe = Xe + Math.imul(Gt, vr) | 0;
    var Pr = (mt + (gt = gt + Math.imul(ur, Jr) | 0) | 0) + ((8191 & (We = (We = We + Math.imul(ur, xr) | 0) + Math.imul(er, Jr) | 0)) << 13) | 0;
    mt = ((Xe = Xe + Math.imul(er, xr) | 0) + (We >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, gt = Math.imul(Zr, Yr), We = (We = Math.imul(Zr, wr)) + Math.imul(Bt, Yr) | 0, Xe = Math.imul(Bt, wr), gt = gt + Math.imul(Nr, Hr) | 0, We = (We = We + Math.imul(Nr, $r) | 0) + Math.imul(dr, Hr) | 0, Xe = Xe + Math.imul(dr, $r) | 0, gt = gt + Math.imul(Br, Wr) | 0, We = (We = We + Math.imul(Br, mr) | 0) + Math.imul(or, Wr) | 0, Xe = Xe + Math.imul(or, mr) | 0, gt = gt + Math.imul(sr, Kr) | 0, We = (We = We + Math.imul(sr, vr) | 0) + Math.imul(Jt, Kr) | 0, Xe = Xe + Math.imul(Jt, vr) | 0;
    var Sr = (mt + (gt = gt + Math.imul(Ht, Jr) | 0) | 0) + ((8191 & (We = (We = We + Math.imul(Ht, xr) | 0) + Math.imul(Gt, Jr) | 0)) << 13) | 0;
    mt = ((Xe = Xe + Math.imul(Gt, xr) | 0) + (We >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, gt = Math.imul(Zr, Hr), We = (We = Math.imul(Zr, $r)) + Math.imul(Bt, Hr) | 0, Xe = Math.imul(Bt, $r), gt = gt + Math.imul(Nr, Wr) | 0, We = (We = We + Math.imul(Nr, mr) | 0) + Math.imul(dr, Wr) | 0, Xe = Xe + Math.imul(dr, mr) | 0, gt = gt + Math.imul(Br, Kr) | 0, We = (We = We + Math.imul(Br, vr) | 0) + Math.imul(or, Kr) | 0, Xe = Xe + Math.imul(or, vr) | 0;
    var Ur = (mt + (gt = gt + Math.imul(sr, Jr) | 0) | 0) + ((8191 & (We = (We = We + Math.imul(sr, xr) | 0) + Math.imul(Jt, Jr) | 0)) << 13) | 0;
    mt = ((Xe = Xe + Math.imul(Jt, xr) | 0) + (We >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, gt = Math.imul(Zr, Wr), We = (We = Math.imul(Zr, mr)) + Math.imul(Bt, Wr) | 0, Xe = Math.imul(Bt, mr), gt = gt + Math.imul(Nr, Kr) | 0, We = (We = We + Math.imul(Nr, vr) | 0) + Math.imul(dr, Kr) | 0, Xe = Xe + Math.imul(dr, vr) | 0;
    var jr = (mt + (gt = gt + Math.imul(Br, Jr) | 0) | 0) + ((8191 & (We = (We = We + Math.imul(Br, xr) | 0) + Math.imul(or, Jr) | 0)) << 13) | 0;
    mt = ((Xe = Xe + Math.imul(or, xr) | 0) + (We >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, gt = Math.imul(Zr, Kr), We = (We = Math.imul(Zr, vr)) + Math.imul(Bt, Kr) | 0, Xe = Math.imul(Bt, vr);
    var Gr = (mt + (gt = gt + Math.imul(Nr, Jr) | 0) | 0) + ((8191 & (We = (We = We + Math.imul(Nr, xr) | 0) + Math.imul(dr, Jr) | 0)) << 13) | 0;
    mt = ((Xe = Xe + Math.imul(dr, xr) | 0) + (We >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863;
    var Vr = (mt + (gt = Math.imul(Zr, Jr)) | 0) + ((8191 & (We = (We = Math.imul(Zr, xr)) + Math.imul(Bt, Jr) | 0)) << 13) | 0;
    return mt = ((Xe = Math.imul(Bt, xr)) + (We >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, ft[0] = tr, ft[1] = Dr, ft[2] = fr, ft[3] = Mr, ft[4] = Fr, ft[5] = qr, ft[6] = tn, ft[7] = Qr, ft[8] = nn, ft[9] = Er, ft[10] = Wt, ft[11] = nr, ft[12] = pr, ft[13] = Pr, ft[14] = Sr, ft[15] = Ur, ft[16] = jr, ft[17] = Gr, ft[18] = Vr, mt !== 0 && (ft[19] = mt, Ft.length++), Ft;
  };
  function vt(Pt, Ot, Ft) {
    return new wt().mulp(Pt, Ot, Ft);
  }
  function wt(Pt, Ot) {
    (this || i$3).x = Pt, (this || i$3).y = Ot;
  }
  Math.imul || ($t = bt), Ve.prototype.mulTo = function(Pt, Ot) {
    var Ft = (this || i$3).length + Pt.length;
    return (this || i$3).length === 10 && Pt.length === 10 ? $t(this || i$3, Pt, Ot) : Ft < 63 ? bt(this || i$3, Pt, Ot) : Ft < 1024 ? function(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative, Xe.length = gt.length + We.length;
      for (var rt = 0, ot = 0, ft = 0; ft < Xe.length - 1; ft++) {
        var mt = ot;
        ot = 0;
        for (var yt = 67108863 & rt, pt = Math.min(ft, We.length - 1), Ge = Math.max(0, ft - gt.length + 1); Ge <= pt; Ge++) {
          var ct = ft - Ge, Mt = (0 | gt.words[ct]) * (0 | We.words[Ge]), St = 67108863 & Mt;
          yt = 67108863 & (St = St + yt | 0), ot += (mt = (mt = mt + (Mt / 67108864 | 0) | 0) + (St >>> 26) | 0) >>> 26, mt &= 67108863;
        }
        Xe.words[ft] = yt, rt = mt, mt = ot;
      }
      return rt !== 0 ? Xe.words[ft] = rt : Xe.length--, Xe.strip();
    }(this || i$3, Pt, Ot) : vt(this || i$3, Pt, Ot);
  }, wt.prototype.makeRBT = function(Pt) {
    for (var Ot = new Array(Pt), Ft = Ve.prototype._countBits(Pt) - 1, gt = 0; gt < Pt; gt++)
      Ot[gt] = this.revBin(gt, Ft, Pt);
    return Ot;
  }, wt.prototype.revBin = function(Pt, Ot, Ft) {
    if (Pt === 0 || Pt === Ft - 1)
      return Pt;
    for (var gt = 0, We = 0; We < Ot; We++)
      gt |= (1 & Pt) << Ot - We - 1, Pt >>= 1;
    return gt;
  }, wt.prototype.permute = function(Pt, Ot, Ft, gt, We, Xe) {
    for (var rt = 0; rt < Xe; rt++)
      gt[rt] = Ot[Pt[rt]], We[rt] = Ft[Pt[rt]];
  }, wt.prototype.transform = function(Pt, Ot, Ft, gt, We, Xe) {
    this.permute(Xe, Pt, Ot, Ft, gt, We);
    for (var rt = 1; rt < We; rt <<= 1)
      for (var ot = rt << 1, ft = Math.cos(2 * Math.PI / ot), mt = Math.sin(2 * Math.PI / ot), yt = 0; yt < We; yt += ot)
        for (var pt = ft, Ge = mt, ct = 0; ct < rt; ct++) {
          var Mt = Ft[yt + ct], St = gt[yt + ct], At = Ft[yt + ct + rt], Nt = gt[yt + ct + rt], qt = pt * At - Ge * Nt;
          Nt = pt * Nt + Ge * At, At = qt, Ft[yt + ct] = Mt + At, gt[yt + ct] = St + Nt, Ft[yt + ct + rt] = Mt - At, gt[yt + ct + rt] = St - Nt, ct !== ot && (qt = ft * pt - mt * Ge, Ge = ft * Ge + mt * pt, pt = qt);
        }
  }, wt.prototype.guessLen13b = function(Pt, Ot) {
    var Ft = 1 | Math.max(Ot, Pt), gt = 1 & Ft, We = 0;
    for (Ft = Ft / 2 | 0; Ft; Ft >>>= 1)
      We++;
    return 1 << We + 1 + gt;
  }, wt.prototype.conjugate = function(Pt, Ot, Ft) {
    if (!(Ft <= 1))
      for (var gt = 0; gt < Ft / 2; gt++) {
        var We = Pt[gt];
        Pt[gt] = Pt[Ft - gt - 1], Pt[Ft - gt - 1] = We, We = Ot[gt], Ot[gt] = -Ot[Ft - gt - 1], Ot[Ft - gt - 1] = -We;
      }
  }, wt.prototype.normalize13b = function(Pt, Ot) {
    for (var Ft = 0, gt = 0; gt < Ot / 2; gt++) {
      var We = 8192 * Math.round(Pt[2 * gt + 1] / Ot) + Math.round(Pt[2 * gt] / Ot) + Ft;
      Pt[gt] = 67108863 & We, Ft = We < 67108864 ? 0 : We / 67108864 | 0;
    }
    return Pt;
  }, wt.prototype.convert13b = function(Pt, Ot, Ft, gt) {
    for (var We = 0, Xe = 0; Xe < Ot; Xe++)
      We += 0 | Pt[Xe], Ft[2 * Xe] = 8191 & We, We >>>= 13, Ft[2 * Xe + 1] = 8191 & We, We >>>= 13;
    for (Xe = 2 * Ot; Xe < gt; ++Xe)
      Ft[Xe] = 0;
    Fe(We === 0), Fe((-8192 & We) == 0);
  }, wt.prototype.stub = function(Pt) {
    for (var Ot = new Array(Pt), Ft = 0; Ft < Pt; Ft++)
      Ot[Ft] = 0;
    return Ot;
  }, wt.prototype.mulp = function(Pt, Ot, Ft) {
    var gt = 2 * this.guessLen13b(Pt.length, Ot.length), We = this.makeRBT(gt), Xe = this.stub(gt), rt = new Array(gt), ot = new Array(gt), ft = new Array(gt), mt = new Array(gt), yt = new Array(gt), pt = new Array(gt), Ge = Ft.words;
    Ge.length = gt, this.convert13b(Pt.words, Pt.length, rt, gt), this.convert13b(Ot.words, Ot.length, mt, gt), this.transform(rt, Xe, ot, ft, gt, We), this.transform(mt, Xe, yt, pt, gt, We);
    for (var ct = 0; ct < gt; ct++) {
      var Mt = ot[ct] * yt[ct] - ft[ct] * pt[ct];
      ft[ct] = ot[ct] * pt[ct] + ft[ct] * yt[ct], ot[ct] = Mt;
    }
    return this.conjugate(ot, ft, gt), this.transform(ot, ft, Ge, Xe, gt, We), this.conjugate(Ge, Xe, gt), this.normalize13b(Ge, gt), Ft.negative = Pt.negative ^ Ot.negative, Ft.length = Pt.length + Ot.length, Ft.strip();
  }, Ve.prototype.mul = function(Pt) {
    var Ot = new Ve(null);
    return Ot.words = new Array((this || i$3).length + Pt.length), this.mulTo(Pt, Ot);
  }, Ve.prototype.mulf = function(Pt) {
    var Ot = new Ve(null);
    return Ot.words = new Array((this || i$3).length + Pt.length), vt(this || i$3, Pt, Ot);
  }, Ve.prototype.imul = function(Pt) {
    return this.clone().mulTo(Pt, this || i$3);
  }, Ve.prototype.imuln = function(Pt) {
    Fe(typeof Pt == "number"), Fe(Pt < 67108864);
    for (var Ot = 0, Ft = 0; Ft < (this || i$3).length; Ft++) {
      var gt = (0 | (this || i$3).words[Ft]) * Pt, We = (67108863 & gt) + (67108863 & Ot);
      Ot >>= 26, Ot += gt / 67108864 | 0, Ot += We >>> 26, (this || i$3).words[Ft] = 67108863 & We;
    }
    return Ot !== 0 && ((this || i$3).words[Ft] = Ot, (this || i$3).length++), this || i$3;
  }, Ve.prototype.muln = function(Pt) {
    return this.clone().imuln(Pt);
  }, Ve.prototype.sqr = function() {
    return this.mul(this || i$3);
  }, Ve.prototype.isqr = function() {
    return this.imul(this.clone());
  }, Ve.prototype.pow = function(Pt) {
    var Ot = function(Xe) {
      for (var rt = new Array(Xe.bitLength()), ot = 0; ot < rt.length; ot++) {
        var ft = ot / 26 | 0, mt = ot % 26;
        rt[ot] = (Xe.words[ft] & 1 << mt) >>> mt;
      }
      return rt;
    }(Pt);
    if (Ot.length === 0)
      return new Ve(1);
    for (var Ft = this || i$3, gt = 0; gt < Ot.length && Ot[gt] === 0; gt++, Ft = Ft.sqr())
      ;
    if (++gt < Ot.length)
      for (var We = Ft.sqr(); gt < Ot.length; gt++, We = We.sqr())
        Ot[gt] !== 0 && (Ft = Ft.mul(We));
    return Ft;
  }, Ve.prototype.iushln = function(Pt) {
    Fe(typeof Pt == "number" && Pt >= 0);
    var Ot, Ft = Pt % 26, gt = (Pt - Ft) / 26, We = 67108863 >>> 26 - Ft << 26 - Ft;
    if (Ft !== 0) {
      var Xe = 0;
      for (Ot = 0; Ot < (this || i$3).length; Ot++) {
        var rt = (this || i$3).words[Ot] & We, ot = (0 | (this || i$3).words[Ot]) - rt << Ft;
        (this || i$3).words[Ot] = ot | Xe, Xe = rt >>> 26 - Ft;
      }
      Xe && ((this || i$3).words[Ot] = Xe, (this || i$3).length++);
    }
    if (gt !== 0) {
      for (Ot = (this || i$3).length - 1; Ot >= 0; Ot--)
        (this || i$3).words[Ot + gt] = (this || i$3).words[Ot];
      for (Ot = 0; Ot < gt; Ot++)
        (this || i$3).words[Ot] = 0;
      (this || i$3).length += gt;
    }
    return this.strip();
  }, Ve.prototype.ishln = function(Pt) {
    return Fe((this || i$3).negative === 0), this.iushln(Pt);
  }, Ve.prototype.iushrn = function(Pt, Ot, Ft) {
    var gt;
    Fe(typeof Pt == "number" && Pt >= 0), gt = Ot ? (Ot - Ot % 26) / 26 : 0;
    var We = Pt % 26, Xe = Math.min((Pt - We) / 26, (this || i$3).length), rt = 67108863 ^ 67108863 >>> We << We, ot = Ft;
    if (gt -= Xe, gt = Math.max(0, gt), ot) {
      for (var ft = 0; ft < Xe; ft++)
        ot.words[ft] = (this || i$3).words[ft];
      ot.length = Xe;
    }
    if (Xe !== 0)
      if ((this || i$3).length > Xe)
        for ((this || i$3).length -= Xe, ft = 0; ft < (this || i$3).length; ft++)
          (this || i$3).words[ft] = (this || i$3).words[ft + Xe];
      else
        (this || i$3).words[0] = 0, (this || i$3).length = 1;
    var mt = 0;
    for (ft = (this || i$3).length - 1; ft >= 0 && (mt !== 0 || ft >= gt); ft--) {
      var yt = 0 | (this || i$3).words[ft];
      (this || i$3).words[ft] = mt << 26 - We | yt >>> We, mt = yt & rt;
    }
    return ot && mt !== 0 && (ot.words[ot.length++] = mt), (this || i$3).length === 0 && ((this || i$3).words[0] = 0, (this || i$3).length = 1), this.strip();
  }, Ve.prototype.ishrn = function(Pt, Ot, Ft) {
    return Fe((this || i$3).negative === 0), this.iushrn(Pt, Ot, Ft);
  }, Ve.prototype.shln = function(Pt) {
    return this.clone().ishln(Pt);
  }, Ve.prototype.ushln = function(Pt) {
    return this.clone().iushln(Pt);
  }, Ve.prototype.shrn = function(Pt) {
    return this.clone().ishrn(Pt);
  }, Ve.prototype.ushrn = function(Pt) {
    return this.clone().iushrn(Pt);
  }, Ve.prototype.testn = function(Pt) {
    Fe(typeof Pt == "number" && Pt >= 0);
    var Ot = Pt % 26, Ft = (Pt - Ot) / 26, gt = 1 << Ot;
    return !((this || i$3).length <= Ft) && !!((this || i$3).words[Ft] & gt);
  }, Ve.prototype.imaskn = function(Pt) {
    Fe(typeof Pt == "number" && Pt >= 0);
    var Ot = Pt % 26, Ft = (Pt - Ot) / 26;
    if (Fe((this || i$3).negative === 0, "imaskn works only with positive numbers"), (this || i$3).length <= Ft)
      return this || i$3;
    if (Ot !== 0 && Ft++, (this || i$3).length = Math.min(Ft, (this || i$3).length), Ot !== 0) {
      var gt = 67108863 ^ 67108863 >>> Ot << Ot;
      (this || i$3).words[(this || i$3).length - 1] &= gt;
    }
    return this.strip();
  }, Ve.prototype.maskn = function(Pt) {
    return this.clone().imaskn(Pt);
  }, Ve.prototype.iaddn = function(Pt) {
    return Fe(typeof Pt == "number"), Fe(Pt < 67108864), Pt < 0 ? this.isubn(-Pt) : (this || i$3).negative !== 0 ? (this || i$3).length === 1 && (0 | (this || i$3).words[0]) < Pt ? ((this || i$3).words[0] = Pt - (0 | (this || i$3).words[0]), (this || i$3).negative = 0, this || i$3) : ((this || i$3).negative = 0, this.isubn(Pt), (this || i$3).negative = 1, this || i$3) : this._iaddn(Pt);
  }, Ve.prototype._iaddn = function(Pt) {
    (this || i$3).words[0] += Pt;
    for (var Ot = 0; Ot < (this || i$3).length && (this || i$3).words[Ot] >= 67108864; Ot++)
      (this || i$3).words[Ot] -= 67108864, Ot === (this || i$3).length - 1 ? (this || i$3).words[Ot + 1] = 1 : (this || i$3).words[Ot + 1]++;
    return (this || i$3).length = Math.max((this || i$3).length, Ot + 1), this || i$3;
  }, Ve.prototype.isubn = function(Pt) {
    if (Fe(typeof Pt == "number"), Fe(Pt < 67108864), Pt < 0)
      return this.iaddn(-Pt);
    if ((this || i$3).negative !== 0)
      return (this || i$3).negative = 0, this.iaddn(Pt), (this || i$3).negative = 1, this || i$3;
    if ((this || i$3).words[0] -= Pt, (this || i$3).length === 1 && (this || i$3).words[0] < 0)
      (this || i$3).words[0] = -(this || i$3).words[0], (this || i$3).negative = 1;
    else
      for (var Ot = 0; Ot < (this || i$3).length && (this || i$3).words[Ot] < 0; Ot++)
        (this || i$3).words[Ot] += 67108864, (this || i$3).words[Ot + 1] -= 1;
    return this.strip();
  }, Ve.prototype.addn = function(Pt) {
    return this.clone().iaddn(Pt);
  }, Ve.prototype.subn = function(Pt) {
    return this.clone().isubn(Pt);
  }, Ve.prototype.iabs = function() {
    return (this || i$3).negative = 0, this || i$3;
  }, Ve.prototype.abs = function() {
    return this.clone().iabs();
  }, Ve.prototype._ishlnsubmul = function(Pt, Ot, Ft) {
    var gt, We, Xe = Pt.length + Ft;
    this._expand(Xe);
    var rt = 0;
    for (gt = 0; gt < Pt.length; gt++) {
      We = (0 | (this || i$3).words[gt + Ft]) + rt;
      var ot = (0 | Pt.words[gt]) * Ot;
      rt = ((We -= 67108863 & ot) >> 26) - (ot / 67108864 | 0), (this || i$3).words[gt + Ft] = 67108863 & We;
    }
    for (; gt < (this || i$3).length - Ft; gt++)
      rt = (We = (0 | (this || i$3).words[gt + Ft]) + rt) >> 26, (this || i$3).words[gt + Ft] = 67108863 & We;
    if (rt === 0)
      return this.strip();
    for (Fe(rt === -1), rt = 0, gt = 0; gt < (this || i$3).length; gt++)
      rt = (We = -(0 | (this || i$3).words[gt]) + rt) >> 26, (this || i$3).words[gt] = 67108863 & We;
    return (this || i$3).negative = 1, this.strip();
  }, Ve.prototype._wordDiv = function(Pt, Ot) {
    var Ft = ((this || i$3).length, Pt.length), gt = this.clone(), We = Pt, Xe = 0 | We.words[We.length - 1];
    (Ft = 26 - this._countBits(Xe)) !== 0 && (We = We.ushln(Ft), gt.iushln(Ft), Xe = 0 | We.words[We.length - 1]);
    var rt, ot = gt.length - We.length;
    if (Ot !== "mod") {
      (rt = new Ve(null)).length = ot + 1, rt.words = new Array(rt.length);
      for (var ft = 0; ft < rt.length; ft++)
        rt.words[ft] = 0;
    }
    var mt = gt.clone()._ishlnsubmul(We, 1, ot);
    mt.negative === 0 && (gt = mt, rt && (rt.words[ot] = 1));
    for (var yt = ot - 1; yt >= 0; yt--) {
      var pt = 67108864 * (0 | gt.words[We.length + yt]) + (0 | gt.words[We.length + yt - 1]);
      for (pt = Math.min(pt / Xe | 0, 67108863), gt._ishlnsubmul(We, pt, yt); gt.negative !== 0; )
        pt--, gt.negative = 0, gt._ishlnsubmul(We, 1, yt), gt.isZero() || (gt.negative ^= 1);
      rt && (rt.words[yt] = pt);
    }
    return rt && rt.strip(), gt.strip(), Ot !== "div" && Ft !== 0 && gt.iushrn(Ft), { div: rt || null, mod: gt };
  }, Ve.prototype.divmod = function(Pt, Ot, Ft) {
    return Fe(!Pt.isZero()), this.isZero() ? { div: new Ve(0), mod: new Ve(0) } : (this || i$3).negative !== 0 && Pt.negative === 0 ? (Xe = this.neg().divmod(Pt, Ot), Ot !== "mod" && (gt = Xe.div.neg()), Ot !== "div" && (We = Xe.mod.neg(), Ft && We.negative !== 0 && We.iadd(Pt)), { div: gt, mod: We }) : (this || i$3).negative === 0 && Pt.negative !== 0 ? (Xe = this.divmod(Pt.neg(), Ot), Ot !== "mod" && (gt = Xe.div.neg()), { div: gt, mod: Xe.mod }) : (this || i$3).negative & Pt.negative ? (Xe = this.neg().divmod(Pt.neg(), Ot), Ot !== "div" && (We = Xe.mod.neg(), Ft && We.negative !== 0 && We.isub(Pt)), { div: Xe.div, mod: We }) : Pt.length > (this || i$3).length || this.cmp(Pt) < 0 ? { div: new Ve(0), mod: this || i$3 } : Pt.length === 1 ? Ot === "div" ? { div: this.divn(Pt.words[0]), mod: null } : Ot === "mod" ? { div: null, mod: new Ve(this.modn(Pt.words[0])) } : { div: this.divn(Pt.words[0]), mod: new Ve(this.modn(Pt.words[0])) } : this._wordDiv(Pt, Ot);
    var gt, We, Xe;
  }, Ve.prototype.div = function(Pt) {
    return this.divmod(Pt, "div", !1).div;
  }, Ve.prototype.mod = function(Pt) {
    return this.divmod(Pt, "mod", !1).mod;
  }, Ve.prototype.umod = function(Pt) {
    return this.divmod(Pt, "mod", !0).mod;
  }, Ve.prototype.divRound = function(Pt) {
    var Ot = this.divmod(Pt);
    if (Ot.mod.isZero())
      return Ot.div;
    var Ft = Ot.div.negative !== 0 ? Ot.mod.isub(Pt) : Ot.mod, gt = Pt.ushrn(1), We = Pt.andln(1), Xe = Ft.cmp(gt);
    return Xe < 0 || We === 1 && Xe === 0 ? Ot.div : Ot.div.negative !== 0 ? Ot.div.isubn(1) : Ot.div.iaddn(1);
  }, Ve.prototype.modn = function(Pt) {
    Fe(Pt <= 67108863);
    for (var Ot = (1 << 26) % Pt, Ft = 0, gt = (this || i$3).length - 1; gt >= 0; gt--)
      Ft = (Ot * Ft + (0 | (this || i$3).words[gt])) % Pt;
    return Ft;
  }, Ve.prototype.idivn = function(Pt) {
    Fe(Pt <= 67108863);
    for (var Ot = 0, Ft = (this || i$3).length - 1; Ft >= 0; Ft--) {
      var gt = (0 | (this || i$3).words[Ft]) + 67108864 * Ot;
      (this || i$3).words[Ft] = gt / Pt | 0, Ot = gt % Pt;
    }
    return this.strip();
  }, Ve.prototype.divn = function(Pt) {
    return this.clone().idivn(Pt);
  }, Ve.prototype.egcd = function(Pt) {
    Fe(Pt.negative === 0), Fe(!Pt.isZero());
    var Ot = this || i$3, Ft = Pt.clone();
    Ot = Ot.negative !== 0 ? Ot.umod(Pt) : Ot.clone();
    for (var gt = new Ve(1), We = new Ve(0), Xe = new Ve(0), rt = new Ve(1), ot = 0; Ot.isEven() && Ft.isEven(); )
      Ot.iushrn(1), Ft.iushrn(1), ++ot;
    for (var ft = Ft.clone(), mt = Ot.clone(); !Ot.isZero(); ) {
      for (var yt = 0, pt = 1; !(Ot.words[0] & pt) && yt < 26; ++yt, pt <<= 1)
        ;
      if (yt > 0)
        for (Ot.iushrn(yt); yt-- > 0; )
          (gt.isOdd() || We.isOdd()) && (gt.iadd(ft), We.isub(mt)), gt.iushrn(1), We.iushrn(1);
      for (var Ge = 0, ct = 1; !(Ft.words[0] & ct) && Ge < 26; ++Ge, ct <<= 1)
        ;
      if (Ge > 0)
        for (Ft.iushrn(Ge); Ge-- > 0; )
          (Xe.isOdd() || rt.isOdd()) && (Xe.iadd(ft), rt.isub(mt)), Xe.iushrn(1), rt.iushrn(1);
      Ot.cmp(Ft) >= 0 ? (Ot.isub(Ft), gt.isub(Xe), We.isub(rt)) : (Ft.isub(Ot), Xe.isub(gt), rt.isub(We));
    }
    return { a: Xe, b: rt, gcd: Ft.iushln(ot) };
  }, Ve.prototype._invmp = function(Pt) {
    Fe(Pt.negative === 0), Fe(!Pt.isZero());
    var Ot = this || i$3, Ft = Pt.clone();
    Ot = Ot.negative !== 0 ? Ot.umod(Pt) : Ot.clone();
    for (var gt, We = new Ve(1), Xe = new Ve(0), rt = Ft.clone(); Ot.cmpn(1) > 0 && Ft.cmpn(1) > 0; ) {
      for (var ot = 0, ft = 1; !(Ot.words[0] & ft) && ot < 26; ++ot, ft <<= 1)
        ;
      if (ot > 0)
        for (Ot.iushrn(ot); ot-- > 0; )
          We.isOdd() && We.iadd(rt), We.iushrn(1);
      for (var mt = 0, yt = 1; !(Ft.words[0] & yt) && mt < 26; ++mt, yt <<= 1)
        ;
      if (mt > 0)
        for (Ft.iushrn(mt); mt-- > 0; )
          Xe.isOdd() && Xe.iadd(rt), Xe.iushrn(1);
      Ot.cmp(Ft) >= 0 ? (Ot.isub(Ft), We.isub(Xe)) : (Ft.isub(Ot), Xe.isub(We));
    }
    return (gt = Ot.cmpn(1) === 0 ? We : Xe).cmpn(0) < 0 && gt.iadd(Pt), gt;
  }, Ve.prototype.gcd = function(Pt) {
    if (this.isZero())
      return Pt.abs();
    if (Pt.isZero())
      return this.abs();
    var Ot = this.clone(), Ft = Pt.clone();
    Ot.negative = 0, Ft.negative = 0;
    for (var gt = 0; Ot.isEven() && Ft.isEven(); gt++)
      Ot.iushrn(1), Ft.iushrn(1);
    for (; ; ) {
      for (; Ot.isEven(); )
        Ot.iushrn(1);
      for (; Ft.isEven(); )
        Ft.iushrn(1);
      var We = Ot.cmp(Ft);
      if (We < 0) {
        var Xe = Ot;
        Ot = Ft, Ft = Xe;
      } else if (We === 0 || Ft.cmpn(1) === 0)
        break;
      Ot.isub(Ft);
    }
    return Ft.iushln(gt);
  }, Ve.prototype.invm = function(Pt) {
    return this.egcd(Pt).a.umod(Pt);
  }, Ve.prototype.isEven = function() {
    return (1 & (this || i$3).words[0]) == 0;
  }, Ve.prototype.isOdd = function() {
    return (1 & (this || i$3).words[0]) == 1;
  }, Ve.prototype.andln = function(Pt) {
    return (this || i$3).words[0] & Pt;
  }, Ve.prototype.bincn = function(Pt) {
    Fe(typeof Pt == "number");
    var Ot = Pt % 26, Ft = (Pt - Ot) / 26, gt = 1 << Ot;
    if ((this || i$3).length <= Ft)
      return this._expand(Ft + 1), (this || i$3).words[Ft] |= gt, this || i$3;
    for (var We = gt, Xe = Ft; We !== 0 && Xe < (this || i$3).length; Xe++) {
      var rt = 0 | (this || i$3).words[Xe];
      We = (rt += We) >>> 26, rt &= 67108863, (this || i$3).words[Xe] = rt;
    }
    return We !== 0 && ((this || i$3).words[Xe] = We, (this || i$3).length++), this || i$3;
  }, Ve.prototype.isZero = function() {
    return (this || i$3).length === 1 && (this || i$3).words[0] === 0;
  }, Ve.prototype.cmpn = function(Pt) {
    var Ot, Ft = Pt < 0;
    if ((this || i$3).negative !== 0 && !Ft)
      return -1;
    if ((this || i$3).negative === 0 && Ft)
      return 1;
    if (this.strip(), (this || i$3).length > 1)
      Ot = 1;
    else {
      Ft && (Pt = -Pt), Fe(Pt <= 67108863, "Number is too big");
      var gt = 0 | (this || i$3).words[0];
      Ot = gt === Pt ? 0 : gt < Pt ? -1 : 1;
    }
    return (this || i$3).negative !== 0 ? 0 | -Ot : Ot;
  }, Ve.prototype.cmp = function(Pt) {
    if ((this || i$3).negative !== 0 && Pt.negative === 0)
      return -1;
    if ((this || i$3).negative === 0 && Pt.negative !== 0)
      return 1;
    var Ot = this.ucmp(Pt);
    return (this || i$3).negative !== 0 ? 0 | -Ot : Ot;
  }, Ve.prototype.ucmp = function(Pt) {
    if ((this || i$3).length > Pt.length)
      return 1;
    if ((this || i$3).length < Pt.length)
      return -1;
    for (var Ot = 0, Ft = (this || i$3).length - 1; Ft >= 0; Ft--) {
      var gt = 0 | (this || i$3).words[Ft], We = 0 | Pt.words[Ft];
      if (gt !== We) {
        gt < We ? Ot = -1 : gt > We && (Ot = 1);
        break;
      }
    }
    return Ot;
  }, Ve.prototype.gtn = function(Pt) {
    return this.cmpn(Pt) === 1;
  }, Ve.prototype.gt = function(Pt) {
    return this.cmp(Pt) === 1;
  }, Ve.prototype.gten = function(Pt) {
    return this.cmpn(Pt) >= 0;
  }, Ve.prototype.gte = function(Pt) {
    return this.cmp(Pt) >= 0;
  }, Ve.prototype.ltn = function(Pt) {
    return this.cmpn(Pt) === -1;
  }, Ve.prototype.lt = function(Pt) {
    return this.cmp(Pt) === -1;
  }, Ve.prototype.lten = function(Pt) {
    return this.cmpn(Pt) <= 0;
  }, Ve.prototype.lte = function(Pt) {
    return this.cmp(Pt) <= 0;
  }, Ve.prototype.eqn = function(Pt) {
    return this.cmpn(Pt) === 0;
  }, Ve.prototype.eq = function(Pt) {
    return this.cmp(Pt) === 0;
  }, Ve.red = function(Pt) {
    return new Lt(Pt);
  }, Ve.prototype.toRed = function(Pt) {
    return Fe(!(this || i$3).red, "Already a number in reduction context"), Fe((this || i$3).negative === 0, "red works only with positives"), Pt.convertTo(this || i$3)._forceRed(Pt);
  }, Ve.prototype.fromRed = function() {
    return Fe((this || i$3).red, "fromRed works only with numbers in reduction context"), (this || i$3).red.convertFrom(this || i$3);
  }, Ve.prototype._forceRed = function(Pt) {
    return (this || i$3).red = Pt, this || i$3;
  }, Ve.prototype.forceRed = function(Pt) {
    return Fe(!(this || i$3).red, "Already a number in reduction context"), this._forceRed(Pt);
  }, Ve.prototype.redAdd = function(Pt) {
    return Fe((this || i$3).red, "redAdd works only with red numbers"), (this || i$3).red.add(this || i$3, Pt);
  }, Ve.prototype.redIAdd = function(Pt) {
    return Fe((this || i$3).red, "redIAdd works only with red numbers"), (this || i$3).red.iadd(this || i$3, Pt);
  }, Ve.prototype.redSub = function(Pt) {
    return Fe((this || i$3).red, "redSub works only with red numbers"), (this || i$3).red.sub(this || i$3, Pt);
  }, Ve.prototype.redISub = function(Pt) {
    return Fe((this || i$3).red, "redISub works only with red numbers"), (this || i$3).red.isub(this || i$3, Pt);
  }, Ve.prototype.redShl = function(Pt) {
    return Fe((this || i$3).red, "redShl works only with red numbers"), (this || i$3).red.shl(this || i$3, Pt);
  }, Ve.prototype.redMul = function(Pt) {
    return Fe((this || i$3).red, "redMul works only with red numbers"), (this || i$3).red._verify2(this || i$3, Pt), (this || i$3).red.mul(this || i$3, Pt);
  }, Ve.prototype.redIMul = function(Pt) {
    return Fe((this || i$3).red, "redMul works only with red numbers"), (this || i$3).red._verify2(this || i$3, Pt), (this || i$3).red.imul(this || i$3, Pt);
  }, Ve.prototype.redSqr = function() {
    return Fe((this || i$3).red, "redSqr works only with red numbers"), (this || i$3).red._verify1(this || i$3), (this || i$3).red.sqr(this || i$3);
  }, Ve.prototype.redISqr = function() {
    return Fe((this || i$3).red, "redISqr works only with red numbers"), (this || i$3).red._verify1(this || i$3), (this || i$3).red.isqr(this || i$3);
  }, Ve.prototype.redSqrt = function() {
    return Fe((this || i$3).red, "redSqrt works only with red numbers"), (this || i$3).red._verify1(this || i$3), (this || i$3).red.sqrt(this || i$3);
  }, Ve.prototype.redInvm = function() {
    return Fe((this || i$3).red, "redInvm works only with red numbers"), (this || i$3).red._verify1(this || i$3), (this || i$3).red.invm(this || i$3);
  }, Ve.prototype.redNeg = function() {
    return Fe((this || i$3).red, "redNeg works only with red numbers"), (this || i$3).red._verify1(this || i$3), (this || i$3).red.neg(this || i$3);
  }, Ve.prototype.redPow = function(Pt) {
    return Fe((this || i$3).red && !Pt.red, "redPow(normalNum)"), (this || i$3).red._verify1(this || i$3), (this || i$3).red.pow(this || i$3, Pt);
  };
  var xt = { k256: null, p224: null, p192: null, p25519: null };
  function Et(Pt, Ot) {
    (this || i$3).name = Pt, (this || i$3).p = new Ve(Ot, 16), (this || i$3).n = (this || i$3).p.bitLength(), (this || i$3).k = new Ve(1).iushln((this || i$3).n).isub((this || i$3).p), (this || i$3).tmp = this._tmp();
  }
  function Tt() {
    Et.call(this || i$3, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
  }
  function Rt() {
    Et.call(this || i$3, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
  }
  function Ct() {
    Et.call(this || i$3, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
  }
  function Zt() {
    Et.call(this || i$3, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
  }
  function Lt(Pt) {
    if (typeof Pt == "string") {
      var Ot = Ve._prime(Pt);
      (this || i$3).m = Ot.p, (this || i$3).prime = Ot;
    } else
      Fe(Pt.gtn(1), "modulus must be greater than 1"), (this || i$3).m = Pt, (this || i$3).prime = null;
  }
  function Ut(Pt) {
    Lt.call(this || i$3, Pt), (this || i$3).shift = (this || i$3).m.bitLength(), (this || i$3).shift % 26 != 0 && ((this || i$3).shift += 26 - (this || i$3).shift % 26), (this || i$3).r = new Ve(1).iushln((this || i$3).shift), (this || i$3).r2 = this.imod((this || i$3).r.sqr()), (this || i$3).rinv = (this || i$3).r._invmp((this || i$3).m), (this || i$3).minv = (this || i$3).rinv.mul((this || i$3).r).isubn(1).div((this || i$3).m), (this || i$3).minv = (this || i$3).minv.umod((this || i$3).r), (this || i$3).minv = (this || i$3).r.sub((this || i$3).minv);
  }
  Et.prototype._tmp = function() {
    var Pt = new Ve(null);
    return Pt.words = new Array(Math.ceil((this || i$3).n / 13)), Pt;
  }, Et.prototype.ireduce = function(Pt) {
    var Ot, Ft = Pt;
    do
      this.split(Ft, (this || i$3).tmp), Ot = (Ft = (Ft = this.imulK(Ft)).iadd((this || i$3).tmp)).bitLength();
    while (Ot > (this || i$3).n);
    var gt = Ot < (this || i$3).n ? -1 : Ft.ucmp((this || i$3).p);
    return gt === 0 ? (Ft.words[0] = 0, Ft.length = 1) : gt > 0 ? Ft.isub((this || i$3).p) : Ft.strip(), Ft;
  }, Et.prototype.split = function(Pt, Ot) {
    Pt.iushrn((this || i$3).n, 0, Ot);
  }, Et.prototype.imulK = function(Pt) {
    return Pt.imul((this || i$3).k);
  }, Ke(Tt, Et), Tt.prototype.split = function(Pt, Ot) {
    for (var Ft = Math.min(Pt.length, 9), gt = 0; gt < Ft; gt++)
      Ot.words[gt] = Pt.words[gt];
    if (Ot.length = Ft, Pt.length <= 9)
      return Pt.words[0] = 0, Pt.length = 1, void 0;
    var We = Pt.words[9];
    for (Ot.words[Ot.length++] = 4194303 & We, gt = 10; gt < Pt.length; gt++) {
      var Xe = 0 | Pt.words[gt];
      Pt.words[gt - 10] = (4194303 & Xe) << 4 | We >>> 22, We = Xe;
    }
    We >>>= 22, Pt.words[gt - 10] = We, We === 0 && Pt.length > 10 ? Pt.length -= 10 : Pt.length -= 9;
  }, Tt.prototype.imulK = function(Pt) {
    Pt.words[Pt.length] = 0, Pt.words[Pt.length + 1] = 0, Pt.length += 2;
    for (var Ot = 0, Ft = 0; Ft < Pt.length; Ft++) {
      var gt = 0 | Pt.words[Ft];
      Ot += 977 * gt, Pt.words[Ft] = 67108863 & Ot, Ot = 64 * gt + (Ot / 67108864 | 0);
    }
    return Pt.words[Pt.length - 1] === 0 && (Pt.length--, Pt.words[Pt.length - 1] === 0 && Pt.length--), Pt;
  }, Ke(Rt, Et), Ke(Ct, Et), Ke(Zt, Et), Zt.prototype.imulK = function(Pt) {
    for (var Ot = 0, Ft = 0; Ft < Pt.length; Ft++) {
      var gt = 19 * (0 | Pt.words[Ft]) + Ot, We = 67108863 & gt;
      gt >>>= 26, Pt.words[Ft] = We, Ot = gt;
    }
    return Ot !== 0 && (Pt.words[Pt.length++] = Ot), Pt;
  }, Ve._prime = function(Pt) {
    if (xt[Pt])
      return xt[Pt];
    var Ot;
    if (Pt === "k256")
      Ot = new Tt();
    else if (Pt === "p224")
      Ot = new Rt();
    else if (Pt === "p192")
      Ot = new Ct();
    else {
      if (Pt !== "p25519")
        throw new Error("Unknown prime " + Pt);
      Ot = new Zt();
    }
    return xt[Pt] = Ot, Ot;
  }, Lt.prototype._verify1 = function(Pt) {
    Fe(Pt.negative === 0, "red works only with positives"), Fe(Pt.red, "red works only with red numbers");
  }, Lt.prototype._verify2 = function(Pt, Ot) {
    Fe((Pt.negative | Ot.negative) == 0, "red works only with positives"), Fe(Pt.red && Pt.red === Ot.red, "red works only with red numbers");
  }, Lt.prototype.imod = function(Pt) {
    return (this || i$3).prime ? (this || i$3).prime.ireduce(Pt)._forceRed(this || i$3) : Pt.umod((this || i$3).m)._forceRed(this || i$3);
  }, Lt.prototype.neg = function(Pt) {
    return Pt.isZero() ? Pt.clone() : (this || i$3).m.sub(Pt)._forceRed(this || i$3);
  }, Lt.prototype.add = function(Pt, Ot) {
    this._verify2(Pt, Ot);
    var Ft = Pt.add(Ot);
    return Ft.cmp((this || i$3).m) >= 0 && Ft.isub((this || i$3).m), Ft._forceRed(this || i$3);
  }, Lt.prototype.iadd = function(Pt, Ot) {
    this._verify2(Pt, Ot);
    var Ft = Pt.iadd(Ot);
    return Ft.cmp((this || i$3).m) >= 0 && Ft.isub((this || i$3).m), Ft;
  }, Lt.prototype.sub = function(Pt, Ot) {
    this._verify2(Pt, Ot);
    var Ft = Pt.sub(Ot);
    return Ft.cmpn(0) < 0 && Ft.iadd((this || i$3).m), Ft._forceRed(this || i$3);
  }, Lt.prototype.isub = function(Pt, Ot) {
    this._verify2(Pt, Ot);
    var Ft = Pt.isub(Ot);
    return Ft.cmpn(0) < 0 && Ft.iadd((this || i$3).m), Ft;
  }, Lt.prototype.shl = function(Pt, Ot) {
    return this._verify1(Pt), this.imod(Pt.ushln(Ot));
  }, Lt.prototype.imul = function(Pt, Ot) {
    return this._verify2(Pt, Ot), this.imod(Pt.imul(Ot));
  }, Lt.prototype.mul = function(Pt, Ot) {
    return this._verify2(Pt, Ot), this.imod(Pt.mul(Ot));
  }, Lt.prototype.isqr = function(Pt) {
    return this.imul(Pt, Pt.clone());
  }, Lt.prototype.sqr = function(Pt) {
    return this.mul(Pt, Pt);
  }, Lt.prototype.sqrt = function(Pt) {
    if (Pt.isZero())
      return Pt.clone();
    var Ot = (this || i$3).m.andln(3);
    if (Fe(Ot % 2 == 1), Ot === 3) {
      var Ft = (this || i$3).m.add(new Ve(1)).iushrn(2);
      return this.pow(Pt, Ft);
    }
    for (var gt = (this || i$3).m.subn(1), We = 0; !gt.isZero() && gt.andln(1) === 0; )
      We++, gt.iushrn(1);
    Fe(!gt.isZero());
    var Xe = new Ve(1).toRed(this || i$3), rt = Xe.redNeg(), ot = (this || i$3).m.subn(1).iushrn(1), ft = (this || i$3).m.bitLength();
    for (ft = new Ve(2 * ft * ft).toRed(this || i$3); this.pow(ft, ot).cmp(rt) !== 0; )
      ft.redIAdd(rt);
    for (var mt = this.pow(ft, gt), yt = this.pow(Pt, gt.addn(1).iushrn(1)), pt = this.pow(Pt, gt), Ge = We; pt.cmp(Xe) !== 0; ) {
      for (var ct = pt, Mt = 0; ct.cmp(Xe) !== 0; Mt++)
        ct = ct.redSqr();
      Fe(Mt < Ge);
      var St = this.pow(mt, new Ve(1).iushln(Ge - Mt - 1));
      yt = yt.redMul(St), mt = St.redSqr(), pt = pt.redMul(mt), Ge = Mt;
    }
    return yt;
  }, Lt.prototype.invm = function(Pt) {
    var Ot = Pt._invmp((this || i$3).m);
    return Ot.negative !== 0 ? (Ot.negative = 0, this.imod(Ot).redNeg()) : this.imod(Ot);
  }, Lt.prototype.pow = function(Pt, Ot) {
    if (Ot.isZero())
      return new Ve(1).toRed(this || i$3);
    if (Ot.cmpn(1) === 0)
      return Pt.clone();
    var Ft = new Array(16);
    Ft[0] = new Ve(1).toRed(this || i$3), Ft[1] = Pt;
    for (var gt = 2; gt < Ft.length; gt++)
      Ft[gt] = this.mul(Ft[gt - 1], Pt);
    var We = Ft[0], Xe = 0, rt = 0, ot = Ot.bitLength() % 26;
    for (ot === 0 && (ot = 26), gt = Ot.length - 1; gt >= 0; gt--) {
      for (var ft = Ot.words[gt], mt = ot - 1; mt >= 0; mt--) {
        var yt = ft >> mt & 1;
        We !== Ft[0] && (We = this.sqr(We)), yt !== 0 || Xe !== 0 ? (Xe <<= 1, Xe |= yt, (++rt === 4 || gt === 0 && mt === 0) && (We = this.mul(We, Ft[Xe]), rt = 0, Xe = 0)) : rt = 0;
      }
      ot = 26;
    }
    return We;
  }, Lt.prototype.convertTo = function(Pt) {
    var Ot = Pt.umod((this || i$3).m);
    return Ot === Pt ? Ot.clone() : Ot;
  }, Lt.prototype.convertFrom = function(Pt) {
    var Ot = Pt.clone();
    return Ot.red = null, Ot;
  }, Ve.mont = function(Pt) {
    return new Ut(Pt);
  }, Ke(Ut, Lt), Ut.prototype.convertTo = function(Pt) {
    return this.imod(Pt.ushln((this || i$3).shift));
  }, Ut.prototype.convertFrom = function(Pt) {
    var Ot = this.imod(Pt.mul((this || i$3).rinv));
    return Ot.red = null, Ot;
  }, Ut.prototype.imul = function(Pt, Ot) {
    if (Pt.isZero() || Ot.isZero())
      return Pt.words[0] = 0, Pt.length = 1, Pt;
    var Ft = Pt.imul(Ot), gt = Ft.maskn((this || i$3).shift).mul((this || i$3).minv).imaskn((this || i$3).shift).mul((this || i$3).m), We = Ft.isub(gt).iushrn((this || i$3).shift), Xe = We;
    return We.cmp((this || i$3).m) >= 0 ? Xe = We.isub((this || i$3).m) : We.cmpn(0) < 0 && (Xe = We.iadd((this || i$3).m)), Xe._forceRed(this || i$3);
  }, Ut.prototype.mul = function(Pt, Ot) {
    if (Pt.isZero() || Ot.isZero())
      return new Ve(0)._forceRed(this || i$3);
    var Ft = Pt.mul(Ot), gt = Ft.maskn((this || i$3).shift).mul((this || i$3).minv).imaskn((this || i$3).shift).mul((this || i$3).m), We = Ft.isub(gt).iushrn((this || i$3).shift), Xe = We;
    return We.cmp((this || i$3).m) >= 0 ? Xe = We.isub((this || i$3).m) : We.cmpn(0) < 0 && (Xe = We.iadd((this || i$3).m)), Xe._forceRed(this || i$3);
  }, Ut.prototype.invm = function(Pt) {
    return this.imod(Pt._invmp((this || i$3).m).mul((this || i$3).r2))._forceRed(this || i$3);
  };
})(h$a, r$7);
var n$c = h$a.exports, t$5, e$a, r$8 = Object.freeze({}), n$d = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function o$d($e) {
  (this || n$d).rand = $e;
}
if ((t$5 = function($e) {
  return e$a || (e$a = new o$d(null)), e$a.generate($e);
}).Rand = o$d, o$d.prototype.generate = function($e) {
  return this._rand($e);
}, o$d.prototype._rand = function($e) {
  if ((this || n$d).rand.getBytes)
    return (this || n$d).rand.getBytes($e);
  for (var Ze = new Uint8Array($e), Fe = 0; Fe < Ze.length; Fe++)
    Ze[Fe] = (this || n$d).rand.getByte();
  return Ze;
}, typeof self == "object")
  self.crypto && self.crypto.getRandomValues ? o$d.prototype._rand = function($e) {
    var Ze = new Uint8Array($e);
    return self.crypto.getRandomValues(Ze), Ze;
  } : self.msCrypto && self.msCrypto.getRandomValues ? o$d.prototype._rand = function($e) {
    var Ze = new Uint8Array($e);
    return self.msCrypto.getRandomValues(Ze), Ze;
  } : typeof window == "object" && (o$d.prototype._rand = function() {
    throw new Error("Not implemented yet");
  });
else
  try {
    if (a$e = r$8, typeof a$e.randomBytes != "function")
      throw new Error("Not supported");
    o$d.prototype._rand = function($e) {
      return a$e.randomBytes($e);
    };
  } catch ($e) {
  }
var a$e, f$i = t$5, n$e, t$6 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, o$e = n$c, a$f = f$i;
function d$b($e) {
  (this || t$6).rand = $e || new a$f.Rand();
}
n$e = d$b, d$b.create = function($e) {
  return new d$b($e);
}, d$b.prototype._randbelow = function($e) {
  var Ze = $e.bitLength(), Fe = Math.ceil(Ze / 8);
  do
    var Ke = new o$e((this || t$6).rand.generate(Fe));
  while (Ke.cmp($e) >= 0);
  return Ke;
}, d$b.prototype._randrange = function($e, Ze) {
  var Fe = Ze.sub($e);
  return $e.add(this._randbelow(Fe));
}, d$b.prototype.test = function($e, Ze, Fe) {
  var Ke = $e.bitLength(), Ve = o$e.mont($e), Je = new o$e(1).toRed(Ve);
  Ze || (Ze = Math.max(1, Ke / 48 | 0));
  for (var Qe = $e.subn(1), at = 0; !Qe.testn(at); at++)
    ;
  for (var ut = $e.shrn(at), lt = Qe.toRed(Ve); Ze > 0; Ze--) {
    var dt = this._randrange(new o$e(2), Qe);
    Fe && Fe(dt);
    var bt = dt.toRed(Ve).redPow(ut);
    if (bt.cmp(Je) !== 0 && bt.cmp(lt) !== 0) {
      for (var $t = 1; $t < at; $t++) {
        if ((bt = bt.redSqr()).cmp(Je) === 0)
          return !1;
        if (bt.cmp(lt) === 0)
          break;
      }
      if ($t === at)
        return !1;
    }
  }
  return !0;
}, d$b.prototype.getDivisor = function($e, Ze) {
  var Fe = $e.bitLength(), Ke = o$e.mont($e), Ve = new o$e(1).toRed(Ke);
  Ze || (Ze = Math.max(1, Fe / 48 | 0));
  for (var Je = $e.subn(1), Qe = 0; !Je.testn(Qe); Qe++)
    ;
  for (var at = $e.shrn(Qe), ut = Je.toRed(Ke); Ze > 0; Ze--) {
    var lt = this._randrange(new o$e(2), Je), dt = $e.gcd(lt);
    if (dt.cmpn(1) !== 0)
      return dt;
    var bt = lt.toRed(Ke).redPow(at);
    if (bt.cmp(Ve) !== 0 && bt.cmp(ut) !== 0) {
      for (var $t = 1; $t < Qe; $t++) {
        if ((bt = bt.redSqr()).cmp(Ve) === 0)
          return bt.fromRed().subn(1).gcd($e);
        if (bt.cmp(ut) === 0)
          break;
      }
      if ($t === Qe)
        return (bt = bt.redSqr()).fromRed().subn(1).gcd($e);
    }
  }
  return !1;
};
var i$4 = n$e, b$7, d$c = a5;
b$7 = v$9, v$9.simpleSieve = _$9, v$9.fermatTest = g$8;
var r$9 = n$c, t$7 = new r$9(24), n$f = new i$4(), i$5 = new r$9(1), o$f = new r$9(2), p$e = new r$9(5), s$c = (new r$9(16), new r$9(8), new r$9(10)), m$9 = new r$9(3), u$b = (new r$9(7), new r$9(11)), h$b = new r$9(4), w$a = (new r$9(12), null);
function l$c() {
  if (w$a !== null)
    return w$a;
  var $e = [];
  $e[0] = 2;
  for (var Ze = 1, Fe = 3; Fe < 1048576; Fe += 2) {
    for (var Ke = Math.ceil(Math.sqrt(Fe)), Ve = 0; Ve < Ze && $e[Ve] <= Ke && Fe % $e[Ve] != 0; Ve++)
      ;
    Ze !== Ve && $e[Ve] <= Ke || ($e[Ze++] = Fe);
  }
  return w$a = $e, $e;
}
function _$9($e) {
  for (var Ze = l$c(), Fe = 0; Fe < Ze.length; Fe++)
    if ($e.modn(Ze[Fe]) === 0)
      return $e.cmpn(Ze[Fe]) === 0;
  return !0;
}
function g$8($e) {
  var Ze = r$9.mont($e);
  return o$f.toRed(Ze).redPow($e.subn(1)).fromRed().cmpn(1) === 0;
}
function v$9($e, Ze) {
  if ($e < 16)
    return new r$9(Ze === 2 || Ze === 5 ? [140, 123] : [140, 39]);
  var Fe, Ke;
  for (Ze = new r$9(Ze); ; ) {
    for (Fe = new r$9(d$c(Math.ceil($e / 8))); Fe.bitLength() > $e; )
      Fe.ishrn(1);
    if (Fe.isEven() && Fe.iadd(i$5), Fe.testn(1) || Fe.iadd(o$f), Ze.cmp(o$f)) {
      if (!Ze.cmp(p$e))
        for (; Fe.mod(s$c).cmp(m$9); )
          Fe.iadd(h$b);
    } else
      for (; Fe.mod(t$7).cmp(u$b); )
        Fe.iadd(h$b);
    if (_$9(Ke = Fe.shrn(1)) && _$9(Fe) && g$8(Ke) && g$8(Fe) && n$f.test(Ke) && n$f.test(Fe))
      return Fe;
  }
}
var y$9, P$2 = b$7, B$5 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, K$2 = e$1$1$1.Buffer, R$1 = n$c, S$5 = new i$4(), x$2 = new R$1(24), C$2 = new R$1(11), D$2 = new R$1(10), G$1 = new R$1(3), H$2 = new R$1(7), T$3 = P$2, j$1 = a5;
function E$6($e, Ze) {
  return Ze = Ze || "utf8", K$2.isBuffer($e) || ($e = new K$2($e, Ze)), (this || B$5)._pub = new R$1($e), this || B$5;
}
function L$1($e, Ze) {
  return Ze = Ze || "utf8", K$2.isBuffer($e) || ($e = new K$2($e, Ze)), (this || B$5)._priv = new R$1($e), this || B$5;
}
y$9 = k$7;
var M$4 = {};
function k$7($e, Ze, Fe) {
  this.setGenerator(Ze), (this || B$5).__prime = new R$1($e), (this || B$5)._prime = R$1.mont((this || B$5).__prime), (this || B$5)._primeLen = $e.length, (this || B$5)._pub = void 0, (this || B$5)._priv = void 0, (this || B$5)._primeCode = void 0, Fe ? ((this || B$5).setPublicKey = E$6, (this || B$5).setPrivateKey = L$1) : (this || B$5)._primeCode = 8;
}
function A$5($e, Ze) {
  var Fe = new K$2($e.toArray());
  return Ze ? Fe.toString(Ze) : Fe;
}
Object.defineProperty(k$7.prototype, "verifyError", { enumerable: !0, get: function() {
  return typeof (this || B$5)._primeCode != "number" && ((this || B$5)._primeCode = function($e, Ze) {
    var Fe = Ze.toString("hex"), Ke = [Fe, $e.toString(16)].join("_");
    if (Ke in M$4)
      return M$4[Ke];
    var Ve, Je = 0;
    if ($e.isEven() || !T$3.simpleSieve || !T$3.fermatTest($e) || !S$5.test($e))
      return Je += 1, Je += Fe === "02" || Fe === "05" ? 8 : 4, M$4[Ke] = Je, Je;
    switch (S$5.test($e.shrn(1)) || (Je += 2), Fe) {
      case "02":
        $e.mod(x$2).cmp(C$2) && (Je += 8);
        break;
      case "05":
        (Ve = $e.mod(D$2)).cmp(G$1) && Ve.cmp(H$2) && (Je += 8);
        break;
      default:
        Je += 4;
    }
    return M$4[Ke] = Je, Je;
  }((this || B$5).__prime, (this || B$5).__gen)), (this || B$5)._primeCode;
} }), k$7.prototype.generateKeys = function() {
  return (this || B$5)._priv || ((this || B$5)._priv = new R$1(j$1((this || B$5)._primeLen))), (this || B$5)._pub = (this || B$5)._gen.toRed((this || B$5)._prime).redPow((this || B$5)._priv).fromRed(), this.getPublicKey();
}, k$7.prototype.computeSecret = function($e) {
  var Ze = ($e = ($e = new R$1($e)).toRed((this || B$5)._prime)).redPow((this || B$5)._priv).fromRed(), Fe = new K$2(Ze.toArray()), Ke = this.getPrime();
  if (Fe.length < Ke.length) {
    var Ve = new K$2(Ke.length - Fe.length);
    Ve.fill(0), Fe = K$2.concat([Ve, Fe]);
  }
  return Fe;
}, k$7.prototype.getPublicKey = function($e) {
  return A$5((this || B$5)._pub, $e);
}, k$7.prototype.getPrivateKey = function($e) {
  return A$5((this || B$5)._priv, $e);
}, k$7.prototype.getPrime = function($e) {
  return A$5((this || B$5).__prime, $e);
}, k$7.prototype.getGenerator = function($e) {
  return A$5((this || B$5)._gen, $e);
}, k$7.prototype.setGenerator = function($e, Ze) {
  return Ze = Ze || "utf8", K$2.isBuffer($e) || ($e = new K$2($e, Ze)), (this || B$5).__gen = $e, (this || B$5)._gen = new R$1($e), this || B$5;
};
var q$1 = y$9, O$3 = {}, z$3 = e$1$1$1.Buffer, F$3 = P$2, I$6 = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } }, J$1 = q$1, N$2 = { binary: !0, hex: !0, base64: !0 };
O$3.DiffieHellmanGroup = O$3.createDiffieHellmanGroup = O$3.getDiffieHellman = function($e) {
  var Ze = new z$3(I$6[$e].prime, "hex"), Fe = new z$3(I$6[$e].gen, "hex");
  return new J$1(Ze, Fe);
}, O$3.createDiffieHellman = O$3.DiffieHellman = function $e(Ze, Fe, Ke, Ve) {
  return z$3.isBuffer(Fe) || N$2[Fe] === void 0 ? $e(Ze, "binary", Fe, Ke) : (Fe = Fe || "binary", Ve = Ve || "binary", Ke = Ke || new z$3([2]), z$3.isBuffer(Ke) || (Ke = new z$3(Ke, Ve)), typeof Ze == "number" ? new J$1(F$3(Ze, Ke), Ke, !0) : (z$3.isBuffer(Ze) || (Ze = new z$3(Ze, Fe)), new J$1(Ze, Ke, !0)));
};
var m$a, u$c = e$1$1$1.Buffer, n$g = n$c, d$d = a5;
function t$8($e, Ze) {
  var Fe = function(vt) {
    var wt = i$6(vt);
    return { blinder: wt.toRed(n$g.mont(vt.modulus)).redPow(new n$g(vt.publicExponent)).fromRed(), unblinder: wt.invm(vt.modulus) };
  }(Ze), Ke = Ze.modulus.byteLength(), Ve = (n$g.mont(Ze.modulus), new n$g($e).mul(Fe.blinder).umod(Ze.modulus)), Je = Ve.toRed(n$g.mont(Ze.prime1)), Qe = Ve.toRed(n$g.mont(Ze.prime2)), at = Ze.coefficient, ut = Ze.prime1, lt = Ze.prime2, dt = Je.redPow(Ze.exponent1), bt = Qe.redPow(Ze.exponent2);
  dt = dt.fromRed(), bt = bt.fromRed();
  var $t = dt.isub(bt).imul(at).umod(ut);
  return $t.imul(lt), bt.iadd($t), new u$c(bt.imul(Fe.unblinder).umod(Ze.modulus).toArray(!1, Ke));
}
function i$6($e) {
  for (var Ze = $e.modulus.byteLength(), Fe = new n$g(d$d(Ze)); Fe.cmp($e.modulus) >= 0 || !Fe.umod($e.prime1) || !Fe.umod($e.prime2); )
    Fe = new n$g(d$d(Ze));
  return Fe;
}
m$a = t$8, t$8.getr = i$6;
var l$d = m$a, r$a = {}, e$b = r$a;
function t$9($e) {
  return $e.length === 1 ? "0" + $e : $e;
}
function n$h($e) {
  for (var Ze = "", Fe = 0; Fe < $e.length; Fe++)
    Ze += t$9($e[Fe].toString(16));
  return Ze;
}
e$b.toArray = function($e, Ze) {
  if (Array.isArray($e))
    return $e.slice();
  if (!$e)
    return [];
  var Fe = [];
  if (typeof $e != "string") {
    for (var Ke = 0; Ke < $e.length; Ke++)
      Fe[Ke] = 0 | $e[Ke];
    return Fe;
  }
  if (Ze === "hex")
    for (($e = $e.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && ($e = "0" + $e), Ke = 0; Ke < $e.length; Ke += 2)
      Fe.push(parseInt($e[Ke] + $e[Ke + 1], 16));
  else
    for (Ke = 0; Ke < $e.length; Ke++) {
      var Ve = $e.charCodeAt(Ke), Je = Ve >> 8, Qe = 255 & Ve;
      Je ? Fe.push(Je, Qe) : Fe.push(Qe);
    }
  return Fe;
}, e$b.zero2 = t$9, e$b.toHex = n$h, e$b.encode = function($e, Ze) {
  return Ze === "hex" ? n$h($e) : $e;
};
var n$i = {}, a$g = n$i, i$7 = n$c, o$g = o$7, c$d = r$a;
a$g.assert = o$g, a$g.toArray = c$d.toArray, a$g.zero2 = c$d.zero2, a$g.toHex = c$d.toHex, a$g.encode = c$d.encode, a$g.getNAF = function($e, Ze, Fe) {
  var Ke = new Array(Math.max($e.bitLength(), Fe) + 1);
  Ke.fill(0);
  for (var Ve = 1 << Ze + 1, Je = $e.clone(), Qe = 0; Qe < Ke.length; Qe++) {
    var at, ut = Je.andln(Ve - 1);
    Je.isOdd() ? (at = ut > (Ve >> 1) - 1 ? (Ve >> 1) - ut : ut, Je.isubn(at)) : at = 0, Ke[Qe] = at, Je.iushrn(1);
  }
  return Ke;
}, a$g.getJSF = function($e, Ze) {
  var Fe = [[], []];
  $e = $e.clone(), Ze = Ze.clone();
  for (var Ke = 0, Ve = 0; $e.cmpn(-Ke) > 0 || Ze.cmpn(-Ve) > 0; ) {
    var Je, Qe, at, ut = $e.andln(3) + Ke & 3, lt = Ze.andln(3) + Ve & 3;
    ut === 3 && (ut = -1), lt === 3 && (lt = -1), (1 & ut) == 0 ? Je = 0 : Je = (at = $e.andln(7) + Ke & 7) !== 3 && at !== 5 || lt !== 2 ? ut : -ut, Fe[0].push(Je), (1 & lt) == 0 ? Qe = 0 : Qe = (at = Ze.andln(7) + Ve & 7) !== 3 && at !== 5 || ut !== 2 ? lt : -lt, Fe[1].push(Qe), 2 * Ke === Je + 1 && (Ke = 1 - Ke), 2 * Ve === Qe + 1 && (Ve = 1 - Ve), $e.iushrn(1), Ze.iushrn(1);
  }
  return Fe;
}, a$g.cachedProperty = function($e, Ze, Fe) {
  var Ke = "_" + Ze;
  $e.prototype[Ze] = function() {
    return this[Ke] !== void 0 ? this[Ke] : this[Ke] = Fe.call(this);
  };
}, a$g.parseBytes = function($e) {
  return typeof $e == "string" ? a$g.toArray($e, "hex") : $e;
}, a$g.intFromLE = function($e) {
  return new i$7($e, "hex", "le");
};
var s$d, l$e = n$c, u$d = n$i, h$c = u$d.assert;
function p$f($e, Ze) {
  if ($e instanceof p$f)
    return $e;
  this._importDER($e, Ze) || (h$c($e.r && $e.s, "Signature without r or s"), this.r = new l$e($e.r, 16), this.s = new l$e($e.s, 16), $e.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = $e.recoveryParam);
}
function f$j() {
  this.place = 0;
}
function v$a($e, Ze) {
  var Fe = $e[Ze.place++];
  if (!(128 & Fe))
    return Fe;
  for (var Ke = 15 & Fe, Ve = 0, Je = 0, Qe = Ze.place; Je < Ke; Je++, Qe++)
    Ve <<= 8, Ve |= $e[Qe];
  return Ze.place = Qe, Ve;
}
function m$b($e) {
  for (var Ze = 0, Fe = $e.length - 1; !$e[Ze] && !(128 & $e[Ze + 1]) && Ze < Fe; )
    Ze++;
  return Ze === 0 ? $e : $e.slice(Ze);
}
function y$a($e, Ze) {
  if (Ze < 128)
    return $e.push(Ze), void 0;
  var Fe = 1 + (Math.log(Ze) / Math.LN2 >>> 3);
  for ($e.push(128 | Fe); --Fe; )
    $e.push(Ze >>> (Fe << 3) & 255);
  $e.push(Ze);
}
s$d = p$f, p$f.prototype._importDER = function($e, Ze) {
  $e = u$d.toArray($e, Ze);
  var Fe = new f$j();
  if ($e[Fe.place++] !== 48 || v$a($e, Fe) + Fe.place !== $e.length || $e[Fe.place++] !== 2)
    return !1;
  var Ke = v$a($e, Fe), Ve = $e.slice(Fe.place, Ke + Fe.place);
  if (Fe.place += Ke, $e[Fe.place++] !== 2)
    return !1;
  var Je = v$a($e, Fe);
  if ($e.length !== Je + Fe.place)
    return !1;
  var Qe = $e.slice(Fe.place, Je + Fe.place);
  return Ve[0] === 0 && 128 & Ve[1] && (Ve = Ve.slice(1)), Qe[0] === 0 && 128 & Qe[1] && (Qe = Qe.slice(1)), this.r = new l$e(Ve), this.s = new l$e(Qe), this.recoveryParam = null, !0;
}, p$f.prototype.toDER = function($e) {
  var Ze = this.r.toArray(), Fe = this.s.toArray();
  for (128 & Ze[0] && (Ze = [0].concat(Ze)), 128 & Fe[0] && (Fe = [0].concat(Fe)), Ze = m$b(Ze), Fe = m$b(Fe); !(Fe[0] || 128 & Fe[1]); )
    Fe = Fe.slice(1);
  var Ke = [2];
  y$a(Ke, Ze.length), (Ke = Ke.concat(Ze)).push(2), y$a(Ke, Fe.length);
  var Ve = Ke.concat(Fe), Je = [48];
  return y$a(Je, Ve.length), Je = Je.concat(Ve), u$d.encode(Je, $e);
};
var d$e = s$d, r$b = {}, i$8 = o$7, e$c = t$2;
function h$d($e, Ze) {
  return (64512 & $e.charCodeAt(Ze)) == 55296 && !(Ze < 0 || Ze + 1 >= $e.length) && (64512 & $e.charCodeAt(Ze + 1)) == 56320;
}
function o$h($e) {
  return ($e >>> 24 | $e >>> 8 & 65280 | $e << 8 & 16711680 | (255 & $e) << 24) >>> 0;
}
function u$e($e) {
  return $e.length === 1 ? "0" + $e : $e;
}
function s$e($e) {
  return $e.length === 7 ? "0" + $e : $e.length === 6 ? "00" + $e : $e.length === 5 ? "000" + $e : $e.length === 4 ? "0000" + $e : $e.length === 3 ? "00000" + $e : $e.length === 2 ? "000000" + $e : $e.length === 1 ? "0000000" + $e : $e;
}
r$b.inherits = e$c, r$b.toArray = function($e, Ze) {
  if (Array.isArray($e))
    return $e.slice();
  if (!$e)
    return [];
  var Fe = [];
  if (typeof $e == "string")
    if (Ze) {
      if (Ze === "hex")
        for (($e = $e.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && ($e = "0" + $e), Ve = 0; Ve < $e.length; Ve += 2)
          Fe.push(parseInt($e[Ve] + $e[Ve + 1], 16));
    } else
      for (var Ke = 0, Ve = 0; Ve < $e.length; Ve++) {
        var Je = $e.charCodeAt(Ve);
        Je < 128 ? Fe[Ke++] = Je : Je < 2048 ? (Fe[Ke++] = Je >> 6 | 192, Fe[Ke++] = 63 & Je | 128) : h$d($e, Ve) ? (Je = 65536 + ((1023 & Je) << 10) + (1023 & $e.charCodeAt(++Ve)), Fe[Ke++] = Je >> 18 | 240, Fe[Ke++] = Je >> 12 & 63 | 128, Fe[Ke++] = Je >> 6 & 63 | 128, Fe[Ke++] = 63 & Je | 128) : (Fe[Ke++] = Je >> 12 | 224, Fe[Ke++] = Je >> 6 & 63 | 128, Fe[Ke++] = 63 & Je | 128);
      }
  else
    for (Ve = 0; Ve < $e.length; Ve++)
      Fe[Ve] = 0 | $e[Ve];
  return Fe;
}, r$b.toHex = function($e) {
  for (var Ze = "", Fe = 0; Fe < $e.length; Fe++)
    Ze += u$e($e[Fe].toString(16));
  return Ze;
}, r$b.htonl = o$h, r$b.toHex32 = function($e, Ze) {
  for (var Fe = "", Ke = 0; Ke < $e.length; Ke++) {
    var Ve = $e[Ke];
    Ze === "little" && (Ve = o$h(Ve)), Fe += s$e(Ve.toString(16));
  }
  return Fe;
}, r$b.zero2 = u$e, r$b.zero8 = s$e, r$b.join32 = function($e, Ze, Fe, Ke) {
  var Ve = Fe - Ze;
  i$8(Ve % 4 == 0);
  for (var Je = new Array(Ve / 4), Qe = 0, at = Ze; Qe < Je.length; Qe++, at += 4) {
    var ut;
    ut = Ke === "big" ? $e[at] << 24 | $e[at + 1] << 16 | $e[at + 2] << 8 | $e[at + 3] : $e[at + 3] << 24 | $e[at + 2] << 16 | $e[at + 1] << 8 | $e[at], Je[Qe] = ut >>> 0;
  }
  return Je;
}, r$b.split32 = function($e, Ze) {
  for (var Fe = new Array(4 * $e.length), Ke = 0, Ve = 0; Ke < $e.length; Ke++, Ve += 4) {
    var Je = $e[Ke];
    Ze === "big" ? (Fe[Ve] = Je >>> 24, Fe[Ve + 1] = Je >>> 16 & 255, Fe[Ve + 2] = Je >>> 8 & 255, Fe[Ve + 3] = 255 & Je) : (Fe[Ve + 3] = Je >>> 24, Fe[Ve + 2] = Je >>> 16 & 255, Fe[Ve + 1] = Je >>> 8 & 255, Fe[Ve] = 255 & Je);
  }
  return Fe;
}, r$b.rotr32 = function($e, Ze) {
  return $e >>> Ze | $e << 32 - Ze;
}, r$b.rotl32 = function($e, Ze) {
  return $e << Ze | $e >>> 32 - Ze;
}, r$b.sum32 = function($e, Ze) {
  return $e + Ze >>> 0;
}, r$b.sum32_3 = function($e, Ze, Fe) {
  return $e + Ze + Fe >>> 0;
}, r$b.sum32_4 = function($e, Ze, Fe, Ke) {
  return $e + Ze + Fe + Ke >>> 0;
}, r$b.sum32_5 = function($e, Ze, Fe, Ke, Ve) {
  return $e + Ze + Fe + Ke + Ve >>> 0;
}, r$b.sum64 = function($e, Ze, Fe, Ke) {
  var Ve = $e[Ze], Je = Ke + $e[Ze + 1] >>> 0, Qe = (Je < Ke ? 1 : 0) + Fe + Ve;
  $e[Ze] = Qe >>> 0, $e[Ze + 1] = Je;
}, r$b.sum64_hi = function($e, Ze, Fe, Ke) {
  return (Ze + Ke >>> 0 < Ze ? 1 : 0) + $e + Fe >>> 0;
}, r$b.sum64_lo = function($e, Ze, Fe, Ke) {
  return Ze + Ke >>> 0;
}, r$b.sum64_4_hi = function($e, Ze, Fe, Ke, Ve, Je, Qe, at) {
  var ut = 0, lt = Ze;
  return ut += (lt = lt + Ke >>> 0) < Ze ? 1 : 0, ut += (lt = lt + Je >>> 0) < Je ? 1 : 0, $e + Fe + Ve + Qe + (ut += (lt = lt + at >>> 0) < at ? 1 : 0) >>> 0;
}, r$b.sum64_4_lo = function($e, Ze, Fe, Ke, Ve, Je, Qe, at) {
  return Ze + Ke + Je + at >>> 0;
}, r$b.sum64_5_hi = function($e, Ze, Fe, Ke, Ve, Je, Qe, at, ut, lt) {
  var dt = 0, bt = Ze;
  return dt += (bt = bt + Ke >>> 0) < Ze ? 1 : 0, dt += (bt = bt + Je >>> 0) < Je ? 1 : 0, dt += (bt = bt + at >>> 0) < at ? 1 : 0, $e + Fe + Ve + Qe + ut + (dt += (bt = bt + lt >>> 0) < lt ? 1 : 0) >>> 0;
}, r$b.sum64_5_lo = function($e, Ze, Fe, Ke, Ve, Je, Qe, at, ut, lt) {
  return Ze + Ke + Je + at + lt >>> 0;
}, r$b.rotr64_hi = function($e, Ze, Fe) {
  return (Ze << 32 - Fe | $e >>> Fe) >>> 0;
}, r$b.rotr64_lo = function($e, Ze, Fe) {
  return ($e << 32 - Fe | Ze >>> Fe) >>> 0;
}, r$b.shr64_hi = function($e, Ze, Fe) {
  return $e >>> Fe;
}, r$b.shr64_lo = function($e, Ze, Fe) {
  return ($e << 32 - Fe | Ze >>> Fe) >>> 0;
};
var a$h = {}, l$f = r$b, g$9 = o$7;
function c$e() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
a$h.BlockHash = c$e, c$e.prototype.update = function($e, Ze) {
  if ($e = l$f.toArray($e, Ze), this.pending ? this.pending = this.pending.concat($e) : this.pending = $e, this.pendingTotal += $e.length, this.pending.length >= this._delta8) {
    var Fe = ($e = this.pending).length % this._delta8;
    this.pending = $e.slice($e.length - Fe, $e.length), this.pending.length === 0 && (this.pending = null), $e = l$f.join32($e, 0, $e.length - Fe, this.endian);
    for (var Ke = 0; Ke < $e.length; Ke += this._delta32)
      this._update($e, Ke, Ke + this._delta32);
  }
  return this;
}, c$e.prototype.digest = function($e) {
  return this.update(this._pad()), g$9(this.pending === null), this._digest($e);
}, c$e.prototype._pad = function() {
  var $e = this.pendingTotal, Ze = this._delta8, Fe = Ze - ($e + this.padLength) % Ze, Ke = new Array(Fe + this.padLength);
  Ke[0] = 128;
  for (var Ve = 1; Ve < Fe; Ve++)
    Ke[Ve] = 0;
  if ($e <<= 3, this.endian === "big") {
    for (var Je = 8; Je < this.padLength; Je++)
      Ke[Ve++] = 0;
    Ke[Ve++] = 0, Ke[Ve++] = 0, Ke[Ve++] = 0, Ke[Ve++] = 0, Ke[Ve++] = $e >>> 24 & 255, Ke[Ve++] = $e >>> 16 & 255, Ke[Ve++] = $e >>> 8 & 255, Ke[Ve++] = 255 & $e;
  } else
    for (Ke[Ve++] = 255 & $e, Ke[Ve++] = $e >>> 8 & 255, Ke[Ve++] = $e >>> 16 & 255, Ke[Ve++] = $e >>> 24 & 255, Ke[Ve++] = 0, Ke[Ve++] = 0, Ke[Ve++] = 0, Ke[Ve++] = 0, Je = 8; Je < this.padLength; Je++)
      Ke[Ve++] = 0;
  return Ke;
};
var r$c, n$j = r$b, s$f = a$h, o$i = o$7, e$d = n$j.rotr64_hi, u$f = n$j.rotr64_lo, a$i = n$j.shr64_hi, c$f = n$j.shr64_lo, f$k = n$j.sum64, v$b = n$j.sum64_hi, _$a = n$j.sum64_lo, l$g = n$j.sum64_4_hi, p$g = n$j.sum64_4_lo, m$c = n$j.sum64_5_hi, g$a = n$j.sum64_5_lo, k$8 = s$f.BlockHash, d$f = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
function y$b() {
  if (!(this instanceof y$b))
    return new y$b();
  k$8.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = d$f, this.W = new Array(160);
}
function b$8($e, Ze, Fe, Ke, Ve) {
  var Je = $e & Fe ^ ~$e & Ve;
  return Je < 0 && (Je += 4294967296), Je;
}
function x$3($e, Ze, Fe, Ke, Ve, Je) {
  var Qe = Ze & Ke ^ ~Ze & Je;
  return Qe < 0 && (Qe += 4294967296), Qe;
}
function B$6($e, Ze, Fe, Ke, Ve) {
  var Je = $e & Fe ^ $e & Ve ^ Fe & Ve;
  return Je < 0 && (Je += 4294967296), Je;
}
function S$6($e, Ze, Fe, Ke, Ve, Je) {
  var Qe = Ze & Ke ^ Ze & Je ^ Ke & Je;
  return Qe < 0 && (Qe += 4294967296), Qe;
}
function W$1($e, Ze) {
  var Fe = e$d($e, Ze, 28) ^ e$d(Ze, $e, 2) ^ e$d(Ze, $e, 7);
  return Fe < 0 && (Fe += 4294967296), Fe;
}
function w$b($e, Ze) {
  var Fe = u$f($e, Ze, 28) ^ u$f(Ze, $e, 2) ^ u$f(Ze, $e, 7);
  return Fe < 0 && (Fe += 4294967296), Fe;
}
function z$4($e, Ze) {
  var Fe = e$d($e, Ze, 14) ^ e$d($e, Ze, 18) ^ e$d(Ze, $e, 9);
  return Fe < 0 && (Fe += 4294967296), Fe;
}
function H$3($e, Ze) {
  var Fe = u$f($e, Ze, 14) ^ u$f($e, Ze, 18) ^ u$f(Ze, $e, 9);
  return Fe < 0 && (Fe += 4294967296), Fe;
}
function j$2($e, Ze) {
  var Fe = e$d($e, Ze, 1) ^ e$d($e, Ze, 8) ^ a$i($e, Ze, 7);
  return Fe < 0 && (Fe += 4294967296), Fe;
}
function A$6($e, Ze) {
  var Fe = u$f($e, Ze, 1) ^ u$f($e, Ze, 8) ^ c$f($e, Ze, 7);
  return Fe < 0 && (Fe += 4294967296), Fe;
}
function L$2($e, Ze) {
  var Fe = e$d($e, Ze, 19) ^ e$d(Ze, $e, 29) ^ a$i($e, Ze, 6);
  return Fe < 0 && (Fe += 4294967296), Fe;
}
function q$2($e, Ze) {
  var Fe = u$f($e, Ze, 19) ^ u$f(Ze, $e, 29) ^ c$f($e, Ze, 6);
  return Fe < 0 && (Fe += 4294967296), Fe;
}
n$j.inherits(y$b, k$8), r$c = y$b, y$b.blockSize = 1024, y$b.outSize = 512, y$b.hmacStrength = 192, y$b.padLength = 128, y$b.prototype._prepareBlock = function($e, Ze) {
  for (var Fe = this.W, Ke = 0; Ke < 32; Ke++)
    Fe[Ke] = $e[Ze + Ke];
  for (; Ke < Fe.length; Ke += 2) {
    var Ve = L$2(Fe[Ke - 4], Fe[Ke - 3]), Je = q$2(Fe[Ke - 4], Fe[Ke - 3]), Qe = Fe[Ke - 14], at = Fe[Ke - 13], ut = j$2(Fe[Ke - 30], Fe[Ke - 29]), lt = A$6(Fe[Ke - 30], Fe[Ke - 29]), dt = Fe[Ke - 32], bt = Fe[Ke - 31];
    Fe[Ke] = l$g(Ve, Je, Qe, at, ut, lt, dt, bt), Fe[Ke + 1] = p$g(Ve, Je, Qe, at, ut, lt, dt, bt);
  }
}, y$b.prototype._update = function($e, Ze) {
  this._prepareBlock($e, Ze);
  var Fe = this.W, Ke = this.h[0], Ve = this.h[1], Je = this.h[2], Qe = this.h[3], at = this.h[4], ut = this.h[5], lt = this.h[6], dt = this.h[7], bt = this.h[8], $t = this.h[9], vt = this.h[10], wt = this.h[11], xt = this.h[12], Et = this.h[13], Tt = this.h[14], Rt = this.h[15];
  o$i(this.k.length === Fe.length);
  for (var Ct = 0; Ct < Fe.length; Ct += 2) {
    var Zt = Tt, Lt = Rt, Ut = z$4(bt, $t), Pt = H$3(bt, $t), Ot = b$8(bt, $t, vt, wt, xt), Ft = x$3(bt, $t, vt, wt, xt, Et), gt = this.k[Ct], We = this.k[Ct + 1], Xe = Fe[Ct], rt = Fe[Ct + 1], ot = m$c(Zt, Lt, Ut, Pt, Ot, Ft, gt, We, Xe, rt), ft = g$a(Zt, Lt, Ut, Pt, Ot, Ft, gt, We, Xe, rt);
    Zt = W$1(Ke, Ve), Lt = w$b(Ke, Ve), Ut = B$6(Ke, Ve, Je, Qe, at), Pt = S$6(Ke, Ve, Je, Qe, at, ut);
    var mt = v$b(Zt, Lt, Ut, Pt), yt = _$a(Zt, Lt, Ut, Pt);
    Tt = xt, Rt = Et, xt = vt, Et = wt, vt = bt, wt = $t, bt = v$b(lt, dt, ot, ft), $t = _$a(dt, dt, ot, ft), lt = at, dt = ut, at = Je, ut = Qe, Je = Ke, Qe = Ve, Ke = v$b(ot, ft, mt, yt), Ve = _$a(ot, ft, mt, yt);
  }
  f$k(this.h, 0, Ke, Ve), f$k(this.h, 2, Je, Qe), f$k(this.h, 4, at, ut), f$k(this.h, 6, lt, dt), f$k(this.h, 8, bt, $t), f$k(this.h, 10, vt, wt), f$k(this.h, 12, xt, Et), f$k(this.h, 14, Tt, Rt);
}, y$b.prototype._digest = function($e) {
  return $e === "hex" ? n$j.toHex32(this.h, "big") : n$j.split32(this.h, "big");
};
var C$3 = r$c, s$g = {}, n$k = r$b.rotr32;
function r$d($e, Ze, Fe) {
  return $e & Ze ^ ~$e & Fe;
}
function e$e($e, Ze, Fe) {
  return $e & Ze ^ $e & Fe ^ Ze & Fe;
}
function o$j($e, Ze, Fe) {
  return $e ^ Ze ^ Fe;
}
s$g.ft_1 = function($e, Ze, Fe, Ke) {
  return $e === 0 ? r$d(Ze, Fe, Ke) : $e === 1 || $e === 3 ? o$j(Ze, Fe, Ke) : $e === 2 ? e$e(Ze, Fe, Ke) : void 0;
}, s$g.ch32 = r$d, s$g.maj32 = e$e, s$g.p32 = o$j, s$g.s0_256 = function($e) {
  return n$k($e, 2) ^ n$k($e, 13) ^ n$k($e, 22);
}, s$g.s1_256 = function($e) {
  return n$k($e, 6) ^ n$k($e, 11) ^ n$k($e, 25);
}, s$g.g0_256 = function($e) {
  return n$k($e, 7) ^ n$k($e, 18) ^ $e >>> 3;
}, s$g.g1_256 = function($e) {
  return n$k($e, 17) ^ n$k($e, 19) ^ $e >>> 10;
};
var u$g, a$j = r$b, c$g = a$h, f$l = s$g, _$b = o$7, g$b = a$j.sum32, m$d = a$j.sum32_4, p$h = a$j.sum32_5, l$h = f$l.ch32, v$c = f$l.maj32, d$g = f$l.s0_256, k$9 = f$l.s1_256, b$9 = f$l.g0_256, j$3 = f$l.g1_256, x$4 = c$g.BlockHash, y$c = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
function S$7() {
  if (!(this instanceof S$7))
    return new S$7();
  x$4.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = y$c, this.W = new Array(64);
}
a$j.inherits(S$7, x$4), u$g = S$7, S$7.blockSize = 512, S$7.outSize = 256, S$7.hmacStrength = 192, S$7.padLength = 64, S$7.prototype._update = function($e, Ze) {
  for (var Fe = this.W, Ke = 0; Ke < 16; Ke++)
    Fe[Ke] = $e[Ze + Ke];
  for (; Ke < Fe.length; Ke++)
    Fe[Ke] = m$d(j$3(Fe[Ke - 2]), Fe[Ke - 7], b$9(Fe[Ke - 15]), Fe[Ke - 16]);
  var Ve = this.h[0], Je = this.h[1], Qe = this.h[2], at = this.h[3], ut = this.h[4], lt = this.h[5], dt = this.h[6], bt = this.h[7];
  for (_$b(this.k.length === Fe.length), Ke = 0; Ke < Fe.length; Ke++) {
    var $t = p$h(bt, k$9(ut), l$h(ut, lt, dt), this.k[Ke], Fe[Ke]), vt = g$b(d$g(Ve), v$c(Ve, Je, Qe));
    bt = dt, dt = lt, lt = ut, ut = g$b(at, $t), at = Qe, Qe = Je, Je = Ve, Ve = g$b($t, vt);
  }
  this.h[0] = g$b(this.h[0], Ve), this.h[1] = g$b(this.h[1], Je), this.h[2] = g$b(this.h[2], Qe), this.h[3] = g$b(this.h[3], at), this.h[4] = g$b(this.h[4], ut), this.h[5] = g$b(this.h[5], lt), this.h[6] = g$b(this.h[6], dt), this.h[7] = g$b(this.h[7], bt);
}, S$7.prototype._digest = function($e) {
  return $e === "hex" ? a$j.toHex32(this.h, "big") : a$j.split32(this.h, "big");
};
var w$c = u$g, r$e, o$k = r$b, a$k = a$h, u$h = s$g, l$i = o$k.rotl32, c$h = o$k.sum32, p$i = o$k.sum32_5, f$m = u$h.ft_1, g$c = a$k.BlockHash, d$h = [1518500249, 1859775393, 2400959708, 3395469782];
function m$e() {
  if (!(this instanceof m$e))
    return new m$e();
  g$c.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
}
o$k.inherits(m$e, g$c), r$e = m$e, m$e.blockSize = 512, m$e.outSize = 160, m$e.hmacStrength = 80, m$e.padLength = 64, m$e.prototype._update = function($e, Ze) {
  for (var Fe = this.W, Ke = 0; Ke < 16; Ke++)
    Fe[Ke] = $e[Ze + Ke];
  for (; Ke < Fe.length; Ke++)
    Fe[Ke] = l$i(Fe[Ke - 3] ^ Fe[Ke - 8] ^ Fe[Ke - 14] ^ Fe[Ke - 16], 1);
  var Ve = this.h[0], Je = this.h[1], Qe = this.h[2], at = this.h[3], ut = this.h[4];
  for (Ke = 0; Ke < Fe.length; Ke++) {
    var lt = ~~(Ke / 20), dt = p$i(l$i(Ve, 5), f$m(lt, Je, Qe, at), ut, Fe[Ke], d$h[lt]);
    ut = at, at = Qe, Qe = l$i(Je, 30), Je = Ve, Ve = dt;
  }
  this.h[0] = c$h(this.h[0], Ve), this.h[1] = c$h(this.h[1], Je), this.h[2] = c$h(this.h[2], Qe), this.h[3] = c$h(this.h[3], at), this.h[4] = c$h(this.h[4], ut);
}, m$e.prototype._digest = function($e) {
  return $e === "hex" ? o$k.toHex32(this.h, "big") : o$k.split32(this.h, "big");
};
var S$8, _$c = r$e, b$a = r$b, z$5 = w$c;
function v$d() {
  if (!(this instanceof v$d))
    return new v$d();
  z$5.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
}
b$a.inherits(v$d, z$5), S$8 = v$d, v$d.blockSize = 512, v$d.outSize = 224, v$d.hmacStrength = 192, v$d.padLength = 64, v$d.prototype._digest = function($e) {
  return $e === "hex" ? b$a.toHex32(this.h.slice(0, 7), "big") : b$a.split32(this.h.slice(0, 7), "big");
};
var k$a, y$d = S$8, H$4 = r$b, w$d = C$3;
function x$5() {
  if (!(this instanceof x$5))
    return new x$5();
  w$d.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
}
H$4.inherits(x$5, w$d), k$a = x$5, x$5.blockSize = 1024, x$5.outSize = 384, x$5.hmacStrength = 192, x$5.padLength = 128, x$5.prototype._digest = function($e) {
  return $e === "hex" ? H$4.toHex32(this.h.slice(0, 12), "big") : H$4.split32(this.h.slice(0, 12), "big");
};
var L$3 = k$a, j$4 = {};
j$4.sha1 = _$c, j$4.sha224 = y$d, j$4.sha256 = w$c, j$4.sha384 = L$3, j$4.sha512 = C$3;
var A$7 = {}, B$7 = r$b, W$2 = a$h, q$3 = B$7.rotl32, C$4 = B$7.sum32, D$3 = B$7.sum32_3, E$7 = B$7.sum32_4, F$4 = W$2.BlockHash;
function G$2() {
  if (!(this instanceof G$2))
    return new G$2();
  F$4.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
function I$7($e, Ze, Fe, Ke) {
  return $e <= 15 ? Ze ^ Fe ^ Ke : $e <= 31 ? Ze & Fe | ~Ze & Ke : $e <= 47 ? (Ze | ~Fe) ^ Ke : $e <= 63 ? Ze & Ke | Fe & ~Ke : Ze ^ (Fe | ~Ke);
}
function J$2($e) {
  return $e <= 15 ? 0 : $e <= 31 ? 1518500249 : $e <= 47 ? 1859775393 : $e <= 63 ? 2400959708 : 2840853838;
}
function K$3($e) {
  return $e <= 15 ? 1352829926 : $e <= 31 ? 1548603684 : $e <= 47 ? 1836072691 : $e <= 63 ? 2053994217 : 0;
}
B$7.inherits(G$2, F$4), A$7.ripemd160 = G$2, G$2.blockSize = 512, G$2.outSize = 160, G$2.hmacStrength = 192, G$2.padLength = 64, G$2.prototype._update = function($e, Ze) {
  for (var Fe = this.h[0], Ke = this.h[1], Ve = this.h[2], Je = this.h[3], Qe = this.h[4], at = Fe, ut = Ke, lt = Ve, dt = Je, bt = Qe, $t = 0; $t < 80; $t++) {
    var vt = C$4(q$3(E$7(Fe, I$7($t, Ke, Ve, Je), $e[N$3[$t] + Ze], J$2($t)), P$3[$t]), Qe);
    Fe = Qe, Qe = Je, Je = q$3(Ve, 10), Ve = Ke, Ke = vt, vt = C$4(q$3(E$7(at, I$7(79 - $t, ut, lt, dt), $e[O$4[$t] + Ze], K$3($t)), Q$1[$t]), bt), at = bt, bt = dt, dt = q$3(lt, 10), lt = ut, ut = vt;
  }
  vt = D$3(this.h[1], Ve, dt), this.h[1] = D$3(this.h[2], Je, bt), this.h[2] = D$3(this.h[3], Qe, at), this.h[3] = D$3(this.h[4], Fe, ut), this.h[4] = D$3(this.h[0], Ke, lt), this.h[0] = vt;
}, G$2.prototype._digest = function($e) {
  return $e === "hex" ? B$7.toHex32(this.h, "little") : B$7.split32(this.h, "little");
};
var M$5, N$3 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], O$4 = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], P$3 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], Q$1 = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], R$2 = r$b, T$4 = o$7;
function U$5($e, Ze, Fe) {
  if (!(this instanceof U$5))
    return new U$5($e, Ze, Fe);
  this.Hash = $e, this.blockSize = $e.blockSize / 8, this.outSize = $e.outSize / 8, this.inner = null, this.outer = null, this._init(R$2.toArray(Ze, Fe));
}
M$5 = U$5, U$5.prototype._init = function($e) {
  $e.length > this.blockSize && ($e = new this.Hash().update($e).digest()), T$4($e.length <= this.blockSize);
  for (var Ze = $e.length; Ze < this.blockSize; Ze++)
    $e.push(0);
  for (Ze = 0; Ze < $e.length; Ze++)
    $e[Ze] ^= 54;
  for (this.inner = new this.Hash().update($e), Ze = 0; Ze < $e.length; Ze++)
    $e[Ze] ^= 106;
  this.outer = new this.Hash().update($e);
}, U$5.prototype.update = function($e, Ze) {
  return this.inner.update($e, Ze), this;
}, U$5.prototype.digest = function($e) {
  return this.outer.update(this.inner.digest()), this.outer.digest($e);
};
var V$2 = M$5, X$2 = {}, Y$1 = X$2;
Y$1.utils = r$b, Y$1.common = a$h, Y$1.sha = j$4, Y$1.ripemd = A$7, Y$1.hmac = V$2, Y$1.sha1 = Y$1.sha.sha1, Y$1.sha256 = Y$1.sha.sha256, Y$1.sha224 = Y$1.sha.sha224, Y$1.sha384 = Y$1.sha.sha384, Y$1.sha512 = Y$1.sha.sha512, Y$1.ripemd160 = Y$1.ripemd.ripemd160;
var s$h, h$e = X$2, r$f = r$a, n$l = o$7;
function o$l($e) {
  if (!(this instanceof o$l))
    return new o$l($e);
  this.hash = $e.hash, this.predResist = !!$e.predResist, this.outLen = this.hash.outSize, this.minEntropy = $e.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var Ze = r$f.toArray($e.entropy, $e.entropyEnc || "hex"), Fe = r$f.toArray($e.nonce, $e.nonceEnc || "hex"), Ke = r$f.toArray($e.pers, $e.persEnc || "hex");
  n$l(Ze.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(Ze, Fe, Ke);
}
s$h = o$l, o$l.prototype._init = function($e, Ze, Fe) {
  var Ke = $e.concat(Ze).concat(Fe);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var Ve = 0; Ve < this.V.length; Ve++)
    this.K[Ve] = 0, this.V[Ve] = 1;
  this._update(Ke), this._reseed = 1, this.reseedInterval = 281474976710656;
}, o$l.prototype._hmac = function() {
  return new h$e.hmac(this.hash, this.K);
}, o$l.prototype._update = function($e) {
  var Ze = this._hmac().update(this.V).update([0]);
  $e && (Ze = Ze.update($e)), this.K = Ze.digest(), this.V = this._hmac().update(this.V).digest(), $e && (this.K = this._hmac().update(this.V).update([1]).update($e).digest(), this.V = this._hmac().update(this.V).digest());
}, o$l.prototype.reseed = function($e, Ze, Fe, Ke) {
  typeof Ze != "string" && (Ke = Fe, Fe = Ze, Ze = null), $e = r$f.toArray($e, Ze), Fe = r$f.toArray(Fe, Ke), n$l($e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update($e.concat(Fe || [])), this._reseed = 1;
}, o$l.prototype.generate = function($e, Ze, Fe, Ke) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof Ze != "string" && (Ke = Fe, Fe = Ze, Ze = null), Fe && (Fe = r$f.toArray(Fe, Ke || "hex"), this._update(Fe));
  for (var Ve = []; Ve.length < $e; )
    this.V = this._hmac().update(this.V).digest(), Ve = Ve.concat(this.V);
  var Je = Ve.slice(0, $e);
  return this._update(Fe), this._reseed++, r$f.encode(Je, Ze);
};
var a$l = s$h, b$b, i$9 = n$c, n$m = n$i, s$i = n$m.getNAF, o$m = n$m.getJSF, u$i = n$m.assert;
function h$f($e, Ze) {
  this.type = $e, this.p = new i$9(Ze.p, 16), this.red = Ze.prime ? i$9.red(Ze.prime) : i$9.mont(this.p), this.zero = new i$9(0).toRed(this.red), this.one = new i$9(1).toRed(this.red), this.two = new i$9(2).toRed(this.red), this.n = Ze.n && new i$9(Ze.n, 16), this.g = Ze.g && this.pointFromJSON(Ze.g, Ze.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var Fe = this.n && this.p.div(this.n);
  !Fe || Fe.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
function p$j($e, Ze) {
  this.curve = $e, this.type = Ze, this.precomputed = null;
}
b$b = h$f, h$f.prototype.point = function() {
  throw new Error("Not implemented");
}, h$f.prototype.validate = function() {
  throw new Error("Not implemented");
}, h$f.prototype._fixedNafMul = function($e, Ze) {
  u$i($e.precomputed);
  var Fe = $e._getDoubles(), Ke = s$i(Ze, 1, this._bitLength), Ve = (1 << Fe.step + 1) - (Fe.step % 2 == 0 ? 2 : 1);
  Ve /= 3;
  for (var Je = [], Qe = 0; Qe < Ke.length; Qe += Fe.step) {
    var at = 0;
    for (Ze = Qe + Fe.step - 1; Ze >= Qe; Ze--)
      at = (at << 1) + Ke[Ze];
    Je.push(at);
  }
  for (var ut = this.jpoint(null, null, null), lt = this.jpoint(null, null, null), dt = Ve; dt > 0; dt--) {
    for (Qe = 0; Qe < Je.length; Qe++)
      (at = Je[Qe]) === dt ? lt = lt.mixedAdd(Fe.points[Qe]) : at === -dt && (lt = lt.mixedAdd(Fe.points[Qe].neg()));
    ut = ut.add(lt);
  }
  return ut.toP();
}, h$f.prototype._wnafMul = function($e, Ze) {
  var Fe = 4, Ke = $e._getNAFPoints(Fe);
  Fe = Ke.wnd;
  for (var Ve = Ke.points, Je = s$i(Ze, Fe, this._bitLength), Qe = this.jpoint(null, null, null), at = Je.length - 1; at >= 0; at--) {
    for (Ze = 0; at >= 0 && Je[at] === 0; at--)
      Ze++;
    if (at >= 0 && Ze++, Qe = Qe.dblp(Ze), at < 0)
      break;
    var ut = Je[at];
    u$i(ut !== 0), Qe = $e.type === "affine" ? ut > 0 ? Qe.mixedAdd(Ve[ut - 1 >> 1]) : Qe.mixedAdd(Ve[-ut - 1 >> 1].neg()) : ut > 0 ? Qe.add(Ve[ut - 1 >> 1]) : Qe.add(Ve[-ut - 1 >> 1].neg());
  }
  return $e.type === "affine" ? Qe.toP() : Qe;
}, h$f.prototype._wnafMulAdd = function($e, Ze, Fe, Ke, Ve) {
  for (var Je = this._wnafT1, Qe = this._wnafT2, at = this._wnafT3, ut = 0, lt = 0; lt < Ke; lt++) {
    var dt = (Pt = Ze[lt])._getNAFPoints($e);
    Je[lt] = dt.wnd, Qe[lt] = dt.points;
  }
  for (lt = Ke - 1; lt >= 1; lt -= 2) {
    var bt = lt - 1, $t = lt;
    if (Je[bt] === 1 && Je[$t] === 1) {
      var vt = [Ze[bt], null, null, Ze[$t]];
      Ze[bt].y.cmp(Ze[$t].y) === 0 ? (vt[1] = Ze[bt].add(Ze[$t]), vt[2] = Ze[bt].toJ().mixedAdd(Ze[$t].neg())) : Ze[bt].y.cmp(Ze[$t].y.redNeg()) === 0 ? (vt[1] = Ze[bt].toJ().mixedAdd(Ze[$t]), vt[2] = Ze[bt].add(Ze[$t].neg())) : (vt[1] = Ze[bt].toJ().mixedAdd(Ze[$t]), vt[2] = Ze[bt].toJ().mixedAdd(Ze[$t].neg()));
      var wt = [-3, -1, -5, -7, 0, 7, 5, 1, 3], xt = o$m(Fe[bt], Fe[$t]);
      ut = Math.max(xt[0].length, ut), at[bt] = new Array(ut), at[$t] = new Array(ut);
      for (var Et = 0; Et < ut; Et++) {
        var Tt = 0 | xt[0][Et], Rt = 0 | xt[1][Et];
        at[bt][Et] = wt[3 * (Tt + 1) + (Rt + 1)], at[$t][Et] = 0, Qe[bt] = vt;
      }
    } else
      at[bt] = s$i(Fe[bt], Je[bt], this._bitLength), at[$t] = s$i(Fe[$t], Je[$t], this._bitLength), ut = Math.max(at[bt].length, ut), ut = Math.max(at[$t].length, ut);
  }
  var Ct = this.jpoint(null, null, null), Zt = this._wnafT4;
  for (lt = ut; lt >= 0; lt--) {
    for (var Lt = 0; lt >= 0; ) {
      var Ut = !0;
      for (Et = 0; Et < Ke; Et++)
        Zt[Et] = 0 | at[Et][lt], Zt[Et] !== 0 && (Ut = !1);
      if (!Ut)
        break;
      Lt++, lt--;
    }
    if (lt >= 0 && Lt++, Ct = Ct.dblp(Lt), lt < 0)
      break;
    for (Et = 0; Et < Ke; Et++) {
      var Pt, Ot = Zt[Et];
      Ot !== 0 && (Ot > 0 ? Pt = Qe[Et][Ot - 1 >> 1] : Ot < 0 && (Pt = Qe[Et][-Ot - 1 >> 1].neg()), Ct = Pt.type === "affine" ? Ct.mixedAdd(Pt) : Ct.add(Pt));
    }
  }
  for (lt = 0; lt < Ke; lt++)
    Qe[lt] = null;
  return Ve ? Ct : Ct.toP();
}, h$f.BasePoint = p$j, p$j.prototype.eq = function() {
  throw new Error("Not implemented");
}, p$j.prototype.validate = function() {
  return this.curve.validate(this);
}, h$f.prototype.decodePoint = function($e, Ze) {
  $e = n$m.toArray($e, Ze);
  var Fe = this.p.byteLength();
  if (($e[0] === 4 || $e[0] === 6 || $e[0] === 7) && $e.length - 1 == 2 * Fe)
    return $e[0] === 6 ? u$i($e[$e.length - 1] % 2 == 0) : $e[0] === 7 && u$i($e[$e.length - 1] % 2 == 1), this.point($e.slice(1, 1 + Fe), $e.slice(1 + Fe, 1 + 2 * Fe));
  if (($e[0] === 2 || $e[0] === 3) && $e.length - 1 === Fe)
    return this.pointFromX($e.slice(1, 1 + Fe), $e[0] === 3);
  throw new Error("Unknown point format");
}, p$j.prototype.encodeCompressed = function($e) {
  return this.encode($e, !0);
}, p$j.prototype._encode = function($e) {
  var Ze = this.curve.p.byteLength(), Fe = this.getX().toArray("be", Ze);
  return $e ? [this.getY().isEven() ? 2 : 3].concat(Fe) : [4].concat(Fe, this.getY().toArray("be", Ze));
}, p$j.prototype.encode = function($e, Ze) {
  return n$m.encode(this._encode(Ze), $e);
}, p$j.prototype.precompute = function($e) {
  if (this.precomputed)
    return this;
  var Ze = { doubles: null, naf: null, beta: null };
  return Ze.naf = this._getNAFPoints(8), Ze.doubles = this._getDoubles(4, $e), Ze.beta = this._getBeta(), this.precomputed = Ze, this;
}, p$j.prototype._hasDoubles = function($e) {
  if (!this.precomputed)
    return !1;
  var Ze = this.precomputed.doubles;
  return !!Ze && Ze.points.length >= Math.ceil(($e.bitLength() + 1) / Ze.step);
}, p$j.prototype._getDoubles = function($e, Ze) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var Fe = [this], Ke = this, Ve = 0; Ve < Ze; Ve += $e) {
    for (var Je = 0; Je < $e; Je++)
      Ke = Ke.dbl();
    Fe.push(Ke);
  }
  return { step: $e, points: Fe };
}, p$j.prototype._getNAFPoints = function($e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var Ze = [this], Fe = (1 << $e) - 1, Ke = Fe === 1 ? null : this.dbl(), Ve = 1; Ve < Fe; Ve++)
    Ze[Ve] = Ze[Ve - 1].add(Ke);
  return { wnd: $e, points: Ze };
}, p$j.prototype._getBeta = function() {
  return null;
}, p$j.prototype.dblp = function($e) {
  for (var Ze = this, Fe = 0; Fe < $e; Fe++)
    Ze = Ze.dbl();
  return Ze;
};
var l$j, v$e = b$b, y$e = n$c, m$f = t$2, S$9 = v$e, g$d = n$i.assert;
function A$8($e) {
  S$9.call(this, "short", $e), this.a = new y$e($e.a, 16).toRed(this.red), this.b = new y$e($e.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism($e), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
function I$8($e, Ze, Fe, Ke) {
  S$9.BasePoint.call(this, $e, "affine"), Ze === null && Fe === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new y$e(Ze, 16), this.y = new y$e(Fe, 16), Ke && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
function w$e($e, Ze, Fe, Ke) {
  S$9.BasePoint.call(this, $e, "jacobian"), Ze === null && Fe === null && Ke === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new y$e(0)) : (this.x = new y$e(Ze, 16), this.y = new y$e(Fe, 16), this.z = new y$e(Ke, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
m$f(A$8, S$9), l$j = A$8, A$8.prototype._getEndomorphism = function($e) {
  if (this.zeroA && this.g && this.n && this.p.modn(3) === 1) {
    var Ze, Fe;
    if ($e.beta)
      Ze = new y$e($e.beta, 16).toRed(this.red);
    else {
      var Ke = this._getEndoRoots(this.p);
      Ze = (Ze = Ke[0].cmp(Ke[1]) < 0 ? Ke[0] : Ke[1]).toRed(this.red);
    }
    if ($e.lambda)
      Fe = new y$e($e.lambda, 16);
    else {
      var Ve = this._getEndoRoots(this.n);
      this.g.mul(Ve[0]).x.cmp(this.g.x.redMul(Ze)) === 0 ? Fe = Ve[0] : (Fe = Ve[1], g$d(this.g.mul(Fe).x.cmp(this.g.x.redMul(Ze)) === 0));
    }
    return { beta: Ze, lambda: Fe, basis: $e.basis ? $e.basis.map(function(Je) {
      return { a: new y$e(Je.a, 16), b: new y$e(Je.b, 16) };
    }) : this._getEndoBasis(Fe) };
  }
}, A$8.prototype._getEndoRoots = function($e) {
  var Ze = $e === this.p ? this.red : y$e.mont($e), Fe = new y$e(2).toRed(Ze).redInvm(), Ke = Fe.redNeg(), Ve = new y$e(3).toRed(Ze).redNeg().redSqrt().redMul(Fe);
  return [Ke.redAdd(Ve).fromRed(), Ke.redSub(Ve).fromRed()];
}, A$8.prototype._getEndoBasis = function($e) {
  for (var Ze, Fe, Ke, Ve, Je, Qe, at, ut, lt, dt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), bt = $e, $t = this.n.clone(), vt = new y$e(1), wt = new y$e(0), xt = new y$e(0), Et = new y$e(1), Tt = 0; bt.cmpn(0) !== 0; ) {
    var Rt = $t.div(bt);
    ut = $t.sub(Rt.mul(bt)), lt = xt.sub(Rt.mul(vt));
    var Ct = Et.sub(Rt.mul(wt));
    if (!Ke && ut.cmp(dt) < 0)
      Ze = at.neg(), Fe = vt, Ke = ut.neg(), Ve = lt;
    else if (Ke && ++Tt == 2)
      break;
    at = ut, $t = bt, bt = ut, xt = vt, vt = lt, Et = wt, wt = Ct;
  }
  Je = ut.neg(), Qe = lt;
  var Zt = Ke.sqr().add(Ve.sqr());
  return Je.sqr().add(Qe.sqr()).cmp(Zt) >= 0 && (Je = Ze, Qe = Fe), Ke.negative && (Ke = Ke.neg(), Ve = Ve.neg()), Je.negative && (Je = Je.neg(), Qe = Qe.neg()), [{ a: Ke, b: Ve }, { a: Je, b: Qe }];
}, A$8.prototype._endoSplit = function($e) {
  var Ze = this.endo.basis, Fe = Ze[0], Ke = Ze[1], Ve = Ke.b.mul($e).divRound(this.n), Je = Fe.b.neg().mul($e).divRound(this.n), Qe = Ve.mul(Fe.a), at = Je.mul(Ke.a), ut = Ve.mul(Fe.b), lt = Je.mul(Ke.b);
  return { k1: $e.sub(Qe).sub(at), k2: ut.add(lt).neg() };
}, A$8.prototype.pointFromX = function($e, Ze) {
  ($e = new y$e($e, 16)).red || ($e = $e.toRed(this.red));
  var Fe = $e.redSqr().redMul($e).redIAdd($e.redMul(this.a)).redIAdd(this.b), Ke = Fe.redSqrt();
  if (Ke.redSqr().redSub(Fe).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var Ve = Ke.fromRed().isOdd();
  return (Ze && !Ve || !Ze && Ve) && (Ke = Ke.redNeg()), this.point($e, Ke);
}, A$8.prototype.validate = function($e) {
  if ($e.inf)
    return !0;
  var Ze = $e.x, Fe = $e.y, Ke = this.a.redMul(Ze), Ve = Ze.redSqr().redMul(Ze).redIAdd(Ke).redIAdd(this.b);
  return Fe.redSqr().redISub(Ve).cmpn(0) === 0;
}, A$8.prototype._endoWnafMulAdd = function($e, Ze, Fe) {
  for (var Ke = this._endoWnafT1, Ve = this._endoWnafT2, Je = 0; Je < $e.length; Je++) {
    var Qe = this._endoSplit(Ze[Je]), at = $e[Je], ut = at._getBeta();
    Qe.k1.negative && (Qe.k1.ineg(), at = at.neg(!0)), Qe.k2.negative && (Qe.k2.ineg(), ut = ut.neg(!0)), Ke[2 * Je] = at, Ke[2 * Je + 1] = ut, Ve[2 * Je] = Qe.k1, Ve[2 * Je + 1] = Qe.k2;
  }
  for (var lt = this._wnafMulAdd(1, Ke, Ve, 2 * Je, Fe), dt = 0; dt < 2 * Je; dt++)
    Ke[dt] = null, Ve[dt] = null;
  return lt;
}, m$f(I$8, S$9.BasePoint), A$8.prototype.point = function($e, Ze, Fe) {
  return new I$8(this, $e, Ze, Fe);
}, A$8.prototype.pointFromJSON = function($e, Ze) {
  return I$8.fromJSON(this, $e, Ze);
}, I$8.prototype._getBeta = function() {
  if (this.curve.endo) {
    var $e = this.precomputed;
    if ($e && $e.beta)
      return $e.beta;
    var Ze = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if ($e) {
      var Fe = this.curve, Ke = function(Ve) {
        return Fe.point(Ve.x.redMul(Fe.endo.beta), Ve.y);
      };
      $e.beta = Ze, Ze.precomputed = { beta: null, naf: $e.naf && { wnd: $e.naf.wnd, points: $e.naf.points.map(Ke) }, doubles: $e.doubles && { step: $e.doubles.step, points: $e.doubles.points.map(Ke) } };
    }
    return Ze;
  }
}, I$8.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
}, I$8.fromJSON = function($e, Ze, Fe) {
  typeof Ze == "string" && (Ze = JSON.parse(Ze));
  var Ke = $e.point(Ze[0], Ze[1], Fe);
  if (!Ze[2])
    return Ke;
  function Ve(Qe) {
    return $e.point(Qe[0], Qe[1], Fe);
  }
  var Je = Ze[2];
  return Ke.precomputed = { beta: null, doubles: Je.doubles && { step: Je.doubles.step, points: [Ke].concat(Je.doubles.points.map(Ve)) }, naf: Je.naf && { wnd: Je.naf.wnd, points: [Ke].concat(Je.naf.points.map(Ve)) } }, Ke;
}, I$8.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
}, I$8.prototype.isInfinity = function() {
  return this.inf;
}, I$8.prototype.add = function($e) {
  if (this.inf)
    return $e;
  if ($e.inf)
    return this;
  if (this.eq($e))
    return this.dbl();
  if (this.neg().eq($e))
    return this.curve.point(null, null);
  if (this.x.cmp($e.x) === 0)
    return this.curve.point(null, null);
  var Ze = this.y.redSub($e.y);
  Ze.cmpn(0) !== 0 && (Ze = Ze.redMul(this.x.redSub($e.x).redInvm()));
  var Fe = Ze.redSqr().redISub(this.x).redISub($e.x), Ke = Ze.redMul(this.x.redSub(Fe)).redISub(this.y);
  return this.curve.point(Fe, Ke);
}, I$8.prototype.dbl = function() {
  if (this.inf)
    return this;
  var $e = this.y.redAdd(this.y);
  if ($e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var Ze = this.curve.a, Fe = this.x.redSqr(), Ke = $e.redInvm(), Ve = Fe.redAdd(Fe).redIAdd(Fe).redIAdd(Ze).redMul(Ke), Je = Ve.redSqr().redISub(this.x.redAdd(this.x)), Qe = Ve.redMul(this.x.redSub(Je)).redISub(this.y);
  return this.curve.point(Je, Qe);
}, I$8.prototype.getX = function() {
  return this.x.fromRed();
}, I$8.prototype.getY = function() {
  return this.y.fromRed();
}, I$8.prototype.mul = function($e) {
  return $e = new y$e($e, 16), this.isInfinity() ? this : this._hasDoubles($e) ? this.curve._fixedNafMul(this, $e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [$e]) : this.curve._wnafMul(this, $e);
}, I$8.prototype.mulAdd = function($e, Ze, Fe) {
  var Ke = [this, Ze], Ve = [$e, Fe];
  return this.curve.endo ? this.curve._endoWnafMulAdd(Ke, Ve) : this.curve._wnafMulAdd(1, Ke, Ve, 2);
}, I$8.prototype.jmulAdd = function($e, Ze, Fe) {
  var Ke = [this, Ze], Ve = [$e, Fe];
  return this.curve.endo ? this.curve._endoWnafMulAdd(Ke, Ve, !0) : this.curve._wnafMulAdd(1, Ke, Ve, 2, !0);
}, I$8.prototype.eq = function($e) {
  return this === $e || this.inf === $e.inf && (this.inf || this.x.cmp($e.x) === 0 && this.y.cmp($e.y) === 0);
}, I$8.prototype.neg = function($e) {
  if (this.inf)
    return this;
  var Ze = this.curve.point(this.x, this.y.redNeg());
  if ($e && this.precomputed) {
    var Fe = this.precomputed, Ke = function(Ve) {
      return Ve.neg();
    };
    Ze.precomputed = { naf: Fe.naf && { wnd: Fe.naf.wnd, points: Fe.naf.points.map(Ke) }, doubles: Fe.doubles && { step: Fe.doubles.step, points: Fe.doubles.points.map(Ke) } };
  }
  return Ze;
}, I$8.prototype.toJ = function() {
  return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one);
}, m$f(w$e, S$9.BasePoint), A$8.prototype.jpoint = function($e, Ze, Fe) {
  return new w$e(this, $e, Ze, Fe);
}, w$e.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var $e = this.z.redInvm(), Ze = $e.redSqr(), Fe = this.x.redMul(Ze), Ke = this.y.redMul(Ze).redMul($e);
  return this.curve.point(Fe, Ke);
}, w$e.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
}, w$e.prototype.add = function($e) {
  if (this.isInfinity())
    return $e;
  if ($e.isInfinity())
    return this;
  var Ze = $e.z.redSqr(), Fe = this.z.redSqr(), Ke = this.x.redMul(Ze), Ve = $e.x.redMul(Fe), Je = this.y.redMul(Ze.redMul($e.z)), Qe = $e.y.redMul(Fe.redMul(this.z)), at = Ke.redSub(Ve), ut = Je.redSub(Qe);
  if (at.cmpn(0) === 0)
    return ut.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var lt = at.redSqr(), dt = lt.redMul(at), bt = Ke.redMul(lt), $t = ut.redSqr().redIAdd(dt).redISub(bt).redISub(bt), vt = ut.redMul(bt.redISub($t)).redISub(Je.redMul(dt)), wt = this.z.redMul($e.z).redMul(at);
  return this.curve.jpoint($t, vt, wt);
}, w$e.prototype.mixedAdd = function($e) {
  if (this.isInfinity())
    return $e.toJ();
  if ($e.isInfinity())
    return this;
  var Ze = this.z.redSqr(), Fe = this.x, Ke = $e.x.redMul(Ze), Ve = this.y, Je = $e.y.redMul(Ze).redMul(this.z), Qe = Fe.redSub(Ke), at = Ve.redSub(Je);
  if (Qe.cmpn(0) === 0)
    return at.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var ut = Qe.redSqr(), lt = ut.redMul(Qe), dt = Fe.redMul(ut), bt = at.redSqr().redIAdd(lt).redISub(dt).redISub(dt), $t = at.redMul(dt.redISub(bt)).redISub(Ve.redMul(lt)), vt = this.z.redMul(Qe);
  return this.curve.jpoint(bt, $t, vt);
}, w$e.prototype.dblp = function($e) {
  if ($e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!$e)
    return this.dbl();
  if (this.curve.zeroA || this.curve.threeA) {
    for (var Ze = this, Fe = 0; Fe < $e; Fe++)
      Ze = Ze.dbl();
    return Ze;
  }
  var Ke = this.curve.a, Ve = this.curve.tinv, Je = this.x, Qe = this.y, at = this.z, ut = at.redSqr().redSqr(), lt = Qe.redAdd(Qe);
  for (Fe = 0; Fe < $e; Fe++) {
    var dt = Je.redSqr(), bt = lt.redSqr(), $t = bt.redSqr(), vt = dt.redAdd(dt).redIAdd(dt).redIAdd(Ke.redMul(ut)), wt = Je.redMul(bt), xt = vt.redSqr().redISub(wt.redAdd(wt)), Et = wt.redISub(xt), Tt = vt.redMul(Et);
    Tt = Tt.redIAdd(Tt).redISub($t);
    var Rt = lt.redMul(at);
    Fe + 1 < $e && (ut = ut.redMul($t)), Je = xt, at = Rt, lt = Tt;
  }
  return this.curve.jpoint(Je, lt.redMul(Ve), at);
}, w$e.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
}, w$e.prototype._zeroDbl = function() {
  var $e, Ze, Fe;
  if (this.zOne) {
    var Ke = this.x.redSqr(), Ve = this.y.redSqr(), Je = Ve.redSqr(), Qe = this.x.redAdd(Ve).redSqr().redISub(Ke).redISub(Je);
    Qe = Qe.redIAdd(Qe);
    var at = Ke.redAdd(Ke).redIAdd(Ke), ut = at.redSqr().redISub(Qe).redISub(Qe), lt = Je.redIAdd(Je);
    lt = (lt = lt.redIAdd(lt)).redIAdd(lt), $e = ut, Ze = at.redMul(Qe.redISub(ut)).redISub(lt), Fe = this.y.redAdd(this.y);
  } else {
    var dt = this.x.redSqr(), bt = this.y.redSqr(), $t = bt.redSqr(), vt = this.x.redAdd(bt).redSqr().redISub(dt).redISub($t);
    vt = vt.redIAdd(vt);
    var wt = dt.redAdd(dt).redIAdd(dt), xt = wt.redSqr(), Et = $t.redIAdd($t);
    Et = (Et = Et.redIAdd(Et)).redIAdd(Et), $e = xt.redISub(vt).redISub(vt), Ze = wt.redMul(vt.redISub($e)).redISub(Et), Fe = (Fe = this.y.redMul(this.z)).redIAdd(Fe);
  }
  return this.curve.jpoint($e, Ze, Fe);
}, w$e.prototype._threeDbl = function() {
  var $e, Ze, Fe;
  if (this.zOne) {
    var Ke = this.x.redSqr(), Ve = this.y.redSqr(), Je = Ve.redSqr(), Qe = this.x.redAdd(Ve).redSqr().redISub(Ke).redISub(Je);
    Qe = Qe.redIAdd(Qe);
    var at = Ke.redAdd(Ke).redIAdd(Ke).redIAdd(this.curve.a), ut = at.redSqr().redISub(Qe).redISub(Qe);
    $e = ut;
    var lt = Je.redIAdd(Je);
    lt = (lt = lt.redIAdd(lt)).redIAdd(lt), Ze = at.redMul(Qe.redISub(ut)).redISub(lt), Fe = this.y.redAdd(this.y);
  } else {
    var dt = this.z.redSqr(), bt = this.y.redSqr(), $t = this.x.redMul(bt), vt = this.x.redSub(dt).redMul(this.x.redAdd(dt));
    vt = vt.redAdd(vt).redIAdd(vt);
    var wt = $t.redIAdd($t), xt = (wt = wt.redIAdd(wt)).redAdd(wt);
    $e = vt.redSqr().redISub(xt), Fe = this.y.redAdd(this.z).redSqr().redISub(bt).redISub(dt);
    var Et = bt.redSqr();
    Et = (Et = (Et = Et.redIAdd(Et)).redIAdd(Et)).redIAdd(Et), Ze = vt.redMul(wt.redISub($e)).redISub(Et);
  }
  return this.curve.jpoint($e, Ze, Fe);
}, w$e.prototype._dbl = function() {
  var $e = this.curve.a, Ze = this.x, Fe = this.y, Ke = this.z, Ve = Ke.redSqr().redSqr(), Je = Ze.redSqr(), Qe = Fe.redSqr(), at = Je.redAdd(Je).redIAdd(Je).redIAdd($e.redMul(Ve)), ut = Ze.redAdd(Ze), lt = (ut = ut.redIAdd(ut)).redMul(Qe), dt = at.redSqr().redISub(lt.redAdd(lt)), bt = lt.redISub(dt), $t = Qe.redSqr();
  $t = ($t = ($t = $t.redIAdd($t)).redIAdd($t)).redIAdd($t);
  var vt = at.redMul(bt).redISub($t), wt = Fe.redAdd(Fe).redMul(Ke);
  return this.curve.jpoint(dt, vt, wt);
}, w$e.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var $e = this.x.redSqr(), Ze = this.y.redSqr(), Fe = this.z.redSqr(), Ke = Ze.redSqr(), Ve = $e.redAdd($e).redIAdd($e), Je = Ve.redSqr(), Qe = this.x.redAdd(Ze).redSqr().redISub($e).redISub(Ke), at = (Qe = (Qe = (Qe = Qe.redIAdd(Qe)).redAdd(Qe).redIAdd(Qe)).redISub(Je)).redSqr(), ut = Ke.redIAdd(Ke);
  ut = (ut = (ut = ut.redIAdd(ut)).redIAdd(ut)).redIAdd(ut);
  var lt = Ve.redIAdd(Qe).redSqr().redISub(Je).redISub(at).redISub(ut), dt = Ze.redMul(lt);
  dt = (dt = dt.redIAdd(dt)).redIAdd(dt);
  var bt = this.x.redMul(at).redISub(dt);
  bt = (bt = bt.redIAdd(bt)).redIAdd(bt);
  var $t = this.y.redMul(lt.redMul(ut.redISub(lt)).redISub(Qe.redMul(at)));
  $t = ($t = ($t = $t.redIAdd($t)).redIAdd($t)).redIAdd($t);
  var vt = this.z.redAdd(Qe).redSqr().redISub(Fe).redISub(at);
  return this.curve.jpoint(bt, $t, vt);
}, w$e.prototype.mul = function($e, Ze) {
  return $e = new y$e($e, Ze), this.curve._wnafMul(this, $e);
}, w$e.prototype.eq = function($e) {
  if ($e.type === "affine")
    return this.eq($e.toJ());
  if (this === $e)
    return !0;
  var Ze = this.z.redSqr(), Fe = $e.z.redSqr();
  if (this.x.redMul(Fe).redISub($e.x.redMul(Ze)).cmpn(0) !== 0)
    return !1;
  var Ke = Ze.redMul(this.z), Ve = Fe.redMul($e.z);
  return this.y.redMul(Ve).redISub($e.y.redMul(Ke)).cmpn(0) === 0;
}, w$e.prototype.eqXToP = function($e) {
  var Ze = this.z.redSqr(), Fe = $e.toRed(this.curve.red).redMul(Ze);
  if (this.x.cmp(Fe) === 0)
    return !0;
  for (var Ke = $e.clone(), Ve = this.curve.redN.redMul(Ze); ; ) {
    if (Ke.iadd(this.curve.n), Ke.cmp(this.curve.p) >= 0)
      return !1;
    if (Fe.redIAdd(Ve), this.x.cmp(Fe) === 0)
      return !0;
  }
}, w$e.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
}, w$e.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var M$6, x$6 = l$j, _$d = n$c, z$6 = t$2, q$4 = v$e, R$3 = n$i;
function P$4($e) {
  q$4.call(this, "mont", $e), this.a = new _$d($e.a, 16).toRed(this.red), this.b = new _$d($e.b, 16).toRed(this.red), this.i4 = new _$d(4).toRed(this.red).redInvm(), this.two = new _$d(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
function j$5($e, Ze, Fe) {
  q$4.BasePoint.call(this, $e, "projective"), Ze === null && Fe === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new _$d(Ze, 16), this.z = new _$d(Fe, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
z$6(P$4, q$4), M$6 = P$4, P$4.prototype.validate = function($e) {
  var Ze = $e.normalize().x, Fe = Ze.redSqr(), Ke = Fe.redMul(Ze).redAdd(Fe.redMul(this.a)).redAdd(Ze);
  return Ke.redSqrt().redSqr().cmp(Ke) === 0;
}, z$6(j$5, q$4.BasePoint), P$4.prototype.decodePoint = function($e, Ze) {
  return this.point(R$3.toArray($e, Ze), 1);
}, P$4.prototype.point = function($e, Ze) {
  return new j$5(this, $e, Ze);
}, P$4.prototype.pointFromJSON = function($e) {
  return j$5.fromJSON(this, $e);
}, j$5.prototype.precompute = function() {
}, j$5.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
}, j$5.fromJSON = function($e, Ze) {
  return new j$5($e, Ze[0], Ze[1] || $e.one);
}, j$5.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
}, j$5.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
}, j$5.prototype.dbl = function() {
  var $e = this.x.redAdd(this.z).redSqr(), Ze = this.x.redSub(this.z).redSqr(), Fe = $e.redSub(Ze), Ke = $e.redMul(Ze), Ve = Fe.redMul(Ze.redAdd(this.curve.a24.redMul(Fe)));
  return this.curve.point(Ke, Ve);
}, j$5.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
}, j$5.prototype.diffAdd = function($e, Ze) {
  var Fe = this.x.redAdd(this.z), Ke = this.x.redSub(this.z), Ve = $e.x.redAdd($e.z), Je = $e.x.redSub($e.z).redMul(Fe), Qe = Ve.redMul(Ke), at = Ze.z.redMul(Je.redAdd(Qe).redSqr()), ut = Ze.x.redMul(Je.redISub(Qe).redSqr());
  return this.curve.point(at, ut);
}, j$5.prototype.mul = function($e) {
  for (var Ze = $e.clone(), Fe = this, Ke = this.curve.point(null, null), Ve = []; Ze.cmpn(0) !== 0; Ze.iushrn(1))
    Ve.push(Ze.andln(1));
  for (var Je = Ve.length - 1; Je >= 0; Je--)
    Ve[Je] === 0 ? (Fe = Fe.diffAdd(Ke, this), Ke = Ke.dbl()) : (Ke = Fe.diffAdd(Ke, this), Fe = Fe.dbl());
  return Ke;
}, j$5.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
}, j$5.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
}, j$5.prototype.eq = function($e) {
  return this.getX().cmp($e.getX()) === 0;
}, j$5.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
}, j$5.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var N$4, E$8 = M$6, k$b = n$c, O$5 = t$2, L$4 = v$e, B$8 = n$i.assert;
function F$5($e) {
  this.twisted = (0 | $e.a) != 1, this.mOneA = this.twisted && (0 | $e.a) == -1, this.extended = this.mOneA, L$4.call(this, "edwards", $e), this.a = new k$b($e.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new k$b($e.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new k$b($e.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), B$8(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (0 | $e.c) == 1;
}
function C$5($e, Ze, Fe, Ke, Ve) {
  L$4.BasePoint.call(this, $e, "projective"), Ze === null && Fe === null && Ke === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new k$b(Ze, 16), this.y = new k$b(Fe, 16), this.z = Ke ? new k$b(Ke, 16) : this.curve.one, this.t = Ve && new k$b(Ve, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
O$5(F$5, L$4), N$4 = F$5, F$5.prototype._mulA = function($e) {
  return this.mOneA ? $e.redNeg() : this.a.redMul($e);
}, F$5.prototype._mulC = function($e) {
  return this.oneC ? $e : this.c.redMul($e);
}, F$5.prototype.jpoint = function($e, Ze, Fe, Ke) {
  return this.point($e, Ze, Fe, Ke);
}, F$5.prototype.pointFromX = function($e, Ze) {
  ($e = new k$b($e, 16)).red || ($e = $e.toRed(this.red));
  var Fe = $e.redSqr(), Ke = this.c2.redSub(this.a.redMul(Fe)), Ve = this.one.redSub(this.c2.redMul(this.d).redMul(Fe)), Je = Ke.redMul(Ve.redInvm()), Qe = Je.redSqrt();
  if (Qe.redSqr().redSub(Je).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var at = Qe.fromRed().isOdd();
  return (Ze && !at || !Ze && at) && (Qe = Qe.redNeg()), this.point($e, Qe);
}, F$5.prototype.pointFromY = function($e, Ze) {
  ($e = new k$b($e, 16)).red || ($e = $e.toRed(this.red));
  var Fe = $e.redSqr(), Ke = Fe.redSub(this.c2), Ve = Fe.redMul(this.d).redMul(this.c2).redSub(this.a), Je = Ke.redMul(Ve.redInvm());
  if (Je.cmp(this.zero) === 0) {
    if (Ze)
      throw new Error("invalid point");
    return this.point(this.zero, $e);
  }
  var Qe = Je.redSqrt();
  if (Qe.redSqr().redSub(Je).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return Qe.fromRed().isOdd() !== Ze && (Qe = Qe.redNeg()), this.point(Qe, $e);
}, F$5.prototype.validate = function($e) {
  if ($e.isInfinity())
    return !0;
  $e.normalize();
  var Ze = $e.x.redSqr(), Fe = $e.y.redSqr(), Ke = Ze.redMul(this.a).redAdd(Fe), Ve = this.c2.redMul(this.one.redAdd(this.d.redMul(Ze).redMul(Fe)));
  return Ke.cmp(Ve) === 0;
}, O$5(C$5, L$4.BasePoint), F$5.prototype.pointFromJSON = function($e) {
  return C$5.fromJSON(this, $e);
}, F$5.prototype.point = function($e, Ze, Fe, Ke) {
  return new C$5(this, $e, Ze, Fe, Ke);
}, C$5.fromJSON = function($e, Ze) {
  return new C$5($e, Ze[0], Ze[1], Ze[2]);
}, C$5.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
}, C$5.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
}, C$5.prototype._extDbl = function() {
  var $e = this.x.redSqr(), Ze = this.y.redSqr(), Fe = this.z.redSqr();
  Fe = Fe.redIAdd(Fe);
  var Ke = this.curve._mulA($e), Ve = this.x.redAdd(this.y).redSqr().redISub($e).redISub(Ze), Je = Ke.redAdd(Ze), Qe = Je.redSub(Fe), at = Ke.redSub(Ze), ut = Ve.redMul(Qe), lt = Je.redMul(at), dt = Ve.redMul(at), bt = Qe.redMul(Je);
  return this.curve.point(ut, lt, bt, dt);
}, C$5.prototype._projDbl = function() {
  var $e, Ze, Fe, Ke = this.x.redAdd(this.y).redSqr(), Ve = this.x.redSqr(), Je = this.y.redSqr();
  if (this.curve.twisted) {
    var Qe = (lt = this.curve._mulA(Ve)).redAdd(Je);
    if (this.zOne)
      $e = Ke.redSub(Ve).redSub(Je).redMul(Qe.redSub(this.curve.two)), Ze = Qe.redMul(lt.redSub(Je)), Fe = Qe.redSqr().redSub(Qe).redSub(Qe);
    else {
      var at = this.z.redSqr(), ut = Qe.redSub(at).redISub(at);
      $e = Ke.redSub(Ve).redISub(Je).redMul(ut), Ze = Qe.redMul(lt.redSub(Je)), Fe = Qe.redMul(ut);
    }
  } else {
    var lt = Ve.redAdd(Je);
    at = this.curve._mulC(this.z).redSqr(), ut = lt.redSub(at).redSub(at), $e = this.curve._mulC(Ke.redISub(lt)).redMul(ut), Ze = this.curve._mulC(lt).redMul(Ve.redISub(Je)), Fe = lt.redMul(ut);
  }
  return this.curve.point($e, Ze, Fe);
}, C$5.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
}, C$5.prototype._extAdd = function($e) {
  var Ze = this.y.redSub(this.x).redMul($e.y.redSub($e.x)), Fe = this.y.redAdd(this.x).redMul($e.y.redAdd($e.x)), Ke = this.t.redMul(this.curve.dd).redMul($e.t), Ve = this.z.redMul($e.z.redAdd($e.z)), Je = Fe.redSub(Ze), Qe = Ve.redSub(Ke), at = Ve.redAdd(Ke), ut = Fe.redAdd(Ze), lt = Je.redMul(Qe), dt = at.redMul(ut), bt = Je.redMul(ut), $t = Qe.redMul(at);
  return this.curve.point(lt, dt, $t, bt);
}, C$5.prototype._projAdd = function($e) {
  var Ze, Fe, Ke = this.z.redMul($e.z), Ve = Ke.redSqr(), Je = this.x.redMul($e.x), Qe = this.y.redMul($e.y), at = this.curve.d.redMul(Je).redMul(Qe), ut = Ve.redSub(at), lt = Ve.redAdd(at), dt = this.x.redAdd(this.y).redMul($e.x.redAdd($e.y)).redISub(Je).redISub(Qe), bt = Ke.redMul(ut).redMul(dt);
  return this.curve.twisted ? (Ze = Ke.redMul(lt).redMul(Qe.redSub(this.curve._mulA(Je))), Fe = ut.redMul(lt)) : (Ze = Ke.redMul(lt).redMul(Qe.redSub(Je)), Fe = this.curve._mulC(ut).redMul(lt)), this.curve.point(bt, Ze, Fe);
}, C$5.prototype.add = function($e) {
  return this.isInfinity() ? $e : $e.isInfinity() ? this : this.curve.extended ? this._extAdd($e) : this._projAdd($e);
}, C$5.prototype.mul = function($e) {
  return this._hasDoubles($e) ? this.curve._fixedNafMul(this, $e) : this.curve._wnafMul(this, $e);
}, C$5.prototype.mulAdd = function($e, Ze, Fe) {
  return this.curve._wnafMulAdd(1, [this, Ze], [$e, Fe], 2, !1);
}, C$5.prototype.jmulAdd = function($e, Ze, Fe) {
  return this.curve._wnafMulAdd(1, [this, Ze], [$e, Fe], 2, !0);
}, C$5.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var $e = this.z.redInvm();
  return this.x = this.x.redMul($e), this.y = this.y.redMul($e), this.t && (this.t = this.t.redMul($e)), this.z = this.curve.one, this.zOne = !0, this;
}, C$5.prototype.neg = function() {
  return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
}, C$5.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
}, C$5.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
}, C$5.prototype.eq = function($e) {
  return this === $e || this.getX().cmp($e.getX()) === 0 && this.getY().cmp($e.getY()) === 0;
}, C$5.prototype.eqXToP = function($e) {
  var Ze = $e.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(Ze) === 0)
    return !0;
  for (var Fe = $e.clone(), Ke = this.curve.redN.redMul(this.z); ; ) {
    if (Fe.iadd(this.curve.n), Fe.cmp(this.curve.p) >= 0)
      return !1;
    if (Ze.redIAdd(Ke), this.x.cmp(Ze) === 0)
      return !0;
  }
}, C$5.prototype.toP = C$5.prototype.normalize, C$5.prototype.mixedAdd = C$5.prototype.add;
var T$5 = N$4, J$3 = {}, X$3 = J$3;
X$3.base = v$e, X$3.short = x$6, X$3.mont = E$8, X$3.edwards = T$5;
var D$4, Y$2 = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } }, W$3 = {}, K$4 = W$3, U$6 = X$2, G$3 = J$3, H$5 = n$i.assert;
function Q$2($e) {
  $e.type === "short" ? this.curve = new G$3.short($e) : $e.type === "edwards" ? this.curve = new G$3.edwards($e) : this.curve = new G$3.mont($e), this.g = this.curve.g, this.n = this.curve.n, this.hash = $e.hash, H$5(this.g.validate(), "Invalid curve"), H$5(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
}
function V$3($e, Ze) {
  Object.defineProperty(K$4, $e, { configurable: !0, enumerable: !0, get: function() {
    var Fe = new Q$2(Ze);
    return Object.defineProperty(K$4, $e, { configurable: !0, enumerable: !0, value: Fe }), Fe;
  } });
}
K$4.PresetCurve = Q$2, V$3("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: U$6.sha256, gRed: !1, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), V$3("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: U$6.sha256, gRed: !1, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), V$3("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: U$6.sha256, gRed: !1, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), V$3("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: U$6.sha384, gRed: !1, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), V$3("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: U$6.sha512, gRed: !1, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), V$3("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: U$6.sha256, gRed: !1, g: ["9"] }), V$3("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: U$6.sha256, gRed: !1, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
try {
  D$4 = Y$2;
} catch ($e) {
  D$4 = void 0;
}
V$3("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: U$6.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: !1, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", D$4] });
var Z$1, $$1 = n$c, ee2 = n$i.assert;
function fe2($e, Ze) {
  this.ec = $e, this.priv = null, this.pub = null, Ze.priv && this._importPrivate(Ze.priv, Ze.privEnc), Ze.pub && this._importPublic(Ze.pub, Ze.pubEnc);
}
Z$1 = fe2, fe2.fromPublic = function($e, Ze, Fe) {
  return Ze instanceof fe2 ? Ze : new fe2($e, { pub: Ze, pubEnc: Fe });
}, fe2.fromPrivate = function($e, Ze, Fe) {
  return Ze instanceof fe2 ? Ze : new fe2($e, { priv: Ze, privEnc: Fe });
}, fe2.prototype.validate = function() {
  var $e = this.getPublic();
  return $e.isInfinity() ? { result: !1, reason: "Invalid public key" } : $e.validate() ? $e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
}, fe2.prototype.getPublic = function($e, Ze) {
  return typeof $e == "string" && (Ze = $e, $e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), Ze ? this.pub.encode(Ze, $e) : this.pub;
}, fe2.prototype.getPrivate = function($e) {
  return $e === "hex" ? this.priv.toString(16, 2) : this.priv;
}, fe2.prototype._importPrivate = function($e, Ze) {
  this.priv = new $$1($e, Ze || 16), this.priv = this.priv.umod(this.ec.curve.n);
}, fe2.prototype._importPublic = function($e, Ze) {
  if ($e.x || $e.y)
    return this.ec.curve.type === "mont" ? ee2($e.x, "Need x coordinate") : this.ec.curve.type !== "short" && this.ec.curve.type !== "edwards" || ee2($e.x && $e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point($e.x, $e.y), void 0;
  this.pub = this.ec.curve.decodePoint($e, Ze);
}, fe2.prototype.derive = function($e) {
  return $e.mul(this.priv).getX();
}, fe2.prototype.sign = function($e, Ze, Fe) {
  return this.ec.sign($e, this, Ze, Fe);
}, fe2.prototype.verify = function($e, Ze) {
  return this.ec.verify($e, Ze, this);
}, fe2.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var de2, ce2 = Z$1, te2 = n$c, ae2 = a$l, re2 = W$3, be2 = f$i, ie = n$i.assert, ne2 = ce2, se2 = d$e;
function oe2($e) {
  if (!(this instanceof oe2))
    return new oe2($e);
  typeof $e == "string" && (ie(re2.hasOwnProperty($e), "Unknown curve " + $e), $e = re2[$e]), $e instanceof re2.PresetCurve && ($e = { curve: $e }), this.curve = $e.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = $e.curve.g, this.g.precompute($e.curve.n.bitLength() + 1), this.hash = $e.hash || $e.curve.hash;
}
de2 = oe2, oe2.prototype.keyPair = function($e) {
  return new ne2(this, $e);
}, oe2.prototype.keyFromPrivate = function($e, Ze) {
  return ne2.fromPrivate(this, $e, Ze);
}, oe2.prototype.keyFromPublic = function($e, Ze) {
  return ne2.fromPublic(this, $e, Ze);
}, oe2.prototype.genKeyPair = function($e) {
  $e || ($e = {});
  for (var Ze = new ae2({ hash: this.hash, pers: $e.pers, persEnc: $e.persEnc || "utf8", entropy: $e.entropy || be2(this.hash.hmacStrength), entropyEnc: $e.entropy && $e.entropyEnc || "utf8", nonce: this.n.toArray() }), Fe = this.n.byteLength(), Ke = this.n.sub(new te2(2)); ; ) {
    var Ve = new te2(Ze.generate(Fe));
    if (!(Ve.cmp(Ke) > 0))
      return Ve.iaddn(1), this.keyFromPrivate(Ve);
  }
}, oe2.prototype._truncateToN = function($e, Ze) {
  var Fe = 8 * $e.byteLength() - this.n.bitLength();
  return Fe > 0 && ($e = $e.ushrn(Fe)), !Ze && $e.cmp(this.n) >= 0 ? $e.sub(this.n) : $e;
}, oe2.prototype.sign = function($e, Ze, Fe, Ke) {
  typeof Fe == "object" && (Ke = Fe, Fe = null), Ke || (Ke = {}), Ze = this.keyFromPrivate(Ze, Fe), $e = this._truncateToN(new te2($e, 16));
  for (var Ve = this.n.byteLength(), Je = Ze.getPrivate().toArray("be", Ve), Qe = $e.toArray("be", Ve), at = new ae2({ hash: this.hash, entropy: Je, nonce: Qe, pers: Ke.pers, persEnc: Ke.persEnc || "utf8" }), ut = this.n.sub(new te2(1)), lt = 0; ; lt++) {
    var dt = Ke.k ? Ke.k(lt) : new te2(at.generate(this.n.byteLength()));
    if (!((dt = this._truncateToN(dt, !0)).cmpn(1) <= 0 || dt.cmp(ut) >= 0)) {
      var bt = this.g.mul(dt);
      if (!bt.isInfinity()) {
        var $t = bt.getX(), vt = $t.umod(this.n);
        if (vt.cmpn(0) !== 0) {
          var wt = dt.invm(this.n).mul(vt.mul(Ze.getPrivate()).iadd($e));
          if ((wt = wt.umod(this.n)).cmpn(0) !== 0) {
            var xt = (bt.getY().isOdd() ? 1 : 0) | ($t.cmp(vt) !== 0 ? 2 : 0);
            return Ke.canonical && wt.cmp(this.nh) > 0 && (wt = this.n.sub(wt), xt ^= 1), new se2({ r: vt, s: wt, recoveryParam: xt });
          }
        }
      }
    }
  }
}, oe2.prototype.verify = function($e, Ze, Fe, Ke) {
  $e = this._truncateToN(new te2($e, 16)), Fe = this.keyFromPublic(Fe, Ke);
  var Ve = (Ze = new se2(Ze, "hex")).r, Je = Ze.s;
  if (Ve.cmpn(1) < 0 || Ve.cmp(this.n) >= 0 || Je.cmpn(1) < 0 || Je.cmp(this.n) >= 0)
    return !1;
  var Qe, at = Je.invm(this.n), ut = at.mul($e).umod(this.n), lt = at.mul(Ve).umod(this.n);
  return this.curve._maxwellTrick ? !(Qe = this.g.jmulAdd(ut, Fe.getPublic(), lt)).isInfinity() && Qe.eqXToP(Ve) : !(Qe = this.g.mulAdd(ut, Fe.getPublic(), lt)).isInfinity() && Qe.getX().umod(this.n).cmp(Ve) === 0;
}, oe2.prototype.recoverPubKey = function($e, Ze, Fe, Ke) {
  ie((3 & Fe) === Fe, "The recovery param is more than two bits"), Ze = new se2(Ze, Ke);
  var Ve = this.n, Je = new te2($e), Qe = Ze.r, at = Ze.s, ut = 1 & Fe, lt = Fe >> 1;
  if (Qe.cmp(this.curve.p.umod(this.curve.n)) >= 0 && lt)
    throw new Error("Unable to find sencond key candinate");
  Qe = lt ? this.curve.pointFromX(Qe.add(this.curve.n), ut) : this.curve.pointFromX(Qe, ut);
  var dt = Ze.r.invm(Ve), bt = Ve.sub(Je).mul(dt).umod(Ve), $t = at.mul(dt).umod(Ve);
  return this.g.mulAdd(bt, Qe, $t);
}, oe2.prototype.getKeyRecoveryParam = function($e, Ze, Fe, Ke) {
  if ((Ze = new se2(Ze, Ke)).recoveryParam !== null)
    return Ze.recoveryParam;
  for (var Ve = 0; Ve < 4; Ve++) {
    var Je;
    try {
      Je = this.recoverPubKey($e, Ze, Ve);
    } catch {
      continue;
    }
    if (Je.eq(Fe))
      return Ve;
  }
  throw new Error("Unable to find valid recovery factor");
};
var ue2 = de2, he2 = n$i, pe2 = he2.assert, le2 = he2.parseBytes, ve2 = he2.cachedProperty;
function ye2($e, Ze) {
  this.eddsa = $e, this._secret = le2(Ze.secret), $e.isPoint(Ze.pub) ? this._pub = Ze.pub : this._pubBytes = le2(Ze.pub);
}
ye2.fromPublic = function($e, Ze) {
  return Ze instanceof ye2 ? Ze : new ye2($e, { pub: Ze });
}, ye2.fromSecret = function($e, Ze) {
  return Ze instanceof ye2 ? Ze : new ye2($e, { secret: Ze });
}, ye2.prototype.secret = function() {
  return this._secret;
}, ve2(ye2, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
}), ve2(ye2, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
}), ve2(ye2, "privBytes", function() {
  var $e = this.eddsa, Ze = this.hash(), Fe = $e.encodingLength - 1, Ke = Ze.slice(0, $e.encodingLength);
  return Ke[0] &= 248, Ke[Fe] &= 127, Ke[Fe] |= 64, Ke;
}), ve2(ye2, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
}), ve2(ye2, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
}), ve2(ye2, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
}), ye2.prototype.sign = function($e) {
  return pe2(this._secret, "KeyPair can only verify"), this.eddsa.sign($e, this);
}, ye2.prototype.verify = function($e, Ze) {
  return this.eddsa.verify($e, Ze, this);
}, ye2.prototype.getSecret = function($e) {
  return pe2(this._secret, "KeyPair is public only"), he2.encode(this.secret(), $e);
}, ye2.prototype.getPublic = function($e) {
  return he2.encode(this.pubBytes(), $e);
};
var me2 = ye2, Se2 = n$c, ge2 = n$i, Ae2 = ge2.assert, Ie = ge2.cachedProperty, we2 = ge2.parseBytes;
function Me($e, Ze) {
  this.eddsa = $e, typeof Ze != "object" && (Ze = we2(Ze)), Array.isArray(Ze) && (Ze = { R: Ze.slice(0, $e.encodingLength), S: Ze.slice($e.encodingLength) }), Ae2(Ze.R && Ze.S, "Signature without R or S"), $e.isPoint(Ze.R) && (this._R = Ze.R), Ze.S instanceof Se2 && (this._S = Ze.S), this._Rencoded = Array.isArray(Ze.R) ? Ze.R : Ze.Rencoded, this._Sencoded = Array.isArray(Ze.S) ? Ze.S : Ze.Sencoded;
}
Ie(Me, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
}), Ie(Me, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
}), Ie(Me, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
}), Ie(Me, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
}), Me.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
}, Me.prototype.toHex = function() {
  return ge2.encode(this.toBytes(), "hex").toUpperCase();
};
var xe, _e = Me, ze = X$2, qe = W$3, Re = n$i, Pe = Re.assert, je2 = Re.parseBytes, Ne = me2, Ee2 = _e;
function ke2($e) {
  if (Pe($e === "ed25519", "only tested with ed25519 so far"), !(this instanceof ke2))
    return new ke2($e);
  $e = qe[$e].curve, this.curve = $e, this.g = $e.g, this.g.precompute($e.n.bitLength() + 1), this.pointClass = $e.point().constructor, this.encodingLength = Math.ceil($e.n.bitLength() / 8), this.hash = ze.sha512;
}
xe = ke2, ke2.prototype.sign = function($e, Ze) {
  $e = je2($e);
  var Fe = this.keyFromSecret(Ze), Ke = this.hashInt(Fe.messagePrefix(), $e), Ve = this.g.mul(Ke), Je = this.encodePoint(Ve), Qe = this.hashInt(Je, Fe.pubBytes(), $e).mul(Fe.priv()), at = Ke.add(Qe).umod(this.curve.n);
  return this.makeSignature({ R: Ve, S: at, Rencoded: Je });
}, ke2.prototype.verify = function($e, Ze, Fe) {
  $e = je2($e), Ze = this.makeSignature(Ze);
  var Ke = this.keyFromPublic(Fe), Ve = this.hashInt(Ze.Rencoded(), Ke.pubBytes(), $e), Je = this.g.mul(Ze.S());
  return Ze.R().add(Ke.pub().mul(Ve)).eq(Je);
}, ke2.prototype.hashInt = function() {
  for (var $e = this.hash(), Ze = 0; Ze < arguments.length; Ze++)
    $e.update(arguments[Ze]);
  return Re.intFromLE($e.digest()).umod(this.curve.n);
}, ke2.prototype.keyFromPublic = function($e) {
  return Ne.fromPublic(this, $e);
}, ke2.prototype.keyFromSecret = function($e) {
  return Ne.fromSecret(this, $e);
}, ke2.prototype.makeSignature = function($e) {
  return $e instanceof Ee2 ? $e : new Ee2(this, $e);
}, ke2.prototype.encodePoint = function($e) {
  var Ze = $e.getY().toArray("le", this.encodingLength);
  return Ze[this.encodingLength - 1] |= $e.getX().isOdd() ? 128 : 0, Ze;
}, ke2.prototype.decodePoint = function($e) {
  var Ze = ($e = Re.parseBytes($e)).length - 1, Fe = $e.slice(0, Ze).concat(-129 & $e[Ze]), Ke = (128 & $e[Ze]) != 0, Ve = Re.intFromLE(Fe);
  return this.curve.pointFromY(Ve, Ke);
}, ke2.prototype.encodeInt = function($e) {
  return $e.toArray("le", this.encodingLength);
}, ke2.prototype.decodeInt = function($e) {
  return Re.intFromLE($e);
}, ke2.prototype.isPoint = function($e) {
  return $e instanceof this.pointClass;
};
var Oe2 = xe, Le = {}, Be2 = Le;
Be2.version = ["elliptic", "6.5.2", "EC cryptography", "lib/elliptic.js", ["lib"], { jscs: "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js", jshint: "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js", lint: "npm run jscs && npm run jshint", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, { type: "git", url: "git@github.com:indutny/elliptic" }, ["EC", "Elliptic", "curve", "Cryptography"], "Fedor Indutny <fedor@indutny.com>", "MIT", { url: "https://github.com/indutny/elliptic/issues" }, "https://github.com/indutny/elliptic", { brfs: "^1.4.3", coveralls: "^3.0.8", grunt: "^1.0.4", "grunt-browserify": "^5.0.0", "grunt-cli": "^1.2.0", "grunt-contrib-connect": "^1.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^1.0.1", "grunt-mocha-istanbul": "^3.0.1", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.2", jscs: "^3.0.7", jshint: "^2.10.3", mocha: "^6.2.2" }, { "bn.js": "^4.4.0", brorand: "^1.0.1", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.0", inherits: "^2.0.1", "minimalistic-assert": "^1.0.0", "minimalistic-crypto-utils": "^1.0.0" }][1], Be2.utils = n$i, Be2.rand = f$i, Be2.curve = J$3, Be2.curves = W$3, Be2.ec = ue2, Be2.eddsa = Oe2;
var o$n = {}, s$j = !1, a$m = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, u$j = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, c$i = {}, f$n = t$2;
function l$k($e) {
  (this || u$j)._reporterState = { obj: null, path: [], options: $e || {}, errors: [] };
}
function h$g($e, Ze) {
  (this || u$j).path = $e, this.rethrow(Ze);
}
c$i.Reporter = l$k, l$k.prototype.isError = function($e) {
  return $e instanceof h$g;
}, l$k.prototype.save = function() {
  var $e = (this || u$j)._reporterState;
  return { obj: $e.obj, pathLen: $e.path.length };
}, l$k.prototype.restore = function($e) {
  var Ze = (this || u$j)._reporterState;
  Ze.obj = $e.obj, Ze.path = Ze.path.slice(0, $e.pathLen);
}, l$k.prototype.enterKey = function($e) {
  return (this || u$j)._reporterState.path.push($e);
}, l$k.prototype.exitKey = function($e) {
  var Ze = (this || u$j)._reporterState;
  Ze.path = Ze.path.slice(0, $e - 1);
}, l$k.prototype.leaveKey = function($e, Ze, Fe) {
  var Ke = (this || u$j)._reporterState;
  this.exitKey($e), Ke.obj !== null && (Ke.obj[Ze] = Fe);
}, l$k.prototype.path = function() {
  return (this || u$j)._reporterState.path.join("/");
}, l$k.prototype.enterObject = function() {
  var $e = (this || u$j)._reporterState, Ze = $e.obj;
  return $e.obj = {}, Ze;
}, l$k.prototype.leaveObject = function($e) {
  var Ze = (this || u$j)._reporterState, Fe = Ze.obj;
  return Ze.obj = $e, Fe;
}, l$k.prototype.error = function($e) {
  var Ze, Fe = (this || u$j)._reporterState, Ke = $e instanceof h$g;
  if (Ze = Ke ? $e : new h$g(Fe.path.map(function(Ve) {
    return "[" + JSON.stringify(Ve) + "]";
  }).join(""), $e.message || $e, $e.stack), !Fe.options.partial)
    throw Ze;
  return Ke || Fe.errors.push(Ze), Ze;
}, l$k.prototype.wrapResult = function($e) {
  var Ze = (this || u$j)._reporterState;
  return Ze.options.partial ? { result: this.isError($e) ? null : $e, errors: Ze.errors } : $e;
}, f$n(h$g, Error), h$g.prototype.rethrow = function($e) {
  if ((this || u$j).message = $e + " at: " + ((this || u$j).path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this || u$j, h$g), !(this || u$j).stack)
    try {
      throw new Error((this || u$j).message);
    } catch (Ze) {
      (this || u$j).stack = Ze.stack;
    }
  return this || u$j;
};
var p$k = {}, d$i = !1, g$e = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function y$f() {
  if (d$i)
    return p$k;
  d$i = !0;
  var $e = t$2, Ze = E$9().Reporter, Fe = e$1$1$1.Buffer;
  function Ke(Je, Qe) {
    if (Ze.call(this || g$e, Qe), !Fe.isBuffer(Je))
      return this.error("Input not Buffer"), void 0;
    (this || g$e).base = Je, (this || g$e).offset = 0, (this || g$e).length = Je.length;
  }
  function Ve(Je, Qe) {
    if (Array.isArray(Je))
      (this || g$e).length = 0, (this || g$e).value = Je.map(function(at) {
        return at instanceof Ve || (at = new Ve(at, Qe)), (this || g$e).length += at.length, at;
      }, this || g$e);
    else if (typeof Je == "number") {
      if (!(0 <= Je && Je <= 255))
        return Qe.error("non-byte EncoderBuffer value");
      (this || g$e).value = Je, (this || g$e).length = 1;
    } else if (typeof Je == "string")
      (this || g$e).value = Je, (this || g$e).length = Fe.byteLength(Je);
    else {
      if (!Fe.isBuffer(Je))
        return Qe.error("Unsupported type: " + typeof Je);
      (this || g$e).value = Je, (this || g$e).length = Je.length;
    }
  }
  return $e(Ke, Ze), p$k.DecoderBuffer = Ke, Ke.prototype.save = function() {
    return { offset: (this || g$e).offset, reporter: Ze.prototype.save.call(this || g$e) };
  }, Ke.prototype.restore = function(Je) {
    var Qe = new Ke((this || g$e).base);
    return Qe.offset = Je.offset, Qe.length = (this || g$e).offset, (this || g$e).offset = Je.offset, Ze.prototype.restore.call(this || g$e, Je.reporter), Qe;
  }, Ke.prototype.isEmpty = function() {
    return (this || g$e).offset === (this || g$e).length;
  }, Ke.prototype.readUInt8 = function(Je) {
    return (this || g$e).offset + 1 <= (this || g$e).length ? (this || g$e).base.readUInt8((this || g$e).offset++, !0) : this.error(Je || "DecoderBuffer overrun");
  }, Ke.prototype.skip = function(Je, Qe) {
    if (!((this || g$e).offset + Je <= (this || g$e).length))
      return this.error(Qe || "DecoderBuffer overrun");
    var at = new Ke((this || g$e).base);
    return at._reporterState = (this || g$e)._reporterState, at.offset = (this || g$e).offset, at.length = (this || g$e).offset + Je, (this || g$e).offset += Je, at;
  }, Ke.prototype.raw = function(Je) {
    return (this || g$e).base.slice(Je ? Je.offset : (this || g$e).offset, (this || g$e).length);
  }, p$k.EncoderBuffer = Ve, Ve.prototype.join = function(Je, Qe) {
    return Je || (Je = new Fe((this || g$e).length)), Qe || (Qe = 0), (this || g$e).length === 0 || (Array.isArray((this || g$e).value) ? (this || g$e).value.forEach(function(at) {
      at.join(Je, Qe), Qe += at.length;
    }) : (typeof (this || g$e).value == "number" ? Je[Qe] = (this || g$e).value : typeof (this || g$e).value == "string" ? Je.write((this || g$e).value, Qe) : Fe.isBuffer((this || g$e).value) && (this || g$e).value.copy(Je, Qe), Qe += (this || g$e).length)), Je;
  }, p$k;
}
var _$e = {}, v$f = !1, b$c = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, m$g = {}, S$a = !1;
function E$9() {
  if (S$a)
    return m$g;
  S$a = !0;
  var $e = m$g;
  return $e.Reporter = c$i.Reporter, $e.DecoderBuffer = y$f().DecoderBuffer, $e.EncoderBuffer = y$f().EncoderBuffer, $e.Node = function() {
    if (v$f)
      return _$e;
    v$f = !0;
    var Ze = E$9().Reporter, Fe = E$9().EncoderBuffer, Ke = E$9().DecoderBuffer, Ve = o$7, Je = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], Qe = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(Je);
    function at(lt, dt) {
      var bt = {};
      (this || b$c)._baseState = bt, bt.enc = lt, bt.parent = dt || null, bt.children = null, bt.tag = null, bt.args = null, bt.reverseArgs = null, bt.choice = null, bt.optional = !1, bt.any = !1, bt.obj = !1, bt.use = null, bt.useDecoder = null, bt.key = null, bt.default = null, bt.explicit = null, bt.implicit = null, bt.contains = null, bt.parent || (bt.children = [], this._wrap());
    }
    _$e = at;
    var ut = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
    return at.prototype.clone = function() {
      var lt = (this || b$c)._baseState, dt = {};
      ut.forEach(function($t) {
        dt[$t] = lt[$t];
      });
      var bt = new (this || b$c).constructor(dt.parent);
      return bt._baseState = dt, bt;
    }, at.prototype._wrap = function() {
      var lt = (this || b$c)._baseState;
      Qe.forEach(function(dt) {
        (this || b$c)[dt] = function() {
          var bt = new (this || b$c).constructor(this || b$c);
          return lt.children.push(bt), bt[dt].apply(bt, arguments);
        };
      }, this || b$c);
    }, at.prototype._init = function(lt) {
      var dt = (this || b$c)._baseState;
      Ve(dt.parent === null), lt.call(this || b$c), dt.children = dt.children.filter(function(bt) {
        return bt._baseState.parent === (this || b$c);
      }, this || b$c), Ve.equal(dt.children.length, 1, "Root node can have only one child");
    }, at.prototype._useArgs = function(lt) {
      var dt = (this || b$c)._baseState, bt = lt.filter(function($t) {
        return $t instanceof (this || b$c).constructor;
      }, this || b$c);
      lt = lt.filter(function($t) {
        return !($t instanceof (this || b$c).constructor);
      }, this || b$c), bt.length !== 0 && (Ve(dt.children === null), dt.children = bt, bt.forEach(function($t) {
        $t._baseState.parent = this || b$c;
      }, this || b$c)), lt.length !== 0 && (Ve(dt.args === null), dt.args = lt, dt.reverseArgs = lt.map(function($t) {
        if (typeof $t != "object" || $t.constructor !== Object)
          return $t;
        var vt = {};
        return Object.keys($t).forEach(function(wt) {
          wt == (0 | wt) && (wt |= 0);
          var xt = $t[wt];
          vt[xt] = wt;
        }), vt;
      }));
    }, ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"].forEach(function(lt) {
      at.prototype[lt] = function() {
        var dt = (this || b$c)._baseState;
        throw new Error(lt + " not implemented for encoding: " + dt.enc);
      };
    }), Je.forEach(function(lt) {
      at.prototype[lt] = function() {
        var dt = (this || b$c)._baseState, bt = Array.prototype.slice.call(arguments);
        return Ve(dt.tag === null), dt.tag = lt, this._useArgs(bt), this || b$c;
      };
    }), at.prototype.use = function(lt) {
      Ve(lt);
      var dt = (this || b$c)._baseState;
      return Ve(dt.use === null), dt.use = lt, this || b$c;
    }, at.prototype.optional = function() {
      return (this || b$c)._baseState.optional = !0, this || b$c;
    }, at.prototype.def = function(lt) {
      var dt = (this || b$c)._baseState;
      return Ve(dt.default === null), dt.default = lt, dt.optional = !0, this || b$c;
    }, at.prototype.explicit = function(lt) {
      var dt = (this || b$c)._baseState;
      return Ve(dt.explicit === null && dt.implicit === null), dt.explicit = lt, this || b$c;
    }, at.prototype.implicit = function(lt) {
      var dt = (this || b$c)._baseState;
      return Ve(dt.explicit === null && dt.implicit === null), dt.implicit = lt, this || b$c;
    }, at.prototype.obj = function() {
      var lt = (this || b$c)._baseState, dt = Array.prototype.slice.call(arguments);
      return lt.obj = !0, dt.length !== 0 && this._useArgs(dt), this || b$c;
    }, at.prototype.key = function(lt) {
      var dt = (this || b$c)._baseState;
      return Ve(dt.key === null), dt.key = lt, this || b$c;
    }, at.prototype.any = function() {
      return (this || b$c)._baseState.any = !0, this || b$c;
    }, at.prototype.choice = function(lt) {
      var dt = (this || b$c)._baseState;
      return Ve(dt.choice === null), dt.choice = lt, this._useArgs(Object.keys(lt).map(function(bt) {
        return lt[bt];
      })), this || b$c;
    }, at.prototype.contains = function(lt) {
      var dt = (this || b$c)._baseState;
      return Ve(dt.use === null), dt.contains = lt, this || b$c;
    }, at.prototype._decode = function(lt, dt) {
      var bt = (this || b$c)._baseState;
      if (bt.parent === null)
        return lt.wrapResult(bt.children[0]._decode(lt, dt));
      var $t, vt = bt.default, wt = !0, xt = null;
      if (bt.key !== null && (xt = lt.enterKey(bt.key)), bt.optional) {
        var Et = null;
        if (bt.explicit !== null ? Et = bt.explicit : bt.implicit !== null ? Et = bt.implicit : bt.tag !== null && (Et = bt.tag), Et !== null || bt.any) {
          if (wt = this._peekTag(lt, Et, bt.any), lt.isError(wt))
            return wt;
        } else {
          var Tt = lt.save();
          try {
            bt.choice === null ? this._decodeGeneric(bt.tag, lt, dt) : this._decodeChoice(lt, dt), wt = !0;
          } catch {
            wt = !1;
          }
          lt.restore(Tt);
        }
      }
      if (bt.obj && wt && ($t = lt.enterObject()), wt) {
        if (bt.explicit !== null) {
          var Rt = this._decodeTag(lt, bt.explicit);
          if (lt.isError(Rt))
            return Rt;
          lt = Rt;
        }
        var Ct = lt.offset;
        if (bt.use === null && bt.choice === null) {
          bt.any && (Tt = lt.save());
          var Zt = this._decodeTag(lt, bt.implicit !== null ? bt.implicit : bt.tag, bt.any);
          if (lt.isError(Zt))
            return Zt;
          bt.any ? vt = lt.raw(Tt) : lt = Zt;
        }
        if (dt && dt.track && bt.tag !== null && dt.track(lt.path(), Ct, lt.length, "tagged"), dt && dt.track && bt.tag !== null && dt.track(lt.path(), lt.offset, lt.length, "content"), vt = bt.any ? vt : bt.choice === null ? this._decodeGeneric(bt.tag, lt, dt) : this._decodeChoice(lt, dt), lt.isError(vt))
          return vt;
        if (bt.any || bt.choice !== null || bt.children === null || bt.children.forEach(function(Ut) {
          Ut._decode(lt, dt);
        }), bt.contains && (bt.tag === "octstr" || bt.tag === "bitstr")) {
          var Lt = new Ke(vt);
          vt = this._getUse(bt.contains, lt._reporterState.obj)._decode(Lt, dt);
        }
      }
      return bt.obj && wt && (vt = lt.leaveObject($t)), bt.key === null || vt === null && wt !== !0 ? xt !== null && lt.exitKey(xt) : lt.leaveKey(xt, bt.key, vt), vt;
    }, at.prototype._decodeGeneric = function(lt, dt, bt) {
      var $t = (this || b$c)._baseState;
      return lt === "seq" || lt === "set" ? null : lt === "seqof" || lt === "setof" ? this._decodeList(dt, lt, $t.args[0], bt) : /str$/.test(lt) ? this._decodeStr(dt, lt, bt) : lt === "objid" && $t.args ? this._decodeObjid(dt, $t.args[0], $t.args[1], bt) : lt === "objid" ? this._decodeObjid(dt, null, null, bt) : lt === "gentime" || lt === "utctime" ? this._decodeTime(dt, lt, bt) : lt === "null_" ? this._decodeNull(dt, bt) : lt === "bool" ? this._decodeBool(dt, bt) : lt === "objDesc" ? this._decodeStr(dt, lt, bt) : lt === "int" || lt === "enum" ? this._decodeInt(dt, $t.args && $t.args[0], bt) : $t.use !== null ? this._getUse($t.use, dt._reporterState.obj)._decode(dt, bt) : dt.error("unknown tag: " + lt);
    }, at.prototype._getUse = function(lt, dt) {
      var bt = (this || b$c)._baseState;
      return bt.useDecoder = this._use(lt, dt), Ve(bt.useDecoder._baseState.parent === null), bt.useDecoder = bt.useDecoder._baseState.children[0], bt.implicit !== bt.useDecoder._baseState.implicit && (bt.useDecoder = bt.useDecoder.clone(), bt.useDecoder._baseState.implicit = bt.implicit), bt.useDecoder;
    }, at.prototype._decodeChoice = function(lt, dt) {
      var bt = (this || b$c)._baseState, $t = null, vt = !1;
      return Object.keys(bt.choice).some(function(wt) {
        var xt = lt.save(), Et = bt.choice[wt];
        try {
          var Tt = Et._decode(lt, dt);
          if (lt.isError(Tt))
            return !1;
          $t = { type: wt, value: Tt }, vt = !0;
        } catch {
          return lt.restore(xt), !1;
        }
        return !0;
      }, this || b$c), vt ? $t : lt.error("Choice not matched");
    }, at.prototype._createEncoderBuffer = function(lt) {
      return new Fe(lt, (this || b$c).reporter);
    }, at.prototype._encode = function(lt, dt, bt) {
      var $t = (this || b$c)._baseState;
      if ($t.default === null || $t.default !== lt) {
        var vt = this._encodeValue(lt, dt, bt);
        if (vt !== void 0 && !this._skipDefault(vt, dt, bt))
          return vt;
      }
    }, at.prototype._encodeValue = function(lt, dt, bt) {
      var $t = (this || b$c)._baseState;
      if ($t.parent === null)
        return $t.children[0]._encode(lt, dt || new Ze());
      var vt = null;
      if ((this || b$c).reporter = dt, $t.optional && lt === void 0) {
        if ($t.default === null)
          return;
        lt = $t.default;
      }
      var wt = null, xt = !1;
      if ($t.any)
        vt = this._createEncoderBuffer(lt);
      else if ($t.choice)
        vt = this._encodeChoice(lt, dt);
      else if ($t.contains)
        wt = this._getUse($t.contains, bt)._encode(lt, dt), xt = !0;
      else if ($t.children)
        wt = $t.children.map(function(Ct) {
          if (Ct._baseState.tag === "null_")
            return Ct._encode(null, dt, lt);
          if (Ct._baseState.key === null)
            return dt.error("Child should have a key");
          var Zt = dt.enterKey(Ct._baseState.key);
          if (typeof lt != "object")
            return dt.error("Child expected, but input is not object");
          var Lt = Ct._encode(lt[Ct._baseState.key], dt, lt);
          return dt.leaveKey(Zt), Lt;
        }, this || b$c).filter(function(Ct) {
          return Ct;
        }), wt = this._createEncoderBuffer(wt);
      else if ($t.tag === "seqof" || $t.tag === "setof") {
        if (!$t.args || $t.args.length !== 1)
          return dt.error("Too many args for : " + $t.tag);
        if (!Array.isArray(lt))
          return dt.error("seqof/setof, but data is not Array");
        var Et = this.clone();
        Et._baseState.implicit = null, wt = this._createEncoderBuffer(lt.map(function(Ct) {
          var Zt = (this || b$c)._baseState;
          return this._getUse(Zt.args[0], lt)._encode(Ct, dt);
        }, Et));
      } else
        $t.use !== null ? vt = this._getUse($t.use, bt)._encode(lt, dt) : (wt = this._encodePrimitive($t.tag, lt), xt = !0);
      if (!$t.any && $t.choice === null) {
        var Tt = $t.implicit !== null ? $t.implicit : $t.tag, Rt = $t.implicit === null ? "universal" : "context";
        Tt === null ? $t.use === null && dt.error("Tag could be omitted only for .use()") : $t.use === null && (vt = this._encodeComposite(Tt, xt, Rt, wt));
      }
      return $t.explicit !== null && (vt = this._encodeComposite($t.explicit, !1, "context", vt)), vt;
    }, at.prototype._encodeChoice = function(lt, dt) {
      var bt = (this || b$c)._baseState, $t = bt.choice[lt.type];
      return $t || Ve(!1, lt.type + " not found in " + JSON.stringify(Object.keys(bt.choice))), $t._encode(lt.value, dt);
    }, at.prototype._encodePrimitive = function(lt, dt) {
      var bt = (this || b$c)._baseState;
      if (/str$/.test(lt))
        return this._encodeStr(dt, lt);
      if (lt === "objid" && bt.args)
        return this._encodeObjid(dt, bt.reverseArgs[0], bt.args[1]);
      if (lt === "objid")
        return this._encodeObjid(dt, null, null);
      if (lt === "gentime" || lt === "utctime")
        return this._encodeTime(dt, lt);
      if (lt === "null_")
        return this._encodeNull();
      if (lt === "int" || lt === "enum")
        return this._encodeInt(dt, bt.args && bt.reverseArgs[0]);
      if (lt === "bool")
        return this._encodeBool(dt);
      if (lt === "objDesc")
        return this._encodeStr(dt, lt);
      throw new Error("Unsupported tag: " + lt);
    }, at.prototype._isNumstr = function(lt) {
      return /^[0-9 ]*$/.test(lt);
    }, at.prototype._isPrintstr = function(lt) {
      return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(lt);
    }, _$e;
  }(), m$g;
}
var j$6 = {}, w$f = !1, B$9 = {}, k$c = !1;
function T$6() {
  if (k$c)
    return B$9;
  k$c = !0;
  var $e = B$9;
  return $e._reverse = function(Ze) {
    var Fe = {};
    return Object.keys(Ze).forEach(function(Ke) {
      (0 | Ke) == Ke && (Ke |= 0);
      var Ve = Ze[Ke];
      Fe[Ve] = Ke;
    }), Fe;
  }, $e.der = function() {
    if (w$f)
      return j$6;
    w$f = !0;
    var Ze = T$6();
    return j$6.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" }, j$6.tagClassByName = Ze._reverse(j$6.tagClass), j$6.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" }, j$6.tagByName = Ze._reverse(j$6.tag), j$6;
  }(), B$9;
}
var D$5 = {}, U$7 = !1, N$5 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function C$6() {
  if (U$7)
    return D$5;
  U$7 = !0;
  var $e = t$2, Ze = Y$3(), Fe = Ze.base, Ke = Ze.bignum, Ve = Ze.constants.der;
  function Je(lt) {
    (this || N$5).enc = "der", (this || N$5).name = lt.name, (this || N$5).entity = lt, (this || N$5).tree = new Qe(), (this || N$5).tree._init(lt.body);
  }
  function Qe(lt) {
    Fe.Node.call(this || N$5, "der", lt);
  }
  function at(lt, dt) {
    var bt = lt.readUInt8(dt);
    if (lt.isError(bt))
      return bt;
    var $t = Ve.tagClass[bt >> 6], vt = (32 & bt) == 0;
    if ((31 & bt) == 31) {
      var wt = bt;
      for (bt = 0; (128 & wt) == 128; ) {
        if (wt = lt.readUInt8(dt), lt.isError(wt))
          return wt;
        bt <<= 7, bt |= 127 & wt;
      }
    } else
      bt &= 31;
    return { cls: $t, primitive: vt, tag: bt, tagStr: Ve.tag[bt] };
  }
  function ut(lt, dt, bt) {
    var $t = lt.readUInt8(bt);
    if (lt.isError($t))
      return $t;
    if (!dt && $t === 128)
      return null;
    if (!(128 & $t))
      return $t;
    var vt = 127 & $t;
    if (vt > 4)
      return lt.error("length octect is too long");
    $t = 0;
    for (var wt = 0; wt < vt; wt++) {
      $t <<= 8;
      var xt = lt.readUInt8(bt);
      if (lt.isError(xt))
        return xt;
      $t |= xt;
    }
    return $t;
  }
  return D$5 = Je, Je.prototype.decode = function(lt, dt) {
    return lt instanceof Fe.DecoderBuffer || (lt = new Fe.DecoderBuffer(lt, dt)), (this || N$5).tree._decode(lt, dt);
  }, $e(Qe, Fe.Node), Qe.prototype._peekTag = function(lt, dt, bt) {
    if (lt.isEmpty())
      return !1;
    var $t = lt.save(), vt = at(lt, 'Failed to peek tag: "' + dt + '"');
    return lt.isError(vt) ? vt : (lt.restore($t), vt.tag === dt || vt.tagStr === dt || vt.tagStr + "of" === dt || bt);
  }, Qe.prototype._decodeTag = function(lt, dt, bt) {
    var $t = at(lt, 'Failed to decode tag of "' + dt + '"');
    if (lt.isError($t))
      return $t;
    var vt = ut(lt, $t.primitive, 'Failed to get length of "' + dt + '"');
    if (lt.isError(vt))
      return vt;
    if (!bt && $t.tag !== dt && $t.tagStr !== dt && $t.tagStr + "of" !== dt)
      return lt.error('Failed to match tag: "' + dt + '"');
    if ($t.primitive || vt !== null)
      return lt.skip(vt, 'Failed to match body of: "' + dt + '"');
    var wt = lt.save(), xt = this._skipUntilEnd(lt, 'Failed to skip indefinite length body: "' + (this || N$5).tag + '"');
    return lt.isError(xt) ? xt : (vt = lt.offset - wt.offset, lt.restore(wt), lt.skip(vt, 'Failed to match body of: "' + dt + '"'));
  }, Qe.prototype._skipUntilEnd = function(lt, dt) {
    for (; ; ) {
      var bt = at(lt, dt);
      if (lt.isError(bt))
        return bt;
      var $t, vt = ut(lt, bt.primitive, dt);
      if (lt.isError(vt))
        return vt;
      if ($t = bt.primitive || vt !== null ? lt.skip(vt) : this._skipUntilEnd(lt, dt), lt.isError($t))
        return $t;
      if (bt.tagStr === "end")
        break;
    }
  }, Qe.prototype._decodeList = function(lt, dt, bt, $t) {
    for (var vt = []; !lt.isEmpty(); ) {
      var wt = this._peekTag(lt, "end");
      if (lt.isError(wt))
        return wt;
      var xt = bt.decode(lt, "der", $t);
      if (lt.isError(xt) && wt)
        break;
      vt.push(xt);
    }
    return vt;
  }, Qe.prototype._decodeStr = function(lt, dt) {
    if (dt === "bitstr") {
      var bt = lt.readUInt8();
      return lt.isError(bt) ? bt : { unused: bt, data: lt.raw() };
    }
    if (dt === "bmpstr") {
      var $t = lt.raw();
      if ($t.length % 2 == 1)
        return lt.error("Decoding of string type: bmpstr length mismatch");
      for (var vt = "", wt = 0; wt < $t.length / 2; wt++)
        vt += String.fromCharCode($t.readUInt16BE(2 * wt));
      return vt;
    }
    if (dt === "numstr") {
      var xt = lt.raw().toString("ascii");
      return this._isNumstr(xt) ? xt : lt.error("Decoding of string type: numstr unsupported characters");
    }
    if (dt === "octstr" || dt === "objDesc")
      return lt.raw();
    if (dt === "printstr") {
      var Et = lt.raw().toString("ascii");
      return this._isPrintstr(Et) ? Et : lt.error("Decoding of string type: printstr unsupported characters");
    }
    return /str$/.test(dt) ? lt.raw().toString() : lt.error("Decoding of string type: " + dt + " unsupported");
  }, Qe.prototype._decodeObjid = function(lt, dt, bt) {
    for (var $t, vt = [], wt = 0; !lt.isEmpty(); ) {
      var xt = lt.readUInt8();
      wt <<= 7, wt |= 127 & xt, !(128 & xt) && (vt.push(wt), wt = 0);
    }
    128 & xt && vt.push(wt);
    var Et = vt[0] / 40 | 0, Tt = vt[0] % 40;
    if ($t = bt ? vt : [Et, Tt].concat(vt.slice(1)), dt) {
      var Rt = dt[$t.join(" ")];
      Rt === void 0 && (Rt = dt[$t.join(".")]), Rt !== void 0 && ($t = Rt);
    }
    return $t;
  }, Qe.prototype._decodeTime = function(lt, dt) {
    var bt = lt.raw().toString();
    if (dt === "gentime")
      var $t = 0 | bt.slice(0, 4), vt = 0 | bt.slice(4, 6), wt = 0 | bt.slice(6, 8), xt = 0 | bt.slice(8, 10), Et = 0 | bt.slice(10, 12), Tt = 0 | bt.slice(12, 14);
    else {
      if (dt !== "utctime")
        return lt.error("Decoding " + dt + " time is not supported yet");
      $t = 0 | bt.slice(0, 2), vt = 0 | bt.slice(2, 4), wt = 0 | bt.slice(4, 6), xt = 0 | bt.slice(6, 8), Et = 0 | bt.slice(8, 10), Tt = 0 | bt.slice(10, 12), $t = $t < 70 ? 2e3 + $t : 1900 + $t;
    }
    return Date.UTC($t, vt - 1, wt, xt, Et, Tt, 0);
  }, Qe.prototype._decodeNull = function(lt) {
    return null;
  }, Qe.prototype._decodeBool = function(lt) {
    var dt = lt.readUInt8();
    return lt.isError(dt) ? dt : dt !== 0;
  }, Qe.prototype._decodeInt = function(lt, dt) {
    var bt = lt.raw(), $t = new Ke(bt);
    return dt && ($t = dt[$t.toString(10)] || $t), $t;
  }, Qe.prototype._use = function(lt, dt) {
    return typeof lt == "function" && (lt = lt(dt)), lt._getDecoder("der").tree;
  }, D$5;
}
var O$6 = {}, A$9 = !1, x$7 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, I$9 = {}, q$5 = !1;
function P$5() {
  if (q$5)
    return I$9;
  q$5 = !0;
  var $e = I$9;
  return $e.der = C$6(), $e.pem = function() {
    if (A$9)
      return O$6;
    A$9 = !0;
    var Ze = t$2, Fe = e$1$1$1.Buffer, Ke = C$6();
    function Ve(Je) {
      Ke.call(this || x$7, Je), (this || x$7).enc = "pem";
    }
    return Ze(Ve, Ke), O$6 = Ve, Ve.prototype.decode = function(Je, Qe) {
      for (var at = Je.toString().split(/[\r\n]+/g), ut = Qe.label.toUpperCase(), lt = /^-----(BEGIN|END) ([^-]+)-----$/, dt = -1, bt = -1, $t = 0; $t < at.length; $t++) {
        var vt = at[$t].match(lt);
        if (vt !== null && vt[2] === ut) {
          if (dt !== -1) {
            if (vt[1] !== "END")
              break;
            bt = $t;
            break;
          }
          if (vt[1] !== "BEGIN")
            break;
          dt = $t;
        }
      }
      if (dt === -1 || bt === -1)
        throw new Error("PEM section not found for: " + ut);
      var wt = at.slice(dt + 1, bt).join("");
      wt.replace(/[^a-z0-9\+\/=]+/gi, "");
      var xt = new Fe(wt, "base64");
      return Ke.prototype.decode.call(this || x$7, xt, Qe);
    }, O$6;
  }(), I$9;
}
var F$6 = {}, K$5 = !1, R$4 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function $$2() {
  if (K$5)
    return F$6;
  K$5 = !0;
  var $e = t$2, Ze = e$1$1$1.Buffer, Fe = Y$3(), Ke = Fe.base, Ve = Fe.constants.der;
  function Je(ut) {
    (this || R$4).enc = "der", (this || R$4).name = ut.name, (this || R$4).entity = ut, (this || R$4).tree = new Qe(), (this || R$4).tree._init(ut.body);
  }
  function Qe(ut) {
    Ke.Node.call(this || R$4, "der", ut);
  }
  function at(ut) {
    return ut < 10 ? "0" + ut : ut;
  }
  return F$6 = Je, Je.prototype.encode = function(ut, lt) {
    return (this || R$4).tree._encode(ut, lt).join();
  }, $e(Qe, Ke.Node), Qe.prototype._encodeComposite = function(ut, lt, dt, bt) {
    var $t, vt = function(Tt, Rt, Ct, Zt) {
      var Lt;
      if (Tt === "seqof" ? Tt = "seq" : Tt === "setof" && (Tt = "set"), Ve.tagByName.hasOwnProperty(Tt))
        Lt = Ve.tagByName[Tt];
      else {
        if (typeof Tt != "number" || (0 | Tt) !== Tt)
          return Zt.error("Unknown tag: " + Tt);
        Lt = Tt;
      }
      return Lt >= 31 ? Zt.error("Multi-octet tag encoding unsupported") : (Rt || (Lt |= 32), Lt |= Ve.tagClassByName[Ct || "universal"] << 6);
    }(ut, lt, dt, (this || R$4).reporter);
    if (bt.length < 128)
      return ($t = new Ze(2))[0] = vt, $t[1] = bt.length, this._createEncoderBuffer([$t, bt]);
    for (var wt = 1, xt = bt.length; xt >= 256; xt >>= 8)
      wt++;
    ($t = new Ze(2 + wt))[0] = vt, $t[1] = 128 | wt, xt = 1 + wt;
    for (var Et = bt.length; Et > 0; xt--, Et >>= 8)
      $t[xt] = 255 & Et;
    return this._createEncoderBuffer([$t, bt]);
  }, Qe.prototype._encodeStr = function(ut, lt) {
    if (lt === "bitstr")
      return this._createEncoderBuffer([0 | ut.unused, ut.data]);
    if (lt === "bmpstr") {
      for (var dt = new Ze(2 * ut.length), bt = 0; bt < ut.length; bt++)
        dt.writeUInt16BE(ut.charCodeAt(bt), 2 * bt);
      return this._createEncoderBuffer(dt);
    }
    return lt === "numstr" ? this._isNumstr(ut) ? this._createEncoderBuffer(ut) : (this || R$4).reporter.error("Encoding of string type: numstr supports only digits and space") : lt === "printstr" ? this._isPrintstr(ut) ? this._createEncoderBuffer(ut) : (this || R$4).reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(lt) || lt === "objDesc" ? this._createEncoderBuffer(ut) : (this || R$4).reporter.error("Encoding of string type: " + lt + " unsupported");
  }, Qe.prototype._encodeObjid = function(ut, lt, dt) {
    if (typeof ut == "string") {
      if (!lt)
        return (this || R$4).reporter.error("string objid given, but no values map found");
      if (!lt.hasOwnProperty(ut))
        return (this || R$4).reporter.error("objid not found in values map");
      ut = lt[ut].split(/[\s\.]+/g);
      for (var bt = 0; bt < ut.length; bt++)
        ut[bt] |= 0;
    } else if (Array.isArray(ut))
      for (ut = ut.slice(), bt = 0; bt < ut.length; bt++)
        ut[bt] |= 0;
    if (!Array.isArray(ut))
      return (this || R$4).reporter.error("objid() should be either array or string, got: " + JSON.stringify(ut));
    if (!dt) {
      if (ut[1] >= 40)
        return (this || R$4).reporter.error("Second objid identifier OOB");
      ut.splice(0, 2, 40 * ut[0] + ut[1]);
    }
    var $t = 0;
    for (bt = 0; bt < ut.length; bt++) {
      var vt = ut[bt];
      for ($t++; vt >= 128; vt >>= 7)
        $t++;
    }
    var wt = new Ze($t), xt = wt.length - 1;
    for (bt = ut.length - 1; bt >= 0; bt--)
      for (vt = ut[bt], wt[xt--] = 127 & vt; (vt >>= 7) > 0; )
        wt[xt--] = 128 | 127 & vt;
    return this._createEncoderBuffer(wt);
  }, Qe.prototype._encodeTime = function(ut, lt) {
    var dt, bt = new Date(ut);
    return lt === "gentime" ? dt = [at(bt.getFullYear()), at(bt.getUTCMonth() + 1), at(bt.getUTCDate()), at(bt.getUTCHours()), at(bt.getUTCMinutes()), at(bt.getUTCSeconds()), "Z"].join("") : lt === "utctime" ? dt = [at(bt.getFullYear() % 100), at(bt.getUTCMonth() + 1), at(bt.getUTCDate()), at(bt.getUTCHours()), at(bt.getUTCMinutes()), at(bt.getUTCSeconds()), "Z"].join("") : (this || R$4).reporter.error("Encoding " + lt + " time is not supported yet"), this._encodeStr(dt, "octstr");
  }, Qe.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, Qe.prototype._encodeInt = function(ut, lt) {
    if (typeof ut == "string") {
      if (!lt)
        return (this || R$4).reporter.error("String int or enum given, but no values map");
      if (!lt.hasOwnProperty(ut))
        return (this || R$4).reporter.error("Values map doesn't contain: " + JSON.stringify(ut));
      ut = lt[ut];
    }
    if (typeof ut != "number" && !Ze.isBuffer(ut)) {
      var dt = ut.toArray();
      !ut.sign && 128 & dt[0] && dt.unshift(0), ut = new Ze(dt);
    }
    if (Ze.isBuffer(ut)) {
      var bt = ut.length;
      ut.length === 0 && bt++;
      var $t = new Ze(bt);
      return ut.copy($t), ut.length === 0 && ($t[0] = 0), this._createEncoderBuffer($t);
    }
    if (ut < 128)
      return this._createEncoderBuffer(ut);
    if (ut < 256)
      return this._createEncoderBuffer([0, ut]);
    bt = 1;
    for (var vt = ut; vt >= 256; vt >>= 8)
      bt++;
    for (vt = ($t = new Array(bt)).length - 1; vt >= 0; vt--)
      $t[vt] = 255 & ut, ut >>= 8;
    return 128 & $t[0] && $t.unshift(0), this._createEncoderBuffer(new Ze($t));
  }, Qe.prototype._encodeBool = function(ut) {
    return this._createEncoderBuffer(ut ? 255 : 0);
  }, Qe.prototype._use = function(ut, lt) {
    return typeof ut == "function" && (ut = ut(lt)), ut._getEncoder("der").tree;
  }, Qe.prototype._skipDefault = function(ut, lt, dt) {
    var bt, $t = (this || R$4)._baseState;
    if ($t.default === null)
      return !1;
    var vt = ut.join();
    if ($t.defaultBuffer === void 0 && ($t.defaultBuffer = this._encodeValue($t.default, lt, dt).join()), vt.length !== $t.defaultBuffer.length)
      return !1;
    for (bt = 0; bt < vt.length; bt++)
      if (vt[bt] !== $t.defaultBuffer[bt])
        return !1;
    return !0;
  }, F$6;
}
var G$4 = {}, L$5 = !1, M$7 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, J$4 = {}, V$4 = !1;
function Z$2() {
  if (V$4)
    return J$4;
  V$4 = !0;
  var $e = J$4;
  return $e.der = $$2(), $e.pem = function() {
    if (L$5)
      return G$4;
    L$5 = !0;
    var Ze = t$2, Fe = $$2();
    function Ke(Ve) {
      Fe.call(this || M$7, Ve), (this || M$7).enc = "pem";
    }
    return Ze(Ke, Fe), G$4 = Ke, Ke.prototype.encode = function(Ve, Je) {
      for (var Qe = Fe.prototype.encode.call(this || M$7, Ve).toString("base64"), at = ["-----BEGIN " + Je.label + "-----"], ut = 0; ut < Qe.length; ut += 64)
        at.push(Qe.slice(ut, ut + 64));
      return at.push("-----END " + Je.label + "-----"), at.join(`
`);
    }, G$4;
  }(), J$4;
}
var z$7 = {}, H$6 = !1;
function Y$3() {
  if (H$6)
    return z$7;
  H$6 = !0;
  var $e = z$7;
  return $e.bignum = n$c, $e.define = function() {
    if (s$j)
      return o$n;
    s$j = !0;
    var Ze = Y$3(), Fe = t$2;
    function Ke(Ve, Je) {
      (this || a$m).name = Ve, (this || a$m).body = Je, (this || a$m).decoders = {}, (this || a$m).encoders = {};
    }
    return o$n.define = function(Ve, Je) {
      return new Ke(Ve, Je);
    }, Ke.prototype._createNamed = function(Ve) {
      var Je;
      try {
        Je = exports$11$1.runInThisContext("(function " + (this || a$m).name + `(entity) {
  this._initNamed(entity);
})`);
      } catch {
        Je = function(at) {
          this._initNamed(at);
        };
      }
      return Fe(Je, Ve), Je.prototype._initNamed = function(Qe) {
        Ve.call(this || a$m, Qe);
      }, new Je(this || a$m);
    }, Ke.prototype._getDecoder = function(Ve) {
      return Ve = Ve || "der", (this || a$m).decoders.hasOwnProperty(Ve) || ((this || a$m).decoders[Ve] = this._createNamed(Ze.decoders[Ve])), (this || a$m).decoders[Ve];
    }, Ke.prototype.decode = function(Ve, Je, Qe) {
      return this._getDecoder(Je).decode(Ve, Qe);
    }, Ke.prototype._getEncoder = function(Ve) {
      return Ve = Ve || "der", (this || a$m).encoders.hasOwnProperty(Ve) || ((this || a$m).encoders[Ve] = this._createNamed(Ze.encoders[Ve])), (this || a$m).encoders[Ve];
    }, Ke.prototype.encode = function(Ve, Je, Qe) {
      return this._getEncoder(Je).encode(Ve, Qe);
    }, o$n;
  }().define, $e.base = E$9(), $e.constants = T$6(), $e.decoders = P$5(), $e.encoders = Z$2(), z$7;
}
var Q$3 = Y$3(), e$f = Q$3, t$a = e$f.define("Time", function() {
  this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
}), s$k = e$f.define("AttributeTypeValue", function() {
  this.seq().obj(this.key("type").objid(), this.key("value").any());
}), n$n = e$f.define("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
}), o$o = e$f.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(n$n), this.key("subjectPublicKey").bitstr());
}), h$h = e$f.define("RelativeDistinguishedName", function() {
  this.setof(s$k);
}), y$g = e$f.define("RDNSequence", function() {
  this.seqof(h$h);
}), r$g = e$f.define("Name", function() {
  this.choice({ rdnSequence: this.use(y$g) });
}), u$k = e$f.define("Validity", function() {
  this.seq().obj(this.key("notBefore").use(t$a), this.key("notAfter").use(t$a));
}), a$n = e$f.define("Extension", function() {
  this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr());
}), c$j = e$f.define("TBSCertificate", function() {
  this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(n$n), this.key("issuer").use(r$g), this.key("validity").use(u$k), this.key("subject").use(r$g), this.key("subjectPublicKeyInfo").use(o$o), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(a$n).optional());
}), k$d = e$f.define("X509Certificate", function() {
  this.seq().obj(this.key("tbsCertificate").use(c$j), this.key("signatureAlgorithm").use(n$n), this.key("signatureValue").bitstr());
}), f$o = {}, b$d = Q$3;
f$o.certificate = k$d;
var l$l = b$d.define("RSAPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
});
f$o.RSAPrivateKey = l$l;
var d$j = b$d.define("RSAPublicKey", function() {
  this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
});
f$o.RSAPublicKey = d$j;
var p$l = b$d.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(j$7), this.key("subjectPublicKey").bitstr());
});
f$o.PublicKey = p$l;
var j$7 = b$d.define("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
}), v$g = b$d.define("PrivateKeyInfo", function() {
  this.seq().obj(this.key("version").int(), this.key("algorithm").use(j$7), this.key("subjectPrivateKey").octstr());
});
f$o.PrivateKey = v$g;
var m$h = b$d.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
});
f$o.EncryptedPrivateKey = m$h;
var q$6 = b$d.define("DSAPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
});
f$o.DSAPrivateKey = q$6, f$o.DSAparam = b$d.define("DSAparam", function() {
  this.int();
});
var K$6 = b$d.define("ECPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(P$6), this.key("publicKey").optional().explicit(1).bitstr());
});
f$o.ECPrivateKey = K$6;
var P$6 = b$d.define("ECParameters", function() {
  this.choice({ namedCurve: this.objid() });
});
f$o.signature = b$d.define("signature", function() {
  this.seq().obj(this.key("r").int(), this.key("s").int());
});
var s$l, i$a = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r\+\/\=]+)[\n\r]+/m, o$p = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, d$k = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r\+\/\=]+)-----END \1-----$/m, n$o = a$c, p$m = t$3, u$l = u4.Buffer, y$h = f$o, m$i = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" }, f$p = function($e, Ze) {
  var Fe, Ke = $e.toString(), Ve = Ke.match(i$a);
  if (Ve) {
    var Je = "aes" + Ve[1], Qe = u$l.from(Ve[2], "hex"), at = u$l.from(Ve[3].replace(/[\r\n]/g, ""), "base64"), ut = n$o(Ze, Qe.slice(0, 8), parseInt(Ve[1], 10)).key, lt = [], dt = p$m.createDecipheriv(Je, ut, Qe);
    lt.push(dt.update(at)), lt.push(dt.final()), Fe = u$l.concat(lt);
  } else {
    var bt = Ke.match(d$k);
    Fe = new u$l(bt[2].replace(/[\r\n]/g, ""), "base64");
  }
  return { tag: Ke.match(o$p)[1], data: Fe };
}, b$e = t$3, E$a = M$1$2, h$i = u4.Buffer;
function l$m($e) {
  var Ze;
  typeof $e != "object" || h$i.isBuffer($e) || (Ze = $e.passphrase, $e = $e.key), typeof $e == "string" && ($e = h$i.from($e));
  var Fe, Ke, Ve = f$p($e, Ze), Je = Ve.tag, Qe = Ve.data;
  switch (Je) {
    case "CERTIFICATE":
      Ke = y$h.certificate.decode(Qe, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (Ke || (Ke = y$h.PublicKey.decode(Qe, "der")), Fe = Ke.algorithm.algorithm.join(".")) {
        case "1.2.840.113549.1.1.1":
          return y$h.RSAPublicKey.decode(Ke.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return Ke.subjectPrivateKey = Ke.subjectPublicKey, { type: "ec", data: Ke };
        case "1.2.840.10040.4.1":
          return Ke.algorithm.params.pub_key = y$h.DSAparam.decode(Ke.subjectPublicKey.data, "der"), { type: "dsa", data: Ke.algorithm.params };
        default:
          throw new Error("unknown key id " + Fe);
      }
    case "ENCRYPTED PRIVATE KEY":
      Qe = function(at, ut) {
        var lt = at.algorithm.decrypt.kde.kdeparams.salt, dt = parseInt(at.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), bt = m$i[at.algorithm.decrypt.cipher.algo.join(".")], $t = at.algorithm.decrypt.cipher.iv, vt = at.subjectPrivateKey, wt = parseInt(bt.split("-")[1], 10) / 8, xt = E$a.pbkdf2Sync(ut, lt, dt, wt, "sha1"), Et = b$e.createDecipheriv(bt, xt, $t), Tt = [];
        return Tt.push(Et.update(vt)), Tt.push(Et.final()), h$i.concat(Tt);
      }(Qe = y$h.EncryptedPrivateKey.decode(Qe, "der"), Ze);
    case "PRIVATE KEY":
      switch (Fe = (Ke = y$h.PrivateKey.decode(Qe, "der")).algorithm.algorithm.join(".")) {
        case "1.2.840.113549.1.1.1":
          return y$h.RSAPrivateKey.decode(Ke.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return { curve: Ke.algorithm.curve, privateKey: y$h.ECPrivateKey.decode(Ke.subjectPrivateKey, "der").privateKey };
        case "1.2.840.10040.4.1":
          return Ke.algorithm.params.priv_key = y$h.DSAparam.decode(Ke.subjectPrivateKey, "der"), { type: "dsa", params: Ke.algorithm.params };
        default:
          throw new Error("unknown key id " + Fe);
      }
    case "RSA PUBLIC KEY":
      return y$h.RSAPublicKey.decode(Qe, "der");
    case "RSA PRIVATE KEY":
      return y$h.RSAPrivateKey.decode(Qe, "der");
    case "DSA PRIVATE KEY":
      return { type: "dsa", params: y$h.DSAPrivateKey.decode(Qe, "der") };
    case "EC PRIVATE KEY":
      return { curve: (Qe = y$h.ECPrivateKey.decode(Qe, "der")).parameters.value, privateKey: Qe.privateKey };
    default:
      throw new Error("unknown key type " + Je);
  }
}
s$l = l$m, l$m.signature = y$h.signature;
var v$h = s$l, p$n = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" }, d$l = {}, f$q = e$1$1$1.Buffer, c$k = w$3, g$f = l$d, w$g = Le.ec, l$n = n$c, m$j = v$h, v$i = p$n;
function y$i($e, Ze, Fe, Ke) {
  if (($e = new f$q($e.toArray())).length < Ze.byteLength()) {
    var Ve = new f$q(Ze.byteLength() - $e.length);
    Ve.fill(0), $e = f$q.concat([Ve, $e]);
  }
  var Je = Fe.length, Qe = function(lt, dt) {
    lt = (lt = b$f(lt, dt)).mod(dt);
    var bt = new f$q(lt.toArray());
    if (bt.length < dt.byteLength()) {
      var $t = new f$q(dt.byteLength() - bt.length);
      $t.fill(0), bt = f$q.concat([$t, bt]);
    }
    return bt;
  }(Fe, Ze), at = new f$q(Je);
  at.fill(1);
  var ut = new f$q(Je);
  return ut.fill(0), ut = c$k(Ke, ut).update(at).update(new f$q([0])).update($e).update(Qe).digest(), at = c$k(Ke, ut).update(at).digest(), { k: ut = c$k(Ke, ut).update(at).update(new f$q([1])).update($e).update(Qe).digest(), v: at = c$k(Ke, ut).update(at).digest() };
}
function b$f($e, Ze) {
  var Fe = new l$n($e), Ke = ($e.length << 3) - Ze.bitLength();
  return Ke > 0 && Fe.ishrn(Ke), Fe;
}
function _$f($e, Ze, Fe) {
  var Ke, Ve;
  do {
    for (Ke = new f$q(0); 8 * Ke.length < $e.bitLength(); )
      Ze.v = c$k(Fe, Ze.k).update(Ze.v).digest(), Ke = f$q.concat([Ke, Ze.v]);
    Ve = b$f(Ke, $e), Ze.k = c$k(Fe, Ze.k).update(Ze.v).update(new f$q([0])).digest(), Ze.v = c$k(Fe, Ze.k).update(Ze.v).digest();
  } while (Ve.cmp($e) !== -1);
  return Ve;
}
function k$e($e, Ze, Fe, Ke) {
  return $e.toRed(l$n.mont(Fe)).redPow(Ze).fromRed().mod(Ke);
}
(d$l = function($e, Ze, Fe, Ke, Ve) {
  var Je = m$j(Ze);
  if (Je.curve) {
    if (Ke !== "ecdsa" && Ke !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    return function(lt, dt) {
      var bt = v$i[dt.curve.join(".")];
      if (!bt)
        throw new Error("unknown curve " + dt.curve.join("."));
      var $t = new w$g(bt).keyFromPrivate(dt.privateKey).sign(lt);
      return new f$q($t.toDER());
    }($e, Je);
  }
  if (Je.type === "dsa") {
    if (Ke !== "dsa")
      throw new Error("wrong private key type");
    return function(lt, dt, bt) {
      for (var $t, vt = dt.params.priv_key, wt = dt.params.p, xt = dt.params.q, Et = dt.params.g, Tt = new l$n(0), Rt = b$f(lt, xt).mod(xt), Ct = !1, Zt = y$i(vt, xt, lt, bt); Ct === !1; )
        $t = _$f(xt, Zt, bt), Tt = k$e(Et, $t, wt, xt), (Ct = $t.invm(xt).imul(Rt.add(vt.mul(Tt))).mod(xt)).cmpn(0) === 0 && (Ct = !1, Tt = new l$n(0));
      return function(Lt, Ut) {
        Lt = Lt.toArray(), Ut = Ut.toArray(), 128 & Lt[0] && (Lt = [0].concat(Lt)), 128 & Ut[0] && (Ut = [0].concat(Ut));
        var Pt = [48, Lt.length + Ut.length + 4, 2, Lt.length];
        return Pt = Pt.concat(Lt, [2, Ut.length], Ut), new f$q(Pt);
      }(Tt, Ct);
    }($e, Je, Fe);
  }
  if (Ke !== "rsa" && Ke !== "ecdsa/rsa")
    throw new Error("wrong private key type");
  $e = f$q.concat([Ve, $e]);
  for (var Qe = Je.modulus.byteLength(), at = [0, 1]; $e.length + at.length + 1 < Qe; )
    at.push(255);
  at.push(0);
  for (var ut = -1; ++ut < $e.length; )
    at.push($e[ut]);
  return g$f(at, Je);
}).getKey = y$i, d$l.makeKey = _$f;
var E$b = d$l, L$6 = e$1$1$1.Buffer, R$5 = n$c, j$8 = Le.ec, T$7 = v$h, P$7 = p$n;
function A$a($e, Ze) {
  if ($e.cmpn(0) <= 0)
    throw new Error("invalid sig");
  if ($e.cmp(Ze) >= Ze)
    throw new Error("invalid sig");
}
var K$7 = function($e, Ze, Fe, Ke, Ve) {
  var Je = T$7(Fe);
  if (Je.type === "ec") {
    if (Ke !== "ecdsa" && Ke !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    return function($t, vt, wt) {
      var xt = P$7[wt.data.algorithm.curve.join(".")];
      if (!xt)
        throw new Error("unknown curve " + wt.data.algorithm.curve.join("."));
      var Et = new j$8(xt), Tt = wt.data.subjectPrivateKey.data;
      return Et.verify(vt, $t, Tt);
    }($e, Ze, Je);
  }
  if (Je.type === "dsa") {
    if (Ke !== "dsa")
      throw new Error("wrong public key type");
    return function($t, vt, wt) {
      var xt = wt.data.p, Et = wt.data.q, Tt = wt.data.g, Rt = wt.data.pub_key, Ct = T$7.signature.decode($t, "der"), Zt = Ct.s, Lt = Ct.r;
      A$a(Zt, Et), A$a(Lt, Et);
      var Ut = R$5.mont(xt), Pt = Zt.invm(Et);
      return Tt.toRed(Ut).redPow(new R$5(vt).mul(Pt).mod(Et)).fromRed().mul(Rt.toRed(Ut).redPow(Lt.mul(Pt).mod(Et)).fromRed()).mod(xt).mod(Et).cmp(Lt) === 0;
    }($e, Ze, Je);
  }
  if (Ke !== "rsa" && Ke !== "ecdsa/rsa")
    throw new Error("wrong public key type");
  Ze = L$6.concat([Ve, Ze]);
  for (var Qe = Je.modulus.byteLength(), at = [1], ut = 0; Ze.length + at.length + 2 < Qe; )
    at.push(255), ut++;
  at.push(0);
  for (var lt = -1; ++lt < Ze.length; )
    at.push(Ze[lt]);
  at = new L$6(at);
  var dt = R$5.mont(Je.modulus);
  $e = ($e = new R$5($e).toRed(dt)).redPow(new R$5(Je.publicExponent)), $e = new L$6($e.fromRed().toArray());
  var bt = ut < 8 ? 1 : 0;
  for (Qe = Math.min($e.length, at.length), $e.length !== at.length && (bt = 1), lt = -1; ++lt < Qe; )
    bt |= $e[lt] ^ at[lt];
  return bt === 0;
}, W$4 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, x$8 = e$1$1$1.Buffer, B$a = h$4, S$b = b$i, q$7 = t$2, U$8 = E$b, V$5 = K$7, C$7 = s$4;
function D$6($e) {
  S$b.Writable.call(this || W$4);
  var Ze = C$7[$e];
  if (!Ze)
    throw new Error("Unknown message digest");
  (this || W$4)._hashType = Ze.hash, (this || W$4)._hash = B$a(Ze.hash), (this || W$4)._tag = Ze.id, (this || W$4)._signType = Ze.sign;
}
function F$7($e) {
  S$b.Writable.call(this || W$4);
  var Ze = C$7[$e];
  if (!Ze)
    throw new Error("Unknown message digest");
  (this || W$4)._hash = B$a(Ze.hash), (this || W$4)._tag = Ze.id, (this || W$4)._signType = Ze.sign;
}
function M$8($e) {
  return new D$6($e);
}
function O$7($e) {
  return new F$7($e);
}
Object.keys(C$7).forEach(function($e) {
  C$7[$e].id = new x$8(C$7[$e].id, "hex"), C$7[$e.toLowerCase()] = C$7[$e];
}), q$7(D$6, S$b.Writable), D$6.prototype._write = function($e, Ze, Fe) {
  (this || W$4)._hash.update($e), Fe();
}, D$6.prototype.update = function($e, Ze) {
  return typeof $e == "string" && ($e = new x$8($e, Ze)), (this || W$4)._hash.update($e), this || W$4;
}, D$6.prototype.sign = function($e, Ze) {
  this.end();
  var Fe = (this || W$4)._hash.digest(), Ke = U$8(Fe, $e, (this || W$4)._hashType, (this || W$4)._signType, (this || W$4)._tag);
  return Ze ? Ke.toString(Ze) : Ke;
}, q$7(F$7, S$b.Writable), F$7.prototype._write = function($e, Ze, Fe) {
  (this || W$4)._hash.update($e), Fe();
}, F$7.prototype.update = function($e, Ze) {
  return typeof $e == "string" && ($e = new x$8($e, Ze)), (this || W$4)._hash.update($e), this || W$4;
}, F$7.prototype.verify = function($e, Ze, Fe) {
  typeof Ze == "string" && (Ze = new x$8(Ze, Fe)), this.end();
  var Ke = (this || W$4)._hash.digest();
  return V$5(Ze, Ke, $e, (this || W$4)._signType, (this || W$4)._tag);
};
var z$8 = { Sign: M$8, Verify: O$7, createSign: M$8, createVerify: O$7 }, i$b, n$p = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, p$o = e$1$1$1.Buffer, s$m = Le, u$m = n$c;
i$b = function($e) {
  return new c$l($e);
};
var o$q = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
function c$l($e) {
  (this || n$p).curveType = o$q[$e], (this || n$p).curveType || ((this || n$p).curveType = { name: $e }), (this || n$p).curve = new s$m.ec((this || n$p).curveType.name), (this || n$p).keys = void 0;
}
function y$j($e, Ze, Fe) {
  Array.isArray($e) || ($e = $e.toArray());
  var Ke = new p$o($e);
  if (Fe && Ke.length < Fe) {
    var Ve = new p$o(Fe - Ke.length);
    Ve.fill(0), Ke = p$o.concat([Ve, Ke]);
  }
  return Ze ? Ke.toString(Ze) : Ke;
}
o$q.p224 = o$q.secp224r1, o$q.p256 = o$q.secp256r1 = o$q.prime256v1, o$q.p192 = o$q.secp192r1 = o$q.prime192v1, o$q.p384 = o$q.secp384r1, o$q.p521 = o$q.secp521r1, c$l.prototype.generateKeys = function($e, Ze) {
  return (this || n$p).keys = (this || n$p).curve.genKeyPair(), this.getPublicKey($e, Ze);
}, c$l.prototype.computeSecret = function($e, Ze, Fe) {
  return Ze = Ze || "utf8", p$o.isBuffer($e) || ($e = new p$o($e, Ze)), y$j((this || n$p).curve.keyFromPublic($e).getPublic().mul((this || n$p).keys.getPrivate()).getX(), Fe, (this || n$p).curveType.byteLength);
}, c$l.prototype.getPublicKey = function($e, Ze) {
  var Fe = (this || n$p).keys.getPublic(Ze === "compressed", !0);
  return Ze === "hybrid" && (Fe[Fe.length - 1] % 2 ? Fe[0] = 7 : Fe[0] = 6), y$j(Fe, $e);
}, c$l.prototype.getPrivateKey = function($e) {
  return y$j((this || n$p).keys.getPrivate(), $e);
}, c$l.prototype.setPublicKey = function($e, Ze) {
  return Ze = Ze || "utf8", p$o.isBuffer($e) || ($e = new p$o($e, Ze)), (this || n$p).keys._importPublic($e), this || n$p;
}, c$l.prototype.setPrivateKey = function($e, Ze) {
  Ze = Ze || "utf8", p$o.isBuffer($e) || ($e = new p$o($e, Ze));
  var Fe = new u$m($e);
  return Fe = Fe.toString(16), (this || n$p).keys = (this || n$p).curve.genKeyPair(), (this || n$p).keys._importPrivate(Fe), this || n$p;
};
var f$r = i$b, i$c = h$4, l$o = u4.Buffer;
function f$s($e) {
  var Ze = l$o.allocUnsafe(4);
  return Ze.writeUInt32BE($e, 0), Ze;
}
var u$n = function($e, Ze) {
  for (var Fe, Ke = l$o.alloc(0), Ve = 0; Ke.length < Ze; )
    Fe = f$s(Ve++), Ke = l$o.concat([Ke, i$c("sha1").update($e).update(Fe).digest()]);
  return Ke.slice(0, Ze);
}, c$m = function($e, Ze) {
  for (var Fe = $e.length, Ke = -1; ++Ke < Fe; )
    $e[Ke] ^= Ze[Ke];
  return $e;
}, p$p = n$c, d$m = u4.Buffer, h$j = function($e, Ze) {
  return d$m.from($e.toRed(p$p.mont(Ze.modulus)).redPow(new p$p(Ze.publicExponent)).fromRed().toArray());
}, s$n = v$h, g$g = a5, m$k = h$4, w$h = u$n, v$j = c$m, y$k = n$c, E$c = h$j, b$g = l$d, B$b = u4.Buffer, x$9 = function($e, Ze, Fe) {
  var Ke;
  Ke = $e.padding ? $e.padding : Fe ? 1 : 4;
  var Ve, Je = s$n($e);
  if (Ke === 4)
    Ve = function(Qe, at) {
      var ut = Qe.modulus.byteLength(), lt = at.length, dt = m$k("sha1").update(B$b.alloc(0)).digest(), bt = dt.length, $t = 2 * bt;
      if (lt > ut - $t - 2)
        throw new Error("message too long");
      var vt = B$b.alloc(ut - lt - $t - 2), wt = ut - bt - 1, xt = g$g(bt), Et = v$j(B$b.concat([dt, vt, B$b.alloc(1, 1), at], wt), w$h(xt, wt)), Tt = v$j(xt, w$h(Et, bt));
      return new y$k(B$b.concat([B$b.alloc(1), Tt, Et], ut));
    }(Je, Ze);
  else if (Ke === 1)
    Ve = function(Qe, at, ut) {
      var lt, dt = at.length, bt = Qe.modulus.byteLength();
      if (dt > bt - 11)
        throw new Error("message too long");
      return lt = ut ? B$b.alloc(bt - dt - 3, 255) : function($t) {
        for (var vt, wt = B$b.allocUnsafe($t), xt = 0, Et = g$g(2 * $t), Tt = 0; xt < $t; )
          Tt === Et.length && (Et = g$g(2 * $t), Tt = 0), (vt = Et[Tt++]) && (wt[xt++] = vt);
        return wt;
      }(bt - dt - 3), new y$k(B$b.concat([B$b.from([0, ut ? 1 : 2]), lt, B$b.alloc(1), at], bt));
    }(Je, Ze, Fe);
  else {
    if (Ke !== 3)
      throw new Error("unknown padding");
    if ((Ve = new y$k(Ze)).cmp(Je.modulus) >= 0)
      throw new Error("data too long for modulus");
  }
  return Fe ? b$g(Ve, Je) : E$c(Ve, Je);
}, L$7 = v$h, k$f = u$n, D$7 = c$m, U$9 = n$c, R$6 = l$d, S$c = h$4, j$9 = h$j, A$b = u4.Buffer, I$a = function($e, Ze, Fe) {
  var Ke;
  Ke = $e.padding ? $e.padding : Fe ? 1 : 4;
  var Ve, Je = L$7($e), Qe = Je.modulus.byteLength();
  if (Ze.length > Qe || new U$9(Ze).cmp(Je.modulus) >= 0)
    throw new Error("decryption error");
  Ve = Fe ? j$9(new U$9(Ze), Je) : R$6(Ze, Je);
  var at = A$b.alloc(Qe - Ve.length);
  if (Ve = A$b.concat([at, Ve], Qe), Ke === 4)
    return function(ut, lt) {
      var dt = ut.modulus.byteLength(), bt = S$c("sha1").update(A$b.alloc(0)).digest(), $t = bt.length;
      if (lt[0] !== 0)
        throw new Error("decryption error");
      var vt = lt.slice(1, $t + 1), wt = lt.slice($t + 1), xt = D$7(vt, k$f(wt, $t)), Et = D$7(wt, k$f(xt, dt - $t - 1));
      if (function(Rt, Ct) {
        Rt = A$b.from(Rt), Ct = A$b.from(Ct);
        var Zt = 0, Lt = Rt.length;
        Rt.length !== Ct.length && (Zt++, Lt = Math.min(Rt.length, Ct.length));
        for (var Ut = -1; ++Ut < Lt; )
          Zt += Rt[Ut] ^ Ct[Ut];
        return Zt;
      }(bt, Et.slice(0, $t)))
        throw new Error("decryption error");
      for (var Tt = $t; Et[Tt] === 0; )
        Tt++;
      if (Et[Tt++] !== 1)
        throw new Error("decryption error");
      return Et.slice(Tt);
    }(Je, Ve);
  if (Ke === 1)
    return function(ut, lt, dt) {
      for (var bt = lt.slice(0, 2), $t = 2, vt = 0; lt[$t++] !== 0; )
        if ($t >= lt.length) {
          vt++;
          break;
        }
      var wt = lt.slice(2, $t - 1);
      if ((bt.toString("hex") !== "0002" && !dt || bt.toString("hex") !== "0001" && dt) && vt++, wt.length < 8 && vt++, vt)
        throw new Error("decryption error");
      return lt.slice($t);
    }(0, Ve, Fe);
  if (Ke === 3)
    return Ve;
  throw new Error("unknown padding");
}, M$9 = {};
M$9.publicEncrypt = x$9, M$9.privateDecrypt = I$a, M$9.privateEncrypt = function($e, Ze) {
  return M$9.publicEncrypt($e, Ze, !0);
}, M$9.publicDecrypt = function($e, Ze) {
  return M$9.privateDecrypt($e, Ze, !0);
};
var o$r = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global, t$b = {}, f$t = T;
function i$d() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var u$o = u4, a$o = a5, s$o = u$o.Buffer, l$p = u$o.kMaxLength, m$l = o$r.crypto || o$r.msCrypto, p$q = Math.pow(2, 32) - 1;
function y$l($e, Ze) {
  if (typeof $e != "number" || $e != $e)
    throw new TypeError("offset must be a number");
  if ($e > p$q || $e < 0)
    throw new TypeError("offset must be a uint32");
  if ($e > l$p || $e > Ze)
    throw new RangeError("offset out of range");
}
function b$h($e, Ze, Fe) {
  if (typeof $e != "number" || $e != $e)
    throw new TypeError("size must be a number");
  if ($e > p$q || $e < 0)
    throw new TypeError("size must be a uint32");
  if ($e + Ze > Fe || $e > l$p)
    throw new RangeError("buffer too small");
}
function w$i($e, Ze, Fe, Ke) {
  if (f$t.browser) {
    var Ve = $e.buffer, Je = new Uint8Array(Ve, Ze, Fe);
    return m$l.getRandomValues(Je), Ke ? (f$t.nextTick(function() {
      Ke(null, $e);
    }), void 0) : $e;
  }
  return Ke ? (a$o(Fe, function(Qe, at) {
    if (Qe)
      return Ke(Qe);
    at.copy($e, Ze), Ke(null, $e);
  }), void 0) : (a$o(Fe).copy($e, Ze), $e);
}
m$l && m$l.getRandomValues || !f$t.browser ? (t$b.randomFill = function($e, Ze, Fe, Ke) {
  if (!(s$o.isBuffer($e) || $e instanceof o$r.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof Ze == "function")
    Ke = Ze, Ze = 0, Fe = $e.length;
  else if (typeof Fe == "function")
    Ke = Fe, Fe = $e.length - Ze;
  else if (typeof Ke != "function")
    throw new TypeError('"cb" argument must be a function');
  return y$l(Ze, $e.length), b$h(Fe, Ze, $e.length), w$i($e, Ze, Fe, Ke);
}, t$b.randomFillSync = function($e, Ze, Fe) {
  if (Ze === void 0 && (Ze = 0), !(s$o.isBuffer($e) || $e instanceof o$r.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return y$l(Ze, $e.length), Fe === void 0 && (Fe = $e.length - Ze), b$h(Fe, Ze, $e.length), w$i($e, Ze, Fe);
}) : (t$b.randomFill = i$d, t$b.randomFillSync = i$d);
var l$q = {};
l$q.randomBytes = l$q.rng = l$q.pseudoRandomBytes = l$q.prng = a5, l$q.createHash = l$q.Hash = h$4, l$q.createHmac = l$q.Hmac = w$3;
var D$8 = s$4, s$p = Object.keys(D$8), _$g = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(s$p);
l$q.getHashes = function() {
  return _$g;
};
var h$k = M$1$2;
l$q.pbkdf2 = h$k.pbkdf2, l$q.pbkdf2Sync = h$k.pbkdf2Sync;
var y$m = p$d;
l$q.Cipher = y$m.Cipher, l$q.createCipher = y$m.createCipher, l$q.Cipheriv = y$m.Cipheriv, l$q.createCipheriv = y$m.createCipheriv, l$q.Decipher = y$m.Decipher, l$q.createDecipher = y$m.createDecipher, l$q.Decipheriv = y$m.Decipheriv, l$q.createDecipheriv = y$m.createDecipheriv, l$q.getCiphers = y$m.getCiphers, l$q.listCiphers = y$m.listCiphers;
var E$d = O$3;
l$q.DiffieHellmanGroup = E$d.DiffieHellmanGroup, l$q.createDiffieHellmanGroup = E$d.createDiffieHellmanGroup, l$q.getDiffieHellman = E$d.getDiffieHellman, l$q.createDiffieHellman = E$d.createDiffieHellman, l$q.DiffieHellman = E$d.DiffieHellman;
var S$d = z$8;
l$q.createSign = S$d.createSign, l$q.Sign = S$d.Sign, l$q.createVerify = S$d.createVerify, l$q.Verify = S$d.Verify, l$q.createECDH = f$r;
var C$8 = M$9;
l$q.publicEncrypt = C$8.publicEncrypt, l$q.privateEncrypt = C$8.privateEncrypt, l$q.publicDecrypt = C$8.publicDecrypt, l$q.privateDecrypt = C$8.privateDecrypt;
var N$6 = t$b;
l$q.randomFill = N$6.randomFill, l$q.randomFillSync = N$6.randomFillSync, l$q.createCredentials = function() {
  throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
}, l$q.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
var exports$10$1 = {}, _dewExec$10$1 = !1, _global$a$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$10$1() {
  if (_dewExec$10$1)
    return exports$10$1;
  _dewExec$10$1 = !0;
  var $e;
  exports$10$1 = function(Ve) {
    return $e || ($e = new Ze(null)), $e.generate(Ve);
  };
  function Ze(Ke) {
    (this || _global$a$1).rand = Ke;
  }
  if (exports$10$1.Rand = Ze, Ze.prototype.generate = function(Ve) {
    return this._rand(Ve);
  }, Ze.prototype._rand = function(Ve) {
    if ((this || _global$a$1).rand.getBytes)
      return (this || _global$a$1).rand.getBytes(Ve);
    for (var Je = new Uint8Array(Ve), Qe = 0; Qe < Je.length; Qe++)
      Je[Qe] = (this || _global$a$1).rand.getByte();
    return Je;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? Ze.prototype._rand = function(Ve) {
      var Je = new Uint8Array(Ve);
      return self.crypto.getRandomValues(Je), Je;
    } : self.msCrypto && self.msCrypto.getRandomValues ? Ze.prototype._rand = function(Ve) {
      var Je = new Uint8Array(Ve);
      return self.msCrypto.getRandomValues(Je), Je;
    } : typeof window == "object" && (Ze.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var Fe = l$q;
      if (typeof Fe.randomBytes != "function")
        throw new Error("Not supported");
      Ze.prototype._rand = function(Ve) {
        return Fe.randomBytes(Ve);
      };
    } catch {
    }
  return exports$10$1;
}
var exports$$$1 = {}, _dewExec$$$1 = !1, _global$9$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$$$1() {
  if (_dewExec$$$1)
    return exports$$$1;
  _dewExec$$$1 = !0;
  var $e = dew$11$1(), Ze = dew$10$1();
  function Fe(Ke) {
    (this || _global$9$1).rand = Ke || new Ze.Rand();
  }
  return exports$$$1 = Fe, Fe.create = function(Ve) {
    return new Fe(Ve);
  }, Fe.prototype._randbelow = function(Ve) {
    var Je = Ve.bitLength(), Qe = Math.ceil(Je / 8);
    do
      var at = new $e((this || _global$9$1).rand.generate(Qe));
    while (at.cmp(Ve) >= 0);
    return at;
  }, Fe.prototype._randrange = function(Ve, Je) {
    var Qe = Je.sub(Ve);
    return Ve.add(this._randbelow(Qe));
  }, Fe.prototype.test = function(Ve, Je, Qe) {
    var at = Ve.bitLength(), ut = $e.mont(Ve), lt = new $e(1).toRed(ut);
    Je || (Je = Math.max(1, at / 48 | 0));
    for (var dt = Ve.subn(1), bt = 0; !dt.testn(bt); bt++)
      ;
    for (var $t = Ve.shrn(bt), vt = dt.toRed(ut), wt = !0; Je > 0; Je--) {
      var xt = this._randrange(new $e(2), dt);
      Qe && Qe(xt);
      var Et = xt.toRed(ut).redPow($t);
      if (!(Et.cmp(lt) === 0 || Et.cmp(vt) === 0)) {
        for (var Tt = 1; Tt < bt; Tt++) {
          if (Et = Et.redSqr(), Et.cmp(lt) === 0)
            return !1;
          if (Et.cmp(vt) === 0)
            break;
        }
        if (Tt === bt)
          return !1;
      }
    }
    return wt;
  }, Fe.prototype.getDivisor = function(Ve, Je) {
    var Qe = Ve.bitLength(), at = $e.mont(Ve), ut = new $e(1).toRed(at);
    Je || (Je = Math.max(1, Qe / 48 | 0));
    for (var lt = Ve.subn(1), dt = 0; !lt.testn(dt); dt++)
      ;
    for (var bt = Ve.shrn(dt), $t = lt.toRed(at); Je > 0; Je--) {
      var vt = this._randrange(new $e(2), lt), wt = Ve.gcd(vt);
      if (wt.cmpn(1) !== 0)
        return wt;
      var xt = vt.toRed(at).redPow(bt);
      if (!(xt.cmp(ut) === 0 || xt.cmp($t) === 0)) {
        for (var Et = 1; Et < dt; Et++) {
          if (xt = xt.redSqr(), xt.cmp(ut) === 0)
            return xt.fromRed().subn(1).gcd(Ve);
          if (xt.cmp($t) === 0)
            break;
        }
        if (Et === dt)
          return xt = xt.redSqr(), xt.fromRed().subn(1).gcd(Ve);
      }
    }
    return !1;
  }, exports$$$1;
}
var exports$_$1 = {}, _dewExec$_$1 = !1;
function dew$_$1() {
  if (_dewExec$_$1)
    return exports$_$1;
  _dewExec$_$1 = !0;
  var $e = dew$1S();
  exports$_$1 = Et, Et.simpleSieve = wt, Et.fermatTest = xt;
  var Ze = dew$122(), Fe = new Ze(24), Ke = dew$$$1(), Ve = new Ke(), Je = new Ze(1), Qe = new Ze(2), at = new Ze(5);
  new Ze(16), new Ze(8);
  var ut = new Ze(10), lt = new Ze(3);
  new Ze(7);
  var dt = new Ze(11), bt = new Ze(4);
  new Ze(12);
  var $t = null;
  function vt() {
    if ($t !== null)
      return $t;
    var Tt = 1048576, Rt = [];
    Rt[0] = 2;
    for (var Ct = 1, Zt = 3; Zt < Tt; Zt += 2) {
      for (var Lt = Math.ceil(Math.sqrt(Zt)), Ut = 0; Ut < Ct && Rt[Ut] <= Lt && Zt % Rt[Ut] !== 0; Ut++)
        ;
      Ct !== Ut && Rt[Ut] <= Lt || (Rt[Ct++] = Zt);
    }
    return $t = Rt, Rt;
  }
  function wt(Tt) {
    for (var Rt = vt(), Ct = 0; Ct < Rt.length; Ct++)
      if (Tt.modn(Rt[Ct]) === 0)
        return Tt.cmpn(Rt[Ct]) === 0;
    return !0;
  }
  function xt(Tt) {
    var Rt = Ze.mont(Tt);
    return Qe.toRed(Rt).redPow(Tt.subn(1)).fromRed().cmpn(1) === 0;
  }
  function Et(Tt, Rt) {
    if (Tt < 16)
      return Rt === 2 || Rt === 5 ? new Ze([140, 123]) : new Ze([140, 39]);
    Rt = new Ze(Rt);
    for (var Ct, Zt; ; ) {
      for (Ct = new Ze($e(Math.ceil(Tt / 8))); Ct.bitLength() > Tt; )
        Ct.ishrn(1);
      if (Ct.isEven() && Ct.iadd(Je), Ct.testn(1) || Ct.iadd(Qe), Rt.cmp(Qe)) {
        if (!Rt.cmp(at))
          for (; Ct.mod(ut).cmp(lt); )
            Ct.iadd(bt);
      } else
        for (; Ct.mod(Fe).cmp(dt); )
          Ct.iadd(bt);
      if (Zt = Ct.shrn(1), wt(Zt) && wt(Ct) && xt(Zt) && xt(Ct) && Ve.test(Zt) && Ve.test(Ct))
        return Ct;
    }
  }
  return exports$_$1;
}
var _primes$1 = {
  modp1: {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
  },
  modp2: {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
  },
  modp5: {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
  },
  modp14: {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
  },
  modp15: {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
  },
  modp16: {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
  },
  modp17: {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
  },
  modp18: {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
  }
}, exports$Z$1 = {}, _dewExec$Z$1 = !1, _global$8$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$Z$1() {
  if (_dewExec$Z$1)
    return exports$Z$1;
  _dewExec$Z$1 = !0;
  var $e = e$1$1$1.Buffer, Ze = dew$122(), Fe = dew$$$1(), Ke = new Fe(), Ve = new Ze(24), Je = new Ze(11), Qe = new Ze(10), at = new Ze(3), ut = new Ze(7), lt = dew$_$1(), dt = dew$1S();
  exports$Z$1 = xt;
  function bt(Tt, Rt) {
    return Rt = Rt || "utf8", $e.isBuffer(Tt) || (Tt = new $e(Tt, Rt)), (this || _global$8$1)._pub = new Ze(Tt), this || _global$8$1;
  }
  function $t(Tt, Rt) {
    return Rt = Rt || "utf8", $e.isBuffer(Tt) || (Tt = new $e(Tt, Rt)), (this || _global$8$1)._priv = new Ze(Tt), this || _global$8$1;
  }
  var vt = {};
  function wt(Tt, Rt) {
    var Ct = Rt.toString("hex"), Zt = [Ct, Tt.toString(16)].join("_");
    if (Zt in vt)
      return vt[Zt];
    var Lt = 0;
    if (Tt.isEven() || !lt.simpleSieve || !lt.fermatTest(Tt) || !Ke.test(Tt))
      return Lt += 1, Ct === "02" || Ct === "05" ? Lt += 8 : Lt += 4, vt[Zt] = Lt, Lt;
    Ke.test(Tt.shrn(1)) || (Lt += 2);
    var Ut;
    switch (Ct) {
      case "02":
        Tt.mod(Ve).cmp(Je) && (Lt += 8);
        break;
      case "05":
        Ut = Tt.mod(Qe), Ut.cmp(at) && Ut.cmp(ut) && (Lt += 8);
        break;
      default:
        Lt += 4;
    }
    return vt[Zt] = Lt, Lt;
  }
  function xt(Tt, Rt, Ct) {
    this.setGenerator(Rt), (this || _global$8$1).__prime = new Ze(Tt), (this || _global$8$1)._prime = Ze.mont((this || _global$8$1).__prime), (this || _global$8$1)._primeLen = Tt.length, (this || _global$8$1)._pub = void 0, (this || _global$8$1)._priv = void 0, (this || _global$8$1)._primeCode = void 0, Ct ? ((this || _global$8$1).setPublicKey = bt, (this || _global$8$1).setPrivateKey = $t) : (this || _global$8$1)._primeCode = 8;
  }
  Object.defineProperty(xt.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof (this || _global$8$1)._primeCode != "number" && ((this || _global$8$1)._primeCode = wt((this || _global$8$1).__prime, (this || _global$8$1).__gen)), (this || _global$8$1)._primeCode;
    }
  }), xt.prototype.generateKeys = function() {
    return (this || _global$8$1)._priv || ((this || _global$8$1)._priv = new Ze(dt((this || _global$8$1)._primeLen))), (this || _global$8$1)._pub = (this || _global$8$1)._gen.toRed((this || _global$8$1)._prime).redPow((this || _global$8$1)._priv).fromRed(), this.getPublicKey();
  }, xt.prototype.computeSecret = function(Tt) {
    Tt = new Ze(Tt), Tt = Tt.toRed((this || _global$8$1)._prime);
    var Rt = Tt.redPow((this || _global$8$1)._priv).fromRed(), Ct = new $e(Rt.toArray()), Zt = this.getPrime();
    if (Ct.length < Zt.length) {
      var Lt = new $e(Zt.length - Ct.length);
      Lt.fill(0), Ct = $e.concat([Lt, Ct]);
    }
    return Ct;
  }, xt.prototype.getPublicKey = function(Rt) {
    return Et((this || _global$8$1)._pub, Rt);
  }, xt.prototype.getPrivateKey = function(Rt) {
    return Et((this || _global$8$1)._priv, Rt);
  }, xt.prototype.getPrime = function(Tt) {
    return Et((this || _global$8$1).__prime, Tt);
  }, xt.prototype.getGenerator = function(Tt) {
    return Et((this || _global$8$1)._gen, Tt);
  }, xt.prototype.setGenerator = function(Tt, Rt) {
    return Rt = Rt || "utf8", $e.isBuffer(Tt) || (Tt = new $e(Tt, Rt)), (this || _global$8$1).__gen = Tt, (this || _global$8$1)._gen = new Ze(Tt), this || _global$8$1;
  };
  function Et(Tt, Rt) {
    var Ct = new $e(Tt.toArray());
    return Rt ? Ct.toString(Rt) : Ct;
  }
  return exports$Z$1;
}
var exports$Y$1 = {}, _dewExec$Y$1 = !1;
function dew$Y$1() {
  if (_dewExec$Y$1)
    return exports$Y$1;
  _dewExec$Y$1 = !0;
  var $e = e$1$1$1.Buffer, Ze = dew$_$1(), Fe = _primes$1, Ke = dew$Z$1();
  function Ve(at) {
    var ut = new $e(Fe[at].prime, "hex"), lt = new $e(Fe[at].gen, "hex");
    return new Ke(ut, lt);
  }
  var Je = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function Qe(at, ut, lt, dt) {
    return $e.isBuffer(ut) || Je[ut] === void 0 ? Qe(at, "binary", ut, lt) : (ut = ut || "binary", dt = dt || "binary", lt = lt || new $e([2]), $e.isBuffer(lt) || (lt = new $e(lt, dt)), typeof at == "number" ? new Ke(Ze(at, lt), lt, !0) : ($e.isBuffer(at) || (at = new $e(at, ut)), new Ke(at, lt, !0)));
  }
  return exports$Y$1.DiffieHellmanGroup = exports$Y$1.createDiffieHellmanGroup = exports$Y$1.getDiffieHellman = Ve, exports$Y$1.createDiffieHellman = exports$Y$1.DiffieHellman = Qe, exports$Y$1;
}
var exports$X$1 = {}, _dewExec$X$1 = !1, module$4$1 = {
  exports: exports$X$1
}, _global$7$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$X$1() {
  return _dewExec$X$1 || (_dewExec$X$1 = !0, function($e, Ze) {
    function Fe(Xe, rt) {
      if (!Xe)
        throw new Error(rt || "Assertion failed");
    }
    function Ke(Xe, rt) {
      Xe.super_ = rt;
      var ot = function() {
      };
      ot.prototype = rt.prototype, Xe.prototype = new ot(), Xe.prototype.constructor = Xe;
    }
    function Ve(Xe, rt, ot) {
      if (Ve.isBN(Xe))
        return Xe;
      (this || _global$7$1).negative = 0, (this || _global$7$1).words = null, (this || _global$7$1).length = 0, (this || _global$7$1).red = null, Xe !== null && ((rt === "le" || rt === "be") && (ot = rt, rt = 10), this._init(Xe || 0, rt || 10, ot || "be"));
    }
    typeof $e == "object" ? $e.exports = Ve : Ze.BN = Ve, Ve.BN = Ve, Ve.wordSize = 26;
    var Je;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Je = window.Buffer : Je = e$1$1$1.Buffer;
    } catch {
    }
    Ve.isBN = function(rt) {
      return rt instanceof Ve ? !0 : rt !== null && typeof rt == "object" && rt.constructor.wordSize === Ve.wordSize && Array.isArray(rt.words);
    }, Ve.max = function(rt, ot) {
      return rt.cmp(ot) > 0 ? rt : ot;
    }, Ve.min = function(rt, ot) {
      return rt.cmp(ot) < 0 ? rt : ot;
    }, Ve.prototype._init = function(rt, ot, ft) {
      if (typeof rt == "number")
        return this._initNumber(rt, ot, ft);
      if (typeof rt == "object")
        return this._initArray(rt, ot, ft);
      ot === "hex" && (ot = 16), Fe(ot === (ot | 0) && ot >= 2 && ot <= 36), rt = rt.toString().replace(/\s+/g, "");
      var mt = 0;
      rt[0] === "-" && (mt++, (this || _global$7$1).negative = 1), mt < rt.length && (ot === 16 ? this._parseHex(rt, mt, ft) : (this._parseBase(rt, ot, mt), ft === "le" && this._initArray(this.toArray(), ot, ft)));
    }, Ve.prototype._initNumber = function(rt, ot, ft) {
      rt < 0 && ((this || _global$7$1).negative = 1, rt = -rt), rt < 67108864 ? ((this || _global$7$1).words = [rt & 67108863], (this || _global$7$1).length = 1) : rt < 4503599627370496 ? ((this || _global$7$1).words = [rt & 67108863, rt / 67108864 & 67108863], (this || _global$7$1).length = 2) : (Fe(rt < 9007199254740992), (this || _global$7$1).words = [rt & 67108863, rt / 67108864 & 67108863, 1], (this || _global$7$1).length = 3), ft === "le" && this._initArray(this.toArray(), ot, ft);
    }, Ve.prototype._initArray = function(rt, ot, ft) {
      if (Fe(typeof rt.length == "number"), rt.length <= 0)
        return (this || _global$7$1).words = [0], (this || _global$7$1).length = 1, this || _global$7$1;
      (this || _global$7$1).length = Math.ceil(rt.length / 3), (this || _global$7$1).words = new Array((this || _global$7$1).length);
      for (var mt = 0; mt < (this || _global$7$1).length; mt++)
        (this || _global$7$1).words[mt] = 0;
      var yt, pt, Ge = 0;
      if (ft === "be")
        for (mt = rt.length - 1, yt = 0; mt >= 0; mt -= 3)
          pt = rt[mt] | rt[mt - 1] << 8 | rt[mt - 2] << 16, (this || _global$7$1).words[yt] |= pt << Ge & 67108863, (this || _global$7$1).words[yt + 1] = pt >>> 26 - Ge & 67108863, Ge += 24, Ge >= 26 && (Ge -= 26, yt++);
      else if (ft === "le")
        for (mt = 0, yt = 0; mt < rt.length; mt += 3)
          pt = rt[mt] | rt[mt + 1] << 8 | rt[mt + 2] << 16, (this || _global$7$1).words[yt] |= pt << Ge & 67108863, (this || _global$7$1).words[yt + 1] = pt >>> 26 - Ge & 67108863, Ge += 24, Ge >= 26 && (Ge -= 26, yt++);
      return this._strip();
    };
    function Qe(Xe, rt) {
      var ot = Xe.charCodeAt(rt);
      if (ot >= 48 && ot <= 57)
        return ot - 48;
      if (ot >= 65 && ot <= 70)
        return ot - 55;
      if (ot >= 97 && ot <= 102)
        return ot - 87;
      Fe(!1, "Invalid character in " + Xe);
    }
    function at(Xe, rt, ot) {
      var ft = Qe(Xe, ot);
      return ot - 1 >= rt && (ft |= Qe(Xe, ot - 1) << 4), ft;
    }
    Ve.prototype._parseHex = function(rt, ot, ft) {
      (this || _global$7$1).length = Math.ceil((rt.length - ot) / 6), (this || _global$7$1).words = new Array((this || _global$7$1).length);
      for (var mt = 0; mt < (this || _global$7$1).length; mt++)
        (this || _global$7$1).words[mt] = 0;
      var yt = 0, pt = 0, Ge;
      if (ft === "be")
        for (mt = rt.length - 1; mt >= ot; mt -= 2)
          Ge = at(rt, ot, mt) << yt, (this || _global$7$1).words[pt] |= Ge & 67108863, yt >= 18 ? (yt -= 18, pt += 1, (this || _global$7$1).words[pt] |= Ge >>> 26) : yt += 8;
      else {
        var ct = rt.length - ot;
        for (mt = ct % 2 === 0 ? ot + 1 : ot; mt < rt.length; mt += 2)
          Ge = at(rt, ot, mt) << yt, (this || _global$7$1).words[pt] |= Ge & 67108863, yt >= 18 ? (yt -= 18, pt += 1, (this || _global$7$1).words[pt] |= Ge >>> 26) : yt += 8;
      }
      this._strip();
    };
    function ut(Xe, rt, ot, ft) {
      for (var mt = 0, yt = 0, pt = Math.min(Xe.length, ot), Ge = rt; Ge < pt; Ge++) {
        var ct = Xe.charCodeAt(Ge) - 48;
        mt *= ft, ct >= 49 ? yt = ct - 49 + 10 : ct >= 17 ? yt = ct - 17 + 10 : yt = ct, Fe(ct >= 0 && yt < ft, "Invalid character"), mt += yt;
      }
      return mt;
    }
    Ve.prototype._parseBase = function(rt, ot, ft) {
      (this || _global$7$1).words = [0], (this || _global$7$1).length = 1;
      for (var mt = 0, yt = 1; yt <= 67108863; yt *= ot)
        mt++;
      mt--, yt = yt / ot | 0;
      for (var pt = rt.length - ft, Ge = pt % mt, ct = Math.min(pt, pt - Ge) + ft, Mt = 0, St = ft; St < ct; St += mt)
        Mt = ut(rt, St, St + mt, ot), this.imuln(yt), (this || _global$7$1).words[0] + Mt < 67108864 ? (this || _global$7$1).words[0] += Mt : this._iaddn(Mt);
      if (Ge !== 0) {
        var At = 1;
        for (Mt = ut(rt, St, rt.length, ot), St = 0; St < Ge; St++)
          At *= ot;
        this.imuln(At), (this || _global$7$1).words[0] + Mt < 67108864 ? (this || _global$7$1).words[0] += Mt : this._iaddn(Mt);
      }
      this._strip();
    }, Ve.prototype.copy = function(rt) {
      rt.words = new Array((this || _global$7$1).length);
      for (var ot = 0; ot < (this || _global$7$1).length; ot++)
        rt.words[ot] = (this || _global$7$1).words[ot];
      rt.length = (this || _global$7$1).length, rt.negative = (this || _global$7$1).negative, rt.red = (this || _global$7$1).red;
    };
    function lt(Xe, rt) {
      Xe.words = rt.words, Xe.length = rt.length, Xe.negative = rt.negative, Xe.red = rt.red;
    }
    if (Ve.prototype._move = function(rt) {
      lt(rt, this || _global$7$1);
    }, Ve.prototype.clone = function() {
      var rt = new Ve(null);
      return this.copy(rt), rt;
    }, Ve.prototype._expand = function(rt) {
      for (; (this || _global$7$1).length < rt; )
        (this || _global$7$1).words[(this || _global$7$1).length++] = 0;
      return this || _global$7$1;
    }, Ve.prototype._strip = function() {
      for (; (this || _global$7$1).length > 1 && (this || _global$7$1).words[(this || _global$7$1).length - 1] === 0; )
        (this || _global$7$1).length--;
      return this._normSign();
    }, Ve.prototype._normSign = function() {
      return (this || _global$7$1).length === 1 && (this || _global$7$1).words[0] === 0 && ((this || _global$7$1).negative = 0), this || _global$7$1;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        Ve.prototype[Symbol.for("nodejs.util.inspect.custom")] = dt;
      } catch {
        Ve.prototype.inspect = dt;
      }
    else
      Ve.prototype.inspect = dt;
    function dt() {
      return ((this || _global$7$1).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var bt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], $t = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], vt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    Ve.prototype.toString = function(rt, ot) {
      rt = rt || 10, ot = ot | 0 || 1;
      var ft;
      if (rt === 16 || rt === "hex") {
        ft = "";
        for (var mt = 0, yt = 0, pt = 0; pt < (this || _global$7$1).length; pt++) {
          var Ge = (this || _global$7$1).words[pt], ct = ((Ge << mt | yt) & 16777215).toString(16);
          yt = Ge >>> 24 - mt & 16777215, yt !== 0 || pt !== (this || _global$7$1).length - 1 ? ft = bt[6 - ct.length] + ct + ft : ft = ct + ft, mt += 2, mt >= 26 && (mt -= 26, pt--);
        }
        for (yt !== 0 && (ft = yt.toString(16) + ft); ft.length % ot !== 0; )
          ft = "0" + ft;
        return (this || _global$7$1).negative !== 0 && (ft = "-" + ft), ft;
      }
      if (rt === (rt | 0) && rt >= 2 && rt <= 36) {
        var Mt = $t[rt], St = vt[rt];
        ft = "";
        var At = this.clone();
        for (At.negative = 0; !At.isZero(); ) {
          var Nt = At.modrn(St).toString(rt);
          At = At.idivn(St), At.isZero() ? ft = Nt + ft : ft = bt[Mt - Nt.length] + Nt + ft;
        }
        for (this.isZero() && (ft = "0" + ft); ft.length % ot !== 0; )
          ft = "0" + ft;
        return (this || _global$7$1).negative !== 0 && (ft = "-" + ft), ft;
      }
      Fe(!1, "Base should be between 2 and 36");
    }, Ve.prototype.toNumber = function() {
      var rt = (this || _global$7$1).words[0];
      return (this || _global$7$1).length === 2 ? rt += (this || _global$7$1).words[1] * 67108864 : (this || _global$7$1).length === 3 && (this || _global$7$1).words[2] === 1 ? rt += 4503599627370496 + (this || _global$7$1).words[1] * 67108864 : (this || _global$7$1).length > 2 && Fe(!1, "Number can only safely store up to 53 bits"), (this || _global$7$1).negative !== 0 ? -rt : rt;
    }, Ve.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, Je && (Ve.prototype.toBuffer = function(rt, ot) {
      return this.toArrayLike(Je, rt, ot);
    }), Ve.prototype.toArray = function(rt, ot) {
      return this.toArrayLike(Array, rt, ot);
    };
    var wt = function(rt, ot) {
      return rt.allocUnsafe ? rt.allocUnsafe(ot) : new rt(ot);
    };
    Ve.prototype.toArrayLike = function(rt, ot, ft) {
      this._strip();
      var mt = this.byteLength(), yt = ft || Math.max(1, mt);
      Fe(mt <= yt, "byte array longer than desired length"), Fe(yt > 0, "Requested array length <= 0");
      var pt = wt(rt, yt), Ge = ot === "le" ? "LE" : "BE";
      return this["_toArrayLike" + Ge](pt, mt), pt;
    }, Ve.prototype._toArrayLikeLE = function(rt, ot) {
      for (var ft = 0, mt = 0, yt = 0, pt = 0; yt < (this || _global$7$1).length; yt++) {
        var Ge = (this || _global$7$1).words[yt] << pt | mt;
        rt[ft++] = Ge & 255, ft < rt.length && (rt[ft++] = Ge >> 8 & 255), ft < rt.length && (rt[ft++] = Ge >> 16 & 255), pt === 6 ? (ft < rt.length && (rt[ft++] = Ge >> 24 & 255), mt = 0, pt = 0) : (mt = Ge >>> 24, pt += 2);
      }
      if (ft < rt.length)
        for (rt[ft++] = mt; ft < rt.length; )
          rt[ft++] = 0;
    }, Ve.prototype._toArrayLikeBE = function(rt, ot) {
      for (var ft = rt.length - 1, mt = 0, yt = 0, pt = 0; yt < (this || _global$7$1).length; yt++) {
        var Ge = (this || _global$7$1).words[yt] << pt | mt;
        rt[ft--] = Ge & 255, ft >= 0 && (rt[ft--] = Ge >> 8 & 255), ft >= 0 && (rt[ft--] = Ge >> 16 & 255), pt === 6 ? (ft >= 0 && (rt[ft--] = Ge >> 24 & 255), mt = 0, pt = 0) : (mt = Ge >>> 24, pt += 2);
      }
      if (ft >= 0)
        for (rt[ft--] = mt; ft >= 0; )
          rt[ft--] = 0;
    }, Math.clz32 ? Ve.prototype._countBits = function(rt) {
      return 32 - Math.clz32(rt);
    } : Ve.prototype._countBits = function(rt) {
      var ot = rt, ft = 0;
      return ot >= 4096 && (ft += 13, ot >>>= 13), ot >= 64 && (ft += 7, ot >>>= 7), ot >= 8 && (ft += 4, ot >>>= 4), ot >= 2 && (ft += 2, ot >>>= 2), ft + ot;
    }, Ve.prototype._zeroBits = function(rt) {
      if (rt === 0)
        return 26;
      var ot = rt, ft = 0;
      return ot & 8191 || (ft += 13, ot >>>= 13), ot & 127 || (ft += 7, ot >>>= 7), ot & 15 || (ft += 4, ot >>>= 4), ot & 3 || (ft += 2, ot >>>= 2), ot & 1 || ft++, ft;
    }, Ve.prototype.bitLength = function() {
      var rt = (this || _global$7$1).words[(this || _global$7$1).length - 1], ot = this._countBits(rt);
      return ((this || _global$7$1).length - 1) * 26 + ot;
    };
    function xt(Xe) {
      for (var rt = new Array(Xe.bitLength()), ot = 0; ot < rt.length; ot++) {
        var ft = ot / 26 | 0, mt = ot % 26;
        rt[ot] = Xe.words[ft] >>> mt & 1;
      }
      return rt;
    }
    Ve.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var rt = 0, ot = 0; ot < (this || _global$7$1).length; ot++) {
        var ft = this._zeroBits((this || _global$7$1).words[ot]);
        if (rt += ft, ft !== 26)
          break;
      }
      return rt;
    }, Ve.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Ve.prototype.toTwos = function(rt) {
      return (this || _global$7$1).negative !== 0 ? this.abs().inotn(rt).iaddn(1) : this.clone();
    }, Ve.prototype.fromTwos = function(rt) {
      return this.testn(rt - 1) ? this.notn(rt).iaddn(1).ineg() : this.clone();
    }, Ve.prototype.isNeg = function() {
      return (this || _global$7$1).negative !== 0;
    }, Ve.prototype.neg = function() {
      return this.clone().ineg();
    }, Ve.prototype.ineg = function() {
      return this.isZero() || ((this || _global$7$1).negative ^= 1), this || _global$7$1;
    }, Ve.prototype.iuor = function(rt) {
      for (; (this || _global$7$1).length < rt.length; )
        (this || _global$7$1).words[(this || _global$7$1).length++] = 0;
      for (var ot = 0; ot < rt.length; ot++)
        (this || _global$7$1).words[ot] = (this || _global$7$1).words[ot] | rt.words[ot];
      return this._strip();
    }, Ve.prototype.ior = function(rt) {
      return Fe(((this || _global$7$1).negative | rt.negative) === 0), this.iuor(rt);
    }, Ve.prototype.or = function(rt) {
      return (this || _global$7$1).length > rt.length ? this.clone().ior(rt) : rt.clone().ior(this || _global$7$1);
    }, Ve.prototype.uor = function(rt) {
      return (this || _global$7$1).length > rt.length ? this.clone().iuor(rt) : rt.clone().iuor(this || _global$7$1);
    }, Ve.prototype.iuand = function(rt) {
      var ot;
      (this || _global$7$1).length > rt.length ? ot = rt : ot = this || _global$7$1;
      for (var ft = 0; ft < ot.length; ft++)
        (this || _global$7$1).words[ft] = (this || _global$7$1).words[ft] & rt.words[ft];
      return (this || _global$7$1).length = ot.length, this._strip();
    }, Ve.prototype.iand = function(rt) {
      return Fe(((this || _global$7$1).negative | rt.negative) === 0), this.iuand(rt);
    }, Ve.prototype.and = function(rt) {
      return (this || _global$7$1).length > rt.length ? this.clone().iand(rt) : rt.clone().iand(this || _global$7$1);
    }, Ve.prototype.uand = function(rt) {
      return (this || _global$7$1).length > rt.length ? this.clone().iuand(rt) : rt.clone().iuand(this || _global$7$1);
    }, Ve.prototype.iuxor = function(rt) {
      var ot, ft;
      (this || _global$7$1).length > rt.length ? (ot = this || _global$7$1, ft = rt) : (ot = rt, ft = this || _global$7$1);
      for (var mt = 0; mt < ft.length; mt++)
        (this || _global$7$1).words[mt] = ot.words[mt] ^ ft.words[mt];
      if ((this || _global$7$1) !== ot)
        for (; mt < ot.length; mt++)
          (this || _global$7$1).words[mt] = ot.words[mt];
      return (this || _global$7$1).length = ot.length, this._strip();
    }, Ve.prototype.ixor = function(rt) {
      return Fe(((this || _global$7$1).negative | rt.negative) === 0), this.iuxor(rt);
    }, Ve.prototype.xor = function(rt) {
      return (this || _global$7$1).length > rt.length ? this.clone().ixor(rt) : rt.clone().ixor(this || _global$7$1);
    }, Ve.prototype.uxor = function(rt) {
      return (this || _global$7$1).length > rt.length ? this.clone().iuxor(rt) : rt.clone().iuxor(this || _global$7$1);
    }, Ve.prototype.inotn = function(rt) {
      Fe(typeof rt == "number" && rt >= 0);
      var ot = Math.ceil(rt / 26) | 0, ft = rt % 26;
      this._expand(ot), ft > 0 && ot--;
      for (var mt = 0; mt < ot; mt++)
        (this || _global$7$1).words[mt] = ~(this || _global$7$1).words[mt] & 67108863;
      return ft > 0 && ((this || _global$7$1).words[mt] = ~(this || _global$7$1).words[mt] & 67108863 >> 26 - ft), this._strip();
    }, Ve.prototype.notn = function(rt) {
      return this.clone().inotn(rt);
    }, Ve.prototype.setn = function(rt, ot) {
      Fe(typeof rt == "number" && rt >= 0);
      var ft = rt / 26 | 0, mt = rt % 26;
      return this._expand(ft + 1), ot ? (this || _global$7$1).words[ft] = (this || _global$7$1).words[ft] | 1 << mt : (this || _global$7$1).words[ft] = (this || _global$7$1).words[ft] & ~(1 << mt), this._strip();
    }, Ve.prototype.iadd = function(rt) {
      var ot;
      if ((this || _global$7$1).negative !== 0 && rt.negative === 0)
        return (this || _global$7$1).negative = 0, ot = this.isub(rt), (this || _global$7$1).negative ^= 1, this._normSign();
      if ((this || _global$7$1).negative === 0 && rt.negative !== 0)
        return rt.negative = 0, ot = this.isub(rt), rt.negative = 1, ot._normSign();
      var ft, mt;
      (this || _global$7$1).length > rt.length ? (ft = this || _global$7$1, mt = rt) : (ft = rt, mt = this || _global$7$1);
      for (var yt = 0, pt = 0; pt < mt.length; pt++)
        ot = (ft.words[pt] | 0) + (mt.words[pt] | 0) + yt, (this || _global$7$1).words[pt] = ot & 67108863, yt = ot >>> 26;
      for (; yt !== 0 && pt < ft.length; pt++)
        ot = (ft.words[pt] | 0) + yt, (this || _global$7$1).words[pt] = ot & 67108863, yt = ot >>> 26;
      if ((this || _global$7$1).length = ft.length, yt !== 0)
        (this || _global$7$1).words[(this || _global$7$1).length] = yt, (this || _global$7$1).length++;
      else if (ft !== (this || _global$7$1))
        for (; pt < ft.length; pt++)
          (this || _global$7$1).words[pt] = ft.words[pt];
      return this || _global$7$1;
    }, Ve.prototype.add = function(rt) {
      var ot;
      return rt.negative !== 0 && (this || _global$7$1).negative === 0 ? (rt.negative = 0, ot = this.sub(rt), rt.negative ^= 1, ot) : rt.negative === 0 && (this || _global$7$1).negative !== 0 ? ((this || _global$7$1).negative = 0, ot = rt.sub(this || _global$7$1), (this || _global$7$1).negative = 1, ot) : (this || _global$7$1).length > rt.length ? this.clone().iadd(rt) : rt.clone().iadd(this || _global$7$1);
    }, Ve.prototype.isub = function(rt) {
      if (rt.negative !== 0) {
        rt.negative = 0;
        var ot = this.iadd(rt);
        return rt.negative = 1, ot._normSign();
      } else if ((this || _global$7$1).negative !== 0)
        return (this || _global$7$1).negative = 0, this.iadd(rt), (this || _global$7$1).negative = 1, this._normSign();
      var ft = this.cmp(rt);
      if (ft === 0)
        return (this || _global$7$1).negative = 0, (this || _global$7$1).length = 1, (this || _global$7$1).words[0] = 0, this || _global$7$1;
      var mt, yt;
      ft > 0 ? (mt = this || _global$7$1, yt = rt) : (mt = rt, yt = this || _global$7$1);
      for (var pt = 0, Ge = 0; Ge < yt.length; Ge++)
        ot = (mt.words[Ge] | 0) - (yt.words[Ge] | 0) + pt, pt = ot >> 26, (this || _global$7$1).words[Ge] = ot & 67108863;
      for (; pt !== 0 && Ge < mt.length; Ge++)
        ot = (mt.words[Ge] | 0) + pt, pt = ot >> 26, (this || _global$7$1).words[Ge] = ot & 67108863;
      if (pt === 0 && Ge < mt.length && mt !== (this || _global$7$1))
        for (; Ge < mt.length; Ge++)
          (this || _global$7$1).words[Ge] = mt.words[Ge];
      return (this || _global$7$1).length = Math.max((this || _global$7$1).length, Ge), mt !== (this || _global$7$1) && ((this || _global$7$1).negative = 1), this._strip();
    }, Ve.prototype.sub = function(rt) {
      return this.clone().isub(rt);
    };
    function Et(Xe, rt, ot) {
      ot.negative = rt.negative ^ Xe.negative;
      var ft = Xe.length + rt.length | 0;
      ot.length = ft, ft = ft - 1 | 0;
      var mt = Xe.words[0] | 0, yt = rt.words[0] | 0, pt = mt * yt, Ge = pt & 67108863, ct = pt / 67108864 | 0;
      ot.words[0] = Ge;
      for (var Mt = 1; Mt < ft; Mt++) {
        for (var St = ct >>> 26, At = ct & 67108863, Nt = Math.min(Mt, rt.length - 1), qt = Math.max(0, Mt - Xe.length + 1); qt <= Nt; qt++) {
          var Qt = Mt - qt | 0;
          mt = Xe.words[Qt] | 0, yt = rt.words[qt] | 0, pt = mt * yt + At, St += pt / 67108864 | 0, At = pt & 67108863;
        }
        ot.words[Mt] = At | 0, ct = St | 0;
      }
      return ct !== 0 ? ot.words[Mt] = ct | 0 : ot.length--, ot._strip();
    }
    var Tt = function(rt, ot, ft) {
      var mt = rt.words, yt = ot.words, pt = ft.words, Ge = 0, ct, Mt, St, At = mt[0] | 0, Nt = At & 8191, qt = At >>> 13, Qt = mt[1] | 0, Xt = Qt & 8191, zt = Qt >>> 13, Kt = mt[2] | 0, ur = Kt & 8191, er = Kt >>> 13, Dt = mt[3] | 0, Ht = Dt & 8191, Gt = Dt >>> 13, rr = mt[4] | 0, sr = rr & 8191, Jt = rr >>> 13, ir = mt[5] | 0, Br = ir & 8191, or = ir >>> 13, lr = mt[6] | 0, Nr = lr & 8191, dr = lr >>> 13, gr = mt[7] | 0, Zr = gr & 8191, Bt = gr >>> 13, kt = mt[8] | 0, It = kt & 8191, jt = kt >>> 13, Vt = mt[9] | 0, ar = Vt & 8191, Yt = Vt >>> 13, hr = yt[0] | 0, zr = hr & 8191, cr = hr >>> 13, _r = yt[1] | 0, Lr = _r & 8191, br = _r >>> 13, kr = yt[2] | 0, Xr = kr & 8191, yr = kr >>> 13, Ir = yt[3] | 0, Yr = Ir & 8191, wr = Ir >>> 13, Cr = yt[4] | 0, Hr = Cr & 8191, $r = Cr >>> 13, Ar = yt[5] | 0, Wr = Ar & 8191, mr = Ar >>> 13, Tr = yt[6] | 0, Kr = Tr & 8191, vr = Tr >>> 13, Rr = yt[7] | 0, Jr = Rr & 8191, xr = Rr >>> 13, tr = yt[8] | 0, Dr = tr & 8191, fr = tr >>> 13, Mr = yt[9] | 0, Fr = Mr & 8191, qr = Mr >>> 13;
      ft.negative = rt.negative ^ ot.negative, ft.length = 19, ct = Math.imul(Nt, zr), Mt = Math.imul(Nt, cr), Mt = Mt + Math.imul(qt, zr) | 0, St = Math.imul(qt, cr);
      var tn = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, ct = Math.imul(Xt, zr), Mt = Math.imul(Xt, cr), Mt = Mt + Math.imul(zt, zr) | 0, St = Math.imul(zt, cr), ct = ct + Math.imul(Nt, Lr) | 0, Mt = Mt + Math.imul(Nt, br) | 0, Mt = Mt + Math.imul(qt, Lr) | 0, St = St + Math.imul(qt, br) | 0;
      var Qr = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, ct = Math.imul(ur, zr), Mt = Math.imul(ur, cr), Mt = Mt + Math.imul(er, zr) | 0, St = Math.imul(er, cr), ct = ct + Math.imul(Xt, Lr) | 0, Mt = Mt + Math.imul(Xt, br) | 0, Mt = Mt + Math.imul(zt, Lr) | 0, St = St + Math.imul(zt, br) | 0, ct = ct + Math.imul(Nt, Xr) | 0, Mt = Mt + Math.imul(Nt, yr) | 0, Mt = Mt + Math.imul(qt, Xr) | 0, St = St + Math.imul(qt, yr) | 0;
      var nn = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, ct = Math.imul(Ht, zr), Mt = Math.imul(Ht, cr), Mt = Mt + Math.imul(Gt, zr) | 0, St = Math.imul(Gt, cr), ct = ct + Math.imul(ur, Lr) | 0, Mt = Mt + Math.imul(ur, br) | 0, Mt = Mt + Math.imul(er, Lr) | 0, St = St + Math.imul(er, br) | 0, ct = ct + Math.imul(Xt, Xr) | 0, Mt = Mt + Math.imul(Xt, yr) | 0, Mt = Mt + Math.imul(zt, Xr) | 0, St = St + Math.imul(zt, yr) | 0, ct = ct + Math.imul(Nt, Yr) | 0, Mt = Mt + Math.imul(Nt, wr) | 0, Mt = Mt + Math.imul(qt, Yr) | 0, St = St + Math.imul(qt, wr) | 0;
      var Er = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, ct = Math.imul(sr, zr), Mt = Math.imul(sr, cr), Mt = Mt + Math.imul(Jt, zr) | 0, St = Math.imul(Jt, cr), ct = ct + Math.imul(Ht, Lr) | 0, Mt = Mt + Math.imul(Ht, br) | 0, Mt = Mt + Math.imul(Gt, Lr) | 0, St = St + Math.imul(Gt, br) | 0, ct = ct + Math.imul(ur, Xr) | 0, Mt = Mt + Math.imul(ur, yr) | 0, Mt = Mt + Math.imul(er, Xr) | 0, St = St + Math.imul(er, yr) | 0, ct = ct + Math.imul(Xt, Yr) | 0, Mt = Mt + Math.imul(Xt, wr) | 0, Mt = Mt + Math.imul(zt, Yr) | 0, St = St + Math.imul(zt, wr) | 0, ct = ct + Math.imul(Nt, Hr) | 0, Mt = Mt + Math.imul(Nt, $r) | 0, Mt = Mt + Math.imul(qt, Hr) | 0, St = St + Math.imul(qt, $r) | 0;
      var Wt = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, ct = Math.imul(Br, zr), Mt = Math.imul(Br, cr), Mt = Mt + Math.imul(or, zr) | 0, St = Math.imul(or, cr), ct = ct + Math.imul(sr, Lr) | 0, Mt = Mt + Math.imul(sr, br) | 0, Mt = Mt + Math.imul(Jt, Lr) | 0, St = St + Math.imul(Jt, br) | 0, ct = ct + Math.imul(Ht, Xr) | 0, Mt = Mt + Math.imul(Ht, yr) | 0, Mt = Mt + Math.imul(Gt, Xr) | 0, St = St + Math.imul(Gt, yr) | 0, ct = ct + Math.imul(ur, Yr) | 0, Mt = Mt + Math.imul(ur, wr) | 0, Mt = Mt + Math.imul(er, Yr) | 0, St = St + Math.imul(er, wr) | 0, ct = ct + Math.imul(Xt, Hr) | 0, Mt = Mt + Math.imul(Xt, $r) | 0, Mt = Mt + Math.imul(zt, Hr) | 0, St = St + Math.imul(zt, $r) | 0, ct = ct + Math.imul(Nt, Wr) | 0, Mt = Mt + Math.imul(Nt, mr) | 0, Mt = Mt + Math.imul(qt, Wr) | 0, St = St + Math.imul(qt, mr) | 0;
      var nr = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, ct = Math.imul(Nr, zr), Mt = Math.imul(Nr, cr), Mt = Mt + Math.imul(dr, zr) | 0, St = Math.imul(dr, cr), ct = ct + Math.imul(Br, Lr) | 0, Mt = Mt + Math.imul(Br, br) | 0, Mt = Mt + Math.imul(or, Lr) | 0, St = St + Math.imul(or, br) | 0, ct = ct + Math.imul(sr, Xr) | 0, Mt = Mt + Math.imul(sr, yr) | 0, Mt = Mt + Math.imul(Jt, Xr) | 0, St = St + Math.imul(Jt, yr) | 0, ct = ct + Math.imul(Ht, Yr) | 0, Mt = Mt + Math.imul(Ht, wr) | 0, Mt = Mt + Math.imul(Gt, Yr) | 0, St = St + Math.imul(Gt, wr) | 0, ct = ct + Math.imul(ur, Hr) | 0, Mt = Mt + Math.imul(ur, $r) | 0, Mt = Mt + Math.imul(er, Hr) | 0, St = St + Math.imul(er, $r) | 0, ct = ct + Math.imul(Xt, Wr) | 0, Mt = Mt + Math.imul(Xt, mr) | 0, Mt = Mt + Math.imul(zt, Wr) | 0, St = St + Math.imul(zt, mr) | 0, ct = ct + Math.imul(Nt, Kr) | 0, Mt = Mt + Math.imul(Nt, vr) | 0, Mt = Mt + Math.imul(qt, Kr) | 0, St = St + Math.imul(qt, vr) | 0;
      var pr = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, ct = Math.imul(Zr, zr), Mt = Math.imul(Zr, cr), Mt = Mt + Math.imul(Bt, zr) | 0, St = Math.imul(Bt, cr), ct = ct + Math.imul(Nr, Lr) | 0, Mt = Mt + Math.imul(Nr, br) | 0, Mt = Mt + Math.imul(dr, Lr) | 0, St = St + Math.imul(dr, br) | 0, ct = ct + Math.imul(Br, Xr) | 0, Mt = Mt + Math.imul(Br, yr) | 0, Mt = Mt + Math.imul(or, Xr) | 0, St = St + Math.imul(or, yr) | 0, ct = ct + Math.imul(sr, Yr) | 0, Mt = Mt + Math.imul(sr, wr) | 0, Mt = Mt + Math.imul(Jt, Yr) | 0, St = St + Math.imul(Jt, wr) | 0, ct = ct + Math.imul(Ht, Hr) | 0, Mt = Mt + Math.imul(Ht, $r) | 0, Mt = Mt + Math.imul(Gt, Hr) | 0, St = St + Math.imul(Gt, $r) | 0, ct = ct + Math.imul(ur, Wr) | 0, Mt = Mt + Math.imul(ur, mr) | 0, Mt = Mt + Math.imul(er, Wr) | 0, St = St + Math.imul(er, mr) | 0, ct = ct + Math.imul(Xt, Kr) | 0, Mt = Mt + Math.imul(Xt, vr) | 0, Mt = Mt + Math.imul(zt, Kr) | 0, St = St + Math.imul(zt, vr) | 0, ct = ct + Math.imul(Nt, Jr) | 0, Mt = Mt + Math.imul(Nt, xr) | 0, Mt = Mt + Math.imul(qt, Jr) | 0, St = St + Math.imul(qt, xr) | 0;
      var Pr = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, ct = Math.imul(It, zr), Mt = Math.imul(It, cr), Mt = Mt + Math.imul(jt, zr) | 0, St = Math.imul(jt, cr), ct = ct + Math.imul(Zr, Lr) | 0, Mt = Mt + Math.imul(Zr, br) | 0, Mt = Mt + Math.imul(Bt, Lr) | 0, St = St + Math.imul(Bt, br) | 0, ct = ct + Math.imul(Nr, Xr) | 0, Mt = Mt + Math.imul(Nr, yr) | 0, Mt = Mt + Math.imul(dr, Xr) | 0, St = St + Math.imul(dr, yr) | 0, ct = ct + Math.imul(Br, Yr) | 0, Mt = Mt + Math.imul(Br, wr) | 0, Mt = Mt + Math.imul(or, Yr) | 0, St = St + Math.imul(or, wr) | 0, ct = ct + Math.imul(sr, Hr) | 0, Mt = Mt + Math.imul(sr, $r) | 0, Mt = Mt + Math.imul(Jt, Hr) | 0, St = St + Math.imul(Jt, $r) | 0, ct = ct + Math.imul(Ht, Wr) | 0, Mt = Mt + Math.imul(Ht, mr) | 0, Mt = Mt + Math.imul(Gt, Wr) | 0, St = St + Math.imul(Gt, mr) | 0, ct = ct + Math.imul(ur, Kr) | 0, Mt = Mt + Math.imul(ur, vr) | 0, Mt = Mt + Math.imul(er, Kr) | 0, St = St + Math.imul(er, vr) | 0, ct = ct + Math.imul(Xt, Jr) | 0, Mt = Mt + Math.imul(Xt, xr) | 0, Mt = Mt + Math.imul(zt, Jr) | 0, St = St + Math.imul(zt, xr) | 0, ct = ct + Math.imul(Nt, Dr) | 0, Mt = Mt + Math.imul(Nt, fr) | 0, Mt = Mt + Math.imul(qt, Dr) | 0, St = St + Math.imul(qt, fr) | 0;
      var Sr = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, ct = Math.imul(ar, zr), Mt = Math.imul(ar, cr), Mt = Mt + Math.imul(Yt, zr) | 0, St = Math.imul(Yt, cr), ct = ct + Math.imul(It, Lr) | 0, Mt = Mt + Math.imul(It, br) | 0, Mt = Mt + Math.imul(jt, Lr) | 0, St = St + Math.imul(jt, br) | 0, ct = ct + Math.imul(Zr, Xr) | 0, Mt = Mt + Math.imul(Zr, yr) | 0, Mt = Mt + Math.imul(Bt, Xr) | 0, St = St + Math.imul(Bt, yr) | 0, ct = ct + Math.imul(Nr, Yr) | 0, Mt = Mt + Math.imul(Nr, wr) | 0, Mt = Mt + Math.imul(dr, Yr) | 0, St = St + Math.imul(dr, wr) | 0, ct = ct + Math.imul(Br, Hr) | 0, Mt = Mt + Math.imul(Br, $r) | 0, Mt = Mt + Math.imul(or, Hr) | 0, St = St + Math.imul(or, $r) | 0, ct = ct + Math.imul(sr, Wr) | 0, Mt = Mt + Math.imul(sr, mr) | 0, Mt = Mt + Math.imul(Jt, Wr) | 0, St = St + Math.imul(Jt, mr) | 0, ct = ct + Math.imul(Ht, Kr) | 0, Mt = Mt + Math.imul(Ht, vr) | 0, Mt = Mt + Math.imul(Gt, Kr) | 0, St = St + Math.imul(Gt, vr) | 0, ct = ct + Math.imul(ur, Jr) | 0, Mt = Mt + Math.imul(ur, xr) | 0, Mt = Mt + Math.imul(er, Jr) | 0, St = St + Math.imul(er, xr) | 0, ct = ct + Math.imul(Xt, Dr) | 0, Mt = Mt + Math.imul(Xt, fr) | 0, Mt = Mt + Math.imul(zt, Dr) | 0, St = St + Math.imul(zt, fr) | 0, ct = ct + Math.imul(Nt, Fr) | 0, Mt = Mt + Math.imul(Nt, qr) | 0, Mt = Mt + Math.imul(qt, Fr) | 0, St = St + Math.imul(qt, qr) | 0;
      var Ur = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, ct = Math.imul(ar, Lr), Mt = Math.imul(ar, br), Mt = Mt + Math.imul(Yt, Lr) | 0, St = Math.imul(Yt, br), ct = ct + Math.imul(It, Xr) | 0, Mt = Mt + Math.imul(It, yr) | 0, Mt = Mt + Math.imul(jt, Xr) | 0, St = St + Math.imul(jt, yr) | 0, ct = ct + Math.imul(Zr, Yr) | 0, Mt = Mt + Math.imul(Zr, wr) | 0, Mt = Mt + Math.imul(Bt, Yr) | 0, St = St + Math.imul(Bt, wr) | 0, ct = ct + Math.imul(Nr, Hr) | 0, Mt = Mt + Math.imul(Nr, $r) | 0, Mt = Mt + Math.imul(dr, Hr) | 0, St = St + Math.imul(dr, $r) | 0, ct = ct + Math.imul(Br, Wr) | 0, Mt = Mt + Math.imul(Br, mr) | 0, Mt = Mt + Math.imul(or, Wr) | 0, St = St + Math.imul(or, mr) | 0, ct = ct + Math.imul(sr, Kr) | 0, Mt = Mt + Math.imul(sr, vr) | 0, Mt = Mt + Math.imul(Jt, Kr) | 0, St = St + Math.imul(Jt, vr) | 0, ct = ct + Math.imul(Ht, Jr) | 0, Mt = Mt + Math.imul(Ht, xr) | 0, Mt = Mt + Math.imul(Gt, Jr) | 0, St = St + Math.imul(Gt, xr) | 0, ct = ct + Math.imul(ur, Dr) | 0, Mt = Mt + Math.imul(ur, fr) | 0, Mt = Mt + Math.imul(er, Dr) | 0, St = St + Math.imul(er, fr) | 0, ct = ct + Math.imul(Xt, Fr) | 0, Mt = Mt + Math.imul(Xt, qr) | 0, Mt = Mt + Math.imul(zt, Fr) | 0, St = St + Math.imul(zt, qr) | 0;
      var jr = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, ct = Math.imul(ar, Xr), Mt = Math.imul(ar, yr), Mt = Mt + Math.imul(Yt, Xr) | 0, St = Math.imul(Yt, yr), ct = ct + Math.imul(It, Yr) | 0, Mt = Mt + Math.imul(It, wr) | 0, Mt = Mt + Math.imul(jt, Yr) | 0, St = St + Math.imul(jt, wr) | 0, ct = ct + Math.imul(Zr, Hr) | 0, Mt = Mt + Math.imul(Zr, $r) | 0, Mt = Mt + Math.imul(Bt, Hr) | 0, St = St + Math.imul(Bt, $r) | 0, ct = ct + Math.imul(Nr, Wr) | 0, Mt = Mt + Math.imul(Nr, mr) | 0, Mt = Mt + Math.imul(dr, Wr) | 0, St = St + Math.imul(dr, mr) | 0, ct = ct + Math.imul(Br, Kr) | 0, Mt = Mt + Math.imul(Br, vr) | 0, Mt = Mt + Math.imul(or, Kr) | 0, St = St + Math.imul(or, vr) | 0, ct = ct + Math.imul(sr, Jr) | 0, Mt = Mt + Math.imul(sr, xr) | 0, Mt = Mt + Math.imul(Jt, Jr) | 0, St = St + Math.imul(Jt, xr) | 0, ct = ct + Math.imul(Ht, Dr) | 0, Mt = Mt + Math.imul(Ht, fr) | 0, Mt = Mt + Math.imul(Gt, Dr) | 0, St = St + Math.imul(Gt, fr) | 0, ct = ct + Math.imul(ur, Fr) | 0, Mt = Mt + Math.imul(ur, qr) | 0, Mt = Mt + Math.imul(er, Fr) | 0, St = St + Math.imul(er, qr) | 0;
      var Gr = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, ct = Math.imul(ar, Yr), Mt = Math.imul(ar, wr), Mt = Mt + Math.imul(Yt, Yr) | 0, St = Math.imul(Yt, wr), ct = ct + Math.imul(It, Hr) | 0, Mt = Mt + Math.imul(It, $r) | 0, Mt = Mt + Math.imul(jt, Hr) | 0, St = St + Math.imul(jt, $r) | 0, ct = ct + Math.imul(Zr, Wr) | 0, Mt = Mt + Math.imul(Zr, mr) | 0, Mt = Mt + Math.imul(Bt, Wr) | 0, St = St + Math.imul(Bt, mr) | 0, ct = ct + Math.imul(Nr, Kr) | 0, Mt = Mt + Math.imul(Nr, vr) | 0, Mt = Mt + Math.imul(dr, Kr) | 0, St = St + Math.imul(dr, vr) | 0, ct = ct + Math.imul(Br, Jr) | 0, Mt = Mt + Math.imul(Br, xr) | 0, Mt = Mt + Math.imul(or, Jr) | 0, St = St + Math.imul(or, xr) | 0, ct = ct + Math.imul(sr, Dr) | 0, Mt = Mt + Math.imul(sr, fr) | 0, Mt = Mt + Math.imul(Jt, Dr) | 0, St = St + Math.imul(Jt, fr) | 0, ct = ct + Math.imul(Ht, Fr) | 0, Mt = Mt + Math.imul(Ht, qr) | 0, Mt = Mt + Math.imul(Gt, Fr) | 0, St = St + Math.imul(Gt, qr) | 0;
      var Vr = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, ct = Math.imul(ar, Hr), Mt = Math.imul(ar, $r), Mt = Mt + Math.imul(Yt, Hr) | 0, St = Math.imul(Yt, $r), ct = ct + Math.imul(It, Wr) | 0, Mt = Mt + Math.imul(It, mr) | 0, Mt = Mt + Math.imul(jt, Wr) | 0, St = St + Math.imul(jt, mr) | 0, ct = ct + Math.imul(Zr, Kr) | 0, Mt = Mt + Math.imul(Zr, vr) | 0, Mt = Mt + Math.imul(Bt, Kr) | 0, St = St + Math.imul(Bt, vr) | 0, ct = ct + Math.imul(Nr, Jr) | 0, Mt = Mt + Math.imul(Nr, xr) | 0, Mt = Mt + Math.imul(dr, Jr) | 0, St = St + Math.imul(dr, xr) | 0, ct = ct + Math.imul(Br, Dr) | 0, Mt = Mt + Math.imul(Br, fr) | 0, Mt = Mt + Math.imul(or, Dr) | 0, St = St + Math.imul(or, fr) | 0, ct = ct + Math.imul(sr, Fr) | 0, Mt = Mt + Math.imul(sr, qr) | 0, Mt = Mt + Math.imul(Jt, Fr) | 0, St = St + Math.imul(Jt, qr) | 0;
      var rn = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, ct = Math.imul(ar, Wr), Mt = Math.imul(ar, mr), Mt = Mt + Math.imul(Yt, Wr) | 0, St = Math.imul(Yt, mr), ct = ct + Math.imul(It, Kr) | 0, Mt = Mt + Math.imul(It, vr) | 0, Mt = Mt + Math.imul(jt, Kr) | 0, St = St + Math.imul(jt, vr) | 0, ct = ct + Math.imul(Zr, Jr) | 0, Mt = Mt + Math.imul(Zr, xr) | 0, Mt = Mt + Math.imul(Bt, Jr) | 0, St = St + Math.imul(Bt, xr) | 0, ct = ct + Math.imul(Nr, Dr) | 0, Mt = Mt + Math.imul(Nr, fr) | 0, Mt = Mt + Math.imul(dr, Dr) | 0, St = St + Math.imul(dr, fr) | 0, ct = ct + Math.imul(Br, Fr) | 0, Mt = Mt + Math.imul(Br, qr) | 0, Mt = Mt + Math.imul(or, Fr) | 0, St = St + Math.imul(or, qr) | 0;
      var an = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, ct = Math.imul(ar, Kr), Mt = Math.imul(ar, vr), Mt = Mt + Math.imul(Yt, Kr) | 0, St = Math.imul(Yt, vr), ct = ct + Math.imul(It, Jr) | 0, Mt = Mt + Math.imul(It, xr) | 0, Mt = Mt + Math.imul(jt, Jr) | 0, St = St + Math.imul(jt, xr) | 0, ct = ct + Math.imul(Zr, Dr) | 0, Mt = Mt + Math.imul(Zr, fr) | 0, Mt = Mt + Math.imul(Bt, Dr) | 0, St = St + Math.imul(Bt, fr) | 0, ct = ct + Math.imul(Nr, Fr) | 0, Mt = Mt + Math.imul(Nr, qr) | 0, Mt = Mt + Math.imul(dr, Fr) | 0, St = St + Math.imul(dr, qr) | 0;
      var ln = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, ct = Math.imul(ar, Jr), Mt = Math.imul(ar, xr), Mt = Mt + Math.imul(Yt, Jr) | 0, St = Math.imul(Yt, xr), ct = ct + Math.imul(It, Dr) | 0, Mt = Mt + Math.imul(It, fr) | 0, Mt = Mt + Math.imul(jt, Dr) | 0, St = St + Math.imul(jt, fr) | 0, ct = ct + Math.imul(Zr, Fr) | 0, Mt = Mt + Math.imul(Zr, qr) | 0, Mt = Mt + Math.imul(Bt, Fr) | 0, St = St + Math.imul(Bt, qr) | 0;
      var sn = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, ct = Math.imul(ar, Dr), Mt = Math.imul(ar, fr), Mt = Mt + Math.imul(Yt, Dr) | 0, St = Math.imul(Yt, fr), ct = ct + Math.imul(It, Fr) | 0, Mt = Mt + Math.imul(It, qr) | 0, Mt = Mt + Math.imul(jt, Fr) | 0, St = St + Math.imul(jt, qr) | 0;
      var hn = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (hn >>> 26) | 0, hn &= 67108863, ct = Math.imul(ar, Fr), Mt = Math.imul(ar, qr), Mt = Mt + Math.imul(Yt, Fr) | 0, St = Math.imul(Yt, qr);
      var pn = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      return Ge = (St + (Mt >>> 13) | 0) + (pn >>> 26) | 0, pn &= 67108863, pt[0] = tn, pt[1] = Qr, pt[2] = nn, pt[3] = Er, pt[4] = Wt, pt[5] = nr, pt[6] = pr, pt[7] = Pr, pt[8] = Sr, pt[9] = Ur, pt[10] = jr, pt[11] = Gr, pt[12] = Vr, pt[13] = rn, pt[14] = an, pt[15] = ln, pt[16] = sn, pt[17] = hn, pt[18] = pn, Ge !== 0 && (pt[19] = Ge, ft.length++), ft;
    };
    Math.imul || (Tt = Et);
    function Rt(Xe, rt, ot) {
      ot.negative = rt.negative ^ Xe.negative, ot.length = Xe.length + rt.length;
      for (var ft = 0, mt = 0, yt = 0; yt < ot.length - 1; yt++) {
        var pt = mt;
        mt = 0;
        for (var Ge = ft & 67108863, ct = Math.min(yt, rt.length - 1), Mt = Math.max(0, yt - Xe.length + 1); Mt <= ct; Mt++) {
          var St = yt - Mt, At = Xe.words[St] | 0, Nt = rt.words[Mt] | 0, qt = At * Nt, Qt = qt & 67108863;
          pt = pt + (qt / 67108864 | 0) | 0, Qt = Qt + Ge | 0, Ge = Qt & 67108863, pt = pt + (Qt >>> 26) | 0, mt += pt >>> 26, pt &= 67108863;
        }
        ot.words[yt] = Ge, ft = pt, pt = mt;
      }
      return ft !== 0 ? ot.words[yt] = ft : ot.length--, ot._strip();
    }
    function Ct(Xe, rt, ot) {
      return Rt(Xe, rt, ot);
    }
    Ve.prototype.mulTo = function(rt, ot) {
      var ft, mt = (this || _global$7$1).length + rt.length;
      return (this || _global$7$1).length === 10 && rt.length === 10 ? ft = Tt(this || _global$7$1, rt, ot) : mt < 63 ? ft = Et(this || _global$7$1, rt, ot) : mt < 1024 ? ft = Rt(this || _global$7$1, rt, ot) : ft = Ct(this || _global$7$1, rt, ot), ft;
    }, Ve.prototype.mul = function(rt) {
      var ot = new Ve(null);
      return ot.words = new Array((this || _global$7$1).length + rt.length), this.mulTo(rt, ot);
    }, Ve.prototype.mulf = function(rt) {
      var ot = new Ve(null);
      return ot.words = new Array((this || _global$7$1).length + rt.length), Ct(this || _global$7$1, rt, ot);
    }, Ve.prototype.imul = function(rt) {
      return this.clone().mulTo(rt, this || _global$7$1);
    }, Ve.prototype.imuln = function(rt) {
      var ot = rt < 0;
      ot && (rt = -rt), Fe(typeof rt == "number"), Fe(rt < 67108864);
      for (var ft = 0, mt = 0; mt < (this || _global$7$1).length; mt++) {
        var yt = ((this || _global$7$1).words[mt] | 0) * rt, pt = (yt & 67108863) + (ft & 67108863);
        ft >>= 26, ft += yt / 67108864 | 0, ft += pt >>> 26, (this || _global$7$1).words[mt] = pt & 67108863;
      }
      return ft !== 0 && ((this || _global$7$1).words[mt] = ft, (this || _global$7$1).length++), ot ? this.ineg() : this || _global$7$1;
    }, Ve.prototype.muln = function(rt) {
      return this.clone().imuln(rt);
    }, Ve.prototype.sqr = function() {
      return this.mul(this || _global$7$1);
    }, Ve.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Ve.prototype.pow = function(rt) {
      var ot = xt(rt);
      if (ot.length === 0)
        return new Ve(1);
      for (var ft = this || _global$7$1, mt = 0; mt < ot.length && ot[mt] === 0; mt++, ft = ft.sqr())
        ;
      if (++mt < ot.length)
        for (var yt = ft.sqr(); mt < ot.length; mt++, yt = yt.sqr())
          ot[mt] !== 0 && (ft = ft.mul(yt));
      return ft;
    }, Ve.prototype.iushln = function(rt) {
      Fe(typeof rt == "number" && rt >= 0);
      var ot = rt % 26, ft = (rt - ot) / 26, mt = 67108863 >>> 26 - ot << 26 - ot, yt;
      if (ot !== 0) {
        var pt = 0;
        for (yt = 0; yt < (this || _global$7$1).length; yt++) {
          var Ge = (this || _global$7$1).words[yt] & mt, ct = ((this || _global$7$1).words[yt] | 0) - Ge << ot;
          (this || _global$7$1).words[yt] = ct | pt, pt = Ge >>> 26 - ot;
        }
        pt && ((this || _global$7$1).words[yt] = pt, (this || _global$7$1).length++);
      }
      if (ft !== 0) {
        for (yt = (this || _global$7$1).length - 1; yt >= 0; yt--)
          (this || _global$7$1).words[yt + ft] = (this || _global$7$1).words[yt];
        for (yt = 0; yt < ft; yt++)
          (this || _global$7$1).words[yt] = 0;
        (this || _global$7$1).length += ft;
      }
      return this._strip();
    }, Ve.prototype.ishln = function(rt) {
      return Fe((this || _global$7$1).negative === 0), this.iushln(rt);
    }, Ve.prototype.iushrn = function(rt, ot, ft) {
      Fe(typeof rt == "number" && rt >= 0);
      var mt;
      ot ? mt = (ot - ot % 26) / 26 : mt = 0;
      var yt = rt % 26, pt = Math.min((rt - yt) / 26, (this || _global$7$1).length), Ge = 67108863 ^ 67108863 >>> yt << yt, ct = ft;
      if (mt -= pt, mt = Math.max(0, mt), ct) {
        for (var Mt = 0; Mt < pt; Mt++)
          ct.words[Mt] = (this || _global$7$1).words[Mt];
        ct.length = pt;
      }
      if (pt !== 0)
        if ((this || _global$7$1).length > pt)
          for ((this || _global$7$1).length -= pt, Mt = 0; Mt < (this || _global$7$1).length; Mt++)
            (this || _global$7$1).words[Mt] = (this || _global$7$1).words[Mt + pt];
        else
          (this || _global$7$1).words[0] = 0, (this || _global$7$1).length = 1;
      var St = 0;
      for (Mt = (this || _global$7$1).length - 1; Mt >= 0 && (St !== 0 || Mt >= mt); Mt--) {
        var At = (this || _global$7$1).words[Mt] | 0;
        (this || _global$7$1).words[Mt] = St << 26 - yt | At >>> yt, St = At & Ge;
      }
      return ct && St !== 0 && (ct.words[ct.length++] = St), (this || _global$7$1).length === 0 && ((this || _global$7$1).words[0] = 0, (this || _global$7$1).length = 1), this._strip();
    }, Ve.prototype.ishrn = function(rt, ot, ft) {
      return Fe((this || _global$7$1).negative === 0), this.iushrn(rt, ot, ft);
    }, Ve.prototype.shln = function(rt) {
      return this.clone().ishln(rt);
    }, Ve.prototype.ushln = function(rt) {
      return this.clone().iushln(rt);
    }, Ve.prototype.shrn = function(rt) {
      return this.clone().ishrn(rt);
    }, Ve.prototype.ushrn = function(rt) {
      return this.clone().iushrn(rt);
    }, Ve.prototype.testn = function(rt) {
      Fe(typeof rt == "number" && rt >= 0);
      var ot = rt % 26, ft = (rt - ot) / 26, mt = 1 << ot;
      if ((this || _global$7$1).length <= ft)
        return !1;
      var yt = (this || _global$7$1).words[ft];
      return !!(yt & mt);
    }, Ve.prototype.imaskn = function(rt) {
      Fe(typeof rt == "number" && rt >= 0);
      var ot = rt % 26, ft = (rt - ot) / 26;
      if (Fe((this || _global$7$1).negative === 0, "imaskn works only with positive numbers"), (this || _global$7$1).length <= ft)
        return this || _global$7$1;
      if (ot !== 0 && ft++, (this || _global$7$1).length = Math.min(ft, (this || _global$7$1).length), ot !== 0) {
        var mt = 67108863 ^ 67108863 >>> ot << ot;
        (this || _global$7$1).words[(this || _global$7$1).length - 1] &= mt;
      }
      return this._strip();
    }, Ve.prototype.maskn = function(rt) {
      return this.clone().imaskn(rt);
    }, Ve.prototype.iaddn = function(rt) {
      return Fe(typeof rt == "number"), Fe(rt < 67108864), rt < 0 ? this.isubn(-rt) : (this || _global$7$1).negative !== 0 ? (this || _global$7$1).length === 1 && ((this || _global$7$1).words[0] | 0) <= rt ? ((this || _global$7$1).words[0] = rt - ((this || _global$7$1).words[0] | 0), (this || _global$7$1).negative = 0, this || _global$7$1) : ((this || _global$7$1).negative = 0, this.isubn(rt), (this || _global$7$1).negative = 1, this || _global$7$1) : this._iaddn(rt);
    }, Ve.prototype._iaddn = function(rt) {
      (this || _global$7$1).words[0] += rt;
      for (var ot = 0; ot < (this || _global$7$1).length && (this || _global$7$1).words[ot] >= 67108864; ot++)
        (this || _global$7$1).words[ot] -= 67108864, ot === (this || _global$7$1).length - 1 ? (this || _global$7$1).words[ot + 1] = 1 : (this || _global$7$1).words[ot + 1]++;
      return (this || _global$7$1).length = Math.max((this || _global$7$1).length, ot + 1), this || _global$7$1;
    }, Ve.prototype.isubn = function(rt) {
      if (Fe(typeof rt == "number"), Fe(rt < 67108864), rt < 0)
        return this.iaddn(-rt);
      if ((this || _global$7$1).negative !== 0)
        return (this || _global$7$1).negative = 0, this.iaddn(rt), (this || _global$7$1).negative = 1, this || _global$7$1;
      if ((this || _global$7$1).words[0] -= rt, (this || _global$7$1).length === 1 && (this || _global$7$1).words[0] < 0)
        (this || _global$7$1).words[0] = -(this || _global$7$1).words[0], (this || _global$7$1).negative = 1;
      else
        for (var ot = 0; ot < (this || _global$7$1).length && (this || _global$7$1).words[ot] < 0; ot++)
          (this || _global$7$1).words[ot] += 67108864, (this || _global$7$1).words[ot + 1] -= 1;
      return this._strip();
    }, Ve.prototype.addn = function(rt) {
      return this.clone().iaddn(rt);
    }, Ve.prototype.subn = function(rt) {
      return this.clone().isubn(rt);
    }, Ve.prototype.iabs = function() {
      return (this || _global$7$1).negative = 0, this || _global$7$1;
    }, Ve.prototype.abs = function() {
      return this.clone().iabs();
    }, Ve.prototype._ishlnsubmul = function(rt, ot, ft) {
      var mt = rt.length + ft, yt;
      this._expand(mt);
      var pt, Ge = 0;
      for (yt = 0; yt < rt.length; yt++) {
        pt = ((this || _global$7$1).words[yt + ft] | 0) + Ge;
        var ct = (rt.words[yt] | 0) * ot;
        pt -= ct & 67108863, Ge = (pt >> 26) - (ct / 67108864 | 0), (this || _global$7$1).words[yt + ft] = pt & 67108863;
      }
      for (; yt < (this || _global$7$1).length - ft; yt++)
        pt = ((this || _global$7$1).words[yt + ft] | 0) + Ge, Ge = pt >> 26, (this || _global$7$1).words[yt + ft] = pt & 67108863;
      if (Ge === 0)
        return this._strip();
      for (Fe(Ge === -1), Ge = 0, yt = 0; yt < (this || _global$7$1).length; yt++)
        pt = -((this || _global$7$1).words[yt] | 0) + Ge, Ge = pt >> 26, (this || _global$7$1).words[yt] = pt & 67108863;
      return (this || _global$7$1).negative = 1, this._strip();
    }, Ve.prototype._wordDiv = function(rt, ot) {
      var ft = (this || _global$7$1).length - rt.length, mt = this.clone(), yt = rt, pt = yt.words[yt.length - 1] | 0, Ge = this._countBits(pt);
      ft = 26 - Ge, ft !== 0 && (yt = yt.ushln(ft), mt.iushln(ft), pt = yt.words[yt.length - 1] | 0);
      var ct = mt.length - yt.length, Mt;
      if (ot !== "mod") {
        Mt = new Ve(null), Mt.length = ct + 1, Mt.words = new Array(Mt.length);
        for (var St = 0; St < Mt.length; St++)
          Mt.words[St] = 0;
      }
      var At = mt.clone()._ishlnsubmul(yt, 1, ct);
      At.negative === 0 && (mt = At, Mt && (Mt.words[ct] = 1));
      for (var Nt = ct - 1; Nt >= 0; Nt--) {
        var qt = (mt.words[yt.length + Nt] | 0) * 67108864 + (mt.words[yt.length + Nt - 1] | 0);
        for (qt = Math.min(qt / pt | 0, 67108863), mt._ishlnsubmul(yt, qt, Nt); mt.negative !== 0; )
          qt--, mt.negative = 0, mt._ishlnsubmul(yt, 1, Nt), mt.isZero() || (mt.negative ^= 1);
        Mt && (Mt.words[Nt] = qt);
      }
      return Mt && Mt._strip(), mt._strip(), ot !== "div" && ft !== 0 && mt.iushrn(ft), {
        div: Mt || null,
        mod: mt
      };
    }, Ve.prototype.divmod = function(rt, ot, ft) {
      if (Fe(!rt.isZero()), this.isZero())
        return {
          div: new Ve(0),
          mod: new Ve(0)
        };
      var mt, yt, pt;
      return (this || _global$7$1).negative !== 0 && rt.negative === 0 ? (pt = this.neg().divmod(rt, ot), ot !== "mod" && (mt = pt.div.neg()), ot !== "div" && (yt = pt.mod.neg(), ft && yt.negative !== 0 && yt.iadd(rt)), {
        div: mt,
        mod: yt
      }) : (this || _global$7$1).negative === 0 && rt.negative !== 0 ? (pt = this.divmod(rt.neg(), ot), ot !== "mod" && (mt = pt.div.neg()), {
        div: mt,
        mod: pt.mod
      }) : (this || _global$7$1).negative & rt.negative ? (pt = this.neg().divmod(rt.neg(), ot), ot !== "div" && (yt = pt.mod.neg(), ft && yt.negative !== 0 && yt.isub(rt)), {
        div: pt.div,
        mod: yt
      }) : rt.length > (this || _global$7$1).length || this.cmp(rt) < 0 ? {
        div: new Ve(0),
        mod: this || _global$7$1
      } : rt.length === 1 ? ot === "div" ? {
        div: this.divn(rt.words[0]),
        mod: null
      } : ot === "mod" ? {
        div: null,
        mod: new Ve(this.modrn(rt.words[0]))
      } : {
        div: this.divn(rt.words[0]),
        mod: new Ve(this.modrn(rt.words[0]))
      } : this._wordDiv(rt, ot);
    }, Ve.prototype.div = function(rt) {
      return this.divmod(rt, "div", !1).div;
    }, Ve.prototype.mod = function(rt) {
      return this.divmod(rt, "mod", !1).mod;
    }, Ve.prototype.umod = function(rt) {
      return this.divmod(rt, "mod", !0).mod;
    }, Ve.prototype.divRound = function(rt) {
      var ot = this.divmod(rt);
      if (ot.mod.isZero())
        return ot.div;
      var ft = ot.div.negative !== 0 ? ot.mod.isub(rt) : ot.mod, mt = rt.ushrn(1), yt = rt.andln(1), pt = ft.cmp(mt);
      return pt < 0 || yt === 1 && pt === 0 ? ot.div : ot.div.negative !== 0 ? ot.div.isubn(1) : ot.div.iaddn(1);
    }, Ve.prototype.modrn = function(rt) {
      var ot = rt < 0;
      ot && (rt = -rt), Fe(rt <= 67108863);
      for (var ft = (1 << 26) % rt, mt = 0, yt = (this || _global$7$1).length - 1; yt >= 0; yt--)
        mt = (ft * mt + ((this || _global$7$1).words[yt] | 0)) % rt;
      return ot ? -mt : mt;
    }, Ve.prototype.modn = function(rt) {
      return this.modrn(rt);
    }, Ve.prototype.idivn = function(rt) {
      var ot = rt < 0;
      ot && (rt = -rt), Fe(rt <= 67108863);
      for (var ft = 0, mt = (this || _global$7$1).length - 1; mt >= 0; mt--) {
        var yt = ((this || _global$7$1).words[mt] | 0) + ft * 67108864;
        (this || _global$7$1).words[mt] = yt / rt | 0, ft = yt % rt;
      }
      return this._strip(), ot ? this.ineg() : this || _global$7$1;
    }, Ve.prototype.divn = function(rt) {
      return this.clone().idivn(rt);
    }, Ve.prototype.egcd = function(rt) {
      Fe(rt.negative === 0), Fe(!rt.isZero());
      var ot = this || _global$7$1, ft = rt.clone();
      ot.negative !== 0 ? ot = ot.umod(rt) : ot = ot.clone();
      for (var mt = new Ve(1), yt = new Ve(0), pt = new Ve(0), Ge = new Ve(1), ct = 0; ot.isEven() && ft.isEven(); )
        ot.iushrn(1), ft.iushrn(1), ++ct;
      for (var Mt = ft.clone(), St = ot.clone(); !ot.isZero(); ) {
        for (var At = 0, Nt = 1; !(ot.words[0] & Nt) && At < 26; ++At, Nt <<= 1)
          ;
        if (At > 0)
          for (ot.iushrn(At); At-- > 0; )
            (mt.isOdd() || yt.isOdd()) && (mt.iadd(Mt), yt.isub(St)), mt.iushrn(1), yt.iushrn(1);
        for (var qt = 0, Qt = 1; !(ft.words[0] & Qt) && qt < 26; ++qt, Qt <<= 1)
          ;
        if (qt > 0)
          for (ft.iushrn(qt); qt-- > 0; )
            (pt.isOdd() || Ge.isOdd()) && (pt.iadd(Mt), Ge.isub(St)), pt.iushrn(1), Ge.iushrn(1);
        ot.cmp(ft) >= 0 ? (ot.isub(ft), mt.isub(pt), yt.isub(Ge)) : (ft.isub(ot), pt.isub(mt), Ge.isub(yt));
      }
      return {
        a: pt,
        b: Ge,
        gcd: ft.iushln(ct)
      };
    }, Ve.prototype._invmp = function(rt) {
      Fe(rt.negative === 0), Fe(!rt.isZero());
      var ot = this || _global$7$1, ft = rt.clone();
      ot.negative !== 0 ? ot = ot.umod(rt) : ot = ot.clone();
      for (var mt = new Ve(1), yt = new Ve(0), pt = ft.clone(); ot.cmpn(1) > 0 && ft.cmpn(1) > 0; ) {
        for (var Ge = 0, ct = 1; !(ot.words[0] & ct) && Ge < 26; ++Ge, ct <<= 1)
          ;
        if (Ge > 0)
          for (ot.iushrn(Ge); Ge-- > 0; )
            mt.isOdd() && mt.iadd(pt), mt.iushrn(1);
        for (var Mt = 0, St = 1; !(ft.words[0] & St) && Mt < 26; ++Mt, St <<= 1)
          ;
        if (Mt > 0)
          for (ft.iushrn(Mt); Mt-- > 0; )
            yt.isOdd() && yt.iadd(pt), yt.iushrn(1);
        ot.cmp(ft) >= 0 ? (ot.isub(ft), mt.isub(yt)) : (ft.isub(ot), yt.isub(mt));
      }
      var At;
      return ot.cmpn(1) === 0 ? At = mt : At = yt, At.cmpn(0) < 0 && At.iadd(rt), At;
    }, Ve.prototype.gcd = function(rt) {
      if (this.isZero())
        return rt.abs();
      if (rt.isZero())
        return this.abs();
      var ot = this.clone(), ft = rt.clone();
      ot.negative = 0, ft.negative = 0;
      for (var mt = 0; ot.isEven() && ft.isEven(); mt++)
        ot.iushrn(1), ft.iushrn(1);
      do {
        for (; ot.isEven(); )
          ot.iushrn(1);
        for (; ft.isEven(); )
          ft.iushrn(1);
        var yt = ot.cmp(ft);
        if (yt < 0) {
          var pt = ot;
          ot = ft, ft = pt;
        } else if (yt === 0 || ft.cmpn(1) === 0)
          break;
        ot.isub(ft);
      } while (!0);
      return ft.iushln(mt);
    }, Ve.prototype.invm = function(rt) {
      return this.egcd(rt).a.umod(rt);
    }, Ve.prototype.isEven = function() {
      return ((this || _global$7$1).words[0] & 1) === 0;
    }, Ve.prototype.isOdd = function() {
      return ((this || _global$7$1).words[0] & 1) === 1;
    }, Ve.prototype.andln = function(rt) {
      return (this || _global$7$1).words[0] & rt;
    }, Ve.prototype.bincn = function(rt) {
      Fe(typeof rt == "number");
      var ot = rt % 26, ft = (rt - ot) / 26, mt = 1 << ot;
      if ((this || _global$7$1).length <= ft)
        return this._expand(ft + 1), (this || _global$7$1).words[ft] |= mt, this || _global$7$1;
      for (var yt = mt, pt = ft; yt !== 0 && pt < (this || _global$7$1).length; pt++) {
        var Ge = (this || _global$7$1).words[pt] | 0;
        Ge += yt, yt = Ge >>> 26, Ge &= 67108863, (this || _global$7$1).words[pt] = Ge;
      }
      return yt !== 0 && ((this || _global$7$1).words[pt] = yt, (this || _global$7$1).length++), this || _global$7$1;
    }, Ve.prototype.isZero = function() {
      return (this || _global$7$1).length === 1 && (this || _global$7$1).words[0] === 0;
    }, Ve.prototype.cmpn = function(rt) {
      var ot = rt < 0;
      if ((this || _global$7$1).negative !== 0 && !ot)
        return -1;
      if ((this || _global$7$1).negative === 0 && ot)
        return 1;
      this._strip();
      var ft;
      if ((this || _global$7$1).length > 1)
        ft = 1;
      else {
        ot && (rt = -rt), Fe(rt <= 67108863, "Number is too big");
        var mt = (this || _global$7$1).words[0] | 0;
        ft = mt === rt ? 0 : mt < rt ? -1 : 1;
      }
      return (this || _global$7$1).negative !== 0 ? -ft | 0 : ft;
    }, Ve.prototype.cmp = function(rt) {
      if ((this || _global$7$1).negative !== 0 && rt.negative === 0)
        return -1;
      if ((this || _global$7$1).negative === 0 && rt.negative !== 0)
        return 1;
      var ot = this.ucmp(rt);
      return (this || _global$7$1).negative !== 0 ? -ot | 0 : ot;
    }, Ve.prototype.ucmp = function(rt) {
      if ((this || _global$7$1).length > rt.length)
        return 1;
      if ((this || _global$7$1).length < rt.length)
        return -1;
      for (var ot = 0, ft = (this || _global$7$1).length - 1; ft >= 0; ft--) {
        var mt = (this || _global$7$1).words[ft] | 0, yt = rt.words[ft] | 0;
        if (mt !== yt) {
          mt < yt ? ot = -1 : mt > yt && (ot = 1);
          break;
        }
      }
      return ot;
    }, Ve.prototype.gtn = function(rt) {
      return this.cmpn(rt) === 1;
    }, Ve.prototype.gt = function(rt) {
      return this.cmp(rt) === 1;
    }, Ve.prototype.gten = function(rt) {
      return this.cmpn(rt) >= 0;
    }, Ve.prototype.gte = function(rt) {
      return this.cmp(rt) >= 0;
    }, Ve.prototype.ltn = function(rt) {
      return this.cmpn(rt) === -1;
    }, Ve.prototype.lt = function(rt) {
      return this.cmp(rt) === -1;
    }, Ve.prototype.lten = function(rt) {
      return this.cmpn(rt) <= 0;
    }, Ve.prototype.lte = function(rt) {
      return this.cmp(rt) <= 0;
    }, Ve.prototype.eqn = function(rt) {
      return this.cmpn(rt) === 0;
    }, Ve.prototype.eq = function(rt) {
      return this.cmp(rt) === 0;
    }, Ve.red = function(rt) {
      return new gt(rt);
    }, Ve.prototype.toRed = function(rt) {
      return Fe(!(this || _global$7$1).red, "Already a number in reduction context"), Fe((this || _global$7$1).negative === 0, "red works only with positives"), rt.convertTo(this || _global$7$1)._forceRed(rt);
    }, Ve.prototype.fromRed = function() {
      return Fe((this || _global$7$1).red, "fromRed works only with numbers in reduction context"), (this || _global$7$1).red.convertFrom(this || _global$7$1);
    }, Ve.prototype._forceRed = function(rt) {
      return (this || _global$7$1).red = rt, this || _global$7$1;
    }, Ve.prototype.forceRed = function(rt) {
      return Fe(!(this || _global$7$1).red, "Already a number in reduction context"), this._forceRed(rt);
    }, Ve.prototype.redAdd = function(rt) {
      return Fe((this || _global$7$1).red, "redAdd works only with red numbers"), (this || _global$7$1).red.add(this || _global$7$1, rt);
    }, Ve.prototype.redIAdd = function(rt) {
      return Fe((this || _global$7$1).red, "redIAdd works only with red numbers"), (this || _global$7$1).red.iadd(this || _global$7$1, rt);
    }, Ve.prototype.redSub = function(rt) {
      return Fe((this || _global$7$1).red, "redSub works only with red numbers"), (this || _global$7$1).red.sub(this || _global$7$1, rt);
    }, Ve.prototype.redISub = function(rt) {
      return Fe((this || _global$7$1).red, "redISub works only with red numbers"), (this || _global$7$1).red.isub(this || _global$7$1, rt);
    }, Ve.prototype.redShl = function(rt) {
      return Fe((this || _global$7$1).red, "redShl works only with red numbers"), (this || _global$7$1).red.shl(this || _global$7$1, rt);
    }, Ve.prototype.redMul = function(rt) {
      return Fe((this || _global$7$1).red, "redMul works only with red numbers"), (this || _global$7$1).red._verify2(this || _global$7$1, rt), (this || _global$7$1).red.mul(this || _global$7$1, rt);
    }, Ve.prototype.redIMul = function(rt) {
      return Fe((this || _global$7$1).red, "redMul works only with red numbers"), (this || _global$7$1).red._verify2(this || _global$7$1, rt), (this || _global$7$1).red.imul(this || _global$7$1, rt);
    }, Ve.prototype.redSqr = function() {
      return Fe((this || _global$7$1).red, "redSqr works only with red numbers"), (this || _global$7$1).red._verify1(this || _global$7$1), (this || _global$7$1).red.sqr(this || _global$7$1);
    }, Ve.prototype.redISqr = function() {
      return Fe((this || _global$7$1).red, "redISqr works only with red numbers"), (this || _global$7$1).red._verify1(this || _global$7$1), (this || _global$7$1).red.isqr(this || _global$7$1);
    }, Ve.prototype.redSqrt = function() {
      return Fe((this || _global$7$1).red, "redSqrt works only with red numbers"), (this || _global$7$1).red._verify1(this || _global$7$1), (this || _global$7$1).red.sqrt(this || _global$7$1);
    }, Ve.prototype.redInvm = function() {
      return Fe((this || _global$7$1).red, "redInvm works only with red numbers"), (this || _global$7$1).red._verify1(this || _global$7$1), (this || _global$7$1).red.invm(this || _global$7$1);
    }, Ve.prototype.redNeg = function() {
      return Fe((this || _global$7$1).red, "redNeg works only with red numbers"), (this || _global$7$1).red._verify1(this || _global$7$1), (this || _global$7$1).red.neg(this || _global$7$1);
    }, Ve.prototype.redPow = function(rt) {
      return Fe((this || _global$7$1).red && !rt.red, "redPow(normalNum)"), (this || _global$7$1).red._verify1(this || _global$7$1), (this || _global$7$1).red.pow(this || _global$7$1, rt);
    };
    var Zt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Lt(Xe, rt) {
      (this || _global$7$1).name = Xe, (this || _global$7$1).p = new Ve(rt, 16), (this || _global$7$1).n = (this || _global$7$1).p.bitLength(), (this || _global$7$1).k = new Ve(1).iushln((this || _global$7$1).n).isub((this || _global$7$1).p), (this || _global$7$1).tmp = this._tmp();
    }
    Lt.prototype._tmp = function() {
      var rt = new Ve(null);
      return rt.words = new Array(Math.ceil((this || _global$7$1).n / 13)), rt;
    }, Lt.prototype.ireduce = function(rt) {
      var ot = rt, ft;
      do
        this.split(ot, (this || _global$7$1).tmp), ot = this.imulK(ot), ot = ot.iadd((this || _global$7$1).tmp), ft = ot.bitLength();
      while (ft > (this || _global$7$1).n);
      var mt = ft < (this || _global$7$1).n ? -1 : ot.ucmp((this || _global$7$1).p);
      return mt === 0 ? (ot.words[0] = 0, ot.length = 1) : mt > 0 ? ot.isub((this || _global$7$1).p) : ot.strip !== void 0 ? ot.strip() : ot._strip(), ot;
    }, Lt.prototype.split = function(rt, ot) {
      rt.iushrn((this || _global$7$1).n, 0, ot);
    }, Lt.prototype.imulK = function(rt) {
      return rt.imul((this || _global$7$1).k);
    };
    function Ut() {
      Lt.call(this || _global$7$1, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    Ke(Ut, Lt), Ut.prototype.split = function(rt, ot) {
      for (var ft = 4194303, mt = Math.min(rt.length, 9), yt = 0; yt < mt; yt++)
        ot.words[yt] = rt.words[yt];
      if (ot.length = mt, rt.length <= 9) {
        rt.words[0] = 0, rt.length = 1;
        return;
      }
      var pt = rt.words[9];
      for (ot.words[ot.length++] = pt & ft, yt = 10; yt < rt.length; yt++) {
        var Ge = rt.words[yt] | 0;
        rt.words[yt - 10] = (Ge & ft) << 4 | pt >>> 22, pt = Ge;
      }
      pt >>>= 22, rt.words[yt - 10] = pt, pt === 0 && rt.length > 10 ? rt.length -= 10 : rt.length -= 9;
    }, Ut.prototype.imulK = function(rt) {
      rt.words[rt.length] = 0, rt.words[rt.length + 1] = 0, rt.length += 2;
      for (var ot = 0, ft = 0; ft < rt.length; ft++) {
        var mt = rt.words[ft] | 0;
        ot += mt * 977, rt.words[ft] = ot & 67108863, ot = mt * 64 + (ot / 67108864 | 0);
      }
      return rt.words[rt.length - 1] === 0 && (rt.length--, rt.words[rt.length - 1] === 0 && rt.length--), rt;
    };
    function Pt() {
      Lt.call(this || _global$7$1, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    Ke(Pt, Lt);
    function Ot() {
      Lt.call(this || _global$7$1, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    Ke(Ot, Lt);
    function Ft() {
      Lt.call(this || _global$7$1, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    Ke(Ft, Lt), Ft.prototype.imulK = function(rt) {
      for (var ot = 0, ft = 0; ft < rt.length; ft++) {
        var mt = (rt.words[ft] | 0) * 19 + ot, yt = mt & 67108863;
        mt >>>= 26, rt.words[ft] = yt, ot = mt;
      }
      return ot !== 0 && (rt.words[rt.length++] = ot), rt;
    }, Ve._prime = function(rt) {
      if (Zt[rt])
        return Zt[rt];
      var ot;
      if (rt === "k256")
        ot = new Ut();
      else if (rt === "p224")
        ot = new Pt();
      else if (rt === "p192")
        ot = new Ot();
      else if (rt === "p25519")
        ot = new Ft();
      else
        throw new Error("Unknown prime " + rt);
      return Zt[rt] = ot, ot;
    };
    function gt(Xe) {
      if (typeof Xe == "string") {
        var rt = Ve._prime(Xe);
        (this || _global$7$1).m = rt.p, (this || _global$7$1).prime = rt;
      } else
        Fe(Xe.gtn(1), "modulus must be greater than 1"), (this || _global$7$1).m = Xe, (this || _global$7$1).prime = null;
    }
    gt.prototype._verify1 = function(rt) {
      Fe(rt.negative === 0, "red works only with positives"), Fe(rt.red, "red works only with red numbers");
    }, gt.prototype._verify2 = function(rt, ot) {
      Fe((rt.negative | ot.negative) === 0, "red works only with positives"), Fe(rt.red && rt.red === ot.red, "red works only with red numbers");
    }, gt.prototype.imod = function(rt) {
      return (this || _global$7$1).prime ? (this || _global$7$1).prime.ireduce(rt)._forceRed(this || _global$7$1) : (lt(rt, rt.umod((this || _global$7$1).m)._forceRed(this || _global$7$1)), rt);
    }, gt.prototype.neg = function(rt) {
      return rt.isZero() ? rt.clone() : (this || _global$7$1).m.sub(rt)._forceRed(this || _global$7$1);
    }, gt.prototype.add = function(rt, ot) {
      this._verify2(rt, ot);
      var ft = rt.add(ot);
      return ft.cmp((this || _global$7$1).m) >= 0 && ft.isub((this || _global$7$1).m), ft._forceRed(this || _global$7$1);
    }, gt.prototype.iadd = function(rt, ot) {
      this._verify2(rt, ot);
      var ft = rt.iadd(ot);
      return ft.cmp((this || _global$7$1).m) >= 0 && ft.isub((this || _global$7$1).m), ft;
    }, gt.prototype.sub = function(rt, ot) {
      this._verify2(rt, ot);
      var ft = rt.sub(ot);
      return ft.cmpn(0) < 0 && ft.iadd((this || _global$7$1).m), ft._forceRed(this || _global$7$1);
    }, gt.prototype.isub = function(rt, ot) {
      this._verify2(rt, ot);
      var ft = rt.isub(ot);
      return ft.cmpn(0) < 0 && ft.iadd((this || _global$7$1).m), ft;
    }, gt.prototype.shl = function(rt, ot) {
      return this._verify1(rt), this.imod(rt.ushln(ot));
    }, gt.prototype.imul = function(rt, ot) {
      return this._verify2(rt, ot), this.imod(rt.imul(ot));
    }, gt.prototype.mul = function(rt, ot) {
      return this._verify2(rt, ot), this.imod(rt.mul(ot));
    }, gt.prototype.isqr = function(rt) {
      return this.imul(rt, rt.clone());
    }, gt.prototype.sqr = function(rt) {
      return this.mul(rt, rt);
    }, gt.prototype.sqrt = function(rt) {
      if (rt.isZero())
        return rt.clone();
      var ot = (this || _global$7$1).m.andln(3);
      if (Fe(ot % 2 === 1), ot === 3) {
        var ft = (this || _global$7$1).m.add(new Ve(1)).iushrn(2);
        return this.pow(rt, ft);
      }
      for (var mt = (this || _global$7$1).m.subn(1), yt = 0; !mt.isZero() && mt.andln(1) === 0; )
        yt++, mt.iushrn(1);
      Fe(!mt.isZero());
      var pt = new Ve(1).toRed(this || _global$7$1), Ge = pt.redNeg(), ct = (this || _global$7$1).m.subn(1).iushrn(1), Mt = (this || _global$7$1).m.bitLength();
      for (Mt = new Ve(2 * Mt * Mt).toRed(this || _global$7$1); this.pow(Mt, ct).cmp(Ge) !== 0; )
        Mt.redIAdd(Ge);
      for (var St = this.pow(Mt, mt), At = this.pow(rt, mt.addn(1).iushrn(1)), Nt = this.pow(rt, mt), qt = yt; Nt.cmp(pt) !== 0; ) {
        for (var Qt = Nt, Xt = 0; Qt.cmp(pt) !== 0; Xt++)
          Qt = Qt.redSqr();
        Fe(Xt < qt);
        var zt = this.pow(St, new Ve(1).iushln(qt - Xt - 1));
        At = At.redMul(zt), St = zt.redSqr(), Nt = Nt.redMul(St), qt = Xt;
      }
      return At;
    }, gt.prototype.invm = function(rt) {
      var ot = rt._invmp((this || _global$7$1).m);
      return ot.negative !== 0 ? (ot.negative = 0, this.imod(ot).redNeg()) : this.imod(ot);
    }, gt.prototype.pow = function(rt, ot) {
      if (ot.isZero())
        return new Ve(1).toRed(this || _global$7$1);
      if (ot.cmpn(1) === 0)
        return rt.clone();
      var ft = 4, mt = new Array(1 << ft);
      mt[0] = new Ve(1).toRed(this || _global$7$1), mt[1] = rt;
      for (var yt = 2; yt < mt.length; yt++)
        mt[yt] = this.mul(mt[yt - 1], rt);
      var pt = mt[0], Ge = 0, ct = 0, Mt = ot.bitLength() % 26;
      for (Mt === 0 && (Mt = 26), yt = ot.length - 1; yt >= 0; yt--) {
        for (var St = ot.words[yt], At = Mt - 1; At >= 0; At--) {
          var Nt = St >> At & 1;
          if (pt !== mt[0] && (pt = this.sqr(pt)), Nt === 0 && Ge === 0) {
            ct = 0;
            continue;
          }
          Ge <<= 1, Ge |= Nt, ct++, !(ct !== ft && (yt !== 0 || At !== 0)) && (pt = this.mul(pt, mt[Ge]), ct = 0, Ge = 0);
        }
        Mt = 26;
      }
      return pt;
    }, gt.prototype.convertTo = function(rt) {
      var ot = rt.umod((this || _global$7$1).m);
      return ot === rt ? ot.clone() : ot;
    }, gt.prototype.convertFrom = function(rt) {
      var ot = rt.clone();
      return ot.red = null, ot;
    }, Ve.mont = function(rt) {
      return new We(rt);
    };
    function We(Xe) {
      gt.call(this || _global$7$1, Xe), (this || _global$7$1).shift = (this || _global$7$1).m.bitLength(), (this || _global$7$1).shift % 26 !== 0 && ((this || _global$7$1).shift += 26 - (this || _global$7$1).shift % 26), (this || _global$7$1).r = new Ve(1).iushln((this || _global$7$1).shift), (this || _global$7$1).r2 = this.imod((this || _global$7$1).r.sqr()), (this || _global$7$1).rinv = (this || _global$7$1).r._invmp((this || _global$7$1).m), (this || _global$7$1).minv = (this || _global$7$1).rinv.mul((this || _global$7$1).r).isubn(1).div((this || _global$7$1).m), (this || _global$7$1).minv = (this || _global$7$1).minv.umod((this || _global$7$1).r), (this || _global$7$1).minv = (this || _global$7$1).r.sub((this || _global$7$1).minv);
    }
    Ke(We, gt), We.prototype.convertTo = function(rt) {
      return this.imod(rt.ushln((this || _global$7$1).shift));
    }, We.prototype.convertFrom = function(rt) {
      var ot = this.imod(rt.mul((this || _global$7$1).rinv));
      return ot.red = null, ot;
    }, We.prototype.imul = function(rt, ot) {
      if (rt.isZero() || ot.isZero())
        return rt.words[0] = 0, rt.length = 1, rt;
      var ft = rt.imul(ot), mt = ft.maskn((this || _global$7$1).shift).mul((this || _global$7$1).minv).imaskn((this || _global$7$1).shift).mul((this || _global$7$1).m), yt = ft.isub(mt).iushrn((this || _global$7$1).shift), pt = yt;
      return yt.cmp((this || _global$7$1).m) >= 0 ? pt = yt.isub((this || _global$7$1).m) : yt.cmpn(0) < 0 && (pt = yt.iadd((this || _global$7$1).m)), pt._forceRed(this || _global$7$1);
    }, We.prototype.mul = function(rt, ot) {
      if (rt.isZero() || ot.isZero())
        return new Ve(0)._forceRed(this || _global$7$1);
      var ft = rt.mul(ot), mt = ft.maskn((this || _global$7$1).shift).mul((this || _global$7$1).minv).imaskn((this || _global$7$1).shift).mul((this || _global$7$1).m), yt = ft.isub(mt).iushrn((this || _global$7$1).shift), pt = yt;
      return yt.cmp((this || _global$7$1).m) >= 0 ? pt = yt.isub((this || _global$7$1).m) : yt.cmpn(0) < 0 && (pt = yt.iadd((this || _global$7$1).m)), pt._forceRed(this || _global$7$1);
    }, We.prototype.invm = function(rt) {
      var ot = this.imod(rt._invmp((this || _global$7$1).m).mul((this || _global$7$1).r2));
      return ot._forceRed(this || _global$7$1);
    };
  }(module$4$1, exports$X$1)), module$4$1.exports;
}
var exports$W$1 = {}, _dewExec$W$1 = !1;
function dew$W$1() {
  if (_dewExec$W$1)
    return exports$W$1;
  _dewExec$W$1 = !0;
  var $e = e$1$1$1.Buffer, Ze = dew$X$1(), Fe = dew$1S();
  function Ke(Qe) {
    var at = Ve(Qe), ut = at.toRed(Ze.mont(Qe.modulus)).redPow(new Ze(Qe.publicExponent)).fromRed();
    return {
      blinder: ut,
      unblinder: at.invm(Qe.modulus)
    };
  }
  function Ve(Qe) {
    var at = Qe.modulus.byteLength(), ut;
    do
      ut = new Ze(Fe(at));
    while (ut.cmp(Qe.modulus) >= 0 || !ut.umod(Qe.prime1) || !ut.umod(Qe.prime2));
    return ut;
  }
  function Je(Qe, at) {
    var ut = Ke(at), lt = at.modulus.byteLength(), dt = new Ze(Qe).mul(ut.blinder).umod(at.modulus), bt = dt.toRed(Ze.mont(at.prime1)), $t = dt.toRed(Ze.mont(at.prime2)), vt = at.coefficient, wt = at.prime1, xt = at.prime2, Et = bt.redPow(at.exponent1).fromRed(), Tt = $t.redPow(at.exponent2).fromRed(), Rt = Et.isub(Tt).imul(vt).umod(wt).imul(xt);
    return Tt.iadd(Rt).imul(ut.unblinder).umod(at.modulus).toArrayLike($e, "be", lt);
  }
  return Je.getr = Ve, exports$W$1 = Je, exports$W$1;
}
var _package$1 = {
  _args: [
    [
      "elliptic@6.5.4",
      "C:\\Users\\guybe\\Projects\\rollup-plugin-jspm"
    ]
  ],
  _from: "elliptic@6.5.4",
  _id: "elliptic@6.5.4",
  _inBundle: !1,
  _integrity: "sha512-iLhC6ULemrljPZb+QutR5TQGB+pdW6KGD5RSegS+8sorOZT+rdQFbsQFJgvN3eRqNALqJer4oQ16YvJHlU8hzQ==",
  _location: "/@jspm/core/elliptic",
  _phantomChildren: {},
  _requested: {
    type: "version",
    registry: !0,
    raw: "elliptic@6.5.4",
    name: "elliptic",
    escapedName: "elliptic",
    rawSpec: "6.5.4",
    saveSpec: null,
    fetchSpec: "6.5.4"
  },
  _requiredBy: [
    "/@jspm/core/browserify-sign",
    "/@jspm/core/create-ecdh"
  ],
  _resolved: "https://registry.npmjs.org/elliptic/-/elliptic-6.5.4.tgz",
  _spec: "6.5.4",
  _where: "C:\\Users\\guybe\\Projects\\rollup-plugin-jspm",
  author: {
    name: "Fedor Indutny",
    email: "fedor@indutny.com"
  },
  bugs: {
    url: "https://github.com/indutny/elliptic/issues"
  },
  dependencies: {
    "bn.js": "^4.11.9",
    brorand: "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    inherits: "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
  },
  description: "EC cryptography",
  devDependencies: {
    brfs: "^2.0.2",
    coveralls: "^3.1.0",
    eslint: "^7.6.0",
    grunt: "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    istanbul: "^0.4.5",
    mocha: "^8.0.1"
  },
  files: [
    "lib"
  ],
  homepage: "https://github.com/indutny/elliptic",
  keywords: [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  license: "MIT",
  main: "lib/elliptic.js",
  name: "elliptic",
  repository: {
    type: "git",
    url: "git+ssh://git@github.com/indutny/elliptic.git"
  },
  scripts: {
    lint: "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    test: "npm run lint && npm run unit",
    unit: "istanbul test _mocha --reporter=spec test/index.js",
    version: "grunt dist && git add dist/"
  },
  version: "6.5.4"
}, exports$V$1 = {}, _dewExec$V$1 = !1, module$3$1 = {
  exports: exports$V$1
}, _global$6$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$V$1() {
  return _dewExec$V$1 || (_dewExec$V$1 = !0, function($e, Ze) {
    function Fe(gt, We) {
      if (!gt)
        throw new Error(We || "Assertion failed");
    }
    function Ke(gt, We) {
      gt.super_ = We;
      var Xe = function() {
      };
      Xe.prototype = We.prototype, gt.prototype = new Xe(), gt.prototype.constructor = gt;
    }
    function Ve(gt, We, Xe) {
      if (Ve.isBN(gt))
        return gt;
      (this || _global$6$1).negative = 0, (this || _global$6$1).words = null, (this || _global$6$1).length = 0, (this || _global$6$1).red = null, gt !== null && ((We === "le" || We === "be") && (Xe = We, We = 10), this._init(gt || 0, We || 10, Xe || "be"));
    }
    typeof $e == "object" ? $e.exports = Ve : Ze.BN = Ve, Ve.BN = Ve, Ve.wordSize = 26;
    var Je;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Je = window.Buffer : Je = e$1$1$1.Buffer;
    } catch {
    }
    Ve.isBN = function(We) {
      return We instanceof Ve ? !0 : We !== null && typeof We == "object" && We.constructor.wordSize === Ve.wordSize && Array.isArray(We.words);
    }, Ve.max = function(We, Xe) {
      return We.cmp(Xe) > 0 ? We : Xe;
    }, Ve.min = function(We, Xe) {
      return We.cmp(Xe) < 0 ? We : Xe;
    }, Ve.prototype._init = function(We, Xe, rt) {
      if (typeof We == "number")
        return this._initNumber(We, Xe, rt);
      if (typeof We == "object")
        return this._initArray(We, Xe, rt);
      Xe === "hex" && (Xe = 16), Fe(Xe === (Xe | 0) && Xe >= 2 && Xe <= 36), We = We.toString().replace(/\s+/g, "");
      var ot = 0;
      We[0] === "-" && (ot++, (this || _global$6$1).negative = 1), ot < We.length && (Xe === 16 ? this._parseHex(We, ot, rt) : (this._parseBase(We, Xe, ot), rt === "le" && this._initArray(this.toArray(), Xe, rt)));
    }, Ve.prototype._initNumber = function(We, Xe, rt) {
      We < 0 && ((this || _global$6$1).negative = 1, We = -We), We < 67108864 ? ((this || _global$6$1).words = [We & 67108863], (this || _global$6$1).length = 1) : We < 4503599627370496 ? ((this || _global$6$1).words = [We & 67108863, We / 67108864 & 67108863], (this || _global$6$1).length = 2) : (Fe(We < 9007199254740992), (this || _global$6$1).words = [We & 67108863, We / 67108864 & 67108863, 1], (this || _global$6$1).length = 3), rt === "le" && this._initArray(this.toArray(), Xe, rt);
    }, Ve.prototype._initArray = function(We, Xe, rt) {
      if (Fe(typeof We.length == "number"), We.length <= 0)
        return (this || _global$6$1).words = [0], (this || _global$6$1).length = 1, this || _global$6$1;
      (this || _global$6$1).length = Math.ceil(We.length / 3), (this || _global$6$1).words = new Array((this || _global$6$1).length);
      for (var ot = 0; ot < (this || _global$6$1).length; ot++)
        (this || _global$6$1).words[ot] = 0;
      var ft, mt, yt = 0;
      if (rt === "be")
        for (ot = We.length - 1, ft = 0; ot >= 0; ot -= 3)
          mt = We[ot] | We[ot - 1] << 8 | We[ot - 2] << 16, (this || _global$6$1).words[ft] |= mt << yt & 67108863, (this || _global$6$1).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      else if (rt === "le")
        for (ot = 0, ft = 0; ot < We.length; ot += 3)
          mt = We[ot] | We[ot + 1] << 8 | We[ot + 2] << 16, (this || _global$6$1).words[ft] |= mt << yt & 67108863, (this || _global$6$1).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      return this.strip();
    };
    function Qe(gt, We) {
      var Xe = gt.charCodeAt(We);
      return Xe >= 65 && Xe <= 70 ? Xe - 55 : Xe >= 97 && Xe <= 102 ? Xe - 87 : Xe - 48 & 15;
    }
    function at(gt, We, Xe) {
      var rt = Qe(gt, Xe);
      return Xe - 1 >= We && (rt |= Qe(gt, Xe - 1) << 4), rt;
    }
    Ve.prototype._parseHex = function(We, Xe, rt) {
      (this || _global$6$1).length = Math.ceil((We.length - Xe) / 6), (this || _global$6$1).words = new Array((this || _global$6$1).length);
      for (var ot = 0; ot < (this || _global$6$1).length; ot++)
        (this || _global$6$1).words[ot] = 0;
      var ft = 0, mt = 0, yt;
      if (rt === "be")
        for (ot = We.length - 1; ot >= Xe; ot -= 2)
          yt = at(We, Xe, ot) << ft, (this || _global$6$1).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$6$1).words[mt] |= yt >>> 26) : ft += 8;
      else {
        var pt = We.length - Xe;
        for (ot = pt % 2 === 0 ? Xe + 1 : Xe; ot < We.length; ot += 2)
          yt = at(We, Xe, ot) << ft, (this || _global$6$1).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$6$1).words[mt] |= yt >>> 26) : ft += 8;
      }
      this.strip();
    };
    function ut(gt, We, Xe, rt) {
      for (var ot = 0, ft = Math.min(gt.length, Xe), mt = We; mt < ft; mt++) {
        var yt = gt.charCodeAt(mt) - 48;
        ot *= rt, yt >= 49 ? ot += yt - 49 + 10 : yt >= 17 ? ot += yt - 17 + 10 : ot += yt;
      }
      return ot;
    }
    Ve.prototype._parseBase = function(We, Xe, rt) {
      (this || _global$6$1).words = [0], (this || _global$6$1).length = 1;
      for (var ot = 0, ft = 1; ft <= 67108863; ft *= Xe)
        ot++;
      ot--, ft = ft / Xe | 0;
      for (var mt = We.length - rt, yt = mt % ot, pt = Math.min(mt, mt - yt) + rt, Ge = 0, ct = rt; ct < pt; ct += ot)
        Ge = ut(We, ct, ct + ot, Xe), this.imuln(ft), (this || _global$6$1).words[0] + Ge < 67108864 ? (this || _global$6$1).words[0] += Ge : this._iaddn(Ge);
      if (yt !== 0) {
        var Mt = 1;
        for (Ge = ut(We, ct, We.length, Xe), ct = 0; ct < yt; ct++)
          Mt *= Xe;
        this.imuln(Mt), (this || _global$6$1).words[0] + Ge < 67108864 ? (this || _global$6$1).words[0] += Ge : this._iaddn(Ge);
      }
      this.strip();
    }, Ve.prototype.copy = function(We) {
      We.words = new Array((this || _global$6$1).length);
      for (var Xe = 0; Xe < (this || _global$6$1).length; Xe++)
        We.words[Xe] = (this || _global$6$1).words[Xe];
      We.length = (this || _global$6$1).length, We.negative = (this || _global$6$1).negative, We.red = (this || _global$6$1).red;
    }, Ve.prototype.clone = function() {
      var We = new Ve(null);
      return this.copy(We), We;
    }, Ve.prototype._expand = function(We) {
      for (; (this || _global$6$1).length < We; )
        (this || _global$6$1).words[(this || _global$6$1).length++] = 0;
      return this || _global$6$1;
    }, Ve.prototype.strip = function() {
      for (; (this || _global$6$1).length > 1 && (this || _global$6$1).words[(this || _global$6$1).length - 1] === 0; )
        (this || _global$6$1).length--;
      return this._normSign();
    }, Ve.prototype._normSign = function() {
      return (this || _global$6$1).length === 1 && (this || _global$6$1).words[0] === 0 && ((this || _global$6$1).negative = 0), this || _global$6$1;
    }, Ve.prototype.inspect = function() {
      return ((this || _global$6$1).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var lt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], dt = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], bt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    Ve.prototype.toString = function(We, Xe) {
      We = We || 10, Xe = Xe | 0 || 1;
      var rt;
      if (We === 16 || We === "hex") {
        rt = "";
        for (var ot = 0, ft = 0, mt = 0; mt < (this || _global$6$1).length; mt++) {
          var yt = (this || _global$6$1).words[mt], pt = ((yt << ot | ft) & 16777215).toString(16);
          ft = yt >>> 24 - ot & 16777215, ft !== 0 || mt !== (this || _global$6$1).length - 1 ? rt = lt[6 - pt.length] + pt + rt : rt = pt + rt, ot += 2, ot >= 26 && (ot -= 26, mt--);
        }
        for (ft !== 0 && (rt = ft.toString(16) + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$6$1).negative !== 0 && (rt = "-" + rt), rt;
      }
      if (We === (We | 0) && We >= 2 && We <= 36) {
        var Ge = dt[We], ct = bt[We];
        rt = "";
        var Mt = this.clone();
        for (Mt.negative = 0; !Mt.isZero(); ) {
          var St = Mt.modn(ct).toString(We);
          Mt = Mt.idivn(ct), Mt.isZero() ? rt = St + rt : rt = lt[Ge - St.length] + St + rt;
        }
        for (this.isZero() && (rt = "0" + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$6$1).negative !== 0 && (rt = "-" + rt), rt;
      }
      Fe(!1, "Base should be between 2 and 36");
    }, Ve.prototype.toNumber = function() {
      var We = (this || _global$6$1).words[0];
      return (this || _global$6$1).length === 2 ? We += (this || _global$6$1).words[1] * 67108864 : (this || _global$6$1).length === 3 && (this || _global$6$1).words[2] === 1 ? We += 4503599627370496 + (this || _global$6$1).words[1] * 67108864 : (this || _global$6$1).length > 2 && Fe(!1, "Number can only safely store up to 53 bits"), (this || _global$6$1).negative !== 0 ? -We : We;
    }, Ve.prototype.toJSON = function() {
      return this.toString(16);
    }, Ve.prototype.toBuffer = function(We, Xe) {
      return Fe(typeof Je < "u"), this.toArrayLike(Je, We, Xe);
    }, Ve.prototype.toArray = function(We, Xe) {
      return this.toArrayLike(Array, We, Xe);
    }, Ve.prototype.toArrayLike = function(We, Xe, rt) {
      var ot = this.byteLength(), ft = rt || Math.max(1, ot);
      Fe(ot <= ft, "byte array longer than desired length"), Fe(ft > 0, "Requested array length <= 0"), this.strip();
      var mt = Xe === "le", yt = new We(ft), pt, Ge, ct = this.clone();
      if (mt) {
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[Ge] = pt;
        for (; Ge < ft; Ge++)
          yt[Ge] = 0;
      } else {
        for (Ge = 0; Ge < ft - ot; Ge++)
          yt[Ge] = 0;
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[ft - Ge - 1] = pt;
      }
      return yt;
    }, Math.clz32 ? Ve.prototype._countBits = function(We) {
      return 32 - Math.clz32(We);
    } : Ve.prototype._countBits = function(We) {
      var Xe = We, rt = 0;
      return Xe >= 4096 && (rt += 13, Xe >>>= 13), Xe >= 64 && (rt += 7, Xe >>>= 7), Xe >= 8 && (rt += 4, Xe >>>= 4), Xe >= 2 && (rt += 2, Xe >>>= 2), rt + Xe;
    }, Ve.prototype._zeroBits = function(We) {
      if (We === 0)
        return 26;
      var Xe = We, rt = 0;
      return Xe & 8191 || (rt += 13, Xe >>>= 13), Xe & 127 || (rt += 7, Xe >>>= 7), Xe & 15 || (rt += 4, Xe >>>= 4), Xe & 3 || (rt += 2, Xe >>>= 2), Xe & 1 || rt++, rt;
    }, Ve.prototype.bitLength = function() {
      var We = (this || _global$6$1).words[(this || _global$6$1).length - 1], Xe = this._countBits(We);
      return ((this || _global$6$1).length - 1) * 26 + Xe;
    };
    function $t(gt) {
      for (var We = new Array(gt.bitLength()), Xe = 0; Xe < We.length; Xe++) {
        var rt = Xe / 26 | 0, ot = Xe % 26;
        We[Xe] = (gt.words[rt] & 1 << ot) >>> ot;
      }
      return We;
    }
    Ve.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var We = 0, Xe = 0; Xe < (this || _global$6$1).length; Xe++) {
        var rt = this._zeroBits((this || _global$6$1).words[Xe]);
        if (We += rt, rt !== 26)
          break;
      }
      return We;
    }, Ve.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Ve.prototype.toTwos = function(We) {
      return (this || _global$6$1).negative !== 0 ? this.abs().inotn(We).iaddn(1) : this.clone();
    }, Ve.prototype.fromTwos = function(We) {
      return this.testn(We - 1) ? this.notn(We).iaddn(1).ineg() : this.clone();
    }, Ve.prototype.isNeg = function() {
      return (this || _global$6$1).negative !== 0;
    }, Ve.prototype.neg = function() {
      return this.clone().ineg();
    }, Ve.prototype.ineg = function() {
      return this.isZero() || ((this || _global$6$1).negative ^= 1), this || _global$6$1;
    }, Ve.prototype.iuor = function(We) {
      for (; (this || _global$6$1).length < We.length; )
        (this || _global$6$1).words[(this || _global$6$1).length++] = 0;
      for (var Xe = 0; Xe < We.length; Xe++)
        (this || _global$6$1).words[Xe] = (this || _global$6$1).words[Xe] | We.words[Xe];
      return this.strip();
    }, Ve.prototype.ior = function(We) {
      return Fe(((this || _global$6$1).negative | We.negative) === 0), this.iuor(We);
    }, Ve.prototype.or = function(We) {
      return (this || _global$6$1).length > We.length ? this.clone().ior(We) : We.clone().ior(this || _global$6$1);
    }, Ve.prototype.uor = function(We) {
      return (this || _global$6$1).length > We.length ? this.clone().iuor(We) : We.clone().iuor(this || _global$6$1);
    }, Ve.prototype.iuand = function(We) {
      var Xe;
      (this || _global$6$1).length > We.length ? Xe = We : Xe = this || _global$6$1;
      for (var rt = 0; rt < Xe.length; rt++)
        (this || _global$6$1).words[rt] = (this || _global$6$1).words[rt] & We.words[rt];
      return (this || _global$6$1).length = Xe.length, this.strip();
    }, Ve.prototype.iand = function(We) {
      return Fe(((this || _global$6$1).negative | We.negative) === 0), this.iuand(We);
    }, Ve.prototype.and = function(We) {
      return (this || _global$6$1).length > We.length ? this.clone().iand(We) : We.clone().iand(this || _global$6$1);
    }, Ve.prototype.uand = function(We) {
      return (this || _global$6$1).length > We.length ? this.clone().iuand(We) : We.clone().iuand(this || _global$6$1);
    }, Ve.prototype.iuxor = function(We) {
      var Xe, rt;
      (this || _global$6$1).length > We.length ? (Xe = this || _global$6$1, rt = We) : (Xe = We, rt = this || _global$6$1);
      for (var ot = 0; ot < rt.length; ot++)
        (this || _global$6$1).words[ot] = Xe.words[ot] ^ rt.words[ot];
      if ((this || _global$6$1) !== Xe)
        for (; ot < Xe.length; ot++)
          (this || _global$6$1).words[ot] = Xe.words[ot];
      return (this || _global$6$1).length = Xe.length, this.strip();
    }, Ve.prototype.ixor = function(We) {
      return Fe(((this || _global$6$1).negative | We.negative) === 0), this.iuxor(We);
    }, Ve.prototype.xor = function(We) {
      return (this || _global$6$1).length > We.length ? this.clone().ixor(We) : We.clone().ixor(this || _global$6$1);
    }, Ve.prototype.uxor = function(We) {
      return (this || _global$6$1).length > We.length ? this.clone().iuxor(We) : We.clone().iuxor(this || _global$6$1);
    }, Ve.prototype.inotn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = Math.ceil(We / 26) | 0, rt = We % 26;
      this._expand(Xe), rt > 0 && Xe--;
      for (var ot = 0; ot < Xe; ot++)
        (this || _global$6$1).words[ot] = ~(this || _global$6$1).words[ot] & 67108863;
      return rt > 0 && ((this || _global$6$1).words[ot] = ~(this || _global$6$1).words[ot] & 67108863 >> 26 - rt), this.strip();
    }, Ve.prototype.notn = function(We) {
      return this.clone().inotn(We);
    }, Ve.prototype.setn = function(We, Xe) {
      Fe(typeof We == "number" && We >= 0);
      var rt = We / 26 | 0, ot = We % 26;
      return this._expand(rt + 1), Xe ? (this || _global$6$1).words[rt] = (this || _global$6$1).words[rt] | 1 << ot : (this || _global$6$1).words[rt] = (this || _global$6$1).words[rt] & ~(1 << ot), this.strip();
    }, Ve.prototype.iadd = function(We) {
      var Xe;
      if ((this || _global$6$1).negative !== 0 && We.negative === 0)
        return (this || _global$6$1).negative = 0, Xe = this.isub(We), (this || _global$6$1).negative ^= 1, this._normSign();
      if ((this || _global$6$1).negative === 0 && We.negative !== 0)
        return We.negative = 0, Xe = this.isub(We), We.negative = 1, Xe._normSign();
      var rt, ot;
      (this || _global$6$1).length > We.length ? (rt = this || _global$6$1, ot = We) : (rt = We, ot = this || _global$6$1);
      for (var ft = 0, mt = 0; mt < ot.length; mt++)
        Xe = (rt.words[mt] | 0) + (ot.words[mt] | 0) + ft, (this || _global$6$1).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      for (; ft !== 0 && mt < rt.length; mt++)
        Xe = (rt.words[mt] | 0) + ft, (this || _global$6$1).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      if ((this || _global$6$1).length = rt.length, ft !== 0)
        (this || _global$6$1).words[(this || _global$6$1).length] = ft, (this || _global$6$1).length++;
      else if (rt !== (this || _global$6$1))
        for (; mt < rt.length; mt++)
          (this || _global$6$1).words[mt] = rt.words[mt];
      return this || _global$6$1;
    }, Ve.prototype.add = function(We) {
      var Xe;
      return We.negative !== 0 && (this || _global$6$1).negative === 0 ? (We.negative = 0, Xe = this.sub(We), We.negative ^= 1, Xe) : We.negative === 0 && (this || _global$6$1).negative !== 0 ? ((this || _global$6$1).negative = 0, Xe = We.sub(this || _global$6$1), (this || _global$6$1).negative = 1, Xe) : (this || _global$6$1).length > We.length ? this.clone().iadd(We) : We.clone().iadd(this || _global$6$1);
    }, Ve.prototype.isub = function(We) {
      if (We.negative !== 0) {
        We.negative = 0;
        var Xe = this.iadd(We);
        return We.negative = 1, Xe._normSign();
      } else if ((this || _global$6$1).negative !== 0)
        return (this || _global$6$1).negative = 0, this.iadd(We), (this || _global$6$1).negative = 1, this._normSign();
      var rt = this.cmp(We);
      if (rt === 0)
        return (this || _global$6$1).negative = 0, (this || _global$6$1).length = 1, (this || _global$6$1).words[0] = 0, this || _global$6$1;
      var ot, ft;
      rt > 0 ? (ot = this || _global$6$1, ft = We) : (ot = We, ft = this || _global$6$1);
      for (var mt = 0, yt = 0; yt < ft.length; yt++)
        Xe = (ot.words[yt] | 0) - (ft.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$6$1).words[yt] = Xe & 67108863;
      for (; mt !== 0 && yt < ot.length; yt++)
        Xe = (ot.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$6$1).words[yt] = Xe & 67108863;
      if (mt === 0 && yt < ot.length && ot !== (this || _global$6$1))
        for (; yt < ot.length; yt++)
          (this || _global$6$1).words[yt] = ot.words[yt];
      return (this || _global$6$1).length = Math.max((this || _global$6$1).length, yt), ot !== (this || _global$6$1) && ((this || _global$6$1).negative = 1), this.strip();
    }, Ve.prototype.sub = function(We) {
      return this.clone().isub(We);
    };
    function vt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative;
      var rt = gt.length + We.length | 0;
      Xe.length = rt, rt = rt - 1 | 0;
      var ot = gt.words[0] | 0, ft = We.words[0] | 0, mt = ot * ft, yt = mt & 67108863, pt = mt / 67108864 | 0;
      Xe.words[0] = yt;
      for (var Ge = 1; Ge < rt; Ge++) {
        for (var ct = pt >>> 26, Mt = pt & 67108863, St = Math.min(Ge, We.length - 1), At = Math.max(0, Ge - gt.length + 1); At <= St; At++) {
          var Nt = Ge - At | 0;
          ot = gt.words[Nt] | 0, ft = We.words[At] | 0, mt = ot * ft + Mt, ct += mt / 67108864 | 0, Mt = mt & 67108863;
        }
        Xe.words[Ge] = Mt | 0, pt = ct | 0;
      }
      return pt !== 0 ? Xe.words[Ge] = pt | 0 : Xe.length--, Xe.strip();
    }
    var wt = function(We, Xe, rt) {
      var ot = We.words, ft = Xe.words, mt = rt.words, yt = 0, pt, Ge, ct, Mt = ot[0] | 0, St = Mt & 8191, At = Mt >>> 13, Nt = ot[1] | 0, qt = Nt & 8191, Qt = Nt >>> 13, Xt = ot[2] | 0, zt = Xt & 8191, Kt = Xt >>> 13, ur = ot[3] | 0, er = ur & 8191, Dt = ur >>> 13, Ht = ot[4] | 0, Gt = Ht & 8191, rr = Ht >>> 13, sr = ot[5] | 0, Jt = sr & 8191, ir = sr >>> 13, Br = ot[6] | 0, or = Br & 8191, lr = Br >>> 13, Nr = ot[7] | 0, dr = Nr & 8191, gr = Nr >>> 13, Zr = ot[8] | 0, Bt = Zr & 8191, kt = Zr >>> 13, It = ot[9] | 0, jt = It & 8191, Vt = It >>> 13, ar = ft[0] | 0, Yt = ar & 8191, hr = ar >>> 13, zr = ft[1] | 0, cr = zr & 8191, _r = zr >>> 13, Lr = ft[2] | 0, br = Lr & 8191, kr = Lr >>> 13, Xr = ft[3] | 0, yr = Xr & 8191, Ir = Xr >>> 13, Yr = ft[4] | 0, wr = Yr & 8191, Cr = Yr >>> 13, Hr = ft[5] | 0, $r = Hr & 8191, Ar = Hr >>> 13, Wr = ft[6] | 0, mr = Wr & 8191, Tr = Wr >>> 13, Kr = ft[7] | 0, vr = Kr & 8191, Rr = Kr >>> 13, Jr = ft[8] | 0, xr = Jr & 8191, tr = Jr >>> 13, Dr = ft[9] | 0, fr = Dr & 8191, Mr = Dr >>> 13;
      rt.negative = We.negative ^ Xe.negative, rt.length = 19, pt = Math.imul(St, Yt), Ge = Math.imul(St, hr), Ge = Ge + Math.imul(At, Yt) | 0, ct = Math.imul(At, hr);
      var Fr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, pt = Math.imul(qt, Yt), Ge = Math.imul(qt, hr), Ge = Ge + Math.imul(Qt, Yt) | 0, ct = Math.imul(Qt, hr), pt = pt + Math.imul(St, cr) | 0, Ge = Ge + Math.imul(St, _r) | 0, Ge = Ge + Math.imul(At, cr) | 0, ct = ct + Math.imul(At, _r) | 0;
      var qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, pt = Math.imul(zt, Yt), Ge = Math.imul(zt, hr), Ge = Ge + Math.imul(Kt, Yt) | 0, ct = Math.imul(Kt, hr), pt = pt + Math.imul(qt, cr) | 0, Ge = Ge + Math.imul(qt, _r) | 0, Ge = Ge + Math.imul(Qt, cr) | 0, ct = ct + Math.imul(Qt, _r) | 0, pt = pt + Math.imul(St, br) | 0, Ge = Ge + Math.imul(St, kr) | 0, Ge = Ge + Math.imul(At, br) | 0, ct = ct + Math.imul(At, kr) | 0;
      var tn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, pt = Math.imul(er, Yt), Ge = Math.imul(er, hr), Ge = Ge + Math.imul(Dt, Yt) | 0, ct = Math.imul(Dt, hr), pt = pt + Math.imul(zt, cr) | 0, Ge = Ge + Math.imul(zt, _r) | 0, Ge = Ge + Math.imul(Kt, cr) | 0, ct = ct + Math.imul(Kt, _r) | 0, pt = pt + Math.imul(qt, br) | 0, Ge = Ge + Math.imul(qt, kr) | 0, Ge = Ge + Math.imul(Qt, br) | 0, ct = ct + Math.imul(Qt, kr) | 0, pt = pt + Math.imul(St, yr) | 0, Ge = Ge + Math.imul(St, Ir) | 0, Ge = Ge + Math.imul(At, yr) | 0, ct = ct + Math.imul(At, Ir) | 0;
      var Qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, pt = Math.imul(Gt, Yt), Ge = Math.imul(Gt, hr), Ge = Ge + Math.imul(rr, Yt) | 0, ct = Math.imul(rr, hr), pt = pt + Math.imul(er, cr) | 0, Ge = Ge + Math.imul(er, _r) | 0, Ge = Ge + Math.imul(Dt, cr) | 0, ct = ct + Math.imul(Dt, _r) | 0, pt = pt + Math.imul(zt, br) | 0, Ge = Ge + Math.imul(zt, kr) | 0, Ge = Ge + Math.imul(Kt, br) | 0, ct = ct + Math.imul(Kt, kr) | 0, pt = pt + Math.imul(qt, yr) | 0, Ge = Ge + Math.imul(qt, Ir) | 0, Ge = Ge + Math.imul(Qt, yr) | 0, ct = ct + Math.imul(Qt, Ir) | 0, pt = pt + Math.imul(St, wr) | 0, Ge = Ge + Math.imul(St, Cr) | 0, Ge = Ge + Math.imul(At, wr) | 0, ct = ct + Math.imul(At, Cr) | 0;
      var nn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, pt = Math.imul(Jt, Yt), Ge = Math.imul(Jt, hr), Ge = Ge + Math.imul(ir, Yt) | 0, ct = Math.imul(ir, hr), pt = pt + Math.imul(Gt, cr) | 0, Ge = Ge + Math.imul(Gt, _r) | 0, Ge = Ge + Math.imul(rr, cr) | 0, ct = ct + Math.imul(rr, _r) | 0, pt = pt + Math.imul(er, br) | 0, Ge = Ge + Math.imul(er, kr) | 0, Ge = Ge + Math.imul(Dt, br) | 0, ct = ct + Math.imul(Dt, kr) | 0, pt = pt + Math.imul(zt, yr) | 0, Ge = Ge + Math.imul(zt, Ir) | 0, Ge = Ge + Math.imul(Kt, yr) | 0, ct = ct + Math.imul(Kt, Ir) | 0, pt = pt + Math.imul(qt, wr) | 0, Ge = Ge + Math.imul(qt, Cr) | 0, Ge = Ge + Math.imul(Qt, wr) | 0, ct = ct + Math.imul(Qt, Cr) | 0, pt = pt + Math.imul(St, $r) | 0, Ge = Ge + Math.imul(St, Ar) | 0, Ge = Ge + Math.imul(At, $r) | 0, ct = ct + Math.imul(At, Ar) | 0;
      var Er = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, pt = Math.imul(or, Yt), Ge = Math.imul(or, hr), Ge = Ge + Math.imul(lr, Yt) | 0, ct = Math.imul(lr, hr), pt = pt + Math.imul(Jt, cr) | 0, Ge = Ge + Math.imul(Jt, _r) | 0, Ge = Ge + Math.imul(ir, cr) | 0, ct = ct + Math.imul(ir, _r) | 0, pt = pt + Math.imul(Gt, br) | 0, Ge = Ge + Math.imul(Gt, kr) | 0, Ge = Ge + Math.imul(rr, br) | 0, ct = ct + Math.imul(rr, kr) | 0, pt = pt + Math.imul(er, yr) | 0, Ge = Ge + Math.imul(er, Ir) | 0, Ge = Ge + Math.imul(Dt, yr) | 0, ct = ct + Math.imul(Dt, Ir) | 0, pt = pt + Math.imul(zt, wr) | 0, Ge = Ge + Math.imul(zt, Cr) | 0, Ge = Ge + Math.imul(Kt, wr) | 0, ct = ct + Math.imul(Kt, Cr) | 0, pt = pt + Math.imul(qt, $r) | 0, Ge = Ge + Math.imul(qt, Ar) | 0, Ge = Ge + Math.imul(Qt, $r) | 0, ct = ct + Math.imul(Qt, Ar) | 0, pt = pt + Math.imul(St, mr) | 0, Ge = Ge + Math.imul(St, Tr) | 0, Ge = Ge + Math.imul(At, mr) | 0, ct = ct + Math.imul(At, Tr) | 0;
      var Wt = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, pt = Math.imul(dr, Yt), Ge = Math.imul(dr, hr), Ge = Ge + Math.imul(gr, Yt) | 0, ct = Math.imul(gr, hr), pt = pt + Math.imul(or, cr) | 0, Ge = Ge + Math.imul(or, _r) | 0, Ge = Ge + Math.imul(lr, cr) | 0, ct = ct + Math.imul(lr, _r) | 0, pt = pt + Math.imul(Jt, br) | 0, Ge = Ge + Math.imul(Jt, kr) | 0, Ge = Ge + Math.imul(ir, br) | 0, ct = ct + Math.imul(ir, kr) | 0, pt = pt + Math.imul(Gt, yr) | 0, Ge = Ge + Math.imul(Gt, Ir) | 0, Ge = Ge + Math.imul(rr, yr) | 0, ct = ct + Math.imul(rr, Ir) | 0, pt = pt + Math.imul(er, wr) | 0, Ge = Ge + Math.imul(er, Cr) | 0, Ge = Ge + Math.imul(Dt, wr) | 0, ct = ct + Math.imul(Dt, Cr) | 0, pt = pt + Math.imul(zt, $r) | 0, Ge = Ge + Math.imul(zt, Ar) | 0, Ge = Ge + Math.imul(Kt, $r) | 0, ct = ct + Math.imul(Kt, Ar) | 0, pt = pt + Math.imul(qt, mr) | 0, Ge = Ge + Math.imul(qt, Tr) | 0, Ge = Ge + Math.imul(Qt, mr) | 0, ct = ct + Math.imul(Qt, Tr) | 0, pt = pt + Math.imul(St, vr) | 0, Ge = Ge + Math.imul(St, Rr) | 0, Ge = Ge + Math.imul(At, vr) | 0, ct = ct + Math.imul(At, Rr) | 0;
      var nr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, pt = Math.imul(Bt, Yt), Ge = Math.imul(Bt, hr), Ge = Ge + Math.imul(kt, Yt) | 0, ct = Math.imul(kt, hr), pt = pt + Math.imul(dr, cr) | 0, Ge = Ge + Math.imul(dr, _r) | 0, Ge = Ge + Math.imul(gr, cr) | 0, ct = ct + Math.imul(gr, _r) | 0, pt = pt + Math.imul(or, br) | 0, Ge = Ge + Math.imul(or, kr) | 0, Ge = Ge + Math.imul(lr, br) | 0, ct = ct + Math.imul(lr, kr) | 0, pt = pt + Math.imul(Jt, yr) | 0, Ge = Ge + Math.imul(Jt, Ir) | 0, Ge = Ge + Math.imul(ir, yr) | 0, ct = ct + Math.imul(ir, Ir) | 0, pt = pt + Math.imul(Gt, wr) | 0, Ge = Ge + Math.imul(Gt, Cr) | 0, Ge = Ge + Math.imul(rr, wr) | 0, ct = ct + Math.imul(rr, Cr) | 0, pt = pt + Math.imul(er, $r) | 0, Ge = Ge + Math.imul(er, Ar) | 0, Ge = Ge + Math.imul(Dt, $r) | 0, ct = ct + Math.imul(Dt, Ar) | 0, pt = pt + Math.imul(zt, mr) | 0, Ge = Ge + Math.imul(zt, Tr) | 0, Ge = Ge + Math.imul(Kt, mr) | 0, ct = ct + Math.imul(Kt, Tr) | 0, pt = pt + Math.imul(qt, vr) | 0, Ge = Ge + Math.imul(qt, Rr) | 0, Ge = Ge + Math.imul(Qt, vr) | 0, ct = ct + Math.imul(Qt, Rr) | 0, pt = pt + Math.imul(St, xr) | 0, Ge = Ge + Math.imul(St, tr) | 0, Ge = Ge + Math.imul(At, xr) | 0, ct = ct + Math.imul(At, tr) | 0;
      var pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, pt = Math.imul(jt, Yt), Ge = Math.imul(jt, hr), Ge = Ge + Math.imul(Vt, Yt) | 0, ct = Math.imul(Vt, hr), pt = pt + Math.imul(Bt, cr) | 0, Ge = Ge + Math.imul(Bt, _r) | 0, Ge = Ge + Math.imul(kt, cr) | 0, ct = ct + Math.imul(kt, _r) | 0, pt = pt + Math.imul(dr, br) | 0, Ge = Ge + Math.imul(dr, kr) | 0, Ge = Ge + Math.imul(gr, br) | 0, ct = ct + Math.imul(gr, kr) | 0, pt = pt + Math.imul(or, yr) | 0, Ge = Ge + Math.imul(or, Ir) | 0, Ge = Ge + Math.imul(lr, yr) | 0, ct = ct + Math.imul(lr, Ir) | 0, pt = pt + Math.imul(Jt, wr) | 0, Ge = Ge + Math.imul(Jt, Cr) | 0, Ge = Ge + Math.imul(ir, wr) | 0, ct = ct + Math.imul(ir, Cr) | 0, pt = pt + Math.imul(Gt, $r) | 0, Ge = Ge + Math.imul(Gt, Ar) | 0, Ge = Ge + Math.imul(rr, $r) | 0, ct = ct + Math.imul(rr, Ar) | 0, pt = pt + Math.imul(er, mr) | 0, Ge = Ge + Math.imul(er, Tr) | 0, Ge = Ge + Math.imul(Dt, mr) | 0, ct = ct + Math.imul(Dt, Tr) | 0, pt = pt + Math.imul(zt, vr) | 0, Ge = Ge + Math.imul(zt, Rr) | 0, Ge = Ge + Math.imul(Kt, vr) | 0, ct = ct + Math.imul(Kt, Rr) | 0, pt = pt + Math.imul(qt, xr) | 0, Ge = Ge + Math.imul(qt, tr) | 0, Ge = Ge + Math.imul(Qt, xr) | 0, ct = ct + Math.imul(Qt, tr) | 0, pt = pt + Math.imul(St, fr) | 0, Ge = Ge + Math.imul(St, Mr) | 0, Ge = Ge + Math.imul(At, fr) | 0, ct = ct + Math.imul(At, Mr) | 0;
      var Pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, pt = Math.imul(jt, cr), Ge = Math.imul(jt, _r), Ge = Ge + Math.imul(Vt, cr) | 0, ct = Math.imul(Vt, _r), pt = pt + Math.imul(Bt, br) | 0, Ge = Ge + Math.imul(Bt, kr) | 0, Ge = Ge + Math.imul(kt, br) | 0, ct = ct + Math.imul(kt, kr) | 0, pt = pt + Math.imul(dr, yr) | 0, Ge = Ge + Math.imul(dr, Ir) | 0, Ge = Ge + Math.imul(gr, yr) | 0, ct = ct + Math.imul(gr, Ir) | 0, pt = pt + Math.imul(or, wr) | 0, Ge = Ge + Math.imul(or, Cr) | 0, Ge = Ge + Math.imul(lr, wr) | 0, ct = ct + Math.imul(lr, Cr) | 0, pt = pt + Math.imul(Jt, $r) | 0, Ge = Ge + Math.imul(Jt, Ar) | 0, Ge = Ge + Math.imul(ir, $r) | 0, ct = ct + Math.imul(ir, Ar) | 0, pt = pt + Math.imul(Gt, mr) | 0, Ge = Ge + Math.imul(Gt, Tr) | 0, Ge = Ge + Math.imul(rr, mr) | 0, ct = ct + Math.imul(rr, Tr) | 0, pt = pt + Math.imul(er, vr) | 0, Ge = Ge + Math.imul(er, Rr) | 0, Ge = Ge + Math.imul(Dt, vr) | 0, ct = ct + Math.imul(Dt, Rr) | 0, pt = pt + Math.imul(zt, xr) | 0, Ge = Ge + Math.imul(zt, tr) | 0, Ge = Ge + Math.imul(Kt, xr) | 0, ct = ct + Math.imul(Kt, tr) | 0, pt = pt + Math.imul(qt, fr) | 0, Ge = Ge + Math.imul(qt, Mr) | 0, Ge = Ge + Math.imul(Qt, fr) | 0, ct = ct + Math.imul(Qt, Mr) | 0;
      var Sr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, pt = Math.imul(jt, br), Ge = Math.imul(jt, kr), Ge = Ge + Math.imul(Vt, br) | 0, ct = Math.imul(Vt, kr), pt = pt + Math.imul(Bt, yr) | 0, Ge = Ge + Math.imul(Bt, Ir) | 0, Ge = Ge + Math.imul(kt, yr) | 0, ct = ct + Math.imul(kt, Ir) | 0, pt = pt + Math.imul(dr, wr) | 0, Ge = Ge + Math.imul(dr, Cr) | 0, Ge = Ge + Math.imul(gr, wr) | 0, ct = ct + Math.imul(gr, Cr) | 0, pt = pt + Math.imul(or, $r) | 0, Ge = Ge + Math.imul(or, Ar) | 0, Ge = Ge + Math.imul(lr, $r) | 0, ct = ct + Math.imul(lr, Ar) | 0, pt = pt + Math.imul(Jt, mr) | 0, Ge = Ge + Math.imul(Jt, Tr) | 0, Ge = Ge + Math.imul(ir, mr) | 0, ct = ct + Math.imul(ir, Tr) | 0, pt = pt + Math.imul(Gt, vr) | 0, Ge = Ge + Math.imul(Gt, Rr) | 0, Ge = Ge + Math.imul(rr, vr) | 0, ct = ct + Math.imul(rr, Rr) | 0, pt = pt + Math.imul(er, xr) | 0, Ge = Ge + Math.imul(er, tr) | 0, Ge = Ge + Math.imul(Dt, xr) | 0, ct = ct + Math.imul(Dt, tr) | 0, pt = pt + Math.imul(zt, fr) | 0, Ge = Ge + Math.imul(zt, Mr) | 0, Ge = Ge + Math.imul(Kt, fr) | 0, ct = ct + Math.imul(Kt, Mr) | 0;
      var Ur = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, pt = Math.imul(jt, yr), Ge = Math.imul(jt, Ir), Ge = Ge + Math.imul(Vt, yr) | 0, ct = Math.imul(Vt, Ir), pt = pt + Math.imul(Bt, wr) | 0, Ge = Ge + Math.imul(Bt, Cr) | 0, Ge = Ge + Math.imul(kt, wr) | 0, ct = ct + Math.imul(kt, Cr) | 0, pt = pt + Math.imul(dr, $r) | 0, Ge = Ge + Math.imul(dr, Ar) | 0, Ge = Ge + Math.imul(gr, $r) | 0, ct = ct + Math.imul(gr, Ar) | 0, pt = pt + Math.imul(or, mr) | 0, Ge = Ge + Math.imul(or, Tr) | 0, Ge = Ge + Math.imul(lr, mr) | 0, ct = ct + Math.imul(lr, Tr) | 0, pt = pt + Math.imul(Jt, vr) | 0, Ge = Ge + Math.imul(Jt, Rr) | 0, Ge = Ge + Math.imul(ir, vr) | 0, ct = ct + Math.imul(ir, Rr) | 0, pt = pt + Math.imul(Gt, xr) | 0, Ge = Ge + Math.imul(Gt, tr) | 0, Ge = Ge + Math.imul(rr, xr) | 0, ct = ct + Math.imul(rr, tr) | 0, pt = pt + Math.imul(er, fr) | 0, Ge = Ge + Math.imul(er, Mr) | 0, Ge = Ge + Math.imul(Dt, fr) | 0, ct = ct + Math.imul(Dt, Mr) | 0;
      var jr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, pt = Math.imul(jt, wr), Ge = Math.imul(jt, Cr), Ge = Ge + Math.imul(Vt, wr) | 0, ct = Math.imul(Vt, Cr), pt = pt + Math.imul(Bt, $r) | 0, Ge = Ge + Math.imul(Bt, Ar) | 0, Ge = Ge + Math.imul(kt, $r) | 0, ct = ct + Math.imul(kt, Ar) | 0, pt = pt + Math.imul(dr, mr) | 0, Ge = Ge + Math.imul(dr, Tr) | 0, Ge = Ge + Math.imul(gr, mr) | 0, ct = ct + Math.imul(gr, Tr) | 0, pt = pt + Math.imul(or, vr) | 0, Ge = Ge + Math.imul(or, Rr) | 0, Ge = Ge + Math.imul(lr, vr) | 0, ct = ct + Math.imul(lr, Rr) | 0, pt = pt + Math.imul(Jt, xr) | 0, Ge = Ge + Math.imul(Jt, tr) | 0, Ge = Ge + Math.imul(ir, xr) | 0, ct = ct + Math.imul(ir, tr) | 0, pt = pt + Math.imul(Gt, fr) | 0, Ge = Ge + Math.imul(Gt, Mr) | 0, Ge = Ge + Math.imul(rr, fr) | 0, ct = ct + Math.imul(rr, Mr) | 0;
      var Gr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, pt = Math.imul(jt, $r), Ge = Math.imul(jt, Ar), Ge = Ge + Math.imul(Vt, $r) | 0, ct = Math.imul(Vt, Ar), pt = pt + Math.imul(Bt, mr) | 0, Ge = Ge + Math.imul(Bt, Tr) | 0, Ge = Ge + Math.imul(kt, mr) | 0, ct = ct + Math.imul(kt, Tr) | 0, pt = pt + Math.imul(dr, vr) | 0, Ge = Ge + Math.imul(dr, Rr) | 0, Ge = Ge + Math.imul(gr, vr) | 0, ct = ct + Math.imul(gr, Rr) | 0, pt = pt + Math.imul(or, xr) | 0, Ge = Ge + Math.imul(or, tr) | 0, Ge = Ge + Math.imul(lr, xr) | 0, ct = ct + Math.imul(lr, tr) | 0, pt = pt + Math.imul(Jt, fr) | 0, Ge = Ge + Math.imul(Jt, Mr) | 0, Ge = Ge + Math.imul(ir, fr) | 0, ct = ct + Math.imul(ir, Mr) | 0;
      var Vr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, pt = Math.imul(jt, mr), Ge = Math.imul(jt, Tr), Ge = Ge + Math.imul(Vt, mr) | 0, ct = Math.imul(Vt, Tr), pt = pt + Math.imul(Bt, vr) | 0, Ge = Ge + Math.imul(Bt, Rr) | 0, Ge = Ge + Math.imul(kt, vr) | 0, ct = ct + Math.imul(kt, Rr) | 0, pt = pt + Math.imul(dr, xr) | 0, Ge = Ge + Math.imul(dr, tr) | 0, Ge = Ge + Math.imul(gr, xr) | 0, ct = ct + Math.imul(gr, tr) | 0, pt = pt + Math.imul(or, fr) | 0, Ge = Ge + Math.imul(or, Mr) | 0, Ge = Ge + Math.imul(lr, fr) | 0, ct = ct + Math.imul(lr, Mr) | 0;
      var rn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, pt = Math.imul(jt, vr), Ge = Math.imul(jt, Rr), Ge = Ge + Math.imul(Vt, vr) | 0, ct = Math.imul(Vt, Rr), pt = pt + Math.imul(Bt, xr) | 0, Ge = Ge + Math.imul(Bt, tr) | 0, Ge = Ge + Math.imul(kt, xr) | 0, ct = ct + Math.imul(kt, tr) | 0, pt = pt + Math.imul(dr, fr) | 0, Ge = Ge + Math.imul(dr, Mr) | 0, Ge = Ge + Math.imul(gr, fr) | 0, ct = ct + Math.imul(gr, Mr) | 0;
      var an = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, pt = Math.imul(jt, xr), Ge = Math.imul(jt, tr), Ge = Ge + Math.imul(Vt, xr) | 0, ct = Math.imul(Vt, tr), pt = pt + Math.imul(Bt, fr) | 0, Ge = Ge + Math.imul(Bt, Mr) | 0, Ge = Ge + Math.imul(kt, fr) | 0, ct = ct + Math.imul(kt, Mr) | 0;
      var ln = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, pt = Math.imul(jt, fr), Ge = Math.imul(jt, Mr), Ge = Ge + Math.imul(Vt, fr) | 0, ct = Math.imul(Vt, Mr);
      var sn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      return yt = (ct + (Ge >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, mt[0] = Fr, mt[1] = qr, mt[2] = tn, mt[3] = Qr, mt[4] = nn, mt[5] = Er, mt[6] = Wt, mt[7] = nr, mt[8] = pr, mt[9] = Pr, mt[10] = Sr, mt[11] = Ur, mt[12] = jr, mt[13] = Gr, mt[14] = Vr, mt[15] = rn, mt[16] = an, mt[17] = ln, mt[18] = sn, yt !== 0 && (mt[19] = yt, rt.length++), rt;
    };
    Math.imul || (wt = vt);
    function xt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative, Xe.length = gt.length + We.length;
      for (var rt = 0, ot = 0, ft = 0; ft < Xe.length - 1; ft++) {
        var mt = ot;
        ot = 0;
        for (var yt = rt & 67108863, pt = Math.min(ft, We.length - 1), Ge = Math.max(0, ft - gt.length + 1); Ge <= pt; Ge++) {
          var ct = ft - Ge, Mt = gt.words[ct] | 0, St = We.words[Ge] | 0, At = Mt * St, Nt = At & 67108863;
          mt = mt + (At / 67108864 | 0) | 0, Nt = Nt + yt | 0, yt = Nt & 67108863, mt = mt + (Nt >>> 26) | 0, ot += mt >>> 26, mt &= 67108863;
        }
        Xe.words[ft] = yt, rt = mt, mt = ot;
      }
      return rt !== 0 ? Xe.words[ft] = rt : Xe.length--, Xe.strip();
    }
    function Et(gt, We, Xe) {
      var rt = new Tt();
      return rt.mulp(gt, We, Xe);
    }
    Ve.prototype.mulTo = function(We, Xe) {
      var rt, ot = (this || _global$6$1).length + We.length;
      return (this || _global$6$1).length === 10 && We.length === 10 ? rt = wt(this || _global$6$1, We, Xe) : ot < 63 ? rt = vt(this || _global$6$1, We, Xe) : ot < 1024 ? rt = xt(this || _global$6$1, We, Xe) : rt = Et(this || _global$6$1, We, Xe), rt;
    };
    function Tt(gt, We) {
      (this || _global$6$1).x = gt, (this || _global$6$1).y = We;
    }
    Tt.prototype.makeRBT = function(We) {
      for (var Xe = new Array(We), rt = Ve.prototype._countBits(We) - 1, ot = 0; ot < We; ot++)
        Xe[ot] = this.revBin(ot, rt, We);
      return Xe;
    }, Tt.prototype.revBin = function(We, Xe, rt) {
      if (We === 0 || We === rt - 1)
        return We;
      for (var ot = 0, ft = 0; ft < Xe; ft++)
        ot |= (We & 1) << Xe - ft - 1, We >>= 1;
      return ot;
    }, Tt.prototype.permute = function(We, Xe, rt, ot, ft, mt) {
      for (var yt = 0; yt < mt; yt++)
        ot[yt] = Xe[We[yt]], ft[yt] = rt[We[yt]];
    }, Tt.prototype.transform = function(We, Xe, rt, ot, ft, mt) {
      this.permute(mt, We, Xe, rt, ot, ft);
      for (var yt = 1; yt < ft; yt <<= 1)
        for (var pt = yt << 1, Ge = Math.cos(2 * Math.PI / pt), ct = Math.sin(2 * Math.PI / pt), Mt = 0; Mt < ft; Mt += pt)
          for (var St = Ge, At = ct, Nt = 0; Nt < yt; Nt++) {
            var qt = rt[Mt + Nt], Qt = ot[Mt + Nt], Xt = rt[Mt + Nt + yt], zt = ot[Mt + Nt + yt], Kt = St * Xt - At * zt;
            zt = St * zt + At * Xt, Xt = Kt, rt[Mt + Nt] = qt + Xt, ot[Mt + Nt] = Qt + zt, rt[Mt + Nt + yt] = qt - Xt, ot[Mt + Nt + yt] = Qt - zt, Nt !== pt && (Kt = Ge * St - ct * At, At = Ge * At + ct * St, St = Kt);
          }
    }, Tt.prototype.guessLen13b = function(We, Xe) {
      var rt = Math.max(Xe, We) | 1, ot = rt & 1, ft = 0;
      for (rt = rt / 2 | 0; rt; rt = rt >>> 1)
        ft++;
      return 1 << ft + 1 + ot;
    }, Tt.prototype.conjugate = function(We, Xe, rt) {
      if (!(rt <= 1))
        for (var ot = 0; ot < rt / 2; ot++) {
          var ft = We[ot];
          We[ot] = We[rt - ot - 1], We[rt - ot - 1] = ft, ft = Xe[ot], Xe[ot] = -Xe[rt - ot - 1], Xe[rt - ot - 1] = -ft;
        }
    }, Tt.prototype.normalize13b = function(We, Xe) {
      for (var rt = 0, ot = 0; ot < Xe / 2; ot++) {
        var ft = Math.round(We[2 * ot + 1] / Xe) * 8192 + Math.round(We[2 * ot] / Xe) + rt;
        We[ot] = ft & 67108863, ft < 67108864 ? rt = 0 : rt = ft / 67108864 | 0;
      }
      return We;
    }, Tt.prototype.convert13b = function(We, Xe, rt, ot) {
      for (var ft = 0, mt = 0; mt < Xe; mt++)
        ft = ft + (We[mt] | 0), rt[2 * mt] = ft & 8191, ft = ft >>> 13, rt[2 * mt + 1] = ft & 8191, ft = ft >>> 13;
      for (mt = 2 * Xe; mt < ot; ++mt)
        rt[mt] = 0;
      Fe(ft === 0), Fe((ft & -8192) === 0);
    }, Tt.prototype.stub = function(We) {
      for (var Xe = new Array(We), rt = 0; rt < We; rt++)
        Xe[rt] = 0;
      return Xe;
    }, Tt.prototype.mulp = function(We, Xe, rt) {
      var ot = 2 * this.guessLen13b(We.length, Xe.length), ft = this.makeRBT(ot), mt = this.stub(ot), yt = new Array(ot), pt = new Array(ot), Ge = new Array(ot), ct = new Array(ot), Mt = new Array(ot), St = new Array(ot), At = rt.words;
      At.length = ot, this.convert13b(We.words, We.length, yt, ot), this.convert13b(Xe.words, Xe.length, ct, ot), this.transform(yt, mt, pt, Ge, ot, ft), this.transform(ct, mt, Mt, St, ot, ft);
      for (var Nt = 0; Nt < ot; Nt++) {
        var qt = pt[Nt] * Mt[Nt] - Ge[Nt] * St[Nt];
        Ge[Nt] = pt[Nt] * St[Nt] + Ge[Nt] * Mt[Nt], pt[Nt] = qt;
      }
      return this.conjugate(pt, Ge, ot), this.transform(pt, Ge, At, mt, ot, ft), this.conjugate(At, mt, ot), this.normalize13b(At, ot), rt.negative = We.negative ^ Xe.negative, rt.length = We.length + Xe.length, rt.strip();
    }, Ve.prototype.mul = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$6$1).length + We.length), this.mulTo(We, Xe);
    }, Ve.prototype.mulf = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$6$1).length + We.length), Et(this || _global$6$1, We, Xe);
    }, Ve.prototype.imul = function(We) {
      return this.clone().mulTo(We, this || _global$6$1);
    }, Ve.prototype.imuln = function(We) {
      Fe(typeof We == "number"), Fe(We < 67108864);
      for (var Xe = 0, rt = 0; rt < (this || _global$6$1).length; rt++) {
        var ot = ((this || _global$6$1).words[rt] | 0) * We, ft = (ot & 67108863) + (Xe & 67108863);
        Xe >>= 26, Xe += ot / 67108864 | 0, Xe += ft >>> 26, (this || _global$6$1).words[rt] = ft & 67108863;
      }
      return Xe !== 0 && ((this || _global$6$1).words[rt] = Xe, (this || _global$6$1).length++), this || _global$6$1;
    }, Ve.prototype.muln = function(We) {
      return this.clone().imuln(We);
    }, Ve.prototype.sqr = function() {
      return this.mul(this || _global$6$1);
    }, Ve.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Ve.prototype.pow = function(We) {
      var Xe = $t(We);
      if (Xe.length === 0)
        return new Ve(1);
      for (var rt = this || _global$6$1, ot = 0; ot < Xe.length && Xe[ot] === 0; ot++, rt = rt.sqr())
        ;
      if (++ot < Xe.length)
        for (var ft = rt.sqr(); ot < Xe.length; ot++, ft = ft.sqr())
          Xe[ot] !== 0 && (rt = rt.mul(ft));
      return rt;
    }, Ve.prototype.iushln = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 67108863 >>> 26 - Xe << 26 - Xe, ft;
      if (Xe !== 0) {
        var mt = 0;
        for (ft = 0; ft < (this || _global$6$1).length; ft++) {
          var yt = (this || _global$6$1).words[ft] & ot, pt = ((this || _global$6$1).words[ft] | 0) - yt << Xe;
          (this || _global$6$1).words[ft] = pt | mt, mt = yt >>> 26 - Xe;
        }
        mt && ((this || _global$6$1).words[ft] = mt, (this || _global$6$1).length++);
      }
      if (rt !== 0) {
        for (ft = (this || _global$6$1).length - 1; ft >= 0; ft--)
          (this || _global$6$1).words[ft + rt] = (this || _global$6$1).words[ft];
        for (ft = 0; ft < rt; ft++)
          (this || _global$6$1).words[ft] = 0;
        (this || _global$6$1).length += rt;
      }
      return this.strip();
    }, Ve.prototype.ishln = function(We) {
      return Fe((this || _global$6$1).negative === 0), this.iushln(We);
    }, Ve.prototype.iushrn = function(We, Xe, rt) {
      Fe(typeof We == "number" && We >= 0);
      var ot;
      Xe ? ot = (Xe - Xe % 26) / 26 : ot = 0;
      var ft = We % 26, mt = Math.min((We - ft) / 26, (this || _global$6$1).length), yt = 67108863 ^ 67108863 >>> ft << ft, pt = rt;
      if (ot -= mt, ot = Math.max(0, ot), pt) {
        for (var Ge = 0; Ge < mt; Ge++)
          pt.words[Ge] = (this || _global$6$1).words[Ge];
        pt.length = mt;
      }
      if (mt !== 0)
        if ((this || _global$6$1).length > mt)
          for ((this || _global$6$1).length -= mt, Ge = 0; Ge < (this || _global$6$1).length; Ge++)
            (this || _global$6$1).words[Ge] = (this || _global$6$1).words[Ge + mt];
        else
          (this || _global$6$1).words[0] = 0, (this || _global$6$1).length = 1;
      var ct = 0;
      for (Ge = (this || _global$6$1).length - 1; Ge >= 0 && (ct !== 0 || Ge >= ot); Ge--) {
        var Mt = (this || _global$6$1).words[Ge] | 0;
        (this || _global$6$1).words[Ge] = ct << 26 - ft | Mt >>> ft, ct = Mt & yt;
      }
      return pt && ct !== 0 && (pt.words[pt.length++] = ct), (this || _global$6$1).length === 0 && ((this || _global$6$1).words[0] = 0, (this || _global$6$1).length = 1), this.strip();
    }, Ve.prototype.ishrn = function(We, Xe, rt) {
      return Fe((this || _global$6$1).negative === 0), this.iushrn(We, Xe, rt);
    }, Ve.prototype.shln = function(We) {
      return this.clone().ishln(We);
    }, Ve.prototype.ushln = function(We) {
      return this.clone().iushln(We);
    }, Ve.prototype.shrn = function(We) {
      return this.clone().ishrn(We);
    }, Ve.prototype.ushrn = function(We) {
      return this.clone().iushrn(We);
    }, Ve.prototype.testn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$6$1).length <= rt)
        return !1;
      var ft = (this || _global$6$1).words[rt];
      return !!(ft & ot);
    }, Ve.prototype.imaskn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26;
      if (Fe((this || _global$6$1).negative === 0, "imaskn works only with positive numbers"), (this || _global$6$1).length <= rt)
        return this || _global$6$1;
      if (Xe !== 0 && rt++, (this || _global$6$1).length = Math.min(rt, (this || _global$6$1).length), Xe !== 0) {
        var ot = 67108863 ^ 67108863 >>> Xe << Xe;
        (this || _global$6$1).words[(this || _global$6$1).length - 1] &= ot;
      }
      return this.strip();
    }, Ve.prototype.maskn = function(We) {
      return this.clone().imaskn(We);
    }, Ve.prototype.iaddn = function(We) {
      return Fe(typeof We == "number"), Fe(We < 67108864), We < 0 ? this.isubn(-We) : (this || _global$6$1).negative !== 0 ? (this || _global$6$1).length === 1 && ((this || _global$6$1).words[0] | 0) < We ? ((this || _global$6$1).words[0] = We - ((this || _global$6$1).words[0] | 0), (this || _global$6$1).negative = 0, this || _global$6$1) : ((this || _global$6$1).negative = 0, this.isubn(We), (this || _global$6$1).negative = 1, this || _global$6$1) : this._iaddn(We);
    }, Ve.prototype._iaddn = function(We) {
      (this || _global$6$1).words[0] += We;
      for (var Xe = 0; Xe < (this || _global$6$1).length && (this || _global$6$1).words[Xe] >= 67108864; Xe++)
        (this || _global$6$1).words[Xe] -= 67108864, Xe === (this || _global$6$1).length - 1 ? (this || _global$6$1).words[Xe + 1] = 1 : (this || _global$6$1).words[Xe + 1]++;
      return (this || _global$6$1).length = Math.max((this || _global$6$1).length, Xe + 1), this || _global$6$1;
    }, Ve.prototype.isubn = function(We) {
      if (Fe(typeof We == "number"), Fe(We < 67108864), We < 0)
        return this.iaddn(-We);
      if ((this || _global$6$1).negative !== 0)
        return (this || _global$6$1).negative = 0, this.iaddn(We), (this || _global$6$1).negative = 1, this || _global$6$1;
      if ((this || _global$6$1).words[0] -= We, (this || _global$6$1).length === 1 && (this || _global$6$1).words[0] < 0)
        (this || _global$6$1).words[0] = -(this || _global$6$1).words[0], (this || _global$6$1).negative = 1;
      else
        for (var Xe = 0; Xe < (this || _global$6$1).length && (this || _global$6$1).words[Xe] < 0; Xe++)
          (this || _global$6$1).words[Xe] += 67108864, (this || _global$6$1).words[Xe + 1] -= 1;
      return this.strip();
    }, Ve.prototype.addn = function(We) {
      return this.clone().iaddn(We);
    }, Ve.prototype.subn = function(We) {
      return this.clone().isubn(We);
    }, Ve.prototype.iabs = function() {
      return (this || _global$6$1).negative = 0, this || _global$6$1;
    }, Ve.prototype.abs = function() {
      return this.clone().iabs();
    }, Ve.prototype._ishlnsubmul = function(We, Xe, rt) {
      var ot = We.length + rt, ft;
      this._expand(ot);
      var mt, yt = 0;
      for (ft = 0; ft < We.length; ft++) {
        mt = ((this || _global$6$1).words[ft + rt] | 0) + yt;
        var pt = (We.words[ft] | 0) * Xe;
        mt -= pt & 67108863, yt = (mt >> 26) - (pt / 67108864 | 0), (this || _global$6$1).words[ft + rt] = mt & 67108863;
      }
      for (; ft < (this || _global$6$1).length - rt; ft++)
        mt = ((this || _global$6$1).words[ft + rt] | 0) + yt, yt = mt >> 26, (this || _global$6$1).words[ft + rt] = mt & 67108863;
      if (yt === 0)
        return this.strip();
      for (Fe(yt === -1), yt = 0, ft = 0; ft < (this || _global$6$1).length; ft++)
        mt = -((this || _global$6$1).words[ft] | 0) + yt, yt = mt >> 26, (this || _global$6$1).words[ft] = mt & 67108863;
      return (this || _global$6$1).negative = 1, this.strip();
    }, Ve.prototype._wordDiv = function(We, Xe) {
      var rt = (this || _global$6$1).length - We.length, ot = this.clone(), ft = We, mt = ft.words[ft.length - 1] | 0, yt = this._countBits(mt);
      rt = 26 - yt, rt !== 0 && (ft = ft.ushln(rt), ot.iushln(rt), mt = ft.words[ft.length - 1] | 0);
      var pt = ot.length - ft.length, Ge;
      if (Xe !== "mod") {
        Ge = new Ve(null), Ge.length = pt + 1, Ge.words = new Array(Ge.length);
        for (var ct = 0; ct < Ge.length; ct++)
          Ge.words[ct] = 0;
      }
      var Mt = ot.clone()._ishlnsubmul(ft, 1, pt);
      Mt.negative === 0 && (ot = Mt, Ge && (Ge.words[pt] = 1));
      for (var St = pt - 1; St >= 0; St--) {
        var At = (ot.words[ft.length + St] | 0) * 67108864 + (ot.words[ft.length + St - 1] | 0);
        for (At = Math.min(At / mt | 0, 67108863), ot._ishlnsubmul(ft, At, St); ot.negative !== 0; )
          At--, ot.negative = 0, ot._ishlnsubmul(ft, 1, St), ot.isZero() || (ot.negative ^= 1);
        Ge && (Ge.words[St] = At);
      }
      return Ge && Ge.strip(), ot.strip(), Xe !== "div" && rt !== 0 && ot.iushrn(rt), {
        div: Ge || null,
        mod: ot
      };
    }, Ve.prototype.divmod = function(We, Xe, rt) {
      if (Fe(!We.isZero()), this.isZero())
        return {
          div: new Ve(0),
          mod: new Ve(0)
        };
      var ot, ft, mt;
      return (this || _global$6$1).negative !== 0 && We.negative === 0 ? (mt = this.neg().divmod(We, Xe), Xe !== "mod" && (ot = mt.div.neg()), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.iadd(We)), {
        div: ot,
        mod: ft
      }) : (this || _global$6$1).negative === 0 && We.negative !== 0 ? (mt = this.divmod(We.neg(), Xe), Xe !== "mod" && (ot = mt.div.neg()), {
        div: ot,
        mod: mt.mod
      }) : (this || _global$6$1).negative & We.negative ? (mt = this.neg().divmod(We.neg(), Xe), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.isub(We)), {
        div: mt.div,
        mod: ft
      }) : We.length > (this || _global$6$1).length || this.cmp(We) < 0 ? {
        div: new Ve(0),
        mod: this || _global$6$1
      } : We.length === 1 ? Xe === "div" ? {
        div: this.divn(We.words[0]),
        mod: null
      } : Xe === "mod" ? {
        div: null,
        mod: new Ve(this.modn(We.words[0]))
      } : {
        div: this.divn(We.words[0]),
        mod: new Ve(this.modn(We.words[0]))
      } : this._wordDiv(We, Xe);
    }, Ve.prototype.div = function(We) {
      return this.divmod(We, "div", !1).div;
    }, Ve.prototype.mod = function(We) {
      return this.divmod(We, "mod", !1).mod;
    }, Ve.prototype.umod = function(We) {
      return this.divmod(We, "mod", !0).mod;
    }, Ve.prototype.divRound = function(We) {
      var Xe = this.divmod(We);
      if (Xe.mod.isZero())
        return Xe.div;
      var rt = Xe.div.negative !== 0 ? Xe.mod.isub(We) : Xe.mod, ot = We.ushrn(1), ft = We.andln(1), mt = rt.cmp(ot);
      return mt < 0 || ft === 1 && mt === 0 ? Xe.div : Xe.div.negative !== 0 ? Xe.div.isubn(1) : Xe.div.iaddn(1);
    }, Ve.prototype.modn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = (1 << 26) % We, rt = 0, ot = (this || _global$6$1).length - 1; ot >= 0; ot--)
        rt = (Xe * rt + ((this || _global$6$1).words[ot] | 0)) % We;
      return rt;
    }, Ve.prototype.idivn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = 0, rt = (this || _global$6$1).length - 1; rt >= 0; rt--) {
        var ot = ((this || _global$6$1).words[rt] | 0) + Xe * 67108864;
        (this || _global$6$1).words[rt] = ot / We | 0, Xe = ot % We;
      }
      return this.strip();
    }, Ve.prototype.divn = function(We) {
      return this.clone().idivn(We);
    }, Ve.prototype.egcd = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$6$1, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = new Ve(0), yt = new Ve(1), pt = 0; Xe.isEven() && rt.isEven(); )
        Xe.iushrn(1), rt.iushrn(1), ++pt;
      for (var Ge = rt.clone(), ct = Xe.clone(); !Xe.isZero(); ) {
        for (var Mt = 0, St = 1; !(Xe.words[0] & St) && Mt < 26; ++Mt, St <<= 1)
          ;
        if (Mt > 0)
          for (Xe.iushrn(Mt); Mt-- > 0; )
            (ot.isOdd() || ft.isOdd()) && (ot.iadd(Ge), ft.isub(ct)), ot.iushrn(1), ft.iushrn(1);
        for (var At = 0, Nt = 1; !(rt.words[0] & Nt) && At < 26; ++At, Nt <<= 1)
          ;
        if (At > 0)
          for (rt.iushrn(At); At-- > 0; )
            (mt.isOdd() || yt.isOdd()) && (mt.iadd(Ge), yt.isub(ct)), mt.iushrn(1), yt.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(mt), ft.isub(yt)) : (rt.isub(Xe), mt.isub(ot), yt.isub(ft));
      }
      return {
        a: mt,
        b: yt,
        gcd: rt.iushln(pt)
      };
    }, Ve.prototype._invmp = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$6$1, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = rt.clone(); Xe.cmpn(1) > 0 && rt.cmpn(1) > 0; ) {
        for (var yt = 0, pt = 1; !(Xe.words[0] & pt) && yt < 26; ++yt, pt <<= 1)
          ;
        if (yt > 0)
          for (Xe.iushrn(yt); yt-- > 0; )
            ot.isOdd() && ot.iadd(mt), ot.iushrn(1);
        for (var Ge = 0, ct = 1; !(rt.words[0] & ct) && Ge < 26; ++Ge, ct <<= 1)
          ;
        if (Ge > 0)
          for (rt.iushrn(Ge); Ge-- > 0; )
            ft.isOdd() && ft.iadd(mt), ft.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(ft)) : (rt.isub(Xe), ft.isub(ot));
      }
      var Mt;
      return Xe.cmpn(1) === 0 ? Mt = ot : Mt = ft, Mt.cmpn(0) < 0 && Mt.iadd(We), Mt;
    }, Ve.prototype.gcd = function(We) {
      if (this.isZero())
        return We.abs();
      if (We.isZero())
        return this.abs();
      var Xe = this.clone(), rt = We.clone();
      Xe.negative = 0, rt.negative = 0;
      for (var ot = 0; Xe.isEven() && rt.isEven(); ot++)
        Xe.iushrn(1), rt.iushrn(1);
      do {
        for (; Xe.isEven(); )
          Xe.iushrn(1);
        for (; rt.isEven(); )
          rt.iushrn(1);
        var ft = Xe.cmp(rt);
        if (ft < 0) {
          var mt = Xe;
          Xe = rt, rt = mt;
        } else if (ft === 0 || rt.cmpn(1) === 0)
          break;
        Xe.isub(rt);
      } while (!0);
      return rt.iushln(ot);
    }, Ve.prototype.invm = function(We) {
      return this.egcd(We).a.umod(We);
    }, Ve.prototype.isEven = function() {
      return ((this || _global$6$1).words[0] & 1) === 0;
    }, Ve.prototype.isOdd = function() {
      return ((this || _global$6$1).words[0] & 1) === 1;
    }, Ve.prototype.andln = function(We) {
      return (this || _global$6$1).words[0] & We;
    }, Ve.prototype.bincn = function(We) {
      Fe(typeof We == "number");
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$6$1).length <= rt)
        return this._expand(rt + 1), (this || _global$6$1).words[rt] |= ot, this || _global$6$1;
      for (var ft = ot, mt = rt; ft !== 0 && mt < (this || _global$6$1).length; mt++) {
        var yt = (this || _global$6$1).words[mt] | 0;
        yt += ft, ft = yt >>> 26, yt &= 67108863, (this || _global$6$1).words[mt] = yt;
      }
      return ft !== 0 && ((this || _global$6$1).words[mt] = ft, (this || _global$6$1).length++), this || _global$6$1;
    }, Ve.prototype.isZero = function() {
      return (this || _global$6$1).length === 1 && (this || _global$6$1).words[0] === 0;
    }, Ve.prototype.cmpn = function(We) {
      var Xe = We < 0;
      if ((this || _global$6$1).negative !== 0 && !Xe)
        return -1;
      if ((this || _global$6$1).negative === 0 && Xe)
        return 1;
      this.strip();
      var rt;
      if ((this || _global$6$1).length > 1)
        rt = 1;
      else {
        Xe && (We = -We), Fe(We <= 67108863, "Number is too big");
        var ot = (this || _global$6$1).words[0] | 0;
        rt = ot === We ? 0 : ot < We ? -1 : 1;
      }
      return (this || _global$6$1).negative !== 0 ? -rt | 0 : rt;
    }, Ve.prototype.cmp = function(We) {
      if ((this || _global$6$1).negative !== 0 && We.negative === 0)
        return -1;
      if ((this || _global$6$1).negative === 0 && We.negative !== 0)
        return 1;
      var Xe = this.ucmp(We);
      return (this || _global$6$1).negative !== 0 ? -Xe | 0 : Xe;
    }, Ve.prototype.ucmp = function(We) {
      if ((this || _global$6$1).length > We.length)
        return 1;
      if ((this || _global$6$1).length < We.length)
        return -1;
      for (var Xe = 0, rt = (this || _global$6$1).length - 1; rt >= 0; rt--) {
        var ot = (this || _global$6$1).words[rt] | 0, ft = We.words[rt] | 0;
        if (ot !== ft) {
          ot < ft ? Xe = -1 : ot > ft && (Xe = 1);
          break;
        }
      }
      return Xe;
    }, Ve.prototype.gtn = function(We) {
      return this.cmpn(We) === 1;
    }, Ve.prototype.gt = function(We) {
      return this.cmp(We) === 1;
    }, Ve.prototype.gten = function(We) {
      return this.cmpn(We) >= 0;
    }, Ve.prototype.gte = function(We) {
      return this.cmp(We) >= 0;
    }, Ve.prototype.ltn = function(We) {
      return this.cmpn(We) === -1;
    }, Ve.prototype.lt = function(We) {
      return this.cmp(We) === -1;
    }, Ve.prototype.lten = function(We) {
      return this.cmpn(We) <= 0;
    }, Ve.prototype.lte = function(We) {
      return this.cmp(We) <= 0;
    }, Ve.prototype.eqn = function(We) {
      return this.cmpn(We) === 0;
    }, Ve.prototype.eq = function(We) {
      return this.cmp(We) === 0;
    }, Ve.red = function(We) {
      return new Ot(We);
    }, Ve.prototype.toRed = function(We) {
      return Fe(!(this || _global$6$1).red, "Already a number in reduction context"), Fe((this || _global$6$1).negative === 0, "red works only with positives"), We.convertTo(this || _global$6$1)._forceRed(We);
    }, Ve.prototype.fromRed = function() {
      return Fe((this || _global$6$1).red, "fromRed works only with numbers in reduction context"), (this || _global$6$1).red.convertFrom(this || _global$6$1);
    }, Ve.prototype._forceRed = function(We) {
      return (this || _global$6$1).red = We, this || _global$6$1;
    }, Ve.prototype.forceRed = function(We) {
      return Fe(!(this || _global$6$1).red, "Already a number in reduction context"), this._forceRed(We);
    }, Ve.prototype.redAdd = function(We) {
      return Fe((this || _global$6$1).red, "redAdd works only with red numbers"), (this || _global$6$1).red.add(this || _global$6$1, We);
    }, Ve.prototype.redIAdd = function(We) {
      return Fe((this || _global$6$1).red, "redIAdd works only with red numbers"), (this || _global$6$1).red.iadd(this || _global$6$1, We);
    }, Ve.prototype.redSub = function(We) {
      return Fe((this || _global$6$1).red, "redSub works only with red numbers"), (this || _global$6$1).red.sub(this || _global$6$1, We);
    }, Ve.prototype.redISub = function(We) {
      return Fe((this || _global$6$1).red, "redISub works only with red numbers"), (this || _global$6$1).red.isub(this || _global$6$1, We);
    }, Ve.prototype.redShl = function(We) {
      return Fe((this || _global$6$1).red, "redShl works only with red numbers"), (this || _global$6$1).red.shl(this || _global$6$1, We);
    }, Ve.prototype.redMul = function(We) {
      return Fe((this || _global$6$1).red, "redMul works only with red numbers"), (this || _global$6$1).red._verify2(this || _global$6$1, We), (this || _global$6$1).red.mul(this || _global$6$1, We);
    }, Ve.prototype.redIMul = function(We) {
      return Fe((this || _global$6$1).red, "redMul works only with red numbers"), (this || _global$6$1).red._verify2(this || _global$6$1, We), (this || _global$6$1).red.imul(this || _global$6$1, We);
    }, Ve.prototype.redSqr = function() {
      return Fe((this || _global$6$1).red, "redSqr works only with red numbers"), (this || _global$6$1).red._verify1(this || _global$6$1), (this || _global$6$1).red.sqr(this || _global$6$1);
    }, Ve.prototype.redISqr = function() {
      return Fe((this || _global$6$1).red, "redISqr works only with red numbers"), (this || _global$6$1).red._verify1(this || _global$6$1), (this || _global$6$1).red.isqr(this || _global$6$1);
    }, Ve.prototype.redSqrt = function() {
      return Fe((this || _global$6$1).red, "redSqrt works only with red numbers"), (this || _global$6$1).red._verify1(this || _global$6$1), (this || _global$6$1).red.sqrt(this || _global$6$1);
    }, Ve.prototype.redInvm = function() {
      return Fe((this || _global$6$1).red, "redInvm works only with red numbers"), (this || _global$6$1).red._verify1(this || _global$6$1), (this || _global$6$1).red.invm(this || _global$6$1);
    }, Ve.prototype.redNeg = function() {
      return Fe((this || _global$6$1).red, "redNeg works only with red numbers"), (this || _global$6$1).red._verify1(this || _global$6$1), (this || _global$6$1).red.neg(this || _global$6$1);
    }, Ve.prototype.redPow = function(We) {
      return Fe((this || _global$6$1).red && !We.red, "redPow(normalNum)"), (this || _global$6$1).red._verify1(this || _global$6$1), (this || _global$6$1).red.pow(this || _global$6$1, We);
    };
    var Rt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ct(gt, We) {
      (this || _global$6$1).name = gt, (this || _global$6$1).p = new Ve(We, 16), (this || _global$6$1).n = (this || _global$6$1).p.bitLength(), (this || _global$6$1).k = new Ve(1).iushln((this || _global$6$1).n).isub((this || _global$6$1).p), (this || _global$6$1).tmp = this._tmp();
    }
    Ct.prototype._tmp = function() {
      var We = new Ve(null);
      return We.words = new Array(Math.ceil((this || _global$6$1).n / 13)), We;
    }, Ct.prototype.ireduce = function(We) {
      var Xe = We, rt;
      do
        this.split(Xe, (this || _global$6$1).tmp), Xe = this.imulK(Xe), Xe = Xe.iadd((this || _global$6$1).tmp), rt = Xe.bitLength();
      while (rt > (this || _global$6$1).n);
      var ot = rt < (this || _global$6$1).n ? -1 : Xe.ucmp((this || _global$6$1).p);
      return ot === 0 ? (Xe.words[0] = 0, Xe.length = 1) : ot > 0 ? Xe.isub((this || _global$6$1).p) : Xe.strip !== void 0 ? Xe.strip() : Xe._strip(), Xe;
    }, Ct.prototype.split = function(We, Xe) {
      We.iushrn((this || _global$6$1).n, 0, Xe);
    }, Ct.prototype.imulK = function(We) {
      return We.imul((this || _global$6$1).k);
    };
    function Zt() {
      Ct.call(this || _global$6$1, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    Ke(Zt, Ct), Zt.prototype.split = function(We, Xe) {
      for (var rt = 4194303, ot = Math.min(We.length, 9), ft = 0; ft < ot; ft++)
        Xe.words[ft] = We.words[ft];
      if (Xe.length = ot, We.length <= 9) {
        We.words[0] = 0, We.length = 1;
        return;
      }
      var mt = We.words[9];
      for (Xe.words[Xe.length++] = mt & rt, ft = 10; ft < We.length; ft++) {
        var yt = We.words[ft] | 0;
        We.words[ft - 10] = (yt & rt) << 4 | mt >>> 22, mt = yt;
      }
      mt >>>= 22, We.words[ft - 10] = mt, mt === 0 && We.length > 10 ? We.length -= 10 : We.length -= 9;
    }, Zt.prototype.imulK = function(We) {
      We.words[We.length] = 0, We.words[We.length + 1] = 0, We.length += 2;
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = We.words[rt] | 0;
        Xe += ot * 977, We.words[rt] = Xe & 67108863, Xe = ot * 64 + (Xe / 67108864 | 0);
      }
      return We.words[We.length - 1] === 0 && (We.length--, We.words[We.length - 1] === 0 && We.length--), We;
    };
    function Lt() {
      Ct.call(this || _global$6$1, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    Ke(Lt, Ct);
    function Ut() {
      Ct.call(this || _global$6$1, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    Ke(Ut, Ct);
    function Pt() {
      Ct.call(this || _global$6$1, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    Ke(Pt, Ct), Pt.prototype.imulK = function(We) {
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = (We.words[rt] | 0) * 19 + Xe, ft = ot & 67108863;
        ot >>>= 26, We.words[rt] = ft, Xe = ot;
      }
      return Xe !== 0 && (We.words[We.length++] = Xe), We;
    }, Ve._prime = function(We) {
      if (Rt[We])
        return Rt[We];
      var Xe;
      if (We === "k256")
        Xe = new Zt();
      else if (We === "p224")
        Xe = new Lt();
      else if (We === "p192")
        Xe = new Ut();
      else if (We === "p25519")
        Xe = new Pt();
      else
        throw new Error("Unknown prime " + We);
      return Rt[We] = Xe, Xe;
    };
    function Ot(gt) {
      if (typeof gt == "string") {
        var We = Ve._prime(gt);
        (this || _global$6$1).m = We.p, (this || _global$6$1).prime = We;
      } else
        Fe(gt.gtn(1), "modulus must be greater than 1"), (this || _global$6$1).m = gt, (this || _global$6$1).prime = null;
    }
    Ot.prototype._verify1 = function(We) {
      Fe(We.negative === 0, "red works only with positives"), Fe(We.red, "red works only with red numbers");
    }, Ot.prototype._verify2 = function(We, Xe) {
      Fe((We.negative | Xe.negative) === 0, "red works only with positives"), Fe(We.red && We.red === Xe.red, "red works only with red numbers");
    }, Ot.prototype.imod = function(We) {
      return (this || _global$6$1).prime ? (this || _global$6$1).prime.ireduce(We)._forceRed(this || _global$6$1) : We.umod((this || _global$6$1).m)._forceRed(this || _global$6$1);
    }, Ot.prototype.neg = function(We) {
      return We.isZero() ? We.clone() : (this || _global$6$1).m.sub(We)._forceRed(this || _global$6$1);
    }, Ot.prototype.add = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.add(Xe);
      return rt.cmp((this || _global$6$1).m) >= 0 && rt.isub((this || _global$6$1).m), rt._forceRed(this || _global$6$1);
    }, Ot.prototype.iadd = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.iadd(Xe);
      return rt.cmp((this || _global$6$1).m) >= 0 && rt.isub((this || _global$6$1).m), rt;
    }, Ot.prototype.sub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.sub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$6$1).m), rt._forceRed(this || _global$6$1);
    }, Ot.prototype.isub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.isub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$6$1).m), rt;
    }, Ot.prototype.shl = function(We, Xe) {
      return this._verify1(We), this.imod(We.ushln(Xe));
    }, Ot.prototype.imul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.imul(Xe));
    }, Ot.prototype.mul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.mul(Xe));
    }, Ot.prototype.isqr = function(We) {
      return this.imul(We, We.clone());
    }, Ot.prototype.sqr = function(We) {
      return this.mul(We, We);
    }, Ot.prototype.sqrt = function(We) {
      if (We.isZero())
        return We.clone();
      var Xe = (this || _global$6$1).m.andln(3);
      if (Fe(Xe % 2 === 1), Xe === 3) {
        var rt = (this || _global$6$1).m.add(new Ve(1)).iushrn(2);
        return this.pow(We, rt);
      }
      for (var ot = (this || _global$6$1).m.subn(1), ft = 0; !ot.isZero() && ot.andln(1) === 0; )
        ft++, ot.iushrn(1);
      Fe(!ot.isZero());
      var mt = new Ve(1).toRed(this || _global$6$1), yt = mt.redNeg(), pt = (this || _global$6$1).m.subn(1).iushrn(1), Ge = (this || _global$6$1).m.bitLength();
      for (Ge = new Ve(2 * Ge * Ge).toRed(this || _global$6$1); this.pow(Ge, pt).cmp(yt) !== 0; )
        Ge.redIAdd(yt);
      for (var ct = this.pow(Ge, ot), Mt = this.pow(We, ot.addn(1).iushrn(1)), St = this.pow(We, ot), At = ft; St.cmp(mt) !== 0; ) {
        for (var Nt = St, qt = 0; Nt.cmp(mt) !== 0; qt++)
          Nt = Nt.redSqr();
        Fe(qt < At);
        var Qt = this.pow(ct, new Ve(1).iushln(At - qt - 1));
        Mt = Mt.redMul(Qt), ct = Qt.redSqr(), St = St.redMul(ct), At = qt;
      }
      return Mt;
    }, Ot.prototype.invm = function(We) {
      var Xe = We._invmp((this || _global$6$1).m);
      return Xe.negative !== 0 ? (Xe.negative = 0, this.imod(Xe).redNeg()) : this.imod(Xe);
    }, Ot.prototype.pow = function(We, Xe) {
      if (Xe.isZero())
        return new Ve(1).toRed(this || _global$6$1);
      if (Xe.cmpn(1) === 0)
        return We.clone();
      var rt = 4, ot = new Array(1 << rt);
      ot[0] = new Ve(1).toRed(this || _global$6$1), ot[1] = We;
      for (var ft = 2; ft < ot.length; ft++)
        ot[ft] = this.mul(ot[ft - 1], We);
      var mt = ot[0], yt = 0, pt = 0, Ge = Xe.bitLength() % 26;
      for (Ge === 0 && (Ge = 26), ft = Xe.length - 1; ft >= 0; ft--) {
        for (var ct = Xe.words[ft], Mt = Ge - 1; Mt >= 0; Mt--) {
          var St = ct >> Mt & 1;
          if (mt !== ot[0] && (mt = this.sqr(mt)), St === 0 && yt === 0) {
            pt = 0;
            continue;
          }
          yt <<= 1, yt |= St, pt++, !(pt !== rt && (ft !== 0 || Mt !== 0)) && (mt = this.mul(mt, ot[yt]), pt = 0, yt = 0);
        }
        Ge = 26;
      }
      return mt;
    }, Ot.prototype.convertTo = function(We) {
      var Xe = We.umod((this || _global$6$1).m);
      return Xe === We ? Xe.clone() : Xe;
    }, Ot.prototype.convertFrom = function(We) {
      var Xe = We.clone();
      return Xe.red = null, Xe;
    }, Ve.mont = function(We) {
      return new Ft(We);
    };
    function Ft(gt) {
      Ot.call(this || _global$6$1, gt), (this || _global$6$1).shift = (this || _global$6$1).m.bitLength(), (this || _global$6$1).shift % 26 !== 0 && ((this || _global$6$1).shift += 26 - (this || _global$6$1).shift % 26), (this || _global$6$1).r = new Ve(1).iushln((this || _global$6$1).shift), (this || _global$6$1).r2 = this.imod((this || _global$6$1).r.sqr()), (this || _global$6$1).rinv = (this || _global$6$1).r._invmp((this || _global$6$1).m), (this || _global$6$1).minv = (this || _global$6$1).rinv.mul((this || _global$6$1).r).isubn(1).div((this || _global$6$1).m), (this || _global$6$1).minv = (this || _global$6$1).minv.umod((this || _global$6$1).r), (this || _global$6$1).minv = (this || _global$6$1).r.sub((this || _global$6$1).minv);
    }
    Ke(Ft, Ot), Ft.prototype.convertTo = function(We) {
      return this.imod(We.ushln((this || _global$6$1).shift));
    }, Ft.prototype.convertFrom = function(We) {
      var Xe = this.imod(We.mul((this || _global$6$1).rinv));
      return Xe.red = null, Xe;
    }, Ft.prototype.imul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return We.words[0] = 0, We.length = 1, We;
      var rt = We.imul(Xe), ot = rt.maskn((this || _global$6$1).shift).mul((this || _global$6$1).minv).imaskn((this || _global$6$1).shift).mul((this || _global$6$1).m), ft = rt.isub(ot).iushrn((this || _global$6$1).shift), mt = ft;
      return ft.cmp((this || _global$6$1).m) >= 0 ? mt = ft.isub((this || _global$6$1).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$6$1).m)), mt._forceRed(this || _global$6$1);
    }, Ft.prototype.mul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return new Ve(0)._forceRed(this || _global$6$1);
      var rt = We.mul(Xe), ot = rt.maskn((this || _global$6$1).shift).mul((this || _global$6$1).minv).imaskn((this || _global$6$1).shift).mul((this || _global$6$1).m), ft = rt.isub(ot).iushrn((this || _global$6$1).shift), mt = ft;
      return ft.cmp((this || _global$6$1).m) >= 0 ? mt = ft.isub((this || _global$6$1).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$6$1).m)), mt._forceRed(this || _global$6$1);
    }, Ft.prototype.invm = function(We) {
      var Xe = this.imod(We._invmp((this || _global$6$1).m).mul((this || _global$6$1).r2));
      return Xe._forceRed(this || _global$6$1);
    };
  }(module$3$1, exports$V$1)), module$3$1.exports;
}
var exports$U$1 = {}, _dewExec$U$1 = !1;
function dew$U$1() {
  if (_dewExec$U$1)
    return exports$U$1;
  _dewExec$U$1 = !0;
  var $e = exports$U$1;
  function Ze(Ve, Je) {
    if (Array.isArray(Ve))
      return Ve.slice();
    if (!Ve)
      return [];
    var Qe = [];
    if (typeof Ve != "string") {
      for (var at = 0; at < Ve.length; at++)
        Qe[at] = Ve[at] | 0;
      return Qe;
    }
    if (Je === "hex") {
      Ve = Ve.replace(/[^a-z0-9]+/ig, ""), Ve.length % 2 !== 0 && (Ve = "0" + Ve);
      for (var at = 0; at < Ve.length; at += 2)
        Qe.push(parseInt(Ve[at] + Ve[at + 1], 16));
    } else
      for (var at = 0; at < Ve.length; at++) {
        var ut = Ve.charCodeAt(at), lt = ut >> 8, dt = ut & 255;
        lt ? Qe.push(lt, dt) : Qe.push(dt);
      }
    return Qe;
  }
  $e.toArray = Ze;
  function Fe(Ve) {
    return Ve.length === 1 ? "0" + Ve : Ve;
  }
  $e.zero2 = Fe;
  function Ke(Ve) {
    for (var Je = "", Qe = 0; Qe < Ve.length; Qe++)
      Je += Fe(Ve[Qe].toString(16));
    return Je;
  }
  return $e.toHex = Ke, $e.encode = function(Je, Qe) {
    return Qe === "hex" ? Ke(Je) : Je;
  }, exports$U$1;
}
var exports$T$1 = {}, _dewExec$T$1 = !1;
function dew$T$1() {
  if (_dewExec$T$1)
    return exports$T$1;
  _dewExec$T$1 = !0;
  var $e = exports$T$1, Ze = dew$V$1(), Fe = dew$1t(), Ke = dew$U$1();
  $e.assert = Fe, $e.toArray = Ke.toArray, $e.zero2 = Ke.zero2, $e.toHex = Ke.toHex, $e.encode = Ke.encode;
  function Ve(lt, dt, bt) {
    var $t = new Array(Math.max(lt.bitLength(), bt) + 1);
    $t.fill(0);
    for (var vt = 1 << dt + 1, wt = lt.clone(), xt = 0; xt < $t.length; xt++) {
      var Et, Tt = wt.andln(vt - 1);
      wt.isOdd() ? (Tt > (vt >> 1) - 1 ? Et = (vt >> 1) - Tt : Et = Tt, wt.isubn(Et)) : Et = 0, $t[xt] = Et, wt.iushrn(1);
    }
    return $t;
  }
  $e.getNAF = Ve;
  function Je(lt, dt) {
    var bt = [[], []];
    lt = lt.clone(), dt = dt.clone();
    for (var $t = 0, vt = 0, wt; lt.cmpn(-$t) > 0 || dt.cmpn(-vt) > 0; ) {
      var xt = lt.andln(3) + $t & 3, Et = dt.andln(3) + vt & 3;
      xt === 3 && (xt = -1), Et === 3 && (Et = -1);
      var Tt;
      xt & 1 ? (wt = lt.andln(7) + $t & 7, (wt === 3 || wt === 5) && Et === 2 ? Tt = -xt : Tt = xt) : Tt = 0, bt[0].push(Tt);
      var Rt;
      Et & 1 ? (wt = dt.andln(7) + vt & 7, (wt === 3 || wt === 5) && xt === 2 ? Rt = -Et : Rt = Et) : Rt = 0, bt[1].push(Rt), 2 * $t === Tt + 1 && ($t = 1 - $t), 2 * vt === Rt + 1 && (vt = 1 - vt), lt.iushrn(1), dt.iushrn(1);
    }
    return bt;
  }
  $e.getJSF = Je;
  function Qe(lt, dt, bt) {
    var $t = "_" + dt;
    lt.prototype[dt] = function() {
      return this[$t] !== void 0 ? this[$t] : this[$t] = bt.call(this);
    };
  }
  $e.cachedProperty = Qe;
  function at(lt) {
    return typeof lt == "string" ? $e.toArray(lt, "hex") : lt;
  }
  $e.parseBytes = at;
  function ut(lt) {
    return new Ze(lt, "hex", "le");
  }
  return $e.intFromLE = ut, exports$T$1;
}
var exports$S$1 = {}, _dewExec$S$1 = !1;
function dew$S$1() {
  if (_dewExec$S$1)
    return exports$S$1;
  _dewExec$S$1 = !0;
  var $e = dew$V$1(), Ze = dew$T$1(), Fe = Ze.getNAF, Ke = Ze.getJSF, Ve = Ze.assert;
  function Je(at, ut) {
    this.type = at, this.p = new $e(ut.p, 16), this.red = ut.prime ? $e.red(ut.prime) : $e.mont(this.p), this.zero = new $e(0).toRed(this.red), this.one = new $e(1).toRed(this.red), this.two = new $e(2).toRed(this.red), this.n = ut.n && new $e(ut.n, 16), this.g = ut.g && this.pointFromJSON(ut.g, ut.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var lt = this.n && this.p.div(this.n);
    !lt || lt.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  exports$S$1 = Je, Je.prototype.point = function() {
    throw new Error("Not implemented");
  }, Je.prototype.validate = function() {
    throw new Error("Not implemented");
  }, Je.prototype._fixedNafMul = function(ut, lt) {
    Ve(ut.precomputed);
    var dt = ut._getDoubles(), bt = Fe(lt, 1, this._bitLength), $t = (1 << dt.step + 1) - (dt.step % 2 === 0 ? 2 : 1);
    $t /= 3;
    var vt = [], wt, xt;
    for (wt = 0; wt < bt.length; wt += dt.step) {
      xt = 0;
      for (var Et = wt + dt.step - 1; Et >= wt; Et--)
        xt = (xt << 1) + bt[Et];
      vt.push(xt);
    }
    for (var Tt = this.jpoint(null, null, null), Rt = this.jpoint(null, null, null), Ct = $t; Ct > 0; Ct--) {
      for (wt = 0; wt < vt.length; wt++)
        xt = vt[wt], xt === Ct ? Rt = Rt.mixedAdd(dt.points[wt]) : xt === -Ct && (Rt = Rt.mixedAdd(dt.points[wt].neg()));
      Tt = Tt.add(Rt);
    }
    return Tt.toP();
  }, Je.prototype._wnafMul = function(ut, lt) {
    var dt = 4, bt = ut._getNAFPoints(dt);
    dt = bt.wnd;
    for (var $t = bt.points, vt = Fe(lt, dt, this._bitLength), wt = this.jpoint(null, null, null), xt = vt.length - 1; xt >= 0; xt--) {
      for (var Et = 0; xt >= 0 && vt[xt] === 0; xt--)
        Et++;
      if (xt >= 0 && Et++, wt = wt.dblp(Et), xt < 0)
        break;
      var Tt = vt[xt];
      Ve(Tt !== 0), ut.type === "affine" ? Tt > 0 ? wt = wt.mixedAdd($t[Tt - 1 >> 1]) : wt = wt.mixedAdd($t[-Tt - 1 >> 1].neg()) : Tt > 0 ? wt = wt.add($t[Tt - 1 >> 1]) : wt = wt.add($t[-Tt - 1 >> 1].neg());
    }
    return ut.type === "affine" ? wt.toP() : wt;
  }, Je.prototype._wnafMulAdd = function(ut, lt, dt, bt, $t) {
    var vt = this._wnafT1, wt = this._wnafT2, xt = this._wnafT3, Et = 0, Tt, Rt, Ct;
    for (Tt = 0; Tt < bt; Tt++) {
      Ct = lt[Tt];
      var Zt = Ct._getNAFPoints(ut);
      vt[Tt] = Zt.wnd, wt[Tt] = Zt.points;
    }
    for (Tt = bt - 1; Tt >= 1; Tt -= 2) {
      var Lt = Tt - 1, Ut = Tt;
      if (vt[Lt] !== 1 || vt[Ut] !== 1) {
        xt[Lt] = Fe(dt[Lt], vt[Lt], this._bitLength), xt[Ut] = Fe(dt[Ut], vt[Ut], this._bitLength), Et = Math.max(xt[Lt].length, Et), Et = Math.max(xt[Ut].length, Et);
        continue;
      }
      var Pt = [
        lt[Lt],
        null,
        null,
        lt[Ut]
      ];
      lt[Lt].y.cmp(lt[Ut].y) === 0 ? (Pt[1] = lt[Lt].add(lt[Ut]), Pt[2] = lt[Lt].toJ().mixedAdd(lt[Ut].neg())) : lt[Lt].y.cmp(lt[Ut].y.redNeg()) === 0 ? (Pt[1] = lt[Lt].toJ().mixedAdd(lt[Ut]), Pt[2] = lt[Lt].add(lt[Ut].neg())) : (Pt[1] = lt[Lt].toJ().mixedAdd(lt[Ut]), Pt[2] = lt[Lt].toJ().mixedAdd(lt[Ut].neg()));
      var Ot = [
        -3,
        -1,
        -5,
        -7,
        0,
        7,
        5,
        1,
        3
      ], Ft = Ke(dt[Lt], dt[Ut]);
      for (Et = Math.max(Ft[0].length, Et), xt[Lt] = new Array(Et), xt[Ut] = new Array(Et), Rt = 0; Rt < Et; Rt++) {
        var gt = Ft[0][Rt] | 0, We = Ft[1][Rt] | 0;
        xt[Lt][Rt] = Ot[(gt + 1) * 3 + (We + 1)], xt[Ut][Rt] = 0, wt[Lt] = Pt;
      }
    }
    var Xe = this.jpoint(null, null, null), rt = this._wnafT4;
    for (Tt = Et; Tt >= 0; Tt--) {
      for (var ot = 0; Tt >= 0; ) {
        var ft = !0;
        for (Rt = 0; Rt < bt; Rt++)
          rt[Rt] = xt[Rt][Tt] | 0, rt[Rt] !== 0 && (ft = !1);
        if (!ft)
          break;
        ot++, Tt--;
      }
      if (Tt >= 0 && ot++, Xe = Xe.dblp(ot), Tt < 0)
        break;
      for (Rt = 0; Rt < bt; Rt++) {
        var mt = rt[Rt];
        mt !== 0 && (mt > 0 ? Ct = wt[Rt][mt - 1 >> 1] : mt < 0 && (Ct = wt[Rt][-mt - 1 >> 1].neg()), Ct.type === "affine" ? Xe = Xe.mixedAdd(Ct) : Xe = Xe.add(Ct));
      }
    }
    for (Tt = 0; Tt < bt; Tt++)
      wt[Tt] = null;
    return $t ? Xe : Xe.toP();
  };
  function Qe(at, ut) {
    this.curve = at, this.type = ut, this.precomputed = null;
  }
  return Je.BasePoint = Qe, Qe.prototype.eq = function() {
    throw new Error("Not implemented");
  }, Qe.prototype.validate = function() {
    return this.curve.validate(this);
  }, Je.prototype.decodePoint = function(ut, lt) {
    ut = Ze.toArray(ut, lt);
    var dt = this.p.byteLength();
    if ((ut[0] === 4 || ut[0] === 6 || ut[0] === 7) && ut.length - 1 === 2 * dt) {
      ut[0] === 6 ? Ve(ut[ut.length - 1] % 2 === 0) : ut[0] === 7 && Ve(ut[ut.length - 1] % 2 === 1);
      var bt = this.point(ut.slice(1, 1 + dt), ut.slice(1 + dt, 1 + 2 * dt));
      return bt;
    } else if ((ut[0] === 2 || ut[0] === 3) && ut.length - 1 === dt)
      return this.pointFromX(ut.slice(1, 1 + dt), ut[0] === 3);
    throw new Error("Unknown point format");
  }, Qe.prototype.encodeCompressed = function(ut) {
    return this.encode(ut, !0);
  }, Qe.prototype._encode = function(ut) {
    var lt = this.curve.p.byteLength(), dt = this.getX().toArray("be", lt);
    return ut ? [this.getY().isEven() ? 2 : 3].concat(dt) : [4].concat(dt, this.getY().toArray("be", lt));
  }, Qe.prototype.encode = function(ut, lt) {
    return Ze.encode(this._encode(lt), ut);
  }, Qe.prototype.precompute = function(ut) {
    if (this.precomputed)
      return this;
    var lt = {
      doubles: null,
      naf: null,
      beta: null
    };
    return lt.naf = this._getNAFPoints(8), lt.doubles = this._getDoubles(4, ut), lt.beta = this._getBeta(), this.precomputed = lt, this;
  }, Qe.prototype._hasDoubles = function(ut) {
    if (!this.precomputed)
      return !1;
    var lt = this.precomputed.doubles;
    return lt ? lt.points.length >= Math.ceil((ut.bitLength() + 1) / lt.step) : !1;
  }, Qe.prototype._getDoubles = function(ut, lt) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var dt = [this], bt = this, $t = 0; $t < lt; $t += ut) {
      for (var vt = 0; vt < ut; vt++)
        bt = bt.dbl();
      dt.push(bt);
    }
    return {
      step: ut,
      points: dt
    };
  }, Qe.prototype._getNAFPoints = function(ut) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var lt = [this], dt = (1 << ut) - 1, bt = dt === 1 ? null : this.dbl(), $t = 1; $t < dt; $t++)
      lt[$t] = lt[$t - 1].add(bt);
    return {
      wnd: ut,
      points: lt
    };
  }, Qe.prototype._getBeta = function() {
    return null;
  }, Qe.prototype.dblp = function(ut) {
    for (var lt = this, dt = 0; dt < ut; dt++)
      lt = lt.dbl();
    return lt;
  }, exports$S$1;
}
var exports$R$1 = {}, _dewExec$R$1 = !1;
function dew$R$1() {
  if (_dewExec$R$1)
    return exports$R$1;
  _dewExec$R$1 = !0;
  var $e = dew$T$1(), Ze = dew$V$1(), Fe = dew$f$2(), Ke = dew$S$1(), Ve = $e.assert;
  function Je(ut) {
    Ke.call(this, "short", ut), this.a = new Ze(ut.a, 16).toRed(this.red), this.b = new Ze(ut.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(ut), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  Fe(Je, Ke), exports$R$1 = Je, Je.prototype._getEndomorphism = function(lt) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var dt, bt;
      if (lt.beta)
        dt = new Ze(lt.beta, 16).toRed(this.red);
      else {
        var $t = this._getEndoRoots(this.p);
        dt = $t[0].cmp($t[1]) < 0 ? $t[0] : $t[1], dt = dt.toRed(this.red);
      }
      if (lt.lambda)
        bt = new Ze(lt.lambda, 16);
      else {
        var vt = this._getEndoRoots(this.n);
        this.g.mul(vt[0]).x.cmp(this.g.x.redMul(dt)) === 0 ? bt = vt[0] : (bt = vt[1], Ve(this.g.mul(bt).x.cmp(this.g.x.redMul(dt)) === 0));
      }
      var wt;
      return lt.basis ? wt = lt.basis.map(function(xt) {
        return {
          a: new Ze(xt.a, 16),
          b: new Ze(xt.b, 16)
        };
      }) : wt = this._getEndoBasis(bt), {
        beta: dt,
        lambda: bt,
        basis: wt
      };
    }
  }, Je.prototype._getEndoRoots = function(lt) {
    var dt = lt === this.p ? this.red : Ze.mont(lt), bt = new Ze(2).toRed(dt).redInvm(), $t = bt.redNeg(), vt = new Ze(3).toRed(dt).redNeg().redSqrt().redMul(bt), wt = $t.redAdd(vt).fromRed(), xt = $t.redSub(vt).fromRed();
    return [wt, xt];
  }, Je.prototype._getEndoBasis = function(lt) {
    for (var dt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), bt = lt, $t = this.n.clone(), vt = new Ze(1), wt = new Ze(0), xt = new Ze(0), Et = new Ze(1), Tt, Rt, Ct, Zt, Lt, Ut, Pt, Ot = 0, Ft, gt; bt.cmpn(0) !== 0; ) {
      var We = $t.div(bt);
      Ft = $t.sub(We.mul(bt)), gt = xt.sub(We.mul(vt));
      var Xe = Et.sub(We.mul(wt));
      if (!Ct && Ft.cmp(dt) < 0)
        Tt = Pt.neg(), Rt = vt, Ct = Ft.neg(), Zt = gt;
      else if (Ct && ++Ot === 2)
        break;
      Pt = Ft, $t = bt, bt = Ft, xt = vt, vt = gt, Et = wt, wt = Xe;
    }
    Lt = Ft.neg(), Ut = gt;
    var rt = Ct.sqr().add(Zt.sqr()), ot = Lt.sqr().add(Ut.sqr());
    return ot.cmp(rt) >= 0 && (Lt = Tt, Ut = Rt), Ct.negative && (Ct = Ct.neg(), Zt = Zt.neg()), Lt.negative && (Lt = Lt.neg(), Ut = Ut.neg()), [{
      a: Ct,
      b: Zt
    }, {
      a: Lt,
      b: Ut
    }];
  }, Je.prototype._endoSplit = function(lt) {
    var dt = this.endo.basis, bt = dt[0], $t = dt[1], vt = $t.b.mul(lt).divRound(this.n), wt = bt.b.neg().mul(lt).divRound(this.n), xt = vt.mul(bt.a), Et = wt.mul($t.a), Tt = vt.mul(bt.b), Rt = wt.mul($t.b), Ct = lt.sub(xt).sub(Et), Zt = Tt.add(Rt).neg();
    return {
      k1: Ct,
      k2: Zt
    };
  }, Je.prototype.pointFromX = function(lt, dt) {
    lt = new Ze(lt, 16), lt.red || (lt = lt.toRed(this.red));
    var bt = lt.redSqr().redMul(lt).redIAdd(lt.redMul(this.a)).redIAdd(this.b), $t = bt.redSqrt();
    if ($t.redSqr().redSub(bt).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var vt = $t.fromRed().isOdd();
    return (dt && !vt || !dt && vt) && ($t = $t.redNeg()), this.point(lt, $t);
  }, Je.prototype.validate = function(lt) {
    if (lt.inf)
      return !0;
    var dt = lt.x, bt = lt.y, $t = this.a.redMul(dt), vt = dt.redSqr().redMul(dt).redIAdd($t).redIAdd(this.b);
    return bt.redSqr().redISub(vt).cmpn(0) === 0;
  }, Je.prototype._endoWnafMulAdd = function(lt, dt, bt) {
    for (var $t = this._endoWnafT1, vt = this._endoWnafT2, wt = 0; wt < lt.length; wt++) {
      var xt = this._endoSplit(dt[wt]), Et = lt[wt], Tt = Et._getBeta();
      xt.k1.negative && (xt.k1.ineg(), Et = Et.neg(!0)), xt.k2.negative && (xt.k2.ineg(), Tt = Tt.neg(!0)), $t[wt * 2] = Et, $t[wt * 2 + 1] = Tt, vt[wt * 2] = xt.k1, vt[wt * 2 + 1] = xt.k2;
    }
    for (var Rt = this._wnafMulAdd(1, $t, vt, wt * 2, bt), Ct = 0; Ct < wt * 2; Ct++)
      $t[Ct] = null, vt[Ct] = null;
    return Rt;
  };
  function Qe(ut, lt, dt, bt) {
    Ke.BasePoint.call(this, ut, "affine"), lt === null && dt === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new Ze(lt, 16), this.y = new Ze(dt, 16), bt && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  Fe(Qe, Ke.BasePoint), Je.prototype.point = function(lt, dt, bt) {
    return new Qe(this, lt, dt, bt);
  }, Je.prototype.pointFromJSON = function(lt, dt) {
    return Qe.fromJSON(this, lt, dt);
  }, Qe.prototype._getBeta = function() {
    if (this.curve.endo) {
      var lt = this.precomputed;
      if (lt && lt.beta)
        return lt.beta;
      var dt = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (lt) {
        var bt = this.curve, $t = function(vt) {
          return bt.point(vt.x.redMul(bt.endo.beta), vt.y);
        };
        lt.beta = dt, dt.precomputed = {
          beta: null,
          naf: lt.naf && {
            wnd: lt.naf.wnd,
            points: lt.naf.points.map($t)
          },
          doubles: lt.doubles && {
            step: lt.doubles.step,
            points: lt.doubles.points.map($t)
          }
        };
      }
      return dt;
    }
  }, Qe.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, Qe.fromJSON = function(lt, dt, bt) {
    typeof dt == "string" && (dt = JSON.parse(dt));
    var $t = lt.point(dt[0], dt[1], bt);
    if (!dt[2])
      return $t;
    function vt(xt) {
      return lt.point(xt[0], xt[1], bt);
    }
    var wt = dt[2];
    return $t.precomputed = {
      beta: null,
      doubles: wt.doubles && {
        step: wt.doubles.step,
        points: [$t].concat(wt.doubles.points.map(vt))
      },
      naf: wt.naf && {
        wnd: wt.naf.wnd,
        points: [$t].concat(wt.naf.points.map(vt))
      }
    }, $t;
  }, Qe.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, Qe.prototype.isInfinity = function() {
    return this.inf;
  }, Qe.prototype.add = function(lt) {
    if (this.inf)
      return lt;
    if (lt.inf)
      return this;
    if (this.eq(lt))
      return this.dbl();
    if (this.neg().eq(lt))
      return this.curve.point(null, null);
    if (this.x.cmp(lt.x) === 0)
      return this.curve.point(null, null);
    var dt = this.y.redSub(lt.y);
    dt.cmpn(0) !== 0 && (dt = dt.redMul(this.x.redSub(lt.x).redInvm()));
    var bt = dt.redSqr().redISub(this.x).redISub(lt.x), $t = dt.redMul(this.x.redSub(bt)).redISub(this.y);
    return this.curve.point(bt, $t);
  }, Qe.prototype.dbl = function() {
    if (this.inf)
      return this;
    var lt = this.y.redAdd(this.y);
    if (lt.cmpn(0) === 0)
      return this.curve.point(null, null);
    var dt = this.curve.a, bt = this.x.redSqr(), $t = lt.redInvm(), vt = bt.redAdd(bt).redIAdd(bt).redIAdd(dt).redMul($t), wt = vt.redSqr().redISub(this.x.redAdd(this.x)), xt = vt.redMul(this.x.redSub(wt)).redISub(this.y);
    return this.curve.point(wt, xt);
  }, Qe.prototype.getX = function() {
    return this.x.fromRed();
  }, Qe.prototype.getY = function() {
    return this.y.fromRed();
  }, Qe.prototype.mul = function(lt) {
    return lt = new Ze(lt, 16), this.isInfinity() ? this : this._hasDoubles(lt) ? this.curve._fixedNafMul(this, lt) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [lt]) : this.curve._wnafMul(this, lt);
  }, Qe.prototype.mulAdd = function(lt, dt, bt) {
    var $t = [this, dt], vt = [lt, bt];
    return this.curve.endo ? this.curve._endoWnafMulAdd($t, vt) : this.curve._wnafMulAdd(1, $t, vt, 2);
  }, Qe.prototype.jmulAdd = function(lt, dt, bt) {
    var $t = [this, dt], vt = [lt, bt];
    return this.curve.endo ? this.curve._endoWnafMulAdd($t, vt, !0) : this.curve._wnafMulAdd(1, $t, vt, 2, !0);
  }, Qe.prototype.eq = function(lt) {
    return this === lt || this.inf === lt.inf && (this.inf || this.x.cmp(lt.x) === 0 && this.y.cmp(lt.y) === 0);
  }, Qe.prototype.neg = function(lt) {
    if (this.inf)
      return this;
    var dt = this.curve.point(this.x, this.y.redNeg());
    if (lt && this.precomputed) {
      var bt = this.precomputed, $t = function(vt) {
        return vt.neg();
      };
      dt.precomputed = {
        naf: bt.naf && {
          wnd: bt.naf.wnd,
          points: bt.naf.points.map($t)
        },
        doubles: bt.doubles && {
          step: bt.doubles.step,
          points: bt.doubles.points.map($t)
        }
      };
    }
    return dt;
  }, Qe.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var lt = this.curve.jpoint(this.x, this.y, this.curve.one);
    return lt;
  };
  function at(ut, lt, dt, bt) {
    Ke.BasePoint.call(this, ut, "jacobian"), lt === null && dt === null && bt === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new Ze(0)) : (this.x = new Ze(lt, 16), this.y = new Ze(dt, 16), this.z = new Ze(bt, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return Fe(at, Ke.BasePoint), Je.prototype.jpoint = function(lt, dt, bt) {
    return new at(this, lt, dt, bt);
  }, at.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var lt = this.z.redInvm(), dt = lt.redSqr(), bt = this.x.redMul(dt), $t = this.y.redMul(dt).redMul(lt);
    return this.curve.point(bt, $t);
  }, at.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, at.prototype.add = function(lt) {
    if (this.isInfinity())
      return lt;
    if (lt.isInfinity())
      return this;
    var dt = lt.z.redSqr(), bt = this.z.redSqr(), $t = this.x.redMul(dt), vt = lt.x.redMul(bt), wt = this.y.redMul(dt.redMul(lt.z)), xt = lt.y.redMul(bt.redMul(this.z)), Et = $t.redSub(vt), Tt = wt.redSub(xt);
    if (Et.cmpn(0) === 0)
      return Tt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var Rt = Et.redSqr(), Ct = Rt.redMul(Et), Zt = $t.redMul(Rt), Lt = Tt.redSqr().redIAdd(Ct).redISub(Zt).redISub(Zt), Ut = Tt.redMul(Zt.redISub(Lt)).redISub(wt.redMul(Ct)), Pt = this.z.redMul(lt.z).redMul(Et);
    return this.curve.jpoint(Lt, Ut, Pt);
  }, at.prototype.mixedAdd = function(lt) {
    if (this.isInfinity())
      return lt.toJ();
    if (lt.isInfinity())
      return this;
    var dt = this.z.redSqr(), bt = this.x, $t = lt.x.redMul(dt), vt = this.y, wt = lt.y.redMul(dt).redMul(this.z), xt = bt.redSub($t), Et = vt.redSub(wt);
    if (xt.cmpn(0) === 0)
      return Et.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var Tt = xt.redSqr(), Rt = Tt.redMul(xt), Ct = bt.redMul(Tt), Zt = Et.redSqr().redIAdd(Rt).redISub(Ct).redISub(Ct), Lt = Et.redMul(Ct.redISub(Zt)).redISub(vt.redMul(Rt)), Ut = this.z.redMul(xt);
    return this.curve.jpoint(Zt, Lt, Ut);
  }, at.prototype.dblp = function(lt) {
    if (lt === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!lt)
      return this.dbl();
    var dt;
    if (this.curve.zeroA || this.curve.threeA) {
      var bt = this;
      for (dt = 0; dt < lt; dt++)
        bt = bt.dbl();
      return bt;
    }
    var $t = this.curve.a, vt = this.curve.tinv, wt = this.x, xt = this.y, Et = this.z, Tt = Et.redSqr().redSqr(), Rt = xt.redAdd(xt);
    for (dt = 0; dt < lt; dt++) {
      var Ct = wt.redSqr(), Zt = Rt.redSqr(), Lt = Zt.redSqr(), Ut = Ct.redAdd(Ct).redIAdd(Ct).redIAdd($t.redMul(Tt)), Pt = wt.redMul(Zt), Ot = Ut.redSqr().redISub(Pt.redAdd(Pt)), Ft = Pt.redISub(Ot), gt = Ut.redMul(Ft);
      gt = gt.redIAdd(gt).redISub(Lt);
      var We = Rt.redMul(Et);
      dt + 1 < lt && (Tt = Tt.redMul(Lt)), wt = Ot, Et = We, Rt = gt;
    }
    return this.curve.jpoint(wt, Rt.redMul(vt), Et);
  }, at.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, at.prototype._zeroDbl = function() {
    var lt, dt, bt;
    if (this.zOne) {
      var $t = this.x.redSqr(), vt = this.y.redSqr(), wt = vt.redSqr(), xt = this.x.redAdd(vt).redSqr().redISub($t).redISub(wt);
      xt = xt.redIAdd(xt);
      var Et = $t.redAdd($t).redIAdd($t), Tt = Et.redSqr().redISub(xt).redISub(xt), Rt = wt.redIAdd(wt);
      Rt = Rt.redIAdd(Rt), Rt = Rt.redIAdd(Rt), lt = Tt, dt = Et.redMul(xt.redISub(Tt)).redISub(Rt), bt = this.y.redAdd(this.y);
    } else {
      var Ct = this.x.redSqr(), Zt = this.y.redSqr(), Lt = Zt.redSqr(), Ut = this.x.redAdd(Zt).redSqr().redISub(Ct).redISub(Lt);
      Ut = Ut.redIAdd(Ut);
      var Pt = Ct.redAdd(Ct).redIAdd(Ct), Ot = Pt.redSqr(), Ft = Lt.redIAdd(Lt);
      Ft = Ft.redIAdd(Ft), Ft = Ft.redIAdd(Ft), lt = Ot.redISub(Ut).redISub(Ut), dt = Pt.redMul(Ut.redISub(lt)).redISub(Ft), bt = this.y.redMul(this.z), bt = bt.redIAdd(bt);
    }
    return this.curve.jpoint(lt, dt, bt);
  }, at.prototype._threeDbl = function() {
    var lt, dt, bt;
    if (this.zOne) {
      var $t = this.x.redSqr(), vt = this.y.redSqr(), wt = vt.redSqr(), xt = this.x.redAdd(vt).redSqr().redISub($t).redISub(wt);
      xt = xt.redIAdd(xt);
      var Et = $t.redAdd($t).redIAdd($t).redIAdd(this.curve.a), Tt = Et.redSqr().redISub(xt).redISub(xt);
      lt = Tt;
      var Rt = wt.redIAdd(wt);
      Rt = Rt.redIAdd(Rt), Rt = Rt.redIAdd(Rt), dt = Et.redMul(xt.redISub(Tt)).redISub(Rt), bt = this.y.redAdd(this.y);
    } else {
      var Ct = this.z.redSqr(), Zt = this.y.redSqr(), Lt = this.x.redMul(Zt), Ut = this.x.redSub(Ct).redMul(this.x.redAdd(Ct));
      Ut = Ut.redAdd(Ut).redIAdd(Ut);
      var Pt = Lt.redIAdd(Lt);
      Pt = Pt.redIAdd(Pt);
      var Ot = Pt.redAdd(Pt);
      lt = Ut.redSqr().redISub(Ot), bt = this.y.redAdd(this.z).redSqr().redISub(Zt).redISub(Ct);
      var Ft = Zt.redSqr();
      Ft = Ft.redIAdd(Ft), Ft = Ft.redIAdd(Ft), Ft = Ft.redIAdd(Ft), dt = Ut.redMul(Pt.redISub(lt)).redISub(Ft);
    }
    return this.curve.jpoint(lt, dt, bt);
  }, at.prototype._dbl = function() {
    var lt = this.curve.a, dt = this.x, bt = this.y, $t = this.z, vt = $t.redSqr().redSqr(), wt = dt.redSqr(), xt = bt.redSqr(), Et = wt.redAdd(wt).redIAdd(wt).redIAdd(lt.redMul(vt)), Tt = dt.redAdd(dt);
    Tt = Tt.redIAdd(Tt);
    var Rt = Tt.redMul(xt), Ct = Et.redSqr().redISub(Rt.redAdd(Rt)), Zt = Rt.redISub(Ct), Lt = xt.redSqr();
    Lt = Lt.redIAdd(Lt), Lt = Lt.redIAdd(Lt), Lt = Lt.redIAdd(Lt);
    var Ut = Et.redMul(Zt).redISub(Lt), Pt = bt.redAdd(bt).redMul($t);
    return this.curve.jpoint(Ct, Ut, Pt);
  }, at.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var lt = this.x.redSqr(), dt = this.y.redSqr(), bt = this.z.redSqr(), $t = dt.redSqr(), vt = lt.redAdd(lt).redIAdd(lt), wt = vt.redSqr(), xt = this.x.redAdd(dt).redSqr().redISub(lt).redISub($t);
    xt = xt.redIAdd(xt), xt = xt.redAdd(xt).redIAdd(xt), xt = xt.redISub(wt);
    var Et = xt.redSqr(), Tt = $t.redIAdd($t);
    Tt = Tt.redIAdd(Tt), Tt = Tt.redIAdd(Tt), Tt = Tt.redIAdd(Tt);
    var Rt = vt.redIAdd(xt).redSqr().redISub(wt).redISub(Et).redISub(Tt), Ct = dt.redMul(Rt);
    Ct = Ct.redIAdd(Ct), Ct = Ct.redIAdd(Ct);
    var Zt = this.x.redMul(Et).redISub(Ct);
    Zt = Zt.redIAdd(Zt), Zt = Zt.redIAdd(Zt);
    var Lt = this.y.redMul(Rt.redMul(Tt.redISub(Rt)).redISub(xt.redMul(Et)));
    Lt = Lt.redIAdd(Lt), Lt = Lt.redIAdd(Lt), Lt = Lt.redIAdd(Lt);
    var Ut = this.z.redAdd(xt).redSqr().redISub(bt).redISub(Et);
    return this.curve.jpoint(Zt, Lt, Ut);
  }, at.prototype.mul = function(lt, dt) {
    return lt = new Ze(lt, dt), this.curve._wnafMul(this, lt);
  }, at.prototype.eq = function(lt) {
    if (lt.type === "affine")
      return this.eq(lt.toJ());
    if (this === lt)
      return !0;
    var dt = this.z.redSqr(), bt = lt.z.redSqr();
    if (this.x.redMul(bt).redISub(lt.x.redMul(dt)).cmpn(0) !== 0)
      return !1;
    var $t = dt.redMul(this.z), vt = bt.redMul(lt.z);
    return this.y.redMul(vt).redISub(lt.y.redMul($t)).cmpn(0) === 0;
  }, at.prototype.eqXToP = function(lt) {
    var dt = this.z.redSqr(), bt = lt.toRed(this.curve.red).redMul(dt);
    if (this.x.cmp(bt) === 0)
      return !0;
    for (var $t = lt.clone(), vt = this.curve.redN.redMul(dt); ; ) {
      if ($t.iadd(this.curve.n), $t.cmp(this.curve.p) >= 0)
        return !1;
      if (bt.redIAdd(vt), this.x.cmp(bt) === 0)
        return !0;
    }
  }, at.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, at.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, exports$R$1;
}
var exports$Q$1 = {}, _dewExec$Q$1 = !1;
function dew$Q$1() {
  if (_dewExec$Q$1)
    return exports$Q$1;
  _dewExec$Q$1 = !0;
  var $e = dew$V$1(), Ze = dew$f$2(), Fe = dew$S$1(), Ke = dew$T$1();
  function Ve(Qe) {
    Fe.call(this, "mont", Qe), this.a = new $e(Qe.a, 16).toRed(this.red), this.b = new $e(Qe.b, 16).toRed(this.red), this.i4 = new $e(4).toRed(this.red).redInvm(), this.two = new $e(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  Ze(Ve, Fe), exports$Q$1 = Ve, Ve.prototype.validate = function(at) {
    var ut = at.normalize().x, lt = ut.redSqr(), dt = lt.redMul(ut).redAdd(lt.redMul(this.a)).redAdd(ut), bt = dt.redSqrt();
    return bt.redSqr().cmp(dt) === 0;
  };
  function Je(Qe, at, ut) {
    Fe.BasePoint.call(this, Qe, "projective"), at === null && ut === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new $e(at, 16), this.z = new $e(ut, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return Ze(Je, Fe.BasePoint), Ve.prototype.decodePoint = function(at, ut) {
    return this.point(Ke.toArray(at, ut), 1);
  }, Ve.prototype.point = function(at, ut) {
    return new Je(this, at, ut);
  }, Ve.prototype.pointFromJSON = function(at) {
    return Je.fromJSON(this, at);
  }, Je.prototype.precompute = function() {
  }, Je.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, Je.fromJSON = function(at, ut) {
    return new Je(at, ut[0], ut[1] || at.one);
  }, Je.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, Je.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, Je.prototype.dbl = function() {
    var at = this.x.redAdd(this.z), ut = at.redSqr(), lt = this.x.redSub(this.z), dt = lt.redSqr(), bt = ut.redSub(dt), $t = ut.redMul(dt), vt = bt.redMul(dt.redAdd(this.curve.a24.redMul(bt)));
    return this.curve.point($t, vt);
  }, Je.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, Je.prototype.diffAdd = function(at, ut) {
    var lt = this.x.redAdd(this.z), dt = this.x.redSub(this.z), bt = at.x.redAdd(at.z), $t = at.x.redSub(at.z), vt = $t.redMul(lt), wt = bt.redMul(dt), xt = ut.z.redMul(vt.redAdd(wt).redSqr()), Et = ut.x.redMul(vt.redISub(wt).redSqr());
    return this.curve.point(xt, Et);
  }, Je.prototype.mul = function(at) {
    for (var ut = at.clone(), lt = this, dt = this.curve.point(null, null), bt = this, $t = []; ut.cmpn(0) !== 0; ut.iushrn(1))
      $t.push(ut.andln(1));
    for (var vt = $t.length - 1; vt >= 0; vt--)
      $t[vt] === 0 ? (lt = lt.diffAdd(dt, bt), dt = dt.dbl()) : (dt = lt.diffAdd(dt, bt), lt = lt.dbl());
    return dt;
  }, Je.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, Je.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, Je.prototype.eq = function(at) {
    return this.getX().cmp(at.getX()) === 0;
  }, Je.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, Je.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, exports$Q$1;
}
var exports$P$1 = {}, _dewExec$P$1 = !1;
function dew$P$1() {
  if (_dewExec$P$1)
    return exports$P$1;
  _dewExec$P$1 = !0;
  var $e = dew$T$1(), Ze = dew$V$1(), Fe = dew$f$2(), Ke = dew$S$1(), Ve = $e.assert;
  function Je(at) {
    this.twisted = (at.a | 0) !== 1, this.mOneA = this.twisted && (at.a | 0) === -1, this.extended = this.mOneA, Ke.call(this, "edwards", at), this.a = new Ze(at.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Ze(at.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Ze(at.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), Ve(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (at.c | 0) === 1;
  }
  Fe(Je, Ke), exports$P$1 = Je, Je.prototype._mulA = function(ut) {
    return this.mOneA ? ut.redNeg() : this.a.redMul(ut);
  }, Je.prototype._mulC = function(ut) {
    return this.oneC ? ut : this.c.redMul(ut);
  }, Je.prototype.jpoint = function(ut, lt, dt, bt) {
    return this.point(ut, lt, dt, bt);
  }, Je.prototype.pointFromX = function(ut, lt) {
    ut = new Ze(ut, 16), ut.red || (ut = ut.toRed(this.red));
    var dt = ut.redSqr(), bt = this.c2.redSub(this.a.redMul(dt)), $t = this.one.redSub(this.c2.redMul(this.d).redMul(dt)), vt = bt.redMul($t.redInvm()), wt = vt.redSqrt();
    if (wt.redSqr().redSub(vt).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var xt = wt.fromRed().isOdd();
    return (lt && !xt || !lt && xt) && (wt = wt.redNeg()), this.point(ut, wt);
  }, Je.prototype.pointFromY = function(ut, lt) {
    ut = new Ze(ut, 16), ut.red || (ut = ut.toRed(this.red));
    var dt = ut.redSqr(), bt = dt.redSub(this.c2), $t = dt.redMul(this.d).redMul(this.c2).redSub(this.a), vt = bt.redMul($t.redInvm());
    if (vt.cmp(this.zero) === 0) {
      if (lt)
        throw new Error("invalid point");
      return this.point(this.zero, ut);
    }
    var wt = vt.redSqrt();
    if (wt.redSqr().redSub(vt).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return wt.fromRed().isOdd() !== lt && (wt = wt.redNeg()), this.point(wt, ut);
  }, Je.prototype.validate = function(ut) {
    if (ut.isInfinity())
      return !0;
    ut.normalize();
    var lt = ut.x.redSqr(), dt = ut.y.redSqr(), bt = lt.redMul(this.a).redAdd(dt), $t = this.c2.redMul(this.one.redAdd(this.d.redMul(lt).redMul(dt)));
    return bt.cmp($t) === 0;
  };
  function Qe(at, ut, lt, dt, bt) {
    Ke.BasePoint.call(this, at, "projective"), ut === null && lt === null && dt === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new Ze(ut, 16), this.y = new Ze(lt, 16), this.z = dt ? new Ze(dt, 16) : this.curve.one, this.t = bt && new Ze(bt, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return Fe(Qe, Ke.BasePoint), Je.prototype.pointFromJSON = function(ut) {
    return Qe.fromJSON(this, ut);
  }, Je.prototype.point = function(ut, lt, dt, bt) {
    return new Qe(this, ut, lt, dt, bt);
  }, Qe.fromJSON = function(ut, lt) {
    return new Qe(ut, lt[0], lt[1], lt[2]);
  }, Qe.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, Qe.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, Qe.prototype._extDbl = function() {
    var ut = this.x.redSqr(), lt = this.y.redSqr(), dt = this.z.redSqr();
    dt = dt.redIAdd(dt);
    var bt = this.curve._mulA(ut), $t = this.x.redAdd(this.y).redSqr().redISub(ut).redISub(lt), vt = bt.redAdd(lt), wt = vt.redSub(dt), xt = bt.redSub(lt), Et = $t.redMul(wt), Tt = vt.redMul(xt), Rt = $t.redMul(xt), Ct = wt.redMul(vt);
    return this.curve.point(Et, Tt, Ct, Rt);
  }, Qe.prototype._projDbl = function() {
    var ut = this.x.redAdd(this.y).redSqr(), lt = this.x.redSqr(), dt = this.y.redSqr(), bt, $t, vt, wt, xt, Et;
    if (this.curve.twisted) {
      wt = this.curve._mulA(lt);
      var Tt = wt.redAdd(dt);
      this.zOne ? (bt = ut.redSub(lt).redSub(dt).redMul(Tt.redSub(this.curve.two)), $t = Tt.redMul(wt.redSub(dt)), vt = Tt.redSqr().redSub(Tt).redSub(Tt)) : (xt = this.z.redSqr(), Et = Tt.redSub(xt).redISub(xt), bt = ut.redSub(lt).redISub(dt).redMul(Et), $t = Tt.redMul(wt.redSub(dt)), vt = Tt.redMul(Et));
    } else
      wt = lt.redAdd(dt), xt = this.curve._mulC(this.z).redSqr(), Et = wt.redSub(xt).redSub(xt), bt = this.curve._mulC(ut.redISub(wt)).redMul(Et), $t = this.curve._mulC(wt).redMul(lt.redISub(dt)), vt = wt.redMul(Et);
    return this.curve.point(bt, $t, vt);
  }, Qe.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, Qe.prototype._extAdd = function(ut) {
    var lt = this.y.redSub(this.x).redMul(ut.y.redSub(ut.x)), dt = this.y.redAdd(this.x).redMul(ut.y.redAdd(ut.x)), bt = this.t.redMul(this.curve.dd).redMul(ut.t), $t = this.z.redMul(ut.z.redAdd(ut.z)), vt = dt.redSub(lt), wt = $t.redSub(bt), xt = $t.redAdd(bt), Et = dt.redAdd(lt), Tt = vt.redMul(wt), Rt = xt.redMul(Et), Ct = vt.redMul(Et), Zt = wt.redMul(xt);
    return this.curve.point(Tt, Rt, Zt, Ct);
  }, Qe.prototype._projAdd = function(ut) {
    var lt = this.z.redMul(ut.z), dt = lt.redSqr(), bt = this.x.redMul(ut.x), $t = this.y.redMul(ut.y), vt = this.curve.d.redMul(bt).redMul($t), wt = dt.redSub(vt), xt = dt.redAdd(vt), Et = this.x.redAdd(this.y).redMul(ut.x.redAdd(ut.y)).redISub(bt).redISub($t), Tt = lt.redMul(wt).redMul(Et), Rt, Ct;
    return this.curve.twisted ? (Rt = lt.redMul(xt).redMul($t.redSub(this.curve._mulA(bt))), Ct = wt.redMul(xt)) : (Rt = lt.redMul(xt).redMul($t.redSub(bt)), Ct = this.curve._mulC(wt).redMul(xt)), this.curve.point(Tt, Rt, Ct);
  }, Qe.prototype.add = function(ut) {
    return this.isInfinity() ? ut : ut.isInfinity() ? this : this.curve.extended ? this._extAdd(ut) : this._projAdd(ut);
  }, Qe.prototype.mul = function(ut) {
    return this._hasDoubles(ut) ? this.curve._fixedNafMul(this, ut) : this.curve._wnafMul(this, ut);
  }, Qe.prototype.mulAdd = function(ut, lt, dt) {
    return this.curve._wnafMulAdd(1, [this, lt], [ut, dt], 2, !1);
  }, Qe.prototype.jmulAdd = function(ut, lt, dt) {
    return this.curve._wnafMulAdd(1, [this, lt], [ut, dt], 2, !0);
  }, Qe.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var ut = this.z.redInvm();
    return this.x = this.x.redMul(ut), this.y = this.y.redMul(ut), this.t && (this.t = this.t.redMul(ut)), this.z = this.curve.one, this.zOne = !0, this;
  }, Qe.prototype.neg = function() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  }, Qe.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, Qe.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, Qe.prototype.eq = function(ut) {
    return this === ut || this.getX().cmp(ut.getX()) === 0 && this.getY().cmp(ut.getY()) === 0;
  }, Qe.prototype.eqXToP = function(ut) {
    var lt = ut.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(lt) === 0)
      return !0;
    for (var dt = ut.clone(), bt = this.curve.redN.redMul(this.z); ; ) {
      if (dt.iadd(this.curve.n), dt.cmp(this.curve.p) >= 0)
        return !1;
      if (lt.redIAdd(bt), this.x.cmp(lt) === 0)
        return !0;
    }
  }, Qe.prototype.toP = Qe.prototype.normalize, Qe.prototype.mixedAdd = Qe.prototype.add, exports$P$1;
}
var exports$O$1 = {}, _dewExec$O$1 = !1;
function dew$O$1() {
  if (_dewExec$O$1)
    return exports$O$1;
  _dewExec$O$1 = !0;
  var $e = exports$O$1;
  return $e.base = dew$S$1(), $e.short = dew$R$1(), $e.mont = dew$Q$1(), $e.edwards = dew$P$1(), exports$O$1;
}
var exports$N$1 = {}, _dewExec$N$1 = !1;
function dew$N$1() {
  if (_dewExec$N$1)
    return exports$N$1;
  _dewExec$N$1 = !0;
  var $e = dew$1t(), Ze = dew$f$2();
  exports$N$1.inherits = Ze;
  function Fe(Xe, rt) {
    return (Xe.charCodeAt(rt) & 64512) !== 55296 || rt < 0 || rt + 1 >= Xe.length ? !1 : (Xe.charCodeAt(rt + 1) & 64512) === 56320;
  }
  function Ke(Xe, rt) {
    if (Array.isArray(Xe))
      return Xe.slice();
    if (!Xe)
      return [];
    var ot = [];
    if (typeof Xe == "string")
      if (rt) {
        if (rt === "hex")
          for (Xe = Xe.replace(/[^a-z0-9]+/ig, ""), Xe.length % 2 !== 0 && (Xe = "0" + Xe), mt = 0; mt < Xe.length; mt += 2)
            ot.push(parseInt(Xe[mt] + Xe[mt + 1], 16));
      } else
        for (var ft = 0, mt = 0; mt < Xe.length; mt++) {
          var yt = Xe.charCodeAt(mt);
          yt < 128 ? ot[ft++] = yt : yt < 2048 ? (ot[ft++] = yt >> 6 | 192, ot[ft++] = yt & 63 | 128) : Fe(Xe, mt) ? (yt = 65536 + ((yt & 1023) << 10) + (Xe.charCodeAt(++mt) & 1023), ot[ft++] = yt >> 18 | 240, ot[ft++] = yt >> 12 & 63 | 128, ot[ft++] = yt >> 6 & 63 | 128, ot[ft++] = yt & 63 | 128) : (ot[ft++] = yt >> 12 | 224, ot[ft++] = yt >> 6 & 63 | 128, ot[ft++] = yt & 63 | 128);
        }
    else
      for (mt = 0; mt < Xe.length; mt++)
        ot[mt] = Xe[mt] | 0;
    return ot;
  }
  exports$N$1.toArray = Ke;
  function Ve(Xe) {
    for (var rt = "", ot = 0; ot < Xe.length; ot++)
      rt += at(Xe[ot].toString(16));
    return rt;
  }
  exports$N$1.toHex = Ve;
  function Je(Xe) {
    var rt = Xe >>> 24 | Xe >>> 8 & 65280 | Xe << 8 & 16711680 | (Xe & 255) << 24;
    return rt >>> 0;
  }
  exports$N$1.htonl = Je;
  function Qe(Xe, rt) {
    for (var ot = "", ft = 0; ft < Xe.length; ft++) {
      var mt = Xe[ft];
      rt === "little" && (mt = Je(mt)), ot += ut(mt.toString(16));
    }
    return ot;
  }
  exports$N$1.toHex32 = Qe;
  function at(Xe) {
    return Xe.length === 1 ? "0" + Xe : Xe;
  }
  exports$N$1.zero2 = at;
  function ut(Xe) {
    return Xe.length === 7 ? "0" + Xe : Xe.length === 6 ? "00" + Xe : Xe.length === 5 ? "000" + Xe : Xe.length === 4 ? "0000" + Xe : Xe.length === 3 ? "00000" + Xe : Xe.length === 2 ? "000000" + Xe : Xe.length === 1 ? "0000000" + Xe : Xe;
  }
  exports$N$1.zero8 = ut;
  function lt(Xe, rt, ot, ft) {
    var mt = ot - rt;
    $e(mt % 4 === 0);
    for (var yt = new Array(mt / 4), pt = 0, Ge = rt; pt < yt.length; pt++, Ge += 4) {
      var ct;
      ft === "big" ? ct = Xe[Ge] << 24 | Xe[Ge + 1] << 16 | Xe[Ge + 2] << 8 | Xe[Ge + 3] : ct = Xe[Ge + 3] << 24 | Xe[Ge + 2] << 16 | Xe[Ge + 1] << 8 | Xe[Ge], yt[pt] = ct >>> 0;
    }
    return yt;
  }
  exports$N$1.join32 = lt;
  function dt(Xe, rt) {
    for (var ot = new Array(Xe.length * 4), ft = 0, mt = 0; ft < Xe.length; ft++, mt += 4) {
      var yt = Xe[ft];
      rt === "big" ? (ot[mt] = yt >>> 24, ot[mt + 1] = yt >>> 16 & 255, ot[mt + 2] = yt >>> 8 & 255, ot[mt + 3] = yt & 255) : (ot[mt + 3] = yt >>> 24, ot[mt + 2] = yt >>> 16 & 255, ot[mt + 1] = yt >>> 8 & 255, ot[mt] = yt & 255);
    }
    return ot;
  }
  exports$N$1.split32 = dt;
  function bt(Xe, rt) {
    return Xe >>> rt | Xe << 32 - rt;
  }
  exports$N$1.rotr32 = bt;
  function $t(Xe, rt) {
    return Xe << rt | Xe >>> 32 - rt;
  }
  exports$N$1.rotl32 = $t;
  function vt(Xe, rt) {
    return Xe + rt >>> 0;
  }
  exports$N$1.sum32 = vt;
  function wt(Xe, rt, ot) {
    return Xe + rt + ot >>> 0;
  }
  exports$N$1.sum32_3 = wt;
  function xt(Xe, rt, ot, ft) {
    return Xe + rt + ot + ft >>> 0;
  }
  exports$N$1.sum32_4 = xt;
  function Et(Xe, rt, ot, ft, mt) {
    return Xe + rt + ot + ft + mt >>> 0;
  }
  exports$N$1.sum32_5 = Et;
  function Tt(Xe, rt, ot, ft) {
    var mt = Xe[rt], yt = Xe[rt + 1], pt = ft + yt >>> 0, Ge = (pt < ft ? 1 : 0) + ot + mt;
    Xe[rt] = Ge >>> 0, Xe[rt + 1] = pt;
  }
  exports$N$1.sum64 = Tt;
  function Rt(Xe, rt, ot, ft) {
    var mt = rt + ft >>> 0, yt = (mt < rt ? 1 : 0) + Xe + ot;
    return yt >>> 0;
  }
  exports$N$1.sum64_hi = Rt;
  function Ct(Xe, rt, ot, ft) {
    var mt = rt + ft;
    return mt >>> 0;
  }
  exports$N$1.sum64_lo = Ct;
  function Zt(Xe, rt, ot, ft, mt, yt, pt, Ge) {
    var ct = 0, Mt = rt;
    Mt = Mt + ft >>> 0, ct += Mt < rt ? 1 : 0, Mt = Mt + yt >>> 0, ct += Mt < yt ? 1 : 0, Mt = Mt + Ge >>> 0, ct += Mt < Ge ? 1 : 0;
    var St = Xe + ot + mt + pt + ct;
    return St >>> 0;
  }
  exports$N$1.sum64_4_hi = Zt;
  function Lt(Xe, rt, ot, ft, mt, yt, pt, Ge) {
    var ct = rt + ft + yt + Ge;
    return ct >>> 0;
  }
  exports$N$1.sum64_4_lo = Lt;
  function Ut(Xe, rt, ot, ft, mt, yt, pt, Ge, ct, Mt) {
    var St = 0, At = rt;
    At = At + ft >>> 0, St += At < rt ? 1 : 0, At = At + yt >>> 0, St += At < yt ? 1 : 0, At = At + Ge >>> 0, St += At < Ge ? 1 : 0, At = At + Mt >>> 0, St += At < Mt ? 1 : 0;
    var Nt = Xe + ot + mt + pt + ct + St;
    return Nt >>> 0;
  }
  exports$N$1.sum64_5_hi = Ut;
  function Pt(Xe, rt, ot, ft, mt, yt, pt, Ge, ct, Mt) {
    var St = rt + ft + yt + Ge + Mt;
    return St >>> 0;
  }
  exports$N$1.sum64_5_lo = Pt;
  function Ot(Xe, rt, ot) {
    var ft = rt << 32 - ot | Xe >>> ot;
    return ft >>> 0;
  }
  exports$N$1.rotr64_hi = Ot;
  function Ft(Xe, rt, ot) {
    var ft = Xe << 32 - ot | rt >>> ot;
    return ft >>> 0;
  }
  exports$N$1.rotr64_lo = Ft;
  function gt(Xe, rt, ot) {
    return Xe >>> ot;
  }
  exports$N$1.shr64_hi = gt;
  function We(Xe, rt, ot) {
    var ft = Xe << 32 - ot | rt >>> ot;
    return ft >>> 0;
  }
  return exports$N$1.shr64_lo = We, exports$N$1;
}
var exports$M$1 = {}, _dewExec$M$1 = !1;
function dew$M$1() {
  if (_dewExec$M$1)
    return exports$M$1;
  _dewExec$M$1 = !0;
  var $e = dew$N$1(), Ze = dew$1t();
  function Fe() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return exports$M$1.BlockHash = Fe, Fe.prototype.update = function(Ve, Je) {
    if (Ve = $e.toArray(Ve, Je), this.pending ? this.pending = this.pending.concat(Ve) : this.pending = Ve, this.pendingTotal += Ve.length, this.pending.length >= this._delta8) {
      Ve = this.pending;
      var Qe = Ve.length % this._delta8;
      this.pending = Ve.slice(Ve.length - Qe, Ve.length), this.pending.length === 0 && (this.pending = null), Ve = $e.join32(Ve, 0, Ve.length - Qe, this.endian);
      for (var at = 0; at < Ve.length; at += this._delta32)
        this._update(Ve, at, at + this._delta32);
    }
    return this;
  }, Fe.prototype.digest = function(Ve) {
    return this.update(this._pad()), Ze(this.pending === null), this._digest(Ve);
  }, Fe.prototype._pad = function() {
    var Ve = this.pendingTotal, Je = this._delta8, Qe = Je - (Ve + this.padLength) % Je, at = new Array(Qe + this.padLength);
    at[0] = 128;
    for (var ut = 1; ut < Qe; ut++)
      at[ut] = 0;
    if (Ve <<= 3, this.endian === "big") {
      for (var lt = 8; lt < this.padLength; lt++)
        at[ut++] = 0;
      at[ut++] = 0, at[ut++] = 0, at[ut++] = 0, at[ut++] = 0, at[ut++] = Ve >>> 24 & 255, at[ut++] = Ve >>> 16 & 255, at[ut++] = Ve >>> 8 & 255, at[ut++] = Ve & 255;
    } else
      for (at[ut++] = Ve & 255, at[ut++] = Ve >>> 8 & 255, at[ut++] = Ve >>> 16 & 255, at[ut++] = Ve >>> 24 & 255, at[ut++] = 0, at[ut++] = 0, at[ut++] = 0, at[ut++] = 0, lt = 8; lt < this.padLength; lt++)
        at[ut++] = 0;
    return at;
  }, exports$M$1;
}
var exports$L$1 = {}, _dewExec$L$1 = !1;
function dew$L$1() {
  return _dewExec$L$1 || (_dewExec$L$1 = !0), exports$L$1;
}
var exports$K$1 = {}, _dewExec$K$1 = !1;
function dew$K$1() {
  if (_dewExec$K$1)
    return exports$K$1;
  _dewExec$K$1 = !0;
  var $e = dew$N$1(), Ze = dew$M$1(), Fe = $e.rotl32, Ke = $e.sum32, Ve = $e.sum32_3, Je = $e.sum32_4, Qe = Ze.BlockHash;
  function at() {
    if (!(this instanceof at))
      return new at();
    Qe.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  $e.inherits(at, Qe), exports$K$1.ripemd160 = at, at.blockSize = 512, at.outSize = 160, at.hmacStrength = 192, at.padLength = 64, at.prototype._update = function(Et, Tt) {
    for (var Rt = this.h[0], Ct = this.h[1], Zt = this.h[2], Lt = this.h[3], Ut = this.h[4], Pt = Rt, Ot = Ct, Ft = Zt, gt = Lt, We = Ut, Xe = 0; Xe < 80; Xe++) {
      var rt = Ke(Fe(Je(Rt, ut(Xe, Ct, Zt, Lt), Et[bt[Xe] + Tt], lt(Xe)), vt[Xe]), Ut);
      Rt = Ut, Ut = Lt, Lt = Fe(Zt, 10), Zt = Ct, Ct = rt, rt = Ke(Fe(Je(Pt, ut(79 - Xe, Ot, Ft, gt), Et[$t[Xe] + Tt], dt(Xe)), wt[Xe]), We), Pt = We, We = gt, gt = Fe(Ft, 10), Ft = Ot, Ot = rt;
    }
    rt = Ve(this.h[1], Zt, gt), this.h[1] = Ve(this.h[2], Lt, We), this.h[2] = Ve(this.h[3], Ut, Pt), this.h[3] = Ve(this.h[4], Rt, Ot), this.h[4] = Ve(this.h[0], Ct, Ft), this.h[0] = rt;
  }, at.prototype._digest = function(Et) {
    return Et === "hex" ? $e.toHex32(this.h, "little") : $e.split32(this.h, "little");
  };
  function ut(xt, Et, Tt, Rt) {
    return xt <= 15 ? Et ^ Tt ^ Rt : xt <= 31 ? Et & Tt | ~Et & Rt : xt <= 47 ? (Et | ~Tt) ^ Rt : xt <= 63 ? Et & Rt | Tt & ~Rt : Et ^ (Tt | ~Rt);
  }
  function lt(xt) {
    return xt <= 15 ? 0 : xt <= 31 ? 1518500249 : xt <= 47 ? 1859775393 : xt <= 63 ? 2400959708 : 2840853838;
  }
  function dt(xt) {
    return xt <= 15 ? 1352829926 : xt <= 31 ? 1548603684 : xt <= 47 ? 1836072691 : xt <= 63 ? 2053994217 : 0;
  }
  var bt = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], $t = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], vt = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], wt = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  return exports$K$1;
}
var exports$J$1 = {}, _dewExec$J$1 = !1;
function dew$J$1() {
  if (_dewExec$J$1)
    return exports$J$1;
  _dewExec$J$1 = !0;
  var $e = dew$N$1(), Ze = dew$1t();
  function Fe(Ke, Ve, Je) {
    if (!(this instanceof Fe))
      return new Fe(Ke, Ve, Je);
    this.Hash = Ke, this.blockSize = Ke.blockSize / 8, this.outSize = Ke.outSize / 8, this.inner = null, this.outer = null, this._init($e.toArray(Ve, Je));
  }
  return exports$J$1 = Fe, Fe.prototype._init = function(Ve) {
    Ve.length > this.blockSize && (Ve = new this.Hash().update(Ve).digest()), Ze(Ve.length <= this.blockSize);
    for (var Je = Ve.length; Je < this.blockSize; Je++)
      Ve.push(0);
    for (Je = 0; Je < Ve.length; Je++)
      Ve[Je] ^= 54;
    for (this.inner = new this.Hash().update(Ve), Je = 0; Je < Ve.length; Je++)
      Ve[Je] ^= 106;
    this.outer = new this.Hash().update(Ve);
  }, Fe.prototype.update = function(Ve, Je) {
    return this.inner.update(Ve, Je), this;
  }, Fe.prototype.digest = function(Ve) {
    return this.outer.update(this.inner.digest()), this.outer.digest(Ve);
  }, exports$J$1;
}
var exports$I$1 = {}, _dewExec$I$1 = !1;
function dew$I$1() {
  if (_dewExec$I$1)
    return exports$I$1;
  _dewExec$I$1 = !0;
  var $e = exports$I$1;
  return $e.utils = dew$N$1(), $e.common = dew$M$1(), $e.sha = dew$L$1(), $e.ripemd = dew$K$1(), $e.hmac = dew$J$1(), $e.sha1 = $e.sha.sha1, $e.sha256 = $e.sha.sha256, $e.sha224 = $e.sha.sha224, $e.sha384 = $e.sha.sha384, $e.sha512 = $e.sha.sha512, $e.ripemd160 = $e.ripemd.ripemd160, exports$I$1;
}
var exports$H$1 = {}, _dewExec$H$1 = !1;
function dew$H$1() {
  return _dewExec$H$1 || (_dewExec$H$1 = !0, exports$H$1 = {
    doubles: {
      step: 4,
      points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]
    },
    naf: {
      wnd: 7,
      points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]
    }
  }), exports$H$1;
}
var exports$G$1 = {}, _dewExec$G$1 = !1;
function dew$G$1() {
  if (_dewExec$G$1)
    return exports$G$1;
  _dewExec$G$1 = !0;
  var $e = exports$G$1, Ze = dew$I$1(), Fe = dew$O$1(), Ke = dew$T$1(), Ve = Ke.assert;
  function Je(ut) {
    ut.type === "short" ? this.curve = new Fe.short(ut) : ut.type === "edwards" ? this.curve = new Fe.edwards(ut) : this.curve = new Fe.mont(ut), this.g = this.curve.g, this.n = this.curve.n, this.hash = ut.hash, Ve(this.g.validate(), "Invalid curve"), Ve(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  $e.PresetCurve = Je;
  function Qe(ut, lt) {
    Object.defineProperty($e, ut, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var dt = new Je(lt);
        return Object.defineProperty($e, ut, {
          configurable: !0,
          enumerable: !0,
          value: dt
        }), dt;
      }
    });
  }
  Qe("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: Ze.sha256,
    gRed: !1,
    g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
  }), Qe("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: Ze.sha256,
    gRed: !1,
    g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
  }), Qe("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: Ze.sha256,
    gRed: !1,
    g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
  }), Qe("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: Ze.sha384,
    gRed: !1,
    g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
  }), Qe("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: Ze.sha512,
    gRed: !1,
    g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
  }), Qe("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Ze.sha256,
    gRed: !1,
    g: ["9"]
  }), Qe("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Ze.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var at;
  try {
    at = dew$H$1();
  } catch {
    at = void 0;
  }
  return Qe("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: Ze.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [{
      a: "3086d221a7d46bcde86c90e49284eb15",
      b: "-e4437ed6010e88286f547fa90abfe4c3"
    }, {
      a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
      b: "3086d221a7d46bcde86c90e49284eb15"
    }],
    gRed: !1,
    g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", at]
  }), exports$G$1;
}
var exports$F$1 = {}, _dewExec$F$1 = !1;
function dew$F$1() {
  if (_dewExec$F$1)
    return exports$F$1;
  _dewExec$F$1 = !0;
  var $e = dew$I$1(), Ze = dew$U$1(), Fe = dew$1t();
  function Ke(Ve) {
    if (!(this instanceof Ke))
      return new Ke(Ve);
    this.hash = Ve.hash, this.predResist = !!Ve.predResist, this.outLen = this.hash.outSize, this.minEntropy = Ve.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var Je = Ze.toArray(Ve.entropy, Ve.entropyEnc || "hex"), Qe = Ze.toArray(Ve.nonce, Ve.nonceEnc || "hex"), at = Ze.toArray(Ve.pers, Ve.persEnc || "hex");
    Fe(Je.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(Je, Qe, at);
  }
  return exports$F$1 = Ke, Ke.prototype._init = function(Je, Qe, at) {
    var ut = Je.concat(Qe).concat(at);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var lt = 0; lt < this.V.length; lt++)
      this.K[lt] = 0, this.V[lt] = 1;
    this._update(ut), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, Ke.prototype._hmac = function() {
    return new $e.hmac(this.hash, this.K);
  }, Ke.prototype._update = function(Je) {
    var Qe = this._hmac().update(this.V).update([0]);
    Je && (Qe = Qe.update(Je)), this.K = Qe.digest(), this.V = this._hmac().update(this.V).digest(), Je && (this.K = this._hmac().update(this.V).update([1]).update(Je).digest(), this.V = this._hmac().update(this.V).digest());
  }, Ke.prototype.reseed = function(Je, Qe, at, ut) {
    typeof Qe != "string" && (ut = at, at = Qe, Qe = null), Je = Ze.toArray(Je, Qe), at = Ze.toArray(at, ut), Fe(Je.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(Je.concat(at || [])), this._reseed = 1;
  }, Ke.prototype.generate = function(Je, Qe, at, ut) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof Qe != "string" && (ut = at, at = Qe, Qe = null), at && (at = Ze.toArray(at, ut || "hex"), this._update(at));
    for (var lt = []; lt.length < Je; )
      this.V = this._hmac().update(this.V).digest(), lt = lt.concat(this.V);
    var dt = lt.slice(0, Je);
    return this._update(at), this._reseed++, Ze.encode(dt, Qe);
  }, exports$F$1;
}
var exports$E$1 = {}, _dewExec$E$1 = !1;
function dew$E$1() {
  if (_dewExec$E$1)
    return exports$E$1;
  _dewExec$E$1 = !0;
  var $e = dew$V$1(), Ze = dew$T$1(), Fe = Ze.assert;
  function Ke(Ve, Je) {
    this.ec = Ve, this.priv = null, this.pub = null, Je.priv && this._importPrivate(Je.priv, Je.privEnc), Je.pub && this._importPublic(Je.pub, Je.pubEnc);
  }
  return exports$E$1 = Ke, Ke.fromPublic = function(Je, Qe, at) {
    return Qe instanceof Ke ? Qe : new Ke(Je, {
      pub: Qe,
      pubEnc: at
    });
  }, Ke.fromPrivate = function(Je, Qe, at) {
    return Qe instanceof Ke ? Qe : new Ke(Je, {
      priv: Qe,
      privEnc: at
    });
  }, Ke.prototype.validate = function() {
    var Je = this.getPublic();
    return Je.isInfinity() ? {
      result: !1,
      reason: "Invalid public key"
    } : Je.validate() ? Je.mul(this.ec.curve.n).isInfinity() ? {
      result: !0,
      reason: null
    } : {
      result: !1,
      reason: "Public key * N != O"
    } : {
      result: !1,
      reason: "Public key is not a point"
    };
  }, Ke.prototype.getPublic = function(Je, Qe) {
    return typeof Je == "string" && (Qe = Je, Je = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), Qe ? this.pub.encode(Qe, Je) : this.pub;
  }, Ke.prototype.getPrivate = function(Je) {
    return Je === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, Ke.prototype._importPrivate = function(Je, Qe) {
    this.priv = new $e(Je, Qe || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, Ke.prototype._importPublic = function(Je, Qe) {
    if (Je.x || Je.y) {
      this.ec.curve.type === "mont" ? Fe(Je.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Fe(Je.x && Je.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(Je.x, Je.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(Je, Qe);
  }, Ke.prototype.derive = function(Je) {
    return Je.validate() || Fe(Je.validate(), "public point not validated"), Je.mul(this.priv).getX();
  }, Ke.prototype.sign = function(Je, Qe, at) {
    return this.ec.sign(Je, this, Qe, at);
  }, Ke.prototype.verify = function(Je, Qe) {
    return this.ec.verify(Je, Qe, this);
  }, Ke.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, exports$E$1;
}
var exports$D$1 = {}, _dewExec$D$1 = !1;
function dew$D$1() {
  if (_dewExec$D$1)
    return exports$D$1;
  _dewExec$D$1 = !0;
  var $e = dew$V$1(), Ze = dew$T$1(), Fe = Ze.assert;
  function Ke(ut, lt) {
    if (ut instanceof Ke)
      return ut;
    this._importDER(ut, lt) || (Fe(ut.r && ut.s, "Signature without r or s"), this.r = new $e(ut.r, 16), this.s = new $e(ut.s, 16), ut.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = ut.recoveryParam);
  }
  exports$D$1 = Ke;
  function Ve() {
    this.place = 0;
  }
  function Je(ut, lt) {
    var dt = ut[lt.place++];
    if (!(dt & 128))
      return dt;
    var bt = dt & 15;
    if (bt === 0 || bt > 4)
      return !1;
    for (var $t = 0, vt = 0, wt = lt.place; vt < bt; vt++, wt++)
      $t <<= 8, $t |= ut[wt], $t >>>= 0;
    return $t <= 127 ? !1 : (lt.place = wt, $t);
  }
  function Qe(ut) {
    for (var lt = 0, dt = ut.length - 1; !ut[lt] && !(ut[lt + 1] & 128) && lt < dt; )
      lt++;
    return lt === 0 ? ut : ut.slice(lt);
  }
  Ke.prototype._importDER = function(lt, dt) {
    lt = Ze.toArray(lt, dt);
    var bt = new Ve();
    if (lt[bt.place++] !== 48)
      return !1;
    var $t = Je(lt, bt);
    if ($t === !1 || $t + bt.place !== lt.length || lt[bt.place++] !== 2)
      return !1;
    var vt = Je(lt, bt);
    if (vt === !1)
      return !1;
    var wt = lt.slice(bt.place, vt + bt.place);
    if (bt.place += vt, lt[bt.place++] !== 2)
      return !1;
    var xt = Je(lt, bt);
    if (xt === !1 || lt.length !== xt + bt.place)
      return !1;
    var Et = lt.slice(bt.place, xt + bt.place);
    if (wt[0] === 0)
      if (wt[1] & 128)
        wt = wt.slice(1);
      else
        return !1;
    if (Et[0] === 0)
      if (Et[1] & 128)
        Et = Et.slice(1);
      else
        return !1;
    return this.r = new $e(wt), this.s = new $e(Et), this.recoveryParam = null, !0;
  };
  function at(ut, lt) {
    if (lt < 128) {
      ut.push(lt);
      return;
    }
    var dt = 1 + (Math.log(lt) / Math.LN2 >>> 3);
    for (ut.push(dt | 128); --dt; )
      ut.push(lt >>> (dt << 3) & 255);
    ut.push(lt);
  }
  return Ke.prototype.toDER = function(lt) {
    var dt = this.r.toArray(), bt = this.s.toArray();
    for (dt[0] & 128 && (dt = [0].concat(dt)), bt[0] & 128 && (bt = [0].concat(bt)), dt = Qe(dt), bt = Qe(bt); !bt[0] && !(bt[1] & 128); )
      bt = bt.slice(1);
    var $t = [2];
    at($t, dt.length), $t = $t.concat(dt), $t.push(2), at($t, bt.length);
    var vt = $t.concat(bt), wt = [48];
    return at(wt, vt.length), wt = wt.concat(vt), Ze.encode(wt, lt);
  }, exports$D$1;
}
var exports$C$1 = {}, _dewExec$C$1 = !1;
function dew$C$1() {
  if (_dewExec$C$1)
    return exports$C$1;
  _dewExec$C$1 = !0;
  var $e = dew$V$1(), Ze = dew$F$1(), Fe = dew$T$1(), Ke = dew$G$1(), Ve = dew$10$1(), Je = Fe.assert, Qe = dew$E$1(), at = dew$D$1();
  function ut(lt) {
    if (!(this instanceof ut))
      return new ut(lt);
    typeof lt == "string" && (Je(Object.prototype.hasOwnProperty.call(Ke, lt), "Unknown curve " + lt), lt = Ke[lt]), lt instanceof Ke.PresetCurve && (lt = {
      curve: lt
    }), this.curve = lt.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = lt.curve.g, this.g.precompute(lt.curve.n.bitLength() + 1), this.hash = lt.hash || lt.curve.hash;
  }
  return exports$C$1 = ut, ut.prototype.keyPair = function(dt) {
    return new Qe(this, dt);
  }, ut.prototype.keyFromPrivate = function(dt, bt) {
    return Qe.fromPrivate(this, dt, bt);
  }, ut.prototype.keyFromPublic = function(dt, bt) {
    return Qe.fromPublic(this, dt, bt);
  }, ut.prototype.genKeyPair = function(dt) {
    dt || (dt = {});
    for (var bt = new Ze({
      hash: this.hash,
      pers: dt.pers,
      persEnc: dt.persEnc || "utf8",
      entropy: dt.entropy || Ve(this.hash.hmacStrength),
      entropyEnc: dt.entropy && dt.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), $t = this.n.byteLength(), vt = this.n.sub(new $e(2)); ; ) {
      var wt = new $e(bt.generate($t));
      if (!(wt.cmp(vt) > 0))
        return wt.iaddn(1), this.keyFromPrivate(wt);
    }
  }, ut.prototype._truncateToN = function(dt, bt) {
    var $t = dt.byteLength() * 8 - this.n.bitLength();
    return $t > 0 && (dt = dt.ushrn($t)), !bt && dt.cmp(this.n) >= 0 ? dt.sub(this.n) : dt;
  }, ut.prototype.sign = function(dt, bt, $t, vt) {
    typeof $t == "object" && (vt = $t, $t = null), vt || (vt = {}), bt = this.keyFromPrivate(bt, $t), dt = this._truncateToN(new $e(dt, 16));
    for (var wt = this.n.byteLength(), xt = bt.getPrivate().toArray("be", wt), Et = dt.toArray("be", wt), Tt = new Ze({
      hash: this.hash,
      entropy: xt,
      nonce: Et,
      pers: vt.pers,
      persEnc: vt.persEnc || "utf8"
    }), Rt = this.n.sub(new $e(1)), Ct = 0; ; Ct++) {
      var Zt = vt.k ? vt.k(Ct) : new $e(Tt.generate(this.n.byteLength()));
      if (Zt = this._truncateToN(Zt, !0), !(Zt.cmpn(1) <= 0 || Zt.cmp(Rt) >= 0)) {
        var Lt = this.g.mul(Zt);
        if (!Lt.isInfinity()) {
          var Ut = Lt.getX(), Pt = Ut.umod(this.n);
          if (Pt.cmpn(0) !== 0) {
            var Ot = Zt.invm(this.n).mul(Pt.mul(bt.getPrivate()).iadd(dt));
            if (Ot = Ot.umod(this.n), Ot.cmpn(0) !== 0) {
              var Ft = (Lt.getY().isOdd() ? 1 : 0) | (Ut.cmp(Pt) !== 0 ? 2 : 0);
              return vt.canonical && Ot.cmp(this.nh) > 0 && (Ot = this.n.sub(Ot), Ft ^= 1), new at({
                r: Pt,
                s: Ot,
                recoveryParam: Ft
              });
            }
          }
        }
      }
    }
  }, ut.prototype.verify = function(dt, bt, $t, vt) {
    dt = this._truncateToN(new $e(dt, 16)), $t = this.keyFromPublic($t, vt), bt = new at(bt, "hex");
    var wt = bt.r, xt = bt.s;
    if (wt.cmpn(1) < 0 || wt.cmp(this.n) >= 0 || xt.cmpn(1) < 0 || xt.cmp(this.n) >= 0)
      return !1;
    var Et = xt.invm(this.n), Tt = Et.mul(dt).umod(this.n), Rt = Et.mul(wt).umod(this.n), Ct;
    return this.curve._maxwellTrick ? (Ct = this.g.jmulAdd(Tt, $t.getPublic(), Rt), Ct.isInfinity() ? !1 : Ct.eqXToP(wt)) : (Ct = this.g.mulAdd(Tt, $t.getPublic(), Rt), Ct.isInfinity() ? !1 : Ct.getX().umod(this.n).cmp(wt) === 0);
  }, ut.prototype.recoverPubKey = function(lt, dt, bt, $t) {
    Je((3 & bt) === bt, "The recovery param is more than two bits"), dt = new at(dt, $t);
    var vt = this.n, wt = new $e(lt), xt = dt.r, Et = dt.s, Tt = bt & 1, Rt = bt >> 1;
    if (xt.cmp(this.curve.p.umod(this.curve.n)) >= 0 && Rt)
      throw new Error("Unable to find sencond key candinate");
    Rt ? xt = this.curve.pointFromX(xt.add(this.curve.n), Tt) : xt = this.curve.pointFromX(xt, Tt);
    var Ct = dt.r.invm(vt), Zt = vt.sub(wt).mul(Ct).umod(vt), Lt = Et.mul(Ct).umod(vt);
    return this.g.mulAdd(Zt, xt, Lt);
  }, ut.prototype.getKeyRecoveryParam = function(lt, dt, bt, $t) {
    if (dt = new at(dt, $t), dt.recoveryParam !== null)
      return dt.recoveryParam;
    for (var vt = 0; vt < 4; vt++) {
      var wt;
      try {
        wt = this.recoverPubKey(lt, dt, vt);
      } catch {
        continue;
      }
      if (wt.eq(bt))
        return vt;
    }
    throw new Error("Unable to find valid recovery factor");
  }, exports$C$1;
}
var exports$B$1 = {}, _dewExec$B$1 = !1;
function dew$B$1() {
  if (_dewExec$B$1)
    return exports$B$1;
  _dewExec$B$1 = !0;
  var $e = dew$T$1(), Ze = $e.assert, Fe = $e.parseBytes, Ke = $e.cachedProperty;
  function Ve(Je, Qe) {
    this.eddsa = Je, this._secret = Fe(Qe.secret), Je.isPoint(Qe.pub) ? this._pub = Qe.pub : this._pubBytes = Fe(Qe.pub);
  }
  return Ve.fromPublic = function(Qe, at) {
    return at instanceof Ve ? at : new Ve(Qe, {
      pub: at
    });
  }, Ve.fromSecret = function(Qe, at) {
    return at instanceof Ve ? at : new Ve(Qe, {
      secret: at
    });
  }, Ve.prototype.secret = function() {
    return this._secret;
  }, Ke(Ve, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), Ke(Ve, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), Ke(Ve, "privBytes", function() {
    var Qe = this.eddsa, at = this.hash(), ut = Qe.encodingLength - 1, lt = at.slice(0, Qe.encodingLength);
    return lt[0] &= 248, lt[ut] &= 127, lt[ut] |= 64, lt;
  }), Ke(Ve, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), Ke(Ve, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), Ke(Ve, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), Ve.prototype.sign = function(Qe) {
    return Ze(this._secret, "KeyPair can only verify"), this.eddsa.sign(Qe, this);
  }, Ve.prototype.verify = function(Qe, at) {
    return this.eddsa.verify(Qe, at, this);
  }, Ve.prototype.getSecret = function(Qe) {
    return Ze(this._secret, "KeyPair is public only"), $e.encode(this.secret(), Qe);
  }, Ve.prototype.getPublic = function(Qe) {
    return $e.encode(this.pubBytes(), Qe);
  }, exports$B$1 = Ve, exports$B$1;
}
var exports$A$1 = {}, _dewExec$A$1 = !1;
function dew$A$1() {
  if (_dewExec$A$1)
    return exports$A$1;
  _dewExec$A$1 = !0;
  var $e = dew$V$1(), Ze = dew$T$1(), Fe = Ze.assert, Ke = Ze.cachedProperty, Ve = Ze.parseBytes;
  function Je(Qe, at) {
    this.eddsa = Qe, typeof at != "object" && (at = Ve(at)), Array.isArray(at) && (at = {
      R: at.slice(0, Qe.encodingLength),
      S: at.slice(Qe.encodingLength)
    }), Fe(at.R && at.S, "Signature without R or S"), Qe.isPoint(at.R) && (this._R = at.R), at.S instanceof $e && (this._S = at.S), this._Rencoded = Array.isArray(at.R) ? at.R : at.Rencoded, this._Sencoded = Array.isArray(at.S) ? at.S : at.Sencoded;
  }
  return Ke(Je, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), Ke(Je, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), Ke(Je, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), Ke(Je, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), Je.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, Je.prototype.toHex = function() {
    return Ze.encode(this.toBytes(), "hex").toUpperCase();
  }, exports$A$1 = Je, exports$A$1;
}
var exports$z$1 = {}, _dewExec$z$1 = !1;
function dew$z$1() {
  if (_dewExec$z$1)
    return exports$z$1;
  _dewExec$z$1 = !0;
  var $e = dew$I$1(), Ze = dew$G$1(), Fe = dew$T$1(), Ke = Fe.assert, Ve = Fe.parseBytes, Je = dew$B$1(), Qe = dew$A$1();
  function at(ut) {
    if (Ke(ut === "ed25519", "only tested with ed25519 so far"), !(this instanceof at))
      return new at(ut);
    ut = Ze[ut].curve, this.curve = ut, this.g = ut.g, this.g.precompute(ut.n.bitLength() + 1), this.pointClass = ut.point().constructor, this.encodingLength = Math.ceil(ut.n.bitLength() / 8), this.hash = $e.sha512;
  }
  return exports$z$1 = at, at.prototype.sign = function(lt, dt) {
    lt = Ve(lt);
    var bt = this.keyFromSecret(dt), $t = this.hashInt(bt.messagePrefix(), lt), vt = this.g.mul($t), wt = this.encodePoint(vt), xt = this.hashInt(wt, bt.pubBytes(), lt).mul(bt.priv()), Et = $t.add(xt).umod(this.curve.n);
    return this.makeSignature({
      R: vt,
      S: Et,
      Rencoded: wt
    });
  }, at.prototype.verify = function(lt, dt, bt) {
    lt = Ve(lt), dt = this.makeSignature(dt);
    var $t = this.keyFromPublic(bt), vt = this.hashInt(dt.Rencoded(), $t.pubBytes(), lt), wt = this.g.mul(dt.S()), xt = dt.R().add($t.pub().mul(vt));
    return xt.eq(wt);
  }, at.prototype.hashInt = function() {
    for (var lt = this.hash(), dt = 0; dt < arguments.length; dt++)
      lt.update(arguments[dt]);
    return Fe.intFromLE(lt.digest()).umod(this.curve.n);
  }, at.prototype.keyFromPublic = function(lt) {
    return Je.fromPublic(this, lt);
  }, at.prototype.keyFromSecret = function(lt) {
    return Je.fromSecret(this, lt);
  }, at.prototype.makeSignature = function(lt) {
    return lt instanceof Qe ? lt : new Qe(this, lt);
  }, at.prototype.encodePoint = function(lt) {
    var dt = lt.getY().toArray("le", this.encodingLength);
    return dt[this.encodingLength - 1] |= lt.getX().isOdd() ? 128 : 0, dt;
  }, at.prototype.decodePoint = function(lt) {
    lt = Fe.parseBytes(lt);
    var dt = lt.length - 1, bt = lt.slice(0, dt).concat(lt[dt] & -129), $t = (lt[dt] & 128) !== 0, vt = Fe.intFromLE(bt);
    return this.curve.pointFromY(vt, $t);
  }, at.prototype.encodeInt = function(lt) {
    return lt.toArray("le", this.encodingLength);
  }, at.prototype.decodeInt = function(lt) {
    return Fe.intFromLE(lt);
  }, at.prototype.isPoint = function(lt) {
    return lt instanceof this.pointClass;
  }, exports$z$1;
}
var exports$y$1 = {}, _dewExec$y$1 = !1;
function dew$y$1() {
  if (_dewExec$y$1)
    return exports$y$1;
  _dewExec$y$1 = !0;
  var $e = exports$y$1;
  return $e.version = _package$1.version, $e.utils = dew$T$1(), $e.rand = dew$10$1(), $e.curve = dew$O$1(), $e.curves = dew$G$1(), $e.ec = dew$C$1(), $e.eddsa = dew$z$1(), exports$y$1;
}
var exports$x$1 = {}, _dewExec$x$1 = !1, module$2$1 = {
  exports: exports$x$1
}, _global$5$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$x$1() {
  return _dewExec$x$1 || (_dewExec$x$1 = !0, function($e, Ze) {
    function Fe(gt, We) {
      if (!gt)
        throw new Error(We || "Assertion failed");
    }
    function Ke(gt, We) {
      gt.super_ = We;
      var Xe = function() {
      };
      Xe.prototype = We.prototype, gt.prototype = new Xe(), gt.prototype.constructor = gt;
    }
    function Ve(gt, We, Xe) {
      if (Ve.isBN(gt))
        return gt;
      (this || _global$5$1).negative = 0, (this || _global$5$1).words = null, (this || _global$5$1).length = 0, (this || _global$5$1).red = null, gt !== null && ((We === "le" || We === "be") && (Xe = We, We = 10), this._init(gt || 0, We || 10, Xe || "be"));
    }
    typeof $e == "object" ? $e.exports = Ve : Ze.BN = Ve, Ve.BN = Ve, Ve.wordSize = 26;
    var Je;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Je = window.Buffer : Je = e$1$1$1.Buffer;
    } catch {
    }
    Ve.isBN = function(We) {
      return We instanceof Ve ? !0 : We !== null && typeof We == "object" && We.constructor.wordSize === Ve.wordSize && Array.isArray(We.words);
    }, Ve.max = function(We, Xe) {
      return We.cmp(Xe) > 0 ? We : Xe;
    }, Ve.min = function(We, Xe) {
      return We.cmp(Xe) < 0 ? We : Xe;
    }, Ve.prototype._init = function(We, Xe, rt) {
      if (typeof We == "number")
        return this._initNumber(We, Xe, rt);
      if (typeof We == "object")
        return this._initArray(We, Xe, rt);
      Xe === "hex" && (Xe = 16), Fe(Xe === (Xe | 0) && Xe >= 2 && Xe <= 36), We = We.toString().replace(/\s+/g, "");
      var ot = 0;
      We[0] === "-" && (ot++, (this || _global$5$1).negative = 1), ot < We.length && (Xe === 16 ? this._parseHex(We, ot, rt) : (this._parseBase(We, Xe, ot), rt === "le" && this._initArray(this.toArray(), Xe, rt)));
    }, Ve.prototype._initNumber = function(We, Xe, rt) {
      We < 0 && ((this || _global$5$1).negative = 1, We = -We), We < 67108864 ? ((this || _global$5$1).words = [We & 67108863], (this || _global$5$1).length = 1) : We < 4503599627370496 ? ((this || _global$5$1).words = [We & 67108863, We / 67108864 & 67108863], (this || _global$5$1).length = 2) : (Fe(We < 9007199254740992), (this || _global$5$1).words = [We & 67108863, We / 67108864 & 67108863, 1], (this || _global$5$1).length = 3), rt === "le" && this._initArray(this.toArray(), Xe, rt);
    }, Ve.prototype._initArray = function(We, Xe, rt) {
      if (Fe(typeof We.length == "number"), We.length <= 0)
        return (this || _global$5$1).words = [0], (this || _global$5$1).length = 1, this || _global$5$1;
      (this || _global$5$1).length = Math.ceil(We.length / 3), (this || _global$5$1).words = new Array((this || _global$5$1).length);
      for (var ot = 0; ot < (this || _global$5$1).length; ot++)
        (this || _global$5$1).words[ot] = 0;
      var ft, mt, yt = 0;
      if (rt === "be")
        for (ot = We.length - 1, ft = 0; ot >= 0; ot -= 3)
          mt = We[ot] | We[ot - 1] << 8 | We[ot - 2] << 16, (this || _global$5$1).words[ft] |= mt << yt & 67108863, (this || _global$5$1).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      else if (rt === "le")
        for (ot = 0, ft = 0; ot < We.length; ot += 3)
          mt = We[ot] | We[ot + 1] << 8 | We[ot + 2] << 16, (this || _global$5$1).words[ft] |= mt << yt & 67108863, (this || _global$5$1).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      return this.strip();
    };
    function Qe(gt, We) {
      var Xe = gt.charCodeAt(We);
      return Xe >= 65 && Xe <= 70 ? Xe - 55 : Xe >= 97 && Xe <= 102 ? Xe - 87 : Xe - 48 & 15;
    }
    function at(gt, We, Xe) {
      var rt = Qe(gt, Xe);
      return Xe - 1 >= We && (rt |= Qe(gt, Xe - 1) << 4), rt;
    }
    Ve.prototype._parseHex = function(We, Xe, rt) {
      (this || _global$5$1).length = Math.ceil((We.length - Xe) / 6), (this || _global$5$1).words = new Array((this || _global$5$1).length);
      for (var ot = 0; ot < (this || _global$5$1).length; ot++)
        (this || _global$5$1).words[ot] = 0;
      var ft = 0, mt = 0, yt;
      if (rt === "be")
        for (ot = We.length - 1; ot >= Xe; ot -= 2)
          yt = at(We, Xe, ot) << ft, (this || _global$5$1).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$5$1).words[mt] |= yt >>> 26) : ft += 8;
      else {
        var pt = We.length - Xe;
        for (ot = pt % 2 === 0 ? Xe + 1 : Xe; ot < We.length; ot += 2)
          yt = at(We, Xe, ot) << ft, (this || _global$5$1).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$5$1).words[mt] |= yt >>> 26) : ft += 8;
      }
      this.strip();
    };
    function ut(gt, We, Xe, rt) {
      for (var ot = 0, ft = Math.min(gt.length, Xe), mt = We; mt < ft; mt++) {
        var yt = gt.charCodeAt(mt) - 48;
        ot *= rt, yt >= 49 ? ot += yt - 49 + 10 : yt >= 17 ? ot += yt - 17 + 10 : ot += yt;
      }
      return ot;
    }
    Ve.prototype._parseBase = function(We, Xe, rt) {
      (this || _global$5$1).words = [0], (this || _global$5$1).length = 1;
      for (var ot = 0, ft = 1; ft <= 67108863; ft *= Xe)
        ot++;
      ot--, ft = ft / Xe | 0;
      for (var mt = We.length - rt, yt = mt % ot, pt = Math.min(mt, mt - yt) + rt, Ge = 0, ct = rt; ct < pt; ct += ot)
        Ge = ut(We, ct, ct + ot, Xe), this.imuln(ft), (this || _global$5$1).words[0] + Ge < 67108864 ? (this || _global$5$1).words[0] += Ge : this._iaddn(Ge);
      if (yt !== 0) {
        var Mt = 1;
        for (Ge = ut(We, ct, We.length, Xe), ct = 0; ct < yt; ct++)
          Mt *= Xe;
        this.imuln(Mt), (this || _global$5$1).words[0] + Ge < 67108864 ? (this || _global$5$1).words[0] += Ge : this._iaddn(Ge);
      }
      this.strip();
    }, Ve.prototype.copy = function(We) {
      We.words = new Array((this || _global$5$1).length);
      for (var Xe = 0; Xe < (this || _global$5$1).length; Xe++)
        We.words[Xe] = (this || _global$5$1).words[Xe];
      We.length = (this || _global$5$1).length, We.negative = (this || _global$5$1).negative, We.red = (this || _global$5$1).red;
    }, Ve.prototype.clone = function() {
      var We = new Ve(null);
      return this.copy(We), We;
    }, Ve.prototype._expand = function(We) {
      for (; (this || _global$5$1).length < We; )
        (this || _global$5$1).words[(this || _global$5$1).length++] = 0;
      return this || _global$5$1;
    }, Ve.prototype.strip = function() {
      for (; (this || _global$5$1).length > 1 && (this || _global$5$1).words[(this || _global$5$1).length - 1] === 0; )
        (this || _global$5$1).length--;
      return this._normSign();
    }, Ve.prototype._normSign = function() {
      return (this || _global$5$1).length === 1 && (this || _global$5$1).words[0] === 0 && ((this || _global$5$1).negative = 0), this || _global$5$1;
    }, Ve.prototype.inspect = function() {
      return ((this || _global$5$1).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var lt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], dt = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], bt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    Ve.prototype.toString = function(We, Xe) {
      We = We || 10, Xe = Xe | 0 || 1;
      var rt;
      if (We === 16 || We === "hex") {
        rt = "";
        for (var ot = 0, ft = 0, mt = 0; mt < (this || _global$5$1).length; mt++) {
          var yt = (this || _global$5$1).words[mt], pt = ((yt << ot | ft) & 16777215).toString(16);
          ft = yt >>> 24 - ot & 16777215, ft !== 0 || mt !== (this || _global$5$1).length - 1 ? rt = lt[6 - pt.length] + pt + rt : rt = pt + rt, ot += 2, ot >= 26 && (ot -= 26, mt--);
        }
        for (ft !== 0 && (rt = ft.toString(16) + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$5$1).negative !== 0 && (rt = "-" + rt), rt;
      }
      if (We === (We | 0) && We >= 2 && We <= 36) {
        var Ge = dt[We], ct = bt[We];
        rt = "";
        var Mt = this.clone();
        for (Mt.negative = 0; !Mt.isZero(); ) {
          var St = Mt.modn(ct).toString(We);
          Mt = Mt.idivn(ct), Mt.isZero() ? rt = St + rt : rt = lt[Ge - St.length] + St + rt;
        }
        for (this.isZero() && (rt = "0" + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$5$1).negative !== 0 && (rt = "-" + rt), rt;
      }
      Fe(!1, "Base should be between 2 and 36");
    }, Ve.prototype.toNumber = function() {
      var We = (this || _global$5$1).words[0];
      return (this || _global$5$1).length === 2 ? We += (this || _global$5$1).words[1] * 67108864 : (this || _global$5$1).length === 3 && (this || _global$5$1).words[2] === 1 ? We += 4503599627370496 + (this || _global$5$1).words[1] * 67108864 : (this || _global$5$1).length > 2 && Fe(!1, "Number can only safely store up to 53 bits"), (this || _global$5$1).negative !== 0 ? -We : We;
    }, Ve.prototype.toJSON = function() {
      return this.toString(16);
    }, Ve.prototype.toBuffer = function(We, Xe) {
      return Fe(typeof Je < "u"), this.toArrayLike(Je, We, Xe);
    }, Ve.prototype.toArray = function(We, Xe) {
      return this.toArrayLike(Array, We, Xe);
    }, Ve.prototype.toArrayLike = function(We, Xe, rt) {
      var ot = this.byteLength(), ft = rt || Math.max(1, ot);
      Fe(ot <= ft, "byte array longer than desired length"), Fe(ft > 0, "Requested array length <= 0"), this.strip();
      var mt = Xe === "le", yt = new We(ft), pt, Ge, ct = this.clone();
      if (mt) {
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[Ge] = pt;
        for (; Ge < ft; Ge++)
          yt[Ge] = 0;
      } else {
        for (Ge = 0; Ge < ft - ot; Ge++)
          yt[Ge] = 0;
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[ft - Ge - 1] = pt;
      }
      return yt;
    }, Math.clz32 ? Ve.prototype._countBits = function(We) {
      return 32 - Math.clz32(We);
    } : Ve.prototype._countBits = function(We) {
      var Xe = We, rt = 0;
      return Xe >= 4096 && (rt += 13, Xe >>>= 13), Xe >= 64 && (rt += 7, Xe >>>= 7), Xe >= 8 && (rt += 4, Xe >>>= 4), Xe >= 2 && (rt += 2, Xe >>>= 2), rt + Xe;
    }, Ve.prototype._zeroBits = function(We) {
      if (We === 0)
        return 26;
      var Xe = We, rt = 0;
      return Xe & 8191 || (rt += 13, Xe >>>= 13), Xe & 127 || (rt += 7, Xe >>>= 7), Xe & 15 || (rt += 4, Xe >>>= 4), Xe & 3 || (rt += 2, Xe >>>= 2), Xe & 1 || rt++, rt;
    }, Ve.prototype.bitLength = function() {
      var We = (this || _global$5$1).words[(this || _global$5$1).length - 1], Xe = this._countBits(We);
      return ((this || _global$5$1).length - 1) * 26 + Xe;
    };
    function $t(gt) {
      for (var We = new Array(gt.bitLength()), Xe = 0; Xe < We.length; Xe++) {
        var rt = Xe / 26 | 0, ot = Xe % 26;
        We[Xe] = (gt.words[rt] & 1 << ot) >>> ot;
      }
      return We;
    }
    Ve.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var We = 0, Xe = 0; Xe < (this || _global$5$1).length; Xe++) {
        var rt = this._zeroBits((this || _global$5$1).words[Xe]);
        if (We += rt, rt !== 26)
          break;
      }
      return We;
    }, Ve.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Ve.prototype.toTwos = function(We) {
      return (this || _global$5$1).negative !== 0 ? this.abs().inotn(We).iaddn(1) : this.clone();
    }, Ve.prototype.fromTwos = function(We) {
      return this.testn(We - 1) ? this.notn(We).iaddn(1).ineg() : this.clone();
    }, Ve.prototype.isNeg = function() {
      return (this || _global$5$1).negative !== 0;
    }, Ve.prototype.neg = function() {
      return this.clone().ineg();
    }, Ve.prototype.ineg = function() {
      return this.isZero() || ((this || _global$5$1).negative ^= 1), this || _global$5$1;
    }, Ve.prototype.iuor = function(We) {
      for (; (this || _global$5$1).length < We.length; )
        (this || _global$5$1).words[(this || _global$5$1).length++] = 0;
      for (var Xe = 0; Xe < We.length; Xe++)
        (this || _global$5$1).words[Xe] = (this || _global$5$1).words[Xe] | We.words[Xe];
      return this.strip();
    }, Ve.prototype.ior = function(We) {
      return Fe(((this || _global$5$1).negative | We.negative) === 0), this.iuor(We);
    }, Ve.prototype.or = function(We) {
      return (this || _global$5$1).length > We.length ? this.clone().ior(We) : We.clone().ior(this || _global$5$1);
    }, Ve.prototype.uor = function(We) {
      return (this || _global$5$1).length > We.length ? this.clone().iuor(We) : We.clone().iuor(this || _global$5$1);
    }, Ve.prototype.iuand = function(We) {
      var Xe;
      (this || _global$5$1).length > We.length ? Xe = We : Xe = this || _global$5$1;
      for (var rt = 0; rt < Xe.length; rt++)
        (this || _global$5$1).words[rt] = (this || _global$5$1).words[rt] & We.words[rt];
      return (this || _global$5$1).length = Xe.length, this.strip();
    }, Ve.prototype.iand = function(We) {
      return Fe(((this || _global$5$1).negative | We.negative) === 0), this.iuand(We);
    }, Ve.prototype.and = function(We) {
      return (this || _global$5$1).length > We.length ? this.clone().iand(We) : We.clone().iand(this || _global$5$1);
    }, Ve.prototype.uand = function(We) {
      return (this || _global$5$1).length > We.length ? this.clone().iuand(We) : We.clone().iuand(this || _global$5$1);
    }, Ve.prototype.iuxor = function(We) {
      var Xe, rt;
      (this || _global$5$1).length > We.length ? (Xe = this || _global$5$1, rt = We) : (Xe = We, rt = this || _global$5$1);
      for (var ot = 0; ot < rt.length; ot++)
        (this || _global$5$1).words[ot] = Xe.words[ot] ^ rt.words[ot];
      if ((this || _global$5$1) !== Xe)
        for (; ot < Xe.length; ot++)
          (this || _global$5$1).words[ot] = Xe.words[ot];
      return (this || _global$5$1).length = Xe.length, this.strip();
    }, Ve.prototype.ixor = function(We) {
      return Fe(((this || _global$5$1).negative | We.negative) === 0), this.iuxor(We);
    }, Ve.prototype.xor = function(We) {
      return (this || _global$5$1).length > We.length ? this.clone().ixor(We) : We.clone().ixor(this || _global$5$1);
    }, Ve.prototype.uxor = function(We) {
      return (this || _global$5$1).length > We.length ? this.clone().iuxor(We) : We.clone().iuxor(this || _global$5$1);
    }, Ve.prototype.inotn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = Math.ceil(We / 26) | 0, rt = We % 26;
      this._expand(Xe), rt > 0 && Xe--;
      for (var ot = 0; ot < Xe; ot++)
        (this || _global$5$1).words[ot] = ~(this || _global$5$1).words[ot] & 67108863;
      return rt > 0 && ((this || _global$5$1).words[ot] = ~(this || _global$5$1).words[ot] & 67108863 >> 26 - rt), this.strip();
    }, Ve.prototype.notn = function(We) {
      return this.clone().inotn(We);
    }, Ve.prototype.setn = function(We, Xe) {
      Fe(typeof We == "number" && We >= 0);
      var rt = We / 26 | 0, ot = We % 26;
      return this._expand(rt + 1), Xe ? (this || _global$5$1).words[rt] = (this || _global$5$1).words[rt] | 1 << ot : (this || _global$5$1).words[rt] = (this || _global$5$1).words[rt] & ~(1 << ot), this.strip();
    }, Ve.prototype.iadd = function(We) {
      var Xe;
      if ((this || _global$5$1).negative !== 0 && We.negative === 0)
        return (this || _global$5$1).negative = 0, Xe = this.isub(We), (this || _global$5$1).negative ^= 1, this._normSign();
      if ((this || _global$5$1).negative === 0 && We.negative !== 0)
        return We.negative = 0, Xe = this.isub(We), We.negative = 1, Xe._normSign();
      var rt, ot;
      (this || _global$5$1).length > We.length ? (rt = this || _global$5$1, ot = We) : (rt = We, ot = this || _global$5$1);
      for (var ft = 0, mt = 0; mt < ot.length; mt++)
        Xe = (rt.words[mt] | 0) + (ot.words[mt] | 0) + ft, (this || _global$5$1).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      for (; ft !== 0 && mt < rt.length; mt++)
        Xe = (rt.words[mt] | 0) + ft, (this || _global$5$1).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      if ((this || _global$5$1).length = rt.length, ft !== 0)
        (this || _global$5$1).words[(this || _global$5$1).length] = ft, (this || _global$5$1).length++;
      else if (rt !== (this || _global$5$1))
        for (; mt < rt.length; mt++)
          (this || _global$5$1).words[mt] = rt.words[mt];
      return this || _global$5$1;
    }, Ve.prototype.add = function(We) {
      var Xe;
      return We.negative !== 0 && (this || _global$5$1).negative === 0 ? (We.negative = 0, Xe = this.sub(We), We.negative ^= 1, Xe) : We.negative === 0 && (this || _global$5$1).negative !== 0 ? ((this || _global$5$1).negative = 0, Xe = We.sub(this || _global$5$1), (this || _global$5$1).negative = 1, Xe) : (this || _global$5$1).length > We.length ? this.clone().iadd(We) : We.clone().iadd(this || _global$5$1);
    }, Ve.prototype.isub = function(We) {
      if (We.negative !== 0) {
        We.negative = 0;
        var Xe = this.iadd(We);
        return We.negative = 1, Xe._normSign();
      } else if ((this || _global$5$1).negative !== 0)
        return (this || _global$5$1).negative = 0, this.iadd(We), (this || _global$5$1).negative = 1, this._normSign();
      var rt = this.cmp(We);
      if (rt === 0)
        return (this || _global$5$1).negative = 0, (this || _global$5$1).length = 1, (this || _global$5$1).words[0] = 0, this || _global$5$1;
      var ot, ft;
      rt > 0 ? (ot = this || _global$5$1, ft = We) : (ot = We, ft = this || _global$5$1);
      for (var mt = 0, yt = 0; yt < ft.length; yt++)
        Xe = (ot.words[yt] | 0) - (ft.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$5$1).words[yt] = Xe & 67108863;
      for (; mt !== 0 && yt < ot.length; yt++)
        Xe = (ot.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$5$1).words[yt] = Xe & 67108863;
      if (mt === 0 && yt < ot.length && ot !== (this || _global$5$1))
        for (; yt < ot.length; yt++)
          (this || _global$5$1).words[yt] = ot.words[yt];
      return (this || _global$5$1).length = Math.max((this || _global$5$1).length, yt), ot !== (this || _global$5$1) && ((this || _global$5$1).negative = 1), this.strip();
    }, Ve.prototype.sub = function(We) {
      return this.clone().isub(We);
    };
    function vt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative;
      var rt = gt.length + We.length | 0;
      Xe.length = rt, rt = rt - 1 | 0;
      var ot = gt.words[0] | 0, ft = We.words[0] | 0, mt = ot * ft, yt = mt & 67108863, pt = mt / 67108864 | 0;
      Xe.words[0] = yt;
      for (var Ge = 1; Ge < rt; Ge++) {
        for (var ct = pt >>> 26, Mt = pt & 67108863, St = Math.min(Ge, We.length - 1), At = Math.max(0, Ge - gt.length + 1); At <= St; At++) {
          var Nt = Ge - At | 0;
          ot = gt.words[Nt] | 0, ft = We.words[At] | 0, mt = ot * ft + Mt, ct += mt / 67108864 | 0, Mt = mt & 67108863;
        }
        Xe.words[Ge] = Mt | 0, pt = ct | 0;
      }
      return pt !== 0 ? Xe.words[Ge] = pt | 0 : Xe.length--, Xe.strip();
    }
    var wt = function(We, Xe, rt) {
      var ot = We.words, ft = Xe.words, mt = rt.words, yt = 0, pt, Ge, ct, Mt = ot[0] | 0, St = Mt & 8191, At = Mt >>> 13, Nt = ot[1] | 0, qt = Nt & 8191, Qt = Nt >>> 13, Xt = ot[2] | 0, zt = Xt & 8191, Kt = Xt >>> 13, ur = ot[3] | 0, er = ur & 8191, Dt = ur >>> 13, Ht = ot[4] | 0, Gt = Ht & 8191, rr = Ht >>> 13, sr = ot[5] | 0, Jt = sr & 8191, ir = sr >>> 13, Br = ot[6] | 0, or = Br & 8191, lr = Br >>> 13, Nr = ot[7] | 0, dr = Nr & 8191, gr = Nr >>> 13, Zr = ot[8] | 0, Bt = Zr & 8191, kt = Zr >>> 13, It = ot[9] | 0, jt = It & 8191, Vt = It >>> 13, ar = ft[0] | 0, Yt = ar & 8191, hr = ar >>> 13, zr = ft[1] | 0, cr = zr & 8191, _r = zr >>> 13, Lr = ft[2] | 0, br = Lr & 8191, kr = Lr >>> 13, Xr = ft[3] | 0, yr = Xr & 8191, Ir = Xr >>> 13, Yr = ft[4] | 0, wr = Yr & 8191, Cr = Yr >>> 13, Hr = ft[5] | 0, $r = Hr & 8191, Ar = Hr >>> 13, Wr = ft[6] | 0, mr = Wr & 8191, Tr = Wr >>> 13, Kr = ft[7] | 0, vr = Kr & 8191, Rr = Kr >>> 13, Jr = ft[8] | 0, xr = Jr & 8191, tr = Jr >>> 13, Dr = ft[9] | 0, fr = Dr & 8191, Mr = Dr >>> 13;
      rt.negative = We.negative ^ Xe.negative, rt.length = 19, pt = Math.imul(St, Yt), Ge = Math.imul(St, hr), Ge = Ge + Math.imul(At, Yt) | 0, ct = Math.imul(At, hr);
      var Fr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, pt = Math.imul(qt, Yt), Ge = Math.imul(qt, hr), Ge = Ge + Math.imul(Qt, Yt) | 0, ct = Math.imul(Qt, hr), pt = pt + Math.imul(St, cr) | 0, Ge = Ge + Math.imul(St, _r) | 0, Ge = Ge + Math.imul(At, cr) | 0, ct = ct + Math.imul(At, _r) | 0;
      var qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, pt = Math.imul(zt, Yt), Ge = Math.imul(zt, hr), Ge = Ge + Math.imul(Kt, Yt) | 0, ct = Math.imul(Kt, hr), pt = pt + Math.imul(qt, cr) | 0, Ge = Ge + Math.imul(qt, _r) | 0, Ge = Ge + Math.imul(Qt, cr) | 0, ct = ct + Math.imul(Qt, _r) | 0, pt = pt + Math.imul(St, br) | 0, Ge = Ge + Math.imul(St, kr) | 0, Ge = Ge + Math.imul(At, br) | 0, ct = ct + Math.imul(At, kr) | 0;
      var tn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, pt = Math.imul(er, Yt), Ge = Math.imul(er, hr), Ge = Ge + Math.imul(Dt, Yt) | 0, ct = Math.imul(Dt, hr), pt = pt + Math.imul(zt, cr) | 0, Ge = Ge + Math.imul(zt, _r) | 0, Ge = Ge + Math.imul(Kt, cr) | 0, ct = ct + Math.imul(Kt, _r) | 0, pt = pt + Math.imul(qt, br) | 0, Ge = Ge + Math.imul(qt, kr) | 0, Ge = Ge + Math.imul(Qt, br) | 0, ct = ct + Math.imul(Qt, kr) | 0, pt = pt + Math.imul(St, yr) | 0, Ge = Ge + Math.imul(St, Ir) | 0, Ge = Ge + Math.imul(At, yr) | 0, ct = ct + Math.imul(At, Ir) | 0;
      var Qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, pt = Math.imul(Gt, Yt), Ge = Math.imul(Gt, hr), Ge = Ge + Math.imul(rr, Yt) | 0, ct = Math.imul(rr, hr), pt = pt + Math.imul(er, cr) | 0, Ge = Ge + Math.imul(er, _r) | 0, Ge = Ge + Math.imul(Dt, cr) | 0, ct = ct + Math.imul(Dt, _r) | 0, pt = pt + Math.imul(zt, br) | 0, Ge = Ge + Math.imul(zt, kr) | 0, Ge = Ge + Math.imul(Kt, br) | 0, ct = ct + Math.imul(Kt, kr) | 0, pt = pt + Math.imul(qt, yr) | 0, Ge = Ge + Math.imul(qt, Ir) | 0, Ge = Ge + Math.imul(Qt, yr) | 0, ct = ct + Math.imul(Qt, Ir) | 0, pt = pt + Math.imul(St, wr) | 0, Ge = Ge + Math.imul(St, Cr) | 0, Ge = Ge + Math.imul(At, wr) | 0, ct = ct + Math.imul(At, Cr) | 0;
      var nn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, pt = Math.imul(Jt, Yt), Ge = Math.imul(Jt, hr), Ge = Ge + Math.imul(ir, Yt) | 0, ct = Math.imul(ir, hr), pt = pt + Math.imul(Gt, cr) | 0, Ge = Ge + Math.imul(Gt, _r) | 0, Ge = Ge + Math.imul(rr, cr) | 0, ct = ct + Math.imul(rr, _r) | 0, pt = pt + Math.imul(er, br) | 0, Ge = Ge + Math.imul(er, kr) | 0, Ge = Ge + Math.imul(Dt, br) | 0, ct = ct + Math.imul(Dt, kr) | 0, pt = pt + Math.imul(zt, yr) | 0, Ge = Ge + Math.imul(zt, Ir) | 0, Ge = Ge + Math.imul(Kt, yr) | 0, ct = ct + Math.imul(Kt, Ir) | 0, pt = pt + Math.imul(qt, wr) | 0, Ge = Ge + Math.imul(qt, Cr) | 0, Ge = Ge + Math.imul(Qt, wr) | 0, ct = ct + Math.imul(Qt, Cr) | 0, pt = pt + Math.imul(St, $r) | 0, Ge = Ge + Math.imul(St, Ar) | 0, Ge = Ge + Math.imul(At, $r) | 0, ct = ct + Math.imul(At, Ar) | 0;
      var Er = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, pt = Math.imul(or, Yt), Ge = Math.imul(or, hr), Ge = Ge + Math.imul(lr, Yt) | 0, ct = Math.imul(lr, hr), pt = pt + Math.imul(Jt, cr) | 0, Ge = Ge + Math.imul(Jt, _r) | 0, Ge = Ge + Math.imul(ir, cr) | 0, ct = ct + Math.imul(ir, _r) | 0, pt = pt + Math.imul(Gt, br) | 0, Ge = Ge + Math.imul(Gt, kr) | 0, Ge = Ge + Math.imul(rr, br) | 0, ct = ct + Math.imul(rr, kr) | 0, pt = pt + Math.imul(er, yr) | 0, Ge = Ge + Math.imul(er, Ir) | 0, Ge = Ge + Math.imul(Dt, yr) | 0, ct = ct + Math.imul(Dt, Ir) | 0, pt = pt + Math.imul(zt, wr) | 0, Ge = Ge + Math.imul(zt, Cr) | 0, Ge = Ge + Math.imul(Kt, wr) | 0, ct = ct + Math.imul(Kt, Cr) | 0, pt = pt + Math.imul(qt, $r) | 0, Ge = Ge + Math.imul(qt, Ar) | 0, Ge = Ge + Math.imul(Qt, $r) | 0, ct = ct + Math.imul(Qt, Ar) | 0, pt = pt + Math.imul(St, mr) | 0, Ge = Ge + Math.imul(St, Tr) | 0, Ge = Ge + Math.imul(At, mr) | 0, ct = ct + Math.imul(At, Tr) | 0;
      var Wt = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, pt = Math.imul(dr, Yt), Ge = Math.imul(dr, hr), Ge = Ge + Math.imul(gr, Yt) | 0, ct = Math.imul(gr, hr), pt = pt + Math.imul(or, cr) | 0, Ge = Ge + Math.imul(or, _r) | 0, Ge = Ge + Math.imul(lr, cr) | 0, ct = ct + Math.imul(lr, _r) | 0, pt = pt + Math.imul(Jt, br) | 0, Ge = Ge + Math.imul(Jt, kr) | 0, Ge = Ge + Math.imul(ir, br) | 0, ct = ct + Math.imul(ir, kr) | 0, pt = pt + Math.imul(Gt, yr) | 0, Ge = Ge + Math.imul(Gt, Ir) | 0, Ge = Ge + Math.imul(rr, yr) | 0, ct = ct + Math.imul(rr, Ir) | 0, pt = pt + Math.imul(er, wr) | 0, Ge = Ge + Math.imul(er, Cr) | 0, Ge = Ge + Math.imul(Dt, wr) | 0, ct = ct + Math.imul(Dt, Cr) | 0, pt = pt + Math.imul(zt, $r) | 0, Ge = Ge + Math.imul(zt, Ar) | 0, Ge = Ge + Math.imul(Kt, $r) | 0, ct = ct + Math.imul(Kt, Ar) | 0, pt = pt + Math.imul(qt, mr) | 0, Ge = Ge + Math.imul(qt, Tr) | 0, Ge = Ge + Math.imul(Qt, mr) | 0, ct = ct + Math.imul(Qt, Tr) | 0, pt = pt + Math.imul(St, vr) | 0, Ge = Ge + Math.imul(St, Rr) | 0, Ge = Ge + Math.imul(At, vr) | 0, ct = ct + Math.imul(At, Rr) | 0;
      var nr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, pt = Math.imul(Bt, Yt), Ge = Math.imul(Bt, hr), Ge = Ge + Math.imul(kt, Yt) | 0, ct = Math.imul(kt, hr), pt = pt + Math.imul(dr, cr) | 0, Ge = Ge + Math.imul(dr, _r) | 0, Ge = Ge + Math.imul(gr, cr) | 0, ct = ct + Math.imul(gr, _r) | 0, pt = pt + Math.imul(or, br) | 0, Ge = Ge + Math.imul(or, kr) | 0, Ge = Ge + Math.imul(lr, br) | 0, ct = ct + Math.imul(lr, kr) | 0, pt = pt + Math.imul(Jt, yr) | 0, Ge = Ge + Math.imul(Jt, Ir) | 0, Ge = Ge + Math.imul(ir, yr) | 0, ct = ct + Math.imul(ir, Ir) | 0, pt = pt + Math.imul(Gt, wr) | 0, Ge = Ge + Math.imul(Gt, Cr) | 0, Ge = Ge + Math.imul(rr, wr) | 0, ct = ct + Math.imul(rr, Cr) | 0, pt = pt + Math.imul(er, $r) | 0, Ge = Ge + Math.imul(er, Ar) | 0, Ge = Ge + Math.imul(Dt, $r) | 0, ct = ct + Math.imul(Dt, Ar) | 0, pt = pt + Math.imul(zt, mr) | 0, Ge = Ge + Math.imul(zt, Tr) | 0, Ge = Ge + Math.imul(Kt, mr) | 0, ct = ct + Math.imul(Kt, Tr) | 0, pt = pt + Math.imul(qt, vr) | 0, Ge = Ge + Math.imul(qt, Rr) | 0, Ge = Ge + Math.imul(Qt, vr) | 0, ct = ct + Math.imul(Qt, Rr) | 0, pt = pt + Math.imul(St, xr) | 0, Ge = Ge + Math.imul(St, tr) | 0, Ge = Ge + Math.imul(At, xr) | 0, ct = ct + Math.imul(At, tr) | 0;
      var pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, pt = Math.imul(jt, Yt), Ge = Math.imul(jt, hr), Ge = Ge + Math.imul(Vt, Yt) | 0, ct = Math.imul(Vt, hr), pt = pt + Math.imul(Bt, cr) | 0, Ge = Ge + Math.imul(Bt, _r) | 0, Ge = Ge + Math.imul(kt, cr) | 0, ct = ct + Math.imul(kt, _r) | 0, pt = pt + Math.imul(dr, br) | 0, Ge = Ge + Math.imul(dr, kr) | 0, Ge = Ge + Math.imul(gr, br) | 0, ct = ct + Math.imul(gr, kr) | 0, pt = pt + Math.imul(or, yr) | 0, Ge = Ge + Math.imul(or, Ir) | 0, Ge = Ge + Math.imul(lr, yr) | 0, ct = ct + Math.imul(lr, Ir) | 0, pt = pt + Math.imul(Jt, wr) | 0, Ge = Ge + Math.imul(Jt, Cr) | 0, Ge = Ge + Math.imul(ir, wr) | 0, ct = ct + Math.imul(ir, Cr) | 0, pt = pt + Math.imul(Gt, $r) | 0, Ge = Ge + Math.imul(Gt, Ar) | 0, Ge = Ge + Math.imul(rr, $r) | 0, ct = ct + Math.imul(rr, Ar) | 0, pt = pt + Math.imul(er, mr) | 0, Ge = Ge + Math.imul(er, Tr) | 0, Ge = Ge + Math.imul(Dt, mr) | 0, ct = ct + Math.imul(Dt, Tr) | 0, pt = pt + Math.imul(zt, vr) | 0, Ge = Ge + Math.imul(zt, Rr) | 0, Ge = Ge + Math.imul(Kt, vr) | 0, ct = ct + Math.imul(Kt, Rr) | 0, pt = pt + Math.imul(qt, xr) | 0, Ge = Ge + Math.imul(qt, tr) | 0, Ge = Ge + Math.imul(Qt, xr) | 0, ct = ct + Math.imul(Qt, tr) | 0, pt = pt + Math.imul(St, fr) | 0, Ge = Ge + Math.imul(St, Mr) | 0, Ge = Ge + Math.imul(At, fr) | 0, ct = ct + Math.imul(At, Mr) | 0;
      var Pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, pt = Math.imul(jt, cr), Ge = Math.imul(jt, _r), Ge = Ge + Math.imul(Vt, cr) | 0, ct = Math.imul(Vt, _r), pt = pt + Math.imul(Bt, br) | 0, Ge = Ge + Math.imul(Bt, kr) | 0, Ge = Ge + Math.imul(kt, br) | 0, ct = ct + Math.imul(kt, kr) | 0, pt = pt + Math.imul(dr, yr) | 0, Ge = Ge + Math.imul(dr, Ir) | 0, Ge = Ge + Math.imul(gr, yr) | 0, ct = ct + Math.imul(gr, Ir) | 0, pt = pt + Math.imul(or, wr) | 0, Ge = Ge + Math.imul(or, Cr) | 0, Ge = Ge + Math.imul(lr, wr) | 0, ct = ct + Math.imul(lr, Cr) | 0, pt = pt + Math.imul(Jt, $r) | 0, Ge = Ge + Math.imul(Jt, Ar) | 0, Ge = Ge + Math.imul(ir, $r) | 0, ct = ct + Math.imul(ir, Ar) | 0, pt = pt + Math.imul(Gt, mr) | 0, Ge = Ge + Math.imul(Gt, Tr) | 0, Ge = Ge + Math.imul(rr, mr) | 0, ct = ct + Math.imul(rr, Tr) | 0, pt = pt + Math.imul(er, vr) | 0, Ge = Ge + Math.imul(er, Rr) | 0, Ge = Ge + Math.imul(Dt, vr) | 0, ct = ct + Math.imul(Dt, Rr) | 0, pt = pt + Math.imul(zt, xr) | 0, Ge = Ge + Math.imul(zt, tr) | 0, Ge = Ge + Math.imul(Kt, xr) | 0, ct = ct + Math.imul(Kt, tr) | 0, pt = pt + Math.imul(qt, fr) | 0, Ge = Ge + Math.imul(qt, Mr) | 0, Ge = Ge + Math.imul(Qt, fr) | 0, ct = ct + Math.imul(Qt, Mr) | 0;
      var Sr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, pt = Math.imul(jt, br), Ge = Math.imul(jt, kr), Ge = Ge + Math.imul(Vt, br) | 0, ct = Math.imul(Vt, kr), pt = pt + Math.imul(Bt, yr) | 0, Ge = Ge + Math.imul(Bt, Ir) | 0, Ge = Ge + Math.imul(kt, yr) | 0, ct = ct + Math.imul(kt, Ir) | 0, pt = pt + Math.imul(dr, wr) | 0, Ge = Ge + Math.imul(dr, Cr) | 0, Ge = Ge + Math.imul(gr, wr) | 0, ct = ct + Math.imul(gr, Cr) | 0, pt = pt + Math.imul(or, $r) | 0, Ge = Ge + Math.imul(or, Ar) | 0, Ge = Ge + Math.imul(lr, $r) | 0, ct = ct + Math.imul(lr, Ar) | 0, pt = pt + Math.imul(Jt, mr) | 0, Ge = Ge + Math.imul(Jt, Tr) | 0, Ge = Ge + Math.imul(ir, mr) | 0, ct = ct + Math.imul(ir, Tr) | 0, pt = pt + Math.imul(Gt, vr) | 0, Ge = Ge + Math.imul(Gt, Rr) | 0, Ge = Ge + Math.imul(rr, vr) | 0, ct = ct + Math.imul(rr, Rr) | 0, pt = pt + Math.imul(er, xr) | 0, Ge = Ge + Math.imul(er, tr) | 0, Ge = Ge + Math.imul(Dt, xr) | 0, ct = ct + Math.imul(Dt, tr) | 0, pt = pt + Math.imul(zt, fr) | 0, Ge = Ge + Math.imul(zt, Mr) | 0, Ge = Ge + Math.imul(Kt, fr) | 0, ct = ct + Math.imul(Kt, Mr) | 0;
      var Ur = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, pt = Math.imul(jt, yr), Ge = Math.imul(jt, Ir), Ge = Ge + Math.imul(Vt, yr) | 0, ct = Math.imul(Vt, Ir), pt = pt + Math.imul(Bt, wr) | 0, Ge = Ge + Math.imul(Bt, Cr) | 0, Ge = Ge + Math.imul(kt, wr) | 0, ct = ct + Math.imul(kt, Cr) | 0, pt = pt + Math.imul(dr, $r) | 0, Ge = Ge + Math.imul(dr, Ar) | 0, Ge = Ge + Math.imul(gr, $r) | 0, ct = ct + Math.imul(gr, Ar) | 0, pt = pt + Math.imul(or, mr) | 0, Ge = Ge + Math.imul(or, Tr) | 0, Ge = Ge + Math.imul(lr, mr) | 0, ct = ct + Math.imul(lr, Tr) | 0, pt = pt + Math.imul(Jt, vr) | 0, Ge = Ge + Math.imul(Jt, Rr) | 0, Ge = Ge + Math.imul(ir, vr) | 0, ct = ct + Math.imul(ir, Rr) | 0, pt = pt + Math.imul(Gt, xr) | 0, Ge = Ge + Math.imul(Gt, tr) | 0, Ge = Ge + Math.imul(rr, xr) | 0, ct = ct + Math.imul(rr, tr) | 0, pt = pt + Math.imul(er, fr) | 0, Ge = Ge + Math.imul(er, Mr) | 0, Ge = Ge + Math.imul(Dt, fr) | 0, ct = ct + Math.imul(Dt, Mr) | 0;
      var jr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, pt = Math.imul(jt, wr), Ge = Math.imul(jt, Cr), Ge = Ge + Math.imul(Vt, wr) | 0, ct = Math.imul(Vt, Cr), pt = pt + Math.imul(Bt, $r) | 0, Ge = Ge + Math.imul(Bt, Ar) | 0, Ge = Ge + Math.imul(kt, $r) | 0, ct = ct + Math.imul(kt, Ar) | 0, pt = pt + Math.imul(dr, mr) | 0, Ge = Ge + Math.imul(dr, Tr) | 0, Ge = Ge + Math.imul(gr, mr) | 0, ct = ct + Math.imul(gr, Tr) | 0, pt = pt + Math.imul(or, vr) | 0, Ge = Ge + Math.imul(or, Rr) | 0, Ge = Ge + Math.imul(lr, vr) | 0, ct = ct + Math.imul(lr, Rr) | 0, pt = pt + Math.imul(Jt, xr) | 0, Ge = Ge + Math.imul(Jt, tr) | 0, Ge = Ge + Math.imul(ir, xr) | 0, ct = ct + Math.imul(ir, tr) | 0, pt = pt + Math.imul(Gt, fr) | 0, Ge = Ge + Math.imul(Gt, Mr) | 0, Ge = Ge + Math.imul(rr, fr) | 0, ct = ct + Math.imul(rr, Mr) | 0;
      var Gr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, pt = Math.imul(jt, $r), Ge = Math.imul(jt, Ar), Ge = Ge + Math.imul(Vt, $r) | 0, ct = Math.imul(Vt, Ar), pt = pt + Math.imul(Bt, mr) | 0, Ge = Ge + Math.imul(Bt, Tr) | 0, Ge = Ge + Math.imul(kt, mr) | 0, ct = ct + Math.imul(kt, Tr) | 0, pt = pt + Math.imul(dr, vr) | 0, Ge = Ge + Math.imul(dr, Rr) | 0, Ge = Ge + Math.imul(gr, vr) | 0, ct = ct + Math.imul(gr, Rr) | 0, pt = pt + Math.imul(or, xr) | 0, Ge = Ge + Math.imul(or, tr) | 0, Ge = Ge + Math.imul(lr, xr) | 0, ct = ct + Math.imul(lr, tr) | 0, pt = pt + Math.imul(Jt, fr) | 0, Ge = Ge + Math.imul(Jt, Mr) | 0, Ge = Ge + Math.imul(ir, fr) | 0, ct = ct + Math.imul(ir, Mr) | 0;
      var Vr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, pt = Math.imul(jt, mr), Ge = Math.imul(jt, Tr), Ge = Ge + Math.imul(Vt, mr) | 0, ct = Math.imul(Vt, Tr), pt = pt + Math.imul(Bt, vr) | 0, Ge = Ge + Math.imul(Bt, Rr) | 0, Ge = Ge + Math.imul(kt, vr) | 0, ct = ct + Math.imul(kt, Rr) | 0, pt = pt + Math.imul(dr, xr) | 0, Ge = Ge + Math.imul(dr, tr) | 0, Ge = Ge + Math.imul(gr, xr) | 0, ct = ct + Math.imul(gr, tr) | 0, pt = pt + Math.imul(or, fr) | 0, Ge = Ge + Math.imul(or, Mr) | 0, Ge = Ge + Math.imul(lr, fr) | 0, ct = ct + Math.imul(lr, Mr) | 0;
      var rn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, pt = Math.imul(jt, vr), Ge = Math.imul(jt, Rr), Ge = Ge + Math.imul(Vt, vr) | 0, ct = Math.imul(Vt, Rr), pt = pt + Math.imul(Bt, xr) | 0, Ge = Ge + Math.imul(Bt, tr) | 0, Ge = Ge + Math.imul(kt, xr) | 0, ct = ct + Math.imul(kt, tr) | 0, pt = pt + Math.imul(dr, fr) | 0, Ge = Ge + Math.imul(dr, Mr) | 0, Ge = Ge + Math.imul(gr, fr) | 0, ct = ct + Math.imul(gr, Mr) | 0;
      var an = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, pt = Math.imul(jt, xr), Ge = Math.imul(jt, tr), Ge = Ge + Math.imul(Vt, xr) | 0, ct = Math.imul(Vt, tr), pt = pt + Math.imul(Bt, fr) | 0, Ge = Ge + Math.imul(Bt, Mr) | 0, Ge = Ge + Math.imul(kt, fr) | 0, ct = ct + Math.imul(kt, Mr) | 0;
      var ln = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, pt = Math.imul(jt, fr), Ge = Math.imul(jt, Mr), Ge = Ge + Math.imul(Vt, fr) | 0, ct = Math.imul(Vt, Mr);
      var sn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      return yt = (ct + (Ge >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, mt[0] = Fr, mt[1] = qr, mt[2] = tn, mt[3] = Qr, mt[4] = nn, mt[5] = Er, mt[6] = Wt, mt[7] = nr, mt[8] = pr, mt[9] = Pr, mt[10] = Sr, mt[11] = Ur, mt[12] = jr, mt[13] = Gr, mt[14] = Vr, mt[15] = rn, mt[16] = an, mt[17] = ln, mt[18] = sn, yt !== 0 && (mt[19] = yt, rt.length++), rt;
    };
    Math.imul || (wt = vt);
    function xt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative, Xe.length = gt.length + We.length;
      for (var rt = 0, ot = 0, ft = 0; ft < Xe.length - 1; ft++) {
        var mt = ot;
        ot = 0;
        for (var yt = rt & 67108863, pt = Math.min(ft, We.length - 1), Ge = Math.max(0, ft - gt.length + 1); Ge <= pt; Ge++) {
          var ct = ft - Ge, Mt = gt.words[ct] | 0, St = We.words[Ge] | 0, At = Mt * St, Nt = At & 67108863;
          mt = mt + (At / 67108864 | 0) | 0, Nt = Nt + yt | 0, yt = Nt & 67108863, mt = mt + (Nt >>> 26) | 0, ot += mt >>> 26, mt &= 67108863;
        }
        Xe.words[ft] = yt, rt = mt, mt = ot;
      }
      return rt !== 0 ? Xe.words[ft] = rt : Xe.length--, Xe.strip();
    }
    function Et(gt, We, Xe) {
      var rt = new Tt();
      return rt.mulp(gt, We, Xe);
    }
    Ve.prototype.mulTo = function(We, Xe) {
      var rt, ot = (this || _global$5$1).length + We.length;
      return (this || _global$5$1).length === 10 && We.length === 10 ? rt = wt(this || _global$5$1, We, Xe) : ot < 63 ? rt = vt(this || _global$5$1, We, Xe) : ot < 1024 ? rt = xt(this || _global$5$1, We, Xe) : rt = Et(this || _global$5$1, We, Xe), rt;
    };
    function Tt(gt, We) {
      (this || _global$5$1).x = gt, (this || _global$5$1).y = We;
    }
    Tt.prototype.makeRBT = function(We) {
      for (var Xe = new Array(We), rt = Ve.prototype._countBits(We) - 1, ot = 0; ot < We; ot++)
        Xe[ot] = this.revBin(ot, rt, We);
      return Xe;
    }, Tt.prototype.revBin = function(We, Xe, rt) {
      if (We === 0 || We === rt - 1)
        return We;
      for (var ot = 0, ft = 0; ft < Xe; ft++)
        ot |= (We & 1) << Xe - ft - 1, We >>= 1;
      return ot;
    }, Tt.prototype.permute = function(We, Xe, rt, ot, ft, mt) {
      for (var yt = 0; yt < mt; yt++)
        ot[yt] = Xe[We[yt]], ft[yt] = rt[We[yt]];
    }, Tt.prototype.transform = function(We, Xe, rt, ot, ft, mt) {
      this.permute(mt, We, Xe, rt, ot, ft);
      for (var yt = 1; yt < ft; yt <<= 1)
        for (var pt = yt << 1, Ge = Math.cos(2 * Math.PI / pt), ct = Math.sin(2 * Math.PI / pt), Mt = 0; Mt < ft; Mt += pt)
          for (var St = Ge, At = ct, Nt = 0; Nt < yt; Nt++) {
            var qt = rt[Mt + Nt], Qt = ot[Mt + Nt], Xt = rt[Mt + Nt + yt], zt = ot[Mt + Nt + yt], Kt = St * Xt - At * zt;
            zt = St * zt + At * Xt, Xt = Kt, rt[Mt + Nt] = qt + Xt, ot[Mt + Nt] = Qt + zt, rt[Mt + Nt + yt] = qt - Xt, ot[Mt + Nt + yt] = Qt - zt, Nt !== pt && (Kt = Ge * St - ct * At, At = Ge * At + ct * St, St = Kt);
          }
    }, Tt.prototype.guessLen13b = function(We, Xe) {
      var rt = Math.max(Xe, We) | 1, ot = rt & 1, ft = 0;
      for (rt = rt / 2 | 0; rt; rt = rt >>> 1)
        ft++;
      return 1 << ft + 1 + ot;
    }, Tt.prototype.conjugate = function(We, Xe, rt) {
      if (!(rt <= 1))
        for (var ot = 0; ot < rt / 2; ot++) {
          var ft = We[ot];
          We[ot] = We[rt - ot - 1], We[rt - ot - 1] = ft, ft = Xe[ot], Xe[ot] = -Xe[rt - ot - 1], Xe[rt - ot - 1] = -ft;
        }
    }, Tt.prototype.normalize13b = function(We, Xe) {
      for (var rt = 0, ot = 0; ot < Xe / 2; ot++) {
        var ft = Math.round(We[2 * ot + 1] / Xe) * 8192 + Math.round(We[2 * ot] / Xe) + rt;
        We[ot] = ft & 67108863, ft < 67108864 ? rt = 0 : rt = ft / 67108864 | 0;
      }
      return We;
    }, Tt.prototype.convert13b = function(We, Xe, rt, ot) {
      for (var ft = 0, mt = 0; mt < Xe; mt++)
        ft = ft + (We[mt] | 0), rt[2 * mt] = ft & 8191, ft = ft >>> 13, rt[2 * mt + 1] = ft & 8191, ft = ft >>> 13;
      for (mt = 2 * Xe; mt < ot; ++mt)
        rt[mt] = 0;
      Fe(ft === 0), Fe((ft & -8192) === 0);
    }, Tt.prototype.stub = function(We) {
      for (var Xe = new Array(We), rt = 0; rt < We; rt++)
        Xe[rt] = 0;
      return Xe;
    }, Tt.prototype.mulp = function(We, Xe, rt) {
      var ot = 2 * this.guessLen13b(We.length, Xe.length), ft = this.makeRBT(ot), mt = this.stub(ot), yt = new Array(ot), pt = new Array(ot), Ge = new Array(ot), ct = new Array(ot), Mt = new Array(ot), St = new Array(ot), At = rt.words;
      At.length = ot, this.convert13b(We.words, We.length, yt, ot), this.convert13b(Xe.words, Xe.length, ct, ot), this.transform(yt, mt, pt, Ge, ot, ft), this.transform(ct, mt, Mt, St, ot, ft);
      for (var Nt = 0; Nt < ot; Nt++) {
        var qt = pt[Nt] * Mt[Nt] - Ge[Nt] * St[Nt];
        Ge[Nt] = pt[Nt] * St[Nt] + Ge[Nt] * Mt[Nt], pt[Nt] = qt;
      }
      return this.conjugate(pt, Ge, ot), this.transform(pt, Ge, At, mt, ot, ft), this.conjugate(At, mt, ot), this.normalize13b(At, ot), rt.negative = We.negative ^ Xe.negative, rt.length = We.length + Xe.length, rt.strip();
    }, Ve.prototype.mul = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$5$1).length + We.length), this.mulTo(We, Xe);
    }, Ve.prototype.mulf = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$5$1).length + We.length), Et(this || _global$5$1, We, Xe);
    }, Ve.prototype.imul = function(We) {
      return this.clone().mulTo(We, this || _global$5$1);
    }, Ve.prototype.imuln = function(We) {
      Fe(typeof We == "number"), Fe(We < 67108864);
      for (var Xe = 0, rt = 0; rt < (this || _global$5$1).length; rt++) {
        var ot = ((this || _global$5$1).words[rt] | 0) * We, ft = (ot & 67108863) + (Xe & 67108863);
        Xe >>= 26, Xe += ot / 67108864 | 0, Xe += ft >>> 26, (this || _global$5$1).words[rt] = ft & 67108863;
      }
      return Xe !== 0 && ((this || _global$5$1).words[rt] = Xe, (this || _global$5$1).length++), this || _global$5$1;
    }, Ve.prototype.muln = function(We) {
      return this.clone().imuln(We);
    }, Ve.prototype.sqr = function() {
      return this.mul(this || _global$5$1);
    }, Ve.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Ve.prototype.pow = function(We) {
      var Xe = $t(We);
      if (Xe.length === 0)
        return new Ve(1);
      for (var rt = this || _global$5$1, ot = 0; ot < Xe.length && Xe[ot] === 0; ot++, rt = rt.sqr())
        ;
      if (++ot < Xe.length)
        for (var ft = rt.sqr(); ot < Xe.length; ot++, ft = ft.sqr())
          Xe[ot] !== 0 && (rt = rt.mul(ft));
      return rt;
    }, Ve.prototype.iushln = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 67108863 >>> 26 - Xe << 26 - Xe, ft;
      if (Xe !== 0) {
        var mt = 0;
        for (ft = 0; ft < (this || _global$5$1).length; ft++) {
          var yt = (this || _global$5$1).words[ft] & ot, pt = ((this || _global$5$1).words[ft] | 0) - yt << Xe;
          (this || _global$5$1).words[ft] = pt | mt, mt = yt >>> 26 - Xe;
        }
        mt && ((this || _global$5$1).words[ft] = mt, (this || _global$5$1).length++);
      }
      if (rt !== 0) {
        for (ft = (this || _global$5$1).length - 1; ft >= 0; ft--)
          (this || _global$5$1).words[ft + rt] = (this || _global$5$1).words[ft];
        for (ft = 0; ft < rt; ft++)
          (this || _global$5$1).words[ft] = 0;
        (this || _global$5$1).length += rt;
      }
      return this.strip();
    }, Ve.prototype.ishln = function(We) {
      return Fe((this || _global$5$1).negative === 0), this.iushln(We);
    }, Ve.prototype.iushrn = function(We, Xe, rt) {
      Fe(typeof We == "number" && We >= 0);
      var ot;
      Xe ? ot = (Xe - Xe % 26) / 26 : ot = 0;
      var ft = We % 26, mt = Math.min((We - ft) / 26, (this || _global$5$1).length), yt = 67108863 ^ 67108863 >>> ft << ft, pt = rt;
      if (ot -= mt, ot = Math.max(0, ot), pt) {
        for (var Ge = 0; Ge < mt; Ge++)
          pt.words[Ge] = (this || _global$5$1).words[Ge];
        pt.length = mt;
      }
      if (mt !== 0)
        if ((this || _global$5$1).length > mt)
          for ((this || _global$5$1).length -= mt, Ge = 0; Ge < (this || _global$5$1).length; Ge++)
            (this || _global$5$1).words[Ge] = (this || _global$5$1).words[Ge + mt];
        else
          (this || _global$5$1).words[0] = 0, (this || _global$5$1).length = 1;
      var ct = 0;
      for (Ge = (this || _global$5$1).length - 1; Ge >= 0 && (ct !== 0 || Ge >= ot); Ge--) {
        var Mt = (this || _global$5$1).words[Ge] | 0;
        (this || _global$5$1).words[Ge] = ct << 26 - ft | Mt >>> ft, ct = Mt & yt;
      }
      return pt && ct !== 0 && (pt.words[pt.length++] = ct), (this || _global$5$1).length === 0 && ((this || _global$5$1).words[0] = 0, (this || _global$5$1).length = 1), this.strip();
    }, Ve.prototype.ishrn = function(We, Xe, rt) {
      return Fe((this || _global$5$1).negative === 0), this.iushrn(We, Xe, rt);
    }, Ve.prototype.shln = function(We) {
      return this.clone().ishln(We);
    }, Ve.prototype.ushln = function(We) {
      return this.clone().iushln(We);
    }, Ve.prototype.shrn = function(We) {
      return this.clone().ishrn(We);
    }, Ve.prototype.ushrn = function(We) {
      return this.clone().iushrn(We);
    }, Ve.prototype.testn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$5$1).length <= rt)
        return !1;
      var ft = (this || _global$5$1).words[rt];
      return !!(ft & ot);
    }, Ve.prototype.imaskn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26;
      if (Fe((this || _global$5$1).negative === 0, "imaskn works only with positive numbers"), (this || _global$5$1).length <= rt)
        return this || _global$5$1;
      if (Xe !== 0 && rt++, (this || _global$5$1).length = Math.min(rt, (this || _global$5$1).length), Xe !== 0) {
        var ot = 67108863 ^ 67108863 >>> Xe << Xe;
        (this || _global$5$1).words[(this || _global$5$1).length - 1] &= ot;
      }
      return this.strip();
    }, Ve.prototype.maskn = function(We) {
      return this.clone().imaskn(We);
    }, Ve.prototype.iaddn = function(We) {
      return Fe(typeof We == "number"), Fe(We < 67108864), We < 0 ? this.isubn(-We) : (this || _global$5$1).negative !== 0 ? (this || _global$5$1).length === 1 && ((this || _global$5$1).words[0] | 0) < We ? ((this || _global$5$1).words[0] = We - ((this || _global$5$1).words[0] | 0), (this || _global$5$1).negative = 0, this || _global$5$1) : ((this || _global$5$1).negative = 0, this.isubn(We), (this || _global$5$1).negative = 1, this || _global$5$1) : this._iaddn(We);
    }, Ve.prototype._iaddn = function(We) {
      (this || _global$5$1).words[0] += We;
      for (var Xe = 0; Xe < (this || _global$5$1).length && (this || _global$5$1).words[Xe] >= 67108864; Xe++)
        (this || _global$5$1).words[Xe] -= 67108864, Xe === (this || _global$5$1).length - 1 ? (this || _global$5$1).words[Xe + 1] = 1 : (this || _global$5$1).words[Xe + 1]++;
      return (this || _global$5$1).length = Math.max((this || _global$5$1).length, Xe + 1), this || _global$5$1;
    }, Ve.prototype.isubn = function(We) {
      if (Fe(typeof We == "number"), Fe(We < 67108864), We < 0)
        return this.iaddn(-We);
      if ((this || _global$5$1).negative !== 0)
        return (this || _global$5$1).negative = 0, this.iaddn(We), (this || _global$5$1).negative = 1, this || _global$5$1;
      if ((this || _global$5$1).words[0] -= We, (this || _global$5$1).length === 1 && (this || _global$5$1).words[0] < 0)
        (this || _global$5$1).words[0] = -(this || _global$5$1).words[0], (this || _global$5$1).negative = 1;
      else
        for (var Xe = 0; Xe < (this || _global$5$1).length && (this || _global$5$1).words[Xe] < 0; Xe++)
          (this || _global$5$1).words[Xe] += 67108864, (this || _global$5$1).words[Xe + 1] -= 1;
      return this.strip();
    }, Ve.prototype.addn = function(We) {
      return this.clone().iaddn(We);
    }, Ve.prototype.subn = function(We) {
      return this.clone().isubn(We);
    }, Ve.prototype.iabs = function() {
      return (this || _global$5$1).negative = 0, this || _global$5$1;
    }, Ve.prototype.abs = function() {
      return this.clone().iabs();
    }, Ve.prototype._ishlnsubmul = function(We, Xe, rt) {
      var ot = We.length + rt, ft;
      this._expand(ot);
      var mt, yt = 0;
      for (ft = 0; ft < We.length; ft++) {
        mt = ((this || _global$5$1).words[ft + rt] | 0) + yt;
        var pt = (We.words[ft] | 0) * Xe;
        mt -= pt & 67108863, yt = (mt >> 26) - (pt / 67108864 | 0), (this || _global$5$1).words[ft + rt] = mt & 67108863;
      }
      for (; ft < (this || _global$5$1).length - rt; ft++)
        mt = ((this || _global$5$1).words[ft + rt] | 0) + yt, yt = mt >> 26, (this || _global$5$1).words[ft + rt] = mt & 67108863;
      if (yt === 0)
        return this.strip();
      for (Fe(yt === -1), yt = 0, ft = 0; ft < (this || _global$5$1).length; ft++)
        mt = -((this || _global$5$1).words[ft] | 0) + yt, yt = mt >> 26, (this || _global$5$1).words[ft] = mt & 67108863;
      return (this || _global$5$1).negative = 1, this.strip();
    }, Ve.prototype._wordDiv = function(We, Xe) {
      var rt = (this || _global$5$1).length - We.length, ot = this.clone(), ft = We, mt = ft.words[ft.length - 1] | 0, yt = this._countBits(mt);
      rt = 26 - yt, rt !== 0 && (ft = ft.ushln(rt), ot.iushln(rt), mt = ft.words[ft.length - 1] | 0);
      var pt = ot.length - ft.length, Ge;
      if (Xe !== "mod") {
        Ge = new Ve(null), Ge.length = pt + 1, Ge.words = new Array(Ge.length);
        for (var ct = 0; ct < Ge.length; ct++)
          Ge.words[ct] = 0;
      }
      var Mt = ot.clone()._ishlnsubmul(ft, 1, pt);
      Mt.negative === 0 && (ot = Mt, Ge && (Ge.words[pt] = 1));
      for (var St = pt - 1; St >= 0; St--) {
        var At = (ot.words[ft.length + St] | 0) * 67108864 + (ot.words[ft.length + St - 1] | 0);
        for (At = Math.min(At / mt | 0, 67108863), ot._ishlnsubmul(ft, At, St); ot.negative !== 0; )
          At--, ot.negative = 0, ot._ishlnsubmul(ft, 1, St), ot.isZero() || (ot.negative ^= 1);
        Ge && (Ge.words[St] = At);
      }
      return Ge && Ge.strip(), ot.strip(), Xe !== "div" && rt !== 0 && ot.iushrn(rt), {
        div: Ge || null,
        mod: ot
      };
    }, Ve.prototype.divmod = function(We, Xe, rt) {
      if (Fe(!We.isZero()), this.isZero())
        return {
          div: new Ve(0),
          mod: new Ve(0)
        };
      var ot, ft, mt;
      return (this || _global$5$1).negative !== 0 && We.negative === 0 ? (mt = this.neg().divmod(We, Xe), Xe !== "mod" && (ot = mt.div.neg()), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.iadd(We)), {
        div: ot,
        mod: ft
      }) : (this || _global$5$1).negative === 0 && We.negative !== 0 ? (mt = this.divmod(We.neg(), Xe), Xe !== "mod" && (ot = mt.div.neg()), {
        div: ot,
        mod: mt.mod
      }) : (this || _global$5$1).negative & We.negative ? (mt = this.neg().divmod(We.neg(), Xe), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.isub(We)), {
        div: mt.div,
        mod: ft
      }) : We.length > (this || _global$5$1).length || this.cmp(We) < 0 ? {
        div: new Ve(0),
        mod: this || _global$5$1
      } : We.length === 1 ? Xe === "div" ? {
        div: this.divn(We.words[0]),
        mod: null
      } : Xe === "mod" ? {
        div: null,
        mod: new Ve(this.modn(We.words[0]))
      } : {
        div: this.divn(We.words[0]),
        mod: new Ve(this.modn(We.words[0]))
      } : this._wordDiv(We, Xe);
    }, Ve.prototype.div = function(We) {
      return this.divmod(We, "div", !1).div;
    }, Ve.prototype.mod = function(We) {
      return this.divmod(We, "mod", !1).mod;
    }, Ve.prototype.umod = function(We) {
      return this.divmod(We, "mod", !0).mod;
    }, Ve.prototype.divRound = function(We) {
      var Xe = this.divmod(We);
      if (Xe.mod.isZero())
        return Xe.div;
      var rt = Xe.div.negative !== 0 ? Xe.mod.isub(We) : Xe.mod, ot = We.ushrn(1), ft = We.andln(1), mt = rt.cmp(ot);
      return mt < 0 || ft === 1 && mt === 0 ? Xe.div : Xe.div.negative !== 0 ? Xe.div.isubn(1) : Xe.div.iaddn(1);
    }, Ve.prototype.modn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = (1 << 26) % We, rt = 0, ot = (this || _global$5$1).length - 1; ot >= 0; ot--)
        rt = (Xe * rt + ((this || _global$5$1).words[ot] | 0)) % We;
      return rt;
    }, Ve.prototype.idivn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = 0, rt = (this || _global$5$1).length - 1; rt >= 0; rt--) {
        var ot = ((this || _global$5$1).words[rt] | 0) + Xe * 67108864;
        (this || _global$5$1).words[rt] = ot / We | 0, Xe = ot % We;
      }
      return this.strip();
    }, Ve.prototype.divn = function(We) {
      return this.clone().idivn(We);
    }, Ve.prototype.egcd = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$5$1, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = new Ve(0), yt = new Ve(1), pt = 0; Xe.isEven() && rt.isEven(); )
        Xe.iushrn(1), rt.iushrn(1), ++pt;
      for (var Ge = rt.clone(), ct = Xe.clone(); !Xe.isZero(); ) {
        for (var Mt = 0, St = 1; !(Xe.words[0] & St) && Mt < 26; ++Mt, St <<= 1)
          ;
        if (Mt > 0)
          for (Xe.iushrn(Mt); Mt-- > 0; )
            (ot.isOdd() || ft.isOdd()) && (ot.iadd(Ge), ft.isub(ct)), ot.iushrn(1), ft.iushrn(1);
        for (var At = 0, Nt = 1; !(rt.words[0] & Nt) && At < 26; ++At, Nt <<= 1)
          ;
        if (At > 0)
          for (rt.iushrn(At); At-- > 0; )
            (mt.isOdd() || yt.isOdd()) && (mt.iadd(Ge), yt.isub(ct)), mt.iushrn(1), yt.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(mt), ft.isub(yt)) : (rt.isub(Xe), mt.isub(ot), yt.isub(ft));
      }
      return {
        a: mt,
        b: yt,
        gcd: rt.iushln(pt)
      };
    }, Ve.prototype._invmp = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$5$1, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = rt.clone(); Xe.cmpn(1) > 0 && rt.cmpn(1) > 0; ) {
        for (var yt = 0, pt = 1; !(Xe.words[0] & pt) && yt < 26; ++yt, pt <<= 1)
          ;
        if (yt > 0)
          for (Xe.iushrn(yt); yt-- > 0; )
            ot.isOdd() && ot.iadd(mt), ot.iushrn(1);
        for (var Ge = 0, ct = 1; !(rt.words[0] & ct) && Ge < 26; ++Ge, ct <<= 1)
          ;
        if (Ge > 0)
          for (rt.iushrn(Ge); Ge-- > 0; )
            ft.isOdd() && ft.iadd(mt), ft.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(ft)) : (rt.isub(Xe), ft.isub(ot));
      }
      var Mt;
      return Xe.cmpn(1) === 0 ? Mt = ot : Mt = ft, Mt.cmpn(0) < 0 && Mt.iadd(We), Mt;
    }, Ve.prototype.gcd = function(We) {
      if (this.isZero())
        return We.abs();
      if (We.isZero())
        return this.abs();
      var Xe = this.clone(), rt = We.clone();
      Xe.negative = 0, rt.negative = 0;
      for (var ot = 0; Xe.isEven() && rt.isEven(); ot++)
        Xe.iushrn(1), rt.iushrn(1);
      do {
        for (; Xe.isEven(); )
          Xe.iushrn(1);
        for (; rt.isEven(); )
          rt.iushrn(1);
        var ft = Xe.cmp(rt);
        if (ft < 0) {
          var mt = Xe;
          Xe = rt, rt = mt;
        } else if (ft === 0 || rt.cmpn(1) === 0)
          break;
        Xe.isub(rt);
      } while (!0);
      return rt.iushln(ot);
    }, Ve.prototype.invm = function(We) {
      return this.egcd(We).a.umod(We);
    }, Ve.prototype.isEven = function() {
      return ((this || _global$5$1).words[0] & 1) === 0;
    }, Ve.prototype.isOdd = function() {
      return ((this || _global$5$1).words[0] & 1) === 1;
    }, Ve.prototype.andln = function(We) {
      return (this || _global$5$1).words[0] & We;
    }, Ve.prototype.bincn = function(We) {
      Fe(typeof We == "number");
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$5$1).length <= rt)
        return this._expand(rt + 1), (this || _global$5$1).words[rt] |= ot, this || _global$5$1;
      for (var ft = ot, mt = rt; ft !== 0 && mt < (this || _global$5$1).length; mt++) {
        var yt = (this || _global$5$1).words[mt] | 0;
        yt += ft, ft = yt >>> 26, yt &= 67108863, (this || _global$5$1).words[mt] = yt;
      }
      return ft !== 0 && ((this || _global$5$1).words[mt] = ft, (this || _global$5$1).length++), this || _global$5$1;
    }, Ve.prototype.isZero = function() {
      return (this || _global$5$1).length === 1 && (this || _global$5$1).words[0] === 0;
    }, Ve.prototype.cmpn = function(We) {
      var Xe = We < 0;
      if ((this || _global$5$1).negative !== 0 && !Xe)
        return -1;
      if ((this || _global$5$1).negative === 0 && Xe)
        return 1;
      this.strip();
      var rt;
      if ((this || _global$5$1).length > 1)
        rt = 1;
      else {
        Xe && (We = -We), Fe(We <= 67108863, "Number is too big");
        var ot = (this || _global$5$1).words[0] | 0;
        rt = ot === We ? 0 : ot < We ? -1 : 1;
      }
      return (this || _global$5$1).negative !== 0 ? -rt | 0 : rt;
    }, Ve.prototype.cmp = function(We) {
      if ((this || _global$5$1).negative !== 0 && We.negative === 0)
        return -1;
      if ((this || _global$5$1).negative === 0 && We.negative !== 0)
        return 1;
      var Xe = this.ucmp(We);
      return (this || _global$5$1).negative !== 0 ? -Xe | 0 : Xe;
    }, Ve.prototype.ucmp = function(We) {
      if ((this || _global$5$1).length > We.length)
        return 1;
      if ((this || _global$5$1).length < We.length)
        return -1;
      for (var Xe = 0, rt = (this || _global$5$1).length - 1; rt >= 0; rt--) {
        var ot = (this || _global$5$1).words[rt] | 0, ft = We.words[rt] | 0;
        if (ot !== ft) {
          ot < ft ? Xe = -1 : ot > ft && (Xe = 1);
          break;
        }
      }
      return Xe;
    }, Ve.prototype.gtn = function(We) {
      return this.cmpn(We) === 1;
    }, Ve.prototype.gt = function(We) {
      return this.cmp(We) === 1;
    }, Ve.prototype.gten = function(We) {
      return this.cmpn(We) >= 0;
    }, Ve.prototype.gte = function(We) {
      return this.cmp(We) >= 0;
    }, Ve.prototype.ltn = function(We) {
      return this.cmpn(We) === -1;
    }, Ve.prototype.lt = function(We) {
      return this.cmp(We) === -1;
    }, Ve.prototype.lten = function(We) {
      return this.cmpn(We) <= 0;
    }, Ve.prototype.lte = function(We) {
      return this.cmp(We) <= 0;
    }, Ve.prototype.eqn = function(We) {
      return this.cmpn(We) === 0;
    }, Ve.prototype.eq = function(We) {
      return this.cmp(We) === 0;
    }, Ve.red = function(We) {
      return new Ot(We);
    }, Ve.prototype.toRed = function(We) {
      return Fe(!(this || _global$5$1).red, "Already a number in reduction context"), Fe((this || _global$5$1).negative === 0, "red works only with positives"), We.convertTo(this || _global$5$1)._forceRed(We);
    }, Ve.prototype.fromRed = function() {
      return Fe((this || _global$5$1).red, "fromRed works only with numbers in reduction context"), (this || _global$5$1).red.convertFrom(this || _global$5$1);
    }, Ve.prototype._forceRed = function(We) {
      return (this || _global$5$1).red = We, this || _global$5$1;
    }, Ve.prototype.forceRed = function(We) {
      return Fe(!(this || _global$5$1).red, "Already a number in reduction context"), this._forceRed(We);
    }, Ve.prototype.redAdd = function(We) {
      return Fe((this || _global$5$1).red, "redAdd works only with red numbers"), (this || _global$5$1).red.add(this || _global$5$1, We);
    }, Ve.prototype.redIAdd = function(We) {
      return Fe((this || _global$5$1).red, "redIAdd works only with red numbers"), (this || _global$5$1).red.iadd(this || _global$5$1, We);
    }, Ve.prototype.redSub = function(We) {
      return Fe((this || _global$5$1).red, "redSub works only with red numbers"), (this || _global$5$1).red.sub(this || _global$5$1, We);
    }, Ve.prototype.redISub = function(We) {
      return Fe((this || _global$5$1).red, "redISub works only with red numbers"), (this || _global$5$1).red.isub(this || _global$5$1, We);
    }, Ve.prototype.redShl = function(We) {
      return Fe((this || _global$5$1).red, "redShl works only with red numbers"), (this || _global$5$1).red.shl(this || _global$5$1, We);
    }, Ve.prototype.redMul = function(We) {
      return Fe((this || _global$5$1).red, "redMul works only with red numbers"), (this || _global$5$1).red._verify2(this || _global$5$1, We), (this || _global$5$1).red.mul(this || _global$5$1, We);
    }, Ve.prototype.redIMul = function(We) {
      return Fe((this || _global$5$1).red, "redMul works only with red numbers"), (this || _global$5$1).red._verify2(this || _global$5$1, We), (this || _global$5$1).red.imul(this || _global$5$1, We);
    }, Ve.prototype.redSqr = function() {
      return Fe((this || _global$5$1).red, "redSqr works only with red numbers"), (this || _global$5$1).red._verify1(this || _global$5$1), (this || _global$5$1).red.sqr(this || _global$5$1);
    }, Ve.prototype.redISqr = function() {
      return Fe((this || _global$5$1).red, "redISqr works only with red numbers"), (this || _global$5$1).red._verify1(this || _global$5$1), (this || _global$5$1).red.isqr(this || _global$5$1);
    }, Ve.prototype.redSqrt = function() {
      return Fe((this || _global$5$1).red, "redSqrt works only with red numbers"), (this || _global$5$1).red._verify1(this || _global$5$1), (this || _global$5$1).red.sqrt(this || _global$5$1);
    }, Ve.prototype.redInvm = function() {
      return Fe((this || _global$5$1).red, "redInvm works only with red numbers"), (this || _global$5$1).red._verify1(this || _global$5$1), (this || _global$5$1).red.invm(this || _global$5$1);
    }, Ve.prototype.redNeg = function() {
      return Fe((this || _global$5$1).red, "redNeg works only with red numbers"), (this || _global$5$1).red._verify1(this || _global$5$1), (this || _global$5$1).red.neg(this || _global$5$1);
    }, Ve.prototype.redPow = function(We) {
      return Fe((this || _global$5$1).red && !We.red, "redPow(normalNum)"), (this || _global$5$1).red._verify1(this || _global$5$1), (this || _global$5$1).red.pow(this || _global$5$1, We);
    };
    var Rt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ct(gt, We) {
      (this || _global$5$1).name = gt, (this || _global$5$1).p = new Ve(We, 16), (this || _global$5$1).n = (this || _global$5$1).p.bitLength(), (this || _global$5$1).k = new Ve(1).iushln((this || _global$5$1).n).isub((this || _global$5$1).p), (this || _global$5$1).tmp = this._tmp();
    }
    Ct.prototype._tmp = function() {
      var We = new Ve(null);
      return We.words = new Array(Math.ceil((this || _global$5$1).n / 13)), We;
    }, Ct.prototype.ireduce = function(We) {
      var Xe = We, rt;
      do
        this.split(Xe, (this || _global$5$1).tmp), Xe = this.imulK(Xe), Xe = Xe.iadd((this || _global$5$1).tmp), rt = Xe.bitLength();
      while (rt > (this || _global$5$1).n);
      var ot = rt < (this || _global$5$1).n ? -1 : Xe.ucmp((this || _global$5$1).p);
      return ot === 0 ? (Xe.words[0] = 0, Xe.length = 1) : ot > 0 ? Xe.isub((this || _global$5$1).p) : Xe.strip !== void 0 ? Xe.strip() : Xe._strip(), Xe;
    }, Ct.prototype.split = function(We, Xe) {
      We.iushrn((this || _global$5$1).n, 0, Xe);
    }, Ct.prototype.imulK = function(We) {
      return We.imul((this || _global$5$1).k);
    };
    function Zt() {
      Ct.call(this || _global$5$1, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    Ke(Zt, Ct), Zt.prototype.split = function(We, Xe) {
      for (var rt = 4194303, ot = Math.min(We.length, 9), ft = 0; ft < ot; ft++)
        Xe.words[ft] = We.words[ft];
      if (Xe.length = ot, We.length <= 9) {
        We.words[0] = 0, We.length = 1;
        return;
      }
      var mt = We.words[9];
      for (Xe.words[Xe.length++] = mt & rt, ft = 10; ft < We.length; ft++) {
        var yt = We.words[ft] | 0;
        We.words[ft - 10] = (yt & rt) << 4 | mt >>> 22, mt = yt;
      }
      mt >>>= 22, We.words[ft - 10] = mt, mt === 0 && We.length > 10 ? We.length -= 10 : We.length -= 9;
    }, Zt.prototype.imulK = function(We) {
      We.words[We.length] = 0, We.words[We.length + 1] = 0, We.length += 2;
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = We.words[rt] | 0;
        Xe += ot * 977, We.words[rt] = Xe & 67108863, Xe = ot * 64 + (Xe / 67108864 | 0);
      }
      return We.words[We.length - 1] === 0 && (We.length--, We.words[We.length - 1] === 0 && We.length--), We;
    };
    function Lt() {
      Ct.call(this || _global$5$1, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    Ke(Lt, Ct);
    function Ut() {
      Ct.call(this || _global$5$1, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    Ke(Ut, Ct);
    function Pt() {
      Ct.call(this || _global$5$1, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    Ke(Pt, Ct), Pt.prototype.imulK = function(We) {
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = (We.words[rt] | 0) * 19 + Xe, ft = ot & 67108863;
        ot >>>= 26, We.words[rt] = ft, Xe = ot;
      }
      return Xe !== 0 && (We.words[We.length++] = Xe), We;
    }, Ve._prime = function(We) {
      if (Rt[We])
        return Rt[We];
      var Xe;
      if (We === "k256")
        Xe = new Zt();
      else if (We === "p224")
        Xe = new Lt();
      else if (We === "p192")
        Xe = new Ut();
      else if (We === "p25519")
        Xe = new Pt();
      else
        throw new Error("Unknown prime " + We);
      return Rt[We] = Xe, Xe;
    };
    function Ot(gt) {
      if (typeof gt == "string") {
        var We = Ve._prime(gt);
        (this || _global$5$1).m = We.p, (this || _global$5$1).prime = We;
      } else
        Fe(gt.gtn(1), "modulus must be greater than 1"), (this || _global$5$1).m = gt, (this || _global$5$1).prime = null;
    }
    Ot.prototype._verify1 = function(We) {
      Fe(We.negative === 0, "red works only with positives"), Fe(We.red, "red works only with red numbers");
    }, Ot.prototype._verify2 = function(We, Xe) {
      Fe((We.negative | Xe.negative) === 0, "red works only with positives"), Fe(We.red && We.red === Xe.red, "red works only with red numbers");
    }, Ot.prototype.imod = function(We) {
      return (this || _global$5$1).prime ? (this || _global$5$1).prime.ireduce(We)._forceRed(this || _global$5$1) : We.umod((this || _global$5$1).m)._forceRed(this || _global$5$1);
    }, Ot.prototype.neg = function(We) {
      return We.isZero() ? We.clone() : (this || _global$5$1).m.sub(We)._forceRed(this || _global$5$1);
    }, Ot.prototype.add = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.add(Xe);
      return rt.cmp((this || _global$5$1).m) >= 0 && rt.isub((this || _global$5$1).m), rt._forceRed(this || _global$5$1);
    }, Ot.prototype.iadd = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.iadd(Xe);
      return rt.cmp((this || _global$5$1).m) >= 0 && rt.isub((this || _global$5$1).m), rt;
    }, Ot.prototype.sub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.sub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$5$1).m), rt._forceRed(this || _global$5$1);
    }, Ot.prototype.isub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.isub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$5$1).m), rt;
    }, Ot.prototype.shl = function(We, Xe) {
      return this._verify1(We), this.imod(We.ushln(Xe));
    }, Ot.prototype.imul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.imul(Xe));
    }, Ot.prototype.mul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.mul(Xe));
    }, Ot.prototype.isqr = function(We) {
      return this.imul(We, We.clone());
    }, Ot.prototype.sqr = function(We) {
      return this.mul(We, We);
    }, Ot.prototype.sqrt = function(We) {
      if (We.isZero())
        return We.clone();
      var Xe = (this || _global$5$1).m.andln(3);
      if (Fe(Xe % 2 === 1), Xe === 3) {
        var rt = (this || _global$5$1).m.add(new Ve(1)).iushrn(2);
        return this.pow(We, rt);
      }
      for (var ot = (this || _global$5$1).m.subn(1), ft = 0; !ot.isZero() && ot.andln(1) === 0; )
        ft++, ot.iushrn(1);
      Fe(!ot.isZero());
      var mt = new Ve(1).toRed(this || _global$5$1), yt = mt.redNeg(), pt = (this || _global$5$1).m.subn(1).iushrn(1), Ge = (this || _global$5$1).m.bitLength();
      for (Ge = new Ve(2 * Ge * Ge).toRed(this || _global$5$1); this.pow(Ge, pt).cmp(yt) !== 0; )
        Ge.redIAdd(yt);
      for (var ct = this.pow(Ge, ot), Mt = this.pow(We, ot.addn(1).iushrn(1)), St = this.pow(We, ot), At = ft; St.cmp(mt) !== 0; ) {
        for (var Nt = St, qt = 0; Nt.cmp(mt) !== 0; qt++)
          Nt = Nt.redSqr();
        Fe(qt < At);
        var Qt = this.pow(ct, new Ve(1).iushln(At - qt - 1));
        Mt = Mt.redMul(Qt), ct = Qt.redSqr(), St = St.redMul(ct), At = qt;
      }
      return Mt;
    }, Ot.prototype.invm = function(We) {
      var Xe = We._invmp((this || _global$5$1).m);
      return Xe.negative !== 0 ? (Xe.negative = 0, this.imod(Xe).redNeg()) : this.imod(Xe);
    }, Ot.prototype.pow = function(We, Xe) {
      if (Xe.isZero())
        return new Ve(1).toRed(this || _global$5$1);
      if (Xe.cmpn(1) === 0)
        return We.clone();
      var rt = 4, ot = new Array(1 << rt);
      ot[0] = new Ve(1).toRed(this || _global$5$1), ot[1] = We;
      for (var ft = 2; ft < ot.length; ft++)
        ot[ft] = this.mul(ot[ft - 1], We);
      var mt = ot[0], yt = 0, pt = 0, Ge = Xe.bitLength() % 26;
      for (Ge === 0 && (Ge = 26), ft = Xe.length - 1; ft >= 0; ft--) {
        for (var ct = Xe.words[ft], Mt = Ge - 1; Mt >= 0; Mt--) {
          var St = ct >> Mt & 1;
          if (mt !== ot[0] && (mt = this.sqr(mt)), St === 0 && yt === 0) {
            pt = 0;
            continue;
          }
          yt <<= 1, yt |= St, pt++, !(pt !== rt && (ft !== 0 || Mt !== 0)) && (mt = this.mul(mt, ot[yt]), pt = 0, yt = 0);
        }
        Ge = 26;
      }
      return mt;
    }, Ot.prototype.convertTo = function(We) {
      var Xe = We.umod((this || _global$5$1).m);
      return Xe === We ? Xe.clone() : Xe;
    }, Ot.prototype.convertFrom = function(We) {
      var Xe = We.clone();
      return Xe.red = null, Xe;
    }, Ve.mont = function(We) {
      return new Ft(We);
    };
    function Ft(gt) {
      Ot.call(this || _global$5$1, gt), (this || _global$5$1).shift = (this || _global$5$1).m.bitLength(), (this || _global$5$1).shift % 26 !== 0 && ((this || _global$5$1).shift += 26 - (this || _global$5$1).shift % 26), (this || _global$5$1).r = new Ve(1).iushln((this || _global$5$1).shift), (this || _global$5$1).r2 = this.imod((this || _global$5$1).r.sqr()), (this || _global$5$1).rinv = (this || _global$5$1).r._invmp((this || _global$5$1).m), (this || _global$5$1).minv = (this || _global$5$1).rinv.mul((this || _global$5$1).r).isubn(1).div((this || _global$5$1).m), (this || _global$5$1).minv = (this || _global$5$1).minv.umod((this || _global$5$1).r), (this || _global$5$1).minv = (this || _global$5$1).r.sub((this || _global$5$1).minv);
    }
    Ke(Ft, Ot), Ft.prototype.convertTo = function(We) {
      return this.imod(We.ushln((this || _global$5$1).shift));
    }, Ft.prototype.convertFrom = function(We) {
      var Xe = this.imod(We.mul((this || _global$5$1).rinv));
      return Xe.red = null, Xe;
    }, Ft.prototype.imul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return We.words[0] = 0, We.length = 1, We;
      var rt = We.imul(Xe), ot = rt.maskn((this || _global$5$1).shift).mul((this || _global$5$1).minv).imaskn((this || _global$5$1).shift).mul((this || _global$5$1).m), ft = rt.isub(ot).iushrn((this || _global$5$1).shift), mt = ft;
      return ft.cmp((this || _global$5$1).m) >= 0 ? mt = ft.isub((this || _global$5$1).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$5$1).m)), mt._forceRed(this || _global$5$1);
    }, Ft.prototype.mul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return new Ve(0)._forceRed(this || _global$5$1);
      var rt = We.mul(Xe), ot = rt.maskn((this || _global$5$1).shift).mul((this || _global$5$1).minv).imaskn((this || _global$5$1).shift).mul((this || _global$5$1).m), ft = rt.isub(ot).iushrn((this || _global$5$1).shift), mt = ft;
      return ft.cmp((this || _global$5$1).m) >= 0 ? mt = ft.isub((this || _global$5$1).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$5$1).m)), mt._forceRed(this || _global$5$1);
    }, Ft.prototype.invm = function(We) {
      var Xe = this.imod(We._invmp((this || _global$5$1).m).mul((this || _global$5$1).r2));
      return Xe._forceRed(this || _global$5$1);
    };
  }(module$2$1, exports$x$1)), module$2$1.exports;
}
var exports$w$1 = {}, _dewExec$w$1 = !1;
function dew$w$1() {
  if (_dewExec$w$1)
    return exports$w$1;
  _dewExec$w$1 = !0;
  var $e = T, Ze = e$1$1$1, Fe = Ze.Buffer, Ke = {}, Ve;
  for (Ve in Ze)
    Ze.hasOwnProperty(Ve) && (Ve === "SlowBuffer" || Ve === "Buffer" || (Ke[Ve] = Ze[Ve]));
  var Je = Ke.Buffer = {};
  for (Ve in Fe)
    Fe.hasOwnProperty(Ve) && (Ve === "allocUnsafe" || Ve === "allocUnsafeSlow" || (Je[Ve] = Fe[Ve]));
  if (Ke.Buffer.prototype = Fe.prototype, (!Je.from || Je.from === Uint8Array.from) && (Je.from = function(Qe, at, ut) {
    if (typeof Qe == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof Qe);
    if (Qe && typeof Qe.length > "u")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Qe);
    return Fe(Qe, at, ut);
  }), Je.alloc || (Je.alloc = function(Qe, at, ut) {
    if (typeof Qe != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof Qe);
    if (Qe < 0 || Qe >= 2 * (1 << 30))
      throw new RangeError('The value "' + Qe + '" is invalid for option "size"');
    var lt = Fe(Qe);
    return !at || at.length === 0 ? lt.fill(0) : typeof ut == "string" ? lt.fill(at, ut) : lt.fill(at), lt;
  }), !Ke.kStringMaxLength)
    try {
      Ke.kStringMaxLength = $e.binding("buffer").kStringMaxLength;
    } catch {
    }
  return Ke.constants || (Ke.constants = {
    MAX_LENGTH: Ke.kMaxLength
  }, Ke.kStringMaxLength && (Ke.constants.MAX_STRING_LENGTH = Ke.kStringMaxLength)), exports$w$1 = Ke, exports$w$1;
}
var exports$v$1 = {}, _dewExec$v$1 = !1;
function dew$v$1() {
  if (_dewExec$v$1)
    return exports$v$1;
  _dewExec$v$1 = !0;
  const $e = dew$f$2();
  function Ze(Ke) {
    this._reporterState = {
      obj: null,
      path: [],
      options: Ke || {},
      errors: []
    };
  }
  exports$v$1.Reporter = Ze, Ze.prototype.isError = function(Ve) {
    return Ve instanceof Fe;
  }, Ze.prototype.save = function() {
    const Ve = this._reporterState;
    return {
      obj: Ve.obj,
      pathLen: Ve.path.length
    };
  }, Ze.prototype.restore = function(Ve) {
    const Je = this._reporterState;
    Je.obj = Ve.obj, Je.path = Je.path.slice(0, Ve.pathLen);
  }, Ze.prototype.enterKey = function(Ve) {
    return this._reporterState.path.push(Ve);
  }, Ze.prototype.exitKey = function(Ve) {
    const Je = this._reporterState;
    Je.path = Je.path.slice(0, Ve - 1);
  }, Ze.prototype.leaveKey = function(Ve, Je, Qe) {
    const at = this._reporterState;
    this.exitKey(Ve), at.obj !== null && (at.obj[Je] = Qe);
  }, Ze.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, Ze.prototype.enterObject = function() {
    const Ve = this._reporterState, Je = Ve.obj;
    return Ve.obj = {}, Je;
  }, Ze.prototype.leaveObject = function(Ve) {
    const Je = this._reporterState, Qe = Je.obj;
    return Je.obj = Ve, Qe;
  }, Ze.prototype.error = function(Ve) {
    let Je;
    const Qe = this._reporterState, at = Ve instanceof Fe;
    if (at ? Je = Ve : Je = new Fe(Qe.path.map(function(ut) {
      return "[" + JSON.stringify(ut) + "]";
    }).join(""), Ve.message || Ve, Ve.stack), !Qe.options.partial)
      throw Je;
    return at || Qe.errors.push(Je), Je;
  }, Ze.prototype.wrapResult = function(Ve) {
    const Je = this._reporterState;
    return Je.options.partial ? {
      result: this.isError(Ve) ? null : Ve,
      errors: Je.errors
    } : Ve;
  };
  function Fe(Ke, Ve) {
    this.path = Ke, this.rethrow(Ve);
  }
  return $e(Fe, Error), Fe.prototype.rethrow = function(Ve) {
    if (this.message = Ve + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, Fe), !this.stack)
      try {
        throw new Error(this.message);
      } catch (Je) {
        this.stack = Je.stack;
      }
    return this;
  }, exports$v$1;
}
var exports$u$1 = {}, _dewExec$u$1 = !1;
function dew$u$1() {
  if (_dewExec$u$1)
    return exports$u$1;
  _dewExec$u$1 = !0;
  const $e = dew$f$2(), Ze = dew$v$1().Reporter, Fe = dew$w$1().Buffer;
  function Ke(Je, Qe) {
    if (Ze.call(this, Qe), !Fe.isBuffer(Je)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = Je, this.offset = 0, this.length = Je.length;
  }
  $e(Ke, Ze), exports$u$1.DecoderBuffer = Ke, Ke.isDecoderBuffer = function(Qe) {
    return Qe instanceof Ke ? !0 : typeof Qe == "object" && Fe.isBuffer(Qe.base) && Qe.constructor.name === "DecoderBuffer" && typeof Qe.offset == "number" && typeof Qe.length == "number" && typeof Qe.save == "function" && typeof Qe.restore == "function" && typeof Qe.isEmpty == "function" && typeof Qe.readUInt8 == "function" && typeof Qe.skip == "function" && typeof Qe.raw == "function";
  }, Ke.prototype.save = function() {
    return {
      offset: this.offset,
      reporter: Ze.prototype.save.call(this)
    };
  }, Ke.prototype.restore = function(Qe) {
    const at = new Ke(this.base);
    return at.offset = Qe.offset, at.length = this.offset, this.offset = Qe.offset, Ze.prototype.restore.call(this, Qe.reporter), at;
  }, Ke.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, Ke.prototype.readUInt8 = function(Qe) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(Qe || "DecoderBuffer overrun");
  }, Ke.prototype.skip = function(Qe, at) {
    if (!(this.offset + Qe <= this.length))
      return this.error(at || "DecoderBuffer overrun");
    const ut = new Ke(this.base);
    return ut._reporterState = this._reporterState, ut.offset = this.offset, ut.length = this.offset + Qe, this.offset += Qe, ut;
  }, Ke.prototype.raw = function(Qe) {
    return this.base.slice(Qe ? Qe.offset : this.offset, this.length);
  };
  function Ve(Je, Qe) {
    if (Array.isArray(Je))
      this.length = 0, this.value = Je.map(function(at) {
        return Ve.isEncoderBuffer(at) || (at = new Ve(at, Qe)), this.length += at.length, at;
      }, this);
    else if (typeof Je == "number") {
      if (!(0 <= Je && Je <= 255))
        return Qe.error("non-byte EncoderBuffer value");
      this.value = Je, this.length = 1;
    } else if (typeof Je == "string")
      this.value = Je, this.length = Fe.byteLength(Je);
    else if (Fe.isBuffer(Je))
      this.value = Je, this.length = Je.length;
    else
      return Qe.error("Unsupported type: " + typeof Je);
  }
  return exports$u$1.EncoderBuffer = Ve, Ve.isEncoderBuffer = function(Qe) {
    return Qe instanceof Ve ? !0 : typeof Qe == "object" && Qe.constructor.name === "EncoderBuffer" && typeof Qe.length == "number" && typeof Qe.join == "function";
  }, Ve.prototype.join = function(Qe, at) {
    return Qe || (Qe = Fe.alloc(this.length)), at || (at = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(ut) {
      ut.join(Qe, at), at += ut.length;
    }) : (typeof this.value == "number" ? Qe[at] = this.value : typeof this.value == "string" ? Qe.write(this.value, at) : Fe.isBuffer(this.value) && this.value.copy(Qe, at), at += this.length)), Qe;
  }, exports$u$1;
}
var exports$t$1 = {}, _dewExec$t$1 = !1;
function dew$t$1() {
  if (_dewExec$t$1)
    return exports$t$1;
  _dewExec$t$1 = !0;
  const $e = dew$v$1().Reporter, Ze = dew$u$1().EncoderBuffer, Fe = dew$u$1().DecoderBuffer, Ke = dew$1t(), Ve = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], Je = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(Ve), Qe = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
  function at(lt, dt, bt) {
    const $t = {};
    this._baseState = $t, $t.name = bt, $t.enc = lt, $t.parent = dt || null, $t.children = null, $t.tag = null, $t.args = null, $t.reverseArgs = null, $t.choice = null, $t.optional = !1, $t.any = !1, $t.obj = !1, $t.use = null, $t.useDecoder = null, $t.key = null, $t.default = null, $t.explicit = null, $t.implicit = null, $t.contains = null, $t.parent || ($t.children = [], this._wrap());
  }
  exports$t$1 = at;
  const ut = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
  return at.prototype.clone = function() {
    const dt = this._baseState, bt = {};
    ut.forEach(function(vt) {
      bt[vt] = dt[vt];
    });
    const $t = new this.constructor(bt.parent);
    return $t._baseState = bt, $t;
  }, at.prototype._wrap = function() {
    const dt = this._baseState;
    Je.forEach(function(bt) {
      this[bt] = function() {
        const vt = new this.constructor(this);
        return dt.children.push(vt), vt[bt].apply(vt, arguments);
      };
    }, this);
  }, at.prototype._init = function(dt) {
    const bt = this._baseState;
    Ke(bt.parent === null), dt.call(this), bt.children = bt.children.filter(function($t) {
      return $t._baseState.parent === this;
    }, this), Ke.equal(bt.children.length, 1, "Root node can have only one child");
  }, at.prototype._useArgs = function(dt) {
    const bt = this._baseState, $t = dt.filter(function(vt) {
      return vt instanceof this.constructor;
    }, this);
    dt = dt.filter(function(vt) {
      return !(vt instanceof this.constructor);
    }, this), $t.length !== 0 && (Ke(bt.children === null), bt.children = $t, $t.forEach(function(vt) {
      vt._baseState.parent = this;
    }, this)), dt.length !== 0 && (Ke(bt.args === null), bt.args = dt, bt.reverseArgs = dt.map(function(vt) {
      if (typeof vt != "object" || vt.constructor !== Object)
        return vt;
      const wt = {};
      return Object.keys(vt).forEach(function(xt) {
        xt == (xt | 0) && (xt |= 0);
        const Et = vt[xt];
        wt[Et] = xt;
      }), wt;
    }));
  }, Qe.forEach(function(lt) {
    at.prototype[lt] = function() {
      const bt = this._baseState;
      throw new Error(lt + " not implemented for encoding: " + bt.enc);
    };
  }), Ve.forEach(function(lt) {
    at.prototype[lt] = function() {
      const bt = this._baseState, $t = Array.prototype.slice.call(arguments);
      return Ke(bt.tag === null), bt.tag = lt, this._useArgs($t), this;
    };
  }), at.prototype.use = function(dt) {
    Ke(dt);
    const bt = this._baseState;
    return Ke(bt.use === null), bt.use = dt, this;
  }, at.prototype.optional = function() {
    const dt = this._baseState;
    return dt.optional = !0, this;
  }, at.prototype.def = function(dt) {
    const bt = this._baseState;
    return Ke(bt.default === null), bt.default = dt, bt.optional = !0, this;
  }, at.prototype.explicit = function(dt) {
    const bt = this._baseState;
    return Ke(bt.explicit === null && bt.implicit === null), bt.explicit = dt, this;
  }, at.prototype.implicit = function(dt) {
    const bt = this._baseState;
    return Ke(bt.explicit === null && bt.implicit === null), bt.implicit = dt, this;
  }, at.prototype.obj = function() {
    const dt = this._baseState, bt = Array.prototype.slice.call(arguments);
    return dt.obj = !0, bt.length !== 0 && this._useArgs(bt), this;
  }, at.prototype.key = function(dt) {
    const bt = this._baseState;
    return Ke(bt.key === null), bt.key = dt, this;
  }, at.prototype.any = function() {
    const dt = this._baseState;
    return dt.any = !0, this;
  }, at.prototype.choice = function(dt) {
    const bt = this._baseState;
    return Ke(bt.choice === null), bt.choice = dt, this._useArgs(Object.keys(dt).map(function($t) {
      return dt[$t];
    })), this;
  }, at.prototype.contains = function(dt) {
    const bt = this._baseState;
    return Ke(bt.use === null), bt.contains = dt, this;
  }, at.prototype._decode = function(dt, bt) {
    const $t = this._baseState;
    if ($t.parent === null)
      return dt.wrapResult($t.children[0]._decode(dt, bt));
    let vt = $t.default, wt = !0, xt = null;
    if ($t.key !== null && (xt = dt.enterKey($t.key)), $t.optional) {
      let Tt = null;
      if ($t.explicit !== null ? Tt = $t.explicit : $t.implicit !== null ? Tt = $t.implicit : $t.tag !== null && (Tt = $t.tag), Tt === null && !$t.any) {
        const Rt = dt.save();
        try {
          $t.choice === null ? this._decodeGeneric($t.tag, dt, bt) : this._decodeChoice(dt, bt), wt = !0;
        } catch {
          wt = !1;
        }
        dt.restore(Rt);
      } else if (wt = this._peekTag(dt, Tt, $t.any), dt.isError(wt))
        return wt;
    }
    let Et;
    if ($t.obj && wt && (Et = dt.enterObject()), wt) {
      if ($t.explicit !== null) {
        const Rt = this._decodeTag(dt, $t.explicit);
        if (dt.isError(Rt))
          return Rt;
        dt = Rt;
      }
      const Tt = dt.offset;
      if ($t.use === null && $t.choice === null) {
        let Rt;
        $t.any && (Rt = dt.save());
        const Ct = this._decodeTag(dt, $t.implicit !== null ? $t.implicit : $t.tag, $t.any);
        if (dt.isError(Ct))
          return Ct;
        $t.any ? vt = dt.raw(Rt) : dt = Ct;
      }
      if (bt && bt.track && $t.tag !== null && bt.track(dt.path(), Tt, dt.length, "tagged"), bt && bt.track && $t.tag !== null && bt.track(dt.path(), dt.offset, dt.length, "content"), $t.any || ($t.choice === null ? vt = this._decodeGeneric($t.tag, dt, bt) : vt = this._decodeChoice(dt, bt)), dt.isError(vt))
        return vt;
      if (!$t.any && $t.choice === null && $t.children !== null && $t.children.forEach(function(Ct) {
        Ct._decode(dt, bt);
      }), $t.contains && ($t.tag === "octstr" || $t.tag === "bitstr")) {
        const Rt = new Fe(vt);
        vt = this._getUse($t.contains, dt._reporterState.obj)._decode(Rt, bt);
      }
    }
    return $t.obj && wt && (vt = dt.leaveObject(Et)), $t.key !== null && (vt !== null || wt === !0) ? dt.leaveKey(xt, $t.key, vt) : xt !== null && dt.exitKey(xt), vt;
  }, at.prototype._decodeGeneric = function(dt, bt, $t) {
    const vt = this._baseState;
    return dt === "seq" || dt === "set" ? null : dt === "seqof" || dt === "setof" ? this._decodeList(bt, dt, vt.args[0], $t) : /str$/.test(dt) ? this._decodeStr(bt, dt, $t) : dt === "objid" && vt.args ? this._decodeObjid(bt, vt.args[0], vt.args[1], $t) : dt === "objid" ? this._decodeObjid(bt, null, null, $t) : dt === "gentime" || dt === "utctime" ? this._decodeTime(bt, dt, $t) : dt === "null_" ? this._decodeNull(bt, $t) : dt === "bool" ? this._decodeBool(bt, $t) : dt === "objDesc" ? this._decodeStr(bt, dt, $t) : dt === "int" || dt === "enum" ? this._decodeInt(bt, vt.args && vt.args[0], $t) : vt.use !== null ? this._getUse(vt.use, bt._reporterState.obj)._decode(bt, $t) : bt.error("unknown tag: " + dt);
  }, at.prototype._getUse = function(dt, bt) {
    const $t = this._baseState;
    return $t.useDecoder = this._use(dt, bt), Ke($t.useDecoder._baseState.parent === null), $t.useDecoder = $t.useDecoder._baseState.children[0], $t.implicit !== $t.useDecoder._baseState.implicit && ($t.useDecoder = $t.useDecoder.clone(), $t.useDecoder._baseState.implicit = $t.implicit), $t.useDecoder;
  }, at.prototype._decodeChoice = function(dt, bt) {
    const $t = this._baseState;
    let vt = null, wt = !1;
    return Object.keys($t.choice).some(function(xt) {
      const Et = dt.save(), Tt = $t.choice[xt];
      try {
        const Rt = Tt._decode(dt, bt);
        if (dt.isError(Rt))
          return !1;
        vt = {
          type: xt,
          value: Rt
        }, wt = !0;
      } catch {
        return dt.restore(Et), !1;
      }
      return !0;
    }, this), wt ? vt : dt.error("Choice not matched");
  }, at.prototype._createEncoderBuffer = function(dt) {
    return new Ze(dt, this.reporter);
  }, at.prototype._encode = function(dt, bt, $t) {
    const vt = this._baseState;
    if (vt.default !== null && vt.default === dt)
      return;
    const wt = this._encodeValue(dt, bt, $t);
    if (wt !== void 0 && !this._skipDefault(wt, bt, $t))
      return wt;
  }, at.prototype._encodeValue = function(dt, bt, $t) {
    const vt = this._baseState;
    if (vt.parent === null)
      return vt.children[0]._encode(dt, bt || new $e());
    let wt = null;
    if (this.reporter = bt, vt.optional && dt === void 0)
      if (vt.default !== null)
        dt = vt.default;
      else
        return;
    let xt = null, Et = !1;
    if (vt.any)
      wt = this._createEncoderBuffer(dt);
    else if (vt.choice)
      wt = this._encodeChoice(dt, bt);
    else if (vt.contains)
      xt = this._getUse(vt.contains, $t)._encode(dt, bt), Et = !0;
    else if (vt.children)
      xt = vt.children.map(function(Tt) {
        if (Tt._baseState.tag === "null_")
          return Tt._encode(null, bt, dt);
        if (Tt._baseState.key === null)
          return bt.error("Child should have a key");
        const Rt = bt.enterKey(Tt._baseState.key);
        if (typeof dt != "object")
          return bt.error("Child expected, but input is not object");
        const Ct = Tt._encode(dt[Tt._baseState.key], bt, dt);
        return bt.leaveKey(Rt), Ct;
      }, this).filter(function(Tt) {
        return Tt;
      }), xt = this._createEncoderBuffer(xt);
    else if (vt.tag === "seqof" || vt.tag === "setof") {
      if (!(vt.args && vt.args.length === 1))
        return bt.error("Too many args for : " + vt.tag);
      if (!Array.isArray(dt))
        return bt.error("seqof/setof, but data is not Array");
      const Tt = this.clone();
      Tt._baseState.implicit = null, xt = this._createEncoderBuffer(dt.map(function(Rt) {
        const Ct = this._baseState;
        return this._getUse(Ct.args[0], dt)._encode(Rt, bt);
      }, Tt));
    } else
      vt.use !== null ? wt = this._getUse(vt.use, $t)._encode(dt, bt) : (xt = this._encodePrimitive(vt.tag, dt), Et = !0);
    if (!vt.any && vt.choice === null) {
      const Tt = vt.implicit !== null ? vt.implicit : vt.tag, Rt = vt.implicit === null ? "universal" : "context";
      Tt === null ? vt.use === null && bt.error("Tag could be omitted only for .use()") : vt.use === null && (wt = this._encodeComposite(Tt, Et, Rt, xt));
    }
    return vt.explicit !== null && (wt = this._encodeComposite(vt.explicit, !1, "context", wt)), wt;
  }, at.prototype._encodeChoice = function(dt, bt) {
    const $t = this._baseState, vt = $t.choice[dt.type];
    return vt || Ke(!1, dt.type + " not found in " + JSON.stringify(Object.keys($t.choice))), vt._encode(dt.value, bt);
  }, at.prototype._encodePrimitive = function(dt, bt) {
    const $t = this._baseState;
    if (/str$/.test(dt))
      return this._encodeStr(bt, dt);
    if (dt === "objid" && $t.args)
      return this._encodeObjid(bt, $t.reverseArgs[0], $t.args[1]);
    if (dt === "objid")
      return this._encodeObjid(bt, null, null);
    if (dt === "gentime" || dt === "utctime")
      return this._encodeTime(bt, dt);
    if (dt === "null_")
      return this._encodeNull();
    if (dt === "int" || dt === "enum")
      return this._encodeInt(bt, $t.args && $t.reverseArgs[0]);
    if (dt === "bool")
      return this._encodeBool(bt);
    if (dt === "objDesc")
      return this._encodeStr(bt, dt);
    throw new Error("Unsupported tag: " + dt);
  }, at.prototype._isNumstr = function(dt) {
    return /^[0-9 ]*$/.test(dt);
  }, at.prototype._isPrintstr = function(dt) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(dt);
  }, exports$t$1;
}
var exports$s$1 = {}, _dewExec$s$1 = !1;
function dew$s$1() {
  if (_dewExec$s$1)
    return exports$s$1;
  _dewExec$s$1 = !0;
  function $e(Ze) {
    const Fe = {};
    return Object.keys(Ze).forEach(function(Ke) {
      (Ke | 0) == Ke && (Ke = Ke | 0);
      const Ve = Ze[Ke];
      Fe[Ve] = Ke;
    }), Fe;
  }
  return exports$s$1.tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
  }, exports$s$1.tagClassByName = $e(exports$s$1.tagClass), exports$s$1.tag = {
    0: "end",
    1: "bool",
    2: "int",
    3: "bitstr",
    4: "octstr",
    5: "null_",
    6: "objid",
    7: "objDesc",
    8: "external",
    9: "real",
    10: "enum",
    11: "embed",
    12: "utf8str",
    13: "relativeOid",
    16: "seq",
    17: "set",
    18: "numstr",
    19: "printstr",
    20: "t61str",
    21: "videostr",
    22: "ia5str",
    23: "utctime",
    24: "gentime",
    25: "graphstr",
    26: "iso646str",
    27: "genstr",
    28: "unistr",
    29: "charstr",
    30: "bmpstr"
  }, exports$s$1.tagByName = $e(exports$s$1.tag), exports$s$1;
}
var exports$r$1 = {}, _dewExec$r$1 = !1;
function dew$r$1() {
  if (_dewExec$r$1)
    return exports$r$1;
  _dewExec$r$1 = !0;
  const $e = dew$f$2(), Ze = dew$w$1().Buffer, Fe = dew$t$1(), Ke = dew$s$1();
  function Ve(ut) {
    this.enc = "der", this.name = ut.name, this.entity = ut, this.tree = new Je(), this.tree._init(ut.body);
  }
  exports$r$1 = Ve, Ve.prototype.encode = function(lt, dt) {
    return this.tree._encode(lt, dt).join();
  };
  function Je(ut) {
    Fe.call(this, "der", ut);
  }
  $e(Je, Fe), Je.prototype._encodeComposite = function(lt, dt, bt, $t) {
    const vt = at(lt, dt, bt, this.reporter);
    if ($t.length < 128) {
      const Et = Ze.alloc(2);
      return Et[0] = vt, Et[1] = $t.length, this._createEncoderBuffer([Et, $t]);
    }
    let wt = 1;
    for (let Et = $t.length; Et >= 256; Et >>= 8)
      wt++;
    const xt = Ze.alloc(1 + 1 + wt);
    xt[0] = vt, xt[1] = 128 | wt;
    for (let Et = 1 + wt, Tt = $t.length; Tt > 0; Et--, Tt >>= 8)
      xt[Et] = Tt & 255;
    return this._createEncoderBuffer([xt, $t]);
  }, Je.prototype._encodeStr = function(lt, dt) {
    if (dt === "bitstr")
      return this._createEncoderBuffer([lt.unused | 0, lt.data]);
    if (dt === "bmpstr") {
      const bt = Ze.alloc(lt.length * 2);
      for (let $t = 0; $t < lt.length; $t++)
        bt.writeUInt16BE(lt.charCodeAt($t), $t * 2);
      return this._createEncoderBuffer(bt);
    } else
      return dt === "numstr" ? this._isNumstr(lt) ? this._createEncoderBuffer(lt) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : dt === "printstr" ? this._isPrintstr(lt) ? this._createEncoderBuffer(lt) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(dt) ? this._createEncoderBuffer(lt) : dt === "objDesc" ? this._createEncoderBuffer(lt) : this.reporter.error("Encoding of string type: " + dt + " unsupported");
  }, Je.prototype._encodeObjid = function(lt, dt, bt) {
    if (typeof lt == "string") {
      if (!dt)
        return this.reporter.error("string objid given, but no values map found");
      if (!dt.hasOwnProperty(lt))
        return this.reporter.error("objid not found in values map");
      lt = dt[lt].split(/[\s.]+/g);
      for (let xt = 0; xt < lt.length; xt++)
        lt[xt] |= 0;
    } else if (Array.isArray(lt)) {
      lt = lt.slice();
      for (let xt = 0; xt < lt.length; xt++)
        lt[xt] |= 0;
    }
    if (!Array.isArray(lt))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(lt));
    if (!bt) {
      if (lt[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      lt.splice(0, 2, lt[0] * 40 + lt[1]);
    }
    let $t = 0;
    for (let xt = 0; xt < lt.length; xt++) {
      let Et = lt[xt];
      for ($t++; Et >= 128; Et >>= 7)
        $t++;
    }
    const vt = Ze.alloc($t);
    let wt = vt.length - 1;
    for (let xt = lt.length - 1; xt >= 0; xt--) {
      let Et = lt[xt];
      for (vt[wt--] = Et & 127; (Et >>= 7) > 0; )
        vt[wt--] = 128 | Et & 127;
    }
    return this._createEncoderBuffer(vt);
  };
  function Qe(ut) {
    return ut < 10 ? "0" + ut : ut;
  }
  Je.prototype._encodeTime = function(lt, dt) {
    let bt;
    const $t = new Date(lt);
    return dt === "gentime" ? bt = [Qe($t.getUTCFullYear()), Qe($t.getUTCMonth() + 1), Qe($t.getUTCDate()), Qe($t.getUTCHours()), Qe($t.getUTCMinutes()), Qe($t.getUTCSeconds()), "Z"].join("") : dt === "utctime" ? bt = [Qe($t.getUTCFullYear() % 100), Qe($t.getUTCMonth() + 1), Qe($t.getUTCDate()), Qe($t.getUTCHours()), Qe($t.getUTCMinutes()), Qe($t.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + dt + " time is not supported yet"), this._encodeStr(bt, "octstr");
  }, Je.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, Je.prototype._encodeInt = function(lt, dt) {
    if (typeof lt == "string") {
      if (!dt)
        return this.reporter.error("String int or enum given, but no values map");
      if (!dt.hasOwnProperty(lt))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(lt));
      lt = dt[lt];
    }
    if (typeof lt != "number" && !Ze.isBuffer(lt)) {
      const vt = lt.toArray();
      !lt.sign && vt[0] & 128 && vt.unshift(0), lt = Ze.from(vt);
    }
    if (Ze.isBuffer(lt)) {
      let vt = lt.length;
      lt.length === 0 && vt++;
      const wt = Ze.alloc(vt);
      return lt.copy(wt), lt.length === 0 && (wt[0] = 0), this._createEncoderBuffer(wt);
    }
    if (lt < 128)
      return this._createEncoderBuffer(lt);
    if (lt < 256)
      return this._createEncoderBuffer([0, lt]);
    let bt = 1;
    for (let vt = lt; vt >= 256; vt >>= 8)
      bt++;
    const $t = new Array(bt);
    for (let vt = $t.length - 1; vt >= 0; vt--)
      $t[vt] = lt & 255, lt >>= 8;
    return $t[0] & 128 && $t.unshift(0), this._createEncoderBuffer(Ze.from($t));
  }, Je.prototype._encodeBool = function(lt) {
    return this._createEncoderBuffer(lt ? 255 : 0);
  }, Je.prototype._use = function(lt, dt) {
    return typeof lt == "function" && (lt = lt(dt)), lt._getEncoder("der").tree;
  }, Je.prototype._skipDefault = function(lt, dt, bt) {
    const $t = this._baseState;
    let vt;
    if ($t.default === null)
      return !1;
    const wt = lt.join();
    if ($t.defaultBuffer === void 0 && ($t.defaultBuffer = this._encodeValue($t.default, dt, bt).join()), wt.length !== $t.defaultBuffer.length)
      return !1;
    for (vt = 0; vt < wt.length; vt++)
      if (wt[vt] !== $t.defaultBuffer[vt])
        return !1;
    return !0;
  };
  function at(ut, lt, dt, bt) {
    let $t;
    if (ut === "seqof" ? ut = "seq" : ut === "setof" && (ut = "set"), Ke.tagByName.hasOwnProperty(ut))
      $t = Ke.tagByName[ut];
    else if (typeof ut == "number" && (ut | 0) === ut)
      $t = ut;
    else
      return bt.error("Unknown tag: " + ut);
    return $t >= 31 ? bt.error("Multi-octet tag encoding unsupported") : (lt || ($t |= 32), $t |= Ke.tagClassByName[dt || "universal"] << 6, $t);
  }
  return exports$r$1;
}
var exports$q$1 = {}, _dewExec$q$1 = !1;
function dew$q$1() {
  if (_dewExec$q$1)
    return exports$q$1;
  _dewExec$q$1 = !0;
  const $e = dew$f$2(), Ze = dew$r$1();
  function Fe(Ke) {
    Ze.call(this, Ke), this.enc = "pem";
  }
  return $e(Fe, Ze), exports$q$1 = Fe, Fe.prototype.encode = function(Ve, Je) {
    const at = Ze.prototype.encode.call(this, Ve).toString("base64"), ut = ["-----BEGIN " + Je.label + "-----"];
    for (let lt = 0; lt < at.length; lt += 64)
      ut.push(at.slice(lt, lt + 64));
    return ut.push("-----END " + Je.label + "-----"), ut.join(`
`);
  }, exports$q$1;
}
var exports$p$1 = {}, _dewExec$p$1 = !1;
function dew$p$1() {
  if (_dewExec$p$1)
    return exports$p$1;
  _dewExec$p$1 = !0;
  const $e = exports$p$1;
  return $e.der = dew$r$1(), $e.pem = dew$q$1(), exports$p$1;
}
var exports$o$1 = {}, _dewExec$o$1 = !1;
function dew$o$1() {
  if (_dewExec$o$1)
    return exports$o$1;
  _dewExec$o$1 = !0;
  const $e = dew$f$2(), Ze = dew$x$1(), Fe = dew$u$1().DecoderBuffer, Ke = dew$t$1(), Ve = dew$s$1();
  function Je(lt) {
    this.enc = "der", this.name = lt.name, this.entity = lt, this.tree = new Qe(), this.tree._init(lt.body);
  }
  exports$o$1 = Je, Je.prototype.decode = function(dt, bt) {
    return Fe.isDecoderBuffer(dt) || (dt = new Fe(dt, bt)), this.tree._decode(dt, bt);
  };
  function Qe(lt) {
    Ke.call(this, "der", lt);
  }
  $e(Qe, Ke), Qe.prototype._peekTag = function(dt, bt, $t) {
    if (dt.isEmpty())
      return !1;
    const vt = dt.save(), wt = at(dt, 'Failed to peek tag: "' + bt + '"');
    return dt.isError(wt) ? wt : (dt.restore(vt), wt.tag === bt || wt.tagStr === bt || wt.tagStr + "of" === bt || $t);
  }, Qe.prototype._decodeTag = function(dt, bt, $t) {
    const vt = at(dt, 'Failed to decode tag of "' + bt + '"');
    if (dt.isError(vt))
      return vt;
    let wt = ut(dt, vt.primitive, 'Failed to get length of "' + bt + '"');
    if (dt.isError(wt))
      return wt;
    if (!$t && vt.tag !== bt && vt.tagStr !== bt && vt.tagStr + "of" !== bt)
      return dt.error('Failed to match tag: "' + bt + '"');
    if (vt.primitive || wt !== null)
      return dt.skip(wt, 'Failed to match body of: "' + bt + '"');
    const xt = dt.save(), Et = this._skipUntilEnd(dt, 'Failed to skip indefinite length body: "' + this.tag + '"');
    return dt.isError(Et) ? Et : (wt = dt.offset - xt.offset, dt.restore(xt), dt.skip(wt, 'Failed to match body of: "' + bt + '"'));
  }, Qe.prototype._skipUntilEnd = function(dt, bt) {
    for (; ; ) {
      const $t = at(dt, bt);
      if (dt.isError($t))
        return $t;
      const vt = ut(dt, $t.primitive, bt);
      if (dt.isError(vt))
        return vt;
      let wt;
      if ($t.primitive || vt !== null ? wt = dt.skip(vt) : wt = this._skipUntilEnd(dt, bt), dt.isError(wt))
        return wt;
      if ($t.tagStr === "end")
        break;
    }
  }, Qe.prototype._decodeList = function(dt, bt, $t, vt) {
    const wt = [];
    for (; !dt.isEmpty(); ) {
      const xt = this._peekTag(dt, "end");
      if (dt.isError(xt))
        return xt;
      const Et = $t.decode(dt, "der", vt);
      if (dt.isError(Et) && xt)
        break;
      wt.push(Et);
    }
    return wt;
  }, Qe.prototype._decodeStr = function(dt, bt) {
    if (bt === "bitstr") {
      const $t = dt.readUInt8();
      return dt.isError($t) ? $t : {
        unused: $t,
        data: dt.raw()
      };
    } else if (bt === "bmpstr") {
      const $t = dt.raw();
      if ($t.length % 2 === 1)
        return dt.error("Decoding of string type: bmpstr length mismatch");
      let vt = "";
      for (let wt = 0; wt < $t.length / 2; wt++)
        vt += String.fromCharCode($t.readUInt16BE(wt * 2));
      return vt;
    } else if (bt === "numstr") {
      const $t = dt.raw().toString("ascii");
      return this._isNumstr($t) ? $t : dt.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (bt === "octstr")
        return dt.raw();
      if (bt === "objDesc")
        return dt.raw();
      if (bt === "printstr") {
        const $t = dt.raw().toString("ascii");
        return this._isPrintstr($t) ? $t : dt.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(bt) ? dt.raw().toString() : dt.error("Decoding of string type: " + bt + " unsupported");
    }
  }, Qe.prototype._decodeObjid = function(dt, bt, $t) {
    let vt;
    const wt = [];
    let xt = 0, Et = 0;
    for (; !dt.isEmpty(); )
      Et = dt.readUInt8(), xt <<= 7, xt |= Et & 127, Et & 128 || (wt.push(xt), xt = 0);
    Et & 128 && wt.push(xt);
    const Tt = wt[0] / 40 | 0, Rt = wt[0] % 40;
    if ($t ? vt = wt : vt = [Tt, Rt].concat(wt.slice(1)), bt) {
      let Ct = bt[vt.join(" ")];
      Ct === void 0 && (Ct = bt[vt.join(".")]), Ct !== void 0 && (vt = Ct);
    }
    return vt;
  }, Qe.prototype._decodeTime = function(dt, bt) {
    const $t = dt.raw().toString();
    let vt, wt, xt, Et, Tt, Rt;
    if (bt === "gentime")
      vt = $t.slice(0, 4) | 0, wt = $t.slice(4, 6) | 0, xt = $t.slice(6, 8) | 0, Et = $t.slice(8, 10) | 0, Tt = $t.slice(10, 12) | 0, Rt = $t.slice(12, 14) | 0;
    else if (bt === "utctime")
      vt = $t.slice(0, 2) | 0, wt = $t.slice(2, 4) | 0, xt = $t.slice(4, 6) | 0, Et = $t.slice(6, 8) | 0, Tt = $t.slice(8, 10) | 0, Rt = $t.slice(10, 12) | 0, vt < 70 ? vt = 2e3 + vt : vt = 1900 + vt;
    else
      return dt.error("Decoding " + bt + " time is not supported yet");
    return Date.UTC(vt, wt - 1, xt, Et, Tt, Rt, 0);
  }, Qe.prototype._decodeNull = function() {
    return null;
  }, Qe.prototype._decodeBool = function(dt) {
    const bt = dt.readUInt8();
    return dt.isError(bt) ? bt : bt !== 0;
  }, Qe.prototype._decodeInt = function(dt, bt) {
    const $t = dt.raw();
    let vt = new Ze($t);
    return bt && (vt = bt[vt.toString(10)] || vt), vt;
  }, Qe.prototype._use = function(dt, bt) {
    return typeof dt == "function" && (dt = dt(bt)), dt._getDecoder("der").tree;
  };
  function at(lt, dt) {
    let bt = lt.readUInt8(dt);
    if (lt.isError(bt))
      return bt;
    const $t = Ve.tagClass[bt >> 6], vt = (bt & 32) === 0;
    if ((bt & 31) === 31) {
      let xt = bt;
      for (bt = 0; (xt & 128) === 128; ) {
        if (xt = lt.readUInt8(dt), lt.isError(xt))
          return xt;
        bt <<= 7, bt |= xt & 127;
      }
    } else
      bt &= 31;
    const wt = Ve.tag[bt];
    return {
      cls: $t,
      primitive: vt,
      tag: bt,
      tagStr: wt
    };
  }
  function ut(lt, dt, bt) {
    let $t = lt.readUInt8(bt);
    if (lt.isError($t))
      return $t;
    if (!dt && $t === 128)
      return null;
    if (!($t & 128))
      return $t;
    const vt = $t & 127;
    if (vt > 4)
      return lt.error("length octect is too long");
    $t = 0;
    for (let wt = 0; wt < vt; wt++) {
      $t <<= 8;
      const xt = lt.readUInt8(bt);
      if (lt.isError(xt))
        return xt;
      $t |= xt;
    }
    return $t;
  }
  return exports$o$1;
}
var exports$n$1 = {}, _dewExec$n$1 = !1;
function dew$n$1() {
  if (_dewExec$n$1)
    return exports$n$1;
  _dewExec$n$1 = !0;
  const $e = dew$f$2(), Ze = dew$w$1().Buffer, Fe = dew$o$1();
  function Ke(Ve) {
    Fe.call(this, Ve), this.enc = "pem";
  }
  return $e(Ke, Fe), exports$n$1 = Ke, Ke.prototype.decode = function(Je, Qe) {
    const at = Je.toString().split(/[\r\n]+/g), ut = Qe.label.toUpperCase(), lt = /^-----(BEGIN|END) ([^-]+)-----$/;
    let dt = -1, bt = -1;
    for (let wt = 0; wt < at.length; wt++) {
      const xt = at[wt].match(lt);
      if (xt !== null && xt[2] === ut)
        if (dt === -1) {
          if (xt[1] !== "BEGIN")
            break;
          dt = wt;
        } else {
          if (xt[1] !== "END")
            break;
          bt = wt;
          break;
        }
    }
    if (dt === -1 || bt === -1)
      throw new Error("PEM section not found for: " + ut);
    const $t = at.slice(dt + 1, bt).join("");
    $t.replace(/[^a-z0-9+/=]+/gi, "");
    const vt = Ze.from($t, "base64");
    return Fe.prototype.decode.call(this, vt, Qe);
  }, exports$n$1;
}
var exports$m$1 = {}, _dewExec$m$1 = !1;
function dew$m$1() {
  if (_dewExec$m$1)
    return exports$m$1;
  _dewExec$m$1 = !0;
  const $e = exports$m$1;
  return $e.der = dew$o$1(), $e.pem = dew$n$1(), exports$m$1;
}
var exports$l$1 = {}, _dewExec$l$1 = !1;
function dew$l$1() {
  if (_dewExec$l$1)
    return exports$l$1;
  _dewExec$l$1 = !0;
  const $e = dew$p$1(), Ze = dew$m$1(), Fe = dew$f$2(), Ke = exports$l$1;
  Ke.define = function(Qe, at) {
    return new Ve(Qe, at);
  };
  function Ve(Je, Qe) {
    this.name = Je, this.body = Qe, this.decoders = {}, this.encoders = {};
  }
  return Ve.prototype._createNamed = function(Qe) {
    const at = this.name;
    function ut(lt) {
      this._initNamed(lt, at);
    }
    return Fe(ut, Qe), ut.prototype._initNamed = function(dt, bt) {
      Qe.call(this, dt, bt);
    }, new ut(this);
  }, Ve.prototype._getDecoder = function(Qe) {
    return Qe = Qe || "der", this.decoders.hasOwnProperty(Qe) || (this.decoders[Qe] = this._createNamed(Ze[Qe])), this.decoders[Qe];
  }, Ve.prototype.decode = function(Qe, at, ut) {
    return this._getDecoder(at).decode(Qe, ut);
  }, Ve.prototype._getEncoder = function(Qe) {
    return Qe = Qe || "der", this.encoders.hasOwnProperty(Qe) || (this.encoders[Qe] = this._createNamed($e[Qe])), this.encoders[Qe];
  }, Ve.prototype.encode = function(Qe, at, ut) {
    return this._getEncoder(at).encode(Qe, ut);
  }, exports$l$1;
}
var exports$k$1 = {}, _dewExec$k$1 = !1;
function dew$k$1() {
  if (_dewExec$k$1)
    return exports$k$1;
  _dewExec$k$1 = !0;
  const $e = exports$k$1;
  return $e.Reporter = dew$v$1().Reporter, $e.DecoderBuffer = dew$u$1().DecoderBuffer, $e.EncoderBuffer = dew$u$1().EncoderBuffer, $e.Node = dew$t$1(), exports$k$1;
}
var exports$j$1 = {}, _dewExec$j$1 = !1;
function dew$j$1() {
  if (_dewExec$j$1)
    return exports$j$1;
  _dewExec$j$1 = !0;
  const $e = exports$j$1;
  return $e._reverse = function(Fe) {
    const Ke = {};
    return Object.keys(Fe).forEach(function(Ve) {
      (Ve | 0) == Ve && (Ve = Ve | 0);
      const Je = Fe[Ve];
      Ke[Je] = Ve;
    }), Ke;
  }, $e.der = dew$s$1(), exports$j$1;
}
var exports$i$1 = {}, _dewExec$i$1 = !1;
function dew$i$1() {
  if (_dewExec$i$1)
    return exports$i$1;
  _dewExec$i$1 = !0;
  const $e = exports$i$1;
  return $e.bignum = dew$x$1(), $e.define = dew$l$1().define, $e.base = dew$k$1(), $e.constants = dew$j$1(), $e.decoders = dew$m$1(), $e.encoders = dew$p$1(), exports$i$1;
}
var exports$h$1 = {}, _dewExec$h$1 = !1;
function dew$h$1() {
  if (_dewExec$h$1)
    return exports$h$1;
  _dewExec$h$1 = !0;
  var $e = dew$i$1(), Ze = $e.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), Fe = $e.define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
  }), Ke = $e.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
  }), Ve = $e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(Ke), this.key("subjectPublicKey").bitstr());
  }), Je = $e.define("RelativeDistinguishedName", function() {
    this.setof(Fe);
  }), Qe = $e.define("RDNSequence", function() {
    this.seqof(Je);
  }), at = $e.define("Name", function() {
    this.choice({
      rdnSequence: this.use(Qe)
    });
  }), ut = $e.define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(Ze), this.key("notAfter").use(Ze));
  }), lt = $e.define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr());
  }), dt = $e.define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(Ke), this.key("issuer").use(at), this.key("validity").use(ut), this.key("subject").use(at), this.key("subjectPublicKeyInfo").use(Ve), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(lt).optional());
  }), bt = $e.define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(dt), this.key("signatureAlgorithm").use(Ke), this.key("signatureValue").bitstr());
  });
  return exports$h$1 = bt, exports$h$1;
}
var exports$g$1 = {}, _dewExec$g$1 = !1;
function dew$g$1() {
  if (_dewExec$g$1)
    return exports$g$1;
  _dewExec$g$1 = !0;
  var $e = dew$i$1();
  exports$g$1.certificate = dew$h$1();
  var Ze = $e.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
  });
  exports$g$1.RSAPrivateKey = Ze;
  var Fe = $e.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
  });
  exports$g$1.RSAPublicKey = Fe;
  var Ke = $e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(Ve), this.key("subjectPublicKey").bitstr());
  });
  exports$g$1.PublicKey = Ke;
  var Ve = $e.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
  }), Je = $e.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(Ve), this.key("subjectPrivateKey").octstr());
  });
  exports$g$1.PrivateKey = Je;
  var Qe = $e.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
  });
  exports$g$1.EncryptedPrivateKey = Qe;
  var at = $e.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
  });
  exports$g$1.DSAPrivateKey = at, exports$g$1.DSAparam = $e.define("DSAparam", function() {
    this.int();
  });
  var ut = $e.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(lt), this.key("publicKey").optional().explicit(1).bitstr());
  });
  exports$g$1.ECPrivateKey = ut;
  var lt = $e.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  });
  return exports$g$1.signature = $e.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
  }), exports$g$1;
}
var _aesid$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
}, exports$f$1 = {}, _dewExec$f$1 = !1;
function dew$f$1() {
  if (_dewExec$f$1)
    return exports$f$1;
  _dewExec$f$1 = !0;
  var $e = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, Ze = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, Fe = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, Ke = dew$18(), Ve = dew$15(), Je = dew$1T().Buffer;
  return exports$f$1 = function(Qe, at) {
    var ut = Qe.toString(), lt = ut.match($e), dt;
    if (lt) {
      var $t = "aes" + lt[1], vt = Je.from(lt[2], "hex"), wt = Je.from(lt[3].replace(/[\r\n]/g, ""), "base64"), xt = Ke(at, vt.slice(0, 8), parseInt(lt[1], 10)).key, Et = [], Tt = Ve.createDecipheriv($t, xt, vt);
      Et.push(Tt.update(wt)), Et.push(Tt.final()), dt = Je.concat(Et);
    } else {
      var bt = ut.match(Fe);
      dt = Je.from(bt[2].replace(/[\r\n]/g, ""), "base64");
    }
    var Rt = ut.match(Ze)[1];
    return {
      tag: Rt,
      data: dt
    };
  }, exports$f$1;
}
var exports$e$1 = {}, _dewExec$e$1 = !1;
function dew$e$1() {
  if (_dewExec$e$1)
    return exports$e$1;
  _dewExec$e$1 = !0;
  var $e = dew$g$1(), Ze = _aesid$1, Fe = dew$f$1(), Ke = dew$15(), Ve = dew$1v(), Je = dew$1T().Buffer;
  exports$e$1 = Qe;
  function Qe(ut) {
    var lt;
    typeof ut == "object" && !Je.isBuffer(ut) && (lt = ut.passphrase, ut = ut.key), typeof ut == "string" && (ut = Je.from(ut));
    var dt = Fe(ut, lt), bt = dt.tag, $t = dt.data, vt, wt;
    switch (bt) {
      case "CERTIFICATE":
        wt = $e.certificate.decode($t, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (wt || (wt = $e.PublicKey.decode($t, "der")), vt = wt.algorithm.algorithm.join("."), vt) {
          case "1.2.840.113549.1.1.1":
            return $e.RSAPublicKey.decode(wt.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return wt.subjectPrivateKey = wt.subjectPublicKey, {
              type: "ec",
              data: wt
            };
          case "1.2.840.10040.4.1":
            return wt.algorithm.params.pub_key = $e.DSAparam.decode(wt.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: wt.algorithm.params
            };
          default:
            throw new Error("unknown key id " + vt);
        }
      case "ENCRYPTED PRIVATE KEY":
        $t = $e.EncryptedPrivateKey.decode($t, "der"), $t = at($t, lt);
      case "PRIVATE KEY":
        switch (wt = $e.PrivateKey.decode($t, "der"), vt = wt.algorithm.algorithm.join("."), vt) {
          case "1.2.840.113549.1.1.1":
            return $e.RSAPrivateKey.decode(wt.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: wt.algorithm.curve,
              privateKey: $e.ECPrivateKey.decode(wt.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return wt.algorithm.params.priv_key = $e.DSAparam.decode(wt.subjectPrivateKey, "der"), {
              type: "dsa",
              params: wt.algorithm.params
            };
          default:
            throw new Error("unknown key id " + vt);
        }
      case "RSA PUBLIC KEY":
        return $e.RSAPublicKey.decode($t, "der");
      case "RSA PRIVATE KEY":
        return $e.RSAPrivateKey.decode($t, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: $e.DSAPrivateKey.decode($t, "der")
        };
      case "EC PRIVATE KEY":
        return $t = $e.ECPrivateKey.decode($t, "der"), {
          curve: $t.parameters.value,
          privateKey: $t.privateKey
        };
      default:
        throw new Error("unknown key type " + bt);
    }
  }
  Qe.signature = $e.signature;
  function at(ut, lt) {
    var dt = ut.algorithm.decrypt.kde.kdeparams.salt, bt = parseInt(ut.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), $t = Ze[ut.algorithm.decrypt.cipher.algo.join(".")], vt = ut.algorithm.decrypt.cipher.iv, wt = ut.subjectPrivateKey, xt = parseInt($t.split("-")[1], 10) / 8, Et = Ve.pbkdf2Sync(lt, dt, bt, xt, "sha1"), Tt = Ke.createDecipheriv($t, Et, vt), Rt = [];
    return Rt.push(Tt.update(wt)), Rt.push(Tt.final()), Je.concat(Rt);
  }
  return exports$e$1;
}
var _curves$1 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
}, exports$d$1 = {}, _dewExec$d$1 = !1;
function dew$d$1() {
  if (_dewExec$d$1)
    return exports$d$1;
  _dewExec$d$1 = !0;
  var $e = dew$1T().Buffer, Ze = dew$1C(), Fe = dew$W$1(), Ke = dew$y$1().ec, Ve = dew$X$1(), Je = dew$e$1(), Qe = _curves$1;
  function at(Et, Tt, Rt, Ct, Zt) {
    var Lt = Je(Tt);
    if (Lt.curve) {
      if (Ct !== "ecdsa" && Ct !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return ut(Et, Lt);
    } else if (Lt.type === "dsa") {
      if (Ct !== "dsa")
        throw new Error("wrong private key type");
      return lt(Et, Lt, Rt);
    } else if (Ct !== "rsa" && Ct !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    Et = $e.concat([Zt, Et]);
    for (var Ut = Lt.modulus.byteLength(), Pt = [0, 1]; Et.length + Pt.length + 1 < Ut; )
      Pt.push(255);
    Pt.push(0);
    for (var Ot = -1; ++Ot < Et.length; )
      Pt.push(Et[Ot]);
    var Ft = Fe(Pt, Lt);
    return Ft;
  }
  function ut(Et, Tt) {
    var Rt = Qe[Tt.curve.join(".")];
    if (!Rt)
      throw new Error("unknown curve " + Tt.curve.join("."));
    var Ct = new Ke(Rt), Zt = Ct.keyFromPrivate(Tt.privateKey), Lt = Zt.sign(Et);
    return $e.from(Lt.toDER());
  }
  function lt(Et, Tt, Rt) {
    for (var Ct = Tt.params.priv_key, Zt = Tt.params.p, Lt = Tt.params.q, Ut = Tt.params.g, Pt = new Ve(0), Ot, Ft = $t(Et, Lt).mod(Lt), gt = !1, We = bt(Ct, Lt, Et, Rt); gt === !1; )
      Ot = wt(Lt, We, Rt), Pt = xt(Ut, Ot, Zt, Lt), gt = Ot.invm(Lt).imul(Ft.add(Ct.mul(Pt))).mod(Lt), gt.cmpn(0) === 0 && (gt = !1, Pt = new Ve(0));
    return dt(Pt, gt);
  }
  function dt(Et, Tt) {
    Et = Et.toArray(), Tt = Tt.toArray(), Et[0] & 128 && (Et = [0].concat(Et)), Tt[0] & 128 && (Tt = [0].concat(Tt));
    var Rt = Et.length + Tt.length + 4, Ct = [48, Rt, 2, Et.length];
    return Ct = Ct.concat(Et, [2, Tt.length], Tt), $e.from(Ct);
  }
  function bt(Et, Tt, Rt, Ct) {
    if (Et = $e.from(Et.toArray()), Et.length < Tt.byteLength()) {
      var Zt = $e.alloc(Tt.byteLength() - Et.length);
      Et = $e.concat([Zt, Et]);
    }
    var Lt = Rt.length, Ut = vt(Rt, Tt), Pt = $e.alloc(Lt);
    Pt.fill(1);
    var Ot = $e.alloc(Lt);
    return Ot = Ze(Ct, Ot).update(Pt).update($e.from([0])).update(Et).update(Ut).digest(), Pt = Ze(Ct, Ot).update(Pt).digest(), Ot = Ze(Ct, Ot).update(Pt).update($e.from([1])).update(Et).update(Ut).digest(), Pt = Ze(Ct, Ot).update(Pt).digest(), {
      k: Ot,
      v: Pt
    };
  }
  function $t(Et, Tt) {
    var Rt = new Ve(Et), Ct = (Et.length << 3) - Tt.bitLength();
    return Ct > 0 && Rt.ishrn(Ct), Rt;
  }
  function vt(Et, Tt) {
    Et = $t(Et, Tt), Et = Et.mod(Tt);
    var Rt = $e.from(Et.toArray());
    if (Rt.length < Tt.byteLength()) {
      var Ct = $e.alloc(Tt.byteLength() - Rt.length);
      Rt = $e.concat([Ct, Rt]);
    }
    return Rt;
  }
  function wt(Et, Tt, Rt) {
    var Ct, Zt;
    do {
      for (Ct = $e.alloc(0); Ct.length * 8 < Et.bitLength(); )
        Tt.v = Ze(Rt, Tt.k).update(Tt.v).digest(), Ct = $e.concat([Ct, Tt.v]);
      Zt = $t(Ct, Et), Tt.k = Ze(Rt, Tt.k).update(Tt.v).update($e.from([0])).digest(), Tt.v = Ze(Rt, Tt.k).update(Tt.v).digest();
    } while (Zt.cmp(Et) !== -1);
    return Zt;
  }
  function xt(Et, Tt, Rt, Ct) {
    return Et.toRed(Ve.mont(Rt)).redPow(Tt).fromRed().mod(Ct);
  }
  return exports$d$1 = at, exports$d$1.getKey = bt, exports$d$1.makeKey = wt, exports$d$1;
}
var exports$c$1 = {}, _dewExec$c$1 = !1;
function dew$c$1() {
  if (_dewExec$c$1)
    return exports$c$1;
  _dewExec$c$1 = !0;
  var $e = dew$1T().Buffer, Ze = dew$X$1(), Fe = dew$y$1().ec, Ke = dew$e$1(), Ve = _curves$1;
  function Je(lt, dt, bt, $t, vt) {
    var wt = Ke(bt);
    if (wt.type === "ec") {
      if ($t !== "ecdsa" && $t !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return Qe(lt, dt, wt);
    } else if (wt.type === "dsa") {
      if ($t !== "dsa")
        throw new Error("wrong public key type");
      return at(lt, dt, wt);
    } else if ($t !== "rsa" && $t !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    dt = $e.concat([vt, dt]);
    for (var xt = wt.modulus.byteLength(), Et = [1], Tt = 0; dt.length + Et.length + 2 < xt; )
      Et.push(255), Tt++;
    Et.push(0);
    for (var Rt = -1; ++Rt < dt.length; )
      Et.push(dt[Rt]);
    Et = $e.from(Et);
    var Ct = Ze.mont(wt.modulus);
    lt = new Ze(lt).toRed(Ct), lt = lt.redPow(new Ze(wt.publicExponent)), lt = $e.from(lt.fromRed().toArray());
    var Zt = Tt < 8 ? 1 : 0;
    for (xt = Math.min(lt.length, Et.length), lt.length !== Et.length && (Zt = 1), Rt = -1; ++Rt < xt; )
      Zt |= lt[Rt] ^ Et[Rt];
    return Zt === 0;
  }
  function Qe(lt, dt, bt) {
    var $t = Ve[bt.data.algorithm.curve.join(".")];
    if (!$t)
      throw new Error("unknown curve " + bt.data.algorithm.curve.join("."));
    var vt = new Fe($t), wt = bt.data.subjectPrivateKey.data;
    return vt.verify(dt, lt, wt);
  }
  function at(lt, dt, bt) {
    var $t = bt.data.p, vt = bt.data.q, wt = bt.data.g, xt = bt.data.pub_key, Et = Ke.signature.decode(lt, "der"), Tt = Et.s, Rt = Et.r;
    ut(Tt, vt), ut(Rt, vt);
    var Ct = Ze.mont($t), Zt = Tt.invm(vt), Lt = wt.toRed(Ct).redPow(new Ze(dt).mul(Zt).mod(vt)).fromRed().mul(xt.toRed(Ct).redPow(Rt.mul(Zt).mod(vt)).fromRed()).mod($t).mod(vt);
    return Lt.cmp(Rt) === 0;
  }
  function ut(lt, dt) {
    if (lt.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (lt.cmp(dt) >= dt)
      throw new Error("invalid sig");
  }
  return exports$c$1 = Je, exports$c$1;
}
var exports$b$1 = {}, _dewExec$b$1 = !1, _global$4$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$b$1() {
  if (_dewExec$b$1)
    return exports$b$1;
  _dewExec$b$1 = !0;
  var $e = dew$1T().Buffer, Ze = dew$1F(), Fe = dew$1V(), Ke = dew$f$2(), Ve = dew$d$1(), Je = dew$c$1(), Qe = _algorithms;
  Object.keys(Qe).forEach(function(bt) {
    Qe[bt].id = $e.from(Qe[bt].id, "hex"), Qe[bt.toLowerCase()] = Qe[bt];
  });
  function at(bt) {
    Fe.Writable.call(this || _global$4$1);
    var $t = Qe[bt];
    if (!$t)
      throw new Error("Unknown message digest");
    (this || _global$4$1)._hashType = $t.hash, (this || _global$4$1)._hash = Ze($t.hash), (this || _global$4$1)._tag = $t.id, (this || _global$4$1)._signType = $t.sign;
  }
  Ke(at, Fe.Writable), at.prototype._write = function($t, vt, wt) {
    (this || _global$4$1)._hash.update($t), wt();
  }, at.prototype.update = function($t, vt) {
    return typeof $t == "string" && ($t = $e.from($t, vt)), (this || _global$4$1)._hash.update($t), this || _global$4$1;
  }, at.prototype.sign = function($t, vt) {
    this.end();
    var wt = (this || _global$4$1)._hash.digest(), xt = Ve(wt, $t, (this || _global$4$1)._hashType, (this || _global$4$1)._signType, (this || _global$4$1)._tag);
    return vt ? xt.toString(vt) : xt;
  };
  function ut(bt) {
    Fe.Writable.call(this || _global$4$1);
    var $t = Qe[bt];
    if (!$t)
      throw new Error("Unknown message digest");
    (this || _global$4$1)._hash = Ze($t.hash), (this || _global$4$1)._tag = $t.id, (this || _global$4$1)._signType = $t.sign;
  }
  Ke(ut, Fe.Writable), ut.prototype._write = function($t, vt, wt) {
    (this || _global$4$1)._hash.update($t), wt();
  }, ut.prototype.update = function($t, vt) {
    return typeof $t == "string" && ($t = $e.from($t, vt)), (this || _global$4$1)._hash.update($t), this || _global$4$1;
  }, ut.prototype.verify = function($t, vt, wt) {
    typeof vt == "string" && (vt = $e.from(vt, wt)), this.end();
    var xt = (this || _global$4$1)._hash.digest();
    return Je(vt, xt, $t, (this || _global$4$1)._signType, (this || _global$4$1)._tag);
  };
  function lt(bt) {
    return new at(bt);
  }
  function dt(bt) {
    return new ut(bt);
  }
  return exports$b$1 = {
    Sign: lt,
    Verify: dt,
    createSign: lt,
    createVerify: dt
  }, exports$b$1;
}
var exports$a$1 = {}, _dewExec$a$1 = !1, module$1$1 = {
  exports: exports$a$1
}, _global$3$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$a$1() {
  return _dewExec$a$1 || (_dewExec$a$1 = !0, function($e, Ze) {
    function Fe(gt, We) {
      if (!gt)
        throw new Error(We || "Assertion failed");
    }
    function Ke(gt, We) {
      gt.super_ = We;
      var Xe = function() {
      };
      Xe.prototype = We.prototype, gt.prototype = new Xe(), gt.prototype.constructor = gt;
    }
    function Ve(gt, We, Xe) {
      if (Ve.isBN(gt))
        return gt;
      (this || _global$3$1).negative = 0, (this || _global$3$1).words = null, (this || _global$3$1).length = 0, (this || _global$3$1).red = null, gt !== null && ((We === "le" || We === "be") && (Xe = We, We = 10), this._init(gt || 0, We || 10, Xe || "be"));
    }
    typeof $e == "object" ? $e.exports = Ve : Ze.BN = Ve, Ve.BN = Ve, Ve.wordSize = 26;
    var Je;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Je = window.Buffer : Je = e$1$1$1.Buffer;
    } catch {
    }
    Ve.isBN = function(We) {
      return We instanceof Ve ? !0 : We !== null && typeof We == "object" && We.constructor.wordSize === Ve.wordSize && Array.isArray(We.words);
    }, Ve.max = function(We, Xe) {
      return We.cmp(Xe) > 0 ? We : Xe;
    }, Ve.min = function(We, Xe) {
      return We.cmp(Xe) < 0 ? We : Xe;
    }, Ve.prototype._init = function(We, Xe, rt) {
      if (typeof We == "number")
        return this._initNumber(We, Xe, rt);
      if (typeof We == "object")
        return this._initArray(We, Xe, rt);
      Xe === "hex" && (Xe = 16), Fe(Xe === (Xe | 0) && Xe >= 2 && Xe <= 36), We = We.toString().replace(/\s+/g, "");
      var ot = 0;
      We[0] === "-" && (ot++, (this || _global$3$1).negative = 1), ot < We.length && (Xe === 16 ? this._parseHex(We, ot, rt) : (this._parseBase(We, Xe, ot), rt === "le" && this._initArray(this.toArray(), Xe, rt)));
    }, Ve.prototype._initNumber = function(We, Xe, rt) {
      We < 0 && ((this || _global$3$1).negative = 1, We = -We), We < 67108864 ? ((this || _global$3$1).words = [We & 67108863], (this || _global$3$1).length = 1) : We < 4503599627370496 ? ((this || _global$3$1).words = [We & 67108863, We / 67108864 & 67108863], (this || _global$3$1).length = 2) : (Fe(We < 9007199254740992), (this || _global$3$1).words = [We & 67108863, We / 67108864 & 67108863, 1], (this || _global$3$1).length = 3), rt === "le" && this._initArray(this.toArray(), Xe, rt);
    }, Ve.prototype._initArray = function(We, Xe, rt) {
      if (Fe(typeof We.length == "number"), We.length <= 0)
        return (this || _global$3$1).words = [0], (this || _global$3$1).length = 1, this || _global$3$1;
      (this || _global$3$1).length = Math.ceil(We.length / 3), (this || _global$3$1).words = new Array((this || _global$3$1).length);
      for (var ot = 0; ot < (this || _global$3$1).length; ot++)
        (this || _global$3$1).words[ot] = 0;
      var ft, mt, yt = 0;
      if (rt === "be")
        for (ot = We.length - 1, ft = 0; ot >= 0; ot -= 3)
          mt = We[ot] | We[ot - 1] << 8 | We[ot - 2] << 16, (this || _global$3$1).words[ft] |= mt << yt & 67108863, (this || _global$3$1).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      else if (rt === "le")
        for (ot = 0, ft = 0; ot < We.length; ot += 3)
          mt = We[ot] | We[ot + 1] << 8 | We[ot + 2] << 16, (this || _global$3$1).words[ft] |= mt << yt & 67108863, (this || _global$3$1).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      return this.strip();
    };
    function Qe(gt, We) {
      var Xe = gt.charCodeAt(We);
      return Xe >= 65 && Xe <= 70 ? Xe - 55 : Xe >= 97 && Xe <= 102 ? Xe - 87 : Xe - 48 & 15;
    }
    function at(gt, We, Xe) {
      var rt = Qe(gt, Xe);
      return Xe - 1 >= We && (rt |= Qe(gt, Xe - 1) << 4), rt;
    }
    Ve.prototype._parseHex = function(We, Xe, rt) {
      (this || _global$3$1).length = Math.ceil((We.length - Xe) / 6), (this || _global$3$1).words = new Array((this || _global$3$1).length);
      for (var ot = 0; ot < (this || _global$3$1).length; ot++)
        (this || _global$3$1).words[ot] = 0;
      var ft = 0, mt = 0, yt;
      if (rt === "be")
        for (ot = We.length - 1; ot >= Xe; ot -= 2)
          yt = at(We, Xe, ot) << ft, (this || _global$3$1).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$3$1).words[mt] |= yt >>> 26) : ft += 8;
      else {
        var pt = We.length - Xe;
        for (ot = pt % 2 === 0 ? Xe + 1 : Xe; ot < We.length; ot += 2)
          yt = at(We, Xe, ot) << ft, (this || _global$3$1).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$3$1).words[mt] |= yt >>> 26) : ft += 8;
      }
      this.strip();
    };
    function ut(gt, We, Xe, rt) {
      for (var ot = 0, ft = Math.min(gt.length, Xe), mt = We; mt < ft; mt++) {
        var yt = gt.charCodeAt(mt) - 48;
        ot *= rt, yt >= 49 ? ot += yt - 49 + 10 : yt >= 17 ? ot += yt - 17 + 10 : ot += yt;
      }
      return ot;
    }
    Ve.prototype._parseBase = function(We, Xe, rt) {
      (this || _global$3$1).words = [0], (this || _global$3$1).length = 1;
      for (var ot = 0, ft = 1; ft <= 67108863; ft *= Xe)
        ot++;
      ot--, ft = ft / Xe | 0;
      for (var mt = We.length - rt, yt = mt % ot, pt = Math.min(mt, mt - yt) + rt, Ge = 0, ct = rt; ct < pt; ct += ot)
        Ge = ut(We, ct, ct + ot, Xe), this.imuln(ft), (this || _global$3$1).words[0] + Ge < 67108864 ? (this || _global$3$1).words[0] += Ge : this._iaddn(Ge);
      if (yt !== 0) {
        var Mt = 1;
        for (Ge = ut(We, ct, We.length, Xe), ct = 0; ct < yt; ct++)
          Mt *= Xe;
        this.imuln(Mt), (this || _global$3$1).words[0] + Ge < 67108864 ? (this || _global$3$1).words[0] += Ge : this._iaddn(Ge);
      }
      this.strip();
    }, Ve.prototype.copy = function(We) {
      We.words = new Array((this || _global$3$1).length);
      for (var Xe = 0; Xe < (this || _global$3$1).length; Xe++)
        We.words[Xe] = (this || _global$3$1).words[Xe];
      We.length = (this || _global$3$1).length, We.negative = (this || _global$3$1).negative, We.red = (this || _global$3$1).red;
    }, Ve.prototype.clone = function() {
      var We = new Ve(null);
      return this.copy(We), We;
    }, Ve.prototype._expand = function(We) {
      for (; (this || _global$3$1).length < We; )
        (this || _global$3$1).words[(this || _global$3$1).length++] = 0;
      return this || _global$3$1;
    }, Ve.prototype.strip = function() {
      for (; (this || _global$3$1).length > 1 && (this || _global$3$1).words[(this || _global$3$1).length - 1] === 0; )
        (this || _global$3$1).length--;
      return this._normSign();
    }, Ve.prototype._normSign = function() {
      return (this || _global$3$1).length === 1 && (this || _global$3$1).words[0] === 0 && ((this || _global$3$1).negative = 0), this || _global$3$1;
    }, Ve.prototype.inspect = function() {
      return ((this || _global$3$1).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var lt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], dt = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], bt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    Ve.prototype.toString = function(We, Xe) {
      We = We || 10, Xe = Xe | 0 || 1;
      var rt;
      if (We === 16 || We === "hex") {
        rt = "";
        for (var ot = 0, ft = 0, mt = 0; mt < (this || _global$3$1).length; mt++) {
          var yt = (this || _global$3$1).words[mt], pt = ((yt << ot | ft) & 16777215).toString(16);
          ft = yt >>> 24 - ot & 16777215, ft !== 0 || mt !== (this || _global$3$1).length - 1 ? rt = lt[6 - pt.length] + pt + rt : rt = pt + rt, ot += 2, ot >= 26 && (ot -= 26, mt--);
        }
        for (ft !== 0 && (rt = ft.toString(16) + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$3$1).negative !== 0 && (rt = "-" + rt), rt;
      }
      if (We === (We | 0) && We >= 2 && We <= 36) {
        var Ge = dt[We], ct = bt[We];
        rt = "";
        var Mt = this.clone();
        for (Mt.negative = 0; !Mt.isZero(); ) {
          var St = Mt.modn(ct).toString(We);
          Mt = Mt.idivn(ct), Mt.isZero() ? rt = St + rt : rt = lt[Ge - St.length] + St + rt;
        }
        for (this.isZero() && (rt = "0" + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$3$1).negative !== 0 && (rt = "-" + rt), rt;
      }
      Fe(!1, "Base should be between 2 and 36");
    }, Ve.prototype.toNumber = function() {
      var We = (this || _global$3$1).words[0];
      return (this || _global$3$1).length === 2 ? We += (this || _global$3$1).words[1] * 67108864 : (this || _global$3$1).length === 3 && (this || _global$3$1).words[2] === 1 ? We += 4503599627370496 + (this || _global$3$1).words[1] * 67108864 : (this || _global$3$1).length > 2 && Fe(!1, "Number can only safely store up to 53 bits"), (this || _global$3$1).negative !== 0 ? -We : We;
    }, Ve.prototype.toJSON = function() {
      return this.toString(16);
    }, Ve.prototype.toBuffer = function(We, Xe) {
      return Fe(typeof Je < "u"), this.toArrayLike(Je, We, Xe);
    }, Ve.prototype.toArray = function(We, Xe) {
      return this.toArrayLike(Array, We, Xe);
    }, Ve.prototype.toArrayLike = function(We, Xe, rt) {
      var ot = this.byteLength(), ft = rt || Math.max(1, ot);
      Fe(ot <= ft, "byte array longer than desired length"), Fe(ft > 0, "Requested array length <= 0"), this.strip();
      var mt = Xe === "le", yt = new We(ft), pt, Ge, ct = this.clone();
      if (mt) {
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[Ge] = pt;
        for (; Ge < ft; Ge++)
          yt[Ge] = 0;
      } else {
        for (Ge = 0; Ge < ft - ot; Ge++)
          yt[Ge] = 0;
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[ft - Ge - 1] = pt;
      }
      return yt;
    }, Math.clz32 ? Ve.prototype._countBits = function(We) {
      return 32 - Math.clz32(We);
    } : Ve.prototype._countBits = function(We) {
      var Xe = We, rt = 0;
      return Xe >= 4096 && (rt += 13, Xe >>>= 13), Xe >= 64 && (rt += 7, Xe >>>= 7), Xe >= 8 && (rt += 4, Xe >>>= 4), Xe >= 2 && (rt += 2, Xe >>>= 2), rt + Xe;
    }, Ve.prototype._zeroBits = function(We) {
      if (We === 0)
        return 26;
      var Xe = We, rt = 0;
      return Xe & 8191 || (rt += 13, Xe >>>= 13), Xe & 127 || (rt += 7, Xe >>>= 7), Xe & 15 || (rt += 4, Xe >>>= 4), Xe & 3 || (rt += 2, Xe >>>= 2), Xe & 1 || rt++, rt;
    }, Ve.prototype.bitLength = function() {
      var We = (this || _global$3$1).words[(this || _global$3$1).length - 1], Xe = this._countBits(We);
      return ((this || _global$3$1).length - 1) * 26 + Xe;
    };
    function $t(gt) {
      for (var We = new Array(gt.bitLength()), Xe = 0; Xe < We.length; Xe++) {
        var rt = Xe / 26 | 0, ot = Xe % 26;
        We[Xe] = (gt.words[rt] & 1 << ot) >>> ot;
      }
      return We;
    }
    Ve.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var We = 0, Xe = 0; Xe < (this || _global$3$1).length; Xe++) {
        var rt = this._zeroBits((this || _global$3$1).words[Xe]);
        if (We += rt, rt !== 26)
          break;
      }
      return We;
    }, Ve.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Ve.prototype.toTwos = function(We) {
      return (this || _global$3$1).negative !== 0 ? this.abs().inotn(We).iaddn(1) : this.clone();
    }, Ve.prototype.fromTwos = function(We) {
      return this.testn(We - 1) ? this.notn(We).iaddn(1).ineg() : this.clone();
    }, Ve.prototype.isNeg = function() {
      return (this || _global$3$1).negative !== 0;
    }, Ve.prototype.neg = function() {
      return this.clone().ineg();
    }, Ve.prototype.ineg = function() {
      return this.isZero() || ((this || _global$3$1).negative ^= 1), this || _global$3$1;
    }, Ve.prototype.iuor = function(We) {
      for (; (this || _global$3$1).length < We.length; )
        (this || _global$3$1).words[(this || _global$3$1).length++] = 0;
      for (var Xe = 0; Xe < We.length; Xe++)
        (this || _global$3$1).words[Xe] = (this || _global$3$1).words[Xe] | We.words[Xe];
      return this.strip();
    }, Ve.prototype.ior = function(We) {
      return Fe(((this || _global$3$1).negative | We.negative) === 0), this.iuor(We);
    }, Ve.prototype.or = function(We) {
      return (this || _global$3$1).length > We.length ? this.clone().ior(We) : We.clone().ior(this || _global$3$1);
    }, Ve.prototype.uor = function(We) {
      return (this || _global$3$1).length > We.length ? this.clone().iuor(We) : We.clone().iuor(this || _global$3$1);
    }, Ve.prototype.iuand = function(We) {
      var Xe;
      (this || _global$3$1).length > We.length ? Xe = We : Xe = this || _global$3$1;
      for (var rt = 0; rt < Xe.length; rt++)
        (this || _global$3$1).words[rt] = (this || _global$3$1).words[rt] & We.words[rt];
      return (this || _global$3$1).length = Xe.length, this.strip();
    }, Ve.prototype.iand = function(We) {
      return Fe(((this || _global$3$1).negative | We.negative) === 0), this.iuand(We);
    }, Ve.prototype.and = function(We) {
      return (this || _global$3$1).length > We.length ? this.clone().iand(We) : We.clone().iand(this || _global$3$1);
    }, Ve.prototype.uand = function(We) {
      return (this || _global$3$1).length > We.length ? this.clone().iuand(We) : We.clone().iuand(this || _global$3$1);
    }, Ve.prototype.iuxor = function(We) {
      var Xe, rt;
      (this || _global$3$1).length > We.length ? (Xe = this || _global$3$1, rt = We) : (Xe = We, rt = this || _global$3$1);
      for (var ot = 0; ot < rt.length; ot++)
        (this || _global$3$1).words[ot] = Xe.words[ot] ^ rt.words[ot];
      if ((this || _global$3$1) !== Xe)
        for (; ot < Xe.length; ot++)
          (this || _global$3$1).words[ot] = Xe.words[ot];
      return (this || _global$3$1).length = Xe.length, this.strip();
    }, Ve.prototype.ixor = function(We) {
      return Fe(((this || _global$3$1).negative | We.negative) === 0), this.iuxor(We);
    }, Ve.prototype.xor = function(We) {
      return (this || _global$3$1).length > We.length ? this.clone().ixor(We) : We.clone().ixor(this || _global$3$1);
    }, Ve.prototype.uxor = function(We) {
      return (this || _global$3$1).length > We.length ? this.clone().iuxor(We) : We.clone().iuxor(this || _global$3$1);
    }, Ve.prototype.inotn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = Math.ceil(We / 26) | 0, rt = We % 26;
      this._expand(Xe), rt > 0 && Xe--;
      for (var ot = 0; ot < Xe; ot++)
        (this || _global$3$1).words[ot] = ~(this || _global$3$1).words[ot] & 67108863;
      return rt > 0 && ((this || _global$3$1).words[ot] = ~(this || _global$3$1).words[ot] & 67108863 >> 26 - rt), this.strip();
    }, Ve.prototype.notn = function(We) {
      return this.clone().inotn(We);
    }, Ve.prototype.setn = function(We, Xe) {
      Fe(typeof We == "number" && We >= 0);
      var rt = We / 26 | 0, ot = We % 26;
      return this._expand(rt + 1), Xe ? (this || _global$3$1).words[rt] = (this || _global$3$1).words[rt] | 1 << ot : (this || _global$3$1).words[rt] = (this || _global$3$1).words[rt] & ~(1 << ot), this.strip();
    }, Ve.prototype.iadd = function(We) {
      var Xe;
      if ((this || _global$3$1).negative !== 0 && We.negative === 0)
        return (this || _global$3$1).negative = 0, Xe = this.isub(We), (this || _global$3$1).negative ^= 1, this._normSign();
      if ((this || _global$3$1).negative === 0 && We.negative !== 0)
        return We.negative = 0, Xe = this.isub(We), We.negative = 1, Xe._normSign();
      var rt, ot;
      (this || _global$3$1).length > We.length ? (rt = this || _global$3$1, ot = We) : (rt = We, ot = this || _global$3$1);
      for (var ft = 0, mt = 0; mt < ot.length; mt++)
        Xe = (rt.words[mt] | 0) + (ot.words[mt] | 0) + ft, (this || _global$3$1).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      for (; ft !== 0 && mt < rt.length; mt++)
        Xe = (rt.words[mt] | 0) + ft, (this || _global$3$1).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      if ((this || _global$3$1).length = rt.length, ft !== 0)
        (this || _global$3$1).words[(this || _global$3$1).length] = ft, (this || _global$3$1).length++;
      else if (rt !== (this || _global$3$1))
        for (; mt < rt.length; mt++)
          (this || _global$3$1).words[mt] = rt.words[mt];
      return this || _global$3$1;
    }, Ve.prototype.add = function(We) {
      var Xe;
      return We.negative !== 0 && (this || _global$3$1).negative === 0 ? (We.negative = 0, Xe = this.sub(We), We.negative ^= 1, Xe) : We.negative === 0 && (this || _global$3$1).negative !== 0 ? ((this || _global$3$1).negative = 0, Xe = We.sub(this || _global$3$1), (this || _global$3$1).negative = 1, Xe) : (this || _global$3$1).length > We.length ? this.clone().iadd(We) : We.clone().iadd(this || _global$3$1);
    }, Ve.prototype.isub = function(We) {
      if (We.negative !== 0) {
        We.negative = 0;
        var Xe = this.iadd(We);
        return We.negative = 1, Xe._normSign();
      } else if ((this || _global$3$1).negative !== 0)
        return (this || _global$3$1).negative = 0, this.iadd(We), (this || _global$3$1).negative = 1, this._normSign();
      var rt = this.cmp(We);
      if (rt === 0)
        return (this || _global$3$1).negative = 0, (this || _global$3$1).length = 1, (this || _global$3$1).words[0] = 0, this || _global$3$1;
      var ot, ft;
      rt > 0 ? (ot = this || _global$3$1, ft = We) : (ot = We, ft = this || _global$3$1);
      for (var mt = 0, yt = 0; yt < ft.length; yt++)
        Xe = (ot.words[yt] | 0) - (ft.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$3$1).words[yt] = Xe & 67108863;
      for (; mt !== 0 && yt < ot.length; yt++)
        Xe = (ot.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$3$1).words[yt] = Xe & 67108863;
      if (mt === 0 && yt < ot.length && ot !== (this || _global$3$1))
        for (; yt < ot.length; yt++)
          (this || _global$3$1).words[yt] = ot.words[yt];
      return (this || _global$3$1).length = Math.max((this || _global$3$1).length, yt), ot !== (this || _global$3$1) && ((this || _global$3$1).negative = 1), this.strip();
    }, Ve.prototype.sub = function(We) {
      return this.clone().isub(We);
    };
    function vt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative;
      var rt = gt.length + We.length | 0;
      Xe.length = rt, rt = rt - 1 | 0;
      var ot = gt.words[0] | 0, ft = We.words[0] | 0, mt = ot * ft, yt = mt & 67108863, pt = mt / 67108864 | 0;
      Xe.words[0] = yt;
      for (var Ge = 1; Ge < rt; Ge++) {
        for (var ct = pt >>> 26, Mt = pt & 67108863, St = Math.min(Ge, We.length - 1), At = Math.max(0, Ge - gt.length + 1); At <= St; At++) {
          var Nt = Ge - At | 0;
          ot = gt.words[Nt] | 0, ft = We.words[At] | 0, mt = ot * ft + Mt, ct += mt / 67108864 | 0, Mt = mt & 67108863;
        }
        Xe.words[Ge] = Mt | 0, pt = ct | 0;
      }
      return pt !== 0 ? Xe.words[Ge] = pt | 0 : Xe.length--, Xe.strip();
    }
    var wt = function(We, Xe, rt) {
      var ot = We.words, ft = Xe.words, mt = rt.words, yt = 0, pt, Ge, ct, Mt = ot[0] | 0, St = Mt & 8191, At = Mt >>> 13, Nt = ot[1] | 0, qt = Nt & 8191, Qt = Nt >>> 13, Xt = ot[2] | 0, zt = Xt & 8191, Kt = Xt >>> 13, ur = ot[3] | 0, er = ur & 8191, Dt = ur >>> 13, Ht = ot[4] | 0, Gt = Ht & 8191, rr = Ht >>> 13, sr = ot[5] | 0, Jt = sr & 8191, ir = sr >>> 13, Br = ot[6] | 0, or = Br & 8191, lr = Br >>> 13, Nr = ot[7] | 0, dr = Nr & 8191, gr = Nr >>> 13, Zr = ot[8] | 0, Bt = Zr & 8191, kt = Zr >>> 13, It = ot[9] | 0, jt = It & 8191, Vt = It >>> 13, ar = ft[0] | 0, Yt = ar & 8191, hr = ar >>> 13, zr = ft[1] | 0, cr = zr & 8191, _r = zr >>> 13, Lr = ft[2] | 0, br = Lr & 8191, kr = Lr >>> 13, Xr = ft[3] | 0, yr = Xr & 8191, Ir = Xr >>> 13, Yr = ft[4] | 0, wr = Yr & 8191, Cr = Yr >>> 13, Hr = ft[5] | 0, $r = Hr & 8191, Ar = Hr >>> 13, Wr = ft[6] | 0, mr = Wr & 8191, Tr = Wr >>> 13, Kr = ft[7] | 0, vr = Kr & 8191, Rr = Kr >>> 13, Jr = ft[8] | 0, xr = Jr & 8191, tr = Jr >>> 13, Dr = ft[9] | 0, fr = Dr & 8191, Mr = Dr >>> 13;
      rt.negative = We.negative ^ Xe.negative, rt.length = 19, pt = Math.imul(St, Yt), Ge = Math.imul(St, hr), Ge = Ge + Math.imul(At, Yt) | 0, ct = Math.imul(At, hr);
      var Fr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, pt = Math.imul(qt, Yt), Ge = Math.imul(qt, hr), Ge = Ge + Math.imul(Qt, Yt) | 0, ct = Math.imul(Qt, hr), pt = pt + Math.imul(St, cr) | 0, Ge = Ge + Math.imul(St, _r) | 0, Ge = Ge + Math.imul(At, cr) | 0, ct = ct + Math.imul(At, _r) | 0;
      var qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, pt = Math.imul(zt, Yt), Ge = Math.imul(zt, hr), Ge = Ge + Math.imul(Kt, Yt) | 0, ct = Math.imul(Kt, hr), pt = pt + Math.imul(qt, cr) | 0, Ge = Ge + Math.imul(qt, _r) | 0, Ge = Ge + Math.imul(Qt, cr) | 0, ct = ct + Math.imul(Qt, _r) | 0, pt = pt + Math.imul(St, br) | 0, Ge = Ge + Math.imul(St, kr) | 0, Ge = Ge + Math.imul(At, br) | 0, ct = ct + Math.imul(At, kr) | 0;
      var tn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, pt = Math.imul(er, Yt), Ge = Math.imul(er, hr), Ge = Ge + Math.imul(Dt, Yt) | 0, ct = Math.imul(Dt, hr), pt = pt + Math.imul(zt, cr) | 0, Ge = Ge + Math.imul(zt, _r) | 0, Ge = Ge + Math.imul(Kt, cr) | 0, ct = ct + Math.imul(Kt, _r) | 0, pt = pt + Math.imul(qt, br) | 0, Ge = Ge + Math.imul(qt, kr) | 0, Ge = Ge + Math.imul(Qt, br) | 0, ct = ct + Math.imul(Qt, kr) | 0, pt = pt + Math.imul(St, yr) | 0, Ge = Ge + Math.imul(St, Ir) | 0, Ge = Ge + Math.imul(At, yr) | 0, ct = ct + Math.imul(At, Ir) | 0;
      var Qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, pt = Math.imul(Gt, Yt), Ge = Math.imul(Gt, hr), Ge = Ge + Math.imul(rr, Yt) | 0, ct = Math.imul(rr, hr), pt = pt + Math.imul(er, cr) | 0, Ge = Ge + Math.imul(er, _r) | 0, Ge = Ge + Math.imul(Dt, cr) | 0, ct = ct + Math.imul(Dt, _r) | 0, pt = pt + Math.imul(zt, br) | 0, Ge = Ge + Math.imul(zt, kr) | 0, Ge = Ge + Math.imul(Kt, br) | 0, ct = ct + Math.imul(Kt, kr) | 0, pt = pt + Math.imul(qt, yr) | 0, Ge = Ge + Math.imul(qt, Ir) | 0, Ge = Ge + Math.imul(Qt, yr) | 0, ct = ct + Math.imul(Qt, Ir) | 0, pt = pt + Math.imul(St, wr) | 0, Ge = Ge + Math.imul(St, Cr) | 0, Ge = Ge + Math.imul(At, wr) | 0, ct = ct + Math.imul(At, Cr) | 0;
      var nn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, pt = Math.imul(Jt, Yt), Ge = Math.imul(Jt, hr), Ge = Ge + Math.imul(ir, Yt) | 0, ct = Math.imul(ir, hr), pt = pt + Math.imul(Gt, cr) | 0, Ge = Ge + Math.imul(Gt, _r) | 0, Ge = Ge + Math.imul(rr, cr) | 0, ct = ct + Math.imul(rr, _r) | 0, pt = pt + Math.imul(er, br) | 0, Ge = Ge + Math.imul(er, kr) | 0, Ge = Ge + Math.imul(Dt, br) | 0, ct = ct + Math.imul(Dt, kr) | 0, pt = pt + Math.imul(zt, yr) | 0, Ge = Ge + Math.imul(zt, Ir) | 0, Ge = Ge + Math.imul(Kt, yr) | 0, ct = ct + Math.imul(Kt, Ir) | 0, pt = pt + Math.imul(qt, wr) | 0, Ge = Ge + Math.imul(qt, Cr) | 0, Ge = Ge + Math.imul(Qt, wr) | 0, ct = ct + Math.imul(Qt, Cr) | 0, pt = pt + Math.imul(St, $r) | 0, Ge = Ge + Math.imul(St, Ar) | 0, Ge = Ge + Math.imul(At, $r) | 0, ct = ct + Math.imul(At, Ar) | 0;
      var Er = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, pt = Math.imul(or, Yt), Ge = Math.imul(or, hr), Ge = Ge + Math.imul(lr, Yt) | 0, ct = Math.imul(lr, hr), pt = pt + Math.imul(Jt, cr) | 0, Ge = Ge + Math.imul(Jt, _r) | 0, Ge = Ge + Math.imul(ir, cr) | 0, ct = ct + Math.imul(ir, _r) | 0, pt = pt + Math.imul(Gt, br) | 0, Ge = Ge + Math.imul(Gt, kr) | 0, Ge = Ge + Math.imul(rr, br) | 0, ct = ct + Math.imul(rr, kr) | 0, pt = pt + Math.imul(er, yr) | 0, Ge = Ge + Math.imul(er, Ir) | 0, Ge = Ge + Math.imul(Dt, yr) | 0, ct = ct + Math.imul(Dt, Ir) | 0, pt = pt + Math.imul(zt, wr) | 0, Ge = Ge + Math.imul(zt, Cr) | 0, Ge = Ge + Math.imul(Kt, wr) | 0, ct = ct + Math.imul(Kt, Cr) | 0, pt = pt + Math.imul(qt, $r) | 0, Ge = Ge + Math.imul(qt, Ar) | 0, Ge = Ge + Math.imul(Qt, $r) | 0, ct = ct + Math.imul(Qt, Ar) | 0, pt = pt + Math.imul(St, mr) | 0, Ge = Ge + Math.imul(St, Tr) | 0, Ge = Ge + Math.imul(At, mr) | 0, ct = ct + Math.imul(At, Tr) | 0;
      var Wt = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, pt = Math.imul(dr, Yt), Ge = Math.imul(dr, hr), Ge = Ge + Math.imul(gr, Yt) | 0, ct = Math.imul(gr, hr), pt = pt + Math.imul(or, cr) | 0, Ge = Ge + Math.imul(or, _r) | 0, Ge = Ge + Math.imul(lr, cr) | 0, ct = ct + Math.imul(lr, _r) | 0, pt = pt + Math.imul(Jt, br) | 0, Ge = Ge + Math.imul(Jt, kr) | 0, Ge = Ge + Math.imul(ir, br) | 0, ct = ct + Math.imul(ir, kr) | 0, pt = pt + Math.imul(Gt, yr) | 0, Ge = Ge + Math.imul(Gt, Ir) | 0, Ge = Ge + Math.imul(rr, yr) | 0, ct = ct + Math.imul(rr, Ir) | 0, pt = pt + Math.imul(er, wr) | 0, Ge = Ge + Math.imul(er, Cr) | 0, Ge = Ge + Math.imul(Dt, wr) | 0, ct = ct + Math.imul(Dt, Cr) | 0, pt = pt + Math.imul(zt, $r) | 0, Ge = Ge + Math.imul(zt, Ar) | 0, Ge = Ge + Math.imul(Kt, $r) | 0, ct = ct + Math.imul(Kt, Ar) | 0, pt = pt + Math.imul(qt, mr) | 0, Ge = Ge + Math.imul(qt, Tr) | 0, Ge = Ge + Math.imul(Qt, mr) | 0, ct = ct + Math.imul(Qt, Tr) | 0, pt = pt + Math.imul(St, vr) | 0, Ge = Ge + Math.imul(St, Rr) | 0, Ge = Ge + Math.imul(At, vr) | 0, ct = ct + Math.imul(At, Rr) | 0;
      var nr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, pt = Math.imul(Bt, Yt), Ge = Math.imul(Bt, hr), Ge = Ge + Math.imul(kt, Yt) | 0, ct = Math.imul(kt, hr), pt = pt + Math.imul(dr, cr) | 0, Ge = Ge + Math.imul(dr, _r) | 0, Ge = Ge + Math.imul(gr, cr) | 0, ct = ct + Math.imul(gr, _r) | 0, pt = pt + Math.imul(or, br) | 0, Ge = Ge + Math.imul(or, kr) | 0, Ge = Ge + Math.imul(lr, br) | 0, ct = ct + Math.imul(lr, kr) | 0, pt = pt + Math.imul(Jt, yr) | 0, Ge = Ge + Math.imul(Jt, Ir) | 0, Ge = Ge + Math.imul(ir, yr) | 0, ct = ct + Math.imul(ir, Ir) | 0, pt = pt + Math.imul(Gt, wr) | 0, Ge = Ge + Math.imul(Gt, Cr) | 0, Ge = Ge + Math.imul(rr, wr) | 0, ct = ct + Math.imul(rr, Cr) | 0, pt = pt + Math.imul(er, $r) | 0, Ge = Ge + Math.imul(er, Ar) | 0, Ge = Ge + Math.imul(Dt, $r) | 0, ct = ct + Math.imul(Dt, Ar) | 0, pt = pt + Math.imul(zt, mr) | 0, Ge = Ge + Math.imul(zt, Tr) | 0, Ge = Ge + Math.imul(Kt, mr) | 0, ct = ct + Math.imul(Kt, Tr) | 0, pt = pt + Math.imul(qt, vr) | 0, Ge = Ge + Math.imul(qt, Rr) | 0, Ge = Ge + Math.imul(Qt, vr) | 0, ct = ct + Math.imul(Qt, Rr) | 0, pt = pt + Math.imul(St, xr) | 0, Ge = Ge + Math.imul(St, tr) | 0, Ge = Ge + Math.imul(At, xr) | 0, ct = ct + Math.imul(At, tr) | 0;
      var pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, pt = Math.imul(jt, Yt), Ge = Math.imul(jt, hr), Ge = Ge + Math.imul(Vt, Yt) | 0, ct = Math.imul(Vt, hr), pt = pt + Math.imul(Bt, cr) | 0, Ge = Ge + Math.imul(Bt, _r) | 0, Ge = Ge + Math.imul(kt, cr) | 0, ct = ct + Math.imul(kt, _r) | 0, pt = pt + Math.imul(dr, br) | 0, Ge = Ge + Math.imul(dr, kr) | 0, Ge = Ge + Math.imul(gr, br) | 0, ct = ct + Math.imul(gr, kr) | 0, pt = pt + Math.imul(or, yr) | 0, Ge = Ge + Math.imul(or, Ir) | 0, Ge = Ge + Math.imul(lr, yr) | 0, ct = ct + Math.imul(lr, Ir) | 0, pt = pt + Math.imul(Jt, wr) | 0, Ge = Ge + Math.imul(Jt, Cr) | 0, Ge = Ge + Math.imul(ir, wr) | 0, ct = ct + Math.imul(ir, Cr) | 0, pt = pt + Math.imul(Gt, $r) | 0, Ge = Ge + Math.imul(Gt, Ar) | 0, Ge = Ge + Math.imul(rr, $r) | 0, ct = ct + Math.imul(rr, Ar) | 0, pt = pt + Math.imul(er, mr) | 0, Ge = Ge + Math.imul(er, Tr) | 0, Ge = Ge + Math.imul(Dt, mr) | 0, ct = ct + Math.imul(Dt, Tr) | 0, pt = pt + Math.imul(zt, vr) | 0, Ge = Ge + Math.imul(zt, Rr) | 0, Ge = Ge + Math.imul(Kt, vr) | 0, ct = ct + Math.imul(Kt, Rr) | 0, pt = pt + Math.imul(qt, xr) | 0, Ge = Ge + Math.imul(qt, tr) | 0, Ge = Ge + Math.imul(Qt, xr) | 0, ct = ct + Math.imul(Qt, tr) | 0, pt = pt + Math.imul(St, fr) | 0, Ge = Ge + Math.imul(St, Mr) | 0, Ge = Ge + Math.imul(At, fr) | 0, ct = ct + Math.imul(At, Mr) | 0;
      var Pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, pt = Math.imul(jt, cr), Ge = Math.imul(jt, _r), Ge = Ge + Math.imul(Vt, cr) | 0, ct = Math.imul(Vt, _r), pt = pt + Math.imul(Bt, br) | 0, Ge = Ge + Math.imul(Bt, kr) | 0, Ge = Ge + Math.imul(kt, br) | 0, ct = ct + Math.imul(kt, kr) | 0, pt = pt + Math.imul(dr, yr) | 0, Ge = Ge + Math.imul(dr, Ir) | 0, Ge = Ge + Math.imul(gr, yr) | 0, ct = ct + Math.imul(gr, Ir) | 0, pt = pt + Math.imul(or, wr) | 0, Ge = Ge + Math.imul(or, Cr) | 0, Ge = Ge + Math.imul(lr, wr) | 0, ct = ct + Math.imul(lr, Cr) | 0, pt = pt + Math.imul(Jt, $r) | 0, Ge = Ge + Math.imul(Jt, Ar) | 0, Ge = Ge + Math.imul(ir, $r) | 0, ct = ct + Math.imul(ir, Ar) | 0, pt = pt + Math.imul(Gt, mr) | 0, Ge = Ge + Math.imul(Gt, Tr) | 0, Ge = Ge + Math.imul(rr, mr) | 0, ct = ct + Math.imul(rr, Tr) | 0, pt = pt + Math.imul(er, vr) | 0, Ge = Ge + Math.imul(er, Rr) | 0, Ge = Ge + Math.imul(Dt, vr) | 0, ct = ct + Math.imul(Dt, Rr) | 0, pt = pt + Math.imul(zt, xr) | 0, Ge = Ge + Math.imul(zt, tr) | 0, Ge = Ge + Math.imul(Kt, xr) | 0, ct = ct + Math.imul(Kt, tr) | 0, pt = pt + Math.imul(qt, fr) | 0, Ge = Ge + Math.imul(qt, Mr) | 0, Ge = Ge + Math.imul(Qt, fr) | 0, ct = ct + Math.imul(Qt, Mr) | 0;
      var Sr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, pt = Math.imul(jt, br), Ge = Math.imul(jt, kr), Ge = Ge + Math.imul(Vt, br) | 0, ct = Math.imul(Vt, kr), pt = pt + Math.imul(Bt, yr) | 0, Ge = Ge + Math.imul(Bt, Ir) | 0, Ge = Ge + Math.imul(kt, yr) | 0, ct = ct + Math.imul(kt, Ir) | 0, pt = pt + Math.imul(dr, wr) | 0, Ge = Ge + Math.imul(dr, Cr) | 0, Ge = Ge + Math.imul(gr, wr) | 0, ct = ct + Math.imul(gr, Cr) | 0, pt = pt + Math.imul(or, $r) | 0, Ge = Ge + Math.imul(or, Ar) | 0, Ge = Ge + Math.imul(lr, $r) | 0, ct = ct + Math.imul(lr, Ar) | 0, pt = pt + Math.imul(Jt, mr) | 0, Ge = Ge + Math.imul(Jt, Tr) | 0, Ge = Ge + Math.imul(ir, mr) | 0, ct = ct + Math.imul(ir, Tr) | 0, pt = pt + Math.imul(Gt, vr) | 0, Ge = Ge + Math.imul(Gt, Rr) | 0, Ge = Ge + Math.imul(rr, vr) | 0, ct = ct + Math.imul(rr, Rr) | 0, pt = pt + Math.imul(er, xr) | 0, Ge = Ge + Math.imul(er, tr) | 0, Ge = Ge + Math.imul(Dt, xr) | 0, ct = ct + Math.imul(Dt, tr) | 0, pt = pt + Math.imul(zt, fr) | 0, Ge = Ge + Math.imul(zt, Mr) | 0, Ge = Ge + Math.imul(Kt, fr) | 0, ct = ct + Math.imul(Kt, Mr) | 0;
      var Ur = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, pt = Math.imul(jt, yr), Ge = Math.imul(jt, Ir), Ge = Ge + Math.imul(Vt, yr) | 0, ct = Math.imul(Vt, Ir), pt = pt + Math.imul(Bt, wr) | 0, Ge = Ge + Math.imul(Bt, Cr) | 0, Ge = Ge + Math.imul(kt, wr) | 0, ct = ct + Math.imul(kt, Cr) | 0, pt = pt + Math.imul(dr, $r) | 0, Ge = Ge + Math.imul(dr, Ar) | 0, Ge = Ge + Math.imul(gr, $r) | 0, ct = ct + Math.imul(gr, Ar) | 0, pt = pt + Math.imul(or, mr) | 0, Ge = Ge + Math.imul(or, Tr) | 0, Ge = Ge + Math.imul(lr, mr) | 0, ct = ct + Math.imul(lr, Tr) | 0, pt = pt + Math.imul(Jt, vr) | 0, Ge = Ge + Math.imul(Jt, Rr) | 0, Ge = Ge + Math.imul(ir, vr) | 0, ct = ct + Math.imul(ir, Rr) | 0, pt = pt + Math.imul(Gt, xr) | 0, Ge = Ge + Math.imul(Gt, tr) | 0, Ge = Ge + Math.imul(rr, xr) | 0, ct = ct + Math.imul(rr, tr) | 0, pt = pt + Math.imul(er, fr) | 0, Ge = Ge + Math.imul(er, Mr) | 0, Ge = Ge + Math.imul(Dt, fr) | 0, ct = ct + Math.imul(Dt, Mr) | 0;
      var jr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, pt = Math.imul(jt, wr), Ge = Math.imul(jt, Cr), Ge = Ge + Math.imul(Vt, wr) | 0, ct = Math.imul(Vt, Cr), pt = pt + Math.imul(Bt, $r) | 0, Ge = Ge + Math.imul(Bt, Ar) | 0, Ge = Ge + Math.imul(kt, $r) | 0, ct = ct + Math.imul(kt, Ar) | 0, pt = pt + Math.imul(dr, mr) | 0, Ge = Ge + Math.imul(dr, Tr) | 0, Ge = Ge + Math.imul(gr, mr) | 0, ct = ct + Math.imul(gr, Tr) | 0, pt = pt + Math.imul(or, vr) | 0, Ge = Ge + Math.imul(or, Rr) | 0, Ge = Ge + Math.imul(lr, vr) | 0, ct = ct + Math.imul(lr, Rr) | 0, pt = pt + Math.imul(Jt, xr) | 0, Ge = Ge + Math.imul(Jt, tr) | 0, Ge = Ge + Math.imul(ir, xr) | 0, ct = ct + Math.imul(ir, tr) | 0, pt = pt + Math.imul(Gt, fr) | 0, Ge = Ge + Math.imul(Gt, Mr) | 0, Ge = Ge + Math.imul(rr, fr) | 0, ct = ct + Math.imul(rr, Mr) | 0;
      var Gr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, pt = Math.imul(jt, $r), Ge = Math.imul(jt, Ar), Ge = Ge + Math.imul(Vt, $r) | 0, ct = Math.imul(Vt, Ar), pt = pt + Math.imul(Bt, mr) | 0, Ge = Ge + Math.imul(Bt, Tr) | 0, Ge = Ge + Math.imul(kt, mr) | 0, ct = ct + Math.imul(kt, Tr) | 0, pt = pt + Math.imul(dr, vr) | 0, Ge = Ge + Math.imul(dr, Rr) | 0, Ge = Ge + Math.imul(gr, vr) | 0, ct = ct + Math.imul(gr, Rr) | 0, pt = pt + Math.imul(or, xr) | 0, Ge = Ge + Math.imul(or, tr) | 0, Ge = Ge + Math.imul(lr, xr) | 0, ct = ct + Math.imul(lr, tr) | 0, pt = pt + Math.imul(Jt, fr) | 0, Ge = Ge + Math.imul(Jt, Mr) | 0, Ge = Ge + Math.imul(ir, fr) | 0, ct = ct + Math.imul(ir, Mr) | 0;
      var Vr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, pt = Math.imul(jt, mr), Ge = Math.imul(jt, Tr), Ge = Ge + Math.imul(Vt, mr) | 0, ct = Math.imul(Vt, Tr), pt = pt + Math.imul(Bt, vr) | 0, Ge = Ge + Math.imul(Bt, Rr) | 0, Ge = Ge + Math.imul(kt, vr) | 0, ct = ct + Math.imul(kt, Rr) | 0, pt = pt + Math.imul(dr, xr) | 0, Ge = Ge + Math.imul(dr, tr) | 0, Ge = Ge + Math.imul(gr, xr) | 0, ct = ct + Math.imul(gr, tr) | 0, pt = pt + Math.imul(or, fr) | 0, Ge = Ge + Math.imul(or, Mr) | 0, Ge = Ge + Math.imul(lr, fr) | 0, ct = ct + Math.imul(lr, Mr) | 0;
      var rn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, pt = Math.imul(jt, vr), Ge = Math.imul(jt, Rr), Ge = Ge + Math.imul(Vt, vr) | 0, ct = Math.imul(Vt, Rr), pt = pt + Math.imul(Bt, xr) | 0, Ge = Ge + Math.imul(Bt, tr) | 0, Ge = Ge + Math.imul(kt, xr) | 0, ct = ct + Math.imul(kt, tr) | 0, pt = pt + Math.imul(dr, fr) | 0, Ge = Ge + Math.imul(dr, Mr) | 0, Ge = Ge + Math.imul(gr, fr) | 0, ct = ct + Math.imul(gr, Mr) | 0;
      var an = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, pt = Math.imul(jt, xr), Ge = Math.imul(jt, tr), Ge = Ge + Math.imul(Vt, xr) | 0, ct = Math.imul(Vt, tr), pt = pt + Math.imul(Bt, fr) | 0, Ge = Ge + Math.imul(Bt, Mr) | 0, Ge = Ge + Math.imul(kt, fr) | 0, ct = ct + Math.imul(kt, Mr) | 0;
      var ln = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, pt = Math.imul(jt, fr), Ge = Math.imul(jt, Mr), Ge = Ge + Math.imul(Vt, fr) | 0, ct = Math.imul(Vt, Mr);
      var sn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      return yt = (ct + (Ge >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, mt[0] = Fr, mt[1] = qr, mt[2] = tn, mt[3] = Qr, mt[4] = nn, mt[5] = Er, mt[6] = Wt, mt[7] = nr, mt[8] = pr, mt[9] = Pr, mt[10] = Sr, mt[11] = Ur, mt[12] = jr, mt[13] = Gr, mt[14] = Vr, mt[15] = rn, mt[16] = an, mt[17] = ln, mt[18] = sn, yt !== 0 && (mt[19] = yt, rt.length++), rt;
    };
    Math.imul || (wt = vt);
    function xt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative, Xe.length = gt.length + We.length;
      for (var rt = 0, ot = 0, ft = 0; ft < Xe.length - 1; ft++) {
        var mt = ot;
        ot = 0;
        for (var yt = rt & 67108863, pt = Math.min(ft, We.length - 1), Ge = Math.max(0, ft - gt.length + 1); Ge <= pt; Ge++) {
          var ct = ft - Ge, Mt = gt.words[ct] | 0, St = We.words[Ge] | 0, At = Mt * St, Nt = At & 67108863;
          mt = mt + (At / 67108864 | 0) | 0, Nt = Nt + yt | 0, yt = Nt & 67108863, mt = mt + (Nt >>> 26) | 0, ot += mt >>> 26, mt &= 67108863;
        }
        Xe.words[ft] = yt, rt = mt, mt = ot;
      }
      return rt !== 0 ? Xe.words[ft] = rt : Xe.length--, Xe.strip();
    }
    function Et(gt, We, Xe) {
      var rt = new Tt();
      return rt.mulp(gt, We, Xe);
    }
    Ve.prototype.mulTo = function(We, Xe) {
      var rt, ot = (this || _global$3$1).length + We.length;
      return (this || _global$3$1).length === 10 && We.length === 10 ? rt = wt(this || _global$3$1, We, Xe) : ot < 63 ? rt = vt(this || _global$3$1, We, Xe) : ot < 1024 ? rt = xt(this || _global$3$1, We, Xe) : rt = Et(this || _global$3$1, We, Xe), rt;
    };
    function Tt(gt, We) {
      (this || _global$3$1).x = gt, (this || _global$3$1).y = We;
    }
    Tt.prototype.makeRBT = function(We) {
      for (var Xe = new Array(We), rt = Ve.prototype._countBits(We) - 1, ot = 0; ot < We; ot++)
        Xe[ot] = this.revBin(ot, rt, We);
      return Xe;
    }, Tt.prototype.revBin = function(We, Xe, rt) {
      if (We === 0 || We === rt - 1)
        return We;
      for (var ot = 0, ft = 0; ft < Xe; ft++)
        ot |= (We & 1) << Xe - ft - 1, We >>= 1;
      return ot;
    }, Tt.prototype.permute = function(We, Xe, rt, ot, ft, mt) {
      for (var yt = 0; yt < mt; yt++)
        ot[yt] = Xe[We[yt]], ft[yt] = rt[We[yt]];
    }, Tt.prototype.transform = function(We, Xe, rt, ot, ft, mt) {
      this.permute(mt, We, Xe, rt, ot, ft);
      for (var yt = 1; yt < ft; yt <<= 1)
        for (var pt = yt << 1, Ge = Math.cos(2 * Math.PI / pt), ct = Math.sin(2 * Math.PI / pt), Mt = 0; Mt < ft; Mt += pt)
          for (var St = Ge, At = ct, Nt = 0; Nt < yt; Nt++) {
            var qt = rt[Mt + Nt], Qt = ot[Mt + Nt], Xt = rt[Mt + Nt + yt], zt = ot[Mt + Nt + yt], Kt = St * Xt - At * zt;
            zt = St * zt + At * Xt, Xt = Kt, rt[Mt + Nt] = qt + Xt, ot[Mt + Nt] = Qt + zt, rt[Mt + Nt + yt] = qt - Xt, ot[Mt + Nt + yt] = Qt - zt, Nt !== pt && (Kt = Ge * St - ct * At, At = Ge * At + ct * St, St = Kt);
          }
    }, Tt.prototype.guessLen13b = function(We, Xe) {
      var rt = Math.max(Xe, We) | 1, ot = rt & 1, ft = 0;
      for (rt = rt / 2 | 0; rt; rt = rt >>> 1)
        ft++;
      return 1 << ft + 1 + ot;
    }, Tt.prototype.conjugate = function(We, Xe, rt) {
      if (!(rt <= 1))
        for (var ot = 0; ot < rt / 2; ot++) {
          var ft = We[ot];
          We[ot] = We[rt - ot - 1], We[rt - ot - 1] = ft, ft = Xe[ot], Xe[ot] = -Xe[rt - ot - 1], Xe[rt - ot - 1] = -ft;
        }
    }, Tt.prototype.normalize13b = function(We, Xe) {
      for (var rt = 0, ot = 0; ot < Xe / 2; ot++) {
        var ft = Math.round(We[2 * ot + 1] / Xe) * 8192 + Math.round(We[2 * ot] / Xe) + rt;
        We[ot] = ft & 67108863, ft < 67108864 ? rt = 0 : rt = ft / 67108864 | 0;
      }
      return We;
    }, Tt.prototype.convert13b = function(We, Xe, rt, ot) {
      for (var ft = 0, mt = 0; mt < Xe; mt++)
        ft = ft + (We[mt] | 0), rt[2 * mt] = ft & 8191, ft = ft >>> 13, rt[2 * mt + 1] = ft & 8191, ft = ft >>> 13;
      for (mt = 2 * Xe; mt < ot; ++mt)
        rt[mt] = 0;
      Fe(ft === 0), Fe((ft & -8192) === 0);
    }, Tt.prototype.stub = function(We) {
      for (var Xe = new Array(We), rt = 0; rt < We; rt++)
        Xe[rt] = 0;
      return Xe;
    }, Tt.prototype.mulp = function(We, Xe, rt) {
      var ot = 2 * this.guessLen13b(We.length, Xe.length), ft = this.makeRBT(ot), mt = this.stub(ot), yt = new Array(ot), pt = new Array(ot), Ge = new Array(ot), ct = new Array(ot), Mt = new Array(ot), St = new Array(ot), At = rt.words;
      At.length = ot, this.convert13b(We.words, We.length, yt, ot), this.convert13b(Xe.words, Xe.length, ct, ot), this.transform(yt, mt, pt, Ge, ot, ft), this.transform(ct, mt, Mt, St, ot, ft);
      for (var Nt = 0; Nt < ot; Nt++) {
        var qt = pt[Nt] * Mt[Nt] - Ge[Nt] * St[Nt];
        Ge[Nt] = pt[Nt] * St[Nt] + Ge[Nt] * Mt[Nt], pt[Nt] = qt;
      }
      return this.conjugate(pt, Ge, ot), this.transform(pt, Ge, At, mt, ot, ft), this.conjugate(At, mt, ot), this.normalize13b(At, ot), rt.negative = We.negative ^ Xe.negative, rt.length = We.length + Xe.length, rt.strip();
    }, Ve.prototype.mul = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$3$1).length + We.length), this.mulTo(We, Xe);
    }, Ve.prototype.mulf = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$3$1).length + We.length), Et(this || _global$3$1, We, Xe);
    }, Ve.prototype.imul = function(We) {
      return this.clone().mulTo(We, this || _global$3$1);
    }, Ve.prototype.imuln = function(We) {
      Fe(typeof We == "number"), Fe(We < 67108864);
      for (var Xe = 0, rt = 0; rt < (this || _global$3$1).length; rt++) {
        var ot = ((this || _global$3$1).words[rt] | 0) * We, ft = (ot & 67108863) + (Xe & 67108863);
        Xe >>= 26, Xe += ot / 67108864 | 0, Xe += ft >>> 26, (this || _global$3$1).words[rt] = ft & 67108863;
      }
      return Xe !== 0 && ((this || _global$3$1).words[rt] = Xe, (this || _global$3$1).length++), this || _global$3$1;
    }, Ve.prototype.muln = function(We) {
      return this.clone().imuln(We);
    }, Ve.prototype.sqr = function() {
      return this.mul(this || _global$3$1);
    }, Ve.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Ve.prototype.pow = function(We) {
      var Xe = $t(We);
      if (Xe.length === 0)
        return new Ve(1);
      for (var rt = this || _global$3$1, ot = 0; ot < Xe.length && Xe[ot] === 0; ot++, rt = rt.sqr())
        ;
      if (++ot < Xe.length)
        for (var ft = rt.sqr(); ot < Xe.length; ot++, ft = ft.sqr())
          Xe[ot] !== 0 && (rt = rt.mul(ft));
      return rt;
    }, Ve.prototype.iushln = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 67108863 >>> 26 - Xe << 26 - Xe, ft;
      if (Xe !== 0) {
        var mt = 0;
        for (ft = 0; ft < (this || _global$3$1).length; ft++) {
          var yt = (this || _global$3$1).words[ft] & ot, pt = ((this || _global$3$1).words[ft] | 0) - yt << Xe;
          (this || _global$3$1).words[ft] = pt | mt, mt = yt >>> 26 - Xe;
        }
        mt && ((this || _global$3$1).words[ft] = mt, (this || _global$3$1).length++);
      }
      if (rt !== 0) {
        for (ft = (this || _global$3$1).length - 1; ft >= 0; ft--)
          (this || _global$3$1).words[ft + rt] = (this || _global$3$1).words[ft];
        for (ft = 0; ft < rt; ft++)
          (this || _global$3$1).words[ft] = 0;
        (this || _global$3$1).length += rt;
      }
      return this.strip();
    }, Ve.prototype.ishln = function(We) {
      return Fe((this || _global$3$1).negative === 0), this.iushln(We);
    }, Ve.prototype.iushrn = function(We, Xe, rt) {
      Fe(typeof We == "number" && We >= 0);
      var ot;
      Xe ? ot = (Xe - Xe % 26) / 26 : ot = 0;
      var ft = We % 26, mt = Math.min((We - ft) / 26, (this || _global$3$1).length), yt = 67108863 ^ 67108863 >>> ft << ft, pt = rt;
      if (ot -= mt, ot = Math.max(0, ot), pt) {
        for (var Ge = 0; Ge < mt; Ge++)
          pt.words[Ge] = (this || _global$3$1).words[Ge];
        pt.length = mt;
      }
      if (mt !== 0)
        if ((this || _global$3$1).length > mt)
          for ((this || _global$3$1).length -= mt, Ge = 0; Ge < (this || _global$3$1).length; Ge++)
            (this || _global$3$1).words[Ge] = (this || _global$3$1).words[Ge + mt];
        else
          (this || _global$3$1).words[0] = 0, (this || _global$3$1).length = 1;
      var ct = 0;
      for (Ge = (this || _global$3$1).length - 1; Ge >= 0 && (ct !== 0 || Ge >= ot); Ge--) {
        var Mt = (this || _global$3$1).words[Ge] | 0;
        (this || _global$3$1).words[Ge] = ct << 26 - ft | Mt >>> ft, ct = Mt & yt;
      }
      return pt && ct !== 0 && (pt.words[pt.length++] = ct), (this || _global$3$1).length === 0 && ((this || _global$3$1).words[0] = 0, (this || _global$3$1).length = 1), this.strip();
    }, Ve.prototype.ishrn = function(We, Xe, rt) {
      return Fe((this || _global$3$1).negative === 0), this.iushrn(We, Xe, rt);
    }, Ve.prototype.shln = function(We) {
      return this.clone().ishln(We);
    }, Ve.prototype.ushln = function(We) {
      return this.clone().iushln(We);
    }, Ve.prototype.shrn = function(We) {
      return this.clone().ishrn(We);
    }, Ve.prototype.ushrn = function(We) {
      return this.clone().iushrn(We);
    }, Ve.prototype.testn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$3$1).length <= rt)
        return !1;
      var ft = (this || _global$3$1).words[rt];
      return !!(ft & ot);
    }, Ve.prototype.imaskn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26;
      if (Fe((this || _global$3$1).negative === 0, "imaskn works only with positive numbers"), (this || _global$3$1).length <= rt)
        return this || _global$3$1;
      if (Xe !== 0 && rt++, (this || _global$3$1).length = Math.min(rt, (this || _global$3$1).length), Xe !== 0) {
        var ot = 67108863 ^ 67108863 >>> Xe << Xe;
        (this || _global$3$1).words[(this || _global$3$1).length - 1] &= ot;
      }
      return this.strip();
    }, Ve.prototype.maskn = function(We) {
      return this.clone().imaskn(We);
    }, Ve.prototype.iaddn = function(We) {
      return Fe(typeof We == "number"), Fe(We < 67108864), We < 0 ? this.isubn(-We) : (this || _global$3$1).negative !== 0 ? (this || _global$3$1).length === 1 && ((this || _global$3$1).words[0] | 0) < We ? ((this || _global$3$1).words[0] = We - ((this || _global$3$1).words[0] | 0), (this || _global$3$1).negative = 0, this || _global$3$1) : ((this || _global$3$1).negative = 0, this.isubn(We), (this || _global$3$1).negative = 1, this || _global$3$1) : this._iaddn(We);
    }, Ve.prototype._iaddn = function(We) {
      (this || _global$3$1).words[0] += We;
      for (var Xe = 0; Xe < (this || _global$3$1).length && (this || _global$3$1).words[Xe] >= 67108864; Xe++)
        (this || _global$3$1).words[Xe] -= 67108864, Xe === (this || _global$3$1).length - 1 ? (this || _global$3$1).words[Xe + 1] = 1 : (this || _global$3$1).words[Xe + 1]++;
      return (this || _global$3$1).length = Math.max((this || _global$3$1).length, Xe + 1), this || _global$3$1;
    }, Ve.prototype.isubn = function(We) {
      if (Fe(typeof We == "number"), Fe(We < 67108864), We < 0)
        return this.iaddn(-We);
      if ((this || _global$3$1).negative !== 0)
        return (this || _global$3$1).negative = 0, this.iaddn(We), (this || _global$3$1).negative = 1, this || _global$3$1;
      if ((this || _global$3$1).words[0] -= We, (this || _global$3$1).length === 1 && (this || _global$3$1).words[0] < 0)
        (this || _global$3$1).words[0] = -(this || _global$3$1).words[0], (this || _global$3$1).negative = 1;
      else
        for (var Xe = 0; Xe < (this || _global$3$1).length && (this || _global$3$1).words[Xe] < 0; Xe++)
          (this || _global$3$1).words[Xe] += 67108864, (this || _global$3$1).words[Xe + 1] -= 1;
      return this.strip();
    }, Ve.prototype.addn = function(We) {
      return this.clone().iaddn(We);
    }, Ve.prototype.subn = function(We) {
      return this.clone().isubn(We);
    }, Ve.prototype.iabs = function() {
      return (this || _global$3$1).negative = 0, this || _global$3$1;
    }, Ve.prototype.abs = function() {
      return this.clone().iabs();
    }, Ve.prototype._ishlnsubmul = function(We, Xe, rt) {
      var ot = We.length + rt, ft;
      this._expand(ot);
      var mt, yt = 0;
      for (ft = 0; ft < We.length; ft++) {
        mt = ((this || _global$3$1).words[ft + rt] | 0) + yt;
        var pt = (We.words[ft] | 0) * Xe;
        mt -= pt & 67108863, yt = (mt >> 26) - (pt / 67108864 | 0), (this || _global$3$1).words[ft + rt] = mt & 67108863;
      }
      for (; ft < (this || _global$3$1).length - rt; ft++)
        mt = ((this || _global$3$1).words[ft + rt] | 0) + yt, yt = mt >> 26, (this || _global$3$1).words[ft + rt] = mt & 67108863;
      if (yt === 0)
        return this.strip();
      for (Fe(yt === -1), yt = 0, ft = 0; ft < (this || _global$3$1).length; ft++)
        mt = -((this || _global$3$1).words[ft] | 0) + yt, yt = mt >> 26, (this || _global$3$1).words[ft] = mt & 67108863;
      return (this || _global$3$1).negative = 1, this.strip();
    }, Ve.prototype._wordDiv = function(We, Xe) {
      var rt = (this || _global$3$1).length - We.length, ot = this.clone(), ft = We, mt = ft.words[ft.length - 1] | 0, yt = this._countBits(mt);
      rt = 26 - yt, rt !== 0 && (ft = ft.ushln(rt), ot.iushln(rt), mt = ft.words[ft.length - 1] | 0);
      var pt = ot.length - ft.length, Ge;
      if (Xe !== "mod") {
        Ge = new Ve(null), Ge.length = pt + 1, Ge.words = new Array(Ge.length);
        for (var ct = 0; ct < Ge.length; ct++)
          Ge.words[ct] = 0;
      }
      var Mt = ot.clone()._ishlnsubmul(ft, 1, pt);
      Mt.negative === 0 && (ot = Mt, Ge && (Ge.words[pt] = 1));
      for (var St = pt - 1; St >= 0; St--) {
        var At = (ot.words[ft.length + St] | 0) * 67108864 + (ot.words[ft.length + St - 1] | 0);
        for (At = Math.min(At / mt | 0, 67108863), ot._ishlnsubmul(ft, At, St); ot.negative !== 0; )
          At--, ot.negative = 0, ot._ishlnsubmul(ft, 1, St), ot.isZero() || (ot.negative ^= 1);
        Ge && (Ge.words[St] = At);
      }
      return Ge && Ge.strip(), ot.strip(), Xe !== "div" && rt !== 0 && ot.iushrn(rt), {
        div: Ge || null,
        mod: ot
      };
    }, Ve.prototype.divmod = function(We, Xe, rt) {
      if (Fe(!We.isZero()), this.isZero())
        return {
          div: new Ve(0),
          mod: new Ve(0)
        };
      var ot, ft, mt;
      return (this || _global$3$1).negative !== 0 && We.negative === 0 ? (mt = this.neg().divmod(We, Xe), Xe !== "mod" && (ot = mt.div.neg()), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.iadd(We)), {
        div: ot,
        mod: ft
      }) : (this || _global$3$1).negative === 0 && We.negative !== 0 ? (mt = this.divmod(We.neg(), Xe), Xe !== "mod" && (ot = mt.div.neg()), {
        div: ot,
        mod: mt.mod
      }) : (this || _global$3$1).negative & We.negative ? (mt = this.neg().divmod(We.neg(), Xe), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.isub(We)), {
        div: mt.div,
        mod: ft
      }) : We.length > (this || _global$3$1).length || this.cmp(We) < 0 ? {
        div: new Ve(0),
        mod: this || _global$3$1
      } : We.length === 1 ? Xe === "div" ? {
        div: this.divn(We.words[0]),
        mod: null
      } : Xe === "mod" ? {
        div: null,
        mod: new Ve(this.modn(We.words[0]))
      } : {
        div: this.divn(We.words[0]),
        mod: new Ve(this.modn(We.words[0]))
      } : this._wordDiv(We, Xe);
    }, Ve.prototype.div = function(We) {
      return this.divmod(We, "div", !1).div;
    }, Ve.prototype.mod = function(We) {
      return this.divmod(We, "mod", !1).mod;
    }, Ve.prototype.umod = function(We) {
      return this.divmod(We, "mod", !0).mod;
    }, Ve.prototype.divRound = function(We) {
      var Xe = this.divmod(We);
      if (Xe.mod.isZero())
        return Xe.div;
      var rt = Xe.div.negative !== 0 ? Xe.mod.isub(We) : Xe.mod, ot = We.ushrn(1), ft = We.andln(1), mt = rt.cmp(ot);
      return mt < 0 || ft === 1 && mt === 0 ? Xe.div : Xe.div.negative !== 0 ? Xe.div.isubn(1) : Xe.div.iaddn(1);
    }, Ve.prototype.modn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = (1 << 26) % We, rt = 0, ot = (this || _global$3$1).length - 1; ot >= 0; ot--)
        rt = (Xe * rt + ((this || _global$3$1).words[ot] | 0)) % We;
      return rt;
    }, Ve.prototype.idivn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = 0, rt = (this || _global$3$1).length - 1; rt >= 0; rt--) {
        var ot = ((this || _global$3$1).words[rt] | 0) + Xe * 67108864;
        (this || _global$3$1).words[rt] = ot / We | 0, Xe = ot % We;
      }
      return this.strip();
    }, Ve.prototype.divn = function(We) {
      return this.clone().idivn(We);
    }, Ve.prototype.egcd = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$3$1, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = new Ve(0), yt = new Ve(1), pt = 0; Xe.isEven() && rt.isEven(); )
        Xe.iushrn(1), rt.iushrn(1), ++pt;
      for (var Ge = rt.clone(), ct = Xe.clone(); !Xe.isZero(); ) {
        for (var Mt = 0, St = 1; !(Xe.words[0] & St) && Mt < 26; ++Mt, St <<= 1)
          ;
        if (Mt > 0)
          for (Xe.iushrn(Mt); Mt-- > 0; )
            (ot.isOdd() || ft.isOdd()) && (ot.iadd(Ge), ft.isub(ct)), ot.iushrn(1), ft.iushrn(1);
        for (var At = 0, Nt = 1; !(rt.words[0] & Nt) && At < 26; ++At, Nt <<= 1)
          ;
        if (At > 0)
          for (rt.iushrn(At); At-- > 0; )
            (mt.isOdd() || yt.isOdd()) && (mt.iadd(Ge), yt.isub(ct)), mt.iushrn(1), yt.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(mt), ft.isub(yt)) : (rt.isub(Xe), mt.isub(ot), yt.isub(ft));
      }
      return {
        a: mt,
        b: yt,
        gcd: rt.iushln(pt)
      };
    }, Ve.prototype._invmp = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$3$1, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = rt.clone(); Xe.cmpn(1) > 0 && rt.cmpn(1) > 0; ) {
        for (var yt = 0, pt = 1; !(Xe.words[0] & pt) && yt < 26; ++yt, pt <<= 1)
          ;
        if (yt > 0)
          for (Xe.iushrn(yt); yt-- > 0; )
            ot.isOdd() && ot.iadd(mt), ot.iushrn(1);
        for (var Ge = 0, ct = 1; !(rt.words[0] & ct) && Ge < 26; ++Ge, ct <<= 1)
          ;
        if (Ge > 0)
          for (rt.iushrn(Ge); Ge-- > 0; )
            ft.isOdd() && ft.iadd(mt), ft.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(ft)) : (rt.isub(Xe), ft.isub(ot));
      }
      var Mt;
      return Xe.cmpn(1) === 0 ? Mt = ot : Mt = ft, Mt.cmpn(0) < 0 && Mt.iadd(We), Mt;
    }, Ve.prototype.gcd = function(We) {
      if (this.isZero())
        return We.abs();
      if (We.isZero())
        return this.abs();
      var Xe = this.clone(), rt = We.clone();
      Xe.negative = 0, rt.negative = 0;
      for (var ot = 0; Xe.isEven() && rt.isEven(); ot++)
        Xe.iushrn(1), rt.iushrn(1);
      do {
        for (; Xe.isEven(); )
          Xe.iushrn(1);
        for (; rt.isEven(); )
          rt.iushrn(1);
        var ft = Xe.cmp(rt);
        if (ft < 0) {
          var mt = Xe;
          Xe = rt, rt = mt;
        } else if (ft === 0 || rt.cmpn(1) === 0)
          break;
        Xe.isub(rt);
      } while (!0);
      return rt.iushln(ot);
    }, Ve.prototype.invm = function(We) {
      return this.egcd(We).a.umod(We);
    }, Ve.prototype.isEven = function() {
      return ((this || _global$3$1).words[0] & 1) === 0;
    }, Ve.prototype.isOdd = function() {
      return ((this || _global$3$1).words[0] & 1) === 1;
    }, Ve.prototype.andln = function(We) {
      return (this || _global$3$1).words[0] & We;
    }, Ve.prototype.bincn = function(We) {
      Fe(typeof We == "number");
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$3$1).length <= rt)
        return this._expand(rt + 1), (this || _global$3$1).words[rt] |= ot, this || _global$3$1;
      for (var ft = ot, mt = rt; ft !== 0 && mt < (this || _global$3$1).length; mt++) {
        var yt = (this || _global$3$1).words[mt] | 0;
        yt += ft, ft = yt >>> 26, yt &= 67108863, (this || _global$3$1).words[mt] = yt;
      }
      return ft !== 0 && ((this || _global$3$1).words[mt] = ft, (this || _global$3$1).length++), this || _global$3$1;
    }, Ve.prototype.isZero = function() {
      return (this || _global$3$1).length === 1 && (this || _global$3$1).words[0] === 0;
    }, Ve.prototype.cmpn = function(We) {
      var Xe = We < 0;
      if ((this || _global$3$1).negative !== 0 && !Xe)
        return -1;
      if ((this || _global$3$1).negative === 0 && Xe)
        return 1;
      this.strip();
      var rt;
      if ((this || _global$3$1).length > 1)
        rt = 1;
      else {
        Xe && (We = -We), Fe(We <= 67108863, "Number is too big");
        var ot = (this || _global$3$1).words[0] | 0;
        rt = ot === We ? 0 : ot < We ? -1 : 1;
      }
      return (this || _global$3$1).negative !== 0 ? -rt | 0 : rt;
    }, Ve.prototype.cmp = function(We) {
      if ((this || _global$3$1).negative !== 0 && We.negative === 0)
        return -1;
      if ((this || _global$3$1).negative === 0 && We.negative !== 0)
        return 1;
      var Xe = this.ucmp(We);
      return (this || _global$3$1).negative !== 0 ? -Xe | 0 : Xe;
    }, Ve.prototype.ucmp = function(We) {
      if ((this || _global$3$1).length > We.length)
        return 1;
      if ((this || _global$3$1).length < We.length)
        return -1;
      for (var Xe = 0, rt = (this || _global$3$1).length - 1; rt >= 0; rt--) {
        var ot = (this || _global$3$1).words[rt] | 0, ft = We.words[rt] | 0;
        if (ot !== ft) {
          ot < ft ? Xe = -1 : ot > ft && (Xe = 1);
          break;
        }
      }
      return Xe;
    }, Ve.prototype.gtn = function(We) {
      return this.cmpn(We) === 1;
    }, Ve.prototype.gt = function(We) {
      return this.cmp(We) === 1;
    }, Ve.prototype.gten = function(We) {
      return this.cmpn(We) >= 0;
    }, Ve.prototype.gte = function(We) {
      return this.cmp(We) >= 0;
    }, Ve.prototype.ltn = function(We) {
      return this.cmpn(We) === -1;
    }, Ve.prototype.lt = function(We) {
      return this.cmp(We) === -1;
    }, Ve.prototype.lten = function(We) {
      return this.cmpn(We) <= 0;
    }, Ve.prototype.lte = function(We) {
      return this.cmp(We) <= 0;
    }, Ve.prototype.eqn = function(We) {
      return this.cmpn(We) === 0;
    }, Ve.prototype.eq = function(We) {
      return this.cmp(We) === 0;
    }, Ve.red = function(We) {
      return new Ot(We);
    }, Ve.prototype.toRed = function(We) {
      return Fe(!(this || _global$3$1).red, "Already a number in reduction context"), Fe((this || _global$3$1).negative === 0, "red works only with positives"), We.convertTo(this || _global$3$1)._forceRed(We);
    }, Ve.prototype.fromRed = function() {
      return Fe((this || _global$3$1).red, "fromRed works only with numbers in reduction context"), (this || _global$3$1).red.convertFrom(this || _global$3$1);
    }, Ve.prototype._forceRed = function(We) {
      return (this || _global$3$1).red = We, this || _global$3$1;
    }, Ve.prototype.forceRed = function(We) {
      return Fe(!(this || _global$3$1).red, "Already a number in reduction context"), this._forceRed(We);
    }, Ve.prototype.redAdd = function(We) {
      return Fe((this || _global$3$1).red, "redAdd works only with red numbers"), (this || _global$3$1).red.add(this || _global$3$1, We);
    }, Ve.prototype.redIAdd = function(We) {
      return Fe((this || _global$3$1).red, "redIAdd works only with red numbers"), (this || _global$3$1).red.iadd(this || _global$3$1, We);
    }, Ve.prototype.redSub = function(We) {
      return Fe((this || _global$3$1).red, "redSub works only with red numbers"), (this || _global$3$1).red.sub(this || _global$3$1, We);
    }, Ve.prototype.redISub = function(We) {
      return Fe((this || _global$3$1).red, "redISub works only with red numbers"), (this || _global$3$1).red.isub(this || _global$3$1, We);
    }, Ve.prototype.redShl = function(We) {
      return Fe((this || _global$3$1).red, "redShl works only with red numbers"), (this || _global$3$1).red.shl(this || _global$3$1, We);
    }, Ve.prototype.redMul = function(We) {
      return Fe((this || _global$3$1).red, "redMul works only with red numbers"), (this || _global$3$1).red._verify2(this || _global$3$1, We), (this || _global$3$1).red.mul(this || _global$3$1, We);
    }, Ve.prototype.redIMul = function(We) {
      return Fe((this || _global$3$1).red, "redMul works only with red numbers"), (this || _global$3$1).red._verify2(this || _global$3$1, We), (this || _global$3$1).red.imul(this || _global$3$1, We);
    }, Ve.prototype.redSqr = function() {
      return Fe((this || _global$3$1).red, "redSqr works only with red numbers"), (this || _global$3$1).red._verify1(this || _global$3$1), (this || _global$3$1).red.sqr(this || _global$3$1);
    }, Ve.prototype.redISqr = function() {
      return Fe((this || _global$3$1).red, "redISqr works only with red numbers"), (this || _global$3$1).red._verify1(this || _global$3$1), (this || _global$3$1).red.isqr(this || _global$3$1);
    }, Ve.prototype.redSqrt = function() {
      return Fe((this || _global$3$1).red, "redSqrt works only with red numbers"), (this || _global$3$1).red._verify1(this || _global$3$1), (this || _global$3$1).red.sqrt(this || _global$3$1);
    }, Ve.prototype.redInvm = function() {
      return Fe((this || _global$3$1).red, "redInvm works only with red numbers"), (this || _global$3$1).red._verify1(this || _global$3$1), (this || _global$3$1).red.invm(this || _global$3$1);
    }, Ve.prototype.redNeg = function() {
      return Fe((this || _global$3$1).red, "redNeg works only with red numbers"), (this || _global$3$1).red._verify1(this || _global$3$1), (this || _global$3$1).red.neg(this || _global$3$1);
    }, Ve.prototype.redPow = function(We) {
      return Fe((this || _global$3$1).red && !We.red, "redPow(normalNum)"), (this || _global$3$1).red._verify1(this || _global$3$1), (this || _global$3$1).red.pow(this || _global$3$1, We);
    };
    var Rt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ct(gt, We) {
      (this || _global$3$1).name = gt, (this || _global$3$1).p = new Ve(We, 16), (this || _global$3$1).n = (this || _global$3$1).p.bitLength(), (this || _global$3$1).k = new Ve(1).iushln((this || _global$3$1).n).isub((this || _global$3$1).p), (this || _global$3$1).tmp = this._tmp();
    }
    Ct.prototype._tmp = function() {
      var We = new Ve(null);
      return We.words = new Array(Math.ceil((this || _global$3$1).n / 13)), We;
    }, Ct.prototype.ireduce = function(We) {
      var Xe = We, rt;
      do
        this.split(Xe, (this || _global$3$1).tmp), Xe = this.imulK(Xe), Xe = Xe.iadd((this || _global$3$1).tmp), rt = Xe.bitLength();
      while (rt > (this || _global$3$1).n);
      var ot = rt < (this || _global$3$1).n ? -1 : Xe.ucmp((this || _global$3$1).p);
      return ot === 0 ? (Xe.words[0] = 0, Xe.length = 1) : ot > 0 ? Xe.isub((this || _global$3$1).p) : Xe.strip !== void 0 ? Xe.strip() : Xe._strip(), Xe;
    }, Ct.prototype.split = function(We, Xe) {
      We.iushrn((this || _global$3$1).n, 0, Xe);
    }, Ct.prototype.imulK = function(We) {
      return We.imul((this || _global$3$1).k);
    };
    function Zt() {
      Ct.call(this || _global$3$1, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    Ke(Zt, Ct), Zt.prototype.split = function(We, Xe) {
      for (var rt = 4194303, ot = Math.min(We.length, 9), ft = 0; ft < ot; ft++)
        Xe.words[ft] = We.words[ft];
      if (Xe.length = ot, We.length <= 9) {
        We.words[0] = 0, We.length = 1;
        return;
      }
      var mt = We.words[9];
      for (Xe.words[Xe.length++] = mt & rt, ft = 10; ft < We.length; ft++) {
        var yt = We.words[ft] | 0;
        We.words[ft - 10] = (yt & rt) << 4 | mt >>> 22, mt = yt;
      }
      mt >>>= 22, We.words[ft - 10] = mt, mt === 0 && We.length > 10 ? We.length -= 10 : We.length -= 9;
    }, Zt.prototype.imulK = function(We) {
      We.words[We.length] = 0, We.words[We.length + 1] = 0, We.length += 2;
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = We.words[rt] | 0;
        Xe += ot * 977, We.words[rt] = Xe & 67108863, Xe = ot * 64 + (Xe / 67108864 | 0);
      }
      return We.words[We.length - 1] === 0 && (We.length--, We.words[We.length - 1] === 0 && We.length--), We;
    };
    function Lt() {
      Ct.call(this || _global$3$1, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    Ke(Lt, Ct);
    function Ut() {
      Ct.call(this || _global$3$1, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    Ke(Ut, Ct);
    function Pt() {
      Ct.call(this || _global$3$1, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    Ke(Pt, Ct), Pt.prototype.imulK = function(We) {
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = (We.words[rt] | 0) * 19 + Xe, ft = ot & 67108863;
        ot >>>= 26, We.words[rt] = ft, Xe = ot;
      }
      return Xe !== 0 && (We.words[We.length++] = Xe), We;
    }, Ve._prime = function(We) {
      if (Rt[We])
        return Rt[We];
      var Xe;
      if (We === "k256")
        Xe = new Zt();
      else if (We === "p224")
        Xe = new Lt();
      else if (We === "p192")
        Xe = new Ut();
      else if (We === "p25519")
        Xe = new Pt();
      else
        throw new Error("Unknown prime " + We);
      return Rt[We] = Xe, Xe;
    };
    function Ot(gt) {
      if (typeof gt == "string") {
        var We = Ve._prime(gt);
        (this || _global$3$1).m = We.p, (this || _global$3$1).prime = We;
      } else
        Fe(gt.gtn(1), "modulus must be greater than 1"), (this || _global$3$1).m = gt, (this || _global$3$1).prime = null;
    }
    Ot.prototype._verify1 = function(We) {
      Fe(We.negative === 0, "red works only with positives"), Fe(We.red, "red works only with red numbers");
    }, Ot.prototype._verify2 = function(We, Xe) {
      Fe((We.negative | Xe.negative) === 0, "red works only with positives"), Fe(We.red && We.red === Xe.red, "red works only with red numbers");
    }, Ot.prototype.imod = function(We) {
      return (this || _global$3$1).prime ? (this || _global$3$1).prime.ireduce(We)._forceRed(this || _global$3$1) : We.umod((this || _global$3$1).m)._forceRed(this || _global$3$1);
    }, Ot.prototype.neg = function(We) {
      return We.isZero() ? We.clone() : (this || _global$3$1).m.sub(We)._forceRed(this || _global$3$1);
    }, Ot.prototype.add = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.add(Xe);
      return rt.cmp((this || _global$3$1).m) >= 0 && rt.isub((this || _global$3$1).m), rt._forceRed(this || _global$3$1);
    }, Ot.prototype.iadd = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.iadd(Xe);
      return rt.cmp((this || _global$3$1).m) >= 0 && rt.isub((this || _global$3$1).m), rt;
    }, Ot.prototype.sub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.sub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$3$1).m), rt._forceRed(this || _global$3$1);
    }, Ot.prototype.isub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.isub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$3$1).m), rt;
    }, Ot.prototype.shl = function(We, Xe) {
      return this._verify1(We), this.imod(We.ushln(Xe));
    }, Ot.prototype.imul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.imul(Xe));
    }, Ot.prototype.mul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.mul(Xe));
    }, Ot.prototype.isqr = function(We) {
      return this.imul(We, We.clone());
    }, Ot.prototype.sqr = function(We) {
      return this.mul(We, We);
    }, Ot.prototype.sqrt = function(We) {
      if (We.isZero())
        return We.clone();
      var Xe = (this || _global$3$1).m.andln(3);
      if (Fe(Xe % 2 === 1), Xe === 3) {
        var rt = (this || _global$3$1).m.add(new Ve(1)).iushrn(2);
        return this.pow(We, rt);
      }
      for (var ot = (this || _global$3$1).m.subn(1), ft = 0; !ot.isZero() && ot.andln(1) === 0; )
        ft++, ot.iushrn(1);
      Fe(!ot.isZero());
      var mt = new Ve(1).toRed(this || _global$3$1), yt = mt.redNeg(), pt = (this || _global$3$1).m.subn(1).iushrn(1), Ge = (this || _global$3$1).m.bitLength();
      for (Ge = new Ve(2 * Ge * Ge).toRed(this || _global$3$1); this.pow(Ge, pt).cmp(yt) !== 0; )
        Ge.redIAdd(yt);
      for (var ct = this.pow(Ge, ot), Mt = this.pow(We, ot.addn(1).iushrn(1)), St = this.pow(We, ot), At = ft; St.cmp(mt) !== 0; ) {
        for (var Nt = St, qt = 0; Nt.cmp(mt) !== 0; qt++)
          Nt = Nt.redSqr();
        Fe(qt < At);
        var Qt = this.pow(ct, new Ve(1).iushln(At - qt - 1));
        Mt = Mt.redMul(Qt), ct = Qt.redSqr(), St = St.redMul(ct), At = qt;
      }
      return Mt;
    }, Ot.prototype.invm = function(We) {
      var Xe = We._invmp((this || _global$3$1).m);
      return Xe.negative !== 0 ? (Xe.negative = 0, this.imod(Xe).redNeg()) : this.imod(Xe);
    }, Ot.prototype.pow = function(We, Xe) {
      if (Xe.isZero())
        return new Ve(1).toRed(this || _global$3$1);
      if (Xe.cmpn(1) === 0)
        return We.clone();
      var rt = 4, ot = new Array(1 << rt);
      ot[0] = new Ve(1).toRed(this || _global$3$1), ot[1] = We;
      for (var ft = 2; ft < ot.length; ft++)
        ot[ft] = this.mul(ot[ft - 1], We);
      var mt = ot[0], yt = 0, pt = 0, Ge = Xe.bitLength() % 26;
      for (Ge === 0 && (Ge = 26), ft = Xe.length - 1; ft >= 0; ft--) {
        for (var ct = Xe.words[ft], Mt = Ge - 1; Mt >= 0; Mt--) {
          var St = ct >> Mt & 1;
          if (mt !== ot[0] && (mt = this.sqr(mt)), St === 0 && yt === 0) {
            pt = 0;
            continue;
          }
          yt <<= 1, yt |= St, pt++, !(pt !== rt && (ft !== 0 || Mt !== 0)) && (mt = this.mul(mt, ot[yt]), pt = 0, yt = 0);
        }
        Ge = 26;
      }
      return mt;
    }, Ot.prototype.convertTo = function(We) {
      var Xe = We.umod((this || _global$3$1).m);
      return Xe === We ? Xe.clone() : Xe;
    }, Ot.prototype.convertFrom = function(We) {
      var Xe = We.clone();
      return Xe.red = null, Xe;
    }, Ve.mont = function(We) {
      return new Ft(We);
    };
    function Ft(gt) {
      Ot.call(this || _global$3$1, gt), (this || _global$3$1).shift = (this || _global$3$1).m.bitLength(), (this || _global$3$1).shift % 26 !== 0 && ((this || _global$3$1).shift += 26 - (this || _global$3$1).shift % 26), (this || _global$3$1).r = new Ve(1).iushln((this || _global$3$1).shift), (this || _global$3$1).r2 = this.imod((this || _global$3$1).r.sqr()), (this || _global$3$1).rinv = (this || _global$3$1).r._invmp((this || _global$3$1).m), (this || _global$3$1).minv = (this || _global$3$1).rinv.mul((this || _global$3$1).r).isubn(1).div((this || _global$3$1).m), (this || _global$3$1).minv = (this || _global$3$1).minv.umod((this || _global$3$1).r), (this || _global$3$1).minv = (this || _global$3$1).r.sub((this || _global$3$1).minv);
    }
    Ke(Ft, Ot), Ft.prototype.convertTo = function(We) {
      return this.imod(We.ushln((this || _global$3$1).shift));
    }, Ft.prototype.convertFrom = function(We) {
      var Xe = this.imod(We.mul((this || _global$3$1).rinv));
      return Xe.red = null, Xe;
    }, Ft.prototype.imul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return We.words[0] = 0, We.length = 1, We;
      var rt = We.imul(Xe), ot = rt.maskn((this || _global$3$1).shift).mul((this || _global$3$1).minv).imaskn((this || _global$3$1).shift).mul((this || _global$3$1).m), ft = rt.isub(ot).iushrn((this || _global$3$1).shift), mt = ft;
      return ft.cmp((this || _global$3$1).m) >= 0 ? mt = ft.isub((this || _global$3$1).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$3$1).m)), mt._forceRed(this || _global$3$1);
    }, Ft.prototype.mul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return new Ve(0)._forceRed(this || _global$3$1);
      var rt = We.mul(Xe), ot = rt.maskn((this || _global$3$1).shift).mul((this || _global$3$1).minv).imaskn((this || _global$3$1).shift).mul((this || _global$3$1).m), ft = rt.isub(ot).iushrn((this || _global$3$1).shift), mt = ft;
      return ft.cmp((this || _global$3$1).m) >= 0 ? mt = ft.isub((this || _global$3$1).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$3$1).m)), mt._forceRed(this || _global$3$1);
    }, Ft.prototype.invm = function(We) {
      var Xe = this.imod(We._invmp((this || _global$3$1).m).mul((this || _global$3$1).r2));
      return Xe._forceRed(this || _global$3$1);
    };
  }(module$1$1, exports$a$1)), module$1$1.exports;
}
var exports$9$1 = {}, _dewExec$9$1 = !1, _global$2$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$9$1() {
  if (_dewExec$9$1)
    return exports$9$1;
  _dewExec$9$1 = !0;
  var $e = e$1$1$1.Buffer, Ze = dew$y$1(), Fe = dew$a$1();
  exports$9$1 = function(at) {
    return new Ve(at);
  };
  var Ke = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  Ke.p224 = Ke.secp224r1, Ke.p256 = Ke.secp256r1 = Ke.prime256v1, Ke.p192 = Ke.secp192r1 = Ke.prime192v1, Ke.p384 = Ke.secp384r1, Ke.p521 = Ke.secp521r1;
  function Ve(Qe) {
    (this || _global$2$1).curveType = Ke[Qe], (this || _global$2$1).curveType || ((this || _global$2$1).curveType = {
      name: Qe
    }), (this || _global$2$1).curve = new Ze.ec((this || _global$2$1).curveType.name), (this || _global$2$1).keys = void 0;
  }
  Ve.prototype.generateKeys = function(Qe, at) {
    return (this || _global$2$1).keys = (this || _global$2$1).curve.genKeyPair(), this.getPublicKey(Qe, at);
  }, Ve.prototype.computeSecret = function(Qe, at, ut) {
    at = at || "utf8", $e.isBuffer(Qe) || (Qe = new $e(Qe, at));
    var lt = (this || _global$2$1).curve.keyFromPublic(Qe).getPublic(), dt = lt.mul((this || _global$2$1).keys.getPrivate()).getX();
    return Je(dt, ut, (this || _global$2$1).curveType.byteLength);
  }, Ve.prototype.getPublicKey = function(Qe, at) {
    var ut = (this || _global$2$1).keys.getPublic(at === "compressed", !0);
    return at === "hybrid" && (ut[ut.length - 1] % 2 ? ut[0] = 7 : ut[0] = 6), Je(ut, Qe);
  }, Ve.prototype.getPrivateKey = function(Qe) {
    return Je((this || _global$2$1).keys.getPrivate(), Qe);
  }, Ve.prototype.setPublicKey = function(Qe, at) {
    return at = at || "utf8", $e.isBuffer(Qe) || (Qe = new $e(Qe, at)), (this || _global$2$1).keys._importPublic(Qe), this || _global$2$1;
  }, Ve.prototype.setPrivateKey = function(Qe, at) {
    at = at || "utf8", $e.isBuffer(Qe) || (Qe = new $e(Qe, at));
    var ut = new Fe(Qe);
    return ut = ut.toString(16), (this || _global$2$1).keys = (this || _global$2$1).curve.genKeyPair(), (this || _global$2$1).keys._importPrivate(ut), this || _global$2$1;
  };
  function Je(Qe, at, ut) {
    Array.isArray(Qe) || (Qe = Qe.toArray());
    var lt = new $e(Qe);
    if (ut && lt.length < ut) {
      var dt = new $e(ut - lt.length);
      dt.fill(0), lt = $e.concat([dt, lt]);
    }
    return at ? lt.toString(at) : lt;
  }
  return exports$9$1;
}
var exports$8$1 = {}, _dewExec$8$1 = !1;
function dew$8$1() {
  if (_dewExec$8$1)
    return exports$8$1;
  _dewExec$8$1 = !0;
  var $e = dew$1F(), Ze = dew$1T().Buffer;
  exports$8$1 = function(Ke, Ve) {
    for (var Je = Ze.alloc(0), Qe = 0, at; Je.length < Ve; )
      at = Fe(Qe++), Je = Ze.concat([Je, $e("sha1").update(Ke).update(at).digest()]);
    return Je.slice(0, Ve);
  };
  function Fe(Ke) {
    var Ve = Ze.allocUnsafe(4);
    return Ve.writeUInt32BE(Ke, 0), Ve;
  }
  return exports$8$1;
}
var exports$7$1 = {}, _dewExec$7$1 = !1;
function dew$7$1() {
  return _dewExec$7$1 || (_dewExec$7$1 = !0, exports$7$1 = function(Ze, Fe) {
    for (var Ke = Ze.length, Ve = -1; ++Ve < Ke; )
      Ze[Ve] ^= Fe[Ve];
    return Ze;
  }), exports$7$1;
}
var exports$6$1 = {}, _dewExec$6$1 = !1, module$8 = {
  exports: exports$6$1
}, _global$1$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$6$1() {
  return _dewExec$6$1 || (_dewExec$6$1 = !0, function($e, Ze) {
    function Fe(gt, We) {
      if (!gt)
        throw new Error(We || "Assertion failed");
    }
    function Ke(gt, We) {
      gt.super_ = We;
      var Xe = function() {
      };
      Xe.prototype = We.prototype, gt.prototype = new Xe(), gt.prototype.constructor = gt;
    }
    function Ve(gt, We, Xe) {
      if (Ve.isBN(gt))
        return gt;
      (this || _global$1$1).negative = 0, (this || _global$1$1).words = null, (this || _global$1$1).length = 0, (this || _global$1$1).red = null, gt !== null && ((We === "le" || We === "be") && (Xe = We, We = 10), this._init(gt || 0, We || 10, Xe || "be"));
    }
    typeof $e == "object" ? $e.exports = Ve : Ze.BN = Ve, Ve.BN = Ve, Ve.wordSize = 26;
    var Je;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Je = window.Buffer : Je = e$1$1$1.Buffer;
    } catch {
    }
    Ve.isBN = function(We) {
      return We instanceof Ve ? !0 : We !== null && typeof We == "object" && We.constructor.wordSize === Ve.wordSize && Array.isArray(We.words);
    }, Ve.max = function(We, Xe) {
      return We.cmp(Xe) > 0 ? We : Xe;
    }, Ve.min = function(We, Xe) {
      return We.cmp(Xe) < 0 ? We : Xe;
    }, Ve.prototype._init = function(We, Xe, rt) {
      if (typeof We == "number")
        return this._initNumber(We, Xe, rt);
      if (typeof We == "object")
        return this._initArray(We, Xe, rt);
      Xe === "hex" && (Xe = 16), Fe(Xe === (Xe | 0) && Xe >= 2 && Xe <= 36), We = We.toString().replace(/\s+/g, "");
      var ot = 0;
      We[0] === "-" && (ot++, (this || _global$1$1).negative = 1), ot < We.length && (Xe === 16 ? this._parseHex(We, ot, rt) : (this._parseBase(We, Xe, ot), rt === "le" && this._initArray(this.toArray(), Xe, rt)));
    }, Ve.prototype._initNumber = function(We, Xe, rt) {
      We < 0 && ((this || _global$1$1).negative = 1, We = -We), We < 67108864 ? ((this || _global$1$1).words = [We & 67108863], (this || _global$1$1).length = 1) : We < 4503599627370496 ? ((this || _global$1$1).words = [We & 67108863, We / 67108864 & 67108863], (this || _global$1$1).length = 2) : (Fe(We < 9007199254740992), (this || _global$1$1).words = [We & 67108863, We / 67108864 & 67108863, 1], (this || _global$1$1).length = 3), rt === "le" && this._initArray(this.toArray(), Xe, rt);
    }, Ve.prototype._initArray = function(We, Xe, rt) {
      if (Fe(typeof We.length == "number"), We.length <= 0)
        return (this || _global$1$1).words = [0], (this || _global$1$1).length = 1, this || _global$1$1;
      (this || _global$1$1).length = Math.ceil(We.length / 3), (this || _global$1$1).words = new Array((this || _global$1$1).length);
      for (var ot = 0; ot < (this || _global$1$1).length; ot++)
        (this || _global$1$1).words[ot] = 0;
      var ft, mt, yt = 0;
      if (rt === "be")
        for (ot = We.length - 1, ft = 0; ot >= 0; ot -= 3)
          mt = We[ot] | We[ot - 1] << 8 | We[ot - 2] << 16, (this || _global$1$1).words[ft] |= mt << yt & 67108863, (this || _global$1$1).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      else if (rt === "le")
        for (ot = 0, ft = 0; ot < We.length; ot += 3)
          mt = We[ot] | We[ot + 1] << 8 | We[ot + 2] << 16, (this || _global$1$1).words[ft] |= mt << yt & 67108863, (this || _global$1$1).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      return this.strip();
    };
    function Qe(gt, We) {
      var Xe = gt.charCodeAt(We);
      return Xe >= 65 && Xe <= 70 ? Xe - 55 : Xe >= 97 && Xe <= 102 ? Xe - 87 : Xe - 48 & 15;
    }
    function at(gt, We, Xe) {
      var rt = Qe(gt, Xe);
      return Xe - 1 >= We && (rt |= Qe(gt, Xe - 1) << 4), rt;
    }
    Ve.prototype._parseHex = function(We, Xe, rt) {
      (this || _global$1$1).length = Math.ceil((We.length - Xe) / 6), (this || _global$1$1).words = new Array((this || _global$1$1).length);
      for (var ot = 0; ot < (this || _global$1$1).length; ot++)
        (this || _global$1$1).words[ot] = 0;
      var ft = 0, mt = 0, yt;
      if (rt === "be")
        for (ot = We.length - 1; ot >= Xe; ot -= 2)
          yt = at(We, Xe, ot) << ft, (this || _global$1$1).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$1$1).words[mt] |= yt >>> 26) : ft += 8;
      else {
        var pt = We.length - Xe;
        for (ot = pt % 2 === 0 ? Xe + 1 : Xe; ot < We.length; ot += 2)
          yt = at(We, Xe, ot) << ft, (this || _global$1$1).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$1$1).words[mt] |= yt >>> 26) : ft += 8;
      }
      this.strip();
    };
    function ut(gt, We, Xe, rt) {
      for (var ot = 0, ft = Math.min(gt.length, Xe), mt = We; mt < ft; mt++) {
        var yt = gt.charCodeAt(mt) - 48;
        ot *= rt, yt >= 49 ? ot += yt - 49 + 10 : yt >= 17 ? ot += yt - 17 + 10 : ot += yt;
      }
      return ot;
    }
    Ve.prototype._parseBase = function(We, Xe, rt) {
      (this || _global$1$1).words = [0], (this || _global$1$1).length = 1;
      for (var ot = 0, ft = 1; ft <= 67108863; ft *= Xe)
        ot++;
      ot--, ft = ft / Xe | 0;
      for (var mt = We.length - rt, yt = mt % ot, pt = Math.min(mt, mt - yt) + rt, Ge = 0, ct = rt; ct < pt; ct += ot)
        Ge = ut(We, ct, ct + ot, Xe), this.imuln(ft), (this || _global$1$1).words[0] + Ge < 67108864 ? (this || _global$1$1).words[0] += Ge : this._iaddn(Ge);
      if (yt !== 0) {
        var Mt = 1;
        for (Ge = ut(We, ct, We.length, Xe), ct = 0; ct < yt; ct++)
          Mt *= Xe;
        this.imuln(Mt), (this || _global$1$1).words[0] + Ge < 67108864 ? (this || _global$1$1).words[0] += Ge : this._iaddn(Ge);
      }
      this.strip();
    }, Ve.prototype.copy = function(We) {
      We.words = new Array((this || _global$1$1).length);
      for (var Xe = 0; Xe < (this || _global$1$1).length; Xe++)
        We.words[Xe] = (this || _global$1$1).words[Xe];
      We.length = (this || _global$1$1).length, We.negative = (this || _global$1$1).negative, We.red = (this || _global$1$1).red;
    }, Ve.prototype.clone = function() {
      var We = new Ve(null);
      return this.copy(We), We;
    }, Ve.prototype._expand = function(We) {
      for (; (this || _global$1$1).length < We; )
        (this || _global$1$1).words[(this || _global$1$1).length++] = 0;
      return this || _global$1$1;
    }, Ve.prototype.strip = function() {
      for (; (this || _global$1$1).length > 1 && (this || _global$1$1).words[(this || _global$1$1).length - 1] === 0; )
        (this || _global$1$1).length--;
      return this._normSign();
    }, Ve.prototype._normSign = function() {
      return (this || _global$1$1).length === 1 && (this || _global$1$1).words[0] === 0 && ((this || _global$1$1).negative = 0), this || _global$1$1;
    }, Ve.prototype.inspect = function() {
      return ((this || _global$1$1).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var lt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], dt = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], bt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    Ve.prototype.toString = function(We, Xe) {
      We = We || 10, Xe = Xe | 0 || 1;
      var rt;
      if (We === 16 || We === "hex") {
        rt = "";
        for (var ot = 0, ft = 0, mt = 0; mt < (this || _global$1$1).length; mt++) {
          var yt = (this || _global$1$1).words[mt], pt = ((yt << ot | ft) & 16777215).toString(16);
          ft = yt >>> 24 - ot & 16777215, ft !== 0 || mt !== (this || _global$1$1).length - 1 ? rt = lt[6 - pt.length] + pt + rt : rt = pt + rt, ot += 2, ot >= 26 && (ot -= 26, mt--);
        }
        for (ft !== 0 && (rt = ft.toString(16) + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$1$1).negative !== 0 && (rt = "-" + rt), rt;
      }
      if (We === (We | 0) && We >= 2 && We <= 36) {
        var Ge = dt[We], ct = bt[We];
        rt = "";
        var Mt = this.clone();
        for (Mt.negative = 0; !Mt.isZero(); ) {
          var St = Mt.modn(ct).toString(We);
          Mt = Mt.idivn(ct), Mt.isZero() ? rt = St + rt : rt = lt[Ge - St.length] + St + rt;
        }
        for (this.isZero() && (rt = "0" + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$1$1).negative !== 0 && (rt = "-" + rt), rt;
      }
      Fe(!1, "Base should be between 2 and 36");
    }, Ve.prototype.toNumber = function() {
      var We = (this || _global$1$1).words[0];
      return (this || _global$1$1).length === 2 ? We += (this || _global$1$1).words[1] * 67108864 : (this || _global$1$1).length === 3 && (this || _global$1$1).words[2] === 1 ? We += 4503599627370496 + (this || _global$1$1).words[1] * 67108864 : (this || _global$1$1).length > 2 && Fe(!1, "Number can only safely store up to 53 bits"), (this || _global$1$1).negative !== 0 ? -We : We;
    }, Ve.prototype.toJSON = function() {
      return this.toString(16);
    }, Ve.prototype.toBuffer = function(We, Xe) {
      return Fe(typeof Je < "u"), this.toArrayLike(Je, We, Xe);
    }, Ve.prototype.toArray = function(We, Xe) {
      return this.toArrayLike(Array, We, Xe);
    }, Ve.prototype.toArrayLike = function(We, Xe, rt) {
      var ot = this.byteLength(), ft = rt || Math.max(1, ot);
      Fe(ot <= ft, "byte array longer than desired length"), Fe(ft > 0, "Requested array length <= 0"), this.strip();
      var mt = Xe === "le", yt = new We(ft), pt, Ge, ct = this.clone();
      if (mt) {
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[Ge] = pt;
        for (; Ge < ft; Ge++)
          yt[Ge] = 0;
      } else {
        for (Ge = 0; Ge < ft - ot; Ge++)
          yt[Ge] = 0;
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[ft - Ge - 1] = pt;
      }
      return yt;
    }, Math.clz32 ? Ve.prototype._countBits = function(We) {
      return 32 - Math.clz32(We);
    } : Ve.prototype._countBits = function(We) {
      var Xe = We, rt = 0;
      return Xe >= 4096 && (rt += 13, Xe >>>= 13), Xe >= 64 && (rt += 7, Xe >>>= 7), Xe >= 8 && (rt += 4, Xe >>>= 4), Xe >= 2 && (rt += 2, Xe >>>= 2), rt + Xe;
    }, Ve.prototype._zeroBits = function(We) {
      if (We === 0)
        return 26;
      var Xe = We, rt = 0;
      return Xe & 8191 || (rt += 13, Xe >>>= 13), Xe & 127 || (rt += 7, Xe >>>= 7), Xe & 15 || (rt += 4, Xe >>>= 4), Xe & 3 || (rt += 2, Xe >>>= 2), Xe & 1 || rt++, rt;
    }, Ve.prototype.bitLength = function() {
      var We = (this || _global$1$1).words[(this || _global$1$1).length - 1], Xe = this._countBits(We);
      return ((this || _global$1$1).length - 1) * 26 + Xe;
    };
    function $t(gt) {
      for (var We = new Array(gt.bitLength()), Xe = 0; Xe < We.length; Xe++) {
        var rt = Xe / 26 | 0, ot = Xe % 26;
        We[Xe] = (gt.words[rt] & 1 << ot) >>> ot;
      }
      return We;
    }
    Ve.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var We = 0, Xe = 0; Xe < (this || _global$1$1).length; Xe++) {
        var rt = this._zeroBits((this || _global$1$1).words[Xe]);
        if (We += rt, rt !== 26)
          break;
      }
      return We;
    }, Ve.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Ve.prototype.toTwos = function(We) {
      return (this || _global$1$1).negative !== 0 ? this.abs().inotn(We).iaddn(1) : this.clone();
    }, Ve.prototype.fromTwos = function(We) {
      return this.testn(We - 1) ? this.notn(We).iaddn(1).ineg() : this.clone();
    }, Ve.prototype.isNeg = function() {
      return (this || _global$1$1).negative !== 0;
    }, Ve.prototype.neg = function() {
      return this.clone().ineg();
    }, Ve.prototype.ineg = function() {
      return this.isZero() || ((this || _global$1$1).negative ^= 1), this || _global$1$1;
    }, Ve.prototype.iuor = function(We) {
      for (; (this || _global$1$1).length < We.length; )
        (this || _global$1$1).words[(this || _global$1$1).length++] = 0;
      for (var Xe = 0; Xe < We.length; Xe++)
        (this || _global$1$1).words[Xe] = (this || _global$1$1).words[Xe] | We.words[Xe];
      return this.strip();
    }, Ve.prototype.ior = function(We) {
      return Fe(((this || _global$1$1).negative | We.negative) === 0), this.iuor(We);
    }, Ve.prototype.or = function(We) {
      return (this || _global$1$1).length > We.length ? this.clone().ior(We) : We.clone().ior(this || _global$1$1);
    }, Ve.prototype.uor = function(We) {
      return (this || _global$1$1).length > We.length ? this.clone().iuor(We) : We.clone().iuor(this || _global$1$1);
    }, Ve.prototype.iuand = function(We) {
      var Xe;
      (this || _global$1$1).length > We.length ? Xe = We : Xe = this || _global$1$1;
      for (var rt = 0; rt < Xe.length; rt++)
        (this || _global$1$1).words[rt] = (this || _global$1$1).words[rt] & We.words[rt];
      return (this || _global$1$1).length = Xe.length, this.strip();
    }, Ve.prototype.iand = function(We) {
      return Fe(((this || _global$1$1).negative | We.negative) === 0), this.iuand(We);
    }, Ve.prototype.and = function(We) {
      return (this || _global$1$1).length > We.length ? this.clone().iand(We) : We.clone().iand(this || _global$1$1);
    }, Ve.prototype.uand = function(We) {
      return (this || _global$1$1).length > We.length ? this.clone().iuand(We) : We.clone().iuand(this || _global$1$1);
    }, Ve.prototype.iuxor = function(We) {
      var Xe, rt;
      (this || _global$1$1).length > We.length ? (Xe = this || _global$1$1, rt = We) : (Xe = We, rt = this || _global$1$1);
      for (var ot = 0; ot < rt.length; ot++)
        (this || _global$1$1).words[ot] = Xe.words[ot] ^ rt.words[ot];
      if ((this || _global$1$1) !== Xe)
        for (; ot < Xe.length; ot++)
          (this || _global$1$1).words[ot] = Xe.words[ot];
      return (this || _global$1$1).length = Xe.length, this.strip();
    }, Ve.prototype.ixor = function(We) {
      return Fe(((this || _global$1$1).negative | We.negative) === 0), this.iuxor(We);
    }, Ve.prototype.xor = function(We) {
      return (this || _global$1$1).length > We.length ? this.clone().ixor(We) : We.clone().ixor(this || _global$1$1);
    }, Ve.prototype.uxor = function(We) {
      return (this || _global$1$1).length > We.length ? this.clone().iuxor(We) : We.clone().iuxor(this || _global$1$1);
    }, Ve.prototype.inotn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = Math.ceil(We / 26) | 0, rt = We % 26;
      this._expand(Xe), rt > 0 && Xe--;
      for (var ot = 0; ot < Xe; ot++)
        (this || _global$1$1).words[ot] = ~(this || _global$1$1).words[ot] & 67108863;
      return rt > 0 && ((this || _global$1$1).words[ot] = ~(this || _global$1$1).words[ot] & 67108863 >> 26 - rt), this.strip();
    }, Ve.prototype.notn = function(We) {
      return this.clone().inotn(We);
    }, Ve.prototype.setn = function(We, Xe) {
      Fe(typeof We == "number" && We >= 0);
      var rt = We / 26 | 0, ot = We % 26;
      return this._expand(rt + 1), Xe ? (this || _global$1$1).words[rt] = (this || _global$1$1).words[rt] | 1 << ot : (this || _global$1$1).words[rt] = (this || _global$1$1).words[rt] & ~(1 << ot), this.strip();
    }, Ve.prototype.iadd = function(We) {
      var Xe;
      if ((this || _global$1$1).negative !== 0 && We.negative === 0)
        return (this || _global$1$1).negative = 0, Xe = this.isub(We), (this || _global$1$1).negative ^= 1, this._normSign();
      if ((this || _global$1$1).negative === 0 && We.negative !== 0)
        return We.negative = 0, Xe = this.isub(We), We.negative = 1, Xe._normSign();
      var rt, ot;
      (this || _global$1$1).length > We.length ? (rt = this || _global$1$1, ot = We) : (rt = We, ot = this || _global$1$1);
      for (var ft = 0, mt = 0; mt < ot.length; mt++)
        Xe = (rt.words[mt] | 0) + (ot.words[mt] | 0) + ft, (this || _global$1$1).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      for (; ft !== 0 && mt < rt.length; mt++)
        Xe = (rt.words[mt] | 0) + ft, (this || _global$1$1).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      if ((this || _global$1$1).length = rt.length, ft !== 0)
        (this || _global$1$1).words[(this || _global$1$1).length] = ft, (this || _global$1$1).length++;
      else if (rt !== (this || _global$1$1))
        for (; mt < rt.length; mt++)
          (this || _global$1$1).words[mt] = rt.words[mt];
      return this || _global$1$1;
    }, Ve.prototype.add = function(We) {
      var Xe;
      return We.negative !== 0 && (this || _global$1$1).negative === 0 ? (We.negative = 0, Xe = this.sub(We), We.negative ^= 1, Xe) : We.negative === 0 && (this || _global$1$1).negative !== 0 ? ((this || _global$1$1).negative = 0, Xe = We.sub(this || _global$1$1), (this || _global$1$1).negative = 1, Xe) : (this || _global$1$1).length > We.length ? this.clone().iadd(We) : We.clone().iadd(this || _global$1$1);
    }, Ve.prototype.isub = function(We) {
      if (We.negative !== 0) {
        We.negative = 0;
        var Xe = this.iadd(We);
        return We.negative = 1, Xe._normSign();
      } else if ((this || _global$1$1).negative !== 0)
        return (this || _global$1$1).negative = 0, this.iadd(We), (this || _global$1$1).negative = 1, this._normSign();
      var rt = this.cmp(We);
      if (rt === 0)
        return (this || _global$1$1).negative = 0, (this || _global$1$1).length = 1, (this || _global$1$1).words[0] = 0, this || _global$1$1;
      var ot, ft;
      rt > 0 ? (ot = this || _global$1$1, ft = We) : (ot = We, ft = this || _global$1$1);
      for (var mt = 0, yt = 0; yt < ft.length; yt++)
        Xe = (ot.words[yt] | 0) - (ft.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$1$1).words[yt] = Xe & 67108863;
      for (; mt !== 0 && yt < ot.length; yt++)
        Xe = (ot.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$1$1).words[yt] = Xe & 67108863;
      if (mt === 0 && yt < ot.length && ot !== (this || _global$1$1))
        for (; yt < ot.length; yt++)
          (this || _global$1$1).words[yt] = ot.words[yt];
      return (this || _global$1$1).length = Math.max((this || _global$1$1).length, yt), ot !== (this || _global$1$1) && ((this || _global$1$1).negative = 1), this.strip();
    }, Ve.prototype.sub = function(We) {
      return this.clone().isub(We);
    };
    function vt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative;
      var rt = gt.length + We.length | 0;
      Xe.length = rt, rt = rt - 1 | 0;
      var ot = gt.words[0] | 0, ft = We.words[0] | 0, mt = ot * ft, yt = mt & 67108863, pt = mt / 67108864 | 0;
      Xe.words[0] = yt;
      for (var Ge = 1; Ge < rt; Ge++) {
        for (var ct = pt >>> 26, Mt = pt & 67108863, St = Math.min(Ge, We.length - 1), At = Math.max(0, Ge - gt.length + 1); At <= St; At++) {
          var Nt = Ge - At | 0;
          ot = gt.words[Nt] | 0, ft = We.words[At] | 0, mt = ot * ft + Mt, ct += mt / 67108864 | 0, Mt = mt & 67108863;
        }
        Xe.words[Ge] = Mt | 0, pt = ct | 0;
      }
      return pt !== 0 ? Xe.words[Ge] = pt | 0 : Xe.length--, Xe.strip();
    }
    var wt = function(We, Xe, rt) {
      var ot = We.words, ft = Xe.words, mt = rt.words, yt = 0, pt, Ge, ct, Mt = ot[0] | 0, St = Mt & 8191, At = Mt >>> 13, Nt = ot[1] | 0, qt = Nt & 8191, Qt = Nt >>> 13, Xt = ot[2] | 0, zt = Xt & 8191, Kt = Xt >>> 13, ur = ot[3] | 0, er = ur & 8191, Dt = ur >>> 13, Ht = ot[4] | 0, Gt = Ht & 8191, rr = Ht >>> 13, sr = ot[5] | 0, Jt = sr & 8191, ir = sr >>> 13, Br = ot[6] | 0, or = Br & 8191, lr = Br >>> 13, Nr = ot[7] | 0, dr = Nr & 8191, gr = Nr >>> 13, Zr = ot[8] | 0, Bt = Zr & 8191, kt = Zr >>> 13, It = ot[9] | 0, jt = It & 8191, Vt = It >>> 13, ar = ft[0] | 0, Yt = ar & 8191, hr = ar >>> 13, zr = ft[1] | 0, cr = zr & 8191, _r = zr >>> 13, Lr = ft[2] | 0, br = Lr & 8191, kr = Lr >>> 13, Xr = ft[3] | 0, yr = Xr & 8191, Ir = Xr >>> 13, Yr = ft[4] | 0, wr = Yr & 8191, Cr = Yr >>> 13, Hr = ft[5] | 0, $r = Hr & 8191, Ar = Hr >>> 13, Wr = ft[6] | 0, mr = Wr & 8191, Tr = Wr >>> 13, Kr = ft[7] | 0, vr = Kr & 8191, Rr = Kr >>> 13, Jr = ft[8] | 0, xr = Jr & 8191, tr = Jr >>> 13, Dr = ft[9] | 0, fr = Dr & 8191, Mr = Dr >>> 13;
      rt.negative = We.negative ^ Xe.negative, rt.length = 19, pt = Math.imul(St, Yt), Ge = Math.imul(St, hr), Ge = Ge + Math.imul(At, Yt) | 0, ct = Math.imul(At, hr);
      var Fr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, pt = Math.imul(qt, Yt), Ge = Math.imul(qt, hr), Ge = Ge + Math.imul(Qt, Yt) | 0, ct = Math.imul(Qt, hr), pt = pt + Math.imul(St, cr) | 0, Ge = Ge + Math.imul(St, _r) | 0, Ge = Ge + Math.imul(At, cr) | 0, ct = ct + Math.imul(At, _r) | 0;
      var qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, pt = Math.imul(zt, Yt), Ge = Math.imul(zt, hr), Ge = Ge + Math.imul(Kt, Yt) | 0, ct = Math.imul(Kt, hr), pt = pt + Math.imul(qt, cr) | 0, Ge = Ge + Math.imul(qt, _r) | 0, Ge = Ge + Math.imul(Qt, cr) | 0, ct = ct + Math.imul(Qt, _r) | 0, pt = pt + Math.imul(St, br) | 0, Ge = Ge + Math.imul(St, kr) | 0, Ge = Ge + Math.imul(At, br) | 0, ct = ct + Math.imul(At, kr) | 0;
      var tn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, pt = Math.imul(er, Yt), Ge = Math.imul(er, hr), Ge = Ge + Math.imul(Dt, Yt) | 0, ct = Math.imul(Dt, hr), pt = pt + Math.imul(zt, cr) | 0, Ge = Ge + Math.imul(zt, _r) | 0, Ge = Ge + Math.imul(Kt, cr) | 0, ct = ct + Math.imul(Kt, _r) | 0, pt = pt + Math.imul(qt, br) | 0, Ge = Ge + Math.imul(qt, kr) | 0, Ge = Ge + Math.imul(Qt, br) | 0, ct = ct + Math.imul(Qt, kr) | 0, pt = pt + Math.imul(St, yr) | 0, Ge = Ge + Math.imul(St, Ir) | 0, Ge = Ge + Math.imul(At, yr) | 0, ct = ct + Math.imul(At, Ir) | 0;
      var Qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, pt = Math.imul(Gt, Yt), Ge = Math.imul(Gt, hr), Ge = Ge + Math.imul(rr, Yt) | 0, ct = Math.imul(rr, hr), pt = pt + Math.imul(er, cr) | 0, Ge = Ge + Math.imul(er, _r) | 0, Ge = Ge + Math.imul(Dt, cr) | 0, ct = ct + Math.imul(Dt, _r) | 0, pt = pt + Math.imul(zt, br) | 0, Ge = Ge + Math.imul(zt, kr) | 0, Ge = Ge + Math.imul(Kt, br) | 0, ct = ct + Math.imul(Kt, kr) | 0, pt = pt + Math.imul(qt, yr) | 0, Ge = Ge + Math.imul(qt, Ir) | 0, Ge = Ge + Math.imul(Qt, yr) | 0, ct = ct + Math.imul(Qt, Ir) | 0, pt = pt + Math.imul(St, wr) | 0, Ge = Ge + Math.imul(St, Cr) | 0, Ge = Ge + Math.imul(At, wr) | 0, ct = ct + Math.imul(At, Cr) | 0;
      var nn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, pt = Math.imul(Jt, Yt), Ge = Math.imul(Jt, hr), Ge = Ge + Math.imul(ir, Yt) | 0, ct = Math.imul(ir, hr), pt = pt + Math.imul(Gt, cr) | 0, Ge = Ge + Math.imul(Gt, _r) | 0, Ge = Ge + Math.imul(rr, cr) | 0, ct = ct + Math.imul(rr, _r) | 0, pt = pt + Math.imul(er, br) | 0, Ge = Ge + Math.imul(er, kr) | 0, Ge = Ge + Math.imul(Dt, br) | 0, ct = ct + Math.imul(Dt, kr) | 0, pt = pt + Math.imul(zt, yr) | 0, Ge = Ge + Math.imul(zt, Ir) | 0, Ge = Ge + Math.imul(Kt, yr) | 0, ct = ct + Math.imul(Kt, Ir) | 0, pt = pt + Math.imul(qt, wr) | 0, Ge = Ge + Math.imul(qt, Cr) | 0, Ge = Ge + Math.imul(Qt, wr) | 0, ct = ct + Math.imul(Qt, Cr) | 0, pt = pt + Math.imul(St, $r) | 0, Ge = Ge + Math.imul(St, Ar) | 0, Ge = Ge + Math.imul(At, $r) | 0, ct = ct + Math.imul(At, Ar) | 0;
      var Er = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, pt = Math.imul(or, Yt), Ge = Math.imul(or, hr), Ge = Ge + Math.imul(lr, Yt) | 0, ct = Math.imul(lr, hr), pt = pt + Math.imul(Jt, cr) | 0, Ge = Ge + Math.imul(Jt, _r) | 0, Ge = Ge + Math.imul(ir, cr) | 0, ct = ct + Math.imul(ir, _r) | 0, pt = pt + Math.imul(Gt, br) | 0, Ge = Ge + Math.imul(Gt, kr) | 0, Ge = Ge + Math.imul(rr, br) | 0, ct = ct + Math.imul(rr, kr) | 0, pt = pt + Math.imul(er, yr) | 0, Ge = Ge + Math.imul(er, Ir) | 0, Ge = Ge + Math.imul(Dt, yr) | 0, ct = ct + Math.imul(Dt, Ir) | 0, pt = pt + Math.imul(zt, wr) | 0, Ge = Ge + Math.imul(zt, Cr) | 0, Ge = Ge + Math.imul(Kt, wr) | 0, ct = ct + Math.imul(Kt, Cr) | 0, pt = pt + Math.imul(qt, $r) | 0, Ge = Ge + Math.imul(qt, Ar) | 0, Ge = Ge + Math.imul(Qt, $r) | 0, ct = ct + Math.imul(Qt, Ar) | 0, pt = pt + Math.imul(St, mr) | 0, Ge = Ge + Math.imul(St, Tr) | 0, Ge = Ge + Math.imul(At, mr) | 0, ct = ct + Math.imul(At, Tr) | 0;
      var Wt = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, pt = Math.imul(dr, Yt), Ge = Math.imul(dr, hr), Ge = Ge + Math.imul(gr, Yt) | 0, ct = Math.imul(gr, hr), pt = pt + Math.imul(or, cr) | 0, Ge = Ge + Math.imul(or, _r) | 0, Ge = Ge + Math.imul(lr, cr) | 0, ct = ct + Math.imul(lr, _r) | 0, pt = pt + Math.imul(Jt, br) | 0, Ge = Ge + Math.imul(Jt, kr) | 0, Ge = Ge + Math.imul(ir, br) | 0, ct = ct + Math.imul(ir, kr) | 0, pt = pt + Math.imul(Gt, yr) | 0, Ge = Ge + Math.imul(Gt, Ir) | 0, Ge = Ge + Math.imul(rr, yr) | 0, ct = ct + Math.imul(rr, Ir) | 0, pt = pt + Math.imul(er, wr) | 0, Ge = Ge + Math.imul(er, Cr) | 0, Ge = Ge + Math.imul(Dt, wr) | 0, ct = ct + Math.imul(Dt, Cr) | 0, pt = pt + Math.imul(zt, $r) | 0, Ge = Ge + Math.imul(zt, Ar) | 0, Ge = Ge + Math.imul(Kt, $r) | 0, ct = ct + Math.imul(Kt, Ar) | 0, pt = pt + Math.imul(qt, mr) | 0, Ge = Ge + Math.imul(qt, Tr) | 0, Ge = Ge + Math.imul(Qt, mr) | 0, ct = ct + Math.imul(Qt, Tr) | 0, pt = pt + Math.imul(St, vr) | 0, Ge = Ge + Math.imul(St, Rr) | 0, Ge = Ge + Math.imul(At, vr) | 0, ct = ct + Math.imul(At, Rr) | 0;
      var nr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, pt = Math.imul(Bt, Yt), Ge = Math.imul(Bt, hr), Ge = Ge + Math.imul(kt, Yt) | 0, ct = Math.imul(kt, hr), pt = pt + Math.imul(dr, cr) | 0, Ge = Ge + Math.imul(dr, _r) | 0, Ge = Ge + Math.imul(gr, cr) | 0, ct = ct + Math.imul(gr, _r) | 0, pt = pt + Math.imul(or, br) | 0, Ge = Ge + Math.imul(or, kr) | 0, Ge = Ge + Math.imul(lr, br) | 0, ct = ct + Math.imul(lr, kr) | 0, pt = pt + Math.imul(Jt, yr) | 0, Ge = Ge + Math.imul(Jt, Ir) | 0, Ge = Ge + Math.imul(ir, yr) | 0, ct = ct + Math.imul(ir, Ir) | 0, pt = pt + Math.imul(Gt, wr) | 0, Ge = Ge + Math.imul(Gt, Cr) | 0, Ge = Ge + Math.imul(rr, wr) | 0, ct = ct + Math.imul(rr, Cr) | 0, pt = pt + Math.imul(er, $r) | 0, Ge = Ge + Math.imul(er, Ar) | 0, Ge = Ge + Math.imul(Dt, $r) | 0, ct = ct + Math.imul(Dt, Ar) | 0, pt = pt + Math.imul(zt, mr) | 0, Ge = Ge + Math.imul(zt, Tr) | 0, Ge = Ge + Math.imul(Kt, mr) | 0, ct = ct + Math.imul(Kt, Tr) | 0, pt = pt + Math.imul(qt, vr) | 0, Ge = Ge + Math.imul(qt, Rr) | 0, Ge = Ge + Math.imul(Qt, vr) | 0, ct = ct + Math.imul(Qt, Rr) | 0, pt = pt + Math.imul(St, xr) | 0, Ge = Ge + Math.imul(St, tr) | 0, Ge = Ge + Math.imul(At, xr) | 0, ct = ct + Math.imul(At, tr) | 0;
      var pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, pt = Math.imul(jt, Yt), Ge = Math.imul(jt, hr), Ge = Ge + Math.imul(Vt, Yt) | 0, ct = Math.imul(Vt, hr), pt = pt + Math.imul(Bt, cr) | 0, Ge = Ge + Math.imul(Bt, _r) | 0, Ge = Ge + Math.imul(kt, cr) | 0, ct = ct + Math.imul(kt, _r) | 0, pt = pt + Math.imul(dr, br) | 0, Ge = Ge + Math.imul(dr, kr) | 0, Ge = Ge + Math.imul(gr, br) | 0, ct = ct + Math.imul(gr, kr) | 0, pt = pt + Math.imul(or, yr) | 0, Ge = Ge + Math.imul(or, Ir) | 0, Ge = Ge + Math.imul(lr, yr) | 0, ct = ct + Math.imul(lr, Ir) | 0, pt = pt + Math.imul(Jt, wr) | 0, Ge = Ge + Math.imul(Jt, Cr) | 0, Ge = Ge + Math.imul(ir, wr) | 0, ct = ct + Math.imul(ir, Cr) | 0, pt = pt + Math.imul(Gt, $r) | 0, Ge = Ge + Math.imul(Gt, Ar) | 0, Ge = Ge + Math.imul(rr, $r) | 0, ct = ct + Math.imul(rr, Ar) | 0, pt = pt + Math.imul(er, mr) | 0, Ge = Ge + Math.imul(er, Tr) | 0, Ge = Ge + Math.imul(Dt, mr) | 0, ct = ct + Math.imul(Dt, Tr) | 0, pt = pt + Math.imul(zt, vr) | 0, Ge = Ge + Math.imul(zt, Rr) | 0, Ge = Ge + Math.imul(Kt, vr) | 0, ct = ct + Math.imul(Kt, Rr) | 0, pt = pt + Math.imul(qt, xr) | 0, Ge = Ge + Math.imul(qt, tr) | 0, Ge = Ge + Math.imul(Qt, xr) | 0, ct = ct + Math.imul(Qt, tr) | 0, pt = pt + Math.imul(St, fr) | 0, Ge = Ge + Math.imul(St, Mr) | 0, Ge = Ge + Math.imul(At, fr) | 0, ct = ct + Math.imul(At, Mr) | 0;
      var Pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, pt = Math.imul(jt, cr), Ge = Math.imul(jt, _r), Ge = Ge + Math.imul(Vt, cr) | 0, ct = Math.imul(Vt, _r), pt = pt + Math.imul(Bt, br) | 0, Ge = Ge + Math.imul(Bt, kr) | 0, Ge = Ge + Math.imul(kt, br) | 0, ct = ct + Math.imul(kt, kr) | 0, pt = pt + Math.imul(dr, yr) | 0, Ge = Ge + Math.imul(dr, Ir) | 0, Ge = Ge + Math.imul(gr, yr) | 0, ct = ct + Math.imul(gr, Ir) | 0, pt = pt + Math.imul(or, wr) | 0, Ge = Ge + Math.imul(or, Cr) | 0, Ge = Ge + Math.imul(lr, wr) | 0, ct = ct + Math.imul(lr, Cr) | 0, pt = pt + Math.imul(Jt, $r) | 0, Ge = Ge + Math.imul(Jt, Ar) | 0, Ge = Ge + Math.imul(ir, $r) | 0, ct = ct + Math.imul(ir, Ar) | 0, pt = pt + Math.imul(Gt, mr) | 0, Ge = Ge + Math.imul(Gt, Tr) | 0, Ge = Ge + Math.imul(rr, mr) | 0, ct = ct + Math.imul(rr, Tr) | 0, pt = pt + Math.imul(er, vr) | 0, Ge = Ge + Math.imul(er, Rr) | 0, Ge = Ge + Math.imul(Dt, vr) | 0, ct = ct + Math.imul(Dt, Rr) | 0, pt = pt + Math.imul(zt, xr) | 0, Ge = Ge + Math.imul(zt, tr) | 0, Ge = Ge + Math.imul(Kt, xr) | 0, ct = ct + Math.imul(Kt, tr) | 0, pt = pt + Math.imul(qt, fr) | 0, Ge = Ge + Math.imul(qt, Mr) | 0, Ge = Ge + Math.imul(Qt, fr) | 0, ct = ct + Math.imul(Qt, Mr) | 0;
      var Sr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, pt = Math.imul(jt, br), Ge = Math.imul(jt, kr), Ge = Ge + Math.imul(Vt, br) | 0, ct = Math.imul(Vt, kr), pt = pt + Math.imul(Bt, yr) | 0, Ge = Ge + Math.imul(Bt, Ir) | 0, Ge = Ge + Math.imul(kt, yr) | 0, ct = ct + Math.imul(kt, Ir) | 0, pt = pt + Math.imul(dr, wr) | 0, Ge = Ge + Math.imul(dr, Cr) | 0, Ge = Ge + Math.imul(gr, wr) | 0, ct = ct + Math.imul(gr, Cr) | 0, pt = pt + Math.imul(or, $r) | 0, Ge = Ge + Math.imul(or, Ar) | 0, Ge = Ge + Math.imul(lr, $r) | 0, ct = ct + Math.imul(lr, Ar) | 0, pt = pt + Math.imul(Jt, mr) | 0, Ge = Ge + Math.imul(Jt, Tr) | 0, Ge = Ge + Math.imul(ir, mr) | 0, ct = ct + Math.imul(ir, Tr) | 0, pt = pt + Math.imul(Gt, vr) | 0, Ge = Ge + Math.imul(Gt, Rr) | 0, Ge = Ge + Math.imul(rr, vr) | 0, ct = ct + Math.imul(rr, Rr) | 0, pt = pt + Math.imul(er, xr) | 0, Ge = Ge + Math.imul(er, tr) | 0, Ge = Ge + Math.imul(Dt, xr) | 0, ct = ct + Math.imul(Dt, tr) | 0, pt = pt + Math.imul(zt, fr) | 0, Ge = Ge + Math.imul(zt, Mr) | 0, Ge = Ge + Math.imul(Kt, fr) | 0, ct = ct + Math.imul(Kt, Mr) | 0;
      var Ur = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, pt = Math.imul(jt, yr), Ge = Math.imul(jt, Ir), Ge = Ge + Math.imul(Vt, yr) | 0, ct = Math.imul(Vt, Ir), pt = pt + Math.imul(Bt, wr) | 0, Ge = Ge + Math.imul(Bt, Cr) | 0, Ge = Ge + Math.imul(kt, wr) | 0, ct = ct + Math.imul(kt, Cr) | 0, pt = pt + Math.imul(dr, $r) | 0, Ge = Ge + Math.imul(dr, Ar) | 0, Ge = Ge + Math.imul(gr, $r) | 0, ct = ct + Math.imul(gr, Ar) | 0, pt = pt + Math.imul(or, mr) | 0, Ge = Ge + Math.imul(or, Tr) | 0, Ge = Ge + Math.imul(lr, mr) | 0, ct = ct + Math.imul(lr, Tr) | 0, pt = pt + Math.imul(Jt, vr) | 0, Ge = Ge + Math.imul(Jt, Rr) | 0, Ge = Ge + Math.imul(ir, vr) | 0, ct = ct + Math.imul(ir, Rr) | 0, pt = pt + Math.imul(Gt, xr) | 0, Ge = Ge + Math.imul(Gt, tr) | 0, Ge = Ge + Math.imul(rr, xr) | 0, ct = ct + Math.imul(rr, tr) | 0, pt = pt + Math.imul(er, fr) | 0, Ge = Ge + Math.imul(er, Mr) | 0, Ge = Ge + Math.imul(Dt, fr) | 0, ct = ct + Math.imul(Dt, Mr) | 0;
      var jr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, pt = Math.imul(jt, wr), Ge = Math.imul(jt, Cr), Ge = Ge + Math.imul(Vt, wr) | 0, ct = Math.imul(Vt, Cr), pt = pt + Math.imul(Bt, $r) | 0, Ge = Ge + Math.imul(Bt, Ar) | 0, Ge = Ge + Math.imul(kt, $r) | 0, ct = ct + Math.imul(kt, Ar) | 0, pt = pt + Math.imul(dr, mr) | 0, Ge = Ge + Math.imul(dr, Tr) | 0, Ge = Ge + Math.imul(gr, mr) | 0, ct = ct + Math.imul(gr, Tr) | 0, pt = pt + Math.imul(or, vr) | 0, Ge = Ge + Math.imul(or, Rr) | 0, Ge = Ge + Math.imul(lr, vr) | 0, ct = ct + Math.imul(lr, Rr) | 0, pt = pt + Math.imul(Jt, xr) | 0, Ge = Ge + Math.imul(Jt, tr) | 0, Ge = Ge + Math.imul(ir, xr) | 0, ct = ct + Math.imul(ir, tr) | 0, pt = pt + Math.imul(Gt, fr) | 0, Ge = Ge + Math.imul(Gt, Mr) | 0, Ge = Ge + Math.imul(rr, fr) | 0, ct = ct + Math.imul(rr, Mr) | 0;
      var Gr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, pt = Math.imul(jt, $r), Ge = Math.imul(jt, Ar), Ge = Ge + Math.imul(Vt, $r) | 0, ct = Math.imul(Vt, Ar), pt = pt + Math.imul(Bt, mr) | 0, Ge = Ge + Math.imul(Bt, Tr) | 0, Ge = Ge + Math.imul(kt, mr) | 0, ct = ct + Math.imul(kt, Tr) | 0, pt = pt + Math.imul(dr, vr) | 0, Ge = Ge + Math.imul(dr, Rr) | 0, Ge = Ge + Math.imul(gr, vr) | 0, ct = ct + Math.imul(gr, Rr) | 0, pt = pt + Math.imul(or, xr) | 0, Ge = Ge + Math.imul(or, tr) | 0, Ge = Ge + Math.imul(lr, xr) | 0, ct = ct + Math.imul(lr, tr) | 0, pt = pt + Math.imul(Jt, fr) | 0, Ge = Ge + Math.imul(Jt, Mr) | 0, Ge = Ge + Math.imul(ir, fr) | 0, ct = ct + Math.imul(ir, Mr) | 0;
      var Vr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, pt = Math.imul(jt, mr), Ge = Math.imul(jt, Tr), Ge = Ge + Math.imul(Vt, mr) | 0, ct = Math.imul(Vt, Tr), pt = pt + Math.imul(Bt, vr) | 0, Ge = Ge + Math.imul(Bt, Rr) | 0, Ge = Ge + Math.imul(kt, vr) | 0, ct = ct + Math.imul(kt, Rr) | 0, pt = pt + Math.imul(dr, xr) | 0, Ge = Ge + Math.imul(dr, tr) | 0, Ge = Ge + Math.imul(gr, xr) | 0, ct = ct + Math.imul(gr, tr) | 0, pt = pt + Math.imul(or, fr) | 0, Ge = Ge + Math.imul(or, Mr) | 0, Ge = Ge + Math.imul(lr, fr) | 0, ct = ct + Math.imul(lr, Mr) | 0;
      var rn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, pt = Math.imul(jt, vr), Ge = Math.imul(jt, Rr), Ge = Ge + Math.imul(Vt, vr) | 0, ct = Math.imul(Vt, Rr), pt = pt + Math.imul(Bt, xr) | 0, Ge = Ge + Math.imul(Bt, tr) | 0, Ge = Ge + Math.imul(kt, xr) | 0, ct = ct + Math.imul(kt, tr) | 0, pt = pt + Math.imul(dr, fr) | 0, Ge = Ge + Math.imul(dr, Mr) | 0, Ge = Ge + Math.imul(gr, fr) | 0, ct = ct + Math.imul(gr, Mr) | 0;
      var an = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, pt = Math.imul(jt, xr), Ge = Math.imul(jt, tr), Ge = Ge + Math.imul(Vt, xr) | 0, ct = Math.imul(Vt, tr), pt = pt + Math.imul(Bt, fr) | 0, Ge = Ge + Math.imul(Bt, Mr) | 0, Ge = Ge + Math.imul(kt, fr) | 0, ct = ct + Math.imul(kt, Mr) | 0;
      var ln = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, pt = Math.imul(jt, fr), Ge = Math.imul(jt, Mr), Ge = Ge + Math.imul(Vt, fr) | 0, ct = Math.imul(Vt, Mr);
      var sn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      return yt = (ct + (Ge >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, mt[0] = Fr, mt[1] = qr, mt[2] = tn, mt[3] = Qr, mt[4] = nn, mt[5] = Er, mt[6] = Wt, mt[7] = nr, mt[8] = pr, mt[9] = Pr, mt[10] = Sr, mt[11] = Ur, mt[12] = jr, mt[13] = Gr, mt[14] = Vr, mt[15] = rn, mt[16] = an, mt[17] = ln, mt[18] = sn, yt !== 0 && (mt[19] = yt, rt.length++), rt;
    };
    Math.imul || (wt = vt);
    function xt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative, Xe.length = gt.length + We.length;
      for (var rt = 0, ot = 0, ft = 0; ft < Xe.length - 1; ft++) {
        var mt = ot;
        ot = 0;
        for (var yt = rt & 67108863, pt = Math.min(ft, We.length - 1), Ge = Math.max(0, ft - gt.length + 1); Ge <= pt; Ge++) {
          var ct = ft - Ge, Mt = gt.words[ct] | 0, St = We.words[Ge] | 0, At = Mt * St, Nt = At & 67108863;
          mt = mt + (At / 67108864 | 0) | 0, Nt = Nt + yt | 0, yt = Nt & 67108863, mt = mt + (Nt >>> 26) | 0, ot += mt >>> 26, mt &= 67108863;
        }
        Xe.words[ft] = yt, rt = mt, mt = ot;
      }
      return rt !== 0 ? Xe.words[ft] = rt : Xe.length--, Xe.strip();
    }
    function Et(gt, We, Xe) {
      var rt = new Tt();
      return rt.mulp(gt, We, Xe);
    }
    Ve.prototype.mulTo = function(We, Xe) {
      var rt, ot = (this || _global$1$1).length + We.length;
      return (this || _global$1$1).length === 10 && We.length === 10 ? rt = wt(this || _global$1$1, We, Xe) : ot < 63 ? rt = vt(this || _global$1$1, We, Xe) : ot < 1024 ? rt = xt(this || _global$1$1, We, Xe) : rt = Et(this || _global$1$1, We, Xe), rt;
    };
    function Tt(gt, We) {
      (this || _global$1$1).x = gt, (this || _global$1$1).y = We;
    }
    Tt.prototype.makeRBT = function(We) {
      for (var Xe = new Array(We), rt = Ve.prototype._countBits(We) - 1, ot = 0; ot < We; ot++)
        Xe[ot] = this.revBin(ot, rt, We);
      return Xe;
    }, Tt.prototype.revBin = function(We, Xe, rt) {
      if (We === 0 || We === rt - 1)
        return We;
      for (var ot = 0, ft = 0; ft < Xe; ft++)
        ot |= (We & 1) << Xe - ft - 1, We >>= 1;
      return ot;
    }, Tt.prototype.permute = function(We, Xe, rt, ot, ft, mt) {
      for (var yt = 0; yt < mt; yt++)
        ot[yt] = Xe[We[yt]], ft[yt] = rt[We[yt]];
    }, Tt.prototype.transform = function(We, Xe, rt, ot, ft, mt) {
      this.permute(mt, We, Xe, rt, ot, ft);
      for (var yt = 1; yt < ft; yt <<= 1)
        for (var pt = yt << 1, Ge = Math.cos(2 * Math.PI / pt), ct = Math.sin(2 * Math.PI / pt), Mt = 0; Mt < ft; Mt += pt)
          for (var St = Ge, At = ct, Nt = 0; Nt < yt; Nt++) {
            var qt = rt[Mt + Nt], Qt = ot[Mt + Nt], Xt = rt[Mt + Nt + yt], zt = ot[Mt + Nt + yt], Kt = St * Xt - At * zt;
            zt = St * zt + At * Xt, Xt = Kt, rt[Mt + Nt] = qt + Xt, ot[Mt + Nt] = Qt + zt, rt[Mt + Nt + yt] = qt - Xt, ot[Mt + Nt + yt] = Qt - zt, Nt !== pt && (Kt = Ge * St - ct * At, At = Ge * At + ct * St, St = Kt);
          }
    }, Tt.prototype.guessLen13b = function(We, Xe) {
      var rt = Math.max(Xe, We) | 1, ot = rt & 1, ft = 0;
      for (rt = rt / 2 | 0; rt; rt = rt >>> 1)
        ft++;
      return 1 << ft + 1 + ot;
    }, Tt.prototype.conjugate = function(We, Xe, rt) {
      if (!(rt <= 1))
        for (var ot = 0; ot < rt / 2; ot++) {
          var ft = We[ot];
          We[ot] = We[rt - ot - 1], We[rt - ot - 1] = ft, ft = Xe[ot], Xe[ot] = -Xe[rt - ot - 1], Xe[rt - ot - 1] = -ft;
        }
    }, Tt.prototype.normalize13b = function(We, Xe) {
      for (var rt = 0, ot = 0; ot < Xe / 2; ot++) {
        var ft = Math.round(We[2 * ot + 1] / Xe) * 8192 + Math.round(We[2 * ot] / Xe) + rt;
        We[ot] = ft & 67108863, ft < 67108864 ? rt = 0 : rt = ft / 67108864 | 0;
      }
      return We;
    }, Tt.prototype.convert13b = function(We, Xe, rt, ot) {
      for (var ft = 0, mt = 0; mt < Xe; mt++)
        ft = ft + (We[mt] | 0), rt[2 * mt] = ft & 8191, ft = ft >>> 13, rt[2 * mt + 1] = ft & 8191, ft = ft >>> 13;
      for (mt = 2 * Xe; mt < ot; ++mt)
        rt[mt] = 0;
      Fe(ft === 0), Fe((ft & -8192) === 0);
    }, Tt.prototype.stub = function(We) {
      for (var Xe = new Array(We), rt = 0; rt < We; rt++)
        Xe[rt] = 0;
      return Xe;
    }, Tt.prototype.mulp = function(We, Xe, rt) {
      var ot = 2 * this.guessLen13b(We.length, Xe.length), ft = this.makeRBT(ot), mt = this.stub(ot), yt = new Array(ot), pt = new Array(ot), Ge = new Array(ot), ct = new Array(ot), Mt = new Array(ot), St = new Array(ot), At = rt.words;
      At.length = ot, this.convert13b(We.words, We.length, yt, ot), this.convert13b(Xe.words, Xe.length, ct, ot), this.transform(yt, mt, pt, Ge, ot, ft), this.transform(ct, mt, Mt, St, ot, ft);
      for (var Nt = 0; Nt < ot; Nt++) {
        var qt = pt[Nt] * Mt[Nt] - Ge[Nt] * St[Nt];
        Ge[Nt] = pt[Nt] * St[Nt] + Ge[Nt] * Mt[Nt], pt[Nt] = qt;
      }
      return this.conjugate(pt, Ge, ot), this.transform(pt, Ge, At, mt, ot, ft), this.conjugate(At, mt, ot), this.normalize13b(At, ot), rt.negative = We.negative ^ Xe.negative, rt.length = We.length + Xe.length, rt.strip();
    }, Ve.prototype.mul = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$1$1).length + We.length), this.mulTo(We, Xe);
    }, Ve.prototype.mulf = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$1$1).length + We.length), Et(this || _global$1$1, We, Xe);
    }, Ve.prototype.imul = function(We) {
      return this.clone().mulTo(We, this || _global$1$1);
    }, Ve.prototype.imuln = function(We) {
      Fe(typeof We == "number"), Fe(We < 67108864);
      for (var Xe = 0, rt = 0; rt < (this || _global$1$1).length; rt++) {
        var ot = ((this || _global$1$1).words[rt] | 0) * We, ft = (ot & 67108863) + (Xe & 67108863);
        Xe >>= 26, Xe += ot / 67108864 | 0, Xe += ft >>> 26, (this || _global$1$1).words[rt] = ft & 67108863;
      }
      return Xe !== 0 && ((this || _global$1$1).words[rt] = Xe, (this || _global$1$1).length++), this || _global$1$1;
    }, Ve.prototype.muln = function(We) {
      return this.clone().imuln(We);
    }, Ve.prototype.sqr = function() {
      return this.mul(this || _global$1$1);
    }, Ve.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Ve.prototype.pow = function(We) {
      var Xe = $t(We);
      if (Xe.length === 0)
        return new Ve(1);
      for (var rt = this || _global$1$1, ot = 0; ot < Xe.length && Xe[ot] === 0; ot++, rt = rt.sqr())
        ;
      if (++ot < Xe.length)
        for (var ft = rt.sqr(); ot < Xe.length; ot++, ft = ft.sqr())
          Xe[ot] !== 0 && (rt = rt.mul(ft));
      return rt;
    }, Ve.prototype.iushln = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 67108863 >>> 26 - Xe << 26 - Xe, ft;
      if (Xe !== 0) {
        var mt = 0;
        for (ft = 0; ft < (this || _global$1$1).length; ft++) {
          var yt = (this || _global$1$1).words[ft] & ot, pt = ((this || _global$1$1).words[ft] | 0) - yt << Xe;
          (this || _global$1$1).words[ft] = pt | mt, mt = yt >>> 26 - Xe;
        }
        mt && ((this || _global$1$1).words[ft] = mt, (this || _global$1$1).length++);
      }
      if (rt !== 0) {
        for (ft = (this || _global$1$1).length - 1; ft >= 0; ft--)
          (this || _global$1$1).words[ft + rt] = (this || _global$1$1).words[ft];
        for (ft = 0; ft < rt; ft++)
          (this || _global$1$1).words[ft] = 0;
        (this || _global$1$1).length += rt;
      }
      return this.strip();
    }, Ve.prototype.ishln = function(We) {
      return Fe((this || _global$1$1).negative === 0), this.iushln(We);
    }, Ve.prototype.iushrn = function(We, Xe, rt) {
      Fe(typeof We == "number" && We >= 0);
      var ot;
      Xe ? ot = (Xe - Xe % 26) / 26 : ot = 0;
      var ft = We % 26, mt = Math.min((We - ft) / 26, (this || _global$1$1).length), yt = 67108863 ^ 67108863 >>> ft << ft, pt = rt;
      if (ot -= mt, ot = Math.max(0, ot), pt) {
        for (var Ge = 0; Ge < mt; Ge++)
          pt.words[Ge] = (this || _global$1$1).words[Ge];
        pt.length = mt;
      }
      if (mt !== 0)
        if ((this || _global$1$1).length > mt)
          for ((this || _global$1$1).length -= mt, Ge = 0; Ge < (this || _global$1$1).length; Ge++)
            (this || _global$1$1).words[Ge] = (this || _global$1$1).words[Ge + mt];
        else
          (this || _global$1$1).words[0] = 0, (this || _global$1$1).length = 1;
      var ct = 0;
      for (Ge = (this || _global$1$1).length - 1; Ge >= 0 && (ct !== 0 || Ge >= ot); Ge--) {
        var Mt = (this || _global$1$1).words[Ge] | 0;
        (this || _global$1$1).words[Ge] = ct << 26 - ft | Mt >>> ft, ct = Mt & yt;
      }
      return pt && ct !== 0 && (pt.words[pt.length++] = ct), (this || _global$1$1).length === 0 && ((this || _global$1$1).words[0] = 0, (this || _global$1$1).length = 1), this.strip();
    }, Ve.prototype.ishrn = function(We, Xe, rt) {
      return Fe((this || _global$1$1).negative === 0), this.iushrn(We, Xe, rt);
    }, Ve.prototype.shln = function(We) {
      return this.clone().ishln(We);
    }, Ve.prototype.ushln = function(We) {
      return this.clone().iushln(We);
    }, Ve.prototype.shrn = function(We) {
      return this.clone().ishrn(We);
    }, Ve.prototype.ushrn = function(We) {
      return this.clone().iushrn(We);
    }, Ve.prototype.testn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$1$1).length <= rt)
        return !1;
      var ft = (this || _global$1$1).words[rt];
      return !!(ft & ot);
    }, Ve.prototype.imaskn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26;
      if (Fe((this || _global$1$1).negative === 0, "imaskn works only with positive numbers"), (this || _global$1$1).length <= rt)
        return this || _global$1$1;
      if (Xe !== 0 && rt++, (this || _global$1$1).length = Math.min(rt, (this || _global$1$1).length), Xe !== 0) {
        var ot = 67108863 ^ 67108863 >>> Xe << Xe;
        (this || _global$1$1).words[(this || _global$1$1).length - 1] &= ot;
      }
      return this.strip();
    }, Ve.prototype.maskn = function(We) {
      return this.clone().imaskn(We);
    }, Ve.prototype.iaddn = function(We) {
      return Fe(typeof We == "number"), Fe(We < 67108864), We < 0 ? this.isubn(-We) : (this || _global$1$1).negative !== 0 ? (this || _global$1$1).length === 1 && ((this || _global$1$1).words[0] | 0) < We ? ((this || _global$1$1).words[0] = We - ((this || _global$1$1).words[0] | 0), (this || _global$1$1).negative = 0, this || _global$1$1) : ((this || _global$1$1).negative = 0, this.isubn(We), (this || _global$1$1).negative = 1, this || _global$1$1) : this._iaddn(We);
    }, Ve.prototype._iaddn = function(We) {
      (this || _global$1$1).words[0] += We;
      for (var Xe = 0; Xe < (this || _global$1$1).length && (this || _global$1$1).words[Xe] >= 67108864; Xe++)
        (this || _global$1$1).words[Xe] -= 67108864, Xe === (this || _global$1$1).length - 1 ? (this || _global$1$1).words[Xe + 1] = 1 : (this || _global$1$1).words[Xe + 1]++;
      return (this || _global$1$1).length = Math.max((this || _global$1$1).length, Xe + 1), this || _global$1$1;
    }, Ve.prototype.isubn = function(We) {
      if (Fe(typeof We == "number"), Fe(We < 67108864), We < 0)
        return this.iaddn(-We);
      if ((this || _global$1$1).negative !== 0)
        return (this || _global$1$1).negative = 0, this.iaddn(We), (this || _global$1$1).negative = 1, this || _global$1$1;
      if ((this || _global$1$1).words[0] -= We, (this || _global$1$1).length === 1 && (this || _global$1$1).words[0] < 0)
        (this || _global$1$1).words[0] = -(this || _global$1$1).words[0], (this || _global$1$1).negative = 1;
      else
        for (var Xe = 0; Xe < (this || _global$1$1).length && (this || _global$1$1).words[Xe] < 0; Xe++)
          (this || _global$1$1).words[Xe] += 67108864, (this || _global$1$1).words[Xe + 1] -= 1;
      return this.strip();
    }, Ve.prototype.addn = function(We) {
      return this.clone().iaddn(We);
    }, Ve.prototype.subn = function(We) {
      return this.clone().isubn(We);
    }, Ve.prototype.iabs = function() {
      return (this || _global$1$1).negative = 0, this || _global$1$1;
    }, Ve.prototype.abs = function() {
      return this.clone().iabs();
    }, Ve.prototype._ishlnsubmul = function(We, Xe, rt) {
      var ot = We.length + rt, ft;
      this._expand(ot);
      var mt, yt = 0;
      for (ft = 0; ft < We.length; ft++) {
        mt = ((this || _global$1$1).words[ft + rt] | 0) + yt;
        var pt = (We.words[ft] | 0) * Xe;
        mt -= pt & 67108863, yt = (mt >> 26) - (pt / 67108864 | 0), (this || _global$1$1).words[ft + rt] = mt & 67108863;
      }
      for (; ft < (this || _global$1$1).length - rt; ft++)
        mt = ((this || _global$1$1).words[ft + rt] | 0) + yt, yt = mt >> 26, (this || _global$1$1).words[ft + rt] = mt & 67108863;
      if (yt === 0)
        return this.strip();
      for (Fe(yt === -1), yt = 0, ft = 0; ft < (this || _global$1$1).length; ft++)
        mt = -((this || _global$1$1).words[ft] | 0) + yt, yt = mt >> 26, (this || _global$1$1).words[ft] = mt & 67108863;
      return (this || _global$1$1).negative = 1, this.strip();
    }, Ve.prototype._wordDiv = function(We, Xe) {
      var rt = (this || _global$1$1).length - We.length, ot = this.clone(), ft = We, mt = ft.words[ft.length - 1] | 0, yt = this._countBits(mt);
      rt = 26 - yt, rt !== 0 && (ft = ft.ushln(rt), ot.iushln(rt), mt = ft.words[ft.length - 1] | 0);
      var pt = ot.length - ft.length, Ge;
      if (Xe !== "mod") {
        Ge = new Ve(null), Ge.length = pt + 1, Ge.words = new Array(Ge.length);
        for (var ct = 0; ct < Ge.length; ct++)
          Ge.words[ct] = 0;
      }
      var Mt = ot.clone()._ishlnsubmul(ft, 1, pt);
      Mt.negative === 0 && (ot = Mt, Ge && (Ge.words[pt] = 1));
      for (var St = pt - 1; St >= 0; St--) {
        var At = (ot.words[ft.length + St] | 0) * 67108864 + (ot.words[ft.length + St - 1] | 0);
        for (At = Math.min(At / mt | 0, 67108863), ot._ishlnsubmul(ft, At, St); ot.negative !== 0; )
          At--, ot.negative = 0, ot._ishlnsubmul(ft, 1, St), ot.isZero() || (ot.negative ^= 1);
        Ge && (Ge.words[St] = At);
      }
      return Ge && Ge.strip(), ot.strip(), Xe !== "div" && rt !== 0 && ot.iushrn(rt), {
        div: Ge || null,
        mod: ot
      };
    }, Ve.prototype.divmod = function(We, Xe, rt) {
      if (Fe(!We.isZero()), this.isZero())
        return {
          div: new Ve(0),
          mod: new Ve(0)
        };
      var ot, ft, mt;
      return (this || _global$1$1).negative !== 0 && We.negative === 0 ? (mt = this.neg().divmod(We, Xe), Xe !== "mod" && (ot = mt.div.neg()), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.iadd(We)), {
        div: ot,
        mod: ft
      }) : (this || _global$1$1).negative === 0 && We.negative !== 0 ? (mt = this.divmod(We.neg(), Xe), Xe !== "mod" && (ot = mt.div.neg()), {
        div: ot,
        mod: mt.mod
      }) : (this || _global$1$1).negative & We.negative ? (mt = this.neg().divmod(We.neg(), Xe), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.isub(We)), {
        div: mt.div,
        mod: ft
      }) : We.length > (this || _global$1$1).length || this.cmp(We) < 0 ? {
        div: new Ve(0),
        mod: this || _global$1$1
      } : We.length === 1 ? Xe === "div" ? {
        div: this.divn(We.words[0]),
        mod: null
      } : Xe === "mod" ? {
        div: null,
        mod: new Ve(this.modn(We.words[0]))
      } : {
        div: this.divn(We.words[0]),
        mod: new Ve(this.modn(We.words[0]))
      } : this._wordDiv(We, Xe);
    }, Ve.prototype.div = function(We) {
      return this.divmod(We, "div", !1).div;
    }, Ve.prototype.mod = function(We) {
      return this.divmod(We, "mod", !1).mod;
    }, Ve.prototype.umod = function(We) {
      return this.divmod(We, "mod", !0).mod;
    }, Ve.prototype.divRound = function(We) {
      var Xe = this.divmod(We);
      if (Xe.mod.isZero())
        return Xe.div;
      var rt = Xe.div.negative !== 0 ? Xe.mod.isub(We) : Xe.mod, ot = We.ushrn(1), ft = We.andln(1), mt = rt.cmp(ot);
      return mt < 0 || ft === 1 && mt === 0 ? Xe.div : Xe.div.negative !== 0 ? Xe.div.isubn(1) : Xe.div.iaddn(1);
    }, Ve.prototype.modn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = (1 << 26) % We, rt = 0, ot = (this || _global$1$1).length - 1; ot >= 0; ot--)
        rt = (Xe * rt + ((this || _global$1$1).words[ot] | 0)) % We;
      return rt;
    }, Ve.prototype.idivn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = 0, rt = (this || _global$1$1).length - 1; rt >= 0; rt--) {
        var ot = ((this || _global$1$1).words[rt] | 0) + Xe * 67108864;
        (this || _global$1$1).words[rt] = ot / We | 0, Xe = ot % We;
      }
      return this.strip();
    }, Ve.prototype.divn = function(We) {
      return this.clone().idivn(We);
    }, Ve.prototype.egcd = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$1$1, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = new Ve(0), yt = new Ve(1), pt = 0; Xe.isEven() && rt.isEven(); )
        Xe.iushrn(1), rt.iushrn(1), ++pt;
      for (var Ge = rt.clone(), ct = Xe.clone(); !Xe.isZero(); ) {
        for (var Mt = 0, St = 1; !(Xe.words[0] & St) && Mt < 26; ++Mt, St <<= 1)
          ;
        if (Mt > 0)
          for (Xe.iushrn(Mt); Mt-- > 0; )
            (ot.isOdd() || ft.isOdd()) && (ot.iadd(Ge), ft.isub(ct)), ot.iushrn(1), ft.iushrn(1);
        for (var At = 0, Nt = 1; !(rt.words[0] & Nt) && At < 26; ++At, Nt <<= 1)
          ;
        if (At > 0)
          for (rt.iushrn(At); At-- > 0; )
            (mt.isOdd() || yt.isOdd()) && (mt.iadd(Ge), yt.isub(ct)), mt.iushrn(1), yt.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(mt), ft.isub(yt)) : (rt.isub(Xe), mt.isub(ot), yt.isub(ft));
      }
      return {
        a: mt,
        b: yt,
        gcd: rt.iushln(pt)
      };
    }, Ve.prototype._invmp = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$1$1, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = rt.clone(); Xe.cmpn(1) > 0 && rt.cmpn(1) > 0; ) {
        for (var yt = 0, pt = 1; !(Xe.words[0] & pt) && yt < 26; ++yt, pt <<= 1)
          ;
        if (yt > 0)
          for (Xe.iushrn(yt); yt-- > 0; )
            ot.isOdd() && ot.iadd(mt), ot.iushrn(1);
        for (var Ge = 0, ct = 1; !(rt.words[0] & ct) && Ge < 26; ++Ge, ct <<= 1)
          ;
        if (Ge > 0)
          for (rt.iushrn(Ge); Ge-- > 0; )
            ft.isOdd() && ft.iadd(mt), ft.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(ft)) : (rt.isub(Xe), ft.isub(ot));
      }
      var Mt;
      return Xe.cmpn(1) === 0 ? Mt = ot : Mt = ft, Mt.cmpn(0) < 0 && Mt.iadd(We), Mt;
    }, Ve.prototype.gcd = function(We) {
      if (this.isZero())
        return We.abs();
      if (We.isZero())
        return this.abs();
      var Xe = this.clone(), rt = We.clone();
      Xe.negative = 0, rt.negative = 0;
      for (var ot = 0; Xe.isEven() && rt.isEven(); ot++)
        Xe.iushrn(1), rt.iushrn(1);
      do {
        for (; Xe.isEven(); )
          Xe.iushrn(1);
        for (; rt.isEven(); )
          rt.iushrn(1);
        var ft = Xe.cmp(rt);
        if (ft < 0) {
          var mt = Xe;
          Xe = rt, rt = mt;
        } else if (ft === 0 || rt.cmpn(1) === 0)
          break;
        Xe.isub(rt);
      } while (!0);
      return rt.iushln(ot);
    }, Ve.prototype.invm = function(We) {
      return this.egcd(We).a.umod(We);
    }, Ve.prototype.isEven = function() {
      return ((this || _global$1$1).words[0] & 1) === 0;
    }, Ve.prototype.isOdd = function() {
      return ((this || _global$1$1).words[0] & 1) === 1;
    }, Ve.prototype.andln = function(We) {
      return (this || _global$1$1).words[0] & We;
    }, Ve.prototype.bincn = function(We) {
      Fe(typeof We == "number");
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$1$1).length <= rt)
        return this._expand(rt + 1), (this || _global$1$1).words[rt] |= ot, this || _global$1$1;
      for (var ft = ot, mt = rt; ft !== 0 && mt < (this || _global$1$1).length; mt++) {
        var yt = (this || _global$1$1).words[mt] | 0;
        yt += ft, ft = yt >>> 26, yt &= 67108863, (this || _global$1$1).words[mt] = yt;
      }
      return ft !== 0 && ((this || _global$1$1).words[mt] = ft, (this || _global$1$1).length++), this || _global$1$1;
    }, Ve.prototype.isZero = function() {
      return (this || _global$1$1).length === 1 && (this || _global$1$1).words[0] === 0;
    }, Ve.prototype.cmpn = function(We) {
      var Xe = We < 0;
      if ((this || _global$1$1).negative !== 0 && !Xe)
        return -1;
      if ((this || _global$1$1).negative === 0 && Xe)
        return 1;
      this.strip();
      var rt;
      if ((this || _global$1$1).length > 1)
        rt = 1;
      else {
        Xe && (We = -We), Fe(We <= 67108863, "Number is too big");
        var ot = (this || _global$1$1).words[0] | 0;
        rt = ot === We ? 0 : ot < We ? -1 : 1;
      }
      return (this || _global$1$1).negative !== 0 ? -rt | 0 : rt;
    }, Ve.prototype.cmp = function(We) {
      if ((this || _global$1$1).negative !== 0 && We.negative === 0)
        return -1;
      if ((this || _global$1$1).negative === 0 && We.negative !== 0)
        return 1;
      var Xe = this.ucmp(We);
      return (this || _global$1$1).negative !== 0 ? -Xe | 0 : Xe;
    }, Ve.prototype.ucmp = function(We) {
      if ((this || _global$1$1).length > We.length)
        return 1;
      if ((this || _global$1$1).length < We.length)
        return -1;
      for (var Xe = 0, rt = (this || _global$1$1).length - 1; rt >= 0; rt--) {
        var ot = (this || _global$1$1).words[rt] | 0, ft = We.words[rt] | 0;
        if (ot !== ft) {
          ot < ft ? Xe = -1 : ot > ft && (Xe = 1);
          break;
        }
      }
      return Xe;
    }, Ve.prototype.gtn = function(We) {
      return this.cmpn(We) === 1;
    }, Ve.prototype.gt = function(We) {
      return this.cmp(We) === 1;
    }, Ve.prototype.gten = function(We) {
      return this.cmpn(We) >= 0;
    }, Ve.prototype.gte = function(We) {
      return this.cmp(We) >= 0;
    }, Ve.prototype.ltn = function(We) {
      return this.cmpn(We) === -1;
    }, Ve.prototype.lt = function(We) {
      return this.cmp(We) === -1;
    }, Ve.prototype.lten = function(We) {
      return this.cmpn(We) <= 0;
    }, Ve.prototype.lte = function(We) {
      return this.cmp(We) <= 0;
    }, Ve.prototype.eqn = function(We) {
      return this.cmpn(We) === 0;
    }, Ve.prototype.eq = function(We) {
      return this.cmp(We) === 0;
    }, Ve.red = function(We) {
      return new Ot(We);
    }, Ve.prototype.toRed = function(We) {
      return Fe(!(this || _global$1$1).red, "Already a number in reduction context"), Fe((this || _global$1$1).negative === 0, "red works only with positives"), We.convertTo(this || _global$1$1)._forceRed(We);
    }, Ve.prototype.fromRed = function() {
      return Fe((this || _global$1$1).red, "fromRed works only with numbers in reduction context"), (this || _global$1$1).red.convertFrom(this || _global$1$1);
    }, Ve.prototype._forceRed = function(We) {
      return (this || _global$1$1).red = We, this || _global$1$1;
    }, Ve.prototype.forceRed = function(We) {
      return Fe(!(this || _global$1$1).red, "Already a number in reduction context"), this._forceRed(We);
    }, Ve.prototype.redAdd = function(We) {
      return Fe((this || _global$1$1).red, "redAdd works only with red numbers"), (this || _global$1$1).red.add(this || _global$1$1, We);
    }, Ve.prototype.redIAdd = function(We) {
      return Fe((this || _global$1$1).red, "redIAdd works only with red numbers"), (this || _global$1$1).red.iadd(this || _global$1$1, We);
    }, Ve.prototype.redSub = function(We) {
      return Fe((this || _global$1$1).red, "redSub works only with red numbers"), (this || _global$1$1).red.sub(this || _global$1$1, We);
    }, Ve.prototype.redISub = function(We) {
      return Fe((this || _global$1$1).red, "redISub works only with red numbers"), (this || _global$1$1).red.isub(this || _global$1$1, We);
    }, Ve.prototype.redShl = function(We) {
      return Fe((this || _global$1$1).red, "redShl works only with red numbers"), (this || _global$1$1).red.shl(this || _global$1$1, We);
    }, Ve.prototype.redMul = function(We) {
      return Fe((this || _global$1$1).red, "redMul works only with red numbers"), (this || _global$1$1).red._verify2(this || _global$1$1, We), (this || _global$1$1).red.mul(this || _global$1$1, We);
    }, Ve.prototype.redIMul = function(We) {
      return Fe((this || _global$1$1).red, "redMul works only with red numbers"), (this || _global$1$1).red._verify2(this || _global$1$1, We), (this || _global$1$1).red.imul(this || _global$1$1, We);
    }, Ve.prototype.redSqr = function() {
      return Fe((this || _global$1$1).red, "redSqr works only with red numbers"), (this || _global$1$1).red._verify1(this || _global$1$1), (this || _global$1$1).red.sqr(this || _global$1$1);
    }, Ve.prototype.redISqr = function() {
      return Fe((this || _global$1$1).red, "redISqr works only with red numbers"), (this || _global$1$1).red._verify1(this || _global$1$1), (this || _global$1$1).red.isqr(this || _global$1$1);
    }, Ve.prototype.redSqrt = function() {
      return Fe((this || _global$1$1).red, "redSqrt works only with red numbers"), (this || _global$1$1).red._verify1(this || _global$1$1), (this || _global$1$1).red.sqrt(this || _global$1$1);
    }, Ve.prototype.redInvm = function() {
      return Fe((this || _global$1$1).red, "redInvm works only with red numbers"), (this || _global$1$1).red._verify1(this || _global$1$1), (this || _global$1$1).red.invm(this || _global$1$1);
    }, Ve.prototype.redNeg = function() {
      return Fe((this || _global$1$1).red, "redNeg works only with red numbers"), (this || _global$1$1).red._verify1(this || _global$1$1), (this || _global$1$1).red.neg(this || _global$1$1);
    }, Ve.prototype.redPow = function(We) {
      return Fe((this || _global$1$1).red && !We.red, "redPow(normalNum)"), (this || _global$1$1).red._verify1(this || _global$1$1), (this || _global$1$1).red.pow(this || _global$1$1, We);
    };
    var Rt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ct(gt, We) {
      (this || _global$1$1).name = gt, (this || _global$1$1).p = new Ve(We, 16), (this || _global$1$1).n = (this || _global$1$1).p.bitLength(), (this || _global$1$1).k = new Ve(1).iushln((this || _global$1$1).n).isub((this || _global$1$1).p), (this || _global$1$1).tmp = this._tmp();
    }
    Ct.prototype._tmp = function() {
      var We = new Ve(null);
      return We.words = new Array(Math.ceil((this || _global$1$1).n / 13)), We;
    }, Ct.prototype.ireduce = function(We) {
      var Xe = We, rt;
      do
        this.split(Xe, (this || _global$1$1).tmp), Xe = this.imulK(Xe), Xe = Xe.iadd((this || _global$1$1).tmp), rt = Xe.bitLength();
      while (rt > (this || _global$1$1).n);
      var ot = rt < (this || _global$1$1).n ? -1 : Xe.ucmp((this || _global$1$1).p);
      return ot === 0 ? (Xe.words[0] = 0, Xe.length = 1) : ot > 0 ? Xe.isub((this || _global$1$1).p) : Xe.strip !== void 0 ? Xe.strip() : Xe._strip(), Xe;
    }, Ct.prototype.split = function(We, Xe) {
      We.iushrn((this || _global$1$1).n, 0, Xe);
    }, Ct.prototype.imulK = function(We) {
      return We.imul((this || _global$1$1).k);
    };
    function Zt() {
      Ct.call(this || _global$1$1, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    Ke(Zt, Ct), Zt.prototype.split = function(We, Xe) {
      for (var rt = 4194303, ot = Math.min(We.length, 9), ft = 0; ft < ot; ft++)
        Xe.words[ft] = We.words[ft];
      if (Xe.length = ot, We.length <= 9) {
        We.words[0] = 0, We.length = 1;
        return;
      }
      var mt = We.words[9];
      for (Xe.words[Xe.length++] = mt & rt, ft = 10; ft < We.length; ft++) {
        var yt = We.words[ft] | 0;
        We.words[ft - 10] = (yt & rt) << 4 | mt >>> 22, mt = yt;
      }
      mt >>>= 22, We.words[ft - 10] = mt, mt === 0 && We.length > 10 ? We.length -= 10 : We.length -= 9;
    }, Zt.prototype.imulK = function(We) {
      We.words[We.length] = 0, We.words[We.length + 1] = 0, We.length += 2;
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = We.words[rt] | 0;
        Xe += ot * 977, We.words[rt] = Xe & 67108863, Xe = ot * 64 + (Xe / 67108864 | 0);
      }
      return We.words[We.length - 1] === 0 && (We.length--, We.words[We.length - 1] === 0 && We.length--), We;
    };
    function Lt() {
      Ct.call(this || _global$1$1, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    Ke(Lt, Ct);
    function Ut() {
      Ct.call(this || _global$1$1, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    Ke(Ut, Ct);
    function Pt() {
      Ct.call(this || _global$1$1, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    Ke(Pt, Ct), Pt.prototype.imulK = function(We) {
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = (We.words[rt] | 0) * 19 + Xe, ft = ot & 67108863;
        ot >>>= 26, We.words[rt] = ft, Xe = ot;
      }
      return Xe !== 0 && (We.words[We.length++] = Xe), We;
    }, Ve._prime = function(We) {
      if (Rt[We])
        return Rt[We];
      var Xe;
      if (We === "k256")
        Xe = new Zt();
      else if (We === "p224")
        Xe = new Lt();
      else if (We === "p192")
        Xe = new Ut();
      else if (We === "p25519")
        Xe = new Pt();
      else
        throw new Error("Unknown prime " + We);
      return Rt[We] = Xe, Xe;
    };
    function Ot(gt) {
      if (typeof gt == "string") {
        var We = Ve._prime(gt);
        (this || _global$1$1).m = We.p, (this || _global$1$1).prime = We;
      } else
        Fe(gt.gtn(1), "modulus must be greater than 1"), (this || _global$1$1).m = gt, (this || _global$1$1).prime = null;
    }
    Ot.prototype._verify1 = function(We) {
      Fe(We.negative === 0, "red works only with positives"), Fe(We.red, "red works only with red numbers");
    }, Ot.prototype._verify2 = function(We, Xe) {
      Fe((We.negative | Xe.negative) === 0, "red works only with positives"), Fe(We.red && We.red === Xe.red, "red works only with red numbers");
    }, Ot.prototype.imod = function(We) {
      return (this || _global$1$1).prime ? (this || _global$1$1).prime.ireduce(We)._forceRed(this || _global$1$1) : We.umod((this || _global$1$1).m)._forceRed(this || _global$1$1);
    }, Ot.prototype.neg = function(We) {
      return We.isZero() ? We.clone() : (this || _global$1$1).m.sub(We)._forceRed(this || _global$1$1);
    }, Ot.prototype.add = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.add(Xe);
      return rt.cmp((this || _global$1$1).m) >= 0 && rt.isub((this || _global$1$1).m), rt._forceRed(this || _global$1$1);
    }, Ot.prototype.iadd = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.iadd(Xe);
      return rt.cmp((this || _global$1$1).m) >= 0 && rt.isub((this || _global$1$1).m), rt;
    }, Ot.prototype.sub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.sub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$1$1).m), rt._forceRed(this || _global$1$1);
    }, Ot.prototype.isub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.isub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$1$1).m), rt;
    }, Ot.prototype.shl = function(We, Xe) {
      return this._verify1(We), this.imod(We.ushln(Xe));
    }, Ot.prototype.imul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.imul(Xe));
    }, Ot.prototype.mul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.mul(Xe));
    }, Ot.prototype.isqr = function(We) {
      return this.imul(We, We.clone());
    }, Ot.prototype.sqr = function(We) {
      return this.mul(We, We);
    }, Ot.prototype.sqrt = function(We) {
      if (We.isZero())
        return We.clone();
      var Xe = (this || _global$1$1).m.andln(3);
      if (Fe(Xe % 2 === 1), Xe === 3) {
        var rt = (this || _global$1$1).m.add(new Ve(1)).iushrn(2);
        return this.pow(We, rt);
      }
      for (var ot = (this || _global$1$1).m.subn(1), ft = 0; !ot.isZero() && ot.andln(1) === 0; )
        ft++, ot.iushrn(1);
      Fe(!ot.isZero());
      var mt = new Ve(1).toRed(this || _global$1$1), yt = mt.redNeg(), pt = (this || _global$1$1).m.subn(1).iushrn(1), Ge = (this || _global$1$1).m.bitLength();
      for (Ge = new Ve(2 * Ge * Ge).toRed(this || _global$1$1); this.pow(Ge, pt).cmp(yt) !== 0; )
        Ge.redIAdd(yt);
      for (var ct = this.pow(Ge, ot), Mt = this.pow(We, ot.addn(1).iushrn(1)), St = this.pow(We, ot), At = ft; St.cmp(mt) !== 0; ) {
        for (var Nt = St, qt = 0; Nt.cmp(mt) !== 0; qt++)
          Nt = Nt.redSqr();
        Fe(qt < At);
        var Qt = this.pow(ct, new Ve(1).iushln(At - qt - 1));
        Mt = Mt.redMul(Qt), ct = Qt.redSqr(), St = St.redMul(ct), At = qt;
      }
      return Mt;
    }, Ot.prototype.invm = function(We) {
      var Xe = We._invmp((this || _global$1$1).m);
      return Xe.negative !== 0 ? (Xe.negative = 0, this.imod(Xe).redNeg()) : this.imod(Xe);
    }, Ot.prototype.pow = function(We, Xe) {
      if (Xe.isZero())
        return new Ve(1).toRed(this || _global$1$1);
      if (Xe.cmpn(1) === 0)
        return We.clone();
      var rt = 4, ot = new Array(1 << rt);
      ot[0] = new Ve(1).toRed(this || _global$1$1), ot[1] = We;
      for (var ft = 2; ft < ot.length; ft++)
        ot[ft] = this.mul(ot[ft - 1], We);
      var mt = ot[0], yt = 0, pt = 0, Ge = Xe.bitLength() % 26;
      for (Ge === 0 && (Ge = 26), ft = Xe.length - 1; ft >= 0; ft--) {
        for (var ct = Xe.words[ft], Mt = Ge - 1; Mt >= 0; Mt--) {
          var St = ct >> Mt & 1;
          if (mt !== ot[0] && (mt = this.sqr(mt)), St === 0 && yt === 0) {
            pt = 0;
            continue;
          }
          yt <<= 1, yt |= St, pt++, !(pt !== rt && (ft !== 0 || Mt !== 0)) && (mt = this.mul(mt, ot[yt]), pt = 0, yt = 0);
        }
        Ge = 26;
      }
      return mt;
    }, Ot.prototype.convertTo = function(We) {
      var Xe = We.umod((this || _global$1$1).m);
      return Xe === We ? Xe.clone() : Xe;
    }, Ot.prototype.convertFrom = function(We) {
      var Xe = We.clone();
      return Xe.red = null, Xe;
    }, Ve.mont = function(We) {
      return new Ft(We);
    };
    function Ft(gt) {
      Ot.call(this || _global$1$1, gt), (this || _global$1$1).shift = (this || _global$1$1).m.bitLength(), (this || _global$1$1).shift % 26 !== 0 && ((this || _global$1$1).shift += 26 - (this || _global$1$1).shift % 26), (this || _global$1$1).r = new Ve(1).iushln((this || _global$1$1).shift), (this || _global$1$1).r2 = this.imod((this || _global$1$1).r.sqr()), (this || _global$1$1).rinv = (this || _global$1$1).r._invmp((this || _global$1$1).m), (this || _global$1$1).minv = (this || _global$1$1).rinv.mul((this || _global$1$1).r).isubn(1).div((this || _global$1$1).m), (this || _global$1$1).minv = (this || _global$1$1).minv.umod((this || _global$1$1).r), (this || _global$1$1).minv = (this || _global$1$1).r.sub((this || _global$1$1).minv);
    }
    Ke(Ft, Ot), Ft.prototype.convertTo = function(We) {
      return this.imod(We.ushln((this || _global$1$1).shift));
    }, Ft.prototype.convertFrom = function(We) {
      var Xe = this.imod(We.mul((this || _global$1$1).rinv));
      return Xe.red = null, Xe;
    }, Ft.prototype.imul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return We.words[0] = 0, We.length = 1, We;
      var rt = We.imul(Xe), ot = rt.maskn((this || _global$1$1).shift).mul((this || _global$1$1).minv).imaskn((this || _global$1$1).shift).mul((this || _global$1$1).m), ft = rt.isub(ot).iushrn((this || _global$1$1).shift), mt = ft;
      return ft.cmp((this || _global$1$1).m) >= 0 ? mt = ft.isub((this || _global$1$1).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$1$1).m)), mt._forceRed(this || _global$1$1);
    }, Ft.prototype.mul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return new Ve(0)._forceRed(this || _global$1$1);
      var rt = We.mul(Xe), ot = rt.maskn((this || _global$1$1).shift).mul((this || _global$1$1).minv).imaskn((this || _global$1$1).shift).mul((this || _global$1$1).m), ft = rt.isub(ot).iushrn((this || _global$1$1).shift), mt = ft;
      return ft.cmp((this || _global$1$1).m) >= 0 ? mt = ft.isub((this || _global$1$1).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$1$1).m)), mt._forceRed(this || _global$1$1);
    }, Ft.prototype.invm = function(We) {
      var Xe = this.imod(We._invmp((this || _global$1$1).m).mul((this || _global$1$1).r2));
      return Xe._forceRed(this || _global$1$1);
    };
  }(module$8, exports$6$1)), module$8.exports;
}
var exports$5$1 = {}, _dewExec$5$1 = !1;
function dew$5$1() {
  if (_dewExec$5$1)
    return exports$5$1;
  _dewExec$5$1 = !0;
  var $e = dew$6$1(), Ze = dew$1T().Buffer;
  function Fe(Ke, Ve) {
    return Ze.from(Ke.toRed($e.mont(Ve.modulus)).redPow(new $e(Ve.publicExponent)).fromRed().toArray());
  }
  return exports$5$1 = Fe, exports$5$1;
}
var exports$4$1 = {}, _dewExec$4$1 = !1;
function dew$4$1() {
  if (_dewExec$4$1)
    return exports$4$1;
  _dewExec$4$1 = !0;
  var $e = dew$e$1(), Ze = dew$1S(), Fe = dew$1F(), Ke = dew$8$1(), Ve = dew$7$1(), Je = dew$6$1(), Qe = dew$5$1(), at = dew$W$1(), ut = dew$1T().Buffer;
  exports$4$1 = function(vt, wt, xt) {
    var Et;
    vt.padding ? Et = vt.padding : xt ? Et = 1 : Et = 4;
    var Tt = $e(vt), Rt;
    if (Et === 4)
      Rt = lt(Tt, wt);
    else if (Et === 1)
      Rt = dt(Tt, wt, xt);
    else if (Et === 3) {
      if (Rt = new Je(wt), Rt.cmp(Tt.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return xt ? at(Rt, Tt) : Qe(Rt, Tt);
  };
  function lt($t, vt) {
    var wt = $t.modulus.byteLength(), xt = vt.length, Et = Fe("sha1").update(ut.alloc(0)).digest(), Tt = Et.length, Rt = 2 * Tt;
    if (xt > wt - Rt - 2)
      throw new Error("message too long");
    var Ct = ut.alloc(wt - xt - Rt - 2), Zt = wt - Tt - 1, Lt = Ze(Tt), Ut = Ve(ut.concat([Et, Ct, ut.alloc(1, 1), vt], Zt), Ke(Lt, Zt)), Pt = Ve(Lt, Ke(Ut, Tt));
    return new Je(ut.concat([ut.alloc(1), Pt, Ut], wt));
  }
  function dt($t, vt, wt) {
    var xt = vt.length, Et = $t.modulus.byteLength();
    if (xt > Et - 11)
      throw new Error("message too long");
    var Tt;
    return wt ? Tt = ut.alloc(Et - xt - 3, 255) : Tt = bt(Et - xt - 3), new Je(ut.concat([ut.from([0, wt ? 1 : 2]), Tt, ut.alloc(1), vt], Et));
  }
  function bt($t) {
    for (var vt = ut.allocUnsafe($t), wt = 0, xt = Ze($t * 2), Et = 0, Tt; wt < $t; )
      Et === xt.length && (xt = Ze($t * 2), Et = 0), Tt = xt[Et++], Tt && (vt[wt++] = Tt);
    return vt;
  }
  return exports$4$1;
}
var exports$3$1 = {}, _dewExec$3$1 = !1;
function dew$3$1() {
  if (_dewExec$3$1)
    return exports$3$1;
  _dewExec$3$1 = !0;
  var $e = dew$e$1(), Ze = dew$8$1(), Fe = dew$7$1(), Ke = dew$6$1(), Ve = dew$W$1(), Je = dew$1F(), Qe = dew$5$1(), at = dew$1T().Buffer;
  exports$3$1 = function($t, vt, wt) {
    var xt;
    $t.padding ? xt = $t.padding : wt ? xt = 1 : xt = 4;
    var Et = $e($t), Tt = Et.modulus.byteLength();
    if (vt.length > Tt || new Ke(vt).cmp(Et.modulus) >= 0)
      throw new Error("decryption error");
    var Rt;
    wt ? Rt = Qe(new Ke(vt), Et) : Rt = Ve(vt, Et);
    var Ct = at.alloc(Tt - Rt.length);
    if (Rt = at.concat([Ct, Rt], Tt), xt === 4)
      return ut(Et, Rt);
    if (xt === 1)
      return lt(Et, Rt, wt);
    if (xt === 3)
      return Rt;
    throw new Error("unknown padding");
  };
  function ut(bt, $t) {
    var vt = bt.modulus.byteLength(), wt = Je("sha1").update(at.alloc(0)).digest(), xt = wt.length;
    if ($t[0] !== 0)
      throw new Error("decryption error");
    var Et = $t.slice(1, xt + 1), Tt = $t.slice(xt + 1), Rt = Fe(Et, Ze(Tt, xt)), Ct = Fe(Tt, Ze(Rt, vt - xt - 1));
    if (dt(wt, Ct.slice(0, xt)))
      throw new Error("decryption error");
    for (var Zt = xt; Ct[Zt] === 0; )
      Zt++;
    if (Ct[Zt++] !== 1)
      throw new Error("decryption error");
    return Ct.slice(Zt);
  }
  function lt(bt, $t, vt) {
    for (var wt = $t.slice(0, 2), xt = 2, Et = 0; $t[xt++] !== 0; )
      if (xt >= $t.length) {
        Et++;
        break;
      }
    var Tt = $t.slice(2, xt - 1);
    if ((wt.toString("hex") !== "0002" && !vt || wt.toString("hex") !== "0001" && vt) && Et++, Tt.length < 8 && Et++, Et)
      throw new Error("decryption error");
    return $t.slice(xt);
  }
  function dt(bt, $t) {
    bt = at.from(bt), $t = at.from($t);
    var vt = 0, wt = bt.length;
    bt.length !== $t.length && (vt++, wt = Math.min(bt.length, $t.length));
    for (var xt = -1; ++xt < wt; )
      vt += bt[xt] ^ $t[xt];
    return vt;
  }
  return exports$3$1;
}
var exports$2$12 = {}, _dewExec$2$12 = !1;
function dew$2$12() {
  return _dewExec$2$12 || (_dewExec$2$12 = !0, exports$2$12.publicEncrypt = dew$4$1(), exports$2$12.privateDecrypt = dew$3$1(), exports$2$12.privateEncrypt = function(Ze, Fe) {
    return exports$2$12.publicEncrypt(Ze, Fe, !0);
  }, exports$2$12.publicDecrypt = function(Ze, Fe) {
    return exports$2$12.privateDecrypt(Ze, Fe, !0);
  }), exports$2$12;
}
var exports$1$12 = {}, _dewExec$1$12 = !1, _global$x = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$1$12() {
  if (_dewExec$1$12)
    return exports$1$12;
  _dewExec$1$12 = !0;
  var $e = T;
  function Ze() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var Fe = dew$1T(), Ke = dew$1S(), Ve = Fe.Buffer, Je = Fe.kMaxLength, Qe = _global$x.crypto || _global$x.msCrypto, at = Math.pow(2, 32) - 1;
  function ut(vt, wt) {
    if (typeof vt != "number" || vt !== vt)
      throw new TypeError("offset must be a number");
    if (vt > at || vt < 0)
      throw new TypeError("offset must be a uint32");
    if (vt > Je || vt > wt)
      throw new RangeError("offset out of range");
  }
  function lt(vt, wt, xt) {
    if (typeof vt != "number" || vt !== vt)
      throw new TypeError("size must be a number");
    if (vt > at || vt < 0)
      throw new TypeError("size must be a uint32");
    if (vt + wt > xt || vt > Je)
      throw new RangeError("buffer too small");
  }
  Qe && Qe.getRandomValues || !$e.browser ? (exports$1$12.randomFill = dt, exports$1$12.randomFillSync = $t) : (exports$1$12.randomFill = Ze, exports$1$12.randomFillSync = Ze);
  function dt(vt, wt, xt, Et) {
    if (!Ve.isBuffer(vt) && !(vt instanceof _global$x.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof wt == "function")
      Et = wt, wt = 0, xt = vt.length;
    else if (typeof xt == "function")
      Et = xt, xt = vt.length - wt;
    else if (typeof Et != "function")
      throw new TypeError('"cb" argument must be a function');
    return ut(wt, vt.length), lt(xt, wt, vt.length), bt(vt, wt, xt, Et);
  }
  function bt(vt, wt, xt, Et) {
    if ($e.browser) {
      var Tt = vt.buffer, Rt = new Uint8Array(Tt, wt, xt);
      if (Qe.getRandomValues(Rt), Et) {
        $e.nextTick(function() {
          Et(null, vt);
        });
        return;
      }
      return vt;
    }
    if (Et) {
      Ke(xt, function(Zt, Lt) {
        if (Zt)
          return Et(Zt);
        Lt.copy(vt, wt), Et(null, vt);
      });
      return;
    }
    var Ct = Ke(xt);
    return Ct.copy(vt, wt), vt;
  }
  function $t(vt, wt, xt) {
    if (typeof wt > "u" && (wt = 0), !Ve.isBuffer(vt) && !(vt instanceof _global$x.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return ut(wt, vt.length), xt === void 0 && (xt = vt.length - wt), lt(xt, wt, vt.length), bt(vt, wt, xt);
  }
  return exports$1$12;
}
var exports$1V = {}, _dewExec$1U = !1;
function dew$1U() {
  if (_dewExec$1U)
    return exports$1V;
  _dewExec$1U = !0, exports$1V.randomBytes = exports$1V.rng = exports$1V.pseudoRandomBytes = exports$1V.prng = dew$1S(), exports$1V.createHash = exports$1V.Hash = dew$1F(), exports$1V.createHmac = exports$1V.Hmac = dew$1C();
  var $e = dew$1B(), Ze = Object.keys($e), Fe = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(Ze);
  exports$1V.getHashes = function() {
    return Fe;
  };
  var Ke = dew$1v();
  exports$1V.pbkdf2 = Ke.pbkdf2, exports$1V.pbkdf2Sync = Ke.pbkdf2Sync;
  var Ve = dew$13();
  exports$1V.Cipher = Ve.Cipher, exports$1V.createCipher = Ve.createCipher, exports$1V.Cipheriv = Ve.Cipheriv, exports$1V.createCipheriv = Ve.createCipheriv, exports$1V.Decipher = Ve.Decipher, exports$1V.createDecipher = Ve.createDecipher, exports$1V.Decipheriv = Ve.Decipheriv, exports$1V.createDecipheriv = Ve.createDecipheriv, exports$1V.getCiphers = Ve.getCiphers, exports$1V.listCiphers = Ve.listCiphers;
  var Je = dew$Y$1();
  exports$1V.DiffieHellmanGroup = Je.DiffieHellmanGroup, exports$1V.createDiffieHellmanGroup = Je.createDiffieHellmanGroup, exports$1V.getDiffieHellman = Je.getDiffieHellman, exports$1V.createDiffieHellman = Je.createDiffieHellman, exports$1V.DiffieHellman = Je.DiffieHellman;
  var Qe = dew$b$1();
  exports$1V.createSign = Qe.createSign, exports$1V.Sign = Qe.Sign, exports$1V.createVerify = Qe.createVerify, exports$1V.Verify = Qe.Verify, exports$1V.createECDH = dew$9$1();
  var at = dew$2$12();
  exports$1V.publicEncrypt = at.publicEncrypt, exports$1V.privateEncrypt = at.privateEncrypt, exports$1V.publicDecrypt = at.publicDecrypt, exports$1V.privateDecrypt = at.privateDecrypt;
  var ut = dew$1$12();
  return exports$1V.randomFill = ut.randomFill, exports$1V.randomFillSync = ut.randomFillSync, exports$1V.createCredentials = function() {
    throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
  }, exports$1V.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, exports$1V;
}
var crypto$1 = dew$1U();
crypto$1.Cipher;
crypto$1.Cipheriv;
crypto$1.Decipher;
crypto$1.Decipheriv;
crypto$1.DiffieHellman;
crypto$1.DiffieHellmanGroup;
crypto$1.Hash;
crypto$1.Hmac;
crypto$1.Sign;
crypto$1.Verify;
crypto$1.constants;
crypto$1.createCipher;
crypto$1.createCipheriv;
crypto$1.createCredentials;
crypto$1.createDecipher;
crypto$1.createDecipheriv;
crypto$1.createDiffieHellman;
crypto$1.createDiffieHellmanGroup;
crypto$1.createECDH;
crypto$1.createHash;
crypto$1.createHmac;
crypto$1.createSign;
crypto$1.createVerify;
crypto$1.getCiphers;
crypto$1.getDiffieHellman;
crypto$1.getHashes;
crypto$1.listCiphers;
crypto$1.pbkdf2;
crypto$1.pbkdf2Sync;
crypto$1.privateDecrypt;
crypto$1.privateEncrypt;
crypto$1.prng;
crypto$1.pseudoRandomBytes;
crypto$1.publicDecrypt;
crypto$1.publicEncrypt;
crypto$1.randomBytes;
crypto$1.randomFill;
crypto$1.randomFillSync;
crypto$1.rng;
var exports$122 = {}, _dewExec$11 = !1, _global$a = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$11() {
  if (_dewExec$11)
    return exports$122;
  _dewExec$11 = !0;
  var $e;
  exports$122 = function(Ve) {
    return $e || ($e = new Ze(null)), $e.generate(Ve);
  };
  function Ze(Ke) {
    (this || _global$a).rand = Ke;
  }
  if (exports$122.Rand = Ze, Ze.prototype.generate = function(Ve) {
    return this._rand(Ve);
  }, Ze.prototype._rand = function(Ve) {
    if ((this || _global$a).rand.getBytes)
      return (this || _global$a).rand.getBytes(Ve);
    for (var Je = new Uint8Array(Ve), Qe = 0; Qe < Je.length; Qe++)
      Je[Qe] = (this || _global$a).rand.getByte();
    return Je;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? Ze.prototype._rand = function(Ve) {
      var Je = new Uint8Array(Ve);
      return self.crypto.getRandomValues(Je), Je;
    } : self.msCrypto && self.msCrypto.getRandomValues ? Ze.prototype._rand = function(Ve) {
      var Je = new Uint8Array(Ve);
      return self.msCrypto.getRandomValues(Je), Je;
    } : typeof window == "object" && (Ze.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var Fe = crypto$1;
      if (typeof Fe.randomBytes != "function")
        throw new Error("Not supported");
      Ze.prototype._rand = function(Ve) {
        return Fe.randomBytes(Ve);
      };
    } catch {
    }
  return exports$122;
}
var exports$11 = {}, _dewExec$10 = !1, _global$9 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$10() {
  if (_dewExec$10)
    return exports$11;
  _dewExec$10 = !0;
  var $e = dew$1W(), Ze = dew$11();
  function Fe(Ke) {
    (this || _global$9).rand = Ke || new Ze.Rand();
  }
  return exports$11 = Fe, Fe.create = function(Ve) {
    return new Fe(Ve);
  }, Fe.prototype._randbelow = function(Ve) {
    var Je = Ve.bitLength(), Qe = Math.ceil(Je / 8);
    do
      var at = new $e((this || _global$9).rand.generate(Qe));
    while (at.cmp(Ve) >= 0);
    return at;
  }, Fe.prototype._randrange = function(Ve, Je) {
    var Qe = Je.sub(Ve);
    return Ve.add(this._randbelow(Qe));
  }, Fe.prototype.test = function(Ve, Je, Qe) {
    var at = Ve.bitLength(), ut = $e.mont(Ve), lt = new $e(1).toRed(ut);
    Je || (Je = Math.max(1, at / 48 | 0));
    for (var dt = Ve.subn(1), bt = 0; !dt.testn(bt); bt++)
      ;
    for (var $t = Ve.shrn(bt), vt = dt.toRed(ut), wt = !0; Je > 0; Je--) {
      var xt = this._randrange(new $e(2), dt);
      Qe && Qe(xt);
      var Et = xt.toRed(ut).redPow($t);
      if (!(Et.cmp(lt) === 0 || Et.cmp(vt) === 0)) {
        for (var Tt = 1; Tt < bt; Tt++) {
          if (Et = Et.redSqr(), Et.cmp(lt) === 0)
            return !1;
          if (Et.cmp(vt) === 0)
            break;
        }
        if (Tt === bt)
          return !1;
      }
    }
    return wt;
  }, Fe.prototype.getDivisor = function(Ve, Je) {
    var Qe = Ve.bitLength(), at = $e.mont(Ve), ut = new $e(1).toRed(at);
    Je || (Je = Math.max(1, Qe / 48 | 0));
    for (var lt = Ve.subn(1), dt = 0; !lt.testn(dt); dt++)
      ;
    for (var bt = Ve.shrn(dt), $t = lt.toRed(at); Je > 0; Je--) {
      var vt = this._randrange(new $e(2), lt), wt = Ve.gcd(vt);
      if (wt.cmpn(1) !== 0)
        return wt;
      var xt = vt.toRed(at).redPow(bt);
      if (!(xt.cmp(ut) === 0 || xt.cmp($t) === 0)) {
        for (var Et = 1; Et < dt; Et++) {
          if (xt = xt.redSqr(), xt.cmp(ut) === 0)
            return xt.fromRed().subn(1).gcd(Ve);
          if (xt.cmp($t) === 0)
            break;
        }
        if (Et === dt)
          return xt = xt.redSqr(), xt.fromRed().subn(1).gcd(Ve);
      }
    }
    return !1;
  }, exports$11;
}
var exports$10 = {}, _dewExec$$ = !1;
function dew$$() {
  if (_dewExec$$)
    return exports$10;
  _dewExec$$ = !0;
  var $e = dew$2O();
  exports$10 = Et, Et.simpleSieve = wt, Et.fermatTest = xt;
  var Ze = dew$1X(), Fe = new Ze(24), Ke = dew$10(), Ve = new Ke(), Je = new Ze(1), Qe = new Ze(2), at = new Ze(5);
  new Ze(16), new Ze(8);
  var ut = new Ze(10), lt = new Ze(3);
  new Ze(7);
  var dt = new Ze(11), bt = new Ze(4);
  new Ze(12);
  var $t = null;
  function vt() {
    if ($t !== null)
      return $t;
    var Tt = 1048576, Rt = [];
    Rt[0] = 2;
    for (var Ct = 1, Zt = 3; Zt < Tt; Zt += 2) {
      for (var Lt = Math.ceil(Math.sqrt(Zt)), Ut = 0; Ut < Ct && Rt[Ut] <= Lt && Zt % Rt[Ut] !== 0; Ut++)
        ;
      Ct !== Ut && Rt[Ut] <= Lt || (Rt[Ct++] = Zt);
    }
    return $t = Rt, Rt;
  }
  function wt(Tt) {
    for (var Rt = vt(), Ct = 0; Ct < Rt.length; Ct++)
      if (Tt.modn(Rt[Ct]) === 0)
        return Tt.cmpn(Rt[Ct]) === 0;
    return !0;
  }
  function xt(Tt) {
    var Rt = Ze.mont(Tt);
    return Qe.toRed(Rt).redPow(Tt.subn(1)).fromRed().cmpn(1) === 0;
  }
  function Et(Tt, Rt) {
    if (Tt < 16)
      return Rt === 2 || Rt === 5 ? new Ze([140, 123]) : new Ze([140, 39]);
    Rt = new Ze(Rt);
    for (var Ct, Zt; ; ) {
      for (Ct = new Ze($e(Math.ceil(Tt / 8))); Ct.bitLength() > Tt; )
        Ct.ishrn(1);
      if (Ct.isEven() && Ct.iadd(Je), Ct.testn(1) || Ct.iadd(Qe), Rt.cmp(Qe)) {
        if (!Rt.cmp(at))
          for (; Ct.mod(ut).cmp(lt); )
            Ct.iadd(bt);
      } else
        for (; Ct.mod(Fe).cmp(dt); )
          Ct.iadd(bt);
      if (Zt = Ct.shrn(1), wt(Zt) && wt(Ct) && xt(Zt) && xt(Ct) && Ve.test(Zt) && Ve.test(Ct))
        return Ct;
    }
  }
  return exports$10;
}
var _primes = {
  modp1: {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
  },
  modp2: {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
  },
  modp5: {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
  },
  modp14: {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
  },
  modp15: {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
  },
  modp16: {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
  },
  modp17: {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
  },
  modp18: {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
  }
}, exports$$ = {}, _dewExec$_ = !1, _global$8 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$_() {
  if (_dewExec$_)
    return exports$$;
  _dewExec$_ = !0;
  var $e = buffer.Buffer, Ze = dew$1X(), Fe = dew$10(), Ke = new Fe(), Ve = new Ze(24), Je = new Ze(11), Qe = new Ze(10), at = new Ze(3), ut = new Ze(7), lt = dew$$(), dt = dew$2O();
  exports$$ = xt;
  function bt(Tt, Rt) {
    return Rt = Rt || "utf8", $e.isBuffer(Tt) || (Tt = new $e(Tt, Rt)), (this || _global$8)._pub = new Ze(Tt), this || _global$8;
  }
  function $t(Tt, Rt) {
    return Rt = Rt || "utf8", $e.isBuffer(Tt) || (Tt = new $e(Tt, Rt)), (this || _global$8)._priv = new Ze(Tt), this || _global$8;
  }
  var vt = {};
  function wt(Tt, Rt) {
    var Ct = Rt.toString("hex"), Zt = [Ct, Tt.toString(16)].join("_");
    if (Zt in vt)
      return vt[Zt];
    var Lt = 0;
    if (Tt.isEven() || !lt.simpleSieve || !lt.fermatTest(Tt) || !Ke.test(Tt))
      return Lt += 1, Ct === "02" || Ct === "05" ? Lt += 8 : Lt += 4, vt[Zt] = Lt, Lt;
    Ke.test(Tt.shrn(1)) || (Lt += 2);
    var Ut;
    switch (Ct) {
      case "02":
        Tt.mod(Ve).cmp(Je) && (Lt += 8);
        break;
      case "05":
        Ut = Tt.mod(Qe), Ut.cmp(at) && Ut.cmp(ut) && (Lt += 8);
        break;
      default:
        Lt += 4;
    }
    return vt[Zt] = Lt, Lt;
  }
  function xt(Tt, Rt, Ct) {
    this.setGenerator(Rt), (this || _global$8).__prime = new Ze(Tt), (this || _global$8)._prime = Ze.mont((this || _global$8).__prime), (this || _global$8)._primeLen = Tt.length, (this || _global$8)._pub = void 0, (this || _global$8)._priv = void 0, (this || _global$8)._primeCode = void 0, Ct ? ((this || _global$8).setPublicKey = bt, (this || _global$8).setPrivateKey = $t) : (this || _global$8)._primeCode = 8;
  }
  Object.defineProperty(xt.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof (this || _global$8)._primeCode != "number" && ((this || _global$8)._primeCode = wt((this || _global$8).__prime, (this || _global$8).__gen)), (this || _global$8)._primeCode;
    }
  }), xt.prototype.generateKeys = function() {
    return (this || _global$8)._priv || ((this || _global$8)._priv = new Ze(dt((this || _global$8)._primeLen))), (this || _global$8)._pub = (this || _global$8)._gen.toRed((this || _global$8)._prime).redPow((this || _global$8)._priv).fromRed(), this.getPublicKey();
  }, xt.prototype.computeSecret = function(Tt) {
    Tt = new Ze(Tt), Tt = Tt.toRed((this || _global$8)._prime);
    var Rt = Tt.redPow((this || _global$8)._priv).fromRed(), Ct = new $e(Rt.toArray()), Zt = this.getPrime();
    if (Ct.length < Zt.length) {
      var Lt = new $e(Zt.length - Ct.length);
      Lt.fill(0), Ct = $e.concat([Lt, Ct]);
    }
    return Ct;
  }, xt.prototype.getPublicKey = function(Rt) {
    return Et((this || _global$8)._pub, Rt);
  }, xt.prototype.getPrivateKey = function(Rt) {
    return Et((this || _global$8)._priv, Rt);
  }, xt.prototype.getPrime = function(Tt) {
    return Et((this || _global$8).__prime, Tt);
  }, xt.prototype.getGenerator = function(Tt) {
    return Et((this || _global$8)._gen, Tt);
  }, xt.prototype.setGenerator = function(Tt, Rt) {
    return Rt = Rt || "utf8", $e.isBuffer(Tt) || (Tt = new $e(Tt, Rt)), (this || _global$8).__gen = Tt, (this || _global$8)._gen = new Ze(Tt), this || _global$8;
  };
  function Et(Tt, Rt) {
    var Ct = new $e(Tt.toArray());
    return Rt ? Ct.toString(Rt) : Ct;
  }
  return exports$$;
}
var exports$_ = {}, _dewExec$Z = !1;
function dew$Z() {
  if (_dewExec$Z)
    return exports$_;
  _dewExec$Z = !0;
  var $e = buffer.Buffer, Ze = dew$$(), Fe = _primes, Ke = dew$_();
  function Ve(at) {
    var ut = new $e(Fe[at].prime, "hex"), lt = new $e(Fe[at].gen, "hex");
    return new Ke(ut, lt);
  }
  var Je = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function Qe(at, ut, lt, dt) {
    return $e.isBuffer(ut) || Je[ut] === void 0 ? Qe(at, "binary", ut, lt) : (ut = ut || "binary", dt = dt || "binary", lt = lt || new $e([2]), $e.isBuffer(lt) || (lt = new $e(lt, dt)), typeof at == "number" ? new Ke(Ze(at, lt), lt, !0) : ($e.isBuffer(at) || (at = new $e(at, ut)), new Ke(at, lt, !0)));
  }
  return exports$_.DiffieHellmanGroup = exports$_.createDiffieHellmanGroup = exports$_.getDiffieHellman = Ve, exports$_.createDiffieHellman = exports$_.DiffieHellman = Qe, exports$_;
}
var exports$Z = {}, _dewExec$Y = !1;
function dew$Y() {
  if (_dewExec$Y)
    return exports$Z;
  _dewExec$Y = !0;
  var $e = buffer, Ze = $e.Buffer;
  function Fe(Ve, Je) {
    for (var Qe in Ve)
      Je[Qe] = Ve[Qe];
  }
  Ze.from && Ze.alloc && Ze.allocUnsafe && Ze.allocUnsafeSlow ? exports$Z = $e : (Fe($e, exports$Z), exports$Z.Buffer = Ke);
  function Ke(Ve, Je, Qe) {
    return Ze(Ve, Je, Qe);
  }
  return Ke.prototype = Object.create(Ze.prototype), Fe(Ze, Ke), Ke.from = function(Ve, Je, Qe) {
    if (typeof Ve == "number")
      throw new TypeError("Argument must not be a number");
    return Ze(Ve, Je, Qe);
  }, Ke.alloc = function(Ve, Je, Qe) {
    if (typeof Ve != "number")
      throw new TypeError("Argument must be a number");
    var at = Ze(Ve);
    return Je !== void 0 ? typeof Qe == "string" ? at.fill(Je, Qe) : at.fill(Je) : at.fill(0), at;
  }, Ke.allocUnsafe = function(Ve) {
    if (typeof Ve != "number")
      throw new TypeError("Argument must be a number");
    return Ze(Ve);
  }, Ke.allocUnsafeSlow = function(Ve) {
    if (typeof Ve != "number")
      throw new TypeError("Argument must be a number");
    return $e.SlowBuffer(Ve);
  }, exports$Z;
}
var exports$Y = {}, _dewExec$X = !1, module$4 = {
  exports: exports$Y
}, _global$7 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$X() {
  return _dewExec$X || (_dewExec$X = !0, function($e, Ze) {
    function Fe(Xe, rt) {
      if (!Xe)
        throw new Error(rt || "Assertion failed");
    }
    function Ke(Xe, rt) {
      Xe.super_ = rt;
      var ot = function() {
      };
      ot.prototype = rt.prototype, Xe.prototype = new ot(), Xe.prototype.constructor = Xe;
    }
    function Ve(Xe, rt, ot) {
      if (Ve.isBN(Xe))
        return Xe;
      (this || _global$7).negative = 0, (this || _global$7).words = null, (this || _global$7).length = 0, (this || _global$7).red = null, Xe !== null && ((rt === "le" || rt === "be") && (ot = rt, rt = 10), this._init(Xe || 0, rt || 10, ot || "be"));
    }
    typeof $e == "object" ? $e.exports = Ve : Ze.BN = Ve, Ve.BN = Ve, Ve.wordSize = 26;
    var Je;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Je = window.Buffer : Je = buffer.Buffer;
    } catch {
    }
    Ve.isBN = function(rt) {
      return rt instanceof Ve ? !0 : rt !== null && typeof rt == "object" && rt.constructor.wordSize === Ve.wordSize && Array.isArray(rt.words);
    }, Ve.max = function(rt, ot) {
      return rt.cmp(ot) > 0 ? rt : ot;
    }, Ve.min = function(rt, ot) {
      return rt.cmp(ot) < 0 ? rt : ot;
    }, Ve.prototype._init = function(rt, ot, ft) {
      if (typeof rt == "number")
        return this._initNumber(rt, ot, ft);
      if (typeof rt == "object")
        return this._initArray(rt, ot, ft);
      ot === "hex" && (ot = 16), Fe(ot === (ot | 0) && ot >= 2 && ot <= 36), rt = rt.toString().replace(/\s+/g, "");
      var mt = 0;
      rt[0] === "-" && (mt++, (this || _global$7).negative = 1), mt < rt.length && (ot === 16 ? this._parseHex(rt, mt, ft) : (this._parseBase(rt, ot, mt), ft === "le" && this._initArray(this.toArray(), ot, ft)));
    }, Ve.prototype._initNumber = function(rt, ot, ft) {
      rt < 0 && ((this || _global$7).negative = 1, rt = -rt), rt < 67108864 ? ((this || _global$7).words = [rt & 67108863], (this || _global$7).length = 1) : rt < 4503599627370496 ? ((this || _global$7).words = [rt & 67108863, rt / 67108864 & 67108863], (this || _global$7).length = 2) : (Fe(rt < 9007199254740992), (this || _global$7).words = [rt & 67108863, rt / 67108864 & 67108863, 1], (this || _global$7).length = 3), ft === "le" && this._initArray(this.toArray(), ot, ft);
    }, Ve.prototype._initArray = function(rt, ot, ft) {
      if (Fe(typeof rt.length == "number"), rt.length <= 0)
        return (this || _global$7).words = [0], (this || _global$7).length = 1, this || _global$7;
      (this || _global$7).length = Math.ceil(rt.length / 3), (this || _global$7).words = new Array((this || _global$7).length);
      for (var mt = 0; mt < (this || _global$7).length; mt++)
        (this || _global$7).words[mt] = 0;
      var yt, pt, Ge = 0;
      if (ft === "be")
        for (mt = rt.length - 1, yt = 0; mt >= 0; mt -= 3)
          pt = rt[mt] | rt[mt - 1] << 8 | rt[mt - 2] << 16, (this || _global$7).words[yt] |= pt << Ge & 67108863, (this || _global$7).words[yt + 1] = pt >>> 26 - Ge & 67108863, Ge += 24, Ge >= 26 && (Ge -= 26, yt++);
      else if (ft === "le")
        for (mt = 0, yt = 0; mt < rt.length; mt += 3)
          pt = rt[mt] | rt[mt + 1] << 8 | rt[mt + 2] << 16, (this || _global$7).words[yt] |= pt << Ge & 67108863, (this || _global$7).words[yt + 1] = pt >>> 26 - Ge & 67108863, Ge += 24, Ge >= 26 && (Ge -= 26, yt++);
      return this._strip();
    };
    function Qe(Xe, rt) {
      var ot = Xe.charCodeAt(rt);
      if (ot >= 48 && ot <= 57)
        return ot - 48;
      if (ot >= 65 && ot <= 70)
        return ot - 55;
      if (ot >= 97 && ot <= 102)
        return ot - 87;
      Fe(!1, "Invalid character in " + Xe);
    }
    function at(Xe, rt, ot) {
      var ft = Qe(Xe, ot);
      return ot - 1 >= rt && (ft |= Qe(Xe, ot - 1) << 4), ft;
    }
    Ve.prototype._parseHex = function(rt, ot, ft) {
      (this || _global$7).length = Math.ceil((rt.length - ot) / 6), (this || _global$7).words = new Array((this || _global$7).length);
      for (var mt = 0; mt < (this || _global$7).length; mt++)
        (this || _global$7).words[mt] = 0;
      var yt = 0, pt = 0, Ge;
      if (ft === "be")
        for (mt = rt.length - 1; mt >= ot; mt -= 2)
          Ge = at(rt, ot, mt) << yt, (this || _global$7).words[pt] |= Ge & 67108863, yt >= 18 ? (yt -= 18, pt += 1, (this || _global$7).words[pt] |= Ge >>> 26) : yt += 8;
      else {
        var ct = rt.length - ot;
        for (mt = ct % 2 === 0 ? ot + 1 : ot; mt < rt.length; mt += 2)
          Ge = at(rt, ot, mt) << yt, (this || _global$7).words[pt] |= Ge & 67108863, yt >= 18 ? (yt -= 18, pt += 1, (this || _global$7).words[pt] |= Ge >>> 26) : yt += 8;
      }
      this._strip();
    };
    function ut(Xe, rt, ot, ft) {
      for (var mt = 0, yt = 0, pt = Math.min(Xe.length, ot), Ge = rt; Ge < pt; Ge++) {
        var ct = Xe.charCodeAt(Ge) - 48;
        mt *= ft, ct >= 49 ? yt = ct - 49 + 10 : ct >= 17 ? yt = ct - 17 + 10 : yt = ct, Fe(ct >= 0 && yt < ft, "Invalid character"), mt += yt;
      }
      return mt;
    }
    Ve.prototype._parseBase = function(rt, ot, ft) {
      (this || _global$7).words = [0], (this || _global$7).length = 1;
      for (var mt = 0, yt = 1; yt <= 67108863; yt *= ot)
        mt++;
      mt--, yt = yt / ot | 0;
      for (var pt = rt.length - ft, Ge = pt % mt, ct = Math.min(pt, pt - Ge) + ft, Mt = 0, St = ft; St < ct; St += mt)
        Mt = ut(rt, St, St + mt, ot), this.imuln(yt), (this || _global$7).words[0] + Mt < 67108864 ? (this || _global$7).words[0] += Mt : this._iaddn(Mt);
      if (Ge !== 0) {
        var At = 1;
        for (Mt = ut(rt, St, rt.length, ot), St = 0; St < Ge; St++)
          At *= ot;
        this.imuln(At), (this || _global$7).words[0] + Mt < 67108864 ? (this || _global$7).words[0] += Mt : this._iaddn(Mt);
      }
      this._strip();
    }, Ve.prototype.copy = function(rt) {
      rt.words = new Array((this || _global$7).length);
      for (var ot = 0; ot < (this || _global$7).length; ot++)
        rt.words[ot] = (this || _global$7).words[ot];
      rt.length = (this || _global$7).length, rt.negative = (this || _global$7).negative, rt.red = (this || _global$7).red;
    };
    function lt(Xe, rt) {
      Xe.words = rt.words, Xe.length = rt.length, Xe.negative = rt.negative, Xe.red = rt.red;
    }
    if (Ve.prototype._move = function(rt) {
      lt(rt, this || _global$7);
    }, Ve.prototype.clone = function() {
      var rt = new Ve(null);
      return this.copy(rt), rt;
    }, Ve.prototype._expand = function(rt) {
      for (; (this || _global$7).length < rt; )
        (this || _global$7).words[(this || _global$7).length++] = 0;
      return this || _global$7;
    }, Ve.prototype._strip = function() {
      for (; (this || _global$7).length > 1 && (this || _global$7).words[(this || _global$7).length - 1] === 0; )
        (this || _global$7).length--;
      return this._normSign();
    }, Ve.prototype._normSign = function() {
      return (this || _global$7).length === 1 && (this || _global$7).words[0] === 0 && ((this || _global$7).negative = 0), this || _global$7;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        Ve.prototype[Symbol.for("nodejs.util.inspect.custom")] = dt;
      } catch {
        Ve.prototype.inspect = dt;
      }
    else
      Ve.prototype.inspect = dt;
    function dt() {
      return ((this || _global$7).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var bt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], $t = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], vt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    Ve.prototype.toString = function(rt, ot) {
      rt = rt || 10, ot = ot | 0 || 1;
      var ft;
      if (rt === 16 || rt === "hex") {
        ft = "";
        for (var mt = 0, yt = 0, pt = 0; pt < (this || _global$7).length; pt++) {
          var Ge = (this || _global$7).words[pt], ct = ((Ge << mt | yt) & 16777215).toString(16);
          yt = Ge >>> 24 - mt & 16777215, yt !== 0 || pt !== (this || _global$7).length - 1 ? ft = bt[6 - ct.length] + ct + ft : ft = ct + ft, mt += 2, mt >= 26 && (mt -= 26, pt--);
        }
        for (yt !== 0 && (ft = yt.toString(16) + ft); ft.length % ot !== 0; )
          ft = "0" + ft;
        return (this || _global$7).negative !== 0 && (ft = "-" + ft), ft;
      }
      if (rt === (rt | 0) && rt >= 2 && rt <= 36) {
        var Mt = $t[rt], St = vt[rt];
        ft = "";
        var At = this.clone();
        for (At.negative = 0; !At.isZero(); ) {
          var Nt = At.modrn(St).toString(rt);
          At = At.idivn(St), At.isZero() ? ft = Nt + ft : ft = bt[Mt - Nt.length] + Nt + ft;
        }
        for (this.isZero() && (ft = "0" + ft); ft.length % ot !== 0; )
          ft = "0" + ft;
        return (this || _global$7).negative !== 0 && (ft = "-" + ft), ft;
      }
      Fe(!1, "Base should be between 2 and 36");
    }, Ve.prototype.toNumber = function() {
      var rt = (this || _global$7).words[0];
      return (this || _global$7).length === 2 ? rt += (this || _global$7).words[1] * 67108864 : (this || _global$7).length === 3 && (this || _global$7).words[2] === 1 ? rt += 4503599627370496 + (this || _global$7).words[1] * 67108864 : (this || _global$7).length > 2 && Fe(!1, "Number can only safely store up to 53 bits"), (this || _global$7).negative !== 0 ? -rt : rt;
    }, Ve.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, Je && (Ve.prototype.toBuffer = function(rt, ot) {
      return this.toArrayLike(Je, rt, ot);
    }), Ve.prototype.toArray = function(rt, ot) {
      return this.toArrayLike(Array, rt, ot);
    };
    var wt = function(rt, ot) {
      return rt.allocUnsafe ? rt.allocUnsafe(ot) : new rt(ot);
    };
    Ve.prototype.toArrayLike = function(rt, ot, ft) {
      this._strip();
      var mt = this.byteLength(), yt = ft || Math.max(1, mt);
      Fe(mt <= yt, "byte array longer than desired length"), Fe(yt > 0, "Requested array length <= 0");
      var pt = wt(rt, yt), Ge = ot === "le" ? "LE" : "BE";
      return this["_toArrayLike" + Ge](pt, mt), pt;
    }, Ve.prototype._toArrayLikeLE = function(rt, ot) {
      for (var ft = 0, mt = 0, yt = 0, pt = 0; yt < (this || _global$7).length; yt++) {
        var Ge = (this || _global$7).words[yt] << pt | mt;
        rt[ft++] = Ge & 255, ft < rt.length && (rt[ft++] = Ge >> 8 & 255), ft < rt.length && (rt[ft++] = Ge >> 16 & 255), pt === 6 ? (ft < rt.length && (rt[ft++] = Ge >> 24 & 255), mt = 0, pt = 0) : (mt = Ge >>> 24, pt += 2);
      }
      if (ft < rt.length)
        for (rt[ft++] = mt; ft < rt.length; )
          rt[ft++] = 0;
    }, Ve.prototype._toArrayLikeBE = function(rt, ot) {
      for (var ft = rt.length - 1, mt = 0, yt = 0, pt = 0; yt < (this || _global$7).length; yt++) {
        var Ge = (this || _global$7).words[yt] << pt | mt;
        rt[ft--] = Ge & 255, ft >= 0 && (rt[ft--] = Ge >> 8 & 255), ft >= 0 && (rt[ft--] = Ge >> 16 & 255), pt === 6 ? (ft >= 0 && (rt[ft--] = Ge >> 24 & 255), mt = 0, pt = 0) : (mt = Ge >>> 24, pt += 2);
      }
      if (ft >= 0)
        for (rt[ft--] = mt; ft >= 0; )
          rt[ft--] = 0;
    }, Math.clz32 ? Ve.prototype._countBits = function(rt) {
      return 32 - Math.clz32(rt);
    } : Ve.prototype._countBits = function(rt) {
      var ot = rt, ft = 0;
      return ot >= 4096 && (ft += 13, ot >>>= 13), ot >= 64 && (ft += 7, ot >>>= 7), ot >= 8 && (ft += 4, ot >>>= 4), ot >= 2 && (ft += 2, ot >>>= 2), ft + ot;
    }, Ve.prototype._zeroBits = function(rt) {
      if (rt === 0)
        return 26;
      var ot = rt, ft = 0;
      return ot & 8191 || (ft += 13, ot >>>= 13), ot & 127 || (ft += 7, ot >>>= 7), ot & 15 || (ft += 4, ot >>>= 4), ot & 3 || (ft += 2, ot >>>= 2), ot & 1 || ft++, ft;
    }, Ve.prototype.bitLength = function() {
      var rt = (this || _global$7).words[(this || _global$7).length - 1], ot = this._countBits(rt);
      return ((this || _global$7).length - 1) * 26 + ot;
    };
    function xt(Xe) {
      for (var rt = new Array(Xe.bitLength()), ot = 0; ot < rt.length; ot++) {
        var ft = ot / 26 | 0, mt = ot % 26;
        rt[ot] = Xe.words[ft] >>> mt & 1;
      }
      return rt;
    }
    Ve.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var rt = 0, ot = 0; ot < (this || _global$7).length; ot++) {
        var ft = this._zeroBits((this || _global$7).words[ot]);
        if (rt += ft, ft !== 26)
          break;
      }
      return rt;
    }, Ve.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Ve.prototype.toTwos = function(rt) {
      return (this || _global$7).negative !== 0 ? this.abs().inotn(rt).iaddn(1) : this.clone();
    }, Ve.prototype.fromTwos = function(rt) {
      return this.testn(rt - 1) ? this.notn(rt).iaddn(1).ineg() : this.clone();
    }, Ve.prototype.isNeg = function() {
      return (this || _global$7).negative !== 0;
    }, Ve.prototype.neg = function() {
      return this.clone().ineg();
    }, Ve.prototype.ineg = function() {
      return this.isZero() || ((this || _global$7).negative ^= 1), this || _global$7;
    }, Ve.prototype.iuor = function(rt) {
      for (; (this || _global$7).length < rt.length; )
        (this || _global$7).words[(this || _global$7).length++] = 0;
      for (var ot = 0; ot < rt.length; ot++)
        (this || _global$7).words[ot] = (this || _global$7).words[ot] | rt.words[ot];
      return this._strip();
    }, Ve.prototype.ior = function(rt) {
      return Fe(((this || _global$7).negative | rt.negative) === 0), this.iuor(rt);
    }, Ve.prototype.or = function(rt) {
      return (this || _global$7).length > rt.length ? this.clone().ior(rt) : rt.clone().ior(this || _global$7);
    }, Ve.prototype.uor = function(rt) {
      return (this || _global$7).length > rt.length ? this.clone().iuor(rt) : rt.clone().iuor(this || _global$7);
    }, Ve.prototype.iuand = function(rt) {
      var ot;
      (this || _global$7).length > rt.length ? ot = rt : ot = this || _global$7;
      for (var ft = 0; ft < ot.length; ft++)
        (this || _global$7).words[ft] = (this || _global$7).words[ft] & rt.words[ft];
      return (this || _global$7).length = ot.length, this._strip();
    }, Ve.prototype.iand = function(rt) {
      return Fe(((this || _global$7).negative | rt.negative) === 0), this.iuand(rt);
    }, Ve.prototype.and = function(rt) {
      return (this || _global$7).length > rt.length ? this.clone().iand(rt) : rt.clone().iand(this || _global$7);
    }, Ve.prototype.uand = function(rt) {
      return (this || _global$7).length > rt.length ? this.clone().iuand(rt) : rt.clone().iuand(this || _global$7);
    }, Ve.prototype.iuxor = function(rt) {
      var ot, ft;
      (this || _global$7).length > rt.length ? (ot = this || _global$7, ft = rt) : (ot = rt, ft = this || _global$7);
      for (var mt = 0; mt < ft.length; mt++)
        (this || _global$7).words[mt] = ot.words[mt] ^ ft.words[mt];
      if ((this || _global$7) !== ot)
        for (; mt < ot.length; mt++)
          (this || _global$7).words[mt] = ot.words[mt];
      return (this || _global$7).length = ot.length, this._strip();
    }, Ve.prototype.ixor = function(rt) {
      return Fe(((this || _global$7).negative | rt.negative) === 0), this.iuxor(rt);
    }, Ve.prototype.xor = function(rt) {
      return (this || _global$7).length > rt.length ? this.clone().ixor(rt) : rt.clone().ixor(this || _global$7);
    }, Ve.prototype.uxor = function(rt) {
      return (this || _global$7).length > rt.length ? this.clone().iuxor(rt) : rt.clone().iuxor(this || _global$7);
    }, Ve.prototype.inotn = function(rt) {
      Fe(typeof rt == "number" && rt >= 0);
      var ot = Math.ceil(rt / 26) | 0, ft = rt % 26;
      this._expand(ot), ft > 0 && ot--;
      for (var mt = 0; mt < ot; mt++)
        (this || _global$7).words[mt] = ~(this || _global$7).words[mt] & 67108863;
      return ft > 0 && ((this || _global$7).words[mt] = ~(this || _global$7).words[mt] & 67108863 >> 26 - ft), this._strip();
    }, Ve.prototype.notn = function(rt) {
      return this.clone().inotn(rt);
    }, Ve.prototype.setn = function(rt, ot) {
      Fe(typeof rt == "number" && rt >= 0);
      var ft = rt / 26 | 0, mt = rt % 26;
      return this._expand(ft + 1), ot ? (this || _global$7).words[ft] = (this || _global$7).words[ft] | 1 << mt : (this || _global$7).words[ft] = (this || _global$7).words[ft] & ~(1 << mt), this._strip();
    }, Ve.prototype.iadd = function(rt) {
      var ot;
      if ((this || _global$7).negative !== 0 && rt.negative === 0)
        return (this || _global$7).negative = 0, ot = this.isub(rt), (this || _global$7).negative ^= 1, this._normSign();
      if ((this || _global$7).negative === 0 && rt.negative !== 0)
        return rt.negative = 0, ot = this.isub(rt), rt.negative = 1, ot._normSign();
      var ft, mt;
      (this || _global$7).length > rt.length ? (ft = this || _global$7, mt = rt) : (ft = rt, mt = this || _global$7);
      for (var yt = 0, pt = 0; pt < mt.length; pt++)
        ot = (ft.words[pt] | 0) + (mt.words[pt] | 0) + yt, (this || _global$7).words[pt] = ot & 67108863, yt = ot >>> 26;
      for (; yt !== 0 && pt < ft.length; pt++)
        ot = (ft.words[pt] | 0) + yt, (this || _global$7).words[pt] = ot & 67108863, yt = ot >>> 26;
      if ((this || _global$7).length = ft.length, yt !== 0)
        (this || _global$7).words[(this || _global$7).length] = yt, (this || _global$7).length++;
      else if (ft !== (this || _global$7))
        for (; pt < ft.length; pt++)
          (this || _global$7).words[pt] = ft.words[pt];
      return this || _global$7;
    }, Ve.prototype.add = function(rt) {
      var ot;
      return rt.negative !== 0 && (this || _global$7).negative === 0 ? (rt.negative = 0, ot = this.sub(rt), rt.negative ^= 1, ot) : rt.negative === 0 && (this || _global$7).negative !== 0 ? ((this || _global$7).negative = 0, ot = rt.sub(this || _global$7), (this || _global$7).negative = 1, ot) : (this || _global$7).length > rt.length ? this.clone().iadd(rt) : rt.clone().iadd(this || _global$7);
    }, Ve.prototype.isub = function(rt) {
      if (rt.negative !== 0) {
        rt.negative = 0;
        var ot = this.iadd(rt);
        return rt.negative = 1, ot._normSign();
      } else if ((this || _global$7).negative !== 0)
        return (this || _global$7).negative = 0, this.iadd(rt), (this || _global$7).negative = 1, this._normSign();
      var ft = this.cmp(rt);
      if (ft === 0)
        return (this || _global$7).negative = 0, (this || _global$7).length = 1, (this || _global$7).words[0] = 0, this || _global$7;
      var mt, yt;
      ft > 0 ? (mt = this || _global$7, yt = rt) : (mt = rt, yt = this || _global$7);
      for (var pt = 0, Ge = 0; Ge < yt.length; Ge++)
        ot = (mt.words[Ge] | 0) - (yt.words[Ge] | 0) + pt, pt = ot >> 26, (this || _global$7).words[Ge] = ot & 67108863;
      for (; pt !== 0 && Ge < mt.length; Ge++)
        ot = (mt.words[Ge] | 0) + pt, pt = ot >> 26, (this || _global$7).words[Ge] = ot & 67108863;
      if (pt === 0 && Ge < mt.length && mt !== (this || _global$7))
        for (; Ge < mt.length; Ge++)
          (this || _global$7).words[Ge] = mt.words[Ge];
      return (this || _global$7).length = Math.max((this || _global$7).length, Ge), mt !== (this || _global$7) && ((this || _global$7).negative = 1), this._strip();
    }, Ve.prototype.sub = function(rt) {
      return this.clone().isub(rt);
    };
    function Et(Xe, rt, ot) {
      ot.negative = rt.negative ^ Xe.negative;
      var ft = Xe.length + rt.length | 0;
      ot.length = ft, ft = ft - 1 | 0;
      var mt = Xe.words[0] | 0, yt = rt.words[0] | 0, pt = mt * yt, Ge = pt & 67108863, ct = pt / 67108864 | 0;
      ot.words[0] = Ge;
      for (var Mt = 1; Mt < ft; Mt++) {
        for (var St = ct >>> 26, At = ct & 67108863, Nt = Math.min(Mt, rt.length - 1), qt = Math.max(0, Mt - Xe.length + 1); qt <= Nt; qt++) {
          var Qt = Mt - qt | 0;
          mt = Xe.words[Qt] | 0, yt = rt.words[qt] | 0, pt = mt * yt + At, St += pt / 67108864 | 0, At = pt & 67108863;
        }
        ot.words[Mt] = At | 0, ct = St | 0;
      }
      return ct !== 0 ? ot.words[Mt] = ct | 0 : ot.length--, ot._strip();
    }
    var Tt = function(rt, ot, ft) {
      var mt = rt.words, yt = ot.words, pt = ft.words, Ge = 0, ct, Mt, St, At = mt[0] | 0, Nt = At & 8191, qt = At >>> 13, Qt = mt[1] | 0, Xt = Qt & 8191, zt = Qt >>> 13, Kt = mt[2] | 0, ur = Kt & 8191, er = Kt >>> 13, Dt = mt[3] | 0, Ht = Dt & 8191, Gt = Dt >>> 13, rr = mt[4] | 0, sr = rr & 8191, Jt = rr >>> 13, ir = mt[5] | 0, Br = ir & 8191, or = ir >>> 13, lr = mt[6] | 0, Nr = lr & 8191, dr = lr >>> 13, gr = mt[7] | 0, Zr = gr & 8191, Bt = gr >>> 13, kt = mt[8] | 0, It = kt & 8191, jt = kt >>> 13, Vt = mt[9] | 0, ar = Vt & 8191, Yt = Vt >>> 13, hr = yt[0] | 0, zr = hr & 8191, cr = hr >>> 13, _r = yt[1] | 0, Lr = _r & 8191, br = _r >>> 13, kr = yt[2] | 0, Xr = kr & 8191, yr = kr >>> 13, Ir = yt[3] | 0, Yr = Ir & 8191, wr = Ir >>> 13, Cr = yt[4] | 0, Hr = Cr & 8191, $r = Cr >>> 13, Ar = yt[5] | 0, Wr = Ar & 8191, mr = Ar >>> 13, Tr = yt[6] | 0, Kr = Tr & 8191, vr = Tr >>> 13, Rr = yt[7] | 0, Jr = Rr & 8191, xr = Rr >>> 13, tr = yt[8] | 0, Dr = tr & 8191, fr = tr >>> 13, Mr = yt[9] | 0, Fr = Mr & 8191, qr = Mr >>> 13;
      ft.negative = rt.negative ^ ot.negative, ft.length = 19, ct = Math.imul(Nt, zr), Mt = Math.imul(Nt, cr), Mt = Mt + Math.imul(qt, zr) | 0, St = Math.imul(qt, cr);
      var tn = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, ct = Math.imul(Xt, zr), Mt = Math.imul(Xt, cr), Mt = Mt + Math.imul(zt, zr) | 0, St = Math.imul(zt, cr), ct = ct + Math.imul(Nt, Lr) | 0, Mt = Mt + Math.imul(Nt, br) | 0, Mt = Mt + Math.imul(qt, Lr) | 0, St = St + Math.imul(qt, br) | 0;
      var Qr = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, ct = Math.imul(ur, zr), Mt = Math.imul(ur, cr), Mt = Mt + Math.imul(er, zr) | 0, St = Math.imul(er, cr), ct = ct + Math.imul(Xt, Lr) | 0, Mt = Mt + Math.imul(Xt, br) | 0, Mt = Mt + Math.imul(zt, Lr) | 0, St = St + Math.imul(zt, br) | 0, ct = ct + Math.imul(Nt, Xr) | 0, Mt = Mt + Math.imul(Nt, yr) | 0, Mt = Mt + Math.imul(qt, Xr) | 0, St = St + Math.imul(qt, yr) | 0;
      var nn = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, ct = Math.imul(Ht, zr), Mt = Math.imul(Ht, cr), Mt = Mt + Math.imul(Gt, zr) | 0, St = Math.imul(Gt, cr), ct = ct + Math.imul(ur, Lr) | 0, Mt = Mt + Math.imul(ur, br) | 0, Mt = Mt + Math.imul(er, Lr) | 0, St = St + Math.imul(er, br) | 0, ct = ct + Math.imul(Xt, Xr) | 0, Mt = Mt + Math.imul(Xt, yr) | 0, Mt = Mt + Math.imul(zt, Xr) | 0, St = St + Math.imul(zt, yr) | 0, ct = ct + Math.imul(Nt, Yr) | 0, Mt = Mt + Math.imul(Nt, wr) | 0, Mt = Mt + Math.imul(qt, Yr) | 0, St = St + Math.imul(qt, wr) | 0;
      var Er = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, ct = Math.imul(sr, zr), Mt = Math.imul(sr, cr), Mt = Mt + Math.imul(Jt, zr) | 0, St = Math.imul(Jt, cr), ct = ct + Math.imul(Ht, Lr) | 0, Mt = Mt + Math.imul(Ht, br) | 0, Mt = Mt + Math.imul(Gt, Lr) | 0, St = St + Math.imul(Gt, br) | 0, ct = ct + Math.imul(ur, Xr) | 0, Mt = Mt + Math.imul(ur, yr) | 0, Mt = Mt + Math.imul(er, Xr) | 0, St = St + Math.imul(er, yr) | 0, ct = ct + Math.imul(Xt, Yr) | 0, Mt = Mt + Math.imul(Xt, wr) | 0, Mt = Mt + Math.imul(zt, Yr) | 0, St = St + Math.imul(zt, wr) | 0, ct = ct + Math.imul(Nt, Hr) | 0, Mt = Mt + Math.imul(Nt, $r) | 0, Mt = Mt + Math.imul(qt, Hr) | 0, St = St + Math.imul(qt, $r) | 0;
      var Wt = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, ct = Math.imul(Br, zr), Mt = Math.imul(Br, cr), Mt = Mt + Math.imul(or, zr) | 0, St = Math.imul(or, cr), ct = ct + Math.imul(sr, Lr) | 0, Mt = Mt + Math.imul(sr, br) | 0, Mt = Mt + Math.imul(Jt, Lr) | 0, St = St + Math.imul(Jt, br) | 0, ct = ct + Math.imul(Ht, Xr) | 0, Mt = Mt + Math.imul(Ht, yr) | 0, Mt = Mt + Math.imul(Gt, Xr) | 0, St = St + Math.imul(Gt, yr) | 0, ct = ct + Math.imul(ur, Yr) | 0, Mt = Mt + Math.imul(ur, wr) | 0, Mt = Mt + Math.imul(er, Yr) | 0, St = St + Math.imul(er, wr) | 0, ct = ct + Math.imul(Xt, Hr) | 0, Mt = Mt + Math.imul(Xt, $r) | 0, Mt = Mt + Math.imul(zt, Hr) | 0, St = St + Math.imul(zt, $r) | 0, ct = ct + Math.imul(Nt, Wr) | 0, Mt = Mt + Math.imul(Nt, mr) | 0, Mt = Mt + Math.imul(qt, Wr) | 0, St = St + Math.imul(qt, mr) | 0;
      var nr = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, ct = Math.imul(Nr, zr), Mt = Math.imul(Nr, cr), Mt = Mt + Math.imul(dr, zr) | 0, St = Math.imul(dr, cr), ct = ct + Math.imul(Br, Lr) | 0, Mt = Mt + Math.imul(Br, br) | 0, Mt = Mt + Math.imul(or, Lr) | 0, St = St + Math.imul(or, br) | 0, ct = ct + Math.imul(sr, Xr) | 0, Mt = Mt + Math.imul(sr, yr) | 0, Mt = Mt + Math.imul(Jt, Xr) | 0, St = St + Math.imul(Jt, yr) | 0, ct = ct + Math.imul(Ht, Yr) | 0, Mt = Mt + Math.imul(Ht, wr) | 0, Mt = Mt + Math.imul(Gt, Yr) | 0, St = St + Math.imul(Gt, wr) | 0, ct = ct + Math.imul(ur, Hr) | 0, Mt = Mt + Math.imul(ur, $r) | 0, Mt = Mt + Math.imul(er, Hr) | 0, St = St + Math.imul(er, $r) | 0, ct = ct + Math.imul(Xt, Wr) | 0, Mt = Mt + Math.imul(Xt, mr) | 0, Mt = Mt + Math.imul(zt, Wr) | 0, St = St + Math.imul(zt, mr) | 0, ct = ct + Math.imul(Nt, Kr) | 0, Mt = Mt + Math.imul(Nt, vr) | 0, Mt = Mt + Math.imul(qt, Kr) | 0, St = St + Math.imul(qt, vr) | 0;
      var pr = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, ct = Math.imul(Zr, zr), Mt = Math.imul(Zr, cr), Mt = Mt + Math.imul(Bt, zr) | 0, St = Math.imul(Bt, cr), ct = ct + Math.imul(Nr, Lr) | 0, Mt = Mt + Math.imul(Nr, br) | 0, Mt = Mt + Math.imul(dr, Lr) | 0, St = St + Math.imul(dr, br) | 0, ct = ct + Math.imul(Br, Xr) | 0, Mt = Mt + Math.imul(Br, yr) | 0, Mt = Mt + Math.imul(or, Xr) | 0, St = St + Math.imul(or, yr) | 0, ct = ct + Math.imul(sr, Yr) | 0, Mt = Mt + Math.imul(sr, wr) | 0, Mt = Mt + Math.imul(Jt, Yr) | 0, St = St + Math.imul(Jt, wr) | 0, ct = ct + Math.imul(Ht, Hr) | 0, Mt = Mt + Math.imul(Ht, $r) | 0, Mt = Mt + Math.imul(Gt, Hr) | 0, St = St + Math.imul(Gt, $r) | 0, ct = ct + Math.imul(ur, Wr) | 0, Mt = Mt + Math.imul(ur, mr) | 0, Mt = Mt + Math.imul(er, Wr) | 0, St = St + Math.imul(er, mr) | 0, ct = ct + Math.imul(Xt, Kr) | 0, Mt = Mt + Math.imul(Xt, vr) | 0, Mt = Mt + Math.imul(zt, Kr) | 0, St = St + Math.imul(zt, vr) | 0, ct = ct + Math.imul(Nt, Jr) | 0, Mt = Mt + Math.imul(Nt, xr) | 0, Mt = Mt + Math.imul(qt, Jr) | 0, St = St + Math.imul(qt, xr) | 0;
      var Pr = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, ct = Math.imul(It, zr), Mt = Math.imul(It, cr), Mt = Mt + Math.imul(jt, zr) | 0, St = Math.imul(jt, cr), ct = ct + Math.imul(Zr, Lr) | 0, Mt = Mt + Math.imul(Zr, br) | 0, Mt = Mt + Math.imul(Bt, Lr) | 0, St = St + Math.imul(Bt, br) | 0, ct = ct + Math.imul(Nr, Xr) | 0, Mt = Mt + Math.imul(Nr, yr) | 0, Mt = Mt + Math.imul(dr, Xr) | 0, St = St + Math.imul(dr, yr) | 0, ct = ct + Math.imul(Br, Yr) | 0, Mt = Mt + Math.imul(Br, wr) | 0, Mt = Mt + Math.imul(or, Yr) | 0, St = St + Math.imul(or, wr) | 0, ct = ct + Math.imul(sr, Hr) | 0, Mt = Mt + Math.imul(sr, $r) | 0, Mt = Mt + Math.imul(Jt, Hr) | 0, St = St + Math.imul(Jt, $r) | 0, ct = ct + Math.imul(Ht, Wr) | 0, Mt = Mt + Math.imul(Ht, mr) | 0, Mt = Mt + Math.imul(Gt, Wr) | 0, St = St + Math.imul(Gt, mr) | 0, ct = ct + Math.imul(ur, Kr) | 0, Mt = Mt + Math.imul(ur, vr) | 0, Mt = Mt + Math.imul(er, Kr) | 0, St = St + Math.imul(er, vr) | 0, ct = ct + Math.imul(Xt, Jr) | 0, Mt = Mt + Math.imul(Xt, xr) | 0, Mt = Mt + Math.imul(zt, Jr) | 0, St = St + Math.imul(zt, xr) | 0, ct = ct + Math.imul(Nt, Dr) | 0, Mt = Mt + Math.imul(Nt, fr) | 0, Mt = Mt + Math.imul(qt, Dr) | 0, St = St + Math.imul(qt, fr) | 0;
      var Sr = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, ct = Math.imul(ar, zr), Mt = Math.imul(ar, cr), Mt = Mt + Math.imul(Yt, zr) | 0, St = Math.imul(Yt, cr), ct = ct + Math.imul(It, Lr) | 0, Mt = Mt + Math.imul(It, br) | 0, Mt = Mt + Math.imul(jt, Lr) | 0, St = St + Math.imul(jt, br) | 0, ct = ct + Math.imul(Zr, Xr) | 0, Mt = Mt + Math.imul(Zr, yr) | 0, Mt = Mt + Math.imul(Bt, Xr) | 0, St = St + Math.imul(Bt, yr) | 0, ct = ct + Math.imul(Nr, Yr) | 0, Mt = Mt + Math.imul(Nr, wr) | 0, Mt = Mt + Math.imul(dr, Yr) | 0, St = St + Math.imul(dr, wr) | 0, ct = ct + Math.imul(Br, Hr) | 0, Mt = Mt + Math.imul(Br, $r) | 0, Mt = Mt + Math.imul(or, Hr) | 0, St = St + Math.imul(or, $r) | 0, ct = ct + Math.imul(sr, Wr) | 0, Mt = Mt + Math.imul(sr, mr) | 0, Mt = Mt + Math.imul(Jt, Wr) | 0, St = St + Math.imul(Jt, mr) | 0, ct = ct + Math.imul(Ht, Kr) | 0, Mt = Mt + Math.imul(Ht, vr) | 0, Mt = Mt + Math.imul(Gt, Kr) | 0, St = St + Math.imul(Gt, vr) | 0, ct = ct + Math.imul(ur, Jr) | 0, Mt = Mt + Math.imul(ur, xr) | 0, Mt = Mt + Math.imul(er, Jr) | 0, St = St + Math.imul(er, xr) | 0, ct = ct + Math.imul(Xt, Dr) | 0, Mt = Mt + Math.imul(Xt, fr) | 0, Mt = Mt + Math.imul(zt, Dr) | 0, St = St + Math.imul(zt, fr) | 0, ct = ct + Math.imul(Nt, Fr) | 0, Mt = Mt + Math.imul(Nt, qr) | 0, Mt = Mt + Math.imul(qt, Fr) | 0, St = St + Math.imul(qt, qr) | 0;
      var Ur = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, ct = Math.imul(ar, Lr), Mt = Math.imul(ar, br), Mt = Mt + Math.imul(Yt, Lr) | 0, St = Math.imul(Yt, br), ct = ct + Math.imul(It, Xr) | 0, Mt = Mt + Math.imul(It, yr) | 0, Mt = Mt + Math.imul(jt, Xr) | 0, St = St + Math.imul(jt, yr) | 0, ct = ct + Math.imul(Zr, Yr) | 0, Mt = Mt + Math.imul(Zr, wr) | 0, Mt = Mt + Math.imul(Bt, Yr) | 0, St = St + Math.imul(Bt, wr) | 0, ct = ct + Math.imul(Nr, Hr) | 0, Mt = Mt + Math.imul(Nr, $r) | 0, Mt = Mt + Math.imul(dr, Hr) | 0, St = St + Math.imul(dr, $r) | 0, ct = ct + Math.imul(Br, Wr) | 0, Mt = Mt + Math.imul(Br, mr) | 0, Mt = Mt + Math.imul(or, Wr) | 0, St = St + Math.imul(or, mr) | 0, ct = ct + Math.imul(sr, Kr) | 0, Mt = Mt + Math.imul(sr, vr) | 0, Mt = Mt + Math.imul(Jt, Kr) | 0, St = St + Math.imul(Jt, vr) | 0, ct = ct + Math.imul(Ht, Jr) | 0, Mt = Mt + Math.imul(Ht, xr) | 0, Mt = Mt + Math.imul(Gt, Jr) | 0, St = St + Math.imul(Gt, xr) | 0, ct = ct + Math.imul(ur, Dr) | 0, Mt = Mt + Math.imul(ur, fr) | 0, Mt = Mt + Math.imul(er, Dr) | 0, St = St + Math.imul(er, fr) | 0, ct = ct + Math.imul(Xt, Fr) | 0, Mt = Mt + Math.imul(Xt, qr) | 0, Mt = Mt + Math.imul(zt, Fr) | 0, St = St + Math.imul(zt, qr) | 0;
      var jr = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, ct = Math.imul(ar, Xr), Mt = Math.imul(ar, yr), Mt = Mt + Math.imul(Yt, Xr) | 0, St = Math.imul(Yt, yr), ct = ct + Math.imul(It, Yr) | 0, Mt = Mt + Math.imul(It, wr) | 0, Mt = Mt + Math.imul(jt, Yr) | 0, St = St + Math.imul(jt, wr) | 0, ct = ct + Math.imul(Zr, Hr) | 0, Mt = Mt + Math.imul(Zr, $r) | 0, Mt = Mt + Math.imul(Bt, Hr) | 0, St = St + Math.imul(Bt, $r) | 0, ct = ct + Math.imul(Nr, Wr) | 0, Mt = Mt + Math.imul(Nr, mr) | 0, Mt = Mt + Math.imul(dr, Wr) | 0, St = St + Math.imul(dr, mr) | 0, ct = ct + Math.imul(Br, Kr) | 0, Mt = Mt + Math.imul(Br, vr) | 0, Mt = Mt + Math.imul(or, Kr) | 0, St = St + Math.imul(or, vr) | 0, ct = ct + Math.imul(sr, Jr) | 0, Mt = Mt + Math.imul(sr, xr) | 0, Mt = Mt + Math.imul(Jt, Jr) | 0, St = St + Math.imul(Jt, xr) | 0, ct = ct + Math.imul(Ht, Dr) | 0, Mt = Mt + Math.imul(Ht, fr) | 0, Mt = Mt + Math.imul(Gt, Dr) | 0, St = St + Math.imul(Gt, fr) | 0, ct = ct + Math.imul(ur, Fr) | 0, Mt = Mt + Math.imul(ur, qr) | 0, Mt = Mt + Math.imul(er, Fr) | 0, St = St + Math.imul(er, qr) | 0;
      var Gr = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, ct = Math.imul(ar, Yr), Mt = Math.imul(ar, wr), Mt = Mt + Math.imul(Yt, Yr) | 0, St = Math.imul(Yt, wr), ct = ct + Math.imul(It, Hr) | 0, Mt = Mt + Math.imul(It, $r) | 0, Mt = Mt + Math.imul(jt, Hr) | 0, St = St + Math.imul(jt, $r) | 0, ct = ct + Math.imul(Zr, Wr) | 0, Mt = Mt + Math.imul(Zr, mr) | 0, Mt = Mt + Math.imul(Bt, Wr) | 0, St = St + Math.imul(Bt, mr) | 0, ct = ct + Math.imul(Nr, Kr) | 0, Mt = Mt + Math.imul(Nr, vr) | 0, Mt = Mt + Math.imul(dr, Kr) | 0, St = St + Math.imul(dr, vr) | 0, ct = ct + Math.imul(Br, Jr) | 0, Mt = Mt + Math.imul(Br, xr) | 0, Mt = Mt + Math.imul(or, Jr) | 0, St = St + Math.imul(or, xr) | 0, ct = ct + Math.imul(sr, Dr) | 0, Mt = Mt + Math.imul(sr, fr) | 0, Mt = Mt + Math.imul(Jt, Dr) | 0, St = St + Math.imul(Jt, fr) | 0, ct = ct + Math.imul(Ht, Fr) | 0, Mt = Mt + Math.imul(Ht, qr) | 0, Mt = Mt + Math.imul(Gt, Fr) | 0, St = St + Math.imul(Gt, qr) | 0;
      var Vr = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, ct = Math.imul(ar, Hr), Mt = Math.imul(ar, $r), Mt = Mt + Math.imul(Yt, Hr) | 0, St = Math.imul(Yt, $r), ct = ct + Math.imul(It, Wr) | 0, Mt = Mt + Math.imul(It, mr) | 0, Mt = Mt + Math.imul(jt, Wr) | 0, St = St + Math.imul(jt, mr) | 0, ct = ct + Math.imul(Zr, Kr) | 0, Mt = Mt + Math.imul(Zr, vr) | 0, Mt = Mt + Math.imul(Bt, Kr) | 0, St = St + Math.imul(Bt, vr) | 0, ct = ct + Math.imul(Nr, Jr) | 0, Mt = Mt + Math.imul(Nr, xr) | 0, Mt = Mt + Math.imul(dr, Jr) | 0, St = St + Math.imul(dr, xr) | 0, ct = ct + Math.imul(Br, Dr) | 0, Mt = Mt + Math.imul(Br, fr) | 0, Mt = Mt + Math.imul(or, Dr) | 0, St = St + Math.imul(or, fr) | 0, ct = ct + Math.imul(sr, Fr) | 0, Mt = Mt + Math.imul(sr, qr) | 0, Mt = Mt + Math.imul(Jt, Fr) | 0, St = St + Math.imul(Jt, qr) | 0;
      var rn = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, ct = Math.imul(ar, Wr), Mt = Math.imul(ar, mr), Mt = Mt + Math.imul(Yt, Wr) | 0, St = Math.imul(Yt, mr), ct = ct + Math.imul(It, Kr) | 0, Mt = Mt + Math.imul(It, vr) | 0, Mt = Mt + Math.imul(jt, Kr) | 0, St = St + Math.imul(jt, vr) | 0, ct = ct + Math.imul(Zr, Jr) | 0, Mt = Mt + Math.imul(Zr, xr) | 0, Mt = Mt + Math.imul(Bt, Jr) | 0, St = St + Math.imul(Bt, xr) | 0, ct = ct + Math.imul(Nr, Dr) | 0, Mt = Mt + Math.imul(Nr, fr) | 0, Mt = Mt + Math.imul(dr, Dr) | 0, St = St + Math.imul(dr, fr) | 0, ct = ct + Math.imul(Br, Fr) | 0, Mt = Mt + Math.imul(Br, qr) | 0, Mt = Mt + Math.imul(or, Fr) | 0, St = St + Math.imul(or, qr) | 0;
      var an = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, ct = Math.imul(ar, Kr), Mt = Math.imul(ar, vr), Mt = Mt + Math.imul(Yt, Kr) | 0, St = Math.imul(Yt, vr), ct = ct + Math.imul(It, Jr) | 0, Mt = Mt + Math.imul(It, xr) | 0, Mt = Mt + Math.imul(jt, Jr) | 0, St = St + Math.imul(jt, xr) | 0, ct = ct + Math.imul(Zr, Dr) | 0, Mt = Mt + Math.imul(Zr, fr) | 0, Mt = Mt + Math.imul(Bt, Dr) | 0, St = St + Math.imul(Bt, fr) | 0, ct = ct + Math.imul(Nr, Fr) | 0, Mt = Mt + Math.imul(Nr, qr) | 0, Mt = Mt + Math.imul(dr, Fr) | 0, St = St + Math.imul(dr, qr) | 0;
      var ln = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, ct = Math.imul(ar, Jr), Mt = Math.imul(ar, xr), Mt = Mt + Math.imul(Yt, Jr) | 0, St = Math.imul(Yt, xr), ct = ct + Math.imul(It, Dr) | 0, Mt = Mt + Math.imul(It, fr) | 0, Mt = Mt + Math.imul(jt, Dr) | 0, St = St + Math.imul(jt, fr) | 0, ct = ct + Math.imul(Zr, Fr) | 0, Mt = Mt + Math.imul(Zr, qr) | 0, Mt = Mt + Math.imul(Bt, Fr) | 0, St = St + Math.imul(Bt, qr) | 0;
      var sn = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, ct = Math.imul(ar, Dr), Mt = Math.imul(ar, fr), Mt = Mt + Math.imul(Yt, Dr) | 0, St = Math.imul(Yt, fr), ct = ct + Math.imul(It, Fr) | 0, Mt = Mt + Math.imul(It, qr) | 0, Mt = Mt + Math.imul(jt, Fr) | 0, St = St + Math.imul(jt, qr) | 0;
      var hn = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      Ge = (St + (Mt >>> 13) | 0) + (hn >>> 26) | 0, hn &= 67108863, ct = Math.imul(ar, Fr), Mt = Math.imul(ar, qr), Mt = Mt + Math.imul(Yt, Fr) | 0, St = Math.imul(Yt, qr);
      var pn = (Ge + ct | 0) + ((Mt & 8191) << 13) | 0;
      return Ge = (St + (Mt >>> 13) | 0) + (pn >>> 26) | 0, pn &= 67108863, pt[0] = tn, pt[1] = Qr, pt[2] = nn, pt[3] = Er, pt[4] = Wt, pt[5] = nr, pt[6] = pr, pt[7] = Pr, pt[8] = Sr, pt[9] = Ur, pt[10] = jr, pt[11] = Gr, pt[12] = Vr, pt[13] = rn, pt[14] = an, pt[15] = ln, pt[16] = sn, pt[17] = hn, pt[18] = pn, Ge !== 0 && (pt[19] = Ge, ft.length++), ft;
    };
    Math.imul || (Tt = Et);
    function Rt(Xe, rt, ot) {
      ot.negative = rt.negative ^ Xe.negative, ot.length = Xe.length + rt.length;
      for (var ft = 0, mt = 0, yt = 0; yt < ot.length - 1; yt++) {
        var pt = mt;
        mt = 0;
        for (var Ge = ft & 67108863, ct = Math.min(yt, rt.length - 1), Mt = Math.max(0, yt - Xe.length + 1); Mt <= ct; Mt++) {
          var St = yt - Mt, At = Xe.words[St] | 0, Nt = rt.words[Mt] | 0, qt = At * Nt, Qt = qt & 67108863;
          pt = pt + (qt / 67108864 | 0) | 0, Qt = Qt + Ge | 0, Ge = Qt & 67108863, pt = pt + (Qt >>> 26) | 0, mt += pt >>> 26, pt &= 67108863;
        }
        ot.words[yt] = Ge, ft = pt, pt = mt;
      }
      return ft !== 0 ? ot.words[yt] = ft : ot.length--, ot._strip();
    }
    function Ct(Xe, rt, ot) {
      return Rt(Xe, rt, ot);
    }
    Ve.prototype.mulTo = function(rt, ot) {
      var ft, mt = (this || _global$7).length + rt.length;
      return (this || _global$7).length === 10 && rt.length === 10 ? ft = Tt(this || _global$7, rt, ot) : mt < 63 ? ft = Et(this || _global$7, rt, ot) : mt < 1024 ? ft = Rt(this || _global$7, rt, ot) : ft = Ct(this || _global$7, rt, ot), ft;
    }, Ve.prototype.mul = function(rt) {
      var ot = new Ve(null);
      return ot.words = new Array((this || _global$7).length + rt.length), this.mulTo(rt, ot);
    }, Ve.prototype.mulf = function(rt) {
      var ot = new Ve(null);
      return ot.words = new Array((this || _global$7).length + rt.length), Ct(this || _global$7, rt, ot);
    }, Ve.prototype.imul = function(rt) {
      return this.clone().mulTo(rt, this || _global$7);
    }, Ve.prototype.imuln = function(rt) {
      var ot = rt < 0;
      ot && (rt = -rt), Fe(typeof rt == "number"), Fe(rt < 67108864);
      for (var ft = 0, mt = 0; mt < (this || _global$7).length; mt++) {
        var yt = ((this || _global$7).words[mt] | 0) * rt, pt = (yt & 67108863) + (ft & 67108863);
        ft >>= 26, ft += yt / 67108864 | 0, ft += pt >>> 26, (this || _global$7).words[mt] = pt & 67108863;
      }
      return ft !== 0 && ((this || _global$7).words[mt] = ft, (this || _global$7).length++), ot ? this.ineg() : this || _global$7;
    }, Ve.prototype.muln = function(rt) {
      return this.clone().imuln(rt);
    }, Ve.prototype.sqr = function() {
      return this.mul(this || _global$7);
    }, Ve.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Ve.prototype.pow = function(rt) {
      var ot = xt(rt);
      if (ot.length === 0)
        return new Ve(1);
      for (var ft = this || _global$7, mt = 0; mt < ot.length && ot[mt] === 0; mt++, ft = ft.sqr())
        ;
      if (++mt < ot.length)
        for (var yt = ft.sqr(); mt < ot.length; mt++, yt = yt.sqr())
          ot[mt] !== 0 && (ft = ft.mul(yt));
      return ft;
    }, Ve.prototype.iushln = function(rt) {
      Fe(typeof rt == "number" && rt >= 0);
      var ot = rt % 26, ft = (rt - ot) / 26, mt = 67108863 >>> 26 - ot << 26 - ot, yt;
      if (ot !== 0) {
        var pt = 0;
        for (yt = 0; yt < (this || _global$7).length; yt++) {
          var Ge = (this || _global$7).words[yt] & mt, ct = ((this || _global$7).words[yt] | 0) - Ge << ot;
          (this || _global$7).words[yt] = ct | pt, pt = Ge >>> 26 - ot;
        }
        pt && ((this || _global$7).words[yt] = pt, (this || _global$7).length++);
      }
      if (ft !== 0) {
        for (yt = (this || _global$7).length - 1; yt >= 0; yt--)
          (this || _global$7).words[yt + ft] = (this || _global$7).words[yt];
        for (yt = 0; yt < ft; yt++)
          (this || _global$7).words[yt] = 0;
        (this || _global$7).length += ft;
      }
      return this._strip();
    }, Ve.prototype.ishln = function(rt) {
      return Fe((this || _global$7).negative === 0), this.iushln(rt);
    }, Ve.prototype.iushrn = function(rt, ot, ft) {
      Fe(typeof rt == "number" && rt >= 0);
      var mt;
      ot ? mt = (ot - ot % 26) / 26 : mt = 0;
      var yt = rt % 26, pt = Math.min((rt - yt) / 26, (this || _global$7).length), Ge = 67108863 ^ 67108863 >>> yt << yt, ct = ft;
      if (mt -= pt, mt = Math.max(0, mt), ct) {
        for (var Mt = 0; Mt < pt; Mt++)
          ct.words[Mt] = (this || _global$7).words[Mt];
        ct.length = pt;
      }
      if (pt !== 0)
        if ((this || _global$7).length > pt)
          for ((this || _global$7).length -= pt, Mt = 0; Mt < (this || _global$7).length; Mt++)
            (this || _global$7).words[Mt] = (this || _global$7).words[Mt + pt];
        else
          (this || _global$7).words[0] = 0, (this || _global$7).length = 1;
      var St = 0;
      for (Mt = (this || _global$7).length - 1; Mt >= 0 && (St !== 0 || Mt >= mt); Mt--) {
        var At = (this || _global$7).words[Mt] | 0;
        (this || _global$7).words[Mt] = St << 26 - yt | At >>> yt, St = At & Ge;
      }
      return ct && St !== 0 && (ct.words[ct.length++] = St), (this || _global$7).length === 0 && ((this || _global$7).words[0] = 0, (this || _global$7).length = 1), this._strip();
    }, Ve.prototype.ishrn = function(rt, ot, ft) {
      return Fe((this || _global$7).negative === 0), this.iushrn(rt, ot, ft);
    }, Ve.prototype.shln = function(rt) {
      return this.clone().ishln(rt);
    }, Ve.prototype.ushln = function(rt) {
      return this.clone().iushln(rt);
    }, Ve.prototype.shrn = function(rt) {
      return this.clone().ishrn(rt);
    }, Ve.prototype.ushrn = function(rt) {
      return this.clone().iushrn(rt);
    }, Ve.prototype.testn = function(rt) {
      Fe(typeof rt == "number" && rt >= 0);
      var ot = rt % 26, ft = (rt - ot) / 26, mt = 1 << ot;
      if ((this || _global$7).length <= ft)
        return !1;
      var yt = (this || _global$7).words[ft];
      return !!(yt & mt);
    }, Ve.prototype.imaskn = function(rt) {
      Fe(typeof rt == "number" && rt >= 0);
      var ot = rt % 26, ft = (rt - ot) / 26;
      if (Fe((this || _global$7).negative === 0, "imaskn works only with positive numbers"), (this || _global$7).length <= ft)
        return this || _global$7;
      if (ot !== 0 && ft++, (this || _global$7).length = Math.min(ft, (this || _global$7).length), ot !== 0) {
        var mt = 67108863 ^ 67108863 >>> ot << ot;
        (this || _global$7).words[(this || _global$7).length - 1] &= mt;
      }
      return this._strip();
    }, Ve.prototype.maskn = function(rt) {
      return this.clone().imaskn(rt);
    }, Ve.prototype.iaddn = function(rt) {
      return Fe(typeof rt == "number"), Fe(rt < 67108864), rt < 0 ? this.isubn(-rt) : (this || _global$7).negative !== 0 ? (this || _global$7).length === 1 && ((this || _global$7).words[0] | 0) <= rt ? ((this || _global$7).words[0] = rt - ((this || _global$7).words[0] | 0), (this || _global$7).negative = 0, this || _global$7) : ((this || _global$7).negative = 0, this.isubn(rt), (this || _global$7).negative = 1, this || _global$7) : this._iaddn(rt);
    }, Ve.prototype._iaddn = function(rt) {
      (this || _global$7).words[0] += rt;
      for (var ot = 0; ot < (this || _global$7).length && (this || _global$7).words[ot] >= 67108864; ot++)
        (this || _global$7).words[ot] -= 67108864, ot === (this || _global$7).length - 1 ? (this || _global$7).words[ot + 1] = 1 : (this || _global$7).words[ot + 1]++;
      return (this || _global$7).length = Math.max((this || _global$7).length, ot + 1), this || _global$7;
    }, Ve.prototype.isubn = function(rt) {
      if (Fe(typeof rt == "number"), Fe(rt < 67108864), rt < 0)
        return this.iaddn(-rt);
      if ((this || _global$7).negative !== 0)
        return (this || _global$7).negative = 0, this.iaddn(rt), (this || _global$7).negative = 1, this || _global$7;
      if ((this || _global$7).words[0] -= rt, (this || _global$7).length === 1 && (this || _global$7).words[0] < 0)
        (this || _global$7).words[0] = -(this || _global$7).words[0], (this || _global$7).negative = 1;
      else
        for (var ot = 0; ot < (this || _global$7).length && (this || _global$7).words[ot] < 0; ot++)
          (this || _global$7).words[ot] += 67108864, (this || _global$7).words[ot + 1] -= 1;
      return this._strip();
    }, Ve.prototype.addn = function(rt) {
      return this.clone().iaddn(rt);
    }, Ve.prototype.subn = function(rt) {
      return this.clone().isubn(rt);
    }, Ve.prototype.iabs = function() {
      return (this || _global$7).negative = 0, this || _global$7;
    }, Ve.prototype.abs = function() {
      return this.clone().iabs();
    }, Ve.prototype._ishlnsubmul = function(rt, ot, ft) {
      var mt = rt.length + ft, yt;
      this._expand(mt);
      var pt, Ge = 0;
      for (yt = 0; yt < rt.length; yt++) {
        pt = ((this || _global$7).words[yt + ft] | 0) + Ge;
        var ct = (rt.words[yt] | 0) * ot;
        pt -= ct & 67108863, Ge = (pt >> 26) - (ct / 67108864 | 0), (this || _global$7).words[yt + ft] = pt & 67108863;
      }
      for (; yt < (this || _global$7).length - ft; yt++)
        pt = ((this || _global$7).words[yt + ft] | 0) + Ge, Ge = pt >> 26, (this || _global$7).words[yt + ft] = pt & 67108863;
      if (Ge === 0)
        return this._strip();
      for (Fe(Ge === -1), Ge = 0, yt = 0; yt < (this || _global$7).length; yt++)
        pt = -((this || _global$7).words[yt] | 0) + Ge, Ge = pt >> 26, (this || _global$7).words[yt] = pt & 67108863;
      return (this || _global$7).negative = 1, this._strip();
    }, Ve.prototype._wordDiv = function(rt, ot) {
      var ft = (this || _global$7).length - rt.length, mt = this.clone(), yt = rt, pt = yt.words[yt.length - 1] | 0, Ge = this._countBits(pt);
      ft = 26 - Ge, ft !== 0 && (yt = yt.ushln(ft), mt.iushln(ft), pt = yt.words[yt.length - 1] | 0);
      var ct = mt.length - yt.length, Mt;
      if (ot !== "mod") {
        Mt = new Ve(null), Mt.length = ct + 1, Mt.words = new Array(Mt.length);
        for (var St = 0; St < Mt.length; St++)
          Mt.words[St] = 0;
      }
      var At = mt.clone()._ishlnsubmul(yt, 1, ct);
      At.negative === 0 && (mt = At, Mt && (Mt.words[ct] = 1));
      for (var Nt = ct - 1; Nt >= 0; Nt--) {
        var qt = (mt.words[yt.length + Nt] | 0) * 67108864 + (mt.words[yt.length + Nt - 1] | 0);
        for (qt = Math.min(qt / pt | 0, 67108863), mt._ishlnsubmul(yt, qt, Nt); mt.negative !== 0; )
          qt--, mt.negative = 0, mt._ishlnsubmul(yt, 1, Nt), mt.isZero() || (mt.negative ^= 1);
        Mt && (Mt.words[Nt] = qt);
      }
      return Mt && Mt._strip(), mt._strip(), ot !== "div" && ft !== 0 && mt.iushrn(ft), {
        div: Mt || null,
        mod: mt
      };
    }, Ve.prototype.divmod = function(rt, ot, ft) {
      if (Fe(!rt.isZero()), this.isZero())
        return {
          div: new Ve(0),
          mod: new Ve(0)
        };
      var mt, yt, pt;
      return (this || _global$7).negative !== 0 && rt.negative === 0 ? (pt = this.neg().divmod(rt, ot), ot !== "mod" && (mt = pt.div.neg()), ot !== "div" && (yt = pt.mod.neg(), ft && yt.negative !== 0 && yt.iadd(rt)), {
        div: mt,
        mod: yt
      }) : (this || _global$7).negative === 0 && rt.negative !== 0 ? (pt = this.divmod(rt.neg(), ot), ot !== "mod" && (mt = pt.div.neg()), {
        div: mt,
        mod: pt.mod
      }) : (this || _global$7).negative & rt.negative ? (pt = this.neg().divmod(rt.neg(), ot), ot !== "div" && (yt = pt.mod.neg(), ft && yt.negative !== 0 && yt.isub(rt)), {
        div: pt.div,
        mod: yt
      }) : rt.length > (this || _global$7).length || this.cmp(rt) < 0 ? {
        div: new Ve(0),
        mod: this || _global$7
      } : rt.length === 1 ? ot === "div" ? {
        div: this.divn(rt.words[0]),
        mod: null
      } : ot === "mod" ? {
        div: null,
        mod: new Ve(this.modrn(rt.words[0]))
      } : {
        div: this.divn(rt.words[0]),
        mod: new Ve(this.modrn(rt.words[0]))
      } : this._wordDiv(rt, ot);
    }, Ve.prototype.div = function(rt) {
      return this.divmod(rt, "div", !1).div;
    }, Ve.prototype.mod = function(rt) {
      return this.divmod(rt, "mod", !1).mod;
    }, Ve.prototype.umod = function(rt) {
      return this.divmod(rt, "mod", !0).mod;
    }, Ve.prototype.divRound = function(rt) {
      var ot = this.divmod(rt);
      if (ot.mod.isZero())
        return ot.div;
      var ft = ot.div.negative !== 0 ? ot.mod.isub(rt) : ot.mod, mt = rt.ushrn(1), yt = rt.andln(1), pt = ft.cmp(mt);
      return pt < 0 || yt === 1 && pt === 0 ? ot.div : ot.div.negative !== 0 ? ot.div.isubn(1) : ot.div.iaddn(1);
    }, Ve.prototype.modrn = function(rt) {
      var ot = rt < 0;
      ot && (rt = -rt), Fe(rt <= 67108863);
      for (var ft = (1 << 26) % rt, mt = 0, yt = (this || _global$7).length - 1; yt >= 0; yt--)
        mt = (ft * mt + ((this || _global$7).words[yt] | 0)) % rt;
      return ot ? -mt : mt;
    }, Ve.prototype.modn = function(rt) {
      return this.modrn(rt);
    }, Ve.prototype.idivn = function(rt) {
      var ot = rt < 0;
      ot && (rt = -rt), Fe(rt <= 67108863);
      for (var ft = 0, mt = (this || _global$7).length - 1; mt >= 0; mt--) {
        var yt = ((this || _global$7).words[mt] | 0) + ft * 67108864;
        (this || _global$7).words[mt] = yt / rt | 0, ft = yt % rt;
      }
      return this._strip(), ot ? this.ineg() : this || _global$7;
    }, Ve.prototype.divn = function(rt) {
      return this.clone().idivn(rt);
    }, Ve.prototype.egcd = function(rt) {
      Fe(rt.negative === 0), Fe(!rt.isZero());
      var ot = this || _global$7, ft = rt.clone();
      ot.negative !== 0 ? ot = ot.umod(rt) : ot = ot.clone();
      for (var mt = new Ve(1), yt = new Ve(0), pt = new Ve(0), Ge = new Ve(1), ct = 0; ot.isEven() && ft.isEven(); )
        ot.iushrn(1), ft.iushrn(1), ++ct;
      for (var Mt = ft.clone(), St = ot.clone(); !ot.isZero(); ) {
        for (var At = 0, Nt = 1; !(ot.words[0] & Nt) && At < 26; ++At, Nt <<= 1)
          ;
        if (At > 0)
          for (ot.iushrn(At); At-- > 0; )
            (mt.isOdd() || yt.isOdd()) && (mt.iadd(Mt), yt.isub(St)), mt.iushrn(1), yt.iushrn(1);
        for (var qt = 0, Qt = 1; !(ft.words[0] & Qt) && qt < 26; ++qt, Qt <<= 1)
          ;
        if (qt > 0)
          for (ft.iushrn(qt); qt-- > 0; )
            (pt.isOdd() || Ge.isOdd()) && (pt.iadd(Mt), Ge.isub(St)), pt.iushrn(1), Ge.iushrn(1);
        ot.cmp(ft) >= 0 ? (ot.isub(ft), mt.isub(pt), yt.isub(Ge)) : (ft.isub(ot), pt.isub(mt), Ge.isub(yt));
      }
      return {
        a: pt,
        b: Ge,
        gcd: ft.iushln(ct)
      };
    }, Ve.prototype._invmp = function(rt) {
      Fe(rt.negative === 0), Fe(!rt.isZero());
      var ot = this || _global$7, ft = rt.clone();
      ot.negative !== 0 ? ot = ot.umod(rt) : ot = ot.clone();
      for (var mt = new Ve(1), yt = new Ve(0), pt = ft.clone(); ot.cmpn(1) > 0 && ft.cmpn(1) > 0; ) {
        for (var Ge = 0, ct = 1; !(ot.words[0] & ct) && Ge < 26; ++Ge, ct <<= 1)
          ;
        if (Ge > 0)
          for (ot.iushrn(Ge); Ge-- > 0; )
            mt.isOdd() && mt.iadd(pt), mt.iushrn(1);
        for (var Mt = 0, St = 1; !(ft.words[0] & St) && Mt < 26; ++Mt, St <<= 1)
          ;
        if (Mt > 0)
          for (ft.iushrn(Mt); Mt-- > 0; )
            yt.isOdd() && yt.iadd(pt), yt.iushrn(1);
        ot.cmp(ft) >= 0 ? (ot.isub(ft), mt.isub(yt)) : (ft.isub(ot), yt.isub(mt));
      }
      var At;
      return ot.cmpn(1) === 0 ? At = mt : At = yt, At.cmpn(0) < 0 && At.iadd(rt), At;
    }, Ve.prototype.gcd = function(rt) {
      if (this.isZero())
        return rt.abs();
      if (rt.isZero())
        return this.abs();
      var ot = this.clone(), ft = rt.clone();
      ot.negative = 0, ft.negative = 0;
      for (var mt = 0; ot.isEven() && ft.isEven(); mt++)
        ot.iushrn(1), ft.iushrn(1);
      do {
        for (; ot.isEven(); )
          ot.iushrn(1);
        for (; ft.isEven(); )
          ft.iushrn(1);
        var yt = ot.cmp(ft);
        if (yt < 0) {
          var pt = ot;
          ot = ft, ft = pt;
        } else if (yt === 0 || ft.cmpn(1) === 0)
          break;
        ot.isub(ft);
      } while (!0);
      return ft.iushln(mt);
    }, Ve.prototype.invm = function(rt) {
      return this.egcd(rt).a.umod(rt);
    }, Ve.prototype.isEven = function() {
      return ((this || _global$7).words[0] & 1) === 0;
    }, Ve.prototype.isOdd = function() {
      return ((this || _global$7).words[0] & 1) === 1;
    }, Ve.prototype.andln = function(rt) {
      return (this || _global$7).words[0] & rt;
    }, Ve.prototype.bincn = function(rt) {
      Fe(typeof rt == "number");
      var ot = rt % 26, ft = (rt - ot) / 26, mt = 1 << ot;
      if ((this || _global$7).length <= ft)
        return this._expand(ft + 1), (this || _global$7).words[ft] |= mt, this || _global$7;
      for (var yt = mt, pt = ft; yt !== 0 && pt < (this || _global$7).length; pt++) {
        var Ge = (this || _global$7).words[pt] | 0;
        Ge += yt, yt = Ge >>> 26, Ge &= 67108863, (this || _global$7).words[pt] = Ge;
      }
      return yt !== 0 && ((this || _global$7).words[pt] = yt, (this || _global$7).length++), this || _global$7;
    }, Ve.prototype.isZero = function() {
      return (this || _global$7).length === 1 && (this || _global$7).words[0] === 0;
    }, Ve.prototype.cmpn = function(rt) {
      var ot = rt < 0;
      if ((this || _global$7).negative !== 0 && !ot)
        return -1;
      if ((this || _global$7).negative === 0 && ot)
        return 1;
      this._strip();
      var ft;
      if ((this || _global$7).length > 1)
        ft = 1;
      else {
        ot && (rt = -rt), Fe(rt <= 67108863, "Number is too big");
        var mt = (this || _global$7).words[0] | 0;
        ft = mt === rt ? 0 : mt < rt ? -1 : 1;
      }
      return (this || _global$7).negative !== 0 ? -ft | 0 : ft;
    }, Ve.prototype.cmp = function(rt) {
      if ((this || _global$7).negative !== 0 && rt.negative === 0)
        return -1;
      if ((this || _global$7).negative === 0 && rt.negative !== 0)
        return 1;
      var ot = this.ucmp(rt);
      return (this || _global$7).negative !== 0 ? -ot | 0 : ot;
    }, Ve.prototype.ucmp = function(rt) {
      if ((this || _global$7).length > rt.length)
        return 1;
      if ((this || _global$7).length < rt.length)
        return -1;
      for (var ot = 0, ft = (this || _global$7).length - 1; ft >= 0; ft--) {
        var mt = (this || _global$7).words[ft] | 0, yt = rt.words[ft] | 0;
        if (mt !== yt) {
          mt < yt ? ot = -1 : mt > yt && (ot = 1);
          break;
        }
      }
      return ot;
    }, Ve.prototype.gtn = function(rt) {
      return this.cmpn(rt) === 1;
    }, Ve.prototype.gt = function(rt) {
      return this.cmp(rt) === 1;
    }, Ve.prototype.gten = function(rt) {
      return this.cmpn(rt) >= 0;
    }, Ve.prototype.gte = function(rt) {
      return this.cmp(rt) >= 0;
    }, Ve.prototype.ltn = function(rt) {
      return this.cmpn(rt) === -1;
    }, Ve.prototype.lt = function(rt) {
      return this.cmp(rt) === -1;
    }, Ve.prototype.lten = function(rt) {
      return this.cmpn(rt) <= 0;
    }, Ve.prototype.lte = function(rt) {
      return this.cmp(rt) <= 0;
    }, Ve.prototype.eqn = function(rt) {
      return this.cmpn(rt) === 0;
    }, Ve.prototype.eq = function(rt) {
      return this.cmp(rt) === 0;
    }, Ve.red = function(rt) {
      return new gt(rt);
    }, Ve.prototype.toRed = function(rt) {
      return Fe(!(this || _global$7).red, "Already a number in reduction context"), Fe((this || _global$7).negative === 0, "red works only with positives"), rt.convertTo(this || _global$7)._forceRed(rt);
    }, Ve.prototype.fromRed = function() {
      return Fe((this || _global$7).red, "fromRed works only with numbers in reduction context"), (this || _global$7).red.convertFrom(this || _global$7);
    }, Ve.prototype._forceRed = function(rt) {
      return (this || _global$7).red = rt, this || _global$7;
    }, Ve.prototype.forceRed = function(rt) {
      return Fe(!(this || _global$7).red, "Already a number in reduction context"), this._forceRed(rt);
    }, Ve.prototype.redAdd = function(rt) {
      return Fe((this || _global$7).red, "redAdd works only with red numbers"), (this || _global$7).red.add(this || _global$7, rt);
    }, Ve.prototype.redIAdd = function(rt) {
      return Fe((this || _global$7).red, "redIAdd works only with red numbers"), (this || _global$7).red.iadd(this || _global$7, rt);
    }, Ve.prototype.redSub = function(rt) {
      return Fe((this || _global$7).red, "redSub works only with red numbers"), (this || _global$7).red.sub(this || _global$7, rt);
    }, Ve.prototype.redISub = function(rt) {
      return Fe((this || _global$7).red, "redISub works only with red numbers"), (this || _global$7).red.isub(this || _global$7, rt);
    }, Ve.prototype.redShl = function(rt) {
      return Fe((this || _global$7).red, "redShl works only with red numbers"), (this || _global$7).red.shl(this || _global$7, rt);
    }, Ve.prototype.redMul = function(rt) {
      return Fe((this || _global$7).red, "redMul works only with red numbers"), (this || _global$7).red._verify2(this || _global$7, rt), (this || _global$7).red.mul(this || _global$7, rt);
    }, Ve.prototype.redIMul = function(rt) {
      return Fe((this || _global$7).red, "redMul works only with red numbers"), (this || _global$7).red._verify2(this || _global$7, rt), (this || _global$7).red.imul(this || _global$7, rt);
    }, Ve.prototype.redSqr = function() {
      return Fe((this || _global$7).red, "redSqr works only with red numbers"), (this || _global$7).red._verify1(this || _global$7), (this || _global$7).red.sqr(this || _global$7);
    }, Ve.prototype.redISqr = function() {
      return Fe((this || _global$7).red, "redISqr works only with red numbers"), (this || _global$7).red._verify1(this || _global$7), (this || _global$7).red.isqr(this || _global$7);
    }, Ve.prototype.redSqrt = function() {
      return Fe((this || _global$7).red, "redSqrt works only with red numbers"), (this || _global$7).red._verify1(this || _global$7), (this || _global$7).red.sqrt(this || _global$7);
    }, Ve.prototype.redInvm = function() {
      return Fe((this || _global$7).red, "redInvm works only with red numbers"), (this || _global$7).red._verify1(this || _global$7), (this || _global$7).red.invm(this || _global$7);
    }, Ve.prototype.redNeg = function() {
      return Fe((this || _global$7).red, "redNeg works only with red numbers"), (this || _global$7).red._verify1(this || _global$7), (this || _global$7).red.neg(this || _global$7);
    }, Ve.prototype.redPow = function(rt) {
      return Fe((this || _global$7).red && !rt.red, "redPow(normalNum)"), (this || _global$7).red._verify1(this || _global$7), (this || _global$7).red.pow(this || _global$7, rt);
    };
    var Zt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Lt(Xe, rt) {
      (this || _global$7).name = Xe, (this || _global$7).p = new Ve(rt, 16), (this || _global$7).n = (this || _global$7).p.bitLength(), (this || _global$7).k = new Ve(1).iushln((this || _global$7).n).isub((this || _global$7).p), (this || _global$7).tmp = this._tmp();
    }
    Lt.prototype._tmp = function() {
      var rt = new Ve(null);
      return rt.words = new Array(Math.ceil((this || _global$7).n / 13)), rt;
    }, Lt.prototype.ireduce = function(rt) {
      var ot = rt, ft;
      do
        this.split(ot, (this || _global$7).tmp), ot = this.imulK(ot), ot = ot.iadd((this || _global$7).tmp), ft = ot.bitLength();
      while (ft > (this || _global$7).n);
      var mt = ft < (this || _global$7).n ? -1 : ot.ucmp((this || _global$7).p);
      return mt === 0 ? (ot.words[0] = 0, ot.length = 1) : mt > 0 ? ot.isub((this || _global$7).p) : ot.strip !== void 0 ? ot.strip() : ot._strip(), ot;
    }, Lt.prototype.split = function(rt, ot) {
      rt.iushrn((this || _global$7).n, 0, ot);
    }, Lt.prototype.imulK = function(rt) {
      return rt.imul((this || _global$7).k);
    };
    function Ut() {
      Lt.call(this || _global$7, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    Ke(Ut, Lt), Ut.prototype.split = function(rt, ot) {
      for (var ft = 4194303, mt = Math.min(rt.length, 9), yt = 0; yt < mt; yt++)
        ot.words[yt] = rt.words[yt];
      if (ot.length = mt, rt.length <= 9) {
        rt.words[0] = 0, rt.length = 1;
        return;
      }
      var pt = rt.words[9];
      for (ot.words[ot.length++] = pt & ft, yt = 10; yt < rt.length; yt++) {
        var Ge = rt.words[yt] | 0;
        rt.words[yt - 10] = (Ge & ft) << 4 | pt >>> 22, pt = Ge;
      }
      pt >>>= 22, rt.words[yt - 10] = pt, pt === 0 && rt.length > 10 ? rt.length -= 10 : rt.length -= 9;
    }, Ut.prototype.imulK = function(rt) {
      rt.words[rt.length] = 0, rt.words[rt.length + 1] = 0, rt.length += 2;
      for (var ot = 0, ft = 0; ft < rt.length; ft++) {
        var mt = rt.words[ft] | 0;
        ot += mt * 977, rt.words[ft] = ot & 67108863, ot = mt * 64 + (ot / 67108864 | 0);
      }
      return rt.words[rt.length - 1] === 0 && (rt.length--, rt.words[rt.length - 1] === 0 && rt.length--), rt;
    };
    function Pt() {
      Lt.call(this || _global$7, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    Ke(Pt, Lt);
    function Ot() {
      Lt.call(this || _global$7, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    Ke(Ot, Lt);
    function Ft() {
      Lt.call(this || _global$7, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    Ke(Ft, Lt), Ft.prototype.imulK = function(rt) {
      for (var ot = 0, ft = 0; ft < rt.length; ft++) {
        var mt = (rt.words[ft] | 0) * 19 + ot, yt = mt & 67108863;
        mt >>>= 26, rt.words[ft] = yt, ot = mt;
      }
      return ot !== 0 && (rt.words[rt.length++] = ot), rt;
    }, Ve._prime = function(rt) {
      if (Zt[rt])
        return Zt[rt];
      var ot;
      if (rt === "k256")
        ot = new Ut();
      else if (rt === "p224")
        ot = new Pt();
      else if (rt === "p192")
        ot = new Ot();
      else if (rt === "p25519")
        ot = new Ft();
      else
        throw new Error("Unknown prime " + rt);
      return Zt[rt] = ot, ot;
    };
    function gt(Xe) {
      if (typeof Xe == "string") {
        var rt = Ve._prime(Xe);
        (this || _global$7).m = rt.p, (this || _global$7).prime = rt;
      } else
        Fe(Xe.gtn(1), "modulus must be greater than 1"), (this || _global$7).m = Xe, (this || _global$7).prime = null;
    }
    gt.prototype._verify1 = function(rt) {
      Fe(rt.negative === 0, "red works only with positives"), Fe(rt.red, "red works only with red numbers");
    }, gt.prototype._verify2 = function(rt, ot) {
      Fe((rt.negative | ot.negative) === 0, "red works only with positives"), Fe(rt.red && rt.red === ot.red, "red works only with red numbers");
    }, gt.prototype.imod = function(rt) {
      return (this || _global$7).prime ? (this || _global$7).prime.ireduce(rt)._forceRed(this || _global$7) : (lt(rt, rt.umod((this || _global$7).m)._forceRed(this || _global$7)), rt);
    }, gt.prototype.neg = function(rt) {
      return rt.isZero() ? rt.clone() : (this || _global$7).m.sub(rt)._forceRed(this || _global$7);
    }, gt.prototype.add = function(rt, ot) {
      this._verify2(rt, ot);
      var ft = rt.add(ot);
      return ft.cmp((this || _global$7).m) >= 0 && ft.isub((this || _global$7).m), ft._forceRed(this || _global$7);
    }, gt.prototype.iadd = function(rt, ot) {
      this._verify2(rt, ot);
      var ft = rt.iadd(ot);
      return ft.cmp((this || _global$7).m) >= 0 && ft.isub((this || _global$7).m), ft;
    }, gt.prototype.sub = function(rt, ot) {
      this._verify2(rt, ot);
      var ft = rt.sub(ot);
      return ft.cmpn(0) < 0 && ft.iadd((this || _global$7).m), ft._forceRed(this || _global$7);
    }, gt.prototype.isub = function(rt, ot) {
      this._verify2(rt, ot);
      var ft = rt.isub(ot);
      return ft.cmpn(0) < 0 && ft.iadd((this || _global$7).m), ft;
    }, gt.prototype.shl = function(rt, ot) {
      return this._verify1(rt), this.imod(rt.ushln(ot));
    }, gt.prototype.imul = function(rt, ot) {
      return this._verify2(rt, ot), this.imod(rt.imul(ot));
    }, gt.prototype.mul = function(rt, ot) {
      return this._verify2(rt, ot), this.imod(rt.mul(ot));
    }, gt.prototype.isqr = function(rt) {
      return this.imul(rt, rt.clone());
    }, gt.prototype.sqr = function(rt) {
      return this.mul(rt, rt);
    }, gt.prototype.sqrt = function(rt) {
      if (rt.isZero())
        return rt.clone();
      var ot = (this || _global$7).m.andln(3);
      if (Fe(ot % 2 === 1), ot === 3) {
        var ft = (this || _global$7).m.add(new Ve(1)).iushrn(2);
        return this.pow(rt, ft);
      }
      for (var mt = (this || _global$7).m.subn(1), yt = 0; !mt.isZero() && mt.andln(1) === 0; )
        yt++, mt.iushrn(1);
      Fe(!mt.isZero());
      var pt = new Ve(1).toRed(this || _global$7), Ge = pt.redNeg(), ct = (this || _global$7).m.subn(1).iushrn(1), Mt = (this || _global$7).m.bitLength();
      for (Mt = new Ve(2 * Mt * Mt).toRed(this || _global$7); this.pow(Mt, ct).cmp(Ge) !== 0; )
        Mt.redIAdd(Ge);
      for (var St = this.pow(Mt, mt), At = this.pow(rt, mt.addn(1).iushrn(1)), Nt = this.pow(rt, mt), qt = yt; Nt.cmp(pt) !== 0; ) {
        for (var Qt = Nt, Xt = 0; Qt.cmp(pt) !== 0; Xt++)
          Qt = Qt.redSqr();
        Fe(Xt < qt);
        var zt = this.pow(St, new Ve(1).iushln(qt - Xt - 1));
        At = At.redMul(zt), St = zt.redSqr(), Nt = Nt.redMul(St), qt = Xt;
      }
      return At;
    }, gt.prototype.invm = function(rt) {
      var ot = rt._invmp((this || _global$7).m);
      return ot.negative !== 0 ? (ot.negative = 0, this.imod(ot).redNeg()) : this.imod(ot);
    }, gt.prototype.pow = function(rt, ot) {
      if (ot.isZero())
        return new Ve(1).toRed(this || _global$7);
      if (ot.cmpn(1) === 0)
        return rt.clone();
      var ft = 4, mt = new Array(1 << ft);
      mt[0] = new Ve(1).toRed(this || _global$7), mt[1] = rt;
      for (var yt = 2; yt < mt.length; yt++)
        mt[yt] = this.mul(mt[yt - 1], rt);
      var pt = mt[0], Ge = 0, ct = 0, Mt = ot.bitLength() % 26;
      for (Mt === 0 && (Mt = 26), yt = ot.length - 1; yt >= 0; yt--) {
        for (var St = ot.words[yt], At = Mt - 1; At >= 0; At--) {
          var Nt = St >> At & 1;
          if (pt !== mt[0] && (pt = this.sqr(pt)), Nt === 0 && Ge === 0) {
            ct = 0;
            continue;
          }
          Ge <<= 1, Ge |= Nt, ct++, !(ct !== ft && (yt !== 0 || At !== 0)) && (pt = this.mul(pt, mt[Ge]), ct = 0, Ge = 0);
        }
        Mt = 26;
      }
      return pt;
    }, gt.prototype.convertTo = function(rt) {
      var ot = rt.umod((this || _global$7).m);
      return ot === rt ? ot.clone() : ot;
    }, gt.prototype.convertFrom = function(rt) {
      var ot = rt.clone();
      return ot.red = null, ot;
    }, Ve.mont = function(rt) {
      return new We(rt);
    };
    function We(Xe) {
      gt.call(this || _global$7, Xe), (this || _global$7).shift = (this || _global$7).m.bitLength(), (this || _global$7).shift % 26 !== 0 && ((this || _global$7).shift += 26 - (this || _global$7).shift % 26), (this || _global$7).r = new Ve(1).iushln((this || _global$7).shift), (this || _global$7).r2 = this.imod((this || _global$7).r.sqr()), (this || _global$7).rinv = (this || _global$7).r._invmp((this || _global$7).m), (this || _global$7).minv = (this || _global$7).rinv.mul((this || _global$7).r).isubn(1).div((this || _global$7).m), (this || _global$7).minv = (this || _global$7).minv.umod((this || _global$7).r), (this || _global$7).minv = (this || _global$7).r.sub((this || _global$7).minv);
    }
    Ke(We, gt), We.prototype.convertTo = function(rt) {
      return this.imod(rt.ushln((this || _global$7).shift));
    }, We.prototype.convertFrom = function(rt) {
      var ot = this.imod(rt.mul((this || _global$7).rinv));
      return ot.red = null, ot;
    }, We.prototype.imul = function(rt, ot) {
      if (rt.isZero() || ot.isZero())
        return rt.words[0] = 0, rt.length = 1, rt;
      var ft = rt.imul(ot), mt = ft.maskn((this || _global$7).shift).mul((this || _global$7).minv).imaskn((this || _global$7).shift).mul((this || _global$7).m), yt = ft.isub(mt).iushrn((this || _global$7).shift), pt = yt;
      return yt.cmp((this || _global$7).m) >= 0 ? pt = yt.isub((this || _global$7).m) : yt.cmpn(0) < 0 && (pt = yt.iadd((this || _global$7).m)), pt._forceRed(this || _global$7);
    }, We.prototype.mul = function(rt, ot) {
      if (rt.isZero() || ot.isZero())
        return new Ve(0)._forceRed(this || _global$7);
      var ft = rt.mul(ot), mt = ft.maskn((this || _global$7).shift).mul((this || _global$7).minv).imaskn((this || _global$7).shift).mul((this || _global$7).m), yt = ft.isub(mt).iushrn((this || _global$7).shift), pt = yt;
      return yt.cmp((this || _global$7).m) >= 0 ? pt = yt.isub((this || _global$7).m) : yt.cmpn(0) < 0 && (pt = yt.iadd((this || _global$7).m)), pt._forceRed(this || _global$7);
    }, We.prototype.invm = function(rt) {
      var ot = this.imod(rt._invmp((this || _global$7).m).mul((this || _global$7).r2));
      return ot._forceRed(this || _global$7);
    };
  }(module$4, exports$Y)), module$4.exports;
}
var exports$X = {}, _dewExec$W = !1;
function dew$W() {
  if (_dewExec$W)
    return exports$X;
  _dewExec$W = !0;
  var $e = buffer.Buffer, Ze = dew$X(), Fe = dew$2O();
  function Ke(Qe) {
    var at = Ve(Qe), ut = at.toRed(Ze.mont(Qe.modulus)).redPow(new Ze(Qe.publicExponent)).fromRed();
    return {
      blinder: ut,
      unblinder: at.invm(Qe.modulus)
    };
  }
  function Ve(Qe) {
    var at = Qe.modulus.byteLength(), ut;
    do
      ut = new Ze(Fe(at));
    while (ut.cmp(Qe.modulus) >= 0 || !ut.umod(Qe.prime1) || !ut.umod(Qe.prime2));
    return ut;
  }
  function Je(Qe, at) {
    var ut = Ke(at), lt = at.modulus.byteLength(), dt = new Ze(Qe).mul(ut.blinder).umod(at.modulus), bt = dt.toRed(Ze.mont(at.prime1)), $t = dt.toRed(Ze.mont(at.prime2)), vt = at.coefficient, wt = at.prime1, xt = at.prime2, Et = bt.redPow(at.exponent1).fromRed(), Tt = $t.redPow(at.exponent2).fromRed(), Rt = Et.isub(Tt).imul(vt).umod(wt).imul(xt);
    return Tt.iadd(Rt).imul(ut.unblinder).umod(at.modulus).toArrayLike($e, "be", lt);
  }
  return Je.getr = Ve, exports$X = Je, exports$X;
}
var _package = {
  name: "elliptic",
  version: "6.5.4",
  description: "EC cryptography",
  main: "lib/elliptic.js",
  files: [
    "lib"
  ],
  scripts: {
    lint: "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    unit: "istanbul test _mocha --reporter=spec test/index.js",
    test: "npm run lint && npm run unit",
    version: "grunt dist && git add dist/"
  },
  repository: {
    type: "git",
    url: "git@github.com:indutny/elliptic"
  },
  keywords: [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  author: "Fedor Indutny <fedor@indutny.com>",
  license: "MIT",
  bugs: {
    url: "https://github.com/indutny/elliptic/issues"
  },
  homepage: "https://github.com/indutny/elliptic",
  devDependencies: {
    brfs: "^2.0.2",
    coveralls: "^3.1.0",
    eslint: "^7.6.0",
    grunt: "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    istanbul: "^0.4.5",
    mocha: "^8.0.1"
  },
  dependencies: {
    "bn.js": "^4.11.9",
    brorand: "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    inherits: "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
  }
}, exports$W = {}, _dewExec$V = !1, module$3 = {
  exports: exports$W
}, _global$6 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$V() {
  return _dewExec$V || (_dewExec$V = !0, function($e, Ze) {
    function Fe(gt, We) {
      if (!gt)
        throw new Error(We || "Assertion failed");
    }
    function Ke(gt, We) {
      gt.super_ = We;
      var Xe = function() {
      };
      Xe.prototype = We.prototype, gt.prototype = new Xe(), gt.prototype.constructor = gt;
    }
    function Ve(gt, We, Xe) {
      if (Ve.isBN(gt))
        return gt;
      (this || _global$6).negative = 0, (this || _global$6).words = null, (this || _global$6).length = 0, (this || _global$6).red = null, gt !== null && ((We === "le" || We === "be") && (Xe = We, We = 10), this._init(gt || 0, We || 10, Xe || "be"));
    }
    typeof $e == "object" ? $e.exports = Ve : Ze.BN = Ve, Ve.BN = Ve, Ve.wordSize = 26;
    var Je;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Je = window.Buffer : Je = buffer.Buffer;
    } catch {
    }
    Ve.isBN = function(We) {
      return We instanceof Ve ? !0 : We !== null && typeof We == "object" && We.constructor.wordSize === Ve.wordSize && Array.isArray(We.words);
    }, Ve.max = function(We, Xe) {
      return We.cmp(Xe) > 0 ? We : Xe;
    }, Ve.min = function(We, Xe) {
      return We.cmp(Xe) < 0 ? We : Xe;
    }, Ve.prototype._init = function(We, Xe, rt) {
      if (typeof We == "number")
        return this._initNumber(We, Xe, rt);
      if (typeof We == "object")
        return this._initArray(We, Xe, rt);
      Xe === "hex" && (Xe = 16), Fe(Xe === (Xe | 0) && Xe >= 2 && Xe <= 36), We = We.toString().replace(/\s+/g, "");
      var ot = 0;
      We[0] === "-" && (ot++, (this || _global$6).negative = 1), ot < We.length && (Xe === 16 ? this._parseHex(We, ot, rt) : (this._parseBase(We, Xe, ot), rt === "le" && this._initArray(this.toArray(), Xe, rt)));
    }, Ve.prototype._initNumber = function(We, Xe, rt) {
      We < 0 && ((this || _global$6).negative = 1, We = -We), We < 67108864 ? ((this || _global$6).words = [We & 67108863], (this || _global$6).length = 1) : We < 4503599627370496 ? ((this || _global$6).words = [We & 67108863, We / 67108864 & 67108863], (this || _global$6).length = 2) : (Fe(We < 9007199254740992), (this || _global$6).words = [We & 67108863, We / 67108864 & 67108863, 1], (this || _global$6).length = 3), rt === "le" && this._initArray(this.toArray(), Xe, rt);
    }, Ve.prototype._initArray = function(We, Xe, rt) {
      if (Fe(typeof We.length == "number"), We.length <= 0)
        return (this || _global$6).words = [0], (this || _global$6).length = 1, this || _global$6;
      (this || _global$6).length = Math.ceil(We.length / 3), (this || _global$6).words = new Array((this || _global$6).length);
      for (var ot = 0; ot < (this || _global$6).length; ot++)
        (this || _global$6).words[ot] = 0;
      var ft, mt, yt = 0;
      if (rt === "be")
        for (ot = We.length - 1, ft = 0; ot >= 0; ot -= 3)
          mt = We[ot] | We[ot - 1] << 8 | We[ot - 2] << 16, (this || _global$6).words[ft] |= mt << yt & 67108863, (this || _global$6).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      else if (rt === "le")
        for (ot = 0, ft = 0; ot < We.length; ot += 3)
          mt = We[ot] | We[ot + 1] << 8 | We[ot + 2] << 16, (this || _global$6).words[ft] |= mt << yt & 67108863, (this || _global$6).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      return this.strip();
    };
    function Qe(gt, We) {
      var Xe = gt.charCodeAt(We);
      return Xe >= 65 && Xe <= 70 ? Xe - 55 : Xe >= 97 && Xe <= 102 ? Xe - 87 : Xe - 48 & 15;
    }
    function at(gt, We, Xe) {
      var rt = Qe(gt, Xe);
      return Xe - 1 >= We && (rt |= Qe(gt, Xe - 1) << 4), rt;
    }
    Ve.prototype._parseHex = function(We, Xe, rt) {
      (this || _global$6).length = Math.ceil((We.length - Xe) / 6), (this || _global$6).words = new Array((this || _global$6).length);
      for (var ot = 0; ot < (this || _global$6).length; ot++)
        (this || _global$6).words[ot] = 0;
      var ft = 0, mt = 0, yt;
      if (rt === "be")
        for (ot = We.length - 1; ot >= Xe; ot -= 2)
          yt = at(We, Xe, ot) << ft, (this || _global$6).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$6).words[mt] |= yt >>> 26) : ft += 8;
      else {
        var pt = We.length - Xe;
        for (ot = pt % 2 === 0 ? Xe + 1 : Xe; ot < We.length; ot += 2)
          yt = at(We, Xe, ot) << ft, (this || _global$6).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$6).words[mt] |= yt >>> 26) : ft += 8;
      }
      this.strip();
    };
    function ut(gt, We, Xe, rt) {
      for (var ot = 0, ft = Math.min(gt.length, Xe), mt = We; mt < ft; mt++) {
        var yt = gt.charCodeAt(mt) - 48;
        ot *= rt, yt >= 49 ? ot += yt - 49 + 10 : yt >= 17 ? ot += yt - 17 + 10 : ot += yt;
      }
      return ot;
    }
    Ve.prototype._parseBase = function(We, Xe, rt) {
      (this || _global$6).words = [0], (this || _global$6).length = 1;
      for (var ot = 0, ft = 1; ft <= 67108863; ft *= Xe)
        ot++;
      ot--, ft = ft / Xe | 0;
      for (var mt = We.length - rt, yt = mt % ot, pt = Math.min(mt, mt - yt) + rt, Ge = 0, ct = rt; ct < pt; ct += ot)
        Ge = ut(We, ct, ct + ot, Xe), this.imuln(ft), (this || _global$6).words[0] + Ge < 67108864 ? (this || _global$6).words[0] += Ge : this._iaddn(Ge);
      if (yt !== 0) {
        var Mt = 1;
        for (Ge = ut(We, ct, We.length, Xe), ct = 0; ct < yt; ct++)
          Mt *= Xe;
        this.imuln(Mt), (this || _global$6).words[0] + Ge < 67108864 ? (this || _global$6).words[0] += Ge : this._iaddn(Ge);
      }
      this.strip();
    }, Ve.prototype.copy = function(We) {
      We.words = new Array((this || _global$6).length);
      for (var Xe = 0; Xe < (this || _global$6).length; Xe++)
        We.words[Xe] = (this || _global$6).words[Xe];
      We.length = (this || _global$6).length, We.negative = (this || _global$6).negative, We.red = (this || _global$6).red;
    }, Ve.prototype.clone = function() {
      var We = new Ve(null);
      return this.copy(We), We;
    }, Ve.prototype._expand = function(We) {
      for (; (this || _global$6).length < We; )
        (this || _global$6).words[(this || _global$6).length++] = 0;
      return this || _global$6;
    }, Ve.prototype.strip = function() {
      for (; (this || _global$6).length > 1 && (this || _global$6).words[(this || _global$6).length - 1] === 0; )
        (this || _global$6).length--;
      return this._normSign();
    }, Ve.prototype._normSign = function() {
      return (this || _global$6).length === 1 && (this || _global$6).words[0] === 0 && ((this || _global$6).negative = 0), this || _global$6;
    }, Ve.prototype.inspect = function() {
      return ((this || _global$6).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var lt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], dt = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], bt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    Ve.prototype.toString = function(We, Xe) {
      We = We || 10, Xe = Xe | 0 || 1;
      var rt;
      if (We === 16 || We === "hex") {
        rt = "";
        for (var ot = 0, ft = 0, mt = 0; mt < (this || _global$6).length; mt++) {
          var yt = (this || _global$6).words[mt], pt = ((yt << ot | ft) & 16777215).toString(16);
          ft = yt >>> 24 - ot & 16777215, ft !== 0 || mt !== (this || _global$6).length - 1 ? rt = lt[6 - pt.length] + pt + rt : rt = pt + rt, ot += 2, ot >= 26 && (ot -= 26, mt--);
        }
        for (ft !== 0 && (rt = ft.toString(16) + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$6).negative !== 0 && (rt = "-" + rt), rt;
      }
      if (We === (We | 0) && We >= 2 && We <= 36) {
        var Ge = dt[We], ct = bt[We];
        rt = "";
        var Mt = this.clone();
        for (Mt.negative = 0; !Mt.isZero(); ) {
          var St = Mt.modn(ct).toString(We);
          Mt = Mt.idivn(ct), Mt.isZero() ? rt = St + rt : rt = lt[Ge - St.length] + St + rt;
        }
        for (this.isZero() && (rt = "0" + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$6).negative !== 0 && (rt = "-" + rt), rt;
      }
      Fe(!1, "Base should be between 2 and 36");
    }, Ve.prototype.toNumber = function() {
      var We = (this || _global$6).words[0];
      return (this || _global$6).length === 2 ? We += (this || _global$6).words[1] * 67108864 : (this || _global$6).length === 3 && (this || _global$6).words[2] === 1 ? We += 4503599627370496 + (this || _global$6).words[1] * 67108864 : (this || _global$6).length > 2 && Fe(!1, "Number can only safely store up to 53 bits"), (this || _global$6).negative !== 0 ? -We : We;
    }, Ve.prototype.toJSON = function() {
      return this.toString(16);
    }, Ve.prototype.toBuffer = function(We, Xe) {
      return Fe(typeof Je < "u"), this.toArrayLike(Je, We, Xe);
    }, Ve.prototype.toArray = function(We, Xe) {
      return this.toArrayLike(Array, We, Xe);
    }, Ve.prototype.toArrayLike = function(We, Xe, rt) {
      var ot = this.byteLength(), ft = rt || Math.max(1, ot);
      Fe(ot <= ft, "byte array longer than desired length"), Fe(ft > 0, "Requested array length <= 0"), this.strip();
      var mt = Xe === "le", yt = new We(ft), pt, Ge, ct = this.clone();
      if (mt) {
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[Ge] = pt;
        for (; Ge < ft; Ge++)
          yt[Ge] = 0;
      } else {
        for (Ge = 0; Ge < ft - ot; Ge++)
          yt[Ge] = 0;
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[ft - Ge - 1] = pt;
      }
      return yt;
    }, Math.clz32 ? Ve.prototype._countBits = function(We) {
      return 32 - Math.clz32(We);
    } : Ve.prototype._countBits = function(We) {
      var Xe = We, rt = 0;
      return Xe >= 4096 && (rt += 13, Xe >>>= 13), Xe >= 64 && (rt += 7, Xe >>>= 7), Xe >= 8 && (rt += 4, Xe >>>= 4), Xe >= 2 && (rt += 2, Xe >>>= 2), rt + Xe;
    }, Ve.prototype._zeroBits = function(We) {
      if (We === 0)
        return 26;
      var Xe = We, rt = 0;
      return Xe & 8191 || (rt += 13, Xe >>>= 13), Xe & 127 || (rt += 7, Xe >>>= 7), Xe & 15 || (rt += 4, Xe >>>= 4), Xe & 3 || (rt += 2, Xe >>>= 2), Xe & 1 || rt++, rt;
    }, Ve.prototype.bitLength = function() {
      var We = (this || _global$6).words[(this || _global$6).length - 1], Xe = this._countBits(We);
      return ((this || _global$6).length - 1) * 26 + Xe;
    };
    function $t(gt) {
      for (var We = new Array(gt.bitLength()), Xe = 0; Xe < We.length; Xe++) {
        var rt = Xe / 26 | 0, ot = Xe % 26;
        We[Xe] = (gt.words[rt] & 1 << ot) >>> ot;
      }
      return We;
    }
    Ve.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var We = 0, Xe = 0; Xe < (this || _global$6).length; Xe++) {
        var rt = this._zeroBits((this || _global$6).words[Xe]);
        if (We += rt, rt !== 26)
          break;
      }
      return We;
    }, Ve.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Ve.prototype.toTwos = function(We) {
      return (this || _global$6).negative !== 0 ? this.abs().inotn(We).iaddn(1) : this.clone();
    }, Ve.prototype.fromTwos = function(We) {
      return this.testn(We - 1) ? this.notn(We).iaddn(1).ineg() : this.clone();
    }, Ve.prototype.isNeg = function() {
      return (this || _global$6).negative !== 0;
    }, Ve.prototype.neg = function() {
      return this.clone().ineg();
    }, Ve.prototype.ineg = function() {
      return this.isZero() || ((this || _global$6).negative ^= 1), this || _global$6;
    }, Ve.prototype.iuor = function(We) {
      for (; (this || _global$6).length < We.length; )
        (this || _global$6).words[(this || _global$6).length++] = 0;
      for (var Xe = 0; Xe < We.length; Xe++)
        (this || _global$6).words[Xe] = (this || _global$6).words[Xe] | We.words[Xe];
      return this.strip();
    }, Ve.prototype.ior = function(We) {
      return Fe(((this || _global$6).negative | We.negative) === 0), this.iuor(We);
    }, Ve.prototype.or = function(We) {
      return (this || _global$6).length > We.length ? this.clone().ior(We) : We.clone().ior(this || _global$6);
    }, Ve.prototype.uor = function(We) {
      return (this || _global$6).length > We.length ? this.clone().iuor(We) : We.clone().iuor(this || _global$6);
    }, Ve.prototype.iuand = function(We) {
      var Xe;
      (this || _global$6).length > We.length ? Xe = We : Xe = this || _global$6;
      for (var rt = 0; rt < Xe.length; rt++)
        (this || _global$6).words[rt] = (this || _global$6).words[rt] & We.words[rt];
      return (this || _global$6).length = Xe.length, this.strip();
    }, Ve.prototype.iand = function(We) {
      return Fe(((this || _global$6).negative | We.negative) === 0), this.iuand(We);
    }, Ve.prototype.and = function(We) {
      return (this || _global$6).length > We.length ? this.clone().iand(We) : We.clone().iand(this || _global$6);
    }, Ve.prototype.uand = function(We) {
      return (this || _global$6).length > We.length ? this.clone().iuand(We) : We.clone().iuand(this || _global$6);
    }, Ve.prototype.iuxor = function(We) {
      var Xe, rt;
      (this || _global$6).length > We.length ? (Xe = this || _global$6, rt = We) : (Xe = We, rt = this || _global$6);
      for (var ot = 0; ot < rt.length; ot++)
        (this || _global$6).words[ot] = Xe.words[ot] ^ rt.words[ot];
      if ((this || _global$6) !== Xe)
        for (; ot < Xe.length; ot++)
          (this || _global$6).words[ot] = Xe.words[ot];
      return (this || _global$6).length = Xe.length, this.strip();
    }, Ve.prototype.ixor = function(We) {
      return Fe(((this || _global$6).negative | We.negative) === 0), this.iuxor(We);
    }, Ve.prototype.xor = function(We) {
      return (this || _global$6).length > We.length ? this.clone().ixor(We) : We.clone().ixor(this || _global$6);
    }, Ve.prototype.uxor = function(We) {
      return (this || _global$6).length > We.length ? this.clone().iuxor(We) : We.clone().iuxor(this || _global$6);
    }, Ve.prototype.inotn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = Math.ceil(We / 26) | 0, rt = We % 26;
      this._expand(Xe), rt > 0 && Xe--;
      for (var ot = 0; ot < Xe; ot++)
        (this || _global$6).words[ot] = ~(this || _global$6).words[ot] & 67108863;
      return rt > 0 && ((this || _global$6).words[ot] = ~(this || _global$6).words[ot] & 67108863 >> 26 - rt), this.strip();
    }, Ve.prototype.notn = function(We) {
      return this.clone().inotn(We);
    }, Ve.prototype.setn = function(We, Xe) {
      Fe(typeof We == "number" && We >= 0);
      var rt = We / 26 | 0, ot = We % 26;
      return this._expand(rt + 1), Xe ? (this || _global$6).words[rt] = (this || _global$6).words[rt] | 1 << ot : (this || _global$6).words[rt] = (this || _global$6).words[rt] & ~(1 << ot), this.strip();
    }, Ve.prototype.iadd = function(We) {
      var Xe;
      if ((this || _global$6).negative !== 0 && We.negative === 0)
        return (this || _global$6).negative = 0, Xe = this.isub(We), (this || _global$6).negative ^= 1, this._normSign();
      if ((this || _global$6).negative === 0 && We.negative !== 0)
        return We.negative = 0, Xe = this.isub(We), We.negative = 1, Xe._normSign();
      var rt, ot;
      (this || _global$6).length > We.length ? (rt = this || _global$6, ot = We) : (rt = We, ot = this || _global$6);
      for (var ft = 0, mt = 0; mt < ot.length; mt++)
        Xe = (rt.words[mt] | 0) + (ot.words[mt] | 0) + ft, (this || _global$6).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      for (; ft !== 0 && mt < rt.length; mt++)
        Xe = (rt.words[mt] | 0) + ft, (this || _global$6).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      if ((this || _global$6).length = rt.length, ft !== 0)
        (this || _global$6).words[(this || _global$6).length] = ft, (this || _global$6).length++;
      else if (rt !== (this || _global$6))
        for (; mt < rt.length; mt++)
          (this || _global$6).words[mt] = rt.words[mt];
      return this || _global$6;
    }, Ve.prototype.add = function(We) {
      var Xe;
      return We.negative !== 0 && (this || _global$6).negative === 0 ? (We.negative = 0, Xe = this.sub(We), We.negative ^= 1, Xe) : We.negative === 0 && (this || _global$6).negative !== 0 ? ((this || _global$6).negative = 0, Xe = We.sub(this || _global$6), (this || _global$6).negative = 1, Xe) : (this || _global$6).length > We.length ? this.clone().iadd(We) : We.clone().iadd(this || _global$6);
    }, Ve.prototype.isub = function(We) {
      if (We.negative !== 0) {
        We.negative = 0;
        var Xe = this.iadd(We);
        return We.negative = 1, Xe._normSign();
      } else if ((this || _global$6).negative !== 0)
        return (this || _global$6).negative = 0, this.iadd(We), (this || _global$6).negative = 1, this._normSign();
      var rt = this.cmp(We);
      if (rt === 0)
        return (this || _global$6).negative = 0, (this || _global$6).length = 1, (this || _global$6).words[0] = 0, this || _global$6;
      var ot, ft;
      rt > 0 ? (ot = this || _global$6, ft = We) : (ot = We, ft = this || _global$6);
      for (var mt = 0, yt = 0; yt < ft.length; yt++)
        Xe = (ot.words[yt] | 0) - (ft.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$6).words[yt] = Xe & 67108863;
      for (; mt !== 0 && yt < ot.length; yt++)
        Xe = (ot.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$6).words[yt] = Xe & 67108863;
      if (mt === 0 && yt < ot.length && ot !== (this || _global$6))
        for (; yt < ot.length; yt++)
          (this || _global$6).words[yt] = ot.words[yt];
      return (this || _global$6).length = Math.max((this || _global$6).length, yt), ot !== (this || _global$6) && ((this || _global$6).negative = 1), this.strip();
    }, Ve.prototype.sub = function(We) {
      return this.clone().isub(We);
    };
    function vt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative;
      var rt = gt.length + We.length | 0;
      Xe.length = rt, rt = rt - 1 | 0;
      var ot = gt.words[0] | 0, ft = We.words[0] | 0, mt = ot * ft, yt = mt & 67108863, pt = mt / 67108864 | 0;
      Xe.words[0] = yt;
      for (var Ge = 1; Ge < rt; Ge++) {
        for (var ct = pt >>> 26, Mt = pt & 67108863, St = Math.min(Ge, We.length - 1), At = Math.max(0, Ge - gt.length + 1); At <= St; At++) {
          var Nt = Ge - At | 0;
          ot = gt.words[Nt] | 0, ft = We.words[At] | 0, mt = ot * ft + Mt, ct += mt / 67108864 | 0, Mt = mt & 67108863;
        }
        Xe.words[Ge] = Mt | 0, pt = ct | 0;
      }
      return pt !== 0 ? Xe.words[Ge] = pt | 0 : Xe.length--, Xe.strip();
    }
    var wt = function(We, Xe, rt) {
      var ot = We.words, ft = Xe.words, mt = rt.words, yt = 0, pt, Ge, ct, Mt = ot[0] | 0, St = Mt & 8191, At = Mt >>> 13, Nt = ot[1] | 0, qt = Nt & 8191, Qt = Nt >>> 13, Xt = ot[2] | 0, zt = Xt & 8191, Kt = Xt >>> 13, ur = ot[3] | 0, er = ur & 8191, Dt = ur >>> 13, Ht = ot[4] | 0, Gt = Ht & 8191, rr = Ht >>> 13, sr = ot[5] | 0, Jt = sr & 8191, ir = sr >>> 13, Br = ot[6] | 0, or = Br & 8191, lr = Br >>> 13, Nr = ot[7] | 0, dr = Nr & 8191, gr = Nr >>> 13, Zr = ot[8] | 0, Bt = Zr & 8191, kt = Zr >>> 13, It = ot[9] | 0, jt = It & 8191, Vt = It >>> 13, ar = ft[0] | 0, Yt = ar & 8191, hr = ar >>> 13, zr = ft[1] | 0, cr = zr & 8191, _r = zr >>> 13, Lr = ft[2] | 0, br = Lr & 8191, kr = Lr >>> 13, Xr = ft[3] | 0, yr = Xr & 8191, Ir = Xr >>> 13, Yr = ft[4] | 0, wr = Yr & 8191, Cr = Yr >>> 13, Hr = ft[5] | 0, $r = Hr & 8191, Ar = Hr >>> 13, Wr = ft[6] | 0, mr = Wr & 8191, Tr = Wr >>> 13, Kr = ft[7] | 0, vr = Kr & 8191, Rr = Kr >>> 13, Jr = ft[8] | 0, xr = Jr & 8191, tr = Jr >>> 13, Dr = ft[9] | 0, fr = Dr & 8191, Mr = Dr >>> 13;
      rt.negative = We.negative ^ Xe.negative, rt.length = 19, pt = Math.imul(St, Yt), Ge = Math.imul(St, hr), Ge = Ge + Math.imul(At, Yt) | 0, ct = Math.imul(At, hr);
      var Fr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, pt = Math.imul(qt, Yt), Ge = Math.imul(qt, hr), Ge = Ge + Math.imul(Qt, Yt) | 0, ct = Math.imul(Qt, hr), pt = pt + Math.imul(St, cr) | 0, Ge = Ge + Math.imul(St, _r) | 0, Ge = Ge + Math.imul(At, cr) | 0, ct = ct + Math.imul(At, _r) | 0;
      var qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, pt = Math.imul(zt, Yt), Ge = Math.imul(zt, hr), Ge = Ge + Math.imul(Kt, Yt) | 0, ct = Math.imul(Kt, hr), pt = pt + Math.imul(qt, cr) | 0, Ge = Ge + Math.imul(qt, _r) | 0, Ge = Ge + Math.imul(Qt, cr) | 0, ct = ct + Math.imul(Qt, _r) | 0, pt = pt + Math.imul(St, br) | 0, Ge = Ge + Math.imul(St, kr) | 0, Ge = Ge + Math.imul(At, br) | 0, ct = ct + Math.imul(At, kr) | 0;
      var tn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, pt = Math.imul(er, Yt), Ge = Math.imul(er, hr), Ge = Ge + Math.imul(Dt, Yt) | 0, ct = Math.imul(Dt, hr), pt = pt + Math.imul(zt, cr) | 0, Ge = Ge + Math.imul(zt, _r) | 0, Ge = Ge + Math.imul(Kt, cr) | 0, ct = ct + Math.imul(Kt, _r) | 0, pt = pt + Math.imul(qt, br) | 0, Ge = Ge + Math.imul(qt, kr) | 0, Ge = Ge + Math.imul(Qt, br) | 0, ct = ct + Math.imul(Qt, kr) | 0, pt = pt + Math.imul(St, yr) | 0, Ge = Ge + Math.imul(St, Ir) | 0, Ge = Ge + Math.imul(At, yr) | 0, ct = ct + Math.imul(At, Ir) | 0;
      var Qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, pt = Math.imul(Gt, Yt), Ge = Math.imul(Gt, hr), Ge = Ge + Math.imul(rr, Yt) | 0, ct = Math.imul(rr, hr), pt = pt + Math.imul(er, cr) | 0, Ge = Ge + Math.imul(er, _r) | 0, Ge = Ge + Math.imul(Dt, cr) | 0, ct = ct + Math.imul(Dt, _r) | 0, pt = pt + Math.imul(zt, br) | 0, Ge = Ge + Math.imul(zt, kr) | 0, Ge = Ge + Math.imul(Kt, br) | 0, ct = ct + Math.imul(Kt, kr) | 0, pt = pt + Math.imul(qt, yr) | 0, Ge = Ge + Math.imul(qt, Ir) | 0, Ge = Ge + Math.imul(Qt, yr) | 0, ct = ct + Math.imul(Qt, Ir) | 0, pt = pt + Math.imul(St, wr) | 0, Ge = Ge + Math.imul(St, Cr) | 0, Ge = Ge + Math.imul(At, wr) | 0, ct = ct + Math.imul(At, Cr) | 0;
      var nn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, pt = Math.imul(Jt, Yt), Ge = Math.imul(Jt, hr), Ge = Ge + Math.imul(ir, Yt) | 0, ct = Math.imul(ir, hr), pt = pt + Math.imul(Gt, cr) | 0, Ge = Ge + Math.imul(Gt, _r) | 0, Ge = Ge + Math.imul(rr, cr) | 0, ct = ct + Math.imul(rr, _r) | 0, pt = pt + Math.imul(er, br) | 0, Ge = Ge + Math.imul(er, kr) | 0, Ge = Ge + Math.imul(Dt, br) | 0, ct = ct + Math.imul(Dt, kr) | 0, pt = pt + Math.imul(zt, yr) | 0, Ge = Ge + Math.imul(zt, Ir) | 0, Ge = Ge + Math.imul(Kt, yr) | 0, ct = ct + Math.imul(Kt, Ir) | 0, pt = pt + Math.imul(qt, wr) | 0, Ge = Ge + Math.imul(qt, Cr) | 0, Ge = Ge + Math.imul(Qt, wr) | 0, ct = ct + Math.imul(Qt, Cr) | 0, pt = pt + Math.imul(St, $r) | 0, Ge = Ge + Math.imul(St, Ar) | 0, Ge = Ge + Math.imul(At, $r) | 0, ct = ct + Math.imul(At, Ar) | 0;
      var Er = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, pt = Math.imul(or, Yt), Ge = Math.imul(or, hr), Ge = Ge + Math.imul(lr, Yt) | 0, ct = Math.imul(lr, hr), pt = pt + Math.imul(Jt, cr) | 0, Ge = Ge + Math.imul(Jt, _r) | 0, Ge = Ge + Math.imul(ir, cr) | 0, ct = ct + Math.imul(ir, _r) | 0, pt = pt + Math.imul(Gt, br) | 0, Ge = Ge + Math.imul(Gt, kr) | 0, Ge = Ge + Math.imul(rr, br) | 0, ct = ct + Math.imul(rr, kr) | 0, pt = pt + Math.imul(er, yr) | 0, Ge = Ge + Math.imul(er, Ir) | 0, Ge = Ge + Math.imul(Dt, yr) | 0, ct = ct + Math.imul(Dt, Ir) | 0, pt = pt + Math.imul(zt, wr) | 0, Ge = Ge + Math.imul(zt, Cr) | 0, Ge = Ge + Math.imul(Kt, wr) | 0, ct = ct + Math.imul(Kt, Cr) | 0, pt = pt + Math.imul(qt, $r) | 0, Ge = Ge + Math.imul(qt, Ar) | 0, Ge = Ge + Math.imul(Qt, $r) | 0, ct = ct + Math.imul(Qt, Ar) | 0, pt = pt + Math.imul(St, mr) | 0, Ge = Ge + Math.imul(St, Tr) | 0, Ge = Ge + Math.imul(At, mr) | 0, ct = ct + Math.imul(At, Tr) | 0;
      var Wt = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, pt = Math.imul(dr, Yt), Ge = Math.imul(dr, hr), Ge = Ge + Math.imul(gr, Yt) | 0, ct = Math.imul(gr, hr), pt = pt + Math.imul(or, cr) | 0, Ge = Ge + Math.imul(or, _r) | 0, Ge = Ge + Math.imul(lr, cr) | 0, ct = ct + Math.imul(lr, _r) | 0, pt = pt + Math.imul(Jt, br) | 0, Ge = Ge + Math.imul(Jt, kr) | 0, Ge = Ge + Math.imul(ir, br) | 0, ct = ct + Math.imul(ir, kr) | 0, pt = pt + Math.imul(Gt, yr) | 0, Ge = Ge + Math.imul(Gt, Ir) | 0, Ge = Ge + Math.imul(rr, yr) | 0, ct = ct + Math.imul(rr, Ir) | 0, pt = pt + Math.imul(er, wr) | 0, Ge = Ge + Math.imul(er, Cr) | 0, Ge = Ge + Math.imul(Dt, wr) | 0, ct = ct + Math.imul(Dt, Cr) | 0, pt = pt + Math.imul(zt, $r) | 0, Ge = Ge + Math.imul(zt, Ar) | 0, Ge = Ge + Math.imul(Kt, $r) | 0, ct = ct + Math.imul(Kt, Ar) | 0, pt = pt + Math.imul(qt, mr) | 0, Ge = Ge + Math.imul(qt, Tr) | 0, Ge = Ge + Math.imul(Qt, mr) | 0, ct = ct + Math.imul(Qt, Tr) | 0, pt = pt + Math.imul(St, vr) | 0, Ge = Ge + Math.imul(St, Rr) | 0, Ge = Ge + Math.imul(At, vr) | 0, ct = ct + Math.imul(At, Rr) | 0;
      var nr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, pt = Math.imul(Bt, Yt), Ge = Math.imul(Bt, hr), Ge = Ge + Math.imul(kt, Yt) | 0, ct = Math.imul(kt, hr), pt = pt + Math.imul(dr, cr) | 0, Ge = Ge + Math.imul(dr, _r) | 0, Ge = Ge + Math.imul(gr, cr) | 0, ct = ct + Math.imul(gr, _r) | 0, pt = pt + Math.imul(or, br) | 0, Ge = Ge + Math.imul(or, kr) | 0, Ge = Ge + Math.imul(lr, br) | 0, ct = ct + Math.imul(lr, kr) | 0, pt = pt + Math.imul(Jt, yr) | 0, Ge = Ge + Math.imul(Jt, Ir) | 0, Ge = Ge + Math.imul(ir, yr) | 0, ct = ct + Math.imul(ir, Ir) | 0, pt = pt + Math.imul(Gt, wr) | 0, Ge = Ge + Math.imul(Gt, Cr) | 0, Ge = Ge + Math.imul(rr, wr) | 0, ct = ct + Math.imul(rr, Cr) | 0, pt = pt + Math.imul(er, $r) | 0, Ge = Ge + Math.imul(er, Ar) | 0, Ge = Ge + Math.imul(Dt, $r) | 0, ct = ct + Math.imul(Dt, Ar) | 0, pt = pt + Math.imul(zt, mr) | 0, Ge = Ge + Math.imul(zt, Tr) | 0, Ge = Ge + Math.imul(Kt, mr) | 0, ct = ct + Math.imul(Kt, Tr) | 0, pt = pt + Math.imul(qt, vr) | 0, Ge = Ge + Math.imul(qt, Rr) | 0, Ge = Ge + Math.imul(Qt, vr) | 0, ct = ct + Math.imul(Qt, Rr) | 0, pt = pt + Math.imul(St, xr) | 0, Ge = Ge + Math.imul(St, tr) | 0, Ge = Ge + Math.imul(At, xr) | 0, ct = ct + Math.imul(At, tr) | 0;
      var pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, pt = Math.imul(jt, Yt), Ge = Math.imul(jt, hr), Ge = Ge + Math.imul(Vt, Yt) | 0, ct = Math.imul(Vt, hr), pt = pt + Math.imul(Bt, cr) | 0, Ge = Ge + Math.imul(Bt, _r) | 0, Ge = Ge + Math.imul(kt, cr) | 0, ct = ct + Math.imul(kt, _r) | 0, pt = pt + Math.imul(dr, br) | 0, Ge = Ge + Math.imul(dr, kr) | 0, Ge = Ge + Math.imul(gr, br) | 0, ct = ct + Math.imul(gr, kr) | 0, pt = pt + Math.imul(or, yr) | 0, Ge = Ge + Math.imul(or, Ir) | 0, Ge = Ge + Math.imul(lr, yr) | 0, ct = ct + Math.imul(lr, Ir) | 0, pt = pt + Math.imul(Jt, wr) | 0, Ge = Ge + Math.imul(Jt, Cr) | 0, Ge = Ge + Math.imul(ir, wr) | 0, ct = ct + Math.imul(ir, Cr) | 0, pt = pt + Math.imul(Gt, $r) | 0, Ge = Ge + Math.imul(Gt, Ar) | 0, Ge = Ge + Math.imul(rr, $r) | 0, ct = ct + Math.imul(rr, Ar) | 0, pt = pt + Math.imul(er, mr) | 0, Ge = Ge + Math.imul(er, Tr) | 0, Ge = Ge + Math.imul(Dt, mr) | 0, ct = ct + Math.imul(Dt, Tr) | 0, pt = pt + Math.imul(zt, vr) | 0, Ge = Ge + Math.imul(zt, Rr) | 0, Ge = Ge + Math.imul(Kt, vr) | 0, ct = ct + Math.imul(Kt, Rr) | 0, pt = pt + Math.imul(qt, xr) | 0, Ge = Ge + Math.imul(qt, tr) | 0, Ge = Ge + Math.imul(Qt, xr) | 0, ct = ct + Math.imul(Qt, tr) | 0, pt = pt + Math.imul(St, fr) | 0, Ge = Ge + Math.imul(St, Mr) | 0, Ge = Ge + Math.imul(At, fr) | 0, ct = ct + Math.imul(At, Mr) | 0;
      var Pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, pt = Math.imul(jt, cr), Ge = Math.imul(jt, _r), Ge = Ge + Math.imul(Vt, cr) | 0, ct = Math.imul(Vt, _r), pt = pt + Math.imul(Bt, br) | 0, Ge = Ge + Math.imul(Bt, kr) | 0, Ge = Ge + Math.imul(kt, br) | 0, ct = ct + Math.imul(kt, kr) | 0, pt = pt + Math.imul(dr, yr) | 0, Ge = Ge + Math.imul(dr, Ir) | 0, Ge = Ge + Math.imul(gr, yr) | 0, ct = ct + Math.imul(gr, Ir) | 0, pt = pt + Math.imul(or, wr) | 0, Ge = Ge + Math.imul(or, Cr) | 0, Ge = Ge + Math.imul(lr, wr) | 0, ct = ct + Math.imul(lr, Cr) | 0, pt = pt + Math.imul(Jt, $r) | 0, Ge = Ge + Math.imul(Jt, Ar) | 0, Ge = Ge + Math.imul(ir, $r) | 0, ct = ct + Math.imul(ir, Ar) | 0, pt = pt + Math.imul(Gt, mr) | 0, Ge = Ge + Math.imul(Gt, Tr) | 0, Ge = Ge + Math.imul(rr, mr) | 0, ct = ct + Math.imul(rr, Tr) | 0, pt = pt + Math.imul(er, vr) | 0, Ge = Ge + Math.imul(er, Rr) | 0, Ge = Ge + Math.imul(Dt, vr) | 0, ct = ct + Math.imul(Dt, Rr) | 0, pt = pt + Math.imul(zt, xr) | 0, Ge = Ge + Math.imul(zt, tr) | 0, Ge = Ge + Math.imul(Kt, xr) | 0, ct = ct + Math.imul(Kt, tr) | 0, pt = pt + Math.imul(qt, fr) | 0, Ge = Ge + Math.imul(qt, Mr) | 0, Ge = Ge + Math.imul(Qt, fr) | 0, ct = ct + Math.imul(Qt, Mr) | 0;
      var Sr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, pt = Math.imul(jt, br), Ge = Math.imul(jt, kr), Ge = Ge + Math.imul(Vt, br) | 0, ct = Math.imul(Vt, kr), pt = pt + Math.imul(Bt, yr) | 0, Ge = Ge + Math.imul(Bt, Ir) | 0, Ge = Ge + Math.imul(kt, yr) | 0, ct = ct + Math.imul(kt, Ir) | 0, pt = pt + Math.imul(dr, wr) | 0, Ge = Ge + Math.imul(dr, Cr) | 0, Ge = Ge + Math.imul(gr, wr) | 0, ct = ct + Math.imul(gr, Cr) | 0, pt = pt + Math.imul(or, $r) | 0, Ge = Ge + Math.imul(or, Ar) | 0, Ge = Ge + Math.imul(lr, $r) | 0, ct = ct + Math.imul(lr, Ar) | 0, pt = pt + Math.imul(Jt, mr) | 0, Ge = Ge + Math.imul(Jt, Tr) | 0, Ge = Ge + Math.imul(ir, mr) | 0, ct = ct + Math.imul(ir, Tr) | 0, pt = pt + Math.imul(Gt, vr) | 0, Ge = Ge + Math.imul(Gt, Rr) | 0, Ge = Ge + Math.imul(rr, vr) | 0, ct = ct + Math.imul(rr, Rr) | 0, pt = pt + Math.imul(er, xr) | 0, Ge = Ge + Math.imul(er, tr) | 0, Ge = Ge + Math.imul(Dt, xr) | 0, ct = ct + Math.imul(Dt, tr) | 0, pt = pt + Math.imul(zt, fr) | 0, Ge = Ge + Math.imul(zt, Mr) | 0, Ge = Ge + Math.imul(Kt, fr) | 0, ct = ct + Math.imul(Kt, Mr) | 0;
      var Ur = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, pt = Math.imul(jt, yr), Ge = Math.imul(jt, Ir), Ge = Ge + Math.imul(Vt, yr) | 0, ct = Math.imul(Vt, Ir), pt = pt + Math.imul(Bt, wr) | 0, Ge = Ge + Math.imul(Bt, Cr) | 0, Ge = Ge + Math.imul(kt, wr) | 0, ct = ct + Math.imul(kt, Cr) | 0, pt = pt + Math.imul(dr, $r) | 0, Ge = Ge + Math.imul(dr, Ar) | 0, Ge = Ge + Math.imul(gr, $r) | 0, ct = ct + Math.imul(gr, Ar) | 0, pt = pt + Math.imul(or, mr) | 0, Ge = Ge + Math.imul(or, Tr) | 0, Ge = Ge + Math.imul(lr, mr) | 0, ct = ct + Math.imul(lr, Tr) | 0, pt = pt + Math.imul(Jt, vr) | 0, Ge = Ge + Math.imul(Jt, Rr) | 0, Ge = Ge + Math.imul(ir, vr) | 0, ct = ct + Math.imul(ir, Rr) | 0, pt = pt + Math.imul(Gt, xr) | 0, Ge = Ge + Math.imul(Gt, tr) | 0, Ge = Ge + Math.imul(rr, xr) | 0, ct = ct + Math.imul(rr, tr) | 0, pt = pt + Math.imul(er, fr) | 0, Ge = Ge + Math.imul(er, Mr) | 0, Ge = Ge + Math.imul(Dt, fr) | 0, ct = ct + Math.imul(Dt, Mr) | 0;
      var jr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, pt = Math.imul(jt, wr), Ge = Math.imul(jt, Cr), Ge = Ge + Math.imul(Vt, wr) | 0, ct = Math.imul(Vt, Cr), pt = pt + Math.imul(Bt, $r) | 0, Ge = Ge + Math.imul(Bt, Ar) | 0, Ge = Ge + Math.imul(kt, $r) | 0, ct = ct + Math.imul(kt, Ar) | 0, pt = pt + Math.imul(dr, mr) | 0, Ge = Ge + Math.imul(dr, Tr) | 0, Ge = Ge + Math.imul(gr, mr) | 0, ct = ct + Math.imul(gr, Tr) | 0, pt = pt + Math.imul(or, vr) | 0, Ge = Ge + Math.imul(or, Rr) | 0, Ge = Ge + Math.imul(lr, vr) | 0, ct = ct + Math.imul(lr, Rr) | 0, pt = pt + Math.imul(Jt, xr) | 0, Ge = Ge + Math.imul(Jt, tr) | 0, Ge = Ge + Math.imul(ir, xr) | 0, ct = ct + Math.imul(ir, tr) | 0, pt = pt + Math.imul(Gt, fr) | 0, Ge = Ge + Math.imul(Gt, Mr) | 0, Ge = Ge + Math.imul(rr, fr) | 0, ct = ct + Math.imul(rr, Mr) | 0;
      var Gr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, pt = Math.imul(jt, $r), Ge = Math.imul(jt, Ar), Ge = Ge + Math.imul(Vt, $r) | 0, ct = Math.imul(Vt, Ar), pt = pt + Math.imul(Bt, mr) | 0, Ge = Ge + Math.imul(Bt, Tr) | 0, Ge = Ge + Math.imul(kt, mr) | 0, ct = ct + Math.imul(kt, Tr) | 0, pt = pt + Math.imul(dr, vr) | 0, Ge = Ge + Math.imul(dr, Rr) | 0, Ge = Ge + Math.imul(gr, vr) | 0, ct = ct + Math.imul(gr, Rr) | 0, pt = pt + Math.imul(or, xr) | 0, Ge = Ge + Math.imul(or, tr) | 0, Ge = Ge + Math.imul(lr, xr) | 0, ct = ct + Math.imul(lr, tr) | 0, pt = pt + Math.imul(Jt, fr) | 0, Ge = Ge + Math.imul(Jt, Mr) | 0, Ge = Ge + Math.imul(ir, fr) | 0, ct = ct + Math.imul(ir, Mr) | 0;
      var Vr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, pt = Math.imul(jt, mr), Ge = Math.imul(jt, Tr), Ge = Ge + Math.imul(Vt, mr) | 0, ct = Math.imul(Vt, Tr), pt = pt + Math.imul(Bt, vr) | 0, Ge = Ge + Math.imul(Bt, Rr) | 0, Ge = Ge + Math.imul(kt, vr) | 0, ct = ct + Math.imul(kt, Rr) | 0, pt = pt + Math.imul(dr, xr) | 0, Ge = Ge + Math.imul(dr, tr) | 0, Ge = Ge + Math.imul(gr, xr) | 0, ct = ct + Math.imul(gr, tr) | 0, pt = pt + Math.imul(or, fr) | 0, Ge = Ge + Math.imul(or, Mr) | 0, Ge = Ge + Math.imul(lr, fr) | 0, ct = ct + Math.imul(lr, Mr) | 0;
      var rn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, pt = Math.imul(jt, vr), Ge = Math.imul(jt, Rr), Ge = Ge + Math.imul(Vt, vr) | 0, ct = Math.imul(Vt, Rr), pt = pt + Math.imul(Bt, xr) | 0, Ge = Ge + Math.imul(Bt, tr) | 0, Ge = Ge + Math.imul(kt, xr) | 0, ct = ct + Math.imul(kt, tr) | 0, pt = pt + Math.imul(dr, fr) | 0, Ge = Ge + Math.imul(dr, Mr) | 0, Ge = Ge + Math.imul(gr, fr) | 0, ct = ct + Math.imul(gr, Mr) | 0;
      var an = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, pt = Math.imul(jt, xr), Ge = Math.imul(jt, tr), Ge = Ge + Math.imul(Vt, xr) | 0, ct = Math.imul(Vt, tr), pt = pt + Math.imul(Bt, fr) | 0, Ge = Ge + Math.imul(Bt, Mr) | 0, Ge = Ge + Math.imul(kt, fr) | 0, ct = ct + Math.imul(kt, Mr) | 0;
      var ln = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, pt = Math.imul(jt, fr), Ge = Math.imul(jt, Mr), Ge = Ge + Math.imul(Vt, fr) | 0, ct = Math.imul(Vt, Mr);
      var sn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      return yt = (ct + (Ge >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, mt[0] = Fr, mt[1] = qr, mt[2] = tn, mt[3] = Qr, mt[4] = nn, mt[5] = Er, mt[6] = Wt, mt[7] = nr, mt[8] = pr, mt[9] = Pr, mt[10] = Sr, mt[11] = Ur, mt[12] = jr, mt[13] = Gr, mt[14] = Vr, mt[15] = rn, mt[16] = an, mt[17] = ln, mt[18] = sn, yt !== 0 && (mt[19] = yt, rt.length++), rt;
    };
    Math.imul || (wt = vt);
    function xt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative, Xe.length = gt.length + We.length;
      for (var rt = 0, ot = 0, ft = 0; ft < Xe.length - 1; ft++) {
        var mt = ot;
        ot = 0;
        for (var yt = rt & 67108863, pt = Math.min(ft, We.length - 1), Ge = Math.max(0, ft - gt.length + 1); Ge <= pt; Ge++) {
          var ct = ft - Ge, Mt = gt.words[ct] | 0, St = We.words[Ge] | 0, At = Mt * St, Nt = At & 67108863;
          mt = mt + (At / 67108864 | 0) | 0, Nt = Nt + yt | 0, yt = Nt & 67108863, mt = mt + (Nt >>> 26) | 0, ot += mt >>> 26, mt &= 67108863;
        }
        Xe.words[ft] = yt, rt = mt, mt = ot;
      }
      return rt !== 0 ? Xe.words[ft] = rt : Xe.length--, Xe.strip();
    }
    function Et(gt, We, Xe) {
      var rt = new Tt();
      return rt.mulp(gt, We, Xe);
    }
    Ve.prototype.mulTo = function(We, Xe) {
      var rt, ot = (this || _global$6).length + We.length;
      return (this || _global$6).length === 10 && We.length === 10 ? rt = wt(this || _global$6, We, Xe) : ot < 63 ? rt = vt(this || _global$6, We, Xe) : ot < 1024 ? rt = xt(this || _global$6, We, Xe) : rt = Et(this || _global$6, We, Xe), rt;
    };
    function Tt(gt, We) {
      (this || _global$6).x = gt, (this || _global$6).y = We;
    }
    Tt.prototype.makeRBT = function(We) {
      for (var Xe = new Array(We), rt = Ve.prototype._countBits(We) - 1, ot = 0; ot < We; ot++)
        Xe[ot] = this.revBin(ot, rt, We);
      return Xe;
    }, Tt.prototype.revBin = function(We, Xe, rt) {
      if (We === 0 || We === rt - 1)
        return We;
      for (var ot = 0, ft = 0; ft < Xe; ft++)
        ot |= (We & 1) << Xe - ft - 1, We >>= 1;
      return ot;
    }, Tt.prototype.permute = function(We, Xe, rt, ot, ft, mt) {
      for (var yt = 0; yt < mt; yt++)
        ot[yt] = Xe[We[yt]], ft[yt] = rt[We[yt]];
    }, Tt.prototype.transform = function(We, Xe, rt, ot, ft, mt) {
      this.permute(mt, We, Xe, rt, ot, ft);
      for (var yt = 1; yt < ft; yt <<= 1)
        for (var pt = yt << 1, Ge = Math.cos(2 * Math.PI / pt), ct = Math.sin(2 * Math.PI / pt), Mt = 0; Mt < ft; Mt += pt)
          for (var St = Ge, At = ct, Nt = 0; Nt < yt; Nt++) {
            var qt = rt[Mt + Nt], Qt = ot[Mt + Nt], Xt = rt[Mt + Nt + yt], zt = ot[Mt + Nt + yt], Kt = St * Xt - At * zt;
            zt = St * zt + At * Xt, Xt = Kt, rt[Mt + Nt] = qt + Xt, ot[Mt + Nt] = Qt + zt, rt[Mt + Nt + yt] = qt - Xt, ot[Mt + Nt + yt] = Qt - zt, Nt !== pt && (Kt = Ge * St - ct * At, At = Ge * At + ct * St, St = Kt);
          }
    }, Tt.prototype.guessLen13b = function(We, Xe) {
      var rt = Math.max(Xe, We) | 1, ot = rt & 1, ft = 0;
      for (rt = rt / 2 | 0; rt; rt = rt >>> 1)
        ft++;
      return 1 << ft + 1 + ot;
    }, Tt.prototype.conjugate = function(We, Xe, rt) {
      if (!(rt <= 1))
        for (var ot = 0; ot < rt / 2; ot++) {
          var ft = We[ot];
          We[ot] = We[rt - ot - 1], We[rt - ot - 1] = ft, ft = Xe[ot], Xe[ot] = -Xe[rt - ot - 1], Xe[rt - ot - 1] = -ft;
        }
    }, Tt.prototype.normalize13b = function(We, Xe) {
      for (var rt = 0, ot = 0; ot < Xe / 2; ot++) {
        var ft = Math.round(We[2 * ot + 1] / Xe) * 8192 + Math.round(We[2 * ot] / Xe) + rt;
        We[ot] = ft & 67108863, ft < 67108864 ? rt = 0 : rt = ft / 67108864 | 0;
      }
      return We;
    }, Tt.prototype.convert13b = function(We, Xe, rt, ot) {
      for (var ft = 0, mt = 0; mt < Xe; mt++)
        ft = ft + (We[mt] | 0), rt[2 * mt] = ft & 8191, ft = ft >>> 13, rt[2 * mt + 1] = ft & 8191, ft = ft >>> 13;
      for (mt = 2 * Xe; mt < ot; ++mt)
        rt[mt] = 0;
      Fe(ft === 0), Fe((ft & -8192) === 0);
    }, Tt.prototype.stub = function(We) {
      for (var Xe = new Array(We), rt = 0; rt < We; rt++)
        Xe[rt] = 0;
      return Xe;
    }, Tt.prototype.mulp = function(We, Xe, rt) {
      var ot = 2 * this.guessLen13b(We.length, Xe.length), ft = this.makeRBT(ot), mt = this.stub(ot), yt = new Array(ot), pt = new Array(ot), Ge = new Array(ot), ct = new Array(ot), Mt = new Array(ot), St = new Array(ot), At = rt.words;
      At.length = ot, this.convert13b(We.words, We.length, yt, ot), this.convert13b(Xe.words, Xe.length, ct, ot), this.transform(yt, mt, pt, Ge, ot, ft), this.transform(ct, mt, Mt, St, ot, ft);
      for (var Nt = 0; Nt < ot; Nt++) {
        var qt = pt[Nt] * Mt[Nt] - Ge[Nt] * St[Nt];
        Ge[Nt] = pt[Nt] * St[Nt] + Ge[Nt] * Mt[Nt], pt[Nt] = qt;
      }
      return this.conjugate(pt, Ge, ot), this.transform(pt, Ge, At, mt, ot, ft), this.conjugate(At, mt, ot), this.normalize13b(At, ot), rt.negative = We.negative ^ Xe.negative, rt.length = We.length + Xe.length, rt.strip();
    }, Ve.prototype.mul = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$6).length + We.length), this.mulTo(We, Xe);
    }, Ve.prototype.mulf = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$6).length + We.length), Et(this || _global$6, We, Xe);
    }, Ve.prototype.imul = function(We) {
      return this.clone().mulTo(We, this || _global$6);
    }, Ve.prototype.imuln = function(We) {
      Fe(typeof We == "number"), Fe(We < 67108864);
      for (var Xe = 0, rt = 0; rt < (this || _global$6).length; rt++) {
        var ot = ((this || _global$6).words[rt] | 0) * We, ft = (ot & 67108863) + (Xe & 67108863);
        Xe >>= 26, Xe += ot / 67108864 | 0, Xe += ft >>> 26, (this || _global$6).words[rt] = ft & 67108863;
      }
      return Xe !== 0 && ((this || _global$6).words[rt] = Xe, (this || _global$6).length++), this || _global$6;
    }, Ve.prototype.muln = function(We) {
      return this.clone().imuln(We);
    }, Ve.prototype.sqr = function() {
      return this.mul(this || _global$6);
    }, Ve.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Ve.prototype.pow = function(We) {
      var Xe = $t(We);
      if (Xe.length === 0)
        return new Ve(1);
      for (var rt = this || _global$6, ot = 0; ot < Xe.length && Xe[ot] === 0; ot++, rt = rt.sqr())
        ;
      if (++ot < Xe.length)
        for (var ft = rt.sqr(); ot < Xe.length; ot++, ft = ft.sqr())
          Xe[ot] !== 0 && (rt = rt.mul(ft));
      return rt;
    }, Ve.prototype.iushln = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 67108863 >>> 26 - Xe << 26 - Xe, ft;
      if (Xe !== 0) {
        var mt = 0;
        for (ft = 0; ft < (this || _global$6).length; ft++) {
          var yt = (this || _global$6).words[ft] & ot, pt = ((this || _global$6).words[ft] | 0) - yt << Xe;
          (this || _global$6).words[ft] = pt | mt, mt = yt >>> 26 - Xe;
        }
        mt && ((this || _global$6).words[ft] = mt, (this || _global$6).length++);
      }
      if (rt !== 0) {
        for (ft = (this || _global$6).length - 1; ft >= 0; ft--)
          (this || _global$6).words[ft + rt] = (this || _global$6).words[ft];
        for (ft = 0; ft < rt; ft++)
          (this || _global$6).words[ft] = 0;
        (this || _global$6).length += rt;
      }
      return this.strip();
    }, Ve.prototype.ishln = function(We) {
      return Fe((this || _global$6).negative === 0), this.iushln(We);
    }, Ve.prototype.iushrn = function(We, Xe, rt) {
      Fe(typeof We == "number" && We >= 0);
      var ot;
      Xe ? ot = (Xe - Xe % 26) / 26 : ot = 0;
      var ft = We % 26, mt = Math.min((We - ft) / 26, (this || _global$6).length), yt = 67108863 ^ 67108863 >>> ft << ft, pt = rt;
      if (ot -= mt, ot = Math.max(0, ot), pt) {
        for (var Ge = 0; Ge < mt; Ge++)
          pt.words[Ge] = (this || _global$6).words[Ge];
        pt.length = mt;
      }
      if (mt !== 0)
        if ((this || _global$6).length > mt)
          for ((this || _global$6).length -= mt, Ge = 0; Ge < (this || _global$6).length; Ge++)
            (this || _global$6).words[Ge] = (this || _global$6).words[Ge + mt];
        else
          (this || _global$6).words[0] = 0, (this || _global$6).length = 1;
      var ct = 0;
      for (Ge = (this || _global$6).length - 1; Ge >= 0 && (ct !== 0 || Ge >= ot); Ge--) {
        var Mt = (this || _global$6).words[Ge] | 0;
        (this || _global$6).words[Ge] = ct << 26 - ft | Mt >>> ft, ct = Mt & yt;
      }
      return pt && ct !== 0 && (pt.words[pt.length++] = ct), (this || _global$6).length === 0 && ((this || _global$6).words[0] = 0, (this || _global$6).length = 1), this.strip();
    }, Ve.prototype.ishrn = function(We, Xe, rt) {
      return Fe((this || _global$6).negative === 0), this.iushrn(We, Xe, rt);
    }, Ve.prototype.shln = function(We) {
      return this.clone().ishln(We);
    }, Ve.prototype.ushln = function(We) {
      return this.clone().iushln(We);
    }, Ve.prototype.shrn = function(We) {
      return this.clone().ishrn(We);
    }, Ve.prototype.ushrn = function(We) {
      return this.clone().iushrn(We);
    }, Ve.prototype.testn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$6).length <= rt)
        return !1;
      var ft = (this || _global$6).words[rt];
      return !!(ft & ot);
    }, Ve.prototype.imaskn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26;
      if (Fe((this || _global$6).negative === 0, "imaskn works only with positive numbers"), (this || _global$6).length <= rt)
        return this || _global$6;
      if (Xe !== 0 && rt++, (this || _global$6).length = Math.min(rt, (this || _global$6).length), Xe !== 0) {
        var ot = 67108863 ^ 67108863 >>> Xe << Xe;
        (this || _global$6).words[(this || _global$6).length - 1] &= ot;
      }
      return this.strip();
    }, Ve.prototype.maskn = function(We) {
      return this.clone().imaskn(We);
    }, Ve.prototype.iaddn = function(We) {
      return Fe(typeof We == "number"), Fe(We < 67108864), We < 0 ? this.isubn(-We) : (this || _global$6).negative !== 0 ? (this || _global$6).length === 1 && ((this || _global$6).words[0] | 0) < We ? ((this || _global$6).words[0] = We - ((this || _global$6).words[0] | 0), (this || _global$6).negative = 0, this || _global$6) : ((this || _global$6).negative = 0, this.isubn(We), (this || _global$6).negative = 1, this || _global$6) : this._iaddn(We);
    }, Ve.prototype._iaddn = function(We) {
      (this || _global$6).words[0] += We;
      for (var Xe = 0; Xe < (this || _global$6).length && (this || _global$6).words[Xe] >= 67108864; Xe++)
        (this || _global$6).words[Xe] -= 67108864, Xe === (this || _global$6).length - 1 ? (this || _global$6).words[Xe + 1] = 1 : (this || _global$6).words[Xe + 1]++;
      return (this || _global$6).length = Math.max((this || _global$6).length, Xe + 1), this || _global$6;
    }, Ve.prototype.isubn = function(We) {
      if (Fe(typeof We == "number"), Fe(We < 67108864), We < 0)
        return this.iaddn(-We);
      if ((this || _global$6).negative !== 0)
        return (this || _global$6).negative = 0, this.iaddn(We), (this || _global$6).negative = 1, this || _global$6;
      if ((this || _global$6).words[0] -= We, (this || _global$6).length === 1 && (this || _global$6).words[0] < 0)
        (this || _global$6).words[0] = -(this || _global$6).words[0], (this || _global$6).negative = 1;
      else
        for (var Xe = 0; Xe < (this || _global$6).length && (this || _global$6).words[Xe] < 0; Xe++)
          (this || _global$6).words[Xe] += 67108864, (this || _global$6).words[Xe + 1] -= 1;
      return this.strip();
    }, Ve.prototype.addn = function(We) {
      return this.clone().iaddn(We);
    }, Ve.prototype.subn = function(We) {
      return this.clone().isubn(We);
    }, Ve.prototype.iabs = function() {
      return (this || _global$6).negative = 0, this || _global$6;
    }, Ve.prototype.abs = function() {
      return this.clone().iabs();
    }, Ve.prototype._ishlnsubmul = function(We, Xe, rt) {
      var ot = We.length + rt, ft;
      this._expand(ot);
      var mt, yt = 0;
      for (ft = 0; ft < We.length; ft++) {
        mt = ((this || _global$6).words[ft + rt] | 0) + yt;
        var pt = (We.words[ft] | 0) * Xe;
        mt -= pt & 67108863, yt = (mt >> 26) - (pt / 67108864 | 0), (this || _global$6).words[ft + rt] = mt & 67108863;
      }
      for (; ft < (this || _global$6).length - rt; ft++)
        mt = ((this || _global$6).words[ft + rt] | 0) + yt, yt = mt >> 26, (this || _global$6).words[ft + rt] = mt & 67108863;
      if (yt === 0)
        return this.strip();
      for (Fe(yt === -1), yt = 0, ft = 0; ft < (this || _global$6).length; ft++)
        mt = -((this || _global$6).words[ft] | 0) + yt, yt = mt >> 26, (this || _global$6).words[ft] = mt & 67108863;
      return (this || _global$6).negative = 1, this.strip();
    }, Ve.prototype._wordDiv = function(We, Xe) {
      var rt = (this || _global$6).length - We.length, ot = this.clone(), ft = We, mt = ft.words[ft.length - 1] | 0, yt = this._countBits(mt);
      rt = 26 - yt, rt !== 0 && (ft = ft.ushln(rt), ot.iushln(rt), mt = ft.words[ft.length - 1] | 0);
      var pt = ot.length - ft.length, Ge;
      if (Xe !== "mod") {
        Ge = new Ve(null), Ge.length = pt + 1, Ge.words = new Array(Ge.length);
        for (var ct = 0; ct < Ge.length; ct++)
          Ge.words[ct] = 0;
      }
      var Mt = ot.clone()._ishlnsubmul(ft, 1, pt);
      Mt.negative === 0 && (ot = Mt, Ge && (Ge.words[pt] = 1));
      for (var St = pt - 1; St >= 0; St--) {
        var At = (ot.words[ft.length + St] | 0) * 67108864 + (ot.words[ft.length + St - 1] | 0);
        for (At = Math.min(At / mt | 0, 67108863), ot._ishlnsubmul(ft, At, St); ot.negative !== 0; )
          At--, ot.negative = 0, ot._ishlnsubmul(ft, 1, St), ot.isZero() || (ot.negative ^= 1);
        Ge && (Ge.words[St] = At);
      }
      return Ge && Ge.strip(), ot.strip(), Xe !== "div" && rt !== 0 && ot.iushrn(rt), {
        div: Ge || null,
        mod: ot
      };
    }, Ve.prototype.divmod = function(We, Xe, rt) {
      if (Fe(!We.isZero()), this.isZero())
        return {
          div: new Ve(0),
          mod: new Ve(0)
        };
      var ot, ft, mt;
      return (this || _global$6).negative !== 0 && We.negative === 0 ? (mt = this.neg().divmod(We, Xe), Xe !== "mod" && (ot = mt.div.neg()), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.iadd(We)), {
        div: ot,
        mod: ft
      }) : (this || _global$6).negative === 0 && We.negative !== 0 ? (mt = this.divmod(We.neg(), Xe), Xe !== "mod" && (ot = mt.div.neg()), {
        div: ot,
        mod: mt.mod
      }) : (this || _global$6).negative & We.negative ? (mt = this.neg().divmod(We.neg(), Xe), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.isub(We)), {
        div: mt.div,
        mod: ft
      }) : We.length > (this || _global$6).length || this.cmp(We) < 0 ? {
        div: new Ve(0),
        mod: this || _global$6
      } : We.length === 1 ? Xe === "div" ? {
        div: this.divn(We.words[0]),
        mod: null
      } : Xe === "mod" ? {
        div: null,
        mod: new Ve(this.modn(We.words[0]))
      } : {
        div: this.divn(We.words[0]),
        mod: new Ve(this.modn(We.words[0]))
      } : this._wordDiv(We, Xe);
    }, Ve.prototype.div = function(We) {
      return this.divmod(We, "div", !1).div;
    }, Ve.prototype.mod = function(We) {
      return this.divmod(We, "mod", !1).mod;
    }, Ve.prototype.umod = function(We) {
      return this.divmod(We, "mod", !0).mod;
    }, Ve.prototype.divRound = function(We) {
      var Xe = this.divmod(We);
      if (Xe.mod.isZero())
        return Xe.div;
      var rt = Xe.div.negative !== 0 ? Xe.mod.isub(We) : Xe.mod, ot = We.ushrn(1), ft = We.andln(1), mt = rt.cmp(ot);
      return mt < 0 || ft === 1 && mt === 0 ? Xe.div : Xe.div.negative !== 0 ? Xe.div.isubn(1) : Xe.div.iaddn(1);
    }, Ve.prototype.modn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = (1 << 26) % We, rt = 0, ot = (this || _global$6).length - 1; ot >= 0; ot--)
        rt = (Xe * rt + ((this || _global$6).words[ot] | 0)) % We;
      return rt;
    }, Ve.prototype.idivn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = 0, rt = (this || _global$6).length - 1; rt >= 0; rt--) {
        var ot = ((this || _global$6).words[rt] | 0) + Xe * 67108864;
        (this || _global$6).words[rt] = ot / We | 0, Xe = ot % We;
      }
      return this.strip();
    }, Ve.prototype.divn = function(We) {
      return this.clone().idivn(We);
    }, Ve.prototype.egcd = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$6, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = new Ve(0), yt = new Ve(1), pt = 0; Xe.isEven() && rt.isEven(); )
        Xe.iushrn(1), rt.iushrn(1), ++pt;
      for (var Ge = rt.clone(), ct = Xe.clone(); !Xe.isZero(); ) {
        for (var Mt = 0, St = 1; !(Xe.words[0] & St) && Mt < 26; ++Mt, St <<= 1)
          ;
        if (Mt > 0)
          for (Xe.iushrn(Mt); Mt-- > 0; )
            (ot.isOdd() || ft.isOdd()) && (ot.iadd(Ge), ft.isub(ct)), ot.iushrn(1), ft.iushrn(1);
        for (var At = 0, Nt = 1; !(rt.words[0] & Nt) && At < 26; ++At, Nt <<= 1)
          ;
        if (At > 0)
          for (rt.iushrn(At); At-- > 0; )
            (mt.isOdd() || yt.isOdd()) && (mt.iadd(Ge), yt.isub(ct)), mt.iushrn(1), yt.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(mt), ft.isub(yt)) : (rt.isub(Xe), mt.isub(ot), yt.isub(ft));
      }
      return {
        a: mt,
        b: yt,
        gcd: rt.iushln(pt)
      };
    }, Ve.prototype._invmp = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$6, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = rt.clone(); Xe.cmpn(1) > 0 && rt.cmpn(1) > 0; ) {
        for (var yt = 0, pt = 1; !(Xe.words[0] & pt) && yt < 26; ++yt, pt <<= 1)
          ;
        if (yt > 0)
          for (Xe.iushrn(yt); yt-- > 0; )
            ot.isOdd() && ot.iadd(mt), ot.iushrn(1);
        for (var Ge = 0, ct = 1; !(rt.words[0] & ct) && Ge < 26; ++Ge, ct <<= 1)
          ;
        if (Ge > 0)
          for (rt.iushrn(Ge); Ge-- > 0; )
            ft.isOdd() && ft.iadd(mt), ft.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(ft)) : (rt.isub(Xe), ft.isub(ot));
      }
      var Mt;
      return Xe.cmpn(1) === 0 ? Mt = ot : Mt = ft, Mt.cmpn(0) < 0 && Mt.iadd(We), Mt;
    }, Ve.prototype.gcd = function(We) {
      if (this.isZero())
        return We.abs();
      if (We.isZero())
        return this.abs();
      var Xe = this.clone(), rt = We.clone();
      Xe.negative = 0, rt.negative = 0;
      for (var ot = 0; Xe.isEven() && rt.isEven(); ot++)
        Xe.iushrn(1), rt.iushrn(1);
      do {
        for (; Xe.isEven(); )
          Xe.iushrn(1);
        for (; rt.isEven(); )
          rt.iushrn(1);
        var ft = Xe.cmp(rt);
        if (ft < 0) {
          var mt = Xe;
          Xe = rt, rt = mt;
        } else if (ft === 0 || rt.cmpn(1) === 0)
          break;
        Xe.isub(rt);
      } while (!0);
      return rt.iushln(ot);
    }, Ve.prototype.invm = function(We) {
      return this.egcd(We).a.umod(We);
    }, Ve.prototype.isEven = function() {
      return ((this || _global$6).words[0] & 1) === 0;
    }, Ve.prototype.isOdd = function() {
      return ((this || _global$6).words[0] & 1) === 1;
    }, Ve.prototype.andln = function(We) {
      return (this || _global$6).words[0] & We;
    }, Ve.prototype.bincn = function(We) {
      Fe(typeof We == "number");
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$6).length <= rt)
        return this._expand(rt + 1), (this || _global$6).words[rt] |= ot, this || _global$6;
      for (var ft = ot, mt = rt; ft !== 0 && mt < (this || _global$6).length; mt++) {
        var yt = (this || _global$6).words[mt] | 0;
        yt += ft, ft = yt >>> 26, yt &= 67108863, (this || _global$6).words[mt] = yt;
      }
      return ft !== 0 && ((this || _global$6).words[mt] = ft, (this || _global$6).length++), this || _global$6;
    }, Ve.prototype.isZero = function() {
      return (this || _global$6).length === 1 && (this || _global$6).words[0] === 0;
    }, Ve.prototype.cmpn = function(We) {
      var Xe = We < 0;
      if ((this || _global$6).negative !== 0 && !Xe)
        return -1;
      if ((this || _global$6).negative === 0 && Xe)
        return 1;
      this.strip();
      var rt;
      if ((this || _global$6).length > 1)
        rt = 1;
      else {
        Xe && (We = -We), Fe(We <= 67108863, "Number is too big");
        var ot = (this || _global$6).words[0] | 0;
        rt = ot === We ? 0 : ot < We ? -1 : 1;
      }
      return (this || _global$6).negative !== 0 ? -rt | 0 : rt;
    }, Ve.prototype.cmp = function(We) {
      if ((this || _global$6).negative !== 0 && We.negative === 0)
        return -1;
      if ((this || _global$6).negative === 0 && We.negative !== 0)
        return 1;
      var Xe = this.ucmp(We);
      return (this || _global$6).negative !== 0 ? -Xe | 0 : Xe;
    }, Ve.prototype.ucmp = function(We) {
      if ((this || _global$6).length > We.length)
        return 1;
      if ((this || _global$6).length < We.length)
        return -1;
      for (var Xe = 0, rt = (this || _global$6).length - 1; rt >= 0; rt--) {
        var ot = (this || _global$6).words[rt] | 0, ft = We.words[rt] | 0;
        if (ot !== ft) {
          ot < ft ? Xe = -1 : ot > ft && (Xe = 1);
          break;
        }
      }
      return Xe;
    }, Ve.prototype.gtn = function(We) {
      return this.cmpn(We) === 1;
    }, Ve.prototype.gt = function(We) {
      return this.cmp(We) === 1;
    }, Ve.prototype.gten = function(We) {
      return this.cmpn(We) >= 0;
    }, Ve.prototype.gte = function(We) {
      return this.cmp(We) >= 0;
    }, Ve.prototype.ltn = function(We) {
      return this.cmpn(We) === -1;
    }, Ve.prototype.lt = function(We) {
      return this.cmp(We) === -1;
    }, Ve.prototype.lten = function(We) {
      return this.cmpn(We) <= 0;
    }, Ve.prototype.lte = function(We) {
      return this.cmp(We) <= 0;
    }, Ve.prototype.eqn = function(We) {
      return this.cmpn(We) === 0;
    }, Ve.prototype.eq = function(We) {
      return this.cmp(We) === 0;
    }, Ve.red = function(We) {
      return new Ot(We);
    }, Ve.prototype.toRed = function(We) {
      return Fe(!(this || _global$6).red, "Already a number in reduction context"), Fe((this || _global$6).negative === 0, "red works only with positives"), We.convertTo(this || _global$6)._forceRed(We);
    }, Ve.prototype.fromRed = function() {
      return Fe((this || _global$6).red, "fromRed works only with numbers in reduction context"), (this || _global$6).red.convertFrom(this || _global$6);
    }, Ve.prototype._forceRed = function(We) {
      return (this || _global$6).red = We, this || _global$6;
    }, Ve.prototype.forceRed = function(We) {
      return Fe(!(this || _global$6).red, "Already a number in reduction context"), this._forceRed(We);
    }, Ve.prototype.redAdd = function(We) {
      return Fe((this || _global$6).red, "redAdd works only with red numbers"), (this || _global$6).red.add(this || _global$6, We);
    }, Ve.prototype.redIAdd = function(We) {
      return Fe((this || _global$6).red, "redIAdd works only with red numbers"), (this || _global$6).red.iadd(this || _global$6, We);
    }, Ve.prototype.redSub = function(We) {
      return Fe((this || _global$6).red, "redSub works only with red numbers"), (this || _global$6).red.sub(this || _global$6, We);
    }, Ve.prototype.redISub = function(We) {
      return Fe((this || _global$6).red, "redISub works only with red numbers"), (this || _global$6).red.isub(this || _global$6, We);
    }, Ve.prototype.redShl = function(We) {
      return Fe((this || _global$6).red, "redShl works only with red numbers"), (this || _global$6).red.shl(this || _global$6, We);
    }, Ve.prototype.redMul = function(We) {
      return Fe((this || _global$6).red, "redMul works only with red numbers"), (this || _global$6).red._verify2(this || _global$6, We), (this || _global$6).red.mul(this || _global$6, We);
    }, Ve.prototype.redIMul = function(We) {
      return Fe((this || _global$6).red, "redMul works only with red numbers"), (this || _global$6).red._verify2(this || _global$6, We), (this || _global$6).red.imul(this || _global$6, We);
    }, Ve.prototype.redSqr = function() {
      return Fe((this || _global$6).red, "redSqr works only with red numbers"), (this || _global$6).red._verify1(this || _global$6), (this || _global$6).red.sqr(this || _global$6);
    }, Ve.prototype.redISqr = function() {
      return Fe((this || _global$6).red, "redISqr works only with red numbers"), (this || _global$6).red._verify1(this || _global$6), (this || _global$6).red.isqr(this || _global$6);
    }, Ve.prototype.redSqrt = function() {
      return Fe((this || _global$6).red, "redSqrt works only with red numbers"), (this || _global$6).red._verify1(this || _global$6), (this || _global$6).red.sqrt(this || _global$6);
    }, Ve.prototype.redInvm = function() {
      return Fe((this || _global$6).red, "redInvm works only with red numbers"), (this || _global$6).red._verify1(this || _global$6), (this || _global$6).red.invm(this || _global$6);
    }, Ve.prototype.redNeg = function() {
      return Fe((this || _global$6).red, "redNeg works only with red numbers"), (this || _global$6).red._verify1(this || _global$6), (this || _global$6).red.neg(this || _global$6);
    }, Ve.prototype.redPow = function(We) {
      return Fe((this || _global$6).red && !We.red, "redPow(normalNum)"), (this || _global$6).red._verify1(this || _global$6), (this || _global$6).red.pow(this || _global$6, We);
    };
    var Rt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ct(gt, We) {
      (this || _global$6).name = gt, (this || _global$6).p = new Ve(We, 16), (this || _global$6).n = (this || _global$6).p.bitLength(), (this || _global$6).k = new Ve(1).iushln((this || _global$6).n).isub((this || _global$6).p), (this || _global$6).tmp = this._tmp();
    }
    Ct.prototype._tmp = function() {
      var We = new Ve(null);
      return We.words = new Array(Math.ceil((this || _global$6).n / 13)), We;
    }, Ct.prototype.ireduce = function(We) {
      var Xe = We, rt;
      do
        this.split(Xe, (this || _global$6).tmp), Xe = this.imulK(Xe), Xe = Xe.iadd((this || _global$6).tmp), rt = Xe.bitLength();
      while (rt > (this || _global$6).n);
      var ot = rt < (this || _global$6).n ? -1 : Xe.ucmp((this || _global$6).p);
      return ot === 0 ? (Xe.words[0] = 0, Xe.length = 1) : ot > 0 ? Xe.isub((this || _global$6).p) : Xe.strip !== void 0 ? Xe.strip() : Xe._strip(), Xe;
    }, Ct.prototype.split = function(We, Xe) {
      We.iushrn((this || _global$6).n, 0, Xe);
    }, Ct.prototype.imulK = function(We) {
      return We.imul((this || _global$6).k);
    };
    function Zt() {
      Ct.call(this || _global$6, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    Ke(Zt, Ct), Zt.prototype.split = function(We, Xe) {
      for (var rt = 4194303, ot = Math.min(We.length, 9), ft = 0; ft < ot; ft++)
        Xe.words[ft] = We.words[ft];
      if (Xe.length = ot, We.length <= 9) {
        We.words[0] = 0, We.length = 1;
        return;
      }
      var mt = We.words[9];
      for (Xe.words[Xe.length++] = mt & rt, ft = 10; ft < We.length; ft++) {
        var yt = We.words[ft] | 0;
        We.words[ft - 10] = (yt & rt) << 4 | mt >>> 22, mt = yt;
      }
      mt >>>= 22, We.words[ft - 10] = mt, mt === 0 && We.length > 10 ? We.length -= 10 : We.length -= 9;
    }, Zt.prototype.imulK = function(We) {
      We.words[We.length] = 0, We.words[We.length + 1] = 0, We.length += 2;
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = We.words[rt] | 0;
        Xe += ot * 977, We.words[rt] = Xe & 67108863, Xe = ot * 64 + (Xe / 67108864 | 0);
      }
      return We.words[We.length - 1] === 0 && (We.length--, We.words[We.length - 1] === 0 && We.length--), We;
    };
    function Lt() {
      Ct.call(this || _global$6, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    Ke(Lt, Ct);
    function Ut() {
      Ct.call(this || _global$6, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    Ke(Ut, Ct);
    function Pt() {
      Ct.call(this || _global$6, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    Ke(Pt, Ct), Pt.prototype.imulK = function(We) {
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = (We.words[rt] | 0) * 19 + Xe, ft = ot & 67108863;
        ot >>>= 26, We.words[rt] = ft, Xe = ot;
      }
      return Xe !== 0 && (We.words[We.length++] = Xe), We;
    }, Ve._prime = function(We) {
      if (Rt[We])
        return Rt[We];
      var Xe;
      if (We === "k256")
        Xe = new Zt();
      else if (We === "p224")
        Xe = new Lt();
      else if (We === "p192")
        Xe = new Ut();
      else if (We === "p25519")
        Xe = new Pt();
      else
        throw new Error("Unknown prime " + We);
      return Rt[We] = Xe, Xe;
    };
    function Ot(gt) {
      if (typeof gt == "string") {
        var We = Ve._prime(gt);
        (this || _global$6).m = We.p, (this || _global$6).prime = We;
      } else
        Fe(gt.gtn(1), "modulus must be greater than 1"), (this || _global$6).m = gt, (this || _global$6).prime = null;
    }
    Ot.prototype._verify1 = function(We) {
      Fe(We.negative === 0, "red works only with positives"), Fe(We.red, "red works only with red numbers");
    }, Ot.prototype._verify2 = function(We, Xe) {
      Fe((We.negative | Xe.negative) === 0, "red works only with positives"), Fe(We.red && We.red === Xe.red, "red works only with red numbers");
    }, Ot.prototype.imod = function(We) {
      return (this || _global$6).prime ? (this || _global$6).prime.ireduce(We)._forceRed(this || _global$6) : We.umod((this || _global$6).m)._forceRed(this || _global$6);
    }, Ot.prototype.neg = function(We) {
      return We.isZero() ? We.clone() : (this || _global$6).m.sub(We)._forceRed(this || _global$6);
    }, Ot.prototype.add = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.add(Xe);
      return rt.cmp((this || _global$6).m) >= 0 && rt.isub((this || _global$6).m), rt._forceRed(this || _global$6);
    }, Ot.prototype.iadd = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.iadd(Xe);
      return rt.cmp((this || _global$6).m) >= 0 && rt.isub((this || _global$6).m), rt;
    }, Ot.prototype.sub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.sub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$6).m), rt._forceRed(this || _global$6);
    }, Ot.prototype.isub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.isub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$6).m), rt;
    }, Ot.prototype.shl = function(We, Xe) {
      return this._verify1(We), this.imod(We.ushln(Xe));
    }, Ot.prototype.imul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.imul(Xe));
    }, Ot.prototype.mul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.mul(Xe));
    }, Ot.prototype.isqr = function(We) {
      return this.imul(We, We.clone());
    }, Ot.prototype.sqr = function(We) {
      return this.mul(We, We);
    }, Ot.prototype.sqrt = function(We) {
      if (We.isZero())
        return We.clone();
      var Xe = (this || _global$6).m.andln(3);
      if (Fe(Xe % 2 === 1), Xe === 3) {
        var rt = (this || _global$6).m.add(new Ve(1)).iushrn(2);
        return this.pow(We, rt);
      }
      for (var ot = (this || _global$6).m.subn(1), ft = 0; !ot.isZero() && ot.andln(1) === 0; )
        ft++, ot.iushrn(1);
      Fe(!ot.isZero());
      var mt = new Ve(1).toRed(this || _global$6), yt = mt.redNeg(), pt = (this || _global$6).m.subn(1).iushrn(1), Ge = (this || _global$6).m.bitLength();
      for (Ge = new Ve(2 * Ge * Ge).toRed(this || _global$6); this.pow(Ge, pt).cmp(yt) !== 0; )
        Ge.redIAdd(yt);
      for (var ct = this.pow(Ge, ot), Mt = this.pow(We, ot.addn(1).iushrn(1)), St = this.pow(We, ot), At = ft; St.cmp(mt) !== 0; ) {
        for (var Nt = St, qt = 0; Nt.cmp(mt) !== 0; qt++)
          Nt = Nt.redSqr();
        Fe(qt < At);
        var Qt = this.pow(ct, new Ve(1).iushln(At - qt - 1));
        Mt = Mt.redMul(Qt), ct = Qt.redSqr(), St = St.redMul(ct), At = qt;
      }
      return Mt;
    }, Ot.prototype.invm = function(We) {
      var Xe = We._invmp((this || _global$6).m);
      return Xe.negative !== 0 ? (Xe.negative = 0, this.imod(Xe).redNeg()) : this.imod(Xe);
    }, Ot.prototype.pow = function(We, Xe) {
      if (Xe.isZero())
        return new Ve(1).toRed(this || _global$6);
      if (Xe.cmpn(1) === 0)
        return We.clone();
      var rt = 4, ot = new Array(1 << rt);
      ot[0] = new Ve(1).toRed(this || _global$6), ot[1] = We;
      for (var ft = 2; ft < ot.length; ft++)
        ot[ft] = this.mul(ot[ft - 1], We);
      var mt = ot[0], yt = 0, pt = 0, Ge = Xe.bitLength() % 26;
      for (Ge === 0 && (Ge = 26), ft = Xe.length - 1; ft >= 0; ft--) {
        for (var ct = Xe.words[ft], Mt = Ge - 1; Mt >= 0; Mt--) {
          var St = ct >> Mt & 1;
          if (mt !== ot[0] && (mt = this.sqr(mt)), St === 0 && yt === 0) {
            pt = 0;
            continue;
          }
          yt <<= 1, yt |= St, pt++, !(pt !== rt && (ft !== 0 || Mt !== 0)) && (mt = this.mul(mt, ot[yt]), pt = 0, yt = 0);
        }
        Ge = 26;
      }
      return mt;
    }, Ot.prototype.convertTo = function(We) {
      var Xe = We.umod((this || _global$6).m);
      return Xe === We ? Xe.clone() : Xe;
    }, Ot.prototype.convertFrom = function(We) {
      var Xe = We.clone();
      return Xe.red = null, Xe;
    }, Ve.mont = function(We) {
      return new Ft(We);
    };
    function Ft(gt) {
      Ot.call(this || _global$6, gt), (this || _global$6).shift = (this || _global$6).m.bitLength(), (this || _global$6).shift % 26 !== 0 && ((this || _global$6).shift += 26 - (this || _global$6).shift % 26), (this || _global$6).r = new Ve(1).iushln((this || _global$6).shift), (this || _global$6).r2 = this.imod((this || _global$6).r.sqr()), (this || _global$6).rinv = (this || _global$6).r._invmp((this || _global$6).m), (this || _global$6).minv = (this || _global$6).rinv.mul((this || _global$6).r).isubn(1).div((this || _global$6).m), (this || _global$6).minv = (this || _global$6).minv.umod((this || _global$6).r), (this || _global$6).minv = (this || _global$6).r.sub((this || _global$6).minv);
    }
    Ke(Ft, Ot), Ft.prototype.convertTo = function(We) {
      return this.imod(We.ushln((this || _global$6).shift));
    }, Ft.prototype.convertFrom = function(We) {
      var Xe = this.imod(We.mul((this || _global$6).rinv));
      return Xe.red = null, Xe;
    }, Ft.prototype.imul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return We.words[0] = 0, We.length = 1, We;
      var rt = We.imul(Xe), ot = rt.maskn((this || _global$6).shift).mul((this || _global$6).minv).imaskn((this || _global$6).shift).mul((this || _global$6).m), ft = rt.isub(ot).iushrn((this || _global$6).shift), mt = ft;
      return ft.cmp((this || _global$6).m) >= 0 ? mt = ft.isub((this || _global$6).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$6).m)), mt._forceRed(this || _global$6);
    }, Ft.prototype.mul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return new Ve(0)._forceRed(this || _global$6);
      var rt = We.mul(Xe), ot = rt.maskn((this || _global$6).shift).mul((this || _global$6).minv).imaskn((this || _global$6).shift).mul((this || _global$6).m), ft = rt.isub(ot).iushrn((this || _global$6).shift), mt = ft;
      return ft.cmp((this || _global$6).m) >= 0 ? mt = ft.isub((this || _global$6).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$6).m)), mt._forceRed(this || _global$6);
    }, Ft.prototype.invm = function(We) {
      var Xe = this.imod(We._invmp((this || _global$6).m).mul((this || _global$6).r2));
      return Xe._forceRed(this || _global$6);
    };
  }(module$3, exports$W)), module$3.exports;
}
var exports$V = {}, _dewExec$U = !1;
function dew$U() {
  if (_dewExec$U)
    return exports$V;
  _dewExec$U = !0;
  var $e = exports$V;
  function Ze(Ve, Je) {
    if (Array.isArray(Ve))
      return Ve.slice();
    if (!Ve)
      return [];
    var Qe = [];
    if (typeof Ve != "string") {
      for (var at = 0; at < Ve.length; at++)
        Qe[at] = Ve[at] | 0;
      return Qe;
    }
    if (Je === "hex") {
      Ve = Ve.replace(/[^a-z0-9]+/ig, ""), Ve.length % 2 !== 0 && (Ve = "0" + Ve);
      for (var at = 0; at < Ve.length; at += 2)
        Qe.push(parseInt(Ve[at] + Ve[at + 1], 16));
    } else
      for (var at = 0; at < Ve.length; at++) {
        var ut = Ve.charCodeAt(at), lt = ut >> 8, dt = ut & 255;
        lt ? Qe.push(lt, dt) : Qe.push(dt);
      }
    return Qe;
  }
  $e.toArray = Ze;
  function Fe(Ve) {
    return Ve.length === 1 ? "0" + Ve : Ve;
  }
  $e.zero2 = Fe;
  function Ke(Ve) {
    for (var Je = "", Qe = 0; Qe < Ve.length; Qe++)
      Je += Fe(Ve[Qe].toString(16));
    return Je;
  }
  return $e.toHex = Ke, $e.encode = function(Je, Qe) {
    return Qe === "hex" ? Ke(Je) : Je;
  }, exports$V;
}
var exports$U = {}, _dewExec$T = !1;
function dew$T() {
  if (_dewExec$T)
    return exports$U;
  _dewExec$T = !0;
  var $e = exports$U, Ze = dew$V(), Fe = dew$2m(), Ke = dew$U();
  $e.assert = Fe, $e.toArray = Ke.toArray, $e.zero2 = Ke.zero2, $e.toHex = Ke.toHex, $e.encode = Ke.encode;
  function Ve(lt, dt, bt) {
    var $t = new Array(Math.max(lt.bitLength(), bt) + 1);
    $t.fill(0);
    for (var vt = 1 << dt + 1, wt = lt.clone(), xt = 0; xt < $t.length; xt++) {
      var Et, Tt = wt.andln(vt - 1);
      wt.isOdd() ? (Tt > (vt >> 1) - 1 ? Et = (vt >> 1) - Tt : Et = Tt, wt.isubn(Et)) : Et = 0, $t[xt] = Et, wt.iushrn(1);
    }
    return $t;
  }
  $e.getNAF = Ve;
  function Je(lt, dt) {
    var bt = [[], []];
    lt = lt.clone(), dt = dt.clone();
    for (var $t = 0, vt = 0, wt; lt.cmpn(-$t) > 0 || dt.cmpn(-vt) > 0; ) {
      var xt = lt.andln(3) + $t & 3, Et = dt.andln(3) + vt & 3;
      xt === 3 && (xt = -1), Et === 3 && (Et = -1);
      var Tt;
      xt & 1 ? (wt = lt.andln(7) + $t & 7, (wt === 3 || wt === 5) && Et === 2 ? Tt = -xt : Tt = xt) : Tt = 0, bt[0].push(Tt);
      var Rt;
      Et & 1 ? (wt = dt.andln(7) + vt & 7, (wt === 3 || wt === 5) && xt === 2 ? Rt = -Et : Rt = Et) : Rt = 0, bt[1].push(Rt), 2 * $t === Tt + 1 && ($t = 1 - $t), 2 * vt === Rt + 1 && (vt = 1 - vt), lt.iushrn(1), dt.iushrn(1);
    }
    return bt;
  }
  $e.getJSF = Je;
  function Qe(lt, dt, bt) {
    var $t = "_" + dt;
    lt.prototype[dt] = function() {
      return this[$t] !== void 0 ? this[$t] : this[$t] = bt.call(this);
    };
  }
  $e.cachedProperty = Qe;
  function at(lt) {
    return typeof lt == "string" ? $e.toArray(lt, "hex") : lt;
  }
  $e.parseBytes = at;
  function ut(lt) {
    return new Ze(lt, "hex", "le");
  }
  return $e.intFromLE = ut, exports$U;
}
var exports$T = {}, _dewExec$S = !1;
function dew$S() {
  if (_dewExec$S)
    return exports$T;
  _dewExec$S = !0;
  var $e = dew$V(), Ze = dew$T(), Fe = Ze.getNAF, Ke = Ze.getJSF, Ve = Ze.assert;
  function Je(at, ut) {
    this.type = at, this.p = new $e(ut.p, 16), this.red = ut.prime ? $e.red(ut.prime) : $e.mont(this.p), this.zero = new $e(0).toRed(this.red), this.one = new $e(1).toRed(this.red), this.two = new $e(2).toRed(this.red), this.n = ut.n && new $e(ut.n, 16), this.g = ut.g && this.pointFromJSON(ut.g, ut.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var lt = this.n && this.p.div(this.n);
    !lt || lt.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  exports$T = Je, Je.prototype.point = function() {
    throw new Error("Not implemented");
  }, Je.prototype.validate = function() {
    throw new Error("Not implemented");
  }, Je.prototype._fixedNafMul = function(ut, lt) {
    Ve(ut.precomputed);
    var dt = ut._getDoubles(), bt = Fe(lt, 1, this._bitLength), $t = (1 << dt.step + 1) - (dt.step % 2 === 0 ? 2 : 1);
    $t /= 3;
    var vt = [], wt, xt;
    for (wt = 0; wt < bt.length; wt += dt.step) {
      xt = 0;
      for (var Et = wt + dt.step - 1; Et >= wt; Et--)
        xt = (xt << 1) + bt[Et];
      vt.push(xt);
    }
    for (var Tt = this.jpoint(null, null, null), Rt = this.jpoint(null, null, null), Ct = $t; Ct > 0; Ct--) {
      for (wt = 0; wt < vt.length; wt++)
        xt = vt[wt], xt === Ct ? Rt = Rt.mixedAdd(dt.points[wt]) : xt === -Ct && (Rt = Rt.mixedAdd(dt.points[wt].neg()));
      Tt = Tt.add(Rt);
    }
    return Tt.toP();
  }, Je.prototype._wnafMul = function(ut, lt) {
    var dt = 4, bt = ut._getNAFPoints(dt);
    dt = bt.wnd;
    for (var $t = bt.points, vt = Fe(lt, dt, this._bitLength), wt = this.jpoint(null, null, null), xt = vt.length - 1; xt >= 0; xt--) {
      for (var Et = 0; xt >= 0 && vt[xt] === 0; xt--)
        Et++;
      if (xt >= 0 && Et++, wt = wt.dblp(Et), xt < 0)
        break;
      var Tt = vt[xt];
      Ve(Tt !== 0), ut.type === "affine" ? Tt > 0 ? wt = wt.mixedAdd($t[Tt - 1 >> 1]) : wt = wt.mixedAdd($t[-Tt - 1 >> 1].neg()) : Tt > 0 ? wt = wt.add($t[Tt - 1 >> 1]) : wt = wt.add($t[-Tt - 1 >> 1].neg());
    }
    return ut.type === "affine" ? wt.toP() : wt;
  }, Je.prototype._wnafMulAdd = function(ut, lt, dt, bt, $t) {
    var vt = this._wnafT1, wt = this._wnafT2, xt = this._wnafT3, Et = 0, Tt, Rt, Ct;
    for (Tt = 0; Tt < bt; Tt++) {
      Ct = lt[Tt];
      var Zt = Ct._getNAFPoints(ut);
      vt[Tt] = Zt.wnd, wt[Tt] = Zt.points;
    }
    for (Tt = bt - 1; Tt >= 1; Tt -= 2) {
      var Lt = Tt - 1, Ut = Tt;
      if (vt[Lt] !== 1 || vt[Ut] !== 1) {
        xt[Lt] = Fe(dt[Lt], vt[Lt], this._bitLength), xt[Ut] = Fe(dt[Ut], vt[Ut], this._bitLength), Et = Math.max(xt[Lt].length, Et), Et = Math.max(xt[Ut].length, Et);
        continue;
      }
      var Pt = [
        lt[Lt],
        null,
        null,
        lt[Ut]
      ];
      lt[Lt].y.cmp(lt[Ut].y) === 0 ? (Pt[1] = lt[Lt].add(lt[Ut]), Pt[2] = lt[Lt].toJ().mixedAdd(lt[Ut].neg())) : lt[Lt].y.cmp(lt[Ut].y.redNeg()) === 0 ? (Pt[1] = lt[Lt].toJ().mixedAdd(lt[Ut]), Pt[2] = lt[Lt].add(lt[Ut].neg())) : (Pt[1] = lt[Lt].toJ().mixedAdd(lt[Ut]), Pt[2] = lt[Lt].toJ().mixedAdd(lt[Ut].neg()));
      var Ot = [
        -3,
        -1,
        -5,
        -7,
        0,
        7,
        5,
        1,
        3
      ], Ft = Ke(dt[Lt], dt[Ut]);
      for (Et = Math.max(Ft[0].length, Et), xt[Lt] = new Array(Et), xt[Ut] = new Array(Et), Rt = 0; Rt < Et; Rt++) {
        var gt = Ft[0][Rt] | 0, We = Ft[1][Rt] | 0;
        xt[Lt][Rt] = Ot[(gt + 1) * 3 + (We + 1)], xt[Ut][Rt] = 0, wt[Lt] = Pt;
      }
    }
    var Xe = this.jpoint(null, null, null), rt = this._wnafT4;
    for (Tt = Et; Tt >= 0; Tt--) {
      for (var ot = 0; Tt >= 0; ) {
        var ft = !0;
        for (Rt = 0; Rt < bt; Rt++)
          rt[Rt] = xt[Rt][Tt] | 0, rt[Rt] !== 0 && (ft = !1);
        if (!ft)
          break;
        ot++, Tt--;
      }
      if (Tt >= 0 && ot++, Xe = Xe.dblp(ot), Tt < 0)
        break;
      for (Rt = 0; Rt < bt; Rt++) {
        var mt = rt[Rt];
        mt !== 0 && (mt > 0 ? Ct = wt[Rt][mt - 1 >> 1] : mt < 0 && (Ct = wt[Rt][-mt - 1 >> 1].neg()), Ct.type === "affine" ? Xe = Xe.mixedAdd(Ct) : Xe = Xe.add(Ct));
      }
    }
    for (Tt = 0; Tt < bt; Tt++)
      wt[Tt] = null;
    return $t ? Xe : Xe.toP();
  };
  function Qe(at, ut) {
    this.curve = at, this.type = ut, this.precomputed = null;
  }
  return Je.BasePoint = Qe, Qe.prototype.eq = function() {
    throw new Error("Not implemented");
  }, Qe.prototype.validate = function() {
    return this.curve.validate(this);
  }, Je.prototype.decodePoint = function(ut, lt) {
    ut = Ze.toArray(ut, lt);
    var dt = this.p.byteLength();
    if ((ut[0] === 4 || ut[0] === 6 || ut[0] === 7) && ut.length - 1 === 2 * dt) {
      ut[0] === 6 ? Ve(ut[ut.length - 1] % 2 === 0) : ut[0] === 7 && Ve(ut[ut.length - 1] % 2 === 1);
      var bt = this.point(ut.slice(1, 1 + dt), ut.slice(1 + dt, 1 + 2 * dt));
      return bt;
    } else if ((ut[0] === 2 || ut[0] === 3) && ut.length - 1 === dt)
      return this.pointFromX(ut.slice(1, 1 + dt), ut[0] === 3);
    throw new Error("Unknown point format");
  }, Qe.prototype.encodeCompressed = function(ut) {
    return this.encode(ut, !0);
  }, Qe.prototype._encode = function(ut) {
    var lt = this.curve.p.byteLength(), dt = this.getX().toArray("be", lt);
    return ut ? [this.getY().isEven() ? 2 : 3].concat(dt) : [4].concat(dt, this.getY().toArray("be", lt));
  }, Qe.prototype.encode = function(ut, lt) {
    return Ze.encode(this._encode(lt), ut);
  }, Qe.prototype.precompute = function(ut) {
    if (this.precomputed)
      return this;
    var lt = {
      doubles: null,
      naf: null,
      beta: null
    };
    return lt.naf = this._getNAFPoints(8), lt.doubles = this._getDoubles(4, ut), lt.beta = this._getBeta(), this.precomputed = lt, this;
  }, Qe.prototype._hasDoubles = function(ut) {
    if (!this.precomputed)
      return !1;
    var lt = this.precomputed.doubles;
    return lt ? lt.points.length >= Math.ceil((ut.bitLength() + 1) / lt.step) : !1;
  }, Qe.prototype._getDoubles = function(ut, lt) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var dt = [this], bt = this, $t = 0; $t < lt; $t += ut) {
      for (var vt = 0; vt < ut; vt++)
        bt = bt.dbl();
      dt.push(bt);
    }
    return {
      step: ut,
      points: dt
    };
  }, Qe.prototype._getNAFPoints = function(ut) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var lt = [this], dt = (1 << ut) - 1, bt = dt === 1 ? null : this.dbl(), $t = 1; $t < dt; $t++)
      lt[$t] = lt[$t - 1].add(bt);
    return {
      wnd: ut,
      points: lt
    };
  }, Qe.prototype._getBeta = function() {
    return null;
  }, Qe.prototype.dblp = function(ut) {
    for (var lt = this, dt = 0; dt < ut; dt++)
      lt = lt.dbl();
    return lt;
  }, exports$T;
}
var exports$S = {}, _dewExec$R = !1;
function dew$R() {
  if (_dewExec$R)
    return exports$S;
  _dewExec$R = !0;
  var $e = dew$T(), Ze = dew$V(), Fe = dew$f(), Ke = dew$S(), Ve = $e.assert;
  function Je(ut) {
    Ke.call(this, "short", ut), this.a = new Ze(ut.a, 16).toRed(this.red), this.b = new Ze(ut.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(ut), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  Fe(Je, Ke), exports$S = Je, Je.prototype._getEndomorphism = function(lt) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var dt, bt;
      if (lt.beta)
        dt = new Ze(lt.beta, 16).toRed(this.red);
      else {
        var $t = this._getEndoRoots(this.p);
        dt = $t[0].cmp($t[1]) < 0 ? $t[0] : $t[1], dt = dt.toRed(this.red);
      }
      if (lt.lambda)
        bt = new Ze(lt.lambda, 16);
      else {
        var vt = this._getEndoRoots(this.n);
        this.g.mul(vt[0]).x.cmp(this.g.x.redMul(dt)) === 0 ? bt = vt[0] : (bt = vt[1], Ve(this.g.mul(bt).x.cmp(this.g.x.redMul(dt)) === 0));
      }
      var wt;
      return lt.basis ? wt = lt.basis.map(function(xt) {
        return {
          a: new Ze(xt.a, 16),
          b: new Ze(xt.b, 16)
        };
      }) : wt = this._getEndoBasis(bt), {
        beta: dt,
        lambda: bt,
        basis: wt
      };
    }
  }, Je.prototype._getEndoRoots = function(lt) {
    var dt = lt === this.p ? this.red : Ze.mont(lt), bt = new Ze(2).toRed(dt).redInvm(), $t = bt.redNeg(), vt = new Ze(3).toRed(dt).redNeg().redSqrt().redMul(bt), wt = $t.redAdd(vt).fromRed(), xt = $t.redSub(vt).fromRed();
    return [wt, xt];
  }, Je.prototype._getEndoBasis = function(lt) {
    for (var dt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), bt = lt, $t = this.n.clone(), vt = new Ze(1), wt = new Ze(0), xt = new Ze(0), Et = new Ze(1), Tt, Rt, Ct, Zt, Lt, Ut, Pt, Ot = 0, Ft, gt; bt.cmpn(0) !== 0; ) {
      var We = $t.div(bt);
      Ft = $t.sub(We.mul(bt)), gt = xt.sub(We.mul(vt));
      var Xe = Et.sub(We.mul(wt));
      if (!Ct && Ft.cmp(dt) < 0)
        Tt = Pt.neg(), Rt = vt, Ct = Ft.neg(), Zt = gt;
      else if (Ct && ++Ot === 2)
        break;
      Pt = Ft, $t = bt, bt = Ft, xt = vt, vt = gt, Et = wt, wt = Xe;
    }
    Lt = Ft.neg(), Ut = gt;
    var rt = Ct.sqr().add(Zt.sqr()), ot = Lt.sqr().add(Ut.sqr());
    return ot.cmp(rt) >= 0 && (Lt = Tt, Ut = Rt), Ct.negative && (Ct = Ct.neg(), Zt = Zt.neg()), Lt.negative && (Lt = Lt.neg(), Ut = Ut.neg()), [{
      a: Ct,
      b: Zt
    }, {
      a: Lt,
      b: Ut
    }];
  }, Je.prototype._endoSplit = function(lt) {
    var dt = this.endo.basis, bt = dt[0], $t = dt[1], vt = $t.b.mul(lt).divRound(this.n), wt = bt.b.neg().mul(lt).divRound(this.n), xt = vt.mul(bt.a), Et = wt.mul($t.a), Tt = vt.mul(bt.b), Rt = wt.mul($t.b), Ct = lt.sub(xt).sub(Et), Zt = Tt.add(Rt).neg();
    return {
      k1: Ct,
      k2: Zt
    };
  }, Je.prototype.pointFromX = function(lt, dt) {
    lt = new Ze(lt, 16), lt.red || (lt = lt.toRed(this.red));
    var bt = lt.redSqr().redMul(lt).redIAdd(lt.redMul(this.a)).redIAdd(this.b), $t = bt.redSqrt();
    if ($t.redSqr().redSub(bt).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var vt = $t.fromRed().isOdd();
    return (dt && !vt || !dt && vt) && ($t = $t.redNeg()), this.point(lt, $t);
  }, Je.prototype.validate = function(lt) {
    if (lt.inf)
      return !0;
    var dt = lt.x, bt = lt.y, $t = this.a.redMul(dt), vt = dt.redSqr().redMul(dt).redIAdd($t).redIAdd(this.b);
    return bt.redSqr().redISub(vt).cmpn(0) === 0;
  }, Je.prototype._endoWnafMulAdd = function(lt, dt, bt) {
    for (var $t = this._endoWnafT1, vt = this._endoWnafT2, wt = 0; wt < lt.length; wt++) {
      var xt = this._endoSplit(dt[wt]), Et = lt[wt], Tt = Et._getBeta();
      xt.k1.negative && (xt.k1.ineg(), Et = Et.neg(!0)), xt.k2.negative && (xt.k2.ineg(), Tt = Tt.neg(!0)), $t[wt * 2] = Et, $t[wt * 2 + 1] = Tt, vt[wt * 2] = xt.k1, vt[wt * 2 + 1] = xt.k2;
    }
    for (var Rt = this._wnafMulAdd(1, $t, vt, wt * 2, bt), Ct = 0; Ct < wt * 2; Ct++)
      $t[Ct] = null, vt[Ct] = null;
    return Rt;
  };
  function Qe(ut, lt, dt, bt) {
    Ke.BasePoint.call(this, ut, "affine"), lt === null && dt === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new Ze(lt, 16), this.y = new Ze(dt, 16), bt && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  Fe(Qe, Ke.BasePoint), Je.prototype.point = function(lt, dt, bt) {
    return new Qe(this, lt, dt, bt);
  }, Je.prototype.pointFromJSON = function(lt, dt) {
    return Qe.fromJSON(this, lt, dt);
  }, Qe.prototype._getBeta = function() {
    if (this.curve.endo) {
      var lt = this.precomputed;
      if (lt && lt.beta)
        return lt.beta;
      var dt = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (lt) {
        var bt = this.curve, $t = function(vt) {
          return bt.point(vt.x.redMul(bt.endo.beta), vt.y);
        };
        lt.beta = dt, dt.precomputed = {
          beta: null,
          naf: lt.naf && {
            wnd: lt.naf.wnd,
            points: lt.naf.points.map($t)
          },
          doubles: lt.doubles && {
            step: lt.doubles.step,
            points: lt.doubles.points.map($t)
          }
        };
      }
      return dt;
    }
  }, Qe.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, Qe.fromJSON = function(lt, dt, bt) {
    typeof dt == "string" && (dt = JSON.parse(dt));
    var $t = lt.point(dt[0], dt[1], bt);
    if (!dt[2])
      return $t;
    function vt(xt) {
      return lt.point(xt[0], xt[1], bt);
    }
    var wt = dt[2];
    return $t.precomputed = {
      beta: null,
      doubles: wt.doubles && {
        step: wt.doubles.step,
        points: [$t].concat(wt.doubles.points.map(vt))
      },
      naf: wt.naf && {
        wnd: wt.naf.wnd,
        points: [$t].concat(wt.naf.points.map(vt))
      }
    }, $t;
  }, Qe.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, Qe.prototype.isInfinity = function() {
    return this.inf;
  }, Qe.prototype.add = function(lt) {
    if (this.inf)
      return lt;
    if (lt.inf)
      return this;
    if (this.eq(lt))
      return this.dbl();
    if (this.neg().eq(lt))
      return this.curve.point(null, null);
    if (this.x.cmp(lt.x) === 0)
      return this.curve.point(null, null);
    var dt = this.y.redSub(lt.y);
    dt.cmpn(0) !== 0 && (dt = dt.redMul(this.x.redSub(lt.x).redInvm()));
    var bt = dt.redSqr().redISub(this.x).redISub(lt.x), $t = dt.redMul(this.x.redSub(bt)).redISub(this.y);
    return this.curve.point(bt, $t);
  }, Qe.prototype.dbl = function() {
    if (this.inf)
      return this;
    var lt = this.y.redAdd(this.y);
    if (lt.cmpn(0) === 0)
      return this.curve.point(null, null);
    var dt = this.curve.a, bt = this.x.redSqr(), $t = lt.redInvm(), vt = bt.redAdd(bt).redIAdd(bt).redIAdd(dt).redMul($t), wt = vt.redSqr().redISub(this.x.redAdd(this.x)), xt = vt.redMul(this.x.redSub(wt)).redISub(this.y);
    return this.curve.point(wt, xt);
  }, Qe.prototype.getX = function() {
    return this.x.fromRed();
  }, Qe.prototype.getY = function() {
    return this.y.fromRed();
  }, Qe.prototype.mul = function(lt) {
    return lt = new Ze(lt, 16), this.isInfinity() ? this : this._hasDoubles(lt) ? this.curve._fixedNafMul(this, lt) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [lt]) : this.curve._wnafMul(this, lt);
  }, Qe.prototype.mulAdd = function(lt, dt, bt) {
    var $t = [this, dt], vt = [lt, bt];
    return this.curve.endo ? this.curve._endoWnafMulAdd($t, vt) : this.curve._wnafMulAdd(1, $t, vt, 2);
  }, Qe.prototype.jmulAdd = function(lt, dt, bt) {
    var $t = [this, dt], vt = [lt, bt];
    return this.curve.endo ? this.curve._endoWnafMulAdd($t, vt, !0) : this.curve._wnafMulAdd(1, $t, vt, 2, !0);
  }, Qe.prototype.eq = function(lt) {
    return this === lt || this.inf === lt.inf && (this.inf || this.x.cmp(lt.x) === 0 && this.y.cmp(lt.y) === 0);
  }, Qe.prototype.neg = function(lt) {
    if (this.inf)
      return this;
    var dt = this.curve.point(this.x, this.y.redNeg());
    if (lt && this.precomputed) {
      var bt = this.precomputed, $t = function(vt) {
        return vt.neg();
      };
      dt.precomputed = {
        naf: bt.naf && {
          wnd: bt.naf.wnd,
          points: bt.naf.points.map($t)
        },
        doubles: bt.doubles && {
          step: bt.doubles.step,
          points: bt.doubles.points.map($t)
        }
      };
    }
    return dt;
  }, Qe.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var lt = this.curve.jpoint(this.x, this.y, this.curve.one);
    return lt;
  };
  function at(ut, lt, dt, bt) {
    Ke.BasePoint.call(this, ut, "jacobian"), lt === null && dt === null && bt === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new Ze(0)) : (this.x = new Ze(lt, 16), this.y = new Ze(dt, 16), this.z = new Ze(bt, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return Fe(at, Ke.BasePoint), Je.prototype.jpoint = function(lt, dt, bt) {
    return new at(this, lt, dt, bt);
  }, at.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var lt = this.z.redInvm(), dt = lt.redSqr(), bt = this.x.redMul(dt), $t = this.y.redMul(dt).redMul(lt);
    return this.curve.point(bt, $t);
  }, at.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, at.prototype.add = function(lt) {
    if (this.isInfinity())
      return lt;
    if (lt.isInfinity())
      return this;
    var dt = lt.z.redSqr(), bt = this.z.redSqr(), $t = this.x.redMul(dt), vt = lt.x.redMul(bt), wt = this.y.redMul(dt.redMul(lt.z)), xt = lt.y.redMul(bt.redMul(this.z)), Et = $t.redSub(vt), Tt = wt.redSub(xt);
    if (Et.cmpn(0) === 0)
      return Tt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var Rt = Et.redSqr(), Ct = Rt.redMul(Et), Zt = $t.redMul(Rt), Lt = Tt.redSqr().redIAdd(Ct).redISub(Zt).redISub(Zt), Ut = Tt.redMul(Zt.redISub(Lt)).redISub(wt.redMul(Ct)), Pt = this.z.redMul(lt.z).redMul(Et);
    return this.curve.jpoint(Lt, Ut, Pt);
  }, at.prototype.mixedAdd = function(lt) {
    if (this.isInfinity())
      return lt.toJ();
    if (lt.isInfinity())
      return this;
    var dt = this.z.redSqr(), bt = this.x, $t = lt.x.redMul(dt), vt = this.y, wt = lt.y.redMul(dt).redMul(this.z), xt = bt.redSub($t), Et = vt.redSub(wt);
    if (xt.cmpn(0) === 0)
      return Et.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var Tt = xt.redSqr(), Rt = Tt.redMul(xt), Ct = bt.redMul(Tt), Zt = Et.redSqr().redIAdd(Rt).redISub(Ct).redISub(Ct), Lt = Et.redMul(Ct.redISub(Zt)).redISub(vt.redMul(Rt)), Ut = this.z.redMul(xt);
    return this.curve.jpoint(Zt, Lt, Ut);
  }, at.prototype.dblp = function(lt) {
    if (lt === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!lt)
      return this.dbl();
    var dt;
    if (this.curve.zeroA || this.curve.threeA) {
      var bt = this;
      for (dt = 0; dt < lt; dt++)
        bt = bt.dbl();
      return bt;
    }
    var $t = this.curve.a, vt = this.curve.tinv, wt = this.x, xt = this.y, Et = this.z, Tt = Et.redSqr().redSqr(), Rt = xt.redAdd(xt);
    for (dt = 0; dt < lt; dt++) {
      var Ct = wt.redSqr(), Zt = Rt.redSqr(), Lt = Zt.redSqr(), Ut = Ct.redAdd(Ct).redIAdd(Ct).redIAdd($t.redMul(Tt)), Pt = wt.redMul(Zt), Ot = Ut.redSqr().redISub(Pt.redAdd(Pt)), Ft = Pt.redISub(Ot), gt = Ut.redMul(Ft);
      gt = gt.redIAdd(gt).redISub(Lt);
      var We = Rt.redMul(Et);
      dt + 1 < lt && (Tt = Tt.redMul(Lt)), wt = Ot, Et = We, Rt = gt;
    }
    return this.curve.jpoint(wt, Rt.redMul(vt), Et);
  }, at.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, at.prototype._zeroDbl = function() {
    var lt, dt, bt;
    if (this.zOne) {
      var $t = this.x.redSqr(), vt = this.y.redSqr(), wt = vt.redSqr(), xt = this.x.redAdd(vt).redSqr().redISub($t).redISub(wt);
      xt = xt.redIAdd(xt);
      var Et = $t.redAdd($t).redIAdd($t), Tt = Et.redSqr().redISub(xt).redISub(xt), Rt = wt.redIAdd(wt);
      Rt = Rt.redIAdd(Rt), Rt = Rt.redIAdd(Rt), lt = Tt, dt = Et.redMul(xt.redISub(Tt)).redISub(Rt), bt = this.y.redAdd(this.y);
    } else {
      var Ct = this.x.redSqr(), Zt = this.y.redSqr(), Lt = Zt.redSqr(), Ut = this.x.redAdd(Zt).redSqr().redISub(Ct).redISub(Lt);
      Ut = Ut.redIAdd(Ut);
      var Pt = Ct.redAdd(Ct).redIAdd(Ct), Ot = Pt.redSqr(), Ft = Lt.redIAdd(Lt);
      Ft = Ft.redIAdd(Ft), Ft = Ft.redIAdd(Ft), lt = Ot.redISub(Ut).redISub(Ut), dt = Pt.redMul(Ut.redISub(lt)).redISub(Ft), bt = this.y.redMul(this.z), bt = bt.redIAdd(bt);
    }
    return this.curve.jpoint(lt, dt, bt);
  }, at.prototype._threeDbl = function() {
    var lt, dt, bt;
    if (this.zOne) {
      var $t = this.x.redSqr(), vt = this.y.redSqr(), wt = vt.redSqr(), xt = this.x.redAdd(vt).redSqr().redISub($t).redISub(wt);
      xt = xt.redIAdd(xt);
      var Et = $t.redAdd($t).redIAdd($t).redIAdd(this.curve.a), Tt = Et.redSqr().redISub(xt).redISub(xt);
      lt = Tt;
      var Rt = wt.redIAdd(wt);
      Rt = Rt.redIAdd(Rt), Rt = Rt.redIAdd(Rt), dt = Et.redMul(xt.redISub(Tt)).redISub(Rt), bt = this.y.redAdd(this.y);
    } else {
      var Ct = this.z.redSqr(), Zt = this.y.redSqr(), Lt = this.x.redMul(Zt), Ut = this.x.redSub(Ct).redMul(this.x.redAdd(Ct));
      Ut = Ut.redAdd(Ut).redIAdd(Ut);
      var Pt = Lt.redIAdd(Lt);
      Pt = Pt.redIAdd(Pt);
      var Ot = Pt.redAdd(Pt);
      lt = Ut.redSqr().redISub(Ot), bt = this.y.redAdd(this.z).redSqr().redISub(Zt).redISub(Ct);
      var Ft = Zt.redSqr();
      Ft = Ft.redIAdd(Ft), Ft = Ft.redIAdd(Ft), Ft = Ft.redIAdd(Ft), dt = Ut.redMul(Pt.redISub(lt)).redISub(Ft);
    }
    return this.curve.jpoint(lt, dt, bt);
  }, at.prototype._dbl = function() {
    var lt = this.curve.a, dt = this.x, bt = this.y, $t = this.z, vt = $t.redSqr().redSqr(), wt = dt.redSqr(), xt = bt.redSqr(), Et = wt.redAdd(wt).redIAdd(wt).redIAdd(lt.redMul(vt)), Tt = dt.redAdd(dt);
    Tt = Tt.redIAdd(Tt);
    var Rt = Tt.redMul(xt), Ct = Et.redSqr().redISub(Rt.redAdd(Rt)), Zt = Rt.redISub(Ct), Lt = xt.redSqr();
    Lt = Lt.redIAdd(Lt), Lt = Lt.redIAdd(Lt), Lt = Lt.redIAdd(Lt);
    var Ut = Et.redMul(Zt).redISub(Lt), Pt = bt.redAdd(bt).redMul($t);
    return this.curve.jpoint(Ct, Ut, Pt);
  }, at.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var lt = this.x.redSqr(), dt = this.y.redSqr(), bt = this.z.redSqr(), $t = dt.redSqr(), vt = lt.redAdd(lt).redIAdd(lt), wt = vt.redSqr(), xt = this.x.redAdd(dt).redSqr().redISub(lt).redISub($t);
    xt = xt.redIAdd(xt), xt = xt.redAdd(xt).redIAdd(xt), xt = xt.redISub(wt);
    var Et = xt.redSqr(), Tt = $t.redIAdd($t);
    Tt = Tt.redIAdd(Tt), Tt = Tt.redIAdd(Tt), Tt = Tt.redIAdd(Tt);
    var Rt = vt.redIAdd(xt).redSqr().redISub(wt).redISub(Et).redISub(Tt), Ct = dt.redMul(Rt);
    Ct = Ct.redIAdd(Ct), Ct = Ct.redIAdd(Ct);
    var Zt = this.x.redMul(Et).redISub(Ct);
    Zt = Zt.redIAdd(Zt), Zt = Zt.redIAdd(Zt);
    var Lt = this.y.redMul(Rt.redMul(Tt.redISub(Rt)).redISub(xt.redMul(Et)));
    Lt = Lt.redIAdd(Lt), Lt = Lt.redIAdd(Lt), Lt = Lt.redIAdd(Lt);
    var Ut = this.z.redAdd(xt).redSqr().redISub(bt).redISub(Et);
    return this.curve.jpoint(Zt, Lt, Ut);
  }, at.prototype.mul = function(lt, dt) {
    return lt = new Ze(lt, dt), this.curve._wnafMul(this, lt);
  }, at.prototype.eq = function(lt) {
    if (lt.type === "affine")
      return this.eq(lt.toJ());
    if (this === lt)
      return !0;
    var dt = this.z.redSqr(), bt = lt.z.redSqr();
    if (this.x.redMul(bt).redISub(lt.x.redMul(dt)).cmpn(0) !== 0)
      return !1;
    var $t = dt.redMul(this.z), vt = bt.redMul(lt.z);
    return this.y.redMul(vt).redISub(lt.y.redMul($t)).cmpn(0) === 0;
  }, at.prototype.eqXToP = function(lt) {
    var dt = this.z.redSqr(), bt = lt.toRed(this.curve.red).redMul(dt);
    if (this.x.cmp(bt) === 0)
      return !0;
    for (var $t = lt.clone(), vt = this.curve.redN.redMul(dt); ; ) {
      if ($t.iadd(this.curve.n), $t.cmp(this.curve.p) >= 0)
        return !1;
      if (bt.redIAdd(vt), this.x.cmp(bt) === 0)
        return !0;
    }
  }, at.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, at.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, exports$S;
}
var exports$R = {}, _dewExec$Q = !1;
function dew$Q() {
  if (_dewExec$Q)
    return exports$R;
  _dewExec$Q = !0;
  var $e = dew$V(), Ze = dew$f(), Fe = dew$S(), Ke = dew$T();
  function Ve(Qe) {
    Fe.call(this, "mont", Qe), this.a = new $e(Qe.a, 16).toRed(this.red), this.b = new $e(Qe.b, 16).toRed(this.red), this.i4 = new $e(4).toRed(this.red).redInvm(), this.two = new $e(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  Ze(Ve, Fe), exports$R = Ve, Ve.prototype.validate = function(at) {
    var ut = at.normalize().x, lt = ut.redSqr(), dt = lt.redMul(ut).redAdd(lt.redMul(this.a)).redAdd(ut), bt = dt.redSqrt();
    return bt.redSqr().cmp(dt) === 0;
  };
  function Je(Qe, at, ut) {
    Fe.BasePoint.call(this, Qe, "projective"), at === null && ut === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new $e(at, 16), this.z = new $e(ut, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return Ze(Je, Fe.BasePoint), Ve.prototype.decodePoint = function(at, ut) {
    return this.point(Ke.toArray(at, ut), 1);
  }, Ve.prototype.point = function(at, ut) {
    return new Je(this, at, ut);
  }, Ve.prototype.pointFromJSON = function(at) {
    return Je.fromJSON(this, at);
  }, Je.prototype.precompute = function() {
  }, Je.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, Je.fromJSON = function(at, ut) {
    return new Je(at, ut[0], ut[1] || at.one);
  }, Je.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, Je.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, Je.prototype.dbl = function() {
    var at = this.x.redAdd(this.z), ut = at.redSqr(), lt = this.x.redSub(this.z), dt = lt.redSqr(), bt = ut.redSub(dt), $t = ut.redMul(dt), vt = bt.redMul(dt.redAdd(this.curve.a24.redMul(bt)));
    return this.curve.point($t, vt);
  }, Je.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, Je.prototype.diffAdd = function(at, ut) {
    var lt = this.x.redAdd(this.z), dt = this.x.redSub(this.z), bt = at.x.redAdd(at.z), $t = at.x.redSub(at.z), vt = $t.redMul(lt), wt = bt.redMul(dt), xt = ut.z.redMul(vt.redAdd(wt).redSqr()), Et = ut.x.redMul(vt.redISub(wt).redSqr());
    return this.curve.point(xt, Et);
  }, Je.prototype.mul = function(at) {
    for (var ut = at.clone(), lt = this, dt = this.curve.point(null, null), bt = this, $t = []; ut.cmpn(0) !== 0; ut.iushrn(1))
      $t.push(ut.andln(1));
    for (var vt = $t.length - 1; vt >= 0; vt--)
      $t[vt] === 0 ? (lt = lt.diffAdd(dt, bt), dt = dt.dbl()) : (dt = lt.diffAdd(dt, bt), lt = lt.dbl());
    return dt;
  }, Je.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, Je.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, Je.prototype.eq = function(at) {
    return this.getX().cmp(at.getX()) === 0;
  }, Je.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, Je.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, exports$R;
}
var exports$Q = {}, _dewExec$P = !1;
function dew$P() {
  if (_dewExec$P)
    return exports$Q;
  _dewExec$P = !0;
  var $e = dew$T(), Ze = dew$V(), Fe = dew$f(), Ke = dew$S(), Ve = $e.assert;
  function Je(at) {
    this.twisted = (at.a | 0) !== 1, this.mOneA = this.twisted && (at.a | 0) === -1, this.extended = this.mOneA, Ke.call(this, "edwards", at), this.a = new Ze(at.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Ze(at.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Ze(at.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), Ve(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (at.c | 0) === 1;
  }
  Fe(Je, Ke), exports$Q = Je, Je.prototype._mulA = function(ut) {
    return this.mOneA ? ut.redNeg() : this.a.redMul(ut);
  }, Je.prototype._mulC = function(ut) {
    return this.oneC ? ut : this.c.redMul(ut);
  }, Je.prototype.jpoint = function(ut, lt, dt, bt) {
    return this.point(ut, lt, dt, bt);
  }, Je.prototype.pointFromX = function(ut, lt) {
    ut = new Ze(ut, 16), ut.red || (ut = ut.toRed(this.red));
    var dt = ut.redSqr(), bt = this.c2.redSub(this.a.redMul(dt)), $t = this.one.redSub(this.c2.redMul(this.d).redMul(dt)), vt = bt.redMul($t.redInvm()), wt = vt.redSqrt();
    if (wt.redSqr().redSub(vt).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var xt = wt.fromRed().isOdd();
    return (lt && !xt || !lt && xt) && (wt = wt.redNeg()), this.point(ut, wt);
  }, Je.prototype.pointFromY = function(ut, lt) {
    ut = new Ze(ut, 16), ut.red || (ut = ut.toRed(this.red));
    var dt = ut.redSqr(), bt = dt.redSub(this.c2), $t = dt.redMul(this.d).redMul(this.c2).redSub(this.a), vt = bt.redMul($t.redInvm());
    if (vt.cmp(this.zero) === 0) {
      if (lt)
        throw new Error("invalid point");
      return this.point(this.zero, ut);
    }
    var wt = vt.redSqrt();
    if (wt.redSqr().redSub(vt).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return wt.fromRed().isOdd() !== lt && (wt = wt.redNeg()), this.point(wt, ut);
  }, Je.prototype.validate = function(ut) {
    if (ut.isInfinity())
      return !0;
    ut.normalize();
    var lt = ut.x.redSqr(), dt = ut.y.redSqr(), bt = lt.redMul(this.a).redAdd(dt), $t = this.c2.redMul(this.one.redAdd(this.d.redMul(lt).redMul(dt)));
    return bt.cmp($t) === 0;
  };
  function Qe(at, ut, lt, dt, bt) {
    Ke.BasePoint.call(this, at, "projective"), ut === null && lt === null && dt === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new Ze(ut, 16), this.y = new Ze(lt, 16), this.z = dt ? new Ze(dt, 16) : this.curve.one, this.t = bt && new Ze(bt, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return Fe(Qe, Ke.BasePoint), Je.prototype.pointFromJSON = function(ut) {
    return Qe.fromJSON(this, ut);
  }, Je.prototype.point = function(ut, lt, dt, bt) {
    return new Qe(this, ut, lt, dt, bt);
  }, Qe.fromJSON = function(ut, lt) {
    return new Qe(ut, lt[0], lt[1], lt[2]);
  }, Qe.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, Qe.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, Qe.prototype._extDbl = function() {
    var ut = this.x.redSqr(), lt = this.y.redSqr(), dt = this.z.redSqr();
    dt = dt.redIAdd(dt);
    var bt = this.curve._mulA(ut), $t = this.x.redAdd(this.y).redSqr().redISub(ut).redISub(lt), vt = bt.redAdd(lt), wt = vt.redSub(dt), xt = bt.redSub(lt), Et = $t.redMul(wt), Tt = vt.redMul(xt), Rt = $t.redMul(xt), Ct = wt.redMul(vt);
    return this.curve.point(Et, Tt, Ct, Rt);
  }, Qe.prototype._projDbl = function() {
    var ut = this.x.redAdd(this.y).redSqr(), lt = this.x.redSqr(), dt = this.y.redSqr(), bt, $t, vt, wt, xt, Et;
    if (this.curve.twisted) {
      wt = this.curve._mulA(lt);
      var Tt = wt.redAdd(dt);
      this.zOne ? (bt = ut.redSub(lt).redSub(dt).redMul(Tt.redSub(this.curve.two)), $t = Tt.redMul(wt.redSub(dt)), vt = Tt.redSqr().redSub(Tt).redSub(Tt)) : (xt = this.z.redSqr(), Et = Tt.redSub(xt).redISub(xt), bt = ut.redSub(lt).redISub(dt).redMul(Et), $t = Tt.redMul(wt.redSub(dt)), vt = Tt.redMul(Et));
    } else
      wt = lt.redAdd(dt), xt = this.curve._mulC(this.z).redSqr(), Et = wt.redSub(xt).redSub(xt), bt = this.curve._mulC(ut.redISub(wt)).redMul(Et), $t = this.curve._mulC(wt).redMul(lt.redISub(dt)), vt = wt.redMul(Et);
    return this.curve.point(bt, $t, vt);
  }, Qe.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, Qe.prototype._extAdd = function(ut) {
    var lt = this.y.redSub(this.x).redMul(ut.y.redSub(ut.x)), dt = this.y.redAdd(this.x).redMul(ut.y.redAdd(ut.x)), bt = this.t.redMul(this.curve.dd).redMul(ut.t), $t = this.z.redMul(ut.z.redAdd(ut.z)), vt = dt.redSub(lt), wt = $t.redSub(bt), xt = $t.redAdd(bt), Et = dt.redAdd(lt), Tt = vt.redMul(wt), Rt = xt.redMul(Et), Ct = vt.redMul(Et), Zt = wt.redMul(xt);
    return this.curve.point(Tt, Rt, Zt, Ct);
  }, Qe.prototype._projAdd = function(ut) {
    var lt = this.z.redMul(ut.z), dt = lt.redSqr(), bt = this.x.redMul(ut.x), $t = this.y.redMul(ut.y), vt = this.curve.d.redMul(bt).redMul($t), wt = dt.redSub(vt), xt = dt.redAdd(vt), Et = this.x.redAdd(this.y).redMul(ut.x.redAdd(ut.y)).redISub(bt).redISub($t), Tt = lt.redMul(wt).redMul(Et), Rt, Ct;
    return this.curve.twisted ? (Rt = lt.redMul(xt).redMul($t.redSub(this.curve._mulA(bt))), Ct = wt.redMul(xt)) : (Rt = lt.redMul(xt).redMul($t.redSub(bt)), Ct = this.curve._mulC(wt).redMul(xt)), this.curve.point(Tt, Rt, Ct);
  }, Qe.prototype.add = function(ut) {
    return this.isInfinity() ? ut : ut.isInfinity() ? this : this.curve.extended ? this._extAdd(ut) : this._projAdd(ut);
  }, Qe.prototype.mul = function(ut) {
    return this._hasDoubles(ut) ? this.curve._fixedNafMul(this, ut) : this.curve._wnafMul(this, ut);
  }, Qe.prototype.mulAdd = function(ut, lt, dt) {
    return this.curve._wnafMulAdd(1, [this, lt], [ut, dt], 2, !1);
  }, Qe.prototype.jmulAdd = function(ut, lt, dt) {
    return this.curve._wnafMulAdd(1, [this, lt], [ut, dt], 2, !0);
  }, Qe.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var ut = this.z.redInvm();
    return this.x = this.x.redMul(ut), this.y = this.y.redMul(ut), this.t && (this.t = this.t.redMul(ut)), this.z = this.curve.one, this.zOne = !0, this;
  }, Qe.prototype.neg = function() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  }, Qe.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, Qe.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, Qe.prototype.eq = function(ut) {
    return this === ut || this.getX().cmp(ut.getX()) === 0 && this.getY().cmp(ut.getY()) === 0;
  }, Qe.prototype.eqXToP = function(ut) {
    var lt = ut.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(lt) === 0)
      return !0;
    for (var dt = ut.clone(), bt = this.curve.redN.redMul(this.z); ; ) {
      if (dt.iadd(this.curve.n), dt.cmp(this.curve.p) >= 0)
        return !1;
      if (lt.redIAdd(bt), this.x.cmp(lt) === 0)
        return !0;
    }
  }, Qe.prototype.toP = Qe.prototype.normalize, Qe.prototype.mixedAdd = Qe.prototype.add, exports$Q;
}
var exports$P = {}, _dewExec$O = !1;
function dew$O() {
  if (_dewExec$O)
    return exports$P;
  _dewExec$O = !0;
  var $e = exports$P;
  return $e.base = dew$S(), $e.short = dew$R(), $e.mont = dew$Q(), $e.edwards = dew$P(), exports$P;
}
var exports$O = {}, _dewExec$N = !1;
function dew$N() {
  if (_dewExec$N)
    return exports$O;
  _dewExec$N = !0;
  var $e = dew$2m(), Ze = dew$f();
  exports$O.inherits = Ze;
  function Fe(Xe, rt) {
    return (Xe.charCodeAt(rt) & 64512) !== 55296 || rt < 0 || rt + 1 >= Xe.length ? !1 : (Xe.charCodeAt(rt + 1) & 64512) === 56320;
  }
  function Ke(Xe, rt) {
    if (Array.isArray(Xe))
      return Xe.slice();
    if (!Xe)
      return [];
    var ot = [];
    if (typeof Xe == "string")
      if (rt) {
        if (rt === "hex")
          for (Xe = Xe.replace(/[^a-z0-9]+/ig, ""), Xe.length % 2 !== 0 && (Xe = "0" + Xe), mt = 0; mt < Xe.length; mt += 2)
            ot.push(parseInt(Xe[mt] + Xe[mt + 1], 16));
      } else
        for (var ft = 0, mt = 0; mt < Xe.length; mt++) {
          var yt = Xe.charCodeAt(mt);
          yt < 128 ? ot[ft++] = yt : yt < 2048 ? (ot[ft++] = yt >> 6 | 192, ot[ft++] = yt & 63 | 128) : Fe(Xe, mt) ? (yt = 65536 + ((yt & 1023) << 10) + (Xe.charCodeAt(++mt) & 1023), ot[ft++] = yt >> 18 | 240, ot[ft++] = yt >> 12 & 63 | 128, ot[ft++] = yt >> 6 & 63 | 128, ot[ft++] = yt & 63 | 128) : (ot[ft++] = yt >> 12 | 224, ot[ft++] = yt >> 6 & 63 | 128, ot[ft++] = yt & 63 | 128);
        }
    else
      for (mt = 0; mt < Xe.length; mt++)
        ot[mt] = Xe[mt] | 0;
    return ot;
  }
  exports$O.toArray = Ke;
  function Ve(Xe) {
    for (var rt = "", ot = 0; ot < Xe.length; ot++)
      rt += at(Xe[ot].toString(16));
    return rt;
  }
  exports$O.toHex = Ve;
  function Je(Xe) {
    var rt = Xe >>> 24 | Xe >>> 8 & 65280 | Xe << 8 & 16711680 | (Xe & 255) << 24;
    return rt >>> 0;
  }
  exports$O.htonl = Je;
  function Qe(Xe, rt) {
    for (var ot = "", ft = 0; ft < Xe.length; ft++) {
      var mt = Xe[ft];
      rt === "little" && (mt = Je(mt)), ot += ut(mt.toString(16));
    }
    return ot;
  }
  exports$O.toHex32 = Qe;
  function at(Xe) {
    return Xe.length === 1 ? "0" + Xe : Xe;
  }
  exports$O.zero2 = at;
  function ut(Xe) {
    return Xe.length === 7 ? "0" + Xe : Xe.length === 6 ? "00" + Xe : Xe.length === 5 ? "000" + Xe : Xe.length === 4 ? "0000" + Xe : Xe.length === 3 ? "00000" + Xe : Xe.length === 2 ? "000000" + Xe : Xe.length === 1 ? "0000000" + Xe : Xe;
  }
  exports$O.zero8 = ut;
  function lt(Xe, rt, ot, ft) {
    var mt = ot - rt;
    $e(mt % 4 === 0);
    for (var yt = new Array(mt / 4), pt = 0, Ge = rt; pt < yt.length; pt++, Ge += 4) {
      var ct;
      ft === "big" ? ct = Xe[Ge] << 24 | Xe[Ge + 1] << 16 | Xe[Ge + 2] << 8 | Xe[Ge + 3] : ct = Xe[Ge + 3] << 24 | Xe[Ge + 2] << 16 | Xe[Ge + 1] << 8 | Xe[Ge], yt[pt] = ct >>> 0;
    }
    return yt;
  }
  exports$O.join32 = lt;
  function dt(Xe, rt) {
    for (var ot = new Array(Xe.length * 4), ft = 0, mt = 0; ft < Xe.length; ft++, mt += 4) {
      var yt = Xe[ft];
      rt === "big" ? (ot[mt] = yt >>> 24, ot[mt + 1] = yt >>> 16 & 255, ot[mt + 2] = yt >>> 8 & 255, ot[mt + 3] = yt & 255) : (ot[mt + 3] = yt >>> 24, ot[mt + 2] = yt >>> 16 & 255, ot[mt + 1] = yt >>> 8 & 255, ot[mt] = yt & 255);
    }
    return ot;
  }
  exports$O.split32 = dt;
  function bt(Xe, rt) {
    return Xe >>> rt | Xe << 32 - rt;
  }
  exports$O.rotr32 = bt;
  function $t(Xe, rt) {
    return Xe << rt | Xe >>> 32 - rt;
  }
  exports$O.rotl32 = $t;
  function vt(Xe, rt) {
    return Xe + rt >>> 0;
  }
  exports$O.sum32 = vt;
  function wt(Xe, rt, ot) {
    return Xe + rt + ot >>> 0;
  }
  exports$O.sum32_3 = wt;
  function xt(Xe, rt, ot, ft) {
    return Xe + rt + ot + ft >>> 0;
  }
  exports$O.sum32_4 = xt;
  function Et(Xe, rt, ot, ft, mt) {
    return Xe + rt + ot + ft + mt >>> 0;
  }
  exports$O.sum32_5 = Et;
  function Tt(Xe, rt, ot, ft) {
    var mt = Xe[rt], yt = Xe[rt + 1], pt = ft + yt >>> 0, Ge = (pt < ft ? 1 : 0) + ot + mt;
    Xe[rt] = Ge >>> 0, Xe[rt + 1] = pt;
  }
  exports$O.sum64 = Tt;
  function Rt(Xe, rt, ot, ft) {
    var mt = rt + ft >>> 0, yt = (mt < rt ? 1 : 0) + Xe + ot;
    return yt >>> 0;
  }
  exports$O.sum64_hi = Rt;
  function Ct(Xe, rt, ot, ft) {
    var mt = rt + ft;
    return mt >>> 0;
  }
  exports$O.sum64_lo = Ct;
  function Zt(Xe, rt, ot, ft, mt, yt, pt, Ge) {
    var ct = 0, Mt = rt;
    Mt = Mt + ft >>> 0, ct += Mt < rt ? 1 : 0, Mt = Mt + yt >>> 0, ct += Mt < yt ? 1 : 0, Mt = Mt + Ge >>> 0, ct += Mt < Ge ? 1 : 0;
    var St = Xe + ot + mt + pt + ct;
    return St >>> 0;
  }
  exports$O.sum64_4_hi = Zt;
  function Lt(Xe, rt, ot, ft, mt, yt, pt, Ge) {
    var ct = rt + ft + yt + Ge;
    return ct >>> 0;
  }
  exports$O.sum64_4_lo = Lt;
  function Ut(Xe, rt, ot, ft, mt, yt, pt, Ge, ct, Mt) {
    var St = 0, At = rt;
    At = At + ft >>> 0, St += At < rt ? 1 : 0, At = At + yt >>> 0, St += At < yt ? 1 : 0, At = At + Ge >>> 0, St += At < Ge ? 1 : 0, At = At + Mt >>> 0, St += At < Mt ? 1 : 0;
    var Nt = Xe + ot + mt + pt + ct + St;
    return Nt >>> 0;
  }
  exports$O.sum64_5_hi = Ut;
  function Pt(Xe, rt, ot, ft, mt, yt, pt, Ge, ct, Mt) {
    var St = rt + ft + yt + Ge + Mt;
    return St >>> 0;
  }
  exports$O.sum64_5_lo = Pt;
  function Ot(Xe, rt, ot) {
    var ft = rt << 32 - ot | Xe >>> ot;
    return ft >>> 0;
  }
  exports$O.rotr64_hi = Ot;
  function Ft(Xe, rt, ot) {
    var ft = Xe << 32 - ot | rt >>> ot;
    return ft >>> 0;
  }
  exports$O.rotr64_lo = Ft;
  function gt(Xe, rt, ot) {
    return Xe >>> ot;
  }
  exports$O.shr64_hi = gt;
  function We(Xe, rt, ot) {
    var ft = Xe << 32 - ot | rt >>> ot;
    return ft >>> 0;
  }
  return exports$O.shr64_lo = We, exports$O;
}
var exports$N = {}, _dewExec$M = !1;
function dew$M() {
  if (_dewExec$M)
    return exports$N;
  _dewExec$M = !0;
  var $e = dew$N(), Ze = dew$2m();
  function Fe() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return exports$N.BlockHash = Fe, Fe.prototype.update = function(Ve, Je) {
    if (Ve = $e.toArray(Ve, Je), this.pending ? this.pending = this.pending.concat(Ve) : this.pending = Ve, this.pendingTotal += Ve.length, this.pending.length >= this._delta8) {
      Ve = this.pending;
      var Qe = Ve.length % this._delta8;
      this.pending = Ve.slice(Ve.length - Qe, Ve.length), this.pending.length === 0 && (this.pending = null), Ve = $e.join32(Ve, 0, Ve.length - Qe, this.endian);
      for (var at = 0; at < Ve.length; at += this._delta32)
        this._update(Ve, at, at + this._delta32);
    }
    return this;
  }, Fe.prototype.digest = function(Ve) {
    return this.update(this._pad()), Ze(this.pending === null), this._digest(Ve);
  }, Fe.prototype._pad = function() {
    var Ve = this.pendingTotal, Je = this._delta8, Qe = Je - (Ve + this.padLength) % Je, at = new Array(Qe + this.padLength);
    at[0] = 128;
    for (var ut = 1; ut < Qe; ut++)
      at[ut] = 0;
    if (Ve <<= 3, this.endian === "big") {
      for (var lt = 8; lt < this.padLength; lt++)
        at[ut++] = 0;
      at[ut++] = 0, at[ut++] = 0, at[ut++] = 0, at[ut++] = 0, at[ut++] = Ve >>> 24 & 255, at[ut++] = Ve >>> 16 & 255, at[ut++] = Ve >>> 8 & 255, at[ut++] = Ve & 255;
    } else
      for (at[ut++] = Ve & 255, at[ut++] = Ve >>> 8 & 255, at[ut++] = Ve >>> 16 & 255, at[ut++] = Ve >>> 24 & 255, at[ut++] = 0, at[ut++] = 0, at[ut++] = 0, at[ut++] = 0, lt = 8; lt < this.padLength; lt++)
        at[ut++] = 0;
    return at;
  }, exports$N;
}
var exports$M = {}, _dewExec$L = !1;
function dew$L() {
  return _dewExec$L || (_dewExec$L = !0), exports$M;
}
var exports$L = {}, _dewExec$K = !1;
function dew$K() {
  if (_dewExec$K)
    return exports$L;
  _dewExec$K = !0;
  var $e = dew$N(), Ze = dew$M(), Fe = $e.rotl32, Ke = $e.sum32, Ve = $e.sum32_3, Je = $e.sum32_4, Qe = Ze.BlockHash;
  function at() {
    if (!(this instanceof at))
      return new at();
    Qe.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  $e.inherits(at, Qe), exports$L.ripemd160 = at, at.blockSize = 512, at.outSize = 160, at.hmacStrength = 192, at.padLength = 64, at.prototype._update = function(Et, Tt) {
    for (var Rt = this.h[0], Ct = this.h[1], Zt = this.h[2], Lt = this.h[3], Ut = this.h[4], Pt = Rt, Ot = Ct, Ft = Zt, gt = Lt, We = Ut, Xe = 0; Xe < 80; Xe++) {
      var rt = Ke(Fe(Je(Rt, ut(Xe, Ct, Zt, Lt), Et[bt[Xe] + Tt], lt(Xe)), vt[Xe]), Ut);
      Rt = Ut, Ut = Lt, Lt = Fe(Zt, 10), Zt = Ct, Ct = rt, rt = Ke(Fe(Je(Pt, ut(79 - Xe, Ot, Ft, gt), Et[$t[Xe] + Tt], dt(Xe)), wt[Xe]), We), Pt = We, We = gt, gt = Fe(Ft, 10), Ft = Ot, Ot = rt;
    }
    rt = Ve(this.h[1], Zt, gt), this.h[1] = Ve(this.h[2], Lt, We), this.h[2] = Ve(this.h[3], Ut, Pt), this.h[3] = Ve(this.h[4], Rt, Ot), this.h[4] = Ve(this.h[0], Ct, Ft), this.h[0] = rt;
  }, at.prototype._digest = function(Et) {
    return Et === "hex" ? $e.toHex32(this.h, "little") : $e.split32(this.h, "little");
  };
  function ut(xt, Et, Tt, Rt) {
    return xt <= 15 ? Et ^ Tt ^ Rt : xt <= 31 ? Et & Tt | ~Et & Rt : xt <= 47 ? (Et | ~Tt) ^ Rt : xt <= 63 ? Et & Rt | Tt & ~Rt : Et ^ (Tt | ~Rt);
  }
  function lt(xt) {
    return xt <= 15 ? 0 : xt <= 31 ? 1518500249 : xt <= 47 ? 1859775393 : xt <= 63 ? 2400959708 : 2840853838;
  }
  function dt(xt) {
    return xt <= 15 ? 1352829926 : xt <= 31 ? 1548603684 : xt <= 47 ? 1836072691 : xt <= 63 ? 2053994217 : 0;
  }
  var bt = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], $t = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], vt = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], wt = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  return exports$L;
}
var exports$K = {}, _dewExec$J = !1;
function dew$J() {
  if (_dewExec$J)
    return exports$K;
  _dewExec$J = !0;
  var $e = dew$N(), Ze = dew$2m();
  function Fe(Ke, Ve, Je) {
    if (!(this instanceof Fe))
      return new Fe(Ke, Ve, Je);
    this.Hash = Ke, this.blockSize = Ke.blockSize / 8, this.outSize = Ke.outSize / 8, this.inner = null, this.outer = null, this._init($e.toArray(Ve, Je));
  }
  return exports$K = Fe, Fe.prototype._init = function(Ve) {
    Ve.length > this.blockSize && (Ve = new this.Hash().update(Ve).digest()), Ze(Ve.length <= this.blockSize);
    for (var Je = Ve.length; Je < this.blockSize; Je++)
      Ve.push(0);
    for (Je = 0; Je < Ve.length; Je++)
      Ve[Je] ^= 54;
    for (this.inner = new this.Hash().update(Ve), Je = 0; Je < Ve.length; Je++)
      Ve[Je] ^= 106;
    this.outer = new this.Hash().update(Ve);
  }, Fe.prototype.update = function(Ve, Je) {
    return this.inner.update(Ve, Je), this;
  }, Fe.prototype.digest = function(Ve) {
    return this.outer.update(this.inner.digest()), this.outer.digest(Ve);
  }, exports$K;
}
var exports$J = {}, _dewExec$I = !1;
function dew$I() {
  if (_dewExec$I)
    return exports$J;
  _dewExec$I = !0;
  var $e = exports$J;
  return $e.utils = dew$N(), $e.common = dew$M(), $e.sha = dew$L(), $e.ripemd = dew$K(), $e.hmac = dew$J(), $e.sha1 = $e.sha.sha1, $e.sha256 = $e.sha.sha256, $e.sha224 = $e.sha.sha224, $e.sha384 = $e.sha.sha384, $e.sha512 = $e.sha.sha512, $e.ripemd160 = $e.ripemd.ripemd160, exports$J;
}
var exports$I = {}, _dewExec$H = !1;
function dew$H() {
  return _dewExec$H || (_dewExec$H = !0, exports$I = {
    doubles: {
      step: 4,
      points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]
    },
    naf: {
      wnd: 7,
      points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]
    }
  }), exports$I;
}
var exports$H = {}, _dewExec$G = !1;
function dew$G() {
  if (_dewExec$G)
    return exports$H;
  _dewExec$G = !0;
  var $e = exports$H, Ze = dew$I(), Fe = dew$O(), Ke = dew$T(), Ve = Ke.assert;
  function Je(ut) {
    ut.type === "short" ? this.curve = new Fe.short(ut) : ut.type === "edwards" ? this.curve = new Fe.edwards(ut) : this.curve = new Fe.mont(ut), this.g = this.curve.g, this.n = this.curve.n, this.hash = ut.hash, Ve(this.g.validate(), "Invalid curve"), Ve(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  $e.PresetCurve = Je;
  function Qe(ut, lt) {
    Object.defineProperty($e, ut, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var dt = new Je(lt);
        return Object.defineProperty($e, ut, {
          configurable: !0,
          enumerable: !0,
          value: dt
        }), dt;
      }
    });
  }
  Qe("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: Ze.sha256,
    gRed: !1,
    g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
  }), Qe("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: Ze.sha256,
    gRed: !1,
    g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
  }), Qe("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: Ze.sha256,
    gRed: !1,
    g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
  }), Qe("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: Ze.sha384,
    gRed: !1,
    g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
  }), Qe("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: Ze.sha512,
    gRed: !1,
    g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
  }), Qe("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Ze.sha256,
    gRed: !1,
    g: ["9"]
  }), Qe("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Ze.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var at;
  try {
    at = dew$H();
  } catch {
    at = void 0;
  }
  return Qe("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: Ze.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [{
      a: "3086d221a7d46bcde86c90e49284eb15",
      b: "-e4437ed6010e88286f547fa90abfe4c3"
    }, {
      a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
      b: "3086d221a7d46bcde86c90e49284eb15"
    }],
    gRed: !1,
    g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", at]
  }), exports$H;
}
var exports$G = {}, _dewExec$F = !1;
function dew$F() {
  if (_dewExec$F)
    return exports$G;
  _dewExec$F = !0;
  var $e = dew$I(), Ze = dew$U(), Fe = dew$2m();
  function Ke(Ve) {
    if (!(this instanceof Ke))
      return new Ke(Ve);
    this.hash = Ve.hash, this.predResist = !!Ve.predResist, this.outLen = this.hash.outSize, this.minEntropy = Ve.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var Je = Ze.toArray(Ve.entropy, Ve.entropyEnc || "hex"), Qe = Ze.toArray(Ve.nonce, Ve.nonceEnc || "hex"), at = Ze.toArray(Ve.pers, Ve.persEnc || "hex");
    Fe(Je.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(Je, Qe, at);
  }
  return exports$G = Ke, Ke.prototype._init = function(Je, Qe, at) {
    var ut = Je.concat(Qe).concat(at);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var lt = 0; lt < this.V.length; lt++)
      this.K[lt] = 0, this.V[lt] = 1;
    this._update(ut), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, Ke.prototype._hmac = function() {
    return new $e.hmac(this.hash, this.K);
  }, Ke.prototype._update = function(Je) {
    var Qe = this._hmac().update(this.V).update([0]);
    Je && (Qe = Qe.update(Je)), this.K = Qe.digest(), this.V = this._hmac().update(this.V).digest(), Je && (this.K = this._hmac().update(this.V).update([1]).update(Je).digest(), this.V = this._hmac().update(this.V).digest());
  }, Ke.prototype.reseed = function(Je, Qe, at, ut) {
    typeof Qe != "string" && (ut = at, at = Qe, Qe = null), Je = Ze.toArray(Je, Qe), at = Ze.toArray(at, ut), Fe(Je.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(Je.concat(at || [])), this._reseed = 1;
  }, Ke.prototype.generate = function(Je, Qe, at, ut) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof Qe != "string" && (ut = at, at = Qe, Qe = null), at && (at = Ze.toArray(at, ut || "hex"), this._update(at));
    for (var lt = []; lt.length < Je; )
      this.V = this._hmac().update(this.V).digest(), lt = lt.concat(this.V);
    var dt = lt.slice(0, Je);
    return this._update(at), this._reseed++, Ze.encode(dt, Qe);
  }, exports$G;
}
var exports$F = {}, _dewExec$E = !1;
function dew$E() {
  if (_dewExec$E)
    return exports$F;
  _dewExec$E = !0;
  var $e = dew$V(), Ze = dew$T(), Fe = Ze.assert;
  function Ke(Ve, Je) {
    this.ec = Ve, this.priv = null, this.pub = null, Je.priv && this._importPrivate(Je.priv, Je.privEnc), Je.pub && this._importPublic(Je.pub, Je.pubEnc);
  }
  return exports$F = Ke, Ke.fromPublic = function(Je, Qe, at) {
    return Qe instanceof Ke ? Qe : new Ke(Je, {
      pub: Qe,
      pubEnc: at
    });
  }, Ke.fromPrivate = function(Je, Qe, at) {
    return Qe instanceof Ke ? Qe : new Ke(Je, {
      priv: Qe,
      privEnc: at
    });
  }, Ke.prototype.validate = function() {
    var Je = this.getPublic();
    return Je.isInfinity() ? {
      result: !1,
      reason: "Invalid public key"
    } : Je.validate() ? Je.mul(this.ec.curve.n).isInfinity() ? {
      result: !0,
      reason: null
    } : {
      result: !1,
      reason: "Public key * N != O"
    } : {
      result: !1,
      reason: "Public key is not a point"
    };
  }, Ke.prototype.getPublic = function(Je, Qe) {
    return typeof Je == "string" && (Qe = Je, Je = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), Qe ? this.pub.encode(Qe, Je) : this.pub;
  }, Ke.prototype.getPrivate = function(Je) {
    return Je === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, Ke.prototype._importPrivate = function(Je, Qe) {
    this.priv = new $e(Je, Qe || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, Ke.prototype._importPublic = function(Je, Qe) {
    if (Je.x || Je.y) {
      this.ec.curve.type === "mont" ? Fe(Je.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Fe(Je.x && Je.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(Je.x, Je.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(Je, Qe);
  }, Ke.prototype.derive = function(Je) {
    return Je.validate() || Fe(Je.validate(), "public point not validated"), Je.mul(this.priv).getX();
  }, Ke.prototype.sign = function(Je, Qe, at) {
    return this.ec.sign(Je, this, Qe, at);
  }, Ke.prototype.verify = function(Je, Qe) {
    return this.ec.verify(Je, Qe, this);
  }, Ke.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, exports$F;
}
var exports$E = {}, _dewExec$D = !1;
function dew$D() {
  if (_dewExec$D)
    return exports$E;
  _dewExec$D = !0;
  var $e = dew$V(), Ze = dew$T(), Fe = Ze.assert;
  function Ke(ut, lt) {
    if (ut instanceof Ke)
      return ut;
    this._importDER(ut, lt) || (Fe(ut.r && ut.s, "Signature without r or s"), this.r = new $e(ut.r, 16), this.s = new $e(ut.s, 16), ut.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = ut.recoveryParam);
  }
  exports$E = Ke;
  function Ve() {
    this.place = 0;
  }
  function Je(ut, lt) {
    var dt = ut[lt.place++];
    if (!(dt & 128))
      return dt;
    var bt = dt & 15;
    if (bt === 0 || bt > 4)
      return !1;
    for (var $t = 0, vt = 0, wt = lt.place; vt < bt; vt++, wt++)
      $t <<= 8, $t |= ut[wt], $t >>>= 0;
    return $t <= 127 ? !1 : (lt.place = wt, $t);
  }
  function Qe(ut) {
    for (var lt = 0, dt = ut.length - 1; !ut[lt] && !(ut[lt + 1] & 128) && lt < dt; )
      lt++;
    return lt === 0 ? ut : ut.slice(lt);
  }
  Ke.prototype._importDER = function(lt, dt) {
    lt = Ze.toArray(lt, dt);
    var bt = new Ve();
    if (lt[bt.place++] !== 48)
      return !1;
    var $t = Je(lt, bt);
    if ($t === !1 || $t + bt.place !== lt.length || lt[bt.place++] !== 2)
      return !1;
    var vt = Je(lt, bt);
    if (vt === !1)
      return !1;
    var wt = lt.slice(bt.place, vt + bt.place);
    if (bt.place += vt, lt[bt.place++] !== 2)
      return !1;
    var xt = Je(lt, bt);
    if (xt === !1 || lt.length !== xt + bt.place)
      return !1;
    var Et = lt.slice(bt.place, xt + bt.place);
    if (wt[0] === 0)
      if (wt[1] & 128)
        wt = wt.slice(1);
      else
        return !1;
    if (Et[0] === 0)
      if (Et[1] & 128)
        Et = Et.slice(1);
      else
        return !1;
    return this.r = new $e(wt), this.s = new $e(Et), this.recoveryParam = null, !0;
  };
  function at(ut, lt) {
    if (lt < 128) {
      ut.push(lt);
      return;
    }
    var dt = 1 + (Math.log(lt) / Math.LN2 >>> 3);
    for (ut.push(dt | 128); --dt; )
      ut.push(lt >>> (dt << 3) & 255);
    ut.push(lt);
  }
  return Ke.prototype.toDER = function(lt) {
    var dt = this.r.toArray(), bt = this.s.toArray();
    for (dt[0] & 128 && (dt = [0].concat(dt)), bt[0] & 128 && (bt = [0].concat(bt)), dt = Qe(dt), bt = Qe(bt); !bt[0] && !(bt[1] & 128); )
      bt = bt.slice(1);
    var $t = [2];
    at($t, dt.length), $t = $t.concat(dt), $t.push(2), at($t, bt.length);
    var vt = $t.concat(bt), wt = [48];
    return at(wt, vt.length), wt = wt.concat(vt), Ze.encode(wt, lt);
  }, exports$E;
}
var exports$D = {}, _dewExec$C = !1;
function dew$C() {
  if (_dewExec$C)
    return exports$D;
  _dewExec$C = !0;
  var $e = dew$V(), Ze = dew$F(), Fe = dew$T(), Ke = dew$G(), Ve = dew$11(), Je = Fe.assert, Qe = dew$E(), at = dew$D();
  function ut(lt) {
    if (!(this instanceof ut))
      return new ut(lt);
    typeof lt == "string" && (Je(Object.prototype.hasOwnProperty.call(Ke, lt), "Unknown curve " + lt), lt = Ke[lt]), lt instanceof Ke.PresetCurve && (lt = {
      curve: lt
    }), this.curve = lt.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = lt.curve.g, this.g.precompute(lt.curve.n.bitLength() + 1), this.hash = lt.hash || lt.curve.hash;
  }
  return exports$D = ut, ut.prototype.keyPair = function(dt) {
    return new Qe(this, dt);
  }, ut.prototype.keyFromPrivate = function(dt, bt) {
    return Qe.fromPrivate(this, dt, bt);
  }, ut.prototype.keyFromPublic = function(dt, bt) {
    return Qe.fromPublic(this, dt, bt);
  }, ut.prototype.genKeyPair = function(dt) {
    dt || (dt = {});
    for (var bt = new Ze({
      hash: this.hash,
      pers: dt.pers,
      persEnc: dt.persEnc || "utf8",
      entropy: dt.entropy || Ve(this.hash.hmacStrength),
      entropyEnc: dt.entropy && dt.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), $t = this.n.byteLength(), vt = this.n.sub(new $e(2)); ; ) {
      var wt = new $e(bt.generate($t));
      if (!(wt.cmp(vt) > 0))
        return wt.iaddn(1), this.keyFromPrivate(wt);
    }
  }, ut.prototype._truncateToN = function(dt, bt) {
    var $t = dt.byteLength() * 8 - this.n.bitLength();
    return $t > 0 && (dt = dt.ushrn($t)), !bt && dt.cmp(this.n) >= 0 ? dt.sub(this.n) : dt;
  }, ut.prototype.sign = function(dt, bt, $t, vt) {
    typeof $t == "object" && (vt = $t, $t = null), vt || (vt = {}), bt = this.keyFromPrivate(bt, $t), dt = this._truncateToN(new $e(dt, 16));
    for (var wt = this.n.byteLength(), xt = bt.getPrivate().toArray("be", wt), Et = dt.toArray("be", wt), Tt = new Ze({
      hash: this.hash,
      entropy: xt,
      nonce: Et,
      pers: vt.pers,
      persEnc: vt.persEnc || "utf8"
    }), Rt = this.n.sub(new $e(1)), Ct = 0; ; Ct++) {
      var Zt = vt.k ? vt.k(Ct) : new $e(Tt.generate(this.n.byteLength()));
      if (Zt = this._truncateToN(Zt, !0), !(Zt.cmpn(1) <= 0 || Zt.cmp(Rt) >= 0)) {
        var Lt = this.g.mul(Zt);
        if (!Lt.isInfinity()) {
          var Ut = Lt.getX(), Pt = Ut.umod(this.n);
          if (Pt.cmpn(0) !== 0) {
            var Ot = Zt.invm(this.n).mul(Pt.mul(bt.getPrivate()).iadd(dt));
            if (Ot = Ot.umod(this.n), Ot.cmpn(0) !== 0) {
              var Ft = (Lt.getY().isOdd() ? 1 : 0) | (Ut.cmp(Pt) !== 0 ? 2 : 0);
              return vt.canonical && Ot.cmp(this.nh) > 0 && (Ot = this.n.sub(Ot), Ft ^= 1), new at({
                r: Pt,
                s: Ot,
                recoveryParam: Ft
              });
            }
          }
        }
      }
    }
  }, ut.prototype.verify = function(dt, bt, $t, vt) {
    dt = this._truncateToN(new $e(dt, 16)), $t = this.keyFromPublic($t, vt), bt = new at(bt, "hex");
    var wt = bt.r, xt = bt.s;
    if (wt.cmpn(1) < 0 || wt.cmp(this.n) >= 0 || xt.cmpn(1) < 0 || xt.cmp(this.n) >= 0)
      return !1;
    var Et = xt.invm(this.n), Tt = Et.mul(dt).umod(this.n), Rt = Et.mul(wt).umod(this.n), Ct;
    return this.curve._maxwellTrick ? (Ct = this.g.jmulAdd(Tt, $t.getPublic(), Rt), Ct.isInfinity() ? !1 : Ct.eqXToP(wt)) : (Ct = this.g.mulAdd(Tt, $t.getPublic(), Rt), Ct.isInfinity() ? !1 : Ct.getX().umod(this.n).cmp(wt) === 0);
  }, ut.prototype.recoverPubKey = function(lt, dt, bt, $t) {
    Je((3 & bt) === bt, "The recovery param is more than two bits"), dt = new at(dt, $t);
    var vt = this.n, wt = new $e(lt), xt = dt.r, Et = dt.s, Tt = bt & 1, Rt = bt >> 1;
    if (xt.cmp(this.curve.p.umod(this.curve.n)) >= 0 && Rt)
      throw new Error("Unable to find sencond key candinate");
    Rt ? xt = this.curve.pointFromX(xt.add(this.curve.n), Tt) : xt = this.curve.pointFromX(xt, Tt);
    var Ct = dt.r.invm(vt), Zt = vt.sub(wt).mul(Ct).umod(vt), Lt = Et.mul(Ct).umod(vt);
    return this.g.mulAdd(Zt, xt, Lt);
  }, ut.prototype.getKeyRecoveryParam = function(lt, dt, bt, $t) {
    if (dt = new at(dt, $t), dt.recoveryParam !== null)
      return dt.recoveryParam;
    for (var vt = 0; vt < 4; vt++) {
      var wt;
      try {
        wt = this.recoverPubKey(lt, dt, vt);
      } catch {
        continue;
      }
      if (wt.eq(bt))
        return vt;
    }
    throw new Error("Unable to find valid recovery factor");
  }, exports$D;
}
var exports$C = {}, _dewExec$B = !1;
function dew$B() {
  if (_dewExec$B)
    return exports$C;
  _dewExec$B = !0;
  var $e = dew$T(), Ze = $e.assert, Fe = $e.parseBytes, Ke = $e.cachedProperty;
  function Ve(Je, Qe) {
    this.eddsa = Je, this._secret = Fe(Qe.secret), Je.isPoint(Qe.pub) ? this._pub = Qe.pub : this._pubBytes = Fe(Qe.pub);
  }
  return Ve.fromPublic = function(Qe, at) {
    return at instanceof Ve ? at : new Ve(Qe, {
      pub: at
    });
  }, Ve.fromSecret = function(Qe, at) {
    return at instanceof Ve ? at : new Ve(Qe, {
      secret: at
    });
  }, Ve.prototype.secret = function() {
    return this._secret;
  }, Ke(Ve, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), Ke(Ve, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), Ke(Ve, "privBytes", function() {
    var Qe = this.eddsa, at = this.hash(), ut = Qe.encodingLength - 1, lt = at.slice(0, Qe.encodingLength);
    return lt[0] &= 248, lt[ut] &= 127, lt[ut] |= 64, lt;
  }), Ke(Ve, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), Ke(Ve, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), Ke(Ve, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), Ve.prototype.sign = function(Qe) {
    return Ze(this._secret, "KeyPair can only verify"), this.eddsa.sign(Qe, this);
  }, Ve.prototype.verify = function(Qe, at) {
    return this.eddsa.verify(Qe, at, this);
  }, Ve.prototype.getSecret = function(Qe) {
    return Ze(this._secret, "KeyPair is public only"), $e.encode(this.secret(), Qe);
  }, Ve.prototype.getPublic = function(Qe) {
    return $e.encode(this.pubBytes(), Qe);
  }, exports$C = Ve, exports$C;
}
var exports$B = {}, _dewExec$A = !1;
function dew$A() {
  if (_dewExec$A)
    return exports$B;
  _dewExec$A = !0;
  var $e = dew$V(), Ze = dew$T(), Fe = Ze.assert, Ke = Ze.cachedProperty, Ve = Ze.parseBytes;
  function Je(Qe, at) {
    this.eddsa = Qe, typeof at != "object" && (at = Ve(at)), Array.isArray(at) && (at = {
      R: at.slice(0, Qe.encodingLength),
      S: at.slice(Qe.encodingLength)
    }), Fe(at.R && at.S, "Signature without R or S"), Qe.isPoint(at.R) && (this._R = at.R), at.S instanceof $e && (this._S = at.S), this._Rencoded = Array.isArray(at.R) ? at.R : at.Rencoded, this._Sencoded = Array.isArray(at.S) ? at.S : at.Sencoded;
  }
  return Ke(Je, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), Ke(Je, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), Ke(Je, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), Ke(Je, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), Je.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, Je.prototype.toHex = function() {
    return Ze.encode(this.toBytes(), "hex").toUpperCase();
  }, exports$B = Je, exports$B;
}
var exports$A = {}, _dewExec$z = !1;
function dew$z() {
  if (_dewExec$z)
    return exports$A;
  _dewExec$z = !0;
  var $e = dew$I(), Ze = dew$G(), Fe = dew$T(), Ke = Fe.assert, Ve = Fe.parseBytes, Je = dew$B(), Qe = dew$A();
  function at(ut) {
    if (Ke(ut === "ed25519", "only tested with ed25519 so far"), !(this instanceof at))
      return new at(ut);
    ut = Ze[ut].curve, this.curve = ut, this.g = ut.g, this.g.precompute(ut.n.bitLength() + 1), this.pointClass = ut.point().constructor, this.encodingLength = Math.ceil(ut.n.bitLength() / 8), this.hash = $e.sha512;
  }
  return exports$A = at, at.prototype.sign = function(lt, dt) {
    lt = Ve(lt);
    var bt = this.keyFromSecret(dt), $t = this.hashInt(bt.messagePrefix(), lt), vt = this.g.mul($t), wt = this.encodePoint(vt), xt = this.hashInt(wt, bt.pubBytes(), lt).mul(bt.priv()), Et = $t.add(xt).umod(this.curve.n);
    return this.makeSignature({
      R: vt,
      S: Et,
      Rencoded: wt
    });
  }, at.prototype.verify = function(lt, dt, bt) {
    lt = Ve(lt), dt = this.makeSignature(dt);
    var $t = this.keyFromPublic(bt), vt = this.hashInt(dt.Rencoded(), $t.pubBytes(), lt), wt = this.g.mul(dt.S()), xt = dt.R().add($t.pub().mul(vt));
    return xt.eq(wt);
  }, at.prototype.hashInt = function() {
    for (var lt = this.hash(), dt = 0; dt < arguments.length; dt++)
      lt.update(arguments[dt]);
    return Fe.intFromLE(lt.digest()).umod(this.curve.n);
  }, at.prototype.keyFromPublic = function(lt) {
    return Je.fromPublic(this, lt);
  }, at.prototype.keyFromSecret = function(lt) {
    return Je.fromSecret(this, lt);
  }, at.prototype.makeSignature = function(lt) {
    return lt instanceof Qe ? lt : new Qe(this, lt);
  }, at.prototype.encodePoint = function(lt) {
    var dt = lt.getY().toArray("le", this.encodingLength);
    return dt[this.encodingLength - 1] |= lt.getX().isOdd() ? 128 : 0, dt;
  }, at.prototype.decodePoint = function(lt) {
    lt = Fe.parseBytes(lt);
    var dt = lt.length - 1, bt = lt.slice(0, dt).concat(lt[dt] & -129), $t = (lt[dt] & 128) !== 0, vt = Fe.intFromLE(bt);
    return this.curve.pointFromY(vt, $t);
  }, at.prototype.encodeInt = function(lt) {
    return lt.toArray("le", this.encodingLength);
  }, at.prototype.decodeInt = function(lt) {
    return Fe.intFromLE(lt);
  }, at.prototype.isPoint = function(lt) {
    return lt instanceof this.pointClass;
  }, exports$A;
}
var exports$z = {}, _dewExec$y = !1;
function dew$y() {
  if (_dewExec$y)
    return exports$z;
  _dewExec$y = !0;
  var $e = exports$z;
  return $e.version = _package.version, $e.utils = dew$T(), $e.rand = dew$11(), $e.curve = dew$O(), $e.curves = dew$G(), $e.ec = dew$C(), $e.eddsa = dew$z(), exports$z;
}
var exports$y = {}, _dewExec$x = !1, module$2 = {
  exports: exports$y
}, _global$5 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$x() {
  return _dewExec$x || (_dewExec$x = !0, function($e, Ze) {
    function Fe(gt, We) {
      if (!gt)
        throw new Error(We || "Assertion failed");
    }
    function Ke(gt, We) {
      gt.super_ = We;
      var Xe = function() {
      };
      Xe.prototype = We.prototype, gt.prototype = new Xe(), gt.prototype.constructor = gt;
    }
    function Ve(gt, We, Xe) {
      if (Ve.isBN(gt))
        return gt;
      (this || _global$5).negative = 0, (this || _global$5).words = null, (this || _global$5).length = 0, (this || _global$5).red = null, gt !== null && ((We === "le" || We === "be") && (Xe = We, We = 10), this._init(gt || 0, We || 10, Xe || "be"));
    }
    typeof $e == "object" ? $e.exports = Ve : Ze.BN = Ve, Ve.BN = Ve, Ve.wordSize = 26;
    var Je;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Je = window.Buffer : Je = buffer.Buffer;
    } catch {
    }
    Ve.isBN = function(We) {
      return We instanceof Ve ? !0 : We !== null && typeof We == "object" && We.constructor.wordSize === Ve.wordSize && Array.isArray(We.words);
    }, Ve.max = function(We, Xe) {
      return We.cmp(Xe) > 0 ? We : Xe;
    }, Ve.min = function(We, Xe) {
      return We.cmp(Xe) < 0 ? We : Xe;
    }, Ve.prototype._init = function(We, Xe, rt) {
      if (typeof We == "number")
        return this._initNumber(We, Xe, rt);
      if (typeof We == "object")
        return this._initArray(We, Xe, rt);
      Xe === "hex" && (Xe = 16), Fe(Xe === (Xe | 0) && Xe >= 2 && Xe <= 36), We = We.toString().replace(/\s+/g, "");
      var ot = 0;
      We[0] === "-" && (ot++, (this || _global$5).negative = 1), ot < We.length && (Xe === 16 ? this._parseHex(We, ot, rt) : (this._parseBase(We, Xe, ot), rt === "le" && this._initArray(this.toArray(), Xe, rt)));
    }, Ve.prototype._initNumber = function(We, Xe, rt) {
      We < 0 && ((this || _global$5).negative = 1, We = -We), We < 67108864 ? ((this || _global$5).words = [We & 67108863], (this || _global$5).length = 1) : We < 4503599627370496 ? ((this || _global$5).words = [We & 67108863, We / 67108864 & 67108863], (this || _global$5).length = 2) : (Fe(We < 9007199254740992), (this || _global$5).words = [We & 67108863, We / 67108864 & 67108863, 1], (this || _global$5).length = 3), rt === "le" && this._initArray(this.toArray(), Xe, rt);
    }, Ve.prototype._initArray = function(We, Xe, rt) {
      if (Fe(typeof We.length == "number"), We.length <= 0)
        return (this || _global$5).words = [0], (this || _global$5).length = 1, this || _global$5;
      (this || _global$5).length = Math.ceil(We.length / 3), (this || _global$5).words = new Array((this || _global$5).length);
      for (var ot = 0; ot < (this || _global$5).length; ot++)
        (this || _global$5).words[ot] = 0;
      var ft, mt, yt = 0;
      if (rt === "be")
        for (ot = We.length - 1, ft = 0; ot >= 0; ot -= 3)
          mt = We[ot] | We[ot - 1] << 8 | We[ot - 2] << 16, (this || _global$5).words[ft] |= mt << yt & 67108863, (this || _global$5).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      else if (rt === "le")
        for (ot = 0, ft = 0; ot < We.length; ot += 3)
          mt = We[ot] | We[ot + 1] << 8 | We[ot + 2] << 16, (this || _global$5).words[ft] |= mt << yt & 67108863, (this || _global$5).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      return this.strip();
    };
    function Qe(gt, We) {
      var Xe = gt.charCodeAt(We);
      return Xe >= 65 && Xe <= 70 ? Xe - 55 : Xe >= 97 && Xe <= 102 ? Xe - 87 : Xe - 48 & 15;
    }
    function at(gt, We, Xe) {
      var rt = Qe(gt, Xe);
      return Xe - 1 >= We && (rt |= Qe(gt, Xe - 1) << 4), rt;
    }
    Ve.prototype._parseHex = function(We, Xe, rt) {
      (this || _global$5).length = Math.ceil((We.length - Xe) / 6), (this || _global$5).words = new Array((this || _global$5).length);
      for (var ot = 0; ot < (this || _global$5).length; ot++)
        (this || _global$5).words[ot] = 0;
      var ft = 0, mt = 0, yt;
      if (rt === "be")
        for (ot = We.length - 1; ot >= Xe; ot -= 2)
          yt = at(We, Xe, ot) << ft, (this || _global$5).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$5).words[mt] |= yt >>> 26) : ft += 8;
      else {
        var pt = We.length - Xe;
        for (ot = pt % 2 === 0 ? Xe + 1 : Xe; ot < We.length; ot += 2)
          yt = at(We, Xe, ot) << ft, (this || _global$5).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$5).words[mt] |= yt >>> 26) : ft += 8;
      }
      this.strip();
    };
    function ut(gt, We, Xe, rt) {
      for (var ot = 0, ft = Math.min(gt.length, Xe), mt = We; mt < ft; mt++) {
        var yt = gt.charCodeAt(mt) - 48;
        ot *= rt, yt >= 49 ? ot += yt - 49 + 10 : yt >= 17 ? ot += yt - 17 + 10 : ot += yt;
      }
      return ot;
    }
    Ve.prototype._parseBase = function(We, Xe, rt) {
      (this || _global$5).words = [0], (this || _global$5).length = 1;
      for (var ot = 0, ft = 1; ft <= 67108863; ft *= Xe)
        ot++;
      ot--, ft = ft / Xe | 0;
      for (var mt = We.length - rt, yt = mt % ot, pt = Math.min(mt, mt - yt) + rt, Ge = 0, ct = rt; ct < pt; ct += ot)
        Ge = ut(We, ct, ct + ot, Xe), this.imuln(ft), (this || _global$5).words[0] + Ge < 67108864 ? (this || _global$5).words[0] += Ge : this._iaddn(Ge);
      if (yt !== 0) {
        var Mt = 1;
        for (Ge = ut(We, ct, We.length, Xe), ct = 0; ct < yt; ct++)
          Mt *= Xe;
        this.imuln(Mt), (this || _global$5).words[0] + Ge < 67108864 ? (this || _global$5).words[0] += Ge : this._iaddn(Ge);
      }
      this.strip();
    }, Ve.prototype.copy = function(We) {
      We.words = new Array((this || _global$5).length);
      for (var Xe = 0; Xe < (this || _global$5).length; Xe++)
        We.words[Xe] = (this || _global$5).words[Xe];
      We.length = (this || _global$5).length, We.negative = (this || _global$5).negative, We.red = (this || _global$5).red;
    }, Ve.prototype.clone = function() {
      var We = new Ve(null);
      return this.copy(We), We;
    }, Ve.prototype._expand = function(We) {
      for (; (this || _global$5).length < We; )
        (this || _global$5).words[(this || _global$5).length++] = 0;
      return this || _global$5;
    }, Ve.prototype.strip = function() {
      for (; (this || _global$5).length > 1 && (this || _global$5).words[(this || _global$5).length - 1] === 0; )
        (this || _global$5).length--;
      return this._normSign();
    }, Ve.prototype._normSign = function() {
      return (this || _global$5).length === 1 && (this || _global$5).words[0] === 0 && ((this || _global$5).negative = 0), this || _global$5;
    }, Ve.prototype.inspect = function() {
      return ((this || _global$5).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var lt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], dt = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], bt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    Ve.prototype.toString = function(We, Xe) {
      We = We || 10, Xe = Xe | 0 || 1;
      var rt;
      if (We === 16 || We === "hex") {
        rt = "";
        for (var ot = 0, ft = 0, mt = 0; mt < (this || _global$5).length; mt++) {
          var yt = (this || _global$5).words[mt], pt = ((yt << ot | ft) & 16777215).toString(16);
          ft = yt >>> 24 - ot & 16777215, ft !== 0 || mt !== (this || _global$5).length - 1 ? rt = lt[6 - pt.length] + pt + rt : rt = pt + rt, ot += 2, ot >= 26 && (ot -= 26, mt--);
        }
        for (ft !== 0 && (rt = ft.toString(16) + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$5).negative !== 0 && (rt = "-" + rt), rt;
      }
      if (We === (We | 0) && We >= 2 && We <= 36) {
        var Ge = dt[We], ct = bt[We];
        rt = "";
        var Mt = this.clone();
        for (Mt.negative = 0; !Mt.isZero(); ) {
          var St = Mt.modn(ct).toString(We);
          Mt = Mt.idivn(ct), Mt.isZero() ? rt = St + rt : rt = lt[Ge - St.length] + St + rt;
        }
        for (this.isZero() && (rt = "0" + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$5).negative !== 0 && (rt = "-" + rt), rt;
      }
      Fe(!1, "Base should be between 2 and 36");
    }, Ve.prototype.toNumber = function() {
      var We = (this || _global$5).words[0];
      return (this || _global$5).length === 2 ? We += (this || _global$5).words[1] * 67108864 : (this || _global$5).length === 3 && (this || _global$5).words[2] === 1 ? We += 4503599627370496 + (this || _global$5).words[1] * 67108864 : (this || _global$5).length > 2 && Fe(!1, "Number can only safely store up to 53 bits"), (this || _global$5).negative !== 0 ? -We : We;
    }, Ve.prototype.toJSON = function() {
      return this.toString(16);
    }, Ve.prototype.toBuffer = function(We, Xe) {
      return Fe(typeof Je < "u"), this.toArrayLike(Je, We, Xe);
    }, Ve.prototype.toArray = function(We, Xe) {
      return this.toArrayLike(Array, We, Xe);
    }, Ve.prototype.toArrayLike = function(We, Xe, rt) {
      var ot = this.byteLength(), ft = rt || Math.max(1, ot);
      Fe(ot <= ft, "byte array longer than desired length"), Fe(ft > 0, "Requested array length <= 0"), this.strip();
      var mt = Xe === "le", yt = new We(ft), pt, Ge, ct = this.clone();
      if (mt) {
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[Ge] = pt;
        for (; Ge < ft; Ge++)
          yt[Ge] = 0;
      } else {
        for (Ge = 0; Ge < ft - ot; Ge++)
          yt[Ge] = 0;
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[ft - Ge - 1] = pt;
      }
      return yt;
    }, Math.clz32 ? Ve.prototype._countBits = function(We) {
      return 32 - Math.clz32(We);
    } : Ve.prototype._countBits = function(We) {
      var Xe = We, rt = 0;
      return Xe >= 4096 && (rt += 13, Xe >>>= 13), Xe >= 64 && (rt += 7, Xe >>>= 7), Xe >= 8 && (rt += 4, Xe >>>= 4), Xe >= 2 && (rt += 2, Xe >>>= 2), rt + Xe;
    }, Ve.prototype._zeroBits = function(We) {
      if (We === 0)
        return 26;
      var Xe = We, rt = 0;
      return Xe & 8191 || (rt += 13, Xe >>>= 13), Xe & 127 || (rt += 7, Xe >>>= 7), Xe & 15 || (rt += 4, Xe >>>= 4), Xe & 3 || (rt += 2, Xe >>>= 2), Xe & 1 || rt++, rt;
    }, Ve.prototype.bitLength = function() {
      var We = (this || _global$5).words[(this || _global$5).length - 1], Xe = this._countBits(We);
      return ((this || _global$5).length - 1) * 26 + Xe;
    };
    function $t(gt) {
      for (var We = new Array(gt.bitLength()), Xe = 0; Xe < We.length; Xe++) {
        var rt = Xe / 26 | 0, ot = Xe % 26;
        We[Xe] = (gt.words[rt] & 1 << ot) >>> ot;
      }
      return We;
    }
    Ve.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var We = 0, Xe = 0; Xe < (this || _global$5).length; Xe++) {
        var rt = this._zeroBits((this || _global$5).words[Xe]);
        if (We += rt, rt !== 26)
          break;
      }
      return We;
    }, Ve.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Ve.prototype.toTwos = function(We) {
      return (this || _global$5).negative !== 0 ? this.abs().inotn(We).iaddn(1) : this.clone();
    }, Ve.prototype.fromTwos = function(We) {
      return this.testn(We - 1) ? this.notn(We).iaddn(1).ineg() : this.clone();
    }, Ve.prototype.isNeg = function() {
      return (this || _global$5).negative !== 0;
    }, Ve.prototype.neg = function() {
      return this.clone().ineg();
    }, Ve.prototype.ineg = function() {
      return this.isZero() || ((this || _global$5).negative ^= 1), this || _global$5;
    }, Ve.prototype.iuor = function(We) {
      for (; (this || _global$5).length < We.length; )
        (this || _global$5).words[(this || _global$5).length++] = 0;
      for (var Xe = 0; Xe < We.length; Xe++)
        (this || _global$5).words[Xe] = (this || _global$5).words[Xe] | We.words[Xe];
      return this.strip();
    }, Ve.prototype.ior = function(We) {
      return Fe(((this || _global$5).negative | We.negative) === 0), this.iuor(We);
    }, Ve.prototype.or = function(We) {
      return (this || _global$5).length > We.length ? this.clone().ior(We) : We.clone().ior(this || _global$5);
    }, Ve.prototype.uor = function(We) {
      return (this || _global$5).length > We.length ? this.clone().iuor(We) : We.clone().iuor(this || _global$5);
    }, Ve.prototype.iuand = function(We) {
      var Xe;
      (this || _global$5).length > We.length ? Xe = We : Xe = this || _global$5;
      for (var rt = 0; rt < Xe.length; rt++)
        (this || _global$5).words[rt] = (this || _global$5).words[rt] & We.words[rt];
      return (this || _global$5).length = Xe.length, this.strip();
    }, Ve.prototype.iand = function(We) {
      return Fe(((this || _global$5).negative | We.negative) === 0), this.iuand(We);
    }, Ve.prototype.and = function(We) {
      return (this || _global$5).length > We.length ? this.clone().iand(We) : We.clone().iand(this || _global$5);
    }, Ve.prototype.uand = function(We) {
      return (this || _global$5).length > We.length ? this.clone().iuand(We) : We.clone().iuand(this || _global$5);
    }, Ve.prototype.iuxor = function(We) {
      var Xe, rt;
      (this || _global$5).length > We.length ? (Xe = this || _global$5, rt = We) : (Xe = We, rt = this || _global$5);
      for (var ot = 0; ot < rt.length; ot++)
        (this || _global$5).words[ot] = Xe.words[ot] ^ rt.words[ot];
      if ((this || _global$5) !== Xe)
        for (; ot < Xe.length; ot++)
          (this || _global$5).words[ot] = Xe.words[ot];
      return (this || _global$5).length = Xe.length, this.strip();
    }, Ve.prototype.ixor = function(We) {
      return Fe(((this || _global$5).negative | We.negative) === 0), this.iuxor(We);
    }, Ve.prototype.xor = function(We) {
      return (this || _global$5).length > We.length ? this.clone().ixor(We) : We.clone().ixor(this || _global$5);
    }, Ve.prototype.uxor = function(We) {
      return (this || _global$5).length > We.length ? this.clone().iuxor(We) : We.clone().iuxor(this || _global$5);
    }, Ve.prototype.inotn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = Math.ceil(We / 26) | 0, rt = We % 26;
      this._expand(Xe), rt > 0 && Xe--;
      for (var ot = 0; ot < Xe; ot++)
        (this || _global$5).words[ot] = ~(this || _global$5).words[ot] & 67108863;
      return rt > 0 && ((this || _global$5).words[ot] = ~(this || _global$5).words[ot] & 67108863 >> 26 - rt), this.strip();
    }, Ve.prototype.notn = function(We) {
      return this.clone().inotn(We);
    }, Ve.prototype.setn = function(We, Xe) {
      Fe(typeof We == "number" && We >= 0);
      var rt = We / 26 | 0, ot = We % 26;
      return this._expand(rt + 1), Xe ? (this || _global$5).words[rt] = (this || _global$5).words[rt] | 1 << ot : (this || _global$5).words[rt] = (this || _global$5).words[rt] & ~(1 << ot), this.strip();
    }, Ve.prototype.iadd = function(We) {
      var Xe;
      if ((this || _global$5).negative !== 0 && We.negative === 0)
        return (this || _global$5).negative = 0, Xe = this.isub(We), (this || _global$5).negative ^= 1, this._normSign();
      if ((this || _global$5).negative === 0 && We.negative !== 0)
        return We.negative = 0, Xe = this.isub(We), We.negative = 1, Xe._normSign();
      var rt, ot;
      (this || _global$5).length > We.length ? (rt = this || _global$5, ot = We) : (rt = We, ot = this || _global$5);
      for (var ft = 0, mt = 0; mt < ot.length; mt++)
        Xe = (rt.words[mt] | 0) + (ot.words[mt] | 0) + ft, (this || _global$5).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      for (; ft !== 0 && mt < rt.length; mt++)
        Xe = (rt.words[mt] | 0) + ft, (this || _global$5).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      if ((this || _global$5).length = rt.length, ft !== 0)
        (this || _global$5).words[(this || _global$5).length] = ft, (this || _global$5).length++;
      else if (rt !== (this || _global$5))
        for (; mt < rt.length; mt++)
          (this || _global$5).words[mt] = rt.words[mt];
      return this || _global$5;
    }, Ve.prototype.add = function(We) {
      var Xe;
      return We.negative !== 0 && (this || _global$5).negative === 0 ? (We.negative = 0, Xe = this.sub(We), We.negative ^= 1, Xe) : We.negative === 0 && (this || _global$5).negative !== 0 ? ((this || _global$5).negative = 0, Xe = We.sub(this || _global$5), (this || _global$5).negative = 1, Xe) : (this || _global$5).length > We.length ? this.clone().iadd(We) : We.clone().iadd(this || _global$5);
    }, Ve.prototype.isub = function(We) {
      if (We.negative !== 0) {
        We.negative = 0;
        var Xe = this.iadd(We);
        return We.negative = 1, Xe._normSign();
      } else if ((this || _global$5).negative !== 0)
        return (this || _global$5).negative = 0, this.iadd(We), (this || _global$5).negative = 1, this._normSign();
      var rt = this.cmp(We);
      if (rt === 0)
        return (this || _global$5).negative = 0, (this || _global$5).length = 1, (this || _global$5).words[0] = 0, this || _global$5;
      var ot, ft;
      rt > 0 ? (ot = this || _global$5, ft = We) : (ot = We, ft = this || _global$5);
      for (var mt = 0, yt = 0; yt < ft.length; yt++)
        Xe = (ot.words[yt] | 0) - (ft.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$5).words[yt] = Xe & 67108863;
      for (; mt !== 0 && yt < ot.length; yt++)
        Xe = (ot.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$5).words[yt] = Xe & 67108863;
      if (mt === 0 && yt < ot.length && ot !== (this || _global$5))
        for (; yt < ot.length; yt++)
          (this || _global$5).words[yt] = ot.words[yt];
      return (this || _global$5).length = Math.max((this || _global$5).length, yt), ot !== (this || _global$5) && ((this || _global$5).negative = 1), this.strip();
    }, Ve.prototype.sub = function(We) {
      return this.clone().isub(We);
    };
    function vt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative;
      var rt = gt.length + We.length | 0;
      Xe.length = rt, rt = rt - 1 | 0;
      var ot = gt.words[0] | 0, ft = We.words[0] | 0, mt = ot * ft, yt = mt & 67108863, pt = mt / 67108864 | 0;
      Xe.words[0] = yt;
      for (var Ge = 1; Ge < rt; Ge++) {
        for (var ct = pt >>> 26, Mt = pt & 67108863, St = Math.min(Ge, We.length - 1), At = Math.max(0, Ge - gt.length + 1); At <= St; At++) {
          var Nt = Ge - At | 0;
          ot = gt.words[Nt] | 0, ft = We.words[At] | 0, mt = ot * ft + Mt, ct += mt / 67108864 | 0, Mt = mt & 67108863;
        }
        Xe.words[Ge] = Mt | 0, pt = ct | 0;
      }
      return pt !== 0 ? Xe.words[Ge] = pt | 0 : Xe.length--, Xe.strip();
    }
    var wt = function(We, Xe, rt) {
      var ot = We.words, ft = Xe.words, mt = rt.words, yt = 0, pt, Ge, ct, Mt = ot[0] | 0, St = Mt & 8191, At = Mt >>> 13, Nt = ot[1] | 0, qt = Nt & 8191, Qt = Nt >>> 13, Xt = ot[2] | 0, zt = Xt & 8191, Kt = Xt >>> 13, ur = ot[3] | 0, er = ur & 8191, Dt = ur >>> 13, Ht = ot[4] | 0, Gt = Ht & 8191, rr = Ht >>> 13, sr = ot[5] | 0, Jt = sr & 8191, ir = sr >>> 13, Br = ot[6] | 0, or = Br & 8191, lr = Br >>> 13, Nr = ot[7] | 0, dr = Nr & 8191, gr = Nr >>> 13, Zr = ot[8] | 0, Bt = Zr & 8191, kt = Zr >>> 13, It = ot[9] | 0, jt = It & 8191, Vt = It >>> 13, ar = ft[0] | 0, Yt = ar & 8191, hr = ar >>> 13, zr = ft[1] | 0, cr = zr & 8191, _r = zr >>> 13, Lr = ft[2] | 0, br = Lr & 8191, kr = Lr >>> 13, Xr = ft[3] | 0, yr = Xr & 8191, Ir = Xr >>> 13, Yr = ft[4] | 0, wr = Yr & 8191, Cr = Yr >>> 13, Hr = ft[5] | 0, $r = Hr & 8191, Ar = Hr >>> 13, Wr = ft[6] | 0, mr = Wr & 8191, Tr = Wr >>> 13, Kr = ft[7] | 0, vr = Kr & 8191, Rr = Kr >>> 13, Jr = ft[8] | 0, xr = Jr & 8191, tr = Jr >>> 13, Dr = ft[9] | 0, fr = Dr & 8191, Mr = Dr >>> 13;
      rt.negative = We.negative ^ Xe.negative, rt.length = 19, pt = Math.imul(St, Yt), Ge = Math.imul(St, hr), Ge = Ge + Math.imul(At, Yt) | 0, ct = Math.imul(At, hr);
      var Fr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, pt = Math.imul(qt, Yt), Ge = Math.imul(qt, hr), Ge = Ge + Math.imul(Qt, Yt) | 0, ct = Math.imul(Qt, hr), pt = pt + Math.imul(St, cr) | 0, Ge = Ge + Math.imul(St, _r) | 0, Ge = Ge + Math.imul(At, cr) | 0, ct = ct + Math.imul(At, _r) | 0;
      var qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, pt = Math.imul(zt, Yt), Ge = Math.imul(zt, hr), Ge = Ge + Math.imul(Kt, Yt) | 0, ct = Math.imul(Kt, hr), pt = pt + Math.imul(qt, cr) | 0, Ge = Ge + Math.imul(qt, _r) | 0, Ge = Ge + Math.imul(Qt, cr) | 0, ct = ct + Math.imul(Qt, _r) | 0, pt = pt + Math.imul(St, br) | 0, Ge = Ge + Math.imul(St, kr) | 0, Ge = Ge + Math.imul(At, br) | 0, ct = ct + Math.imul(At, kr) | 0;
      var tn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, pt = Math.imul(er, Yt), Ge = Math.imul(er, hr), Ge = Ge + Math.imul(Dt, Yt) | 0, ct = Math.imul(Dt, hr), pt = pt + Math.imul(zt, cr) | 0, Ge = Ge + Math.imul(zt, _r) | 0, Ge = Ge + Math.imul(Kt, cr) | 0, ct = ct + Math.imul(Kt, _r) | 0, pt = pt + Math.imul(qt, br) | 0, Ge = Ge + Math.imul(qt, kr) | 0, Ge = Ge + Math.imul(Qt, br) | 0, ct = ct + Math.imul(Qt, kr) | 0, pt = pt + Math.imul(St, yr) | 0, Ge = Ge + Math.imul(St, Ir) | 0, Ge = Ge + Math.imul(At, yr) | 0, ct = ct + Math.imul(At, Ir) | 0;
      var Qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, pt = Math.imul(Gt, Yt), Ge = Math.imul(Gt, hr), Ge = Ge + Math.imul(rr, Yt) | 0, ct = Math.imul(rr, hr), pt = pt + Math.imul(er, cr) | 0, Ge = Ge + Math.imul(er, _r) | 0, Ge = Ge + Math.imul(Dt, cr) | 0, ct = ct + Math.imul(Dt, _r) | 0, pt = pt + Math.imul(zt, br) | 0, Ge = Ge + Math.imul(zt, kr) | 0, Ge = Ge + Math.imul(Kt, br) | 0, ct = ct + Math.imul(Kt, kr) | 0, pt = pt + Math.imul(qt, yr) | 0, Ge = Ge + Math.imul(qt, Ir) | 0, Ge = Ge + Math.imul(Qt, yr) | 0, ct = ct + Math.imul(Qt, Ir) | 0, pt = pt + Math.imul(St, wr) | 0, Ge = Ge + Math.imul(St, Cr) | 0, Ge = Ge + Math.imul(At, wr) | 0, ct = ct + Math.imul(At, Cr) | 0;
      var nn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, pt = Math.imul(Jt, Yt), Ge = Math.imul(Jt, hr), Ge = Ge + Math.imul(ir, Yt) | 0, ct = Math.imul(ir, hr), pt = pt + Math.imul(Gt, cr) | 0, Ge = Ge + Math.imul(Gt, _r) | 0, Ge = Ge + Math.imul(rr, cr) | 0, ct = ct + Math.imul(rr, _r) | 0, pt = pt + Math.imul(er, br) | 0, Ge = Ge + Math.imul(er, kr) | 0, Ge = Ge + Math.imul(Dt, br) | 0, ct = ct + Math.imul(Dt, kr) | 0, pt = pt + Math.imul(zt, yr) | 0, Ge = Ge + Math.imul(zt, Ir) | 0, Ge = Ge + Math.imul(Kt, yr) | 0, ct = ct + Math.imul(Kt, Ir) | 0, pt = pt + Math.imul(qt, wr) | 0, Ge = Ge + Math.imul(qt, Cr) | 0, Ge = Ge + Math.imul(Qt, wr) | 0, ct = ct + Math.imul(Qt, Cr) | 0, pt = pt + Math.imul(St, $r) | 0, Ge = Ge + Math.imul(St, Ar) | 0, Ge = Ge + Math.imul(At, $r) | 0, ct = ct + Math.imul(At, Ar) | 0;
      var Er = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, pt = Math.imul(or, Yt), Ge = Math.imul(or, hr), Ge = Ge + Math.imul(lr, Yt) | 0, ct = Math.imul(lr, hr), pt = pt + Math.imul(Jt, cr) | 0, Ge = Ge + Math.imul(Jt, _r) | 0, Ge = Ge + Math.imul(ir, cr) | 0, ct = ct + Math.imul(ir, _r) | 0, pt = pt + Math.imul(Gt, br) | 0, Ge = Ge + Math.imul(Gt, kr) | 0, Ge = Ge + Math.imul(rr, br) | 0, ct = ct + Math.imul(rr, kr) | 0, pt = pt + Math.imul(er, yr) | 0, Ge = Ge + Math.imul(er, Ir) | 0, Ge = Ge + Math.imul(Dt, yr) | 0, ct = ct + Math.imul(Dt, Ir) | 0, pt = pt + Math.imul(zt, wr) | 0, Ge = Ge + Math.imul(zt, Cr) | 0, Ge = Ge + Math.imul(Kt, wr) | 0, ct = ct + Math.imul(Kt, Cr) | 0, pt = pt + Math.imul(qt, $r) | 0, Ge = Ge + Math.imul(qt, Ar) | 0, Ge = Ge + Math.imul(Qt, $r) | 0, ct = ct + Math.imul(Qt, Ar) | 0, pt = pt + Math.imul(St, mr) | 0, Ge = Ge + Math.imul(St, Tr) | 0, Ge = Ge + Math.imul(At, mr) | 0, ct = ct + Math.imul(At, Tr) | 0;
      var Wt = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, pt = Math.imul(dr, Yt), Ge = Math.imul(dr, hr), Ge = Ge + Math.imul(gr, Yt) | 0, ct = Math.imul(gr, hr), pt = pt + Math.imul(or, cr) | 0, Ge = Ge + Math.imul(or, _r) | 0, Ge = Ge + Math.imul(lr, cr) | 0, ct = ct + Math.imul(lr, _r) | 0, pt = pt + Math.imul(Jt, br) | 0, Ge = Ge + Math.imul(Jt, kr) | 0, Ge = Ge + Math.imul(ir, br) | 0, ct = ct + Math.imul(ir, kr) | 0, pt = pt + Math.imul(Gt, yr) | 0, Ge = Ge + Math.imul(Gt, Ir) | 0, Ge = Ge + Math.imul(rr, yr) | 0, ct = ct + Math.imul(rr, Ir) | 0, pt = pt + Math.imul(er, wr) | 0, Ge = Ge + Math.imul(er, Cr) | 0, Ge = Ge + Math.imul(Dt, wr) | 0, ct = ct + Math.imul(Dt, Cr) | 0, pt = pt + Math.imul(zt, $r) | 0, Ge = Ge + Math.imul(zt, Ar) | 0, Ge = Ge + Math.imul(Kt, $r) | 0, ct = ct + Math.imul(Kt, Ar) | 0, pt = pt + Math.imul(qt, mr) | 0, Ge = Ge + Math.imul(qt, Tr) | 0, Ge = Ge + Math.imul(Qt, mr) | 0, ct = ct + Math.imul(Qt, Tr) | 0, pt = pt + Math.imul(St, vr) | 0, Ge = Ge + Math.imul(St, Rr) | 0, Ge = Ge + Math.imul(At, vr) | 0, ct = ct + Math.imul(At, Rr) | 0;
      var nr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, pt = Math.imul(Bt, Yt), Ge = Math.imul(Bt, hr), Ge = Ge + Math.imul(kt, Yt) | 0, ct = Math.imul(kt, hr), pt = pt + Math.imul(dr, cr) | 0, Ge = Ge + Math.imul(dr, _r) | 0, Ge = Ge + Math.imul(gr, cr) | 0, ct = ct + Math.imul(gr, _r) | 0, pt = pt + Math.imul(or, br) | 0, Ge = Ge + Math.imul(or, kr) | 0, Ge = Ge + Math.imul(lr, br) | 0, ct = ct + Math.imul(lr, kr) | 0, pt = pt + Math.imul(Jt, yr) | 0, Ge = Ge + Math.imul(Jt, Ir) | 0, Ge = Ge + Math.imul(ir, yr) | 0, ct = ct + Math.imul(ir, Ir) | 0, pt = pt + Math.imul(Gt, wr) | 0, Ge = Ge + Math.imul(Gt, Cr) | 0, Ge = Ge + Math.imul(rr, wr) | 0, ct = ct + Math.imul(rr, Cr) | 0, pt = pt + Math.imul(er, $r) | 0, Ge = Ge + Math.imul(er, Ar) | 0, Ge = Ge + Math.imul(Dt, $r) | 0, ct = ct + Math.imul(Dt, Ar) | 0, pt = pt + Math.imul(zt, mr) | 0, Ge = Ge + Math.imul(zt, Tr) | 0, Ge = Ge + Math.imul(Kt, mr) | 0, ct = ct + Math.imul(Kt, Tr) | 0, pt = pt + Math.imul(qt, vr) | 0, Ge = Ge + Math.imul(qt, Rr) | 0, Ge = Ge + Math.imul(Qt, vr) | 0, ct = ct + Math.imul(Qt, Rr) | 0, pt = pt + Math.imul(St, xr) | 0, Ge = Ge + Math.imul(St, tr) | 0, Ge = Ge + Math.imul(At, xr) | 0, ct = ct + Math.imul(At, tr) | 0;
      var pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, pt = Math.imul(jt, Yt), Ge = Math.imul(jt, hr), Ge = Ge + Math.imul(Vt, Yt) | 0, ct = Math.imul(Vt, hr), pt = pt + Math.imul(Bt, cr) | 0, Ge = Ge + Math.imul(Bt, _r) | 0, Ge = Ge + Math.imul(kt, cr) | 0, ct = ct + Math.imul(kt, _r) | 0, pt = pt + Math.imul(dr, br) | 0, Ge = Ge + Math.imul(dr, kr) | 0, Ge = Ge + Math.imul(gr, br) | 0, ct = ct + Math.imul(gr, kr) | 0, pt = pt + Math.imul(or, yr) | 0, Ge = Ge + Math.imul(or, Ir) | 0, Ge = Ge + Math.imul(lr, yr) | 0, ct = ct + Math.imul(lr, Ir) | 0, pt = pt + Math.imul(Jt, wr) | 0, Ge = Ge + Math.imul(Jt, Cr) | 0, Ge = Ge + Math.imul(ir, wr) | 0, ct = ct + Math.imul(ir, Cr) | 0, pt = pt + Math.imul(Gt, $r) | 0, Ge = Ge + Math.imul(Gt, Ar) | 0, Ge = Ge + Math.imul(rr, $r) | 0, ct = ct + Math.imul(rr, Ar) | 0, pt = pt + Math.imul(er, mr) | 0, Ge = Ge + Math.imul(er, Tr) | 0, Ge = Ge + Math.imul(Dt, mr) | 0, ct = ct + Math.imul(Dt, Tr) | 0, pt = pt + Math.imul(zt, vr) | 0, Ge = Ge + Math.imul(zt, Rr) | 0, Ge = Ge + Math.imul(Kt, vr) | 0, ct = ct + Math.imul(Kt, Rr) | 0, pt = pt + Math.imul(qt, xr) | 0, Ge = Ge + Math.imul(qt, tr) | 0, Ge = Ge + Math.imul(Qt, xr) | 0, ct = ct + Math.imul(Qt, tr) | 0, pt = pt + Math.imul(St, fr) | 0, Ge = Ge + Math.imul(St, Mr) | 0, Ge = Ge + Math.imul(At, fr) | 0, ct = ct + Math.imul(At, Mr) | 0;
      var Pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, pt = Math.imul(jt, cr), Ge = Math.imul(jt, _r), Ge = Ge + Math.imul(Vt, cr) | 0, ct = Math.imul(Vt, _r), pt = pt + Math.imul(Bt, br) | 0, Ge = Ge + Math.imul(Bt, kr) | 0, Ge = Ge + Math.imul(kt, br) | 0, ct = ct + Math.imul(kt, kr) | 0, pt = pt + Math.imul(dr, yr) | 0, Ge = Ge + Math.imul(dr, Ir) | 0, Ge = Ge + Math.imul(gr, yr) | 0, ct = ct + Math.imul(gr, Ir) | 0, pt = pt + Math.imul(or, wr) | 0, Ge = Ge + Math.imul(or, Cr) | 0, Ge = Ge + Math.imul(lr, wr) | 0, ct = ct + Math.imul(lr, Cr) | 0, pt = pt + Math.imul(Jt, $r) | 0, Ge = Ge + Math.imul(Jt, Ar) | 0, Ge = Ge + Math.imul(ir, $r) | 0, ct = ct + Math.imul(ir, Ar) | 0, pt = pt + Math.imul(Gt, mr) | 0, Ge = Ge + Math.imul(Gt, Tr) | 0, Ge = Ge + Math.imul(rr, mr) | 0, ct = ct + Math.imul(rr, Tr) | 0, pt = pt + Math.imul(er, vr) | 0, Ge = Ge + Math.imul(er, Rr) | 0, Ge = Ge + Math.imul(Dt, vr) | 0, ct = ct + Math.imul(Dt, Rr) | 0, pt = pt + Math.imul(zt, xr) | 0, Ge = Ge + Math.imul(zt, tr) | 0, Ge = Ge + Math.imul(Kt, xr) | 0, ct = ct + Math.imul(Kt, tr) | 0, pt = pt + Math.imul(qt, fr) | 0, Ge = Ge + Math.imul(qt, Mr) | 0, Ge = Ge + Math.imul(Qt, fr) | 0, ct = ct + Math.imul(Qt, Mr) | 0;
      var Sr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, pt = Math.imul(jt, br), Ge = Math.imul(jt, kr), Ge = Ge + Math.imul(Vt, br) | 0, ct = Math.imul(Vt, kr), pt = pt + Math.imul(Bt, yr) | 0, Ge = Ge + Math.imul(Bt, Ir) | 0, Ge = Ge + Math.imul(kt, yr) | 0, ct = ct + Math.imul(kt, Ir) | 0, pt = pt + Math.imul(dr, wr) | 0, Ge = Ge + Math.imul(dr, Cr) | 0, Ge = Ge + Math.imul(gr, wr) | 0, ct = ct + Math.imul(gr, Cr) | 0, pt = pt + Math.imul(or, $r) | 0, Ge = Ge + Math.imul(or, Ar) | 0, Ge = Ge + Math.imul(lr, $r) | 0, ct = ct + Math.imul(lr, Ar) | 0, pt = pt + Math.imul(Jt, mr) | 0, Ge = Ge + Math.imul(Jt, Tr) | 0, Ge = Ge + Math.imul(ir, mr) | 0, ct = ct + Math.imul(ir, Tr) | 0, pt = pt + Math.imul(Gt, vr) | 0, Ge = Ge + Math.imul(Gt, Rr) | 0, Ge = Ge + Math.imul(rr, vr) | 0, ct = ct + Math.imul(rr, Rr) | 0, pt = pt + Math.imul(er, xr) | 0, Ge = Ge + Math.imul(er, tr) | 0, Ge = Ge + Math.imul(Dt, xr) | 0, ct = ct + Math.imul(Dt, tr) | 0, pt = pt + Math.imul(zt, fr) | 0, Ge = Ge + Math.imul(zt, Mr) | 0, Ge = Ge + Math.imul(Kt, fr) | 0, ct = ct + Math.imul(Kt, Mr) | 0;
      var Ur = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, pt = Math.imul(jt, yr), Ge = Math.imul(jt, Ir), Ge = Ge + Math.imul(Vt, yr) | 0, ct = Math.imul(Vt, Ir), pt = pt + Math.imul(Bt, wr) | 0, Ge = Ge + Math.imul(Bt, Cr) | 0, Ge = Ge + Math.imul(kt, wr) | 0, ct = ct + Math.imul(kt, Cr) | 0, pt = pt + Math.imul(dr, $r) | 0, Ge = Ge + Math.imul(dr, Ar) | 0, Ge = Ge + Math.imul(gr, $r) | 0, ct = ct + Math.imul(gr, Ar) | 0, pt = pt + Math.imul(or, mr) | 0, Ge = Ge + Math.imul(or, Tr) | 0, Ge = Ge + Math.imul(lr, mr) | 0, ct = ct + Math.imul(lr, Tr) | 0, pt = pt + Math.imul(Jt, vr) | 0, Ge = Ge + Math.imul(Jt, Rr) | 0, Ge = Ge + Math.imul(ir, vr) | 0, ct = ct + Math.imul(ir, Rr) | 0, pt = pt + Math.imul(Gt, xr) | 0, Ge = Ge + Math.imul(Gt, tr) | 0, Ge = Ge + Math.imul(rr, xr) | 0, ct = ct + Math.imul(rr, tr) | 0, pt = pt + Math.imul(er, fr) | 0, Ge = Ge + Math.imul(er, Mr) | 0, Ge = Ge + Math.imul(Dt, fr) | 0, ct = ct + Math.imul(Dt, Mr) | 0;
      var jr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, pt = Math.imul(jt, wr), Ge = Math.imul(jt, Cr), Ge = Ge + Math.imul(Vt, wr) | 0, ct = Math.imul(Vt, Cr), pt = pt + Math.imul(Bt, $r) | 0, Ge = Ge + Math.imul(Bt, Ar) | 0, Ge = Ge + Math.imul(kt, $r) | 0, ct = ct + Math.imul(kt, Ar) | 0, pt = pt + Math.imul(dr, mr) | 0, Ge = Ge + Math.imul(dr, Tr) | 0, Ge = Ge + Math.imul(gr, mr) | 0, ct = ct + Math.imul(gr, Tr) | 0, pt = pt + Math.imul(or, vr) | 0, Ge = Ge + Math.imul(or, Rr) | 0, Ge = Ge + Math.imul(lr, vr) | 0, ct = ct + Math.imul(lr, Rr) | 0, pt = pt + Math.imul(Jt, xr) | 0, Ge = Ge + Math.imul(Jt, tr) | 0, Ge = Ge + Math.imul(ir, xr) | 0, ct = ct + Math.imul(ir, tr) | 0, pt = pt + Math.imul(Gt, fr) | 0, Ge = Ge + Math.imul(Gt, Mr) | 0, Ge = Ge + Math.imul(rr, fr) | 0, ct = ct + Math.imul(rr, Mr) | 0;
      var Gr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, pt = Math.imul(jt, $r), Ge = Math.imul(jt, Ar), Ge = Ge + Math.imul(Vt, $r) | 0, ct = Math.imul(Vt, Ar), pt = pt + Math.imul(Bt, mr) | 0, Ge = Ge + Math.imul(Bt, Tr) | 0, Ge = Ge + Math.imul(kt, mr) | 0, ct = ct + Math.imul(kt, Tr) | 0, pt = pt + Math.imul(dr, vr) | 0, Ge = Ge + Math.imul(dr, Rr) | 0, Ge = Ge + Math.imul(gr, vr) | 0, ct = ct + Math.imul(gr, Rr) | 0, pt = pt + Math.imul(or, xr) | 0, Ge = Ge + Math.imul(or, tr) | 0, Ge = Ge + Math.imul(lr, xr) | 0, ct = ct + Math.imul(lr, tr) | 0, pt = pt + Math.imul(Jt, fr) | 0, Ge = Ge + Math.imul(Jt, Mr) | 0, Ge = Ge + Math.imul(ir, fr) | 0, ct = ct + Math.imul(ir, Mr) | 0;
      var Vr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, pt = Math.imul(jt, mr), Ge = Math.imul(jt, Tr), Ge = Ge + Math.imul(Vt, mr) | 0, ct = Math.imul(Vt, Tr), pt = pt + Math.imul(Bt, vr) | 0, Ge = Ge + Math.imul(Bt, Rr) | 0, Ge = Ge + Math.imul(kt, vr) | 0, ct = ct + Math.imul(kt, Rr) | 0, pt = pt + Math.imul(dr, xr) | 0, Ge = Ge + Math.imul(dr, tr) | 0, Ge = Ge + Math.imul(gr, xr) | 0, ct = ct + Math.imul(gr, tr) | 0, pt = pt + Math.imul(or, fr) | 0, Ge = Ge + Math.imul(or, Mr) | 0, Ge = Ge + Math.imul(lr, fr) | 0, ct = ct + Math.imul(lr, Mr) | 0;
      var rn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, pt = Math.imul(jt, vr), Ge = Math.imul(jt, Rr), Ge = Ge + Math.imul(Vt, vr) | 0, ct = Math.imul(Vt, Rr), pt = pt + Math.imul(Bt, xr) | 0, Ge = Ge + Math.imul(Bt, tr) | 0, Ge = Ge + Math.imul(kt, xr) | 0, ct = ct + Math.imul(kt, tr) | 0, pt = pt + Math.imul(dr, fr) | 0, Ge = Ge + Math.imul(dr, Mr) | 0, Ge = Ge + Math.imul(gr, fr) | 0, ct = ct + Math.imul(gr, Mr) | 0;
      var an = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, pt = Math.imul(jt, xr), Ge = Math.imul(jt, tr), Ge = Ge + Math.imul(Vt, xr) | 0, ct = Math.imul(Vt, tr), pt = pt + Math.imul(Bt, fr) | 0, Ge = Ge + Math.imul(Bt, Mr) | 0, Ge = Ge + Math.imul(kt, fr) | 0, ct = ct + Math.imul(kt, Mr) | 0;
      var ln = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, pt = Math.imul(jt, fr), Ge = Math.imul(jt, Mr), Ge = Ge + Math.imul(Vt, fr) | 0, ct = Math.imul(Vt, Mr);
      var sn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      return yt = (ct + (Ge >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, mt[0] = Fr, mt[1] = qr, mt[2] = tn, mt[3] = Qr, mt[4] = nn, mt[5] = Er, mt[6] = Wt, mt[7] = nr, mt[8] = pr, mt[9] = Pr, mt[10] = Sr, mt[11] = Ur, mt[12] = jr, mt[13] = Gr, mt[14] = Vr, mt[15] = rn, mt[16] = an, mt[17] = ln, mt[18] = sn, yt !== 0 && (mt[19] = yt, rt.length++), rt;
    };
    Math.imul || (wt = vt);
    function xt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative, Xe.length = gt.length + We.length;
      for (var rt = 0, ot = 0, ft = 0; ft < Xe.length - 1; ft++) {
        var mt = ot;
        ot = 0;
        for (var yt = rt & 67108863, pt = Math.min(ft, We.length - 1), Ge = Math.max(0, ft - gt.length + 1); Ge <= pt; Ge++) {
          var ct = ft - Ge, Mt = gt.words[ct] | 0, St = We.words[Ge] | 0, At = Mt * St, Nt = At & 67108863;
          mt = mt + (At / 67108864 | 0) | 0, Nt = Nt + yt | 0, yt = Nt & 67108863, mt = mt + (Nt >>> 26) | 0, ot += mt >>> 26, mt &= 67108863;
        }
        Xe.words[ft] = yt, rt = mt, mt = ot;
      }
      return rt !== 0 ? Xe.words[ft] = rt : Xe.length--, Xe.strip();
    }
    function Et(gt, We, Xe) {
      var rt = new Tt();
      return rt.mulp(gt, We, Xe);
    }
    Ve.prototype.mulTo = function(We, Xe) {
      var rt, ot = (this || _global$5).length + We.length;
      return (this || _global$5).length === 10 && We.length === 10 ? rt = wt(this || _global$5, We, Xe) : ot < 63 ? rt = vt(this || _global$5, We, Xe) : ot < 1024 ? rt = xt(this || _global$5, We, Xe) : rt = Et(this || _global$5, We, Xe), rt;
    };
    function Tt(gt, We) {
      (this || _global$5).x = gt, (this || _global$5).y = We;
    }
    Tt.prototype.makeRBT = function(We) {
      for (var Xe = new Array(We), rt = Ve.prototype._countBits(We) - 1, ot = 0; ot < We; ot++)
        Xe[ot] = this.revBin(ot, rt, We);
      return Xe;
    }, Tt.prototype.revBin = function(We, Xe, rt) {
      if (We === 0 || We === rt - 1)
        return We;
      for (var ot = 0, ft = 0; ft < Xe; ft++)
        ot |= (We & 1) << Xe - ft - 1, We >>= 1;
      return ot;
    }, Tt.prototype.permute = function(We, Xe, rt, ot, ft, mt) {
      for (var yt = 0; yt < mt; yt++)
        ot[yt] = Xe[We[yt]], ft[yt] = rt[We[yt]];
    }, Tt.prototype.transform = function(We, Xe, rt, ot, ft, mt) {
      this.permute(mt, We, Xe, rt, ot, ft);
      for (var yt = 1; yt < ft; yt <<= 1)
        for (var pt = yt << 1, Ge = Math.cos(2 * Math.PI / pt), ct = Math.sin(2 * Math.PI / pt), Mt = 0; Mt < ft; Mt += pt)
          for (var St = Ge, At = ct, Nt = 0; Nt < yt; Nt++) {
            var qt = rt[Mt + Nt], Qt = ot[Mt + Nt], Xt = rt[Mt + Nt + yt], zt = ot[Mt + Nt + yt], Kt = St * Xt - At * zt;
            zt = St * zt + At * Xt, Xt = Kt, rt[Mt + Nt] = qt + Xt, ot[Mt + Nt] = Qt + zt, rt[Mt + Nt + yt] = qt - Xt, ot[Mt + Nt + yt] = Qt - zt, Nt !== pt && (Kt = Ge * St - ct * At, At = Ge * At + ct * St, St = Kt);
          }
    }, Tt.prototype.guessLen13b = function(We, Xe) {
      var rt = Math.max(Xe, We) | 1, ot = rt & 1, ft = 0;
      for (rt = rt / 2 | 0; rt; rt = rt >>> 1)
        ft++;
      return 1 << ft + 1 + ot;
    }, Tt.prototype.conjugate = function(We, Xe, rt) {
      if (!(rt <= 1))
        for (var ot = 0; ot < rt / 2; ot++) {
          var ft = We[ot];
          We[ot] = We[rt - ot - 1], We[rt - ot - 1] = ft, ft = Xe[ot], Xe[ot] = -Xe[rt - ot - 1], Xe[rt - ot - 1] = -ft;
        }
    }, Tt.prototype.normalize13b = function(We, Xe) {
      for (var rt = 0, ot = 0; ot < Xe / 2; ot++) {
        var ft = Math.round(We[2 * ot + 1] / Xe) * 8192 + Math.round(We[2 * ot] / Xe) + rt;
        We[ot] = ft & 67108863, ft < 67108864 ? rt = 0 : rt = ft / 67108864 | 0;
      }
      return We;
    }, Tt.prototype.convert13b = function(We, Xe, rt, ot) {
      for (var ft = 0, mt = 0; mt < Xe; mt++)
        ft = ft + (We[mt] | 0), rt[2 * mt] = ft & 8191, ft = ft >>> 13, rt[2 * mt + 1] = ft & 8191, ft = ft >>> 13;
      for (mt = 2 * Xe; mt < ot; ++mt)
        rt[mt] = 0;
      Fe(ft === 0), Fe((ft & -8192) === 0);
    }, Tt.prototype.stub = function(We) {
      for (var Xe = new Array(We), rt = 0; rt < We; rt++)
        Xe[rt] = 0;
      return Xe;
    }, Tt.prototype.mulp = function(We, Xe, rt) {
      var ot = 2 * this.guessLen13b(We.length, Xe.length), ft = this.makeRBT(ot), mt = this.stub(ot), yt = new Array(ot), pt = new Array(ot), Ge = new Array(ot), ct = new Array(ot), Mt = new Array(ot), St = new Array(ot), At = rt.words;
      At.length = ot, this.convert13b(We.words, We.length, yt, ot), this.convert13b(Xe.words, Xe.length, ct, ot), this.transform(yt, mt, pt, Ge, ot, ft), this.transform(ct, mt, Mt, St, ot, ft);
      for (var Nt = 0; Nt < ot; Nt++) {
        var qt = pt[Nt] * Mt[Nt] - Ge[Nt] * St[Nt];
        Ge[Nt] = pt[Nt] * St[Nt] + Ge[Nt] * Mt[Nt], pt[Nt] = qt;
      }
      return this.conjugate(pt, Ge, ot), this.transform(pt, Ge, At, mt, ot, ft), this.conjugate(At, mt, ot), this.normalize13b(At, ot), rt.negative = We.negative ^ Xe.negative, rt.length = We.length + Xe.length, rt.strip();
    }, Ve.prototype.mul = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$5).length + We.length), this.mulTo(We, Xe);
    }, Ve.prototype.mulf = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$5).length + We.length), Et(this || _global$5, We, Xe);
    }, Ve.prototype.imul = function(We) {
      return this.clone().mulTo(We, this || _global$5);
    }, Ve.prototype.imuln = function(We) {
      Fe(typeof We == "number"), Fe(We < 67108864);
      for (var Xe = 0, rt = 0; rt < (this || _global$5).length; rt++) {
        var ot = ((this || _global$5).words[rt] | 0) * We, ft = (ot & 67108863) + (Xe & 67108863);
        Xe >>= 26, Xe += ot / 67108864 | 0, Xe += ft >>> 26, (this || _global$5).words[rt] = ft & 67108863;
      }
      return Xe !== 0 && ((this || _global$5).words[rt] = Xe, (this || _global$5).length++), this || _global$5;
    }, Ve.prototype.muln = function(We) {
      return this.clone().imuln(We);
    }, Ve.prototype.sqr = function() {
      return this.mul(this || _global$5);
    }, Ve.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Ve.prototype.pow = function(We) {
      var Xe = $t(We);
      if (Xe.length === 0)
        return new Ve(1);
      for (var rt = this || _global$5, ot = 0; ot < Xe.length && Xe[ot] === 0; ot++, rt = rt.sqr())
        ;
      if (++ot < Xe.length)
        for (var ft = rt.sqr(); ot < Xe.length; ot++, ft = ft.sqr())
          Xe[ot] !== 0 && (rt = rt.mul(ft));
      return rt;
    }, Ve.prototype.iushln = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 67108863 >>> 26 - Xe << 26 - Xe, ft;
      if (Xe !== 0) {
        var mt = 0;
        for (ft = 0; ft < (this || _global$5).length; ft++) {
          var yt = (this || _global$5).words[ft] & ot, pt = ((this || _global$5).words[ft] | 0) - yt << Xe;
          (this || _global$5).words[ft] = pt | mt, mt = yt >>> 26 - Xe;
        }
        mt && ((this || _global$5).words[ft] = mt, (this || _global$5).length++);
      }
      if (rt !== 0) {
        for (ft = (this || _global$5).length - 1; ft >= 0; ft--)
          (this || _global$5).words[ft + rt] = (this || _global$5).words[ft];
        for (ft = 0; ft < rt; ft++)
          (this || _global$5).words[ft] = 0;
        (this || _global$5).length += rt;
      }
      return this.strip();
    }, Ve.prototype.ishln = function(We) {
      return Fe((this || _global$5).negative === 0), this.iushln(We);
    }, Ve.prototype.iushrn = function(We, Xe, rt) {
      Fe(typeof We == "number" && We >= 0);
      var ot;
      Xe ? ot = (Xe - Xe % 26) / 26 : ot = 0;
      var ft = We % 26, mt = Math.min((We - ft) / 26, (this || _global$5).length), yt = 67108863 ^ 67108863 >>> ft << ft, pt = rt;
      if (ot -= mt, ot = Math.max(0, ot), pt) {
        for (var Ge = 0; Ge < mt; Ge++)
          pt.words[Ge] = (this || _global$5).words[Ge];
        pt.length = mt;
      }
      if (mt !== 0)
        if ((this || _global$5).length > mt)
          for ((this || _global$5).length -= mt, Ge = 0; Ge < (this || _global$5).length; Ge++)
            (this || _global$5).words[Ge] = (this || _global$5).words[Ge + mt];
        else
          (this || _global$5).words[0] = 0, (this || _global$5).length = 1;
      var ct = 0;
      for (Ge = (this || _global$5).length - 1; Ge >= 0 && (ct !== 0 || Ge >= ot); Ge--) {
        var Mt = (this || _global$5).words[Ge] | 0;
        (this || _global$5).words[Ge] = ct << 26 - ft | Mt >>> ft, ct = Mt & yt;
      }
      return pt && ct !== 0 && (pt.words[pt.length++] = ct), (this || _global$5).length === 0 && ((this || _global$5).words[0] = 0, (this || _global$5).length = 1), this.strip();
    }, Ve.prototype.ishrn = function(We, Xe, rt) {
      return Fe((this || _global$5).negative === 0), this.iushrn(We, Xe, rt);
    }, Ve.prototype.shln = function(We) {
      return this.clone().ishln(We);
    }, Ve.prototype.ushln = function(We) {
      return this.clone().iushln(We);
    }, Ve.prototype.shrn = function(We) {
      return this.clone().ishrn(We);
    }, Ve.prototype.ushrn = function(We) {
      return this.clone().iushrn(We);
    }, Ve.prototype.testn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$5).length <= rt)
        return !1;
      var ft = (this || _global$5).words[rt];
      return !!(ft & ot);
    }, Ve.prototype.imaskn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26;
      if (Fe((this || _global$5).negative === 0, "imaskn works only with positive numbers"), (this || _global$5).length <= rt)
        return this || _global$5;
      if (Xe !== 0 && rt++, (this || _global$5).length = Math.min(rt, (this || _global$5).length), Xe !== 0) {
        var ot = 67108863 ^ 67108863 >>> Xe << Xe;
        (this || _global$5).words[(this || _global$5).length - 1] &= ot;
      }
      return this.strip();
    }, Ve.prototype.maskn = function(We) {
      return this.clone().imaskn(We);
    }, Ve.prototype.iaddn = function(We) {
      return Fe(typeof We == "number"), Fe(We < 67108864), We < 0 ? this.isubn(-We) : (this || _global$5).negative !== 0 ? (this || _global$5).length === 1 && ((this || _global$5).words[0] | 0) < We ? ((this || _global$5).words[0] = We - ((this || _global$5).words[0] | 0), (this || _global$5).negative = 0, this || _global$5) : ((this || _global$5).negative = 0, this.isubn(We), (this || _global$5).negative = 1, this || _global$5) : this._iaddn(We);
    }, Ve.prototype._iaddn = function(We) {
      (this || _global$5).words[0] += We;
      for (var Xe = 0; Xe < (this || _global$5).length && (this || _global$5).words[Xe] >= 67108864; Xe++)
        (this || _global$5).words[Xe] -= 67108864, Xe === (this || _global$5).length - 1 ? (this || _global$5).words[Xe + 1] = 1 : (this || _global$5).words[Xe + 1]++;
      return (this || _global$5).length = Math.max((this || _global$5).length, Xe + 1), this || _global$5;
    }, Ve.prototype.isubn = function(We) {
      if (Fe(typeof We == "number"), Fe(We < 67108864), We < 0)
        return this.iaddn(-We);
      if ((this || _global$5).negative !== 0)
        return (this || _global$5).negative = 0, this.iaddn(We), (this || _global$5).negative = 1, this || _global$5;
      if ((this || _global$5).words[0] -= We, (this || _global$5).length === 1 && (this || _global$5).words[0] < 0)
        (this || _global$5).words[0] = -(this || _global$5).words[0], (this || _global$5).negative = 1;
      else
        for (var Xe = 0; Xe < (this || _global$5).length && (this || _global$5).words[Xe] < 0; Xe++)
          (this || _global$5).words[Xe] += 67108864, (this || _global$5).words[Xe + 1] -= 1;
      return this.strip();
    }, Ve.prototype.addn = function(We) {
      return this.clone().iaddn(We);
    }, Ve.prototype.subn = function(We) {
      return this.clone().isubn(We);
    }, Ve.prototype.iabs = function() {
      return (this || _global$5).negative = 0, this || _global$5;
    }, Ve.prototype.abs = function() {
      return this.clone().iabs();
    }, Ve.prototype._ishlnsubmul = function(We, Xe, rt) {
      var ot = We.length + rt, ft;
      this._expand(ot);
      var mt, yt = 0;
      for (ft = 0; ft < We.length; ft++) {
        mt = ((this || _global$5).words[ft + rt] | 0) + yt;
        var pt = (We.words[ft] | 0) * Xe;
        mt -= pt & 67108863, yt = (mt >> 26) - (pt / 67108864 | 0), (this || _global$5).words[ft + rt] = mt & 67108863;
      }
      for (; ft < (this || _global$5).length - rt; ft++)
        mt = ((this || _global$5).words[ft + rt] | 0) + yt, yt = mt >> 26, (this || _global$5).words[ft + rt] = mt & 67108863;
      if (yt === 0)
        return this.strip();
      for (Fe(yt === -1), yt = 0, ft = 0; ft < (this || _global$5).length; ft++)
        mt = -((this || _global$5).words[ft] | 0) + yt, yt = mt >> 26, (this || _global$5).words[ft] = mt & 67108863;
      return (this || _global$5).negative = 1, this.strip();
    }, Ve.prototype._wordDiv = function(We, Xe) {
      var rt = (this || _global$5).length - We.length, ot = this.clone(), ft = We, mt = ft.words[ft.length - 1] | 0, yt = this._countBits(mt);
      rt = 26 - yt, rt !== 0 && (ft = ft.ushln(rt), ot.iushln(rt), mt = ft.words[ft.length - 1] | 0);
      var pt = ot.length - ft.length, Ge;
      if (Xe !== "mod") {
        Ge = new Ve(null), Ge.length = pt + 1, Ge.words = new Array(Ge.length);
        for (var ct = 0; ct < Ge.length; ct++)
          Ge.words[ct] = 0;
      }
      var Mt = ot.clone()._ishlnsubmul(ft, 1, pt);
      Mt.negative === 0 && (ot = Mt, Ge && (Ge.words[pt] = 1));
      for (var St = pt - 1; St >= 0; St--) {
        var At = (ot.words[ft.length + St] | 0) * 67108864 + (ot.words[ft.length + St - 1] | 0);
        for (At = Math.min(At / mt | 0, 67108863), ot._ishlnsubmul(ft, At, St); ot.negative !== 0; )
          At--, ot.negative = 0, ot._ishlnsubmul(ft, 1, St), ot.isZero() || (ot.negative ^= 1);
        Ge && (Ge.words[St] = At);
      }
      return Ge && Ge.strip(), ot.strip(), Xe !== "div" && rt !== 0 && ot.iushrn(rt), {
        div: Ge || null,
        mod: ot
      };
    }, Ve.prototype.divmod = function(We, Xe, rt) {
      if (Fe(!We.isZero()), this.isZero())
        return {
          div: new Ve(0),
          mod: new Ve(0)
        };
      var ot, ft, mt;
      return (this || _global$5).negative !== 0 && We.negative === 0 ? (mt = this.neg().divmod(We, Xe), Xe !== "mod" && (ot = mt.div.neg()), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.iadd(We)), {
        div: ot,
        mod: ft
      }) : (this || _global$5).negative === 0 && We.negative !== 0 ? (mt = this.divmod(We.neg(), Xe), Xe !== "mod" && (ot = mt.div.neg()), {
        div: ot,
        mod: mt.mod
      }) : (this || _global$5).negative & We.negative ? (mt = this.neg().divmod(We.neg(), Xe), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.isub(We)), {
        div: mt.div,
        mod: ft
      }) : We.length > (this || _global$5).length || this.cmp(We) < 0 ? {
        div: new Ve(0),
        mod: this || _global$5
      } : We.length === 1 ? Xe === "div" ? {
        div: this.divn(We.words[0]),
        mod: null
      } : Xe === "mod" ? {
        div: null,
        mod: new Ve(this.modn(We.words[0]))
      } : {
        div: this.divn(We.words[0]),
        mod: new Ve(this.modn(We.words[0]))
      } : this._wordDiv(We, Xe);
    }, Ve.prototype.div = function(We) {
      return this.divmod(We, "div", !1).div;
    }, Ve.prototype.mod = function(We) {
      return this.divmod(We, "mod", !1).mod;
    }, Ve.prototype.umod = function(We) {
      return this.divmod(We, "mod", !0).mod;
    }, Ve.prototype.divRound = function(We) {
      var Xe = this.divmod(We);
      if (Xe.mod.isZero())
        return Xe.div;
      var rt = Xe.div.negative !== 0 ? Xe.mod.isub(We) : Xe.mod, ot = We.ushrn(1), ft = We.andln(1), mt = rt.cmp(ot);
      return mt < 0 || ft === 1 && mt === 0 ? Xe.div : Xe.div.negative !== 0 ? Xe.div.isubn(1) : Xe.div.iaddn(1);
    }, Ve.prototype.modn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = (1 << 26) % We, rt = 0, ot = (this || _global$5).length - 1; ot >= 0; ot--)
        rt = (Xe * rt + ((this || _global$5).words[ot] | 0)) % We;
      return rt;
    }, Ve.prototype.idivn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = 0, rt = (this || _global$5).length - 1; rt >= 0; rt--) {
        var ot = ((this || _global$5).words[rt] | 0) + Xe * 67108864;
        (this || _global$5).words[rt] = ot / We | 0, Xe = ot % We;
      }
      return this.strip();
    }, Ve.prototype.divn = function(We) {
      return this.clone().idivn(We);
    }, Ve.prototype.egcd = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$5, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = new Ve(0), yt = new Ve(1), pt = 0; Xe.isEven() && rt.isEven(); )
        Xe.iushrn(1), rt.iushrn(1), ++pt;
      for (var Ge = rt.clone(), ct = Xe.clone(); !Xe.isZero(); ) {
        for (var Mt = 0, St = 1; !(Xe.words[0] & St) && Mt < 26; ++Mt, St <<= 1)
          ;
        if (Mt > 0)
          for (Xe.iushrn(Mt); Mt-- > 0; )
            (ot.isOdd() || ft.isOdd()) && (ot.iadd(Ge), ft.isub(ct)), ot.iushrn(1), ft.iushrn(1);
        for (var At = 0, Nt = 1; !(rt.words[0] & Nt) && At < 26; ++At, Nt <<= 1)
          ;
        if (At > 0)
          for (rt.iushrn(At); At-- > 0; )
            (mt.isOdd() || yt.isOdd()) && (mt.iadd(Ge), yt.isub(ct)), mt.iushrn(1), yt.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(mt), ft.isub(yt)) : (rt.isub(Xe), mt.isub(ot), yt.isub(ft));
      }
      return {
        a: mt,
        b: yt,
        gcd: rt.iushln(pt)
      };
    }, Ve.prototype._invmp = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$5, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = rt.clone(); Xe.cmpn(1) > 0 && rt.cmpn(1) > 0; ) {
        for (var yt = 0, pt = 1; !(Xe.words[0] & pt) && yt < 26; ++yt, pt <<= 1)
          ;
        if (yt > 0)
          for (Xe.iushrn(yt); yt-- > 0; )
            ot.isOdd() && ot.iadd(mt), ot.iushrn(1);
        for (var Ge = 0, ct = 1; !(rt.words[0] & ct) && Ge < 26; ++Ge, ct <<= 1)
          ;
        if (Ge > 0)
          for (rt.iushrn(Ge); Ge-- > 0; )
            ft.isOdd() && ft.iadd(mt), ft.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(ft)) : (rt.isub(Xe), ft.isub(ot));
      }
      var Mt;
      return Xe.cmpn(1) === 0 ? Mt = ot : Mt = ft, Mt.cmpn(0) < 0 && Mt.iadd(We), Mt;
    }, Ve.prototype.gcd = function(We) {
      if (this.isZero())
        return We.abs();
      if (We.isZero())
        return this.abs();
      var Xe = this.clone(), rt = We.clone();
      Xe.negative = 0, rt.negative = 0;
      for (var ot = 0; Xe.isEven() && rt.isEven(); ot++)
        Xe.iushrn(1), rt.iushrn(1);
      do {
        for (; Xe.isEven(); )
          Xe.iushrn(1);
        for (; rt.isEven(); )
          rt.iushrn(1);
        var ft = Xe.cmp(rt);
        if (ft < 0) {
          var mt = Xe;
          Xe = rt, rt = mt;
        } else if (ft === 0 || rt.cmpn(1) === 0)
          break;
        Xe.isub(rt);
      } while (!0);
      return rt.iushln(ot);
    }, Ve.prototype.invm = function(We) {
      return this.egcd(We).a.umod(We);
    }, Ve.prototype.isEven = function() {
      return ((this || _global$5).words[0] & 1) === 0;
    }, Ve.prototype.isOdd = function() {
      return ((this || _global$5).words[0] & 1) === 1;
    }, Ve.prototype.andln = function(We) {
      return (this || _global$5).words[0] & We;
    }, Ve.prototype.bincn = function(We) {
      Fe(typeof We == "number");
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$5).length <= rt)
        return this._expand(rt + 1), (this || _global$5).words[rt] |= ot, this || _global$5;
      for (var ft = ot, mt = rt; ft !== 0 && mt < (this || _global$5).length; mt++) {
        var yt = (this || _global$5).words[mt] | 0;
        yt += ft, ft = yt >>> 26, yt &= 67108863, (this || _global$5).words[mt] = yt;
      }
      return ft !== 0 && ((this || _global$5).words[mt] = ft, (this || _global$5).length++), this || _global$5;
    }, Ve.prototype.isZero = function() {
      return (this || _global$5).length === 1 && (this || _global$5).words[0] === 0;
    }, Ve.prototype.cmpn = function(We) {
      var Xe = We < 0;
      if ((this || _global$5).negative !== 0 && !Xe)
        return -1;
      if ((this || _global$5).negative === 0 && Xe)
        return 1;
      this.strip();
      var rt;
      if ((this || _global$5).length > 1)
        rt = 1;
      else {
        Xe && (We = -We), Fe(We <= 67108863, "Number is too big");
        var ot = (this || _global$5).words[0] | 0;
        rt = ot === We ? 0 : ot < We ? -1 : 1;
      }
      return (this || _global$5).negative !== 0 ? -rt | 0 : rt;
    }, Ve.prototype.cmp = function(We) {
      if ((this || _global$5).negative !== 0 && We.negative === 0)
        return -1;
      if ((this || _global$5).negative === 0 && We.negative !== 0)
        return 1;
      var Xe = this.ucmp(We);
      return (this || _global$5).negative !== 0 ? -Xe | 0 : Xe;
    }, Ve.prototype.ucmp = function(We) {
      if ((this || _global$5).length > We.length)
        return 1;
      if ((this || _global$5).length < We.length)
        return -1;
      for (var Xe = 0, rt = (this || _global$5).length - 1; rt >= 0; rt--) {
        var ot = (this || _global$5).words[rt] | 0, ft = We.words[rt] | 0;
        if (ot !== ft) {
          ot < ft ? Xe = -1 : ot > ft && (Xe = 1);
          break;
        }
      }
      return Xe;
    }, Ve.prototype.gtn = function(We) {
      return this.cmpn(We) === 1;
    }, Ve.prototype.gt = function(We) {
      return this.cmp(We) === 1;
    }, Ve.prototype.gten = function(We) {
      return this.cmpn(We) >= 0;
    }, Ve.prototype.gte = function(We) {
      return this.cmp(We) >= 0;
    }, Ve.prototype.ltn = function(We) {
      return this.cmpn(We) === -1;
    }, Ve.prototype.lt = function(We) {
      return this.cmp(We) === -1;
    }, Ve.prototype.lten = function(We) {
      return this.cmpn(We) <= 0;
    }, Ve.prototype.lte = function(We) {
      return this.cmp(We) <= 0;
    }, Ve.prototype.eqn = function(We) {
      return this.cmpn(We) === 0;
    }, Ve.prototype.eq = function(We) {
      return this.cmp(We) === 0;
    }, Ve.red = function(We) {
      return new Ot(We);
    }, Ve.prototype.toRed = function(We) {
      return Fe(!(this || _global$5).red, "Already a number in reduction context"), Fe((this || _global$5).negative === 0, "red works only with positives"), We.convertTo(this || _global$5)._forceRed(We);
    }, Ve.prototype.fromRed = function() {
      return Fe((this || _global$5).red, "fromRed works only with numbers in reduction context"), (this || _global$5).red.convertFrom(this || _global$5);
    }, Ve.prototype._forceRed = function(We) {
      return (this || _global$5).red = We, this || _global$5;
    }, Ve.prototype.forceRed = function(We) {
      return Fe(!(this || _global$5).red, "Already a number in reduction context"), this._forceRed(We);
    }, Ve.prototype.redAdd = function(We) {
      return Fe((this || _global$5).red, "redAdd works only with red numbers"), (this || _global$5).red.add(this || _global$5, We);
    }, Ve.prototype.redIAdd = function(We) {
      return Fe((this || _global$5).red, "redIAdd works only with red numbers"), (this || _global$5).red.iadd(this || _global$5, We);
    }, Ve.prototype.redSub = function(We) {
      return Fe((this || _global$5).red, "redSub works only with red numbers"), (this || _global$5).red.sub(this || _global$5, We);
    }, Ve.prototype.redISub = function(We) {
      return Fe((this || _global$5).red, "redISub works only with red numbers"), (this || _global$5).red.isub(this || _global$5, We);
    }, Ve.prototype.redShl = function(We) {
      return Fe((this || _global$5).red, "redShl works only with red numbers"), (this || _global$5).red.shl(this || _global$5, We);
    }, Ve.prototype.redMul = function(We) {
      return Fe((this || _global$5).red, "redMul works only with red numbers"), (this || _global$5).red._verify2(this || _global$5, We), (this || _global$5).red.mul(this || _global$5, We);
    }, Ve.prototype.redIMul = function(We) {
      return Fe((this || _global$5).red, "redMul works only with red numbers"), (this || _global$5).red._verify2(this || _global$5, We), (this || _global$5).red.imul(this || _global$5, We);
    }, Ve.prototype.redSqr = function() {
      return Fe((this || _global$5).red, "redSqr works only with red numbers"), (this || _global$5).red._verify1(this || _global$5), (this || _global$5).red.sqr(this || _global$5);
    }, Ve.prototype.redISqr = function() {
      return Fe((this || _global$5).red, "redISqr works only with red numbers"), (this || _global$5).red._verify1(this || _global$5), (this || _global$5).red.isqr(this || _global$5);
    }, Ve.prototype.redSqrt = function() {
      return Fe((this || _global$5).red, "redSqrt works only with red numbers"), (this || _global$5).red._verify1(this || _global$5), (this || _global$5).red.sqrt(this || _global$5);
    }, Ve.prototype.redInvm = function() {
      return Fe((this || _global$5).red, "redInvm works only with red numbers"), (this || _global$5).red._verify1(this || _global$5), (this || _global$5).red.invm(this || _global$5);
    }, Ve.prototype.redNeg = function() {
      return Fe((this || _global$5).red, "redNeg works only with red numbers"), (this || _global$5).red._verify1(this || _global$5), (this || _global$5).red.neg(this || _global$5);
    }, Ve.prototype.redPow = function(We) {
      return Fe((this || _global$5).red && !We.red, "redPow(normalNum)"), (this || _global$5).red._verify1(this || _global$5), (this || _global$5).red.pow(this || _global$5, We);
    };
    var Rt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ct(gt, We) {
      (this || _global$5).name = gt, (this || _global$5).p = new Ve(We, 16), (this || _global$5).n = (this || _global$5).p.bitLength(), (this || _global$5).k = new Ve(1).iushln((this || _global$5).n).isub((this || _global$5).p), (this || _global$5).tmp = this._tmp();
    }
    Ct.prototype._tmp = function() {
      var We = new Ve(null);
      return We.words = new Array(Math.ceil((this || _global$5).n / 13)), We;
    }, Ct.prototype.ireduce = function(We) {
      var Xe = We, rt;
      do
        this.split(Xe, (this || _global$5).tmp), Xe = this.imulK(Xe), Xe = Xe.iadd((this || _global$5).tmp), rt = Xe.bitLength();
      while (rt > (this || _global$5).n);
      var ot = rt < (this || _global$5).n ? -1 : Xe.ucmp((this || _global$5).p);
      return ot === 0 ? (Xe.words[0] = 0, Xe.length = 1) : ot > 0 ? Xe.isub((this || _global$5).p) : Xe.strip !== void 0 ? Xe.strip() : Xe._strip(), Xe;
    }, Ct.prototype.split = function(We, Xe) {
      We.iushrn((this || _global$5).n, 0, Xe);
    }, Ct.prototype.imulK = function(We) {
      return We.imul((this || _global$5).k);
    };
    function Zt() {
      Ct.call(this || _global$5, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    Ke(Zt, Ct), Zt.prototype.split = function(We, Xe) {
      for (var rt = 4194303, ot = Math.min(We.length, 9), ft = 0; ft < ot; ft++)
        Xe.words[ft] = We.words[ft];
      if (Xe.length = ot, We.length <= 9) {
        We.words[0] = 0, We.length = 1;
        return;
      }
      var mt = We.words[9];
      for (Xe.words[Xe.length++] = mt & rt, ft = 10; ft < We.length; ft++) {
        var yt = We.words[ft] | 0;
        We.words[ft - 10] = (yt & rt) << 4 | mt >>> 22, mt = yt;
      }
      mt >>>= 22, We.words[ft - 10] = mt, mt === 0 && We.length > 10 ? We.length -= 10 : We.length -= 9;
    }, Zt.prototype.imulK = function(We) {
      We.words[We.length] = 0, We.words[We.length + 1] = 0, We.length += 2;
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = We.words[rt] | 0;
        Xe += ot * 977, We.words[rt] = Xe & 67108863, Xe = ot * 64 + (Xe / 67108864 | 0);
      }
      return We.words[We.length - 1] === 0 && (We.length--, We.words[We.length - 1] === 0 && We.length--), We;
    };
    function Lt() {
      Ct.call(this || _global$5, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    Ke(Lt, Ct);
    function Ut() {
      Ct.call(this || _global$5, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    Ke(Ut, Ct);
    function Pt() {
      Ct.call(this || _global$5, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    Ke(Pt, Ct), Pt.prototype.imulK = function(We) {
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = (We.words[rt] | 0) * 19 + Xe, ft = ot & 67108863;
        ot >>>= 26, We.words[rt] = ft, Xe = ot;
      }
      return Xe !== 0 && (We.words[We.length++] = Xe), We;
    }, Ve._prime = function(We) {
      if (Rt[We])
        return Rt[We];
      var Xe;
      if (We === "k256")
        Xe = new Zt();
      else if (We === "p224")
        Xe = new Lt();
      else if (We === "p192")
        Xe = new Ut();
      else if (We === "p25519")
        Xe = new Pt();
      else
        throw new Error("Unknown prime " + We);
      return Rt[We] = Xe, Xe;
    };
    function Ot(gt) {
      if (typeof gt == "string") {
        var We = Ve._prime(gt);
        (this || _global$5).m = We.p, (this || _global$5).prime = We;
      } else
        Fe(gt.gtn(1), "modulus must be greater than 1"), (this || _global$5).m = gt, (this || _global$5).prime = null;
    }
    Ot.prototype._verify1 = function(We) {
      Fe(We.negative === 0, "red works only with positives"), Fe(We.red, "red works only with red numbers");
    }, Ot.prototype._verify2 = function(We, Xe) {
      Fe((We.negative | Xe.negative) === 0, "red works only with positives"), Fe(We.red && We.red === Xe.red, "red works only with red numbers");
    }, Ot.prototype.imod = function(We) {
      return (this || _global$5).prime ? (this || _global$5).prime.ireduce(We)._forceRed(this || _global$5) : We.umod((this || _global$5).m)._forceRed(this || _global$5);
    }, Ot.prototype.neg = function(We) {
      return We.isZero() ? We.clone() : (this || _global$5).m.sub(We)._forceRed(this || _global$5);
    }, Ot.prototype.add = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.add(Xe);
      return rt.cmp((this || _global$5).m) >= 0 && rt.isub((this || _global$5).m), rt._forceRed(this || _global$5);
    }, Ot.prototype.iadd = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.iadd(Xe);
      return rt.cmp((this || _global$5).m) >= 0 && rt.isub((this || _global$5).m), rt;
    }, Ot.prototype.sub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.sub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$5).m), rt._forceRed(this || _global$5);
    }, Ot.prototype.isub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.isub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$5).m), rt;
    }, Ot.prototype.shl = function(We, Xe) {
      return this._verify1(We), this.imod(We.ushln(Xe));
    }, Ot.prototype.imul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.imul(Xe));
    }, Ot.prototype.mul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.mul(Xe));
    }, Ot.prototype.isqr = function(We) {
      return this.imul(We, We.clone());
    }, Ot.prototype.sqr = function(We) {
      return this.mul(We, We);
    }, Ot.prototype.sqrt = function(We) {
      if (We.isZero())
        return We.clone();
      var Xe = (this || _global$5).m.andln(3);
      if (Fe(Xe % 2 === 1), Xe === 3) {
        var rt = (this || _global$5).m.add(new Ve(1)).iushrn(2);
        return this.pow(We, rt);
      }
      for (var ot = (this || _global$5).m.subn(1), ft = 0; !ot.isZero() && ot.andln(1) === 0; )
        ft++, ot.iushrn(1);
      Fe(!ot.isZero());
      var mt = new Ve(1).toRed(this || _global$5), yt = mt.redNeg(), pt = (this || _global$5).m.subn(1).iushrn(1), Ge = (this || _global$5).m.bitLength();
      for (Ge = new Ve(2 * Ge * Ge).toRed(this || _global$5); this.pow(Ge, pt).cmp(yt) !== 0; )
        Ge.redIAdd(yt);
      for (var ct = this.pow(Ge, ot), Mt = this.pow(We, ot.addn(1).iushrn(1)), St = this.pow(We, ot), At = ft; St.cmp(mt) !== 0; ) {
        for (var Nt = St, qt = 0; Nt.cmp(mt) !== 0; qt++)
          Nt = Nt.redSqr();
        Fe(qt < At);
        var Qt = this.pow(ct, new Ve(1).iushln(At - qt - 1));
        Mt = Mt.redMul(Qt), ct = Qt.redSqr(), St = St.redMul(ct), At = qt;
      }
      return Mt;
    }, Ot.prototype.invm = function(We) {
      var Xe = We._invmp((this || _global$5).m);
      return Xe.negative !== 0 ? (Xe.negative = 0, this.imod(Xe).redNeg()) : this.imod(Xe);
    }, Ot.prototype.pow = function(We, Xe) {
      if (Xe.isZero())
        return new Ve(1).toRed(this || _global$5);
      if (Xe.cmpn(1) === 0)
        return We.clone();
      var rt = 4, ot = new Array(1 << rt);
      ot[0] = new Ve(1).toRed(this || _global$5), ot[1] = We;
      for (var ft = 2; ft < ot.length; ft++)
        ot[ft] = this.mul(ot[ft - 1], We);
      var mt = ot[0], yt = 0, pt = 0, Ge = Xe.bitLength() % 26;
      for (Ge === 0 && (Ge = 26), ft = Xe.length - 1; ft >= 0; ft--) {
        for (var ct = Xe.words[ft], Mt = Ge - 1; Mt >= 0; Mt--) {
          var St = ct >> Mt & 1;
          if (mt !== ot[0] && (mt = this.sqr(mt)), St === 0 && yt === 0) {
            pt = 0;
            continue;
          }
          yt <<= 1, yt |= St, pt++, !(pt !== rt && (ft !== 0 || Mt !== 0)) && (mt = this.mul(mt, ot[yt]), pt = 0, yt = 0);
        }
        Ge = 26;
      }
      return mt;
    }, Ot.prototype.convertTo = function(We) {
      var Xe = We.umod((this || _global$5).m);
      return Xe === We ? Xe.clone() : Xe;
    }, Ot.prototype.convertFrom = function(We) {
      var Xe = We.clone();
      return Xe.red = null, Xe;
    }, Ve.mont = function(We) {
      return new Ft(We);
    };
    function Ft(gt) {
      Ot.call(this || _global$5, gt), (this || _global$5).shift = (this || _global$5).m.bitLength(), (this || _global$5).shift % 26 !== 0 && ((this || _global$5).shift += 26 - (this || _global$5).shift % 26), (this || _global$5).r = new Ve(1).iushln((this || _global$5).shift), (this || _global$5).r2 = this.imod((this || _global$5).r.sqr()), (this || _global$5).rinv = (this || _global$5).r._invmp((this || _global$5).m), (this || _global$5).minv = (this || _global$5).rinv.mul((this || _global$5).r).isubn(1).div((this || _global$5).m), (this || _global$5).minv = (this || _global$5).minv.umod((this || _global$5).r), (this || _global$5).minv = (this || _global$5).r.sub((this || _global$5).minv);
    }
    Ke(Ft, Ot), Ft.prototype.convertTo = function(We) {
      return this.imod(We.ushln((this || _global$5).shift));
    }, Ft.prototype.convertFrom = function(We) {
      var Xe = this.imod(We.mul((this || _global$5).rinv));
      return Xe.red = null, Xe;
    }, Ft.prototype.imul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return We.words[0] = 0, We.length = 1, We;
      var rt = We.imul(Xe), ot = rt.maskn((this || _global$5).shift).mul((this || _global$5).minv).imaskn((this || _global$5).shift).mul((this || _global$5).m), ft = rt.isub(ot).iushrn((this || _global$5).shift), mt = ft;
      return ft.cmp((this || _global$5).m) >= 0 ? mt = ft.isub((this || _global$5).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$5).m)), mt._forceRed(this || _global$5);
    }, Ft.prototype.mul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return new Ve(0)._forceRed(this || _global$5);
      var rt = We.mul(Xe), ot = rt.maskn((this || _global$5).shift).mul((this || _global$5).minv).imaskn((this || _global$5).shift).mul((this || _global$5).m), ft = rt.isub(ot).iushrn((this || _global$5).shift), mt = ft;
      return ft.cmp((this || _global$5).m) >= 0 ? mt = ft.isub((this || _global$5).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$5).m)), mt._forceRed(this || _global$5);
    }, Ft.prototype.invm = function(We) {
      var Xe = this.imod(We._invmp((this || _global$5).m).mul((this || _global$5).r2));
      return Xe._forceRed(this || _global$5);
    };
  }(module$2, exports$y)), module$2.exports;
}
var exports$x = {}, _dewExec$w = !1;
function dew$w() {
  if (_dewExec$w)
    return exports$x;
  _dewExec$w = !0;
  var $e = process2, Ze = buffer, Fe = Ze.Buffer, Ke = {}, Ve;
  for (Ve in Ze)
    Ze.hasOwnProperty(Ve) && (Ve === "SlowBuffer" || Ve === "Buffer" || (Ke[Ve] = Ze[Ve]));
  var Je = Ke.Buffer = {};
  for (Ve in Fe)
    Fe.hasOwnProperty(Ve) && (Ve === "allocUnsafe" || Ve === "allocUnsafeSlow" || (Je[Ve] = Fe[Ve]));
  if (Ke.Buffer.prototype = Fe.prototype, (!Je.from || Je.from === Uint8Array.from) && (Je.from = function(Qe, at, ut) {
    if (typeof Qe == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof Qe);
    if (Qe && typeof Qe.length > "u")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Qe);
    return Fe(Qe, at, ut);
  }), Je.alloc || (Je.alloc = function(Qe, at, ut) {
    if (typeof Qe != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof Qe);
    if (Qe < 0 || Qe >= 2 * (1 << 30))
      throw new RangeError('The value "' + Qe + '" is invalid for option "size"');
    var lt = Fe(Qe);
    return !at || at.length === 0 ? lt.fill(0) : typeof ut == "string" ? lt.fill(at, ut) : lt.fill(at), lt;
  }), !Ke.kStringMaxLength)
    try {
      Ke.kStringMaxLength = $e.binding("buffer").kStringMaxLength;
    } catch {
    }
  return Ke.constants || (Ke.constants = {
    MAX_LENGTH: Ke.kMaxLength
  }, Ke.kStringMaxLength && (Ke.constants.MAX_STRING_LENGTH = Ke.kStringMaxLength)), exports$x = Ke, exports$x;
}
var exports$w = {}, _dewExec$v = !1;
function dew$v() {
  if (_dewExec$v)
    return exports$w;
  _dewExec$v = !0;
  const $e = dew$f();
  function Ze(Ke) {
    this._reporterState = {
      obj: null,
      path: [],
      options: Ke || {},
      errors: []
    };
  }
  exports$w.Reporter = Ze, Ze.prototype.isError = function(Ve) {
    return Ve instanceof Fe;
  }, Ze.prototype.save = function() {
    const Ve = this._reporterState;
    return {
      obj: Ve.obj,
      pathLen: Ve.path.length
    };
  }, Ze.prototype.restore = function(Ve) {
    const Je = this._reporterState;
    Je.obj = Ve.obj, Je.path = Je.path.slice(0, Ve.pathLen);
  }, Ze.prototype.enterKey = function(Ve) {
    return this._reporterState.path.push(Ve);
  }, Ze.prototype.exitKey = function(Ve) {
    const Je = this._reporterState;
    Je.path = Je.path.slice(0, Ve - 1);
  }, Ze.prototype.leaveKey = function(Ve, Je, Qe) {
    const at = this._reporterState;
    this.exitKey(Ve), at.obj !== null && (at.obj[Je] = Qe);
  }, Ze.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, Ze.prototype.enterObject = function() {
    const Ve = this._reporterState, Je = Ve.obj;
    return Ve.obj = {}, Je;
  }, Ze.prototype.leaveObject = function(Ve) {
    const Je = this._reporterState, Qe = Je.obj;
    return Je.obj = Ve, Qe;
  }, Ze.prototype.error = function(Ve) {
    let Je;
    const Qe = this._reporterState, at = Ve instanceof Fe;
    if (at ? Je = Ve : Je = new Fe(Qe.path.map(function(ut) {
      return "[" + JSON.stringify(ut) + "]";
    }).join(""), Ve.message || Ve, Ve.stack), !Qe.options.partial)
      throw Je;
    return at || Qe.errors.push(Je), Je;
  }, Ze.prototype.wrapResult = function(Ve) {
    const Je = this._reporterState;
    return Je.options.partial ? {
      result: this.isError(Ve) ? null : Ve,
      errors: Je.errors
    } : Ve;
  };
  function Fe(Ke, Ve) {
    this.path = Ke, this.rethrow(Ve);
  }
  return $e(Fe, Error), Fe.prototype.rethrow = function(Ve) {
    if (this.message = Ve + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, Fe), !this.stack)
      try {
        throw new Error(this.message);
      } catch (Je) {
        this.stack = Je.stack;
      }
    return this;
  }, exports$w;
}
var exports$v = {}, _dewExec$u = !1;
function dew$u() {
  if (_dewExec$u)
    return exports$v;
  _dewExec$u = !0;
  const $e = dew$f(), Ze = dew$v().Reporter, Fe = dew$w().Buffer;
  function Ke(Je, Qe) {
    if (Ze.call(this, Qe), !Fe.isBuffer(Je)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = Je, this.offset = 0, this.length = Je.length;
  }
  $e(Ke, Ze), exports$v.DecoderBuffer = Ke, Ke.isDecoderBuffer = function(Qe) {
    return Qe instanceof Ke ? !0 : typeof Qe == "object" && Fe.isBuffer(Qe.base) && Qe.constructor.name === "DecoderBuffer" && typeof Qe.offset == "number" && typeof Qe.length == "number" && typeof Qe.save == "function" && typeof Qe.restore == "function" && typeof Qe.isEmpty == "function" && typeof Qe.readUInt8 == "function" && typeof Qe.skip == "function" && typeof Qe.raw == "function";
  }, Ke.prototype.save = function() {
    return {
      offset: this.offset,
      reporter: Ze.prototype.save.call(this)
    };
  }, Ke.prototype.restore = function(Qe) {
    const at = new Ke(this.base);
    return at.offset = Qe.offset, at.length = this.offset, this.offset = Qe.offset, Ze.prototype.restore.call(this, Qe.reporter), at;
  }, Ke.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, Ke.prototype.readUInt8 = function(Qe) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(Qe || "DecoderBuffer overrun");
  }, Ke.prototype.skip = function(Qe, at) {
    if (!(this.offset + Qe <= this.length))
      return this.error(at || "DecoderBuffer overrun");
    const ut = new Ke(this.base);
    return ut._reporterState = this._reporterState, ut.offset = this.offset, ut.length = this.offset + Qe, this.offset += Qe, ut;
  }, Ke.prototype.raw = function(Qe) {
    return this.base.slice(Qe ? Qe.offset : this.offset, this.length);
  };
  function Ve(Je, Qe) {
    if (Array.isArray(Je))
      this.length = 0, this.value = Je.map(function(at) {
        return Ve.isEncoderBuffer(at) || (at = new Ve(at, Qe)), this.length += at.length, at;
      }, this);
    else if (typeof Je == "number") {
      if (!(0 <= Je && Je <= 255))
        return Qe.error("non-byte EncoderBuffer value");
      this.value = Je, this.length = 1;
    } else if (typeof Je == "string")
      this.value = Je, this.length = Fe.byteLength(Je);
    else if (Fe.isBuffer(Je))
      this.value = Je, this.length = Je.length;
    else
      return Qe.error("Unsupported type: " + typeof Je);
  }
  return exports$v.EncoderBuffer = Ve, Ve.isEncoderBuffer = function(Qe) {
    return Qe instanceof Ve ? !0 : typeof Qe == "object" && Qe.constructor.name === "EncoderBuffer" && typeof Qe.length == "number" && typeof Qe.join == "function";
  }, Ve.prototype.join = function(Qe, at) {
    return Qe || (Qe = Fe.alloc(this.length)), at || (at = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(ut) {
      ut.join(Qe, at), at += ut.length;
    }) : (typeof this.value == "number" ? Qe[at] = this.value : typeof this.value == "string" ? Qe.write(this.value, at) : Fe.isBuffer(this.value) && this.value.copy(Qe, at), at += this.length)), Qe;
  }, exports$v;
}
var exports$u = {}, _dewExec$t = !1;
function dew$t() {
  if (_dewExec$t)
    return exports$u;
  _dewExec$t = !0;
  const $e = dew$v().Reporter, Ze = dew$u().EncoderBuffer, Fe = dew$u().DecoderBuffer, Ke = dew$2m(), Ve = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], Je = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(Ve), Qe = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
  function at(lt, dt, bt) {
    const $t = {};
    this._baseState = $t, $t.name = bt, $t.enc = lt, $t.parent = dt || null, $t.children = null, $t.tag = null, $t.args = null, $t.reverseArgs = null, $t.choice = null, $t.optional = !1, $t.any = !1, $t.obj = !1, $t.use = null, $t.useDecoder = null, $t.key = null, $t.default = null, $t.explicit = null, $t.implicit = null, $t.contains = null, $t.parent || ($t.children = [], this._wrap());
  }
  exports$u = at;
  const ut = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
  return at.prototype.clone = function() {
    const dt = this._baseState, bt = {};
    ut.forEach(function(vt) {
      bt[vt] = dt[vt];
    });
    const $t = new this.constructor(bt.parent);
    return $t._baseState = bt, $t;
  }, at.prototype._wrap = function() {
    const dt = this._baseState;
    Je.forEach(function(bt) {
      this[bt] = function() {
        const vt = new this.constructor(this);
        return dt.children.push(vt), vt[bt].apply(vt, arguments);
      };
    }, this);
  }, at.prototype._init = function(dt) {
    const bt = this._baseState;
    Ke(bt.parent === null), dt.call(this), bt.children = bt.children.filter(function($t) {
      return $t._baseState.parent === this;
    }, this), Ke.equal(bt.children.length, 1, "Root node can have only one child");
  }, at.prototype._useArgs = function(dt) {
    const bt = this._baseState, $t = dt.filter(function(vt) {
      return vt instanceof this.constructor;
    }, this);
    dt = dt.filter(function(vt) {
      return !(vt instanceof this.constructor);
    }, this), $t.length !== 0 && (Ke(bt.children === null), bt.children = $t, $t.forEach(function(vt) {
      vt._baseState.parent = this;
    }, this)), dt.length !== 0 && (Ke(bt.args === null), bt.args = dt, bt.reverseArgs = dt.map(function(vt) {
      if (typeof vt != "object" || vt.constructor !== Object)
        return vt;
      const wt = {};
      return Object.keys(vt).forEach(function(xt) {
        xt == (xt | 0) && (xt |= 0);
        const Et = vt[xt];
        wt[Et] = xt;
      }), wt;
    }));
  }, Qe.forEach(function(lt) {
    at.prototype[lt] = function() {
      const bt = this._baseState;
      throw new Error(lt + " not implemented for encoding: " + bt.enc);
    };
  }), Ve.forEach(function(lt) {
    at.prototype[lt] = function() {
      const bt = this._baseState, $t = Array.prototype.slice.call(arguments);
      return Ke(bt.tag === null), bt.tag = lt, this._useArgs($t), this;
    };
  }), at.prototype.use = function(dt) {
    Ke(dt);
    const bt = this._baseState;
    return Ke(bt.use === null), bt.use = dt, this;
  }, at.prototype.optional = function() {
    const dt = this._baseState;
    return dt.optional = !0, this;
  }, at.prototype.def = function(dt) {
    const bt = this._baseState;
    return Ke(bt.default === null), bt.default = dt, bt.optional = !0, this;
  }, at.prototype.explicit = function(dt) {
    const bt = this._baseState;
    return Ke(bt.explicit === null && bt.implicit === null), bt.explicit = dt, this;
  }, at.prototype.implicit = function(dt) {
    const bt = this._baseState;
    return Ke(bt.explicit === null && bt.implicit === null), bt.implicit = dt, this;
  }, at.prototype.obj = function() {
    const dt = this._baseState, bt = Array.prototype.slice.call(arguments);
    return dt.obj = !0, bt.length !== 0 && this._useArgs(bt), this;
  }, at.prototype.key = function(dt) {
    const bt = this._baseState;
    return Ke(bt.key === null), bt.key = dt, this;
  }, at.prototype.any = function() {
    const dt = this._baseState;
    return dt.any = !0, this;
  }, at.prototype.choice = function(dt) {
    const bt = this._baseState;
    return Ke(bt.choice === null), bt.choice = dt, this._useArgs(Object.keys(dt).map(function($t) {
      return dt[$t];
    })), this;
  }, at.prototype.contains = function(dt) {
    const bt = this._baseState;
    return Ke(bt.use === null), bt.contains = dt, this;
  }, at.prototype._decode = function(dt, bt) {
    const $t = this._baseState;
    if ($t.parent === null)
      return dt.wrapResult($t.children[0]._decode(dt, bt));
    let vt = $t.default, wt = !0, xt = null;
    if ($t.key !== null && (xt = dt.enterKey($t.key)), $t.optional) {
      let Tt = null;
      if ($t.explicit !== null ? Tt = $t.explicit : $t.implicit !== null ? Tt = $t.implicit : $t.tag !== null && (Tt = $t.tag), Tt === null && !$t.any) {
        const Rt = dt.save();
        try {
          $t.choice === null ? this._decodeGeneric($t.tag, dt, bt) : this._decodeChoice(dt, bt), wt = !0;
        } catch {
          wt = !1;
        }
        dt.restore(Rt);
      } else if (wt = this._peekTag(dt, Tt, $t.any), dt.isError(wt))
        return wt;
    }
    let Et;
    if ($t.obj && wt && (Et = dt.enterObject()), wt) {
      if ($t.explicit !== null) {
        const Rt = this._decodeTag(dt, $t.explicit);
        if (dt.isError(Rt))
          return Rt;
        dt = Rt;
      }
      const Tt = dt.offset;
      if ($t.use === null && $t.choice === null) {
        let Rt;
        $t.any && (Rt = dt.save());
        const Ct = this._decodeTag(dt, $t.implicit !== null ? $t.implicit : $t.tag, $t.any);
        if (dt.isError(Ct))
          return Ct;
        $t.any ? vt = dt.raw(Rt) : dt = Ct;
      }
      if (bt && bt.track && $t.tag !== null && bt.track(dt.path(), Tt, dt.length, "tagged"), bt && bt.track && $t.tag !== null && bt.track(dt.path(), dt.offset, dt.length, "content"), $t.any || ($t.choice === null ? vt = this._decodeGeneric($t.tag, dt, bt) : vt = this._decodeChoice(dt, bt)), dt.isError(vt))
        return vt;
      if (!$t.any && $t.choice === null && $t.children !== null && $t.children.forEach(function(Ct) {
        Ct._decode(dt, bt);
      }), $t.contains && ($t.tag === "octstr" || $t.tag === "bitstr")) {
        const Rt = new Fe(vt);
        vt = this._getUse($t.contains, dt._reporterState.obj)._decode(Rt, bt);
      }
    }
    return $t.obj && wt && (vt = dt.leaveObject(Et)), $t.key !== null && (vt !== null || wt === !0) ? dt.leaveKey(xt, $t.key, vt) : xt !== null && dt.exitKey(xt), vt;
  }, at.prototype._decodeGeneric = function(dt, bt, $t) {
    const vt = this._baseState;
    return dt === "seq" || dt === "set" ? null : dt === "seqof" || dt === "setof" ? this._decodeList(bt, dt, vt.args[0], $t) : /str$/.test(dt) ? this._decodeStr(bt, dt, $t) : dt === "objid" && vt.args ? this._decodeObjid(bt, vt.args[0], vt.args[1], $t) : dt === "objid" ? this._decodeObjid(bt, null, null, $t) : dt === "gentime" || dt === "utctime" ? this._decodeTime(bt, dt, $t) : dt === "null_" ? this._decodeNull(bt, $t) : dt === "bool" ? this._decodeBool(bt, $t) : dt === "objDesc" ? this._decodeStr(bt, dt, $t) : dt === "int" || dt === "enum" ? this._decodeInt(bt, vt.args && vt.args[0], $t) : vt.use !== null ? this._getUse(vt.use, bt._reporterState.obj)._decode(bt, $t) : bt.error("unknown tag: " + dt);
  }, at.prototype._getUse = function(dt, bt) {
    const $t = this._baseState;
    return $t.useDecoder = this._use(dt, bt), Ke($t.useDecoder._baseState.parent === null), $t.useDecoder = $t.useDecoder._baseState.children[0], $t.implicit !== $t.useDecoder._baseState.implicit && ($t.useDecoder = $t.useDecoder.clone(), $t.useDecoder._baseState.implicit = $t.implicit), $t.useDecoder;
  }, at.prototype._decodeChoice = function(dt, bt) {
    const $t = this._baseState;
    let vt = null, wt = !1;
    return Object.keys($t.choice).some(function(xt) {
      const Et = dt.save(), Tt = $t.choice[xt];
      try {
        const Rt = Tt._decode(dt, bt);
        if (dt.isError(Rt))
          return !1;
        vt = {
          type: xt,
          value: Rt
        }, wt = !0;
      } catch {
        return dt.restore(Et), !1;
      }
      return !0;
    }, this), wt ? vt : dt.error("Choice not matched");
  }, at.prototype._createEncoderBuffer = function(dt) {
    return new Ze(dt, this.reporter);
  }, at.prototype._encode = function(dt, bt, $t) {
    const vt = this._baseState;
    if (vt.default !== null && vt.default === dt)
      return;
    const wt = this._encodeValue(dt, bt, $t);
    if (wt !== void 0 && !this._skipDefault(wt, bt, $t))
      return wt;
  }, at.prototype._encodeValue = function(dt, bt, $t) {
    const vt = this._baseState;
    if (vt.parent === null)
      return vt.children[0]._encode(dt, bt || new $e());
    let wt = null;
    if (this.reporter = bt, vt.optional && dt === void 0)
      if (vt.default !== null)
        dt = vt.default;
      else
        return;
    let xt = null, Et = !1;
    if (vt.any)
      wt = this._createEncoderBuffer(dt);
    else if (vt.choice)
      wt = this._encodeChoice(dt, bt);
    else if (vt.contains)
      xt = this._getUse(vt.contains, $t)._encode(dt, bt), Et = !0;
    else if (vt.children)
      xt = vt.children.map(function(Tt) {
        if (Tt._baseState.tag === "null_")
          return Tt._encode(null, bt, dt);
        if (Tt._baseState.key === null)
          return bt.error("Child should have a key");
        const Rt = bt.enterKey(Tt._baseState.key);
        if (typeof dt != "object")
          return bt.error("Child expected, but input is not object");
        const Ct = Tt._encode(dt[Tt._baseState.key], bt, dt);
        return bt.leaveKey(Rt), Ct;
      }, this).filter(function(Tt) {
        return Tt;
      }), xt = this._createEncoderBuffer(xt);
    else if (vt.tag === "seqof" || vt.tag === "setof") {
      if (!(vt.args && vt.args.length === 1))
        return bt.error("Too many args for : " + vt.tag);
      if (!Array.isArray(dt))
        return bt.error("seqof/setof, but data is not Array");
      const Tt = this.clone();
      Tt._baseState.implicit = null, xt = this._createEncoderBuffer(dt.map(function(Rt) {
        const Ct = this._baseState;
        return this._getUse(Ct.args[0], dt)._encode(Rt, bt);
      }, Tt));
    } else
      vt.use !== null ? wt = this._getUse(vt.use, $t)._encode(dt, bt) : (xt = this._encodePrimitive(vt.tag, dt), Et = !0);
    if (!vt.any && vt.choice === null) {
      const Tt = vt.implicit !== null ? vt.implicit : vt.tag, Rt = vt.implicit === null ? "universal" : "context";
      Tt === null ? vt.use === null && bt.error("Tag could be omitted only for .use()") : vt.use === null && (wt = this._encodeComposite(Tt, Et, Rt, xt));
    }
    return vt.explicit !== null && (wt = this._encodeComposite(vt.explicit, !1, "context", wt)), wt;
  }, at.prototype._encodeChoice = function(dt, bt) {
    const $t = this._baseState, vt = $t.choice[dt.type];
    return vt || Ke(!1, dt.type + " not found in " + JSON.stringify(Object.keys($t.choice))), vt._encode(dt.value, bt);
  }, at.prototype._encodePrimitive = function(dt, bt) {
    const $t = this._baseState;
    if (/str$/.test(dt))
      return this._encodeStr(bt, dt);
    if (dt === "objid" && $t.args)
      return this._encodeObjid(bt, $t.reverseArgs[0], $t.args[1]);
    if (dt === "objid")
      return this._encodeObjid(bt, null, null);
    if (dt === "gentime" || dt === "utctime")
      return this._encodeTime(bt, dt);
    if (dt === "null_")
      return this._encodeNull();
    if (dt === "int" || dt === "enum")
      return this._encodeInt(bt, $t.args && $t.reverseArgs[0]);
    if (dt === "bool")
      return this._encodeBool(bt);
    if (dt === "objDesc")
      return this._encodeStr(bt, dt);
    throw new Error("Unsupported tag: " + dt);
  }, at.prototype._isNumstr = function(dt) {
    return /^[0-9 ]*$/.test(dt);
  }, at.prototype._isPrintstr = function(dt) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(dt);
  }, exports$u;
}
var exports$t = {}, _dewExec$s = !1;
function dew$s() {
  if (_dewExec$s)
    return exports$t;
  _dewExec$s = !0;
  function $e(Ze) {
    const Fe = {};
    return Object.keys(Ze).forEach(function(Ke) {
      (Ke | 0) == Ke && (Ke = Ke | 0);
      const Ve = Ze[Ke];
      Fe[Ve] = Ke;
    }), Fe;
  }
  return exports$t.tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
  }, exports$t.tagClassByName = $e(exports$t.tagClass), exports$t.tag = {
    0: "end",
    1: "bool",
    2: "int",
    3: "bitstr",
    4: "octstr",
    5: "null_",
    6: "objid",
    7: "objDesc",
    8: "external",
    9: "real",
    10: "enum",
    11: "embed",
    12: "utf8str",
    13: "relativeOid",
    16: "seq",
    17: "set",
    18: "numstr",
    19: "printstr",
    20: "t61str",
    21: "videostr",
    22: "ia5str",
    23: "utctime",
    24: "gentime",
    25: "graphstr",
    26: "iso646str",
    27: "genstr",
    28: "unistr",
    29: "charstr",
    30: "bmpstr"
  }, exports$t.tagByName = $e(exports$t.tag), exports$t;
}
var exports$s = {}, _dewExec$r = !1;
function dew$r() {
  if (_dewExec$r)
    return exports$s;
  _dewExec$r = !0;
  const $e = dew$f(), Ze = dew$w().Buffer, Fe = dew$t(), Ke = dew$s();
  function Ve(ut) {
    this.enc = "der", this.name = ut.name, this.entity = ut, this.tree = new Je(), this.tree._init(ut.body);
  }
  exports$s = Ve, Ve.prototype.encode = function(lt, dt) {
    return this.tree._encode(lt, dt).join();
  };
  function Je(ut) {
    Fe.call(this, "der", ut);
  }
  $e(Je, Fe), Je.prototype._encodeComposite = function(lt, dt, bt, $t) {
    const vt = at(lt, dt, bt, this.reporter);
    if ($t.length < 128) {
      const Et = Ze.alloc(2);
      return Et[0] = vt, Et[1] = $t.length, this._createEncoderBuffer([Et, $t]);
    }
    let wt = 1;
    for (let Et = $t.length; Et >= 256; Et >>= 8)
      wt++;
    const xt = Ze.alloc(1 + 1 + wt);
    xt[0] = vt, xt[1] = 128 | wt;
    for (let Et = 1 + wt, Tt = $t.length; Tt > 0; Et--, Tt >>= 8)
      xt[Et] = Tt & 255;
    return this._createEncoderBuffer([xt, $t]);
  }, Je.prototype._encodeStr = function(lt, dt) {
    if (dt === "bitstr")
      return this._createEncoderBuffer([lt.unused | 0, lt.data]);
    if (dt === "bmpstr") {
      const bt = Ze.alloc(lt.length * 2);
      for (let $t = 0; $t < lt.length; $t++)
        bt.writeUInt16BE(lt.charCodeAt($t), $t * 2);
      return this._createEncoderBuffer(bt);
    } else
      return dt === "numstr" ? this._isNumstr(lt) ? this._createEncoderBuffer(lt) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : dt === "printstr" ? this._isPrintstr(lt) ? this._createEncoderBuffer(lt) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(dt) ? this._createEncoderBuffer(lt) : dt === "objDesc" ? this._createEncoderBuffer(lt) : this.reporter.error("Encoding of string type: " + dt + " unsupported");
  }, Je.prototype._encodeObjid = function(lt, dt, bt) {
    if (typeof lt == "string") {
      if (!dt)
        return this.reporter.error("string objid given, but no values map found");
      if (!dt.hasOwnProperty(lt))
        return this.reporter.error("objid not found in values map");
      lt = dt[lt].split(/[\s.]+/g);
      for (let xt = 0; xt < lt.length; xt++)
        lt[xt] |= 0;
    } else if (Array.isArray(lt)) {
      lt = lt.slice();
      for (let xt = 0; xt < lt.length; xt++)
        lt[xt] |= 0;
    }
    if (!Array.isArray(lt))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(lt));
    if (!bt) {
      if (lt[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      lt.splice(0, 2, lt[0] * 40 + lt[1]);
    }
    let $t = 0;
    for (let xt = 0; xt < lt.length; xt++) {
      let Et = lt[xt];
      for ($t++; Et >= 128; Et >>= 7)
        $t++;
    }
    const vt = Ze.alloc($t);
    let wt = vt.length - 1;
    for (let xt = lt.length - 1; xt >= 0; xt--) {
      let Et = lt[xt];
      for (vt[wt--] = Et & 127; (Et >>= 7) > 0; )
        vt[wt--] = 128 | Et & 127;
    }
    return this._createEncoderBuffer(vt);
  };
  function Qe(ut) {
    return ut < 10 ? "0" + ut : ut;
  }
  Je.prototype._encodeTime = function(lt, dt) {
    let bt;
    const $t = new Date(lt);
    return dt === "gentime" ? bt = [Qe($t.getUTCFullYear()), Qe($t.getUTCMonth() + 1), Qe($t.getUTCDate()), Qe($t.getUTCHours()), Qe($t.getUTCMinutes()), Qe($t.getUTCSeconds()), "Z"].join("") : dt === "utctime" ? bt = [Qe($t.getUTCFullYear() % 100), Qe($t.getUTCMonth() + 1), Qe($t.getUTCDate()), Qe($t.getUTCHours()), Qe($t.getUTCMinutes()), Qe($t.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + dt + " time is not supported yet"), this._encodeStr(bt, "octstr");
  }, Je.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, Je.prototype._encodeInt = function(lt, dt) {
    if (typeof lt == "string") {
      if (!dt)
        return this.reporter.error("String int or enum given, but no values map");
      if (!dt.hasOwnProperty(lt))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(lt));
      lt = dt[lt];
    }
    if (typeof lt != "number" && !Ze.isBuffer(lt)) {
      const vt = lt.toArray();
      !lt.sign && vt[0] & 128 && vt.unshift(0), lt = Ze.from(vt);
    }
    if (Ze.isBuffer(lt)) {
      let vt = lt.length;
      lt.length === 0 && vt++;
      const wt = Ze.alloc(vt);
      return lt.copy(wt), lt.length === 0 && (wt[0] = 0), this._createEncoderBuffer(wt);
    }
    if (lt < 128)
      return this._createEncoderBuffer(lt);
    if (lt < 256)
      return this._createEncoderBuffer([0, lt]);
    let bt = 1;
    for (let vt = lt; vt >= 256; vt >>= 8)
      bt++;
    const $t = new Array(bt);
    for (let vt = $t.length - 1; vt >= 0; vt--)
      $t[vt] = lt & 255, lt >>= 8;
    return $t[0] & 128 && $t.unshift(0), this._createEncoderBuffer(Ze.from($t));
  }, Je.prototype._encodeBool = function(lt) {
    return this._createEncoderBuffer(lt ? 255 : 0);
  }, Je.prototype._use = function(lt, dt) {
    return typeof lt == "function" && (lt = lt(dt)), lt._getEncoder("der").tree;
  }, Je.prototype._skipDefault = function(lt, dt, bt) {
    const $t = this._baseState;
    let vt;
    if ($t.default === null)
      return !1;
    const wt = lt.join();
    if ($t.defaultBuffer === void 0 && ($t.defaultBuffer = this._encodeValue($t.default, dt, bt).join()), wt.length !== $t.defaultBuffer.length)
      return !1;
    for (vt = 0; vt < wt.length; vt++)
      if (wt[vt] !== $t.defaultBuffer[vt])
        return !1;
    return !0;
  };
  function at(ut, lt, dt, bt) {
    let $t;
    if (ut === "seqof" ? ut = "seq" : ut === "setof" && (ut = "set"), Ke.tagByName.hasOwnProperty(ut))
      $t = Ke.tagByName[ut];
    else if (typeof ut == "number" && (ut | 0) === ut)
      $t = ut;
    else
      return bt.error("Unknown tag: " + ut);
    return $t >= 31 ? bt.error("Multi-octet tag encoding unsupported") : (lt || ($t |= 32), $t |= Ke.tagClassByName[dt || "universal"] << 6, $t);
  }
  return exports$s;
}
var exports$r = {}, _dewExec$q = !1;
function dew$q() {
  if (_dewExec$q)
    return exports$r;
  _dewExec$q = !0;
  const $e = dew$f(), Ze = dew$r();
  function Fe(Ke) {
    Ze.call(this, Ke), this.enc = "pem";
  }
  return $e(Fe, Ze), exports$r = Fe, Fe.prototype.encode = function(Ve, Je) {
    const at = Ze.prototype.encode.call(this, Ve).toString("base64"), ut = ["-----BEGIN " + Je.label + "-----"];
    for (let lt = 0; lt < at.length; lt += 64)
      ut.push(at.slice(lt, lt + 64));
    return ut.push("-----END " + Je.label + "-----"), ut.join(`
`);
  }, exports$r;
}
var exports$q = {}, _dewExec$p = !1;
function dew$p() {
  if (_dewExec$p)
    return exports$q;
  _dewExec$p = !0;
  const $e = exports$q;
  return $e.der = dew$r(), $e.pem = dew$q(), exports$q;
}
var exports$p = {}, _dewExec$o = !1;
function dew$o() {
  if (_dewExec$o)
    return exports$p;
  _dewExec$o = !0;
  const $e = dew$f(), Ze = dew$x(), Fe = dew$u().DecoderBuffer, Ke = dew$t(), Ve = dew$s();
  function Je(lt) {
    this.enc = "der", this.name = lt.name, this.entity = lt, this.tree = new Qe(), this.tree._init(lt.body);
  }
  exports$p = Je, Je.prototype.decode = function(dt, bt) {
    return Fe.isDecoderBuffer(dt) || (dt = new Fe(dt, bt)), this.tree._decode(dt, bt);
  };
  function Qe(lt) {
    Ke.call(this, "der", lt);
  }
  $e(Qe, Ke), Qe.prototype._peekTag = function(dt, bt, $t) {
    if (dt.isEmpty())
      return !1;
    const vt = dt.save(), wt = at(dt, 'Failed to peek tag: "' + bt + '"');
    return dt.isError(wt) ? wt : (dt.restore(vt), wt.tag === bt || wt.tagStr === bt || wt.tagStr + "of" === bt || $t);
  }, Qe.prototype._decodeTag = function(dt, bt, $t) {
    const vt = at(dt, 'Failed to decode tag of "' + bt + '"');
    if (dt.isError(vt))
      return vt;
    let wt = ut(dt, vt.primitive, 'Failed to get length of "' + bt + '"');
    if (dt.isError(wt))
      return wt;
    if (!$t && vt.tag !== bt && vt.tagStr !== bt && vt.tagStr + "of" !== bt)
      return dt.error('Failed to match tag: "' + bt + '"');
    if (vt.primitive || wt !== null)
      return dt.skip(wt, 'Failed to match body of: "' + bt + '"');
    const xt = dt.save(), Et = this._skipUntilEnd(dt, 'Failed to skip indefinite length body: "' + this.tag + '"');
    return dt.isError(Et) ? Et : (wt = dt.offset - xt.offset, dt.restore(xt), dt.skip(wt, 'Failed to match body of: "' + bt + '"'));
  }, Qe.prototype._skipUntilEnd = function(dt, bt) {
    for (; ; ) {
      const $t = at(dt, bt);
      if (dt.isError($t))
        return $t;
      const vt = ut(dt, $t.primitive, bt);
      if (dt.isError(vt))
        return vt;
      let wt;
      if ($t.primitive || vt !== null ? wt = dt.skip(vt) : wt = this._skipUntilEnd(dt, bt), dt.isError(wt))
        return wt;
      if ($t.tagStr === "end")
        break;
    }
  }, Qe.prototype._decodeList = function(dt, bt, $t, vt) {
    const wt = [];
    for (; !dt.isEmpty(); ) {
      const xt = this._peekTag(dt, "end");
      if (dt.isError(xt))
        return xt;
      const Et = $t.decode(dt, "der", vt);
      if (dt.isError(Et) && xt)
        break;
      wt.push(Et);
    }
    return wt;
  }, Qe.prototype._decodeStr = function(dt, bt) {
    if (bt === "bitstr") {
      const $t = dt.readUInt8();
      return dt.isError($t) ? $t : {
        unused: $t,
        data: dt.raw()
      };
    } else if (bt === "bmpstr") {
      const $t = dt.raw();
      if ($t.length % 2 === 1)
        return dt.error("Decoding of string type: bmpstr length mismatch");
      let vt = "";
      for (let wt = 0; wt < $t.length / 2; wt++)
        vt += String.fromCharCode($t.readUInt16BE(wt * 2));
      return vt;
    } else if (bt === "numstr") {
      const $t = dt.raw().toString("ascii");
      return this._isNumstr($t) ? $t : dt.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (bt === "octstr")
        return dt.raw();
      if (bt === "objDesc")
        return dt.raw();
      if (bt === "printstr") {
        const $t = dt.raw().toString("ascii");
        return this._isPrintstr($t) ? $t : dt.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(bt) ? dt.raw().toString() : dt.error("Decoding of string type: " + bt + " unsupported");
    }
  }, Qe.prototype._decodeObjid = function(dt, bt, $t) {
    let vt;
    const wt = [];
    let xt = 0, Et = 0;
    for (; !dt.isEmpty(); )
      Et = dt.readUInt8(), xt <<= 7, xt |= Et & 127, Et & 128 || (wt.push(xt), xt = 0);
    Et & 128 && wt.push(xt);
    const Tt = wt[0] / 40 | 0, Rt = wt[0] % 40;
    if ($t ? vt = wt : vt = [Tt, Rt].concat(wt.slice(1)), bt) {
      let Ct = bt[vt.join(" ")];
      Ct === void 0 && (Ct = bt[vt.join(".")]), Ct !== void 0 && (vt = Ct);
    }
    return vt;
  }, Qe.prototype._decodeTime = function(dt, bt) {
    const $t = dt.raw().toString();
    let vt, wt, xt, Et, Tt, Rt;
    if (bt === "gentime")
      vt = $t.slice(0, 4) | 0, wt = $t.slice(4, 6) | 0, xt = $t.slice(6, 8) | 0, Et = $t.slice(8, 10) | 0, Tt = $t.slice(10, 12) | 0, Rt = $t.slice(12, 14) | 0;
    else if (bt === "utctime")
      vt = $t.slice(0, 2) | 0, wt = $t.slice(2, 4) | 0, xt = $t.slice(4, 6) | 0, Et = $t.slice(6, 8) | 0, Tt = $t.slice(8, 10) | 0, Rt = $t.slice(10, 12) | 0, vt < 70 ? vt = 2e3 + vt : vt = 1900 + vt;
    else
      return dt.error("Decoding " + bt + " time is not supported yet");
    return Date.UTC(vt, wt - 1, xt, Et, Tt, Rt, 0);
  }, Qe.prototype._decodeNull = function() {
    return null;
  }, Qe.prototype._decodeBool = function(dt) {
    const bt = dt.readUInt8();
    return dt.isError(bt) ? bt : bt !== 0;
  }, Qe.prototype._decodeInt = function(dt, bt) {
    const $t = dt.raw();
    let vt = new Ze($t);
    return bt && (vt = bt[vt.toString(10)] || vt), vt;
  }, Qe.prototype._use = function(dt, bt) {
    return typeof dt == "function" && (dt = dt(bt)), dt._getDecoder("der").tree;
  };
  function at(lt, dt) {
    let bt = lt.readUInt8(dt);
    if (lt.isError(bt))
      return bt;
    const $t = Ve.tagClass[bt >> 6], vt = (bt & 32) === 0;
    if ((bt & 31) === 31) {
      let xt = bt;
      for (bt = 0; (xt & 128) === 128; ) {
        if (xt = lt.readUInt8(dt), lt.isError(xt))
          return xt;
        bt <<= 7, bt |= xt & 127;
      }
    } else
      bt &= 31;
    const wt = Ve.tag[bt];
    return {
      cls: $t,
      primitive: vt,
      tag: bt,
      tagStr: wt
    };
  }
  function ut(lt, dt, bt) {
    let $t = lt.readUInt8(bt);
    if (lt.isError($t))
      return $t;
    if (!dt && $t === 128)
      return null;
    if (!($t & 128))
      return $t;
    const vt = $t & 127;
    if (vt > 4)
      return lt.error("length octect is too long");
    $t = 0;
    for (let wt = 0; wt < vt; wt++) {
      $t <<= 8;
      const xt = lt.readUInt8(bt);
      if (lt.isError(xt))
        return xt;
      $t |= xt;
    }
    return $t;
  }
  return exports$p;
}
var exports$o = {}, _dewExec$n = !1;
function dew$n() {
  if (_dewExec$n)
    return exports$o;
  _dewExec$n = !0;
  const $e = dew$f(), Ze = dew$w().Buffer, Fe = dew$o();
  function Ke(Ve) {
    Fe.call(this, Ve), this.enc = "pem";
  }
  return $e(Ke, Fe), exports$o = Ke, Ke.prototype.decode = function(Je, Qe) {
    const at = Je.toString().split(/[\r\n]+/g), ut = Qe.label.toUpperCase(), lt = /^-----(BEGIN|END) ([^-]+)-----$/;
    let dt = -1, bt = -1;
    for (let wt = 0; wt < at.length; wt++) {
      const xt = at[wt].match(lt);
      if (xt !== null && xt[2] === ut)
        if (dt === -1) {
          if (xt[1] !== "BEGIN")
            break;
          dt = wt;
        } else {
          if (xt[1] !== "END")
            break;
          bt = wt;
          break;
        }
    }
    if (dt === -1 || bt === -1)
      throw new Error("PEM section not found for: " + ut);
    const $t = at.slice(dt + 1, bt).join("");
    $t.replace(/[^a-z0-9+/=]+/gi, "");
    const vt = Ze.from($t, "base64");
    return Fe.prototype.decode.call(this, vt, Qe);
  }, exports$o;
}
var exports$n = {}, _dewExec$m = !1;
function dew$m() {
  if (_dewExec$m)
    return exports$n;
  _dewExec$m = !0;
  const $e = exports$n;
  return $e.der = dew$o(), $e.pem = dew$n(), exports$n;
}
var exports$m = {}, _dewExec$l = !1;
function dew$l() {
  if (_dewExec$l)
    return exports$m;
  _dewExec$l = !0;
  const $e = dew$p(), Ze = dew$m(), Fe = dew$f(), Ke = exports$m;
  Ke.define = function(Qe, at) {
    return new Ve(Qe, at);
  };
  function Ve(Je, Qe) {
    this.name = Je, this.body = Qe, this.decoders = {}, this.encoders = {};
  }
  return Ve.prototype._createNamed = function(Qe) {
    const at = this.name;
    function ut(lt) {
      this._initNamed(lt, at);
    }
    return Fe(ut, Qe), ut.prototype._initNamed = function(dt, bt) {
      Qe.call(this, dt, bt);
    }, new ut(this);
  }, Ve.prototype._getDecoder = function(Qe) {
    return Qe = Qe || "der", this.decoders.hasOwnProperty(Qe) || (this.decoders[Qe] = this._createNamed(Ze[Qe])), this.decoders[Qe];
  }, Ve.prototype.decode = function(Qe, at, ut) {
    return this._getDecoder(at).decode(Qe, ut);
  }, Ve.prototype._getEncoder = function(Qe) {
    return Qe = Qe || "der", this.encoders.hasOwnProperty(Qe) || (this.encoders[Qe] = this._createNamed($e[Qe])), this.encoders[Qe];
  }, Ve.prototype.encode = function(Qe, at, ut) {
    return this._getEncoder(at).encode(Qe, ut);
  }, exports$m;
}
var exports$l = {}, _dewExec$k = !1;
function dew$k() {
  if (_dewExec$k)
    return exports$l;
  _dewExec$k = !0;
  const $e = exports$l;
  return $e.Reporter = dew$v().Reporter, $e.DecoderBuffer = dew$u().DecoderBuffer, $e.EncoderBuffer = dew$u().EncoderBuffer, $e.Node = dew$t(), exports$l;
}
var exports$k = {}, _dewExec$j = !1;
function dew$j() {
  if (_dewExec$j)
    return exports$k;
  _dewExec$j = !0;
  const $e = exports$k;
  return $e._reverse = function(Fe) {
    const Ke = {};
    return Object.keys(Fe).forEach(function(Ve) {
      (Ve | 0) == Ve && (Ve = Ve | 0);
      const Je = Fe[Ve];
      Ke[Je] = Ve;
    }), Ke;
  }, $e.der = dew$s(), exports$k;
}
var exports$j = {}, _dewExec$i = !1;
function dew$i() {
  if (_dewExec$i)
    return exports$j;
  _dewExec$i = !0;
  const $e = exports$j;
  return $e.bignum = dew$x(), $e.define = dew$l().define, $e.base = dew$k(), $e.constants = dew$j(), $e.decoders = dew$m(), $e.encoders = dew$p(), exports$j;
}
var exports$i = {}, _dewExec$h = !1;
function dew$h() {
  if (_dewExec$h)
    return exports$i;
  _dewExec$h = !0;
  var $e = dew$i(), Ze = $e.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), Fe = $e.define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
  }), Ke = $e.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
  }), Ve = $e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(Ke), this.key("subjectPublicKey").bitstr());
  }), Je = $e.define("RelativeDistinguishedName", function() {
    this.setof(Fe);
  }), Qe = $e.define("RDNSequence", function() {
    this.seqof(Je);
  }), at = $e.define("Name", function() {
    this.choice({
      rdnSequence: this.use(Qe)
    });
  }), ut = $e.define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(Ze), this.key("notAfter").use(Ze));
  }), lt = $e.define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr());
  }), dt = $e.define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(Ke), this.key("issuer").use(at), this.key("validity").use(ut), this.key("subject").use(at), this.key("subjectPublicKeyInfo").use(Ve), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(lt).optional());
  }), bt = $e.define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(dt), this.key("signatureAlgorithm").use(Ke), this.key("signatureValue").bitstr());
  });
  return exports$i = bt, exports$i;
}
var exports$h = {}, _dewExec$g2 = !1;
function dew$g2() {
  if (_dewExec$g2)
    return exports$h;
  _dewExec$g2 = !0;
  var $e = dew$i();
  exports$h.certificate = dew$h();
  var Ze = $e.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
  });
  exports$h.RSAPrivateKey = Ze;
  var Fe = $e.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
  });
  exports$h.RSAPublicKey = Fe;
  var Ke = $e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(Ve), this.key("subjectPublicKey").bitstr());
  });
  exports$h.PublicKey = Ke;
  var Ve = $e.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
  }), Je = $e.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(Ve), this.key("subjectPrivateKey").octstr());
  });
  exports$h.PrivateKey = Je;
  var Qe = $e.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
  });
  exports$h.EncryptedPrivateKey = Qe;
  var at = $e.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
  });
  exports$h.DSAPrivateKey = at, exports$h.DSAparam = $e.define("DSAparam", function() {
    this.int();
  });
  var ut = $e.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(lt), this.key("publicKey").optional().explicit(1).bitstr());
  });
  exports$h.ECPrivateKey = ut;
  var lt = $e.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  });
  return exports$h.signature = $e.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
  }), exports$h;
}
var _aesid = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
}, exports$g2 = {}, _dewExec$f2 = !1;
function dew$f2() {
  if (_dewExec$f2)
    return exports$g2;
  _dewExec$f2 = !0;
  var $e = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, Ze = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, Fe = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, Ke = dew$21(), Ve = dew$1_(), Je = dew$2P().Buffer;
  return exports$g2 = function(Qe, at) {
    var ut = Qe.toString(), lt = ut.match($e), dt;
    if (lt) {
      var $t = "aes" + lt[1], vt = Je.from(lt[2], "hex"), wt = Je.from(lt[3].replace(/[\r\n]/g, ""), "base64"), xt = Ke(at, vt.slice(0, 8), parseInt(lt[1], 10)).key, Et = [], Tt = Ve.createDecipheriv($t, xt, vt);
      Et.push(Tt.update(wt)), Et.push(Tt.final()), dt = Je.concat(Et);
    } else {
      var bt = ut.match(Fe);
      dt = Je.from(bt[2].replace(/[\r\n]/g, ""), "base64");
    }
    var Rt = ut.match(Ze)[1];
    return {
      tag: Rt,
      data: dt
    };
  }, exports$g2;
}
var exports$f2 = {}, _dewExec$e2 = !1;
function dew$e2() {
  if (_dewExec$e2)
    return exports$f2;
  _dewExec$e2 = !0;
  var $e = dew$g2(), Ze = _aesid, Fe = dew$f2(), Ke = dew$1_(), Ve = dew$2o(), Je = dew$2P().Buffer;
  exports$f2 = Qe;
  function Qe(ut) {
    var lt;
    typeof ut == "object" && !Je.isBuffer(ut) && (lt = ut.passphrase, ut = ut.key), typeof ut == "string" && (ut = Je.from(ut));
    var dt = Fe(ut, lt), bt = dt.tag, $t = dt.data, vt, wt;
    switch (bt) {
      case "CERTIFICATE":
        wt = $e.certificate.decode($t, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (wt || (wt = $e.PublicKey.decode($t, "der")), vt = wt.algorithm.algorithm.join("."), vt) {
          case "1.2.840.113549.1.1.1":
            return $e.RSAPublicKey.decode(wt.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return wt.subjectPrivateKey = wt.subjectPublicKey, {
              type: "ec",
              data: wt
            };
          case "1.2.840.10040.4.1":
            return wt.algorithm.params.pub_key = $e.DSAparam.decode(wt.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: wt.algorithm.params
            };
          default:
            throw new Error("unknown key id " + vt);
        }
      case "ENCRYPTED PRIVATE KEY":
        $t = $e.EncryptedPrivateKey.decode($t, "der"), $t = at($t, lt);
      case "PRIVATE KEY":
        switch (wt = $e.PrivateKey.decode($t, "der"), vt = wt.algorithm.algorithm.join("."), vt) {
          case "1.2.840.113549.1.1.1":
            return $e.RSAPrivateKey.decode(wt.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: wt.algorithm.curve,
              privateKey: $e.ECPrivateKey.decode(wt.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return wt.algorithm.params.priv_key = $e.DSAparam.decode(wt.subjectPrivateKey, "der"), {
              type: "dsa",
              params: wt.algorithm.params
            };
          default:
            throw new Error("unknown key id " + vt);
        }
      case "RSA PUBLIC KEY":
        return $e.RSAPublicKey.decode($t, "der");
      case "RSA PRIVATE KEY":
        return $e.RSAPrivateKey.decode($t, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: $e.DSAPrivateKey.decode($t, "der")
        };
      case "EC PRIVATE KEY":
        return $t = $e.ECPrivateKey.decode($t, "der"), {
          curve: $t.parameters.value,
          privateKey: $t.privateKey
        };
      default:
        throw new Error("unknown key type " + bt);
    }
  }
  Qe.signature = $e.signature;
  function at(ut, lt) {
    var dt = ut.algorithm.decrypt.kde.kdeparams.salt, bt = parseInt(ut.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), $t = Ze[ut.algorithm.decrypt.cipher.algo.join(".")], vt = ut.algorithm.decrypt.cipher.iv, wt = ut.subjectPrivateKey, xt = parseInt($t.split("-")[1], 10) / 8, Et = Ve.pbkdf2Sync(lt, dt, bt, xt, "sha1"), Tt = Ke.createDecipheriv($t, Et, vt), Rt = [];
    return Rt.push(Tt.update(wt)), Rt.push(Tt.final()), Je.concat(Rt);
  }
  return exports$f2;
}
var _curves = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
}, exports$e2 = {}, _dewExec$d2 = !1;
function dew$d2() {
  if (_dewExec$d2)
    return exports$e2;
  _dewExec$d2 = !0;
  var $e = dew$Y().Buffer, Ze = dew$2v(), Fe = dew$W(), Ke = dew$y().ec, Ve = dew$X(), Je = dew$e2(), Qe = _curves;
  function at(Et, Tt, Rt, Ct, Zt) {
    var Lt = Je(Tt);
    if (Lt.curve) {
      if (Ct !== "ecdsa" && Ct !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return ut(Et, Lt);
    } else if (Lt.type === "dsa") {
      if (Ct !== "dsa")
        throw new Error("wrong private key type");
      return lt(Et, Lt, Rt);
    } else if (Ct !== "rsa" && Ct !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    Et = $e.concat([Zt, Et]);
    for (var Ut = Lt.modulus.byteLength(), Pt = [0, 1]; Et.length + Pt.length + 1 < Ut; )
      Pt.push(255);
    Pt.push(0);
    for (var Ot = -1; ++Ot < Et.length; )
      Pt.push(Et[Ot]);
    var Ft = Fe(Pt, Lt);
    return Ft;
  }
  function ut(Et, Tt) {
    var Rt = Qe[Tt.curve.join(".")];
    if (!Rt)
      throw new Error("unknown curve " + Tt.curve.join("."));
    var Ct = new Ke(Rt), Zt = Ct.keyFromPrivate(Tt.privateKey), Lt = Zt.sign(Et);
    return $e.from(Lt.toDER());
  }
  function lt(Et, Tt, Rt) {
    for (var Ct = Tt.params.priv_key, Zt = Tt.params.p, Lt = Tt.params.q, Ut = Tt.params.g, Pt = new Ve(0), Ot, Ft = $t(Et, Lt).mod(Lt), gt = !1, We = bt(Ct, Lt, Et, Rt); gt === !1; )
      Ot = wt(Lt, We, Rt), Pt = xt(Ut, Ot, Zt, Lt), gt = Ot.invm(Lt).imul(Ft.add(Ct.mul(Pt))).mod(Lt), gt.cmpn(0) === 0 && (gt = !1, Pt = new Ve(0));
    return dt(Pt, gt);
  }
  function dt(Et, Tt) {
    Et = Et.toArray(), Tt = Tt.toArray(), Et[0] & 128 && (Et = [0].concat(Et)), Tt[0] & 128 && (Tt = [0].concat(Tt));
    var Rt = Et.length + Tt.length + 4, Ct = [48, Rt, 2, Et.length];
    return Ct = Ct.concat(Et, [2, Tt.length], Tt), $e.from(Ct);
  }
  function bt(Et, Tt, Rt, Ct) {
    if (Et = $e.from(Et.toArray()), Et.length < Tt.byteLength()) {
      var Zt = $e.alloc(Tt.byteLength() - Et.length);
      Et = $e.concat([Zt, Et]);
    }
    var Lt = Rt.length, Ut = vt(Rt, Tt), Pt = $e.alloc(Lt);
    Pt.fill(1);
    var Ot = $e.alloc(Lt);
    return Ot = Ze(Ct, Ot).update(Pt).update($e.from([0])).update(Et).update(Ut).digest(), Pt = Ze(Ct, Ot).update(Pt).digest(), Ot = Ze(Ct, Ot).update(Pt).update($e.from([1])).update(Et).update(Ut).digest(), Pt = Ze(Ct, Ot).update(Pt).digest(), {
      k: Ot,
      v: Pt
    };
  }
  function $t(Et, Tt) {
    var Rt = new Ve(Et), Ct = (Et.length << 3) - Tt.bitLength();
    return Ct > 0 && Rt.ishrn(Ct), Rt;
  }
  function vt(Et, Tt) {
    Et = $t(Et, Tt), Et = Et.mod(Tt);
    var Rt = $e.from(Et.toArray());
    if (Rt.length < Tt.byteLength()) {
      var Ct = $e.alloc(Tt.byteLength() - Rt.length);
      Rt = $e.concat([Ct, Rt]);
    }
    return Rt;
  }
  function wt(Et, Tt, Rt) {
    var Ct, Zt;
    do {
      for (Ct = $e.alloc(0); Ct.length * 8 < Et.bitLength(); )
        Tt.v = Ze(Rt, Tt.k).update(Tt.v).digest(), Ct = $e.concat([Ct, Tt.v]);
      Zt = $t(Ct, Et), Tt.k = Ze(Rt, Tt.k).update(Tt.v).update($e.from([0])).digest(), Tt.v = Ze(Rt, Tt.k).update(Tt.v).digest();
    } while (Zt.cmp(Et) !== -1);
    return Zt;
  }
  function xt(Et, Tt, Rt, Ct) {
    return Et.toRed(Ve.mont(Rt)).redPow(Tt).fromRed().mod(Ct);
  }
  return exports$e2 = at, exports$e2.getKey = bt, exports$e2.makeKey = wt, exports$e2;
}
var exports$d2 = {}, _dewExec$c2 = !1;
function dew$c2() {
  if (_dewExec$c2)
    return exports$d2;
  _dewExec$c2 = !0;
  var $e = dew$Y().Buffer, Ze = dew$X(), Fe = dew$y().ec, Ke = dew$e2(), Ve = _curves;
  function Je(lt, dt, bt, $t, vt) {
    var wt = Ke(bt);
    if (wt.type === "ec") {
      if ($t !== "ecdsa" && $t !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return Qe(lt, dt, wt);
    } else if (wt.type === "dsa") {
      if ($t !== "dsa")
        throw new Error("wrong public key type");
      return at(lt, dt, wt);
    } else if ($t !== "rsa" && $t !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    dt = $e.concat([vt, dt]);
    for (var xt = wt.modulus.byteLength(), Et = [1], Tt = 0; dt.length + Et.length + 2 < xt; )
      Et.push(255), Tt++;
    Et.push(0);
    for (var Rt = -1; ++Rt < dt.length; )
      Et.push(dt[Rt]);
    Et = $e.from(Et);
    var Ct = Ze.mont(wt.modulus);
    lt = new Ze(lt).toRed(Ct), lt = lt.redPow(new Ze(wt.publicExponent)), lt = $e.from(lt.fromRed().toArray());
    var Zt = Tt < 8 ? 1 : 0;
    for (xt = Math.min(lt.length, Et.length), lt.length !== Et.length && (Zt = 1), Rt = -1; ++Rt < xt; )
      Zt |= lt[Rt] ^ Et[Rt];
    return Zt === 0;
  }
  function Qe(lt, dt, bt) {
    var $t = Ve[bt.data.algorithm.curve.join(".")];
    if (!$t)
      throw new Error("unknown curve " + bt.data.algorithm.curve.join("."));
    var vt = new Fe($t), wt = bt.data.subjectPrivateKey.data;
    return vt.verify(dt, lt, wt);
  }
  function at(lt, dt, bt) {
    var $t = bt.data.p, vt = bt.data.q, wt = bt.data.g, xt = bt.data.pub_key, Et = Ke.signature.decode(lt, "der"), Tt = Et.s, Rt = Et.r;
    ut(Tt, vt), ut(Rt, vt);
    var Ct = Ze.mont($t), Zt = Tt.invm(vt), Lt = wt.toRed(Ct).redPow(new Ze(dt).mul(Zt).mod(vt)).fromRed().mul(xt.toRed(Ct).redPow(Rt.mul(Zt).mod(vt)).fromRed()).mod($t).mod(vt);
    return Lt.cmp(Rt) === 0;
  }
  function ut(lt, dt) {
    if (lt.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (lt.cmp(dt) >= dt)
      throw new Error("invalid sig");
  }
  return exports$d2 = Je, exports$d2;
}
var exports$c2 = {}, _dewExec$b2 = !1, _global$4 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$b2() {
  if (_dewExec$b2)
    return exports$c2;
  _dewExec$b2 = !0;
  var $e = dew$Y().Buffer, Ze = dew$2y(), Fe = dew4(), Ke = dew$f(), Ve = dew$d2(), Je = dew$c2(), Qe = _algorithms$1;
  Object.keys(Qe).forEach(function(bt) {
    Qe[bt].id = $e.from(Qe[bt].id, "hex"), Qe[bt.toLowerCase()] = Qe[bt];
  });
  function at(bt) {
    Fe.Writable.call(this || _global$4);
    var $t = Qe[bt];
    if (!$t)
      throw new Error("Unknown message digest");
    (this || _global$4)._hashType = $t.hash, (this || _global$4)._hash = Ze($t.hash), (this || _global$4)._tag = $t.id, (this || _global$4)._signType = $t.sign;
  }
  Ke(at, Fe.Writable), at.prototype._write = function($t, vt, wt) {
    (this || _global$4)._hash.update($t), wt();
  }, at.prototype.update = function($t, vt) {
    return typeof $t == "string" && ($t = $e.from($t, vt)), (this || _global$4)._hash.update($t), this || _global$4;
  }, at.prototype.sign = function($t, vt) {
    this.end();
    var wt = (this || _global$4)._hash.digest(), xt = Ve(wt, $t, (this || _global$4)._hashType, (this || _global$4)._signType, (this || _global$4)._tag);
    return vt ? xt.toString(vt) : xt;
  };
  function ut(bt) {
    Fe.Writable.call(this || _global$4);
    var $t = Qe[bt];
    if (!$t)
      throw new Error("Unknown message digest");
    (this || _global$4)._hash = Ze($t.hash), (this || _global$4)._tag = $t.id, (this || _global$4)._signType = $t.sign;
  }
  Ke(ut, Fe.Writable), ut.prototype._write = function($t, vt, wt) {
    (this || _global$4)._hash.update($t), wt();
  }, ut.prototype.update = function($t, vt) {
    return typeof $t == "string" && ($t = $e.from($t, vt)), (this || _global$4)._hash.update($t), this || _global$4;
  }, ut.prototype.verify = function($t, vt, wt) {
    typeof vt == "string" && (vt = $e.from(vt, wt)), this.end();
    var xt = (this || _global$4)._hash.digest();
    return Je(vt, xt, $t, (this || _global$4)._signType, (this || _global$4)._tag);
  };
  function lt(bt) {
    return new at(bt);
  }
  function dt(bt) {
    return new ut(bt);
  }
  return exports$c2 = {
    Sign: lt,
    Verify: dt,
    createSign: lt,
    createVerify: dt
  }, exports$c2;
}
var exports$b2 = {}, _dewExec$a2 = !1, module$1 = {
  exports: exports$b2
}, _global$3 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$a2() {
  return _dewExec$a2 || (_dewExec$a2 = !0, function($e, Ze) {
    function Fe(gt, We) {
      if (!gt)
        throw new Error(We || "Assertion failed");
    }
    function Ke(gt, We) {
      gt.super_ = We;
      var Xe = function() {
      };
      Xe.prototype = We.prototype, gt.prototype = new Xe(), gt.prototype.constructor = gt;
    }
    function Ve(gt, We, Xe) {
      if (Ve.isBN(gt))
        return gt;
      (this || _global$3).negative = 0, (this || _global$3).words = null, (this || _global$3).length = 0, (this || _global$3).red = null, gt !== null && ((We === "le" || We === "be") && (Xe = We, We = 10), this._init(gt || 0, We || 10, Xe || "be"));
    }
    typeof $e == "object" ? $e.exports = Ve : Ze.BN = Ve, Ve.BN = Ve, Ve.wordSize = 26;
    var Je;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Je = window.Buffer : Je = buffer.Buffer;
    } catch {
    }
    Ve.isBN = function(We) {
      return We instanceof Ve ? !0 : We !== null && typeof We == "object" && We.constructor.wordSize === Ve.wordSize && Array.isArray(We.words);
    }, Ve.max = function(We, Xe) {
      return We.cmp(Xe) > 0 ? We : Xe;
    }, Ve.min = function(We, Xe) {
      return We.cmp(Xe) < 0 ? We : Xe;
    }, Ve.prototype._init = function(We, Xe, rt) {
      if (typeof We == "number")
        return this._initNumber(We, Xe, rt);
      if (typeof We == "object")
        return this._initArray(We, Xe, rt);
      Xe === "hex" && (Xe = 16), Fe(Xe === (Xe | 0) && Xe >= 2 && Xe <= 36), We = We.toString().replace(/\s+/g, "");
      var ot = 0;
      We[0] === "-" && (ot++, (this || _global$3).negative = 1), ot < We.length && (Xe === 16 ? this._parseHex(We, ot, rt) : (this._parseBase(We, Xe, ot), rt === "le" && this._initArray(this.toArray(), Xe, rt)));
    }, Ve.prototype._initNumber = function(We, Xe, rt) {
      We < 0 && ((this || _global$3).negative = 1, We = -We), We < 67108864 ? ((this || _global$3).words = [We & 67108863], (this || _global$3).length = 1) : We < 4503599627370496 ? ((this || _global$3).words = [We & 67108863, We / 67108864 & 67108863], (this || _global$3).length = 2) : (Fe(We < 9007199254740992), (this || _global$3).words = [We & 67108863, We / 67108864 & 67108863, 1], (this || _global$3).length = 3), rt === "le" && this._initArray(this.toArray(), Xe, rt);
    }, Ve.prototype._initArray = function(We, Xe, rt) {
      if (Fe(typeof We.length == "number"), We.length <= 0)
        return (this || _global$3).words = [0], (this || _global$3).length = 1, this || _global$3;
      (this || _global$3).length = Math.ceil(We.length / 3), (this || _global$3).words = new Array((this || _global$3).length);
      for (var ot = 0; ot < (this || _global$3).length; ot++)
        (this || _global$3).words[ot] = 0;
      var ft, mt, yt = 0;
      if (rt === "be")
        for (ot = We.length - 1, ft = 0; ot >= 0; ot -= 3)
          mt = We[ot] | We[ot - 1] << 8 | We[ot - 2] << 16, (this || _global$3).words[ft] |= mt << yt & 67108863, (this || _global$3).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      else if (rt === "le")
        for (ot = 0, ft = 0; ot < We.length; ot += 3)
          mt = We[ot] | We[ot + 1] << 8 | We[ot + 2] << 16, (this || _global$3).words[ft] |= mt << yt & 67108863, (this || _global$3).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      return this.strip();
    };
    function Qe(gt, We) {
      var Xe = gt.charCodeAt(We);
      return Xe >= 65 && Xe <= 70 ? Xe - 55 : Xe >= 97 && Xe <= 102 ? Xe - 87 : Xe - 48 & 15;
    }
    function at(gt, We, Xe) {
      var rt = Qe(gt, Xe);
      return Xe - 1 >= We && (rt |= Qe(gt, Xe - 1) << 4), rt;
    }
    Ve.prototype._parseHex = function(We, Xe, rt) {
      (this || _global$3).length = Math.ceil((We.length - Xe) / 6), (this || _global$3).words = new Array((this || _global$3).length);
      for (var ot = 0; ot < (this || _global$3).length; ot++)
        (this || _global$3).words[ot] = 0;
      var ft = 0, mt = 0, yt;
      if (rt === "be")
        for (ot = We.length - 1; ot >= Xe; ot -= 2)
          yt = at(We, Xe, ot) << ft, (this || _global$3).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$3).words[mt] |= yt >>> 26) : ft += 8;
      else {
        var pt = We.length - Xe;
        for (ot = pt % 2 === 0 ? Xe + 1 : Xe; ot < We.length; ot += 2)
          yt = at(We, Xe, ot) << ft, (this || _global$3).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$3).words[mt] |= yt >>> 26) : ft += 8;
      }
      this.strip();
    };
    function ut(gt, We, Xe, rt) {
      for (var ot = 0, ft = Math.min(gt.length, Xe), mt = We; mt < ft; mt++) {
        var yt = gt.charCodeAt(mt) - 48;
        ot *= rt, yt >= 49 ? ot += yt - 49 + 10 : yt >= 17 ? ot += yt - 17 + 10 : ot += yt;
      }
      return ot;
    }
    Ve.prototype._parseBase = function(We, Xe, rt) {
      (this || _global$3).words = [0], (this || _global$3).length = 1;
      for (var ot = 0, ft = 1; ft <= 67108863; ft *= Xe)
        ot++;
      ot--, ft = ft / Xe | 0;
      for (var mt = We.length - rt, yt = mt % ot, pt = Math.min(mt, mt - yt) + rt, Ge = 0, ct = rt; ct < pt; ct += ot)
        Ge = ut(We, ct, ct + ot, Xe), this.imuln(ft), (this || _global$3).words[0] + Ge < 67108864 ? (this || _global$3).words[0] += Ge : this._iaddn(Ge);
      if (yt !== 0) {
        var Mt = 1;
        for (Ge = ut(We, ct, We.length, Xe), ct = 0; ct < yt; ct++)
          Mt *= Xe;
        this.imuln(Mt), (this || _global$3).words[0] + Ge < 67108864 ? (this || _global$3).words[0] += Ge : this._iaddn(Ge);
      }
      this.strip();
    }, Ve.prototype.copy = function(We) {
      We.words = new Array((this || _global$3).length);
      for (var Xe = 0; Xe < (this || _global$3).length; Xe++)
        We.words[Xe] = (this || _global$3).words[Xe];
      We.length = (this || _global$3).length, We.negative = (this || _global$3).negative, We.red = (this || _global$3).red;
    }, Ve.prototype.clone = function() {
      var We = new Ve(null);
      return this.copy(We), We;
    }, Ve.prototype._expand = function(We) {
      for (; (this || _global$3).length < We; )
        (this || _global$3).words[(this || _global$3).length++] = 0;
      return this || _global$3;
    }, Ve.prototype.strip = function() {
      for (; (this || _global$3).length > 1 && (this || _global$3).words[(this || _global$3).length - 1] === 0; )
        (this || _global$3).length--;
      return this._normSign();
    }, Ve.prototype._normSign = function() {
      return (this || _global$3).length === 1 && (this || _global$3).words[0] === 0 && ((this || _global$3).negative = 0), this || _global$3;
    }, Ve.prototype.inspect = function() {
      return ((this || _global$3).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var lt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], dt = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], bt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    Ve.prototype.toString = function(We, Xe) {
      We = We || 10, Xe = Xe | 0 || 1;
      var rt;
      if (We === 16 || We === "hex") {
        rt = "";
        for (var ot = 0, ft = 0, mt = 0; mt < (this || _global$3).length; mt++) {
          var yt = (this || _global$3).words[mt], pt = ((yt << ot | ft) & 16777215).toString(16);
          ft = yt >>> 24 - ot & 16777215, ft !== 0 || mt !== (this || _global$3).length - 1 ? rt = lt[6 - pt.length] + pt + rt : rt = pt + rt, ot += 2, ot >= 26 && (ot -= 26, mt--);
        }
        for (ft !== 0 && (rt = ft.toString(16) + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$3).negative !== 0 && (rt = "-" + rt), rt;
      }
      if (We === (We | 0) && We >= 2 && We <= 36) {
        var Ge = dt[We], ct = bt[We];
        rt = "";
        var Mt = this.clone();
        for (Mt.negative = 0; !Mt.isZero(); ) {
          var St = Mt.modn(ct).toString(We);
          Mt = Mt.idivn(ct), Mt.isZero() ? rt = St + rt : rt = lt[Ge - St.length] + St + rt;
        }
        for (this.isZero() && (rt = "0" + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$3).negative !== 0 && (rt = "-" + rt), rt;
      }
      Fe(!1, "Base should be between 2 and 36");
    }, Ve.prototype.toNumber = function() {
      var We = (this || _global$3).words[0];
      return (this || _global$3).length === 2 ? We += (this || _global$3).words[1] * 67108864 : (this || _global$3).length === 3 && (this || _global$3).words[2] === 1 ? We += 4503599627370496 + (this || _global$3).words[1] * 67108864 : (this || _global$3).length > 2 && Fe(!1, "Number can only safely store up to 53 bits"), (this || _global$3).negative !== 0 ? -We : We;
    }, Ve.prototype.toJSON = function() {
      return this.toString(16);
    }, Ve.prototype.toBuffer = function(We, Xe) {
      return Fe(typeof Je < "u"), this.toArrayLike(Je, We, Xe);
    }, Ve.prototype.toArray = function(We, Xe) {
      return this.toArrayLike(Array, We, Xe);
    }, Ve.prototype.toArrayLike = function(We, Xe, rt) {
      var ot = this.byteLength(), ft = rt || Math.max(1, ot);
      Fe(ot <= ft, "byte array longer than desired length"), Fe(ft > 0, "Requested array length <= 0"), this.strip();
      var mt = Xe === "le", yt = new We(ft), pt, Ge, ct = this.clone();
      if (mt) {
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[Ge] = pt;
        for (; Ge < ft; Ge++)
          yt[Ge] = 0;
      } else {
        for (Ge = 0; Ge < ft - ot; Ge++)
          yt[Ge] = 0;
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[ft - Ge - 1] = pt;
      }
      return yt;
    }, Math.clz32 ? Ve.prototype._countBits = function(We) {
      return 32 - Math.clz32(We);
    } : Ve.prototype._countBits = function(We) {
      var Xe = We, rt = 0;
      return Xe >= 4096 && (rt += 13, Xe >>>= 13), Xe >= 64 && (rt += 7, Xe >>>= 7), Xe >= 8 && (rt += 4, Xe >>>= 4), Xe >= 2 && (rt += 2, Xe >>>= 2), rt + Xe;
    }, Ve.prototype._zeroBits = function(We) {
      if (We === 0)
        return 26;
      var Xe = We, rt = 0;
      return Xe & 8191 || (rt += 13, Xe >>>= 13), Xe & 127 || (rt += 7, Xe >>>= 7), Xe & 15 || (rt += 4, Xe >>>= 4), Xe & 3 || (rt += 2, Xe >>>= 2), Xe & 1 || rt++, rt;
    }, Ve.prototype.bitLength = function() {
      var We = (this || _global$3).words[(this || _global$3).length - 1], Xe = this._countBits(We);
      return ((this || _global$3).length - 1) * 26 + Xe;
    };
    function $t(gt) {
      for (var We = new Array(gt.bitLength()), Xe = 0; Xe < We.length; Xe++) {
        var rt = Xe / 26 | 0, ot = Xe % 26;
        We[Xe] = (gt.words[rt] & 1 << ot) >>> ot;
      }
      return We;
    }
    Ve.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var We = 0, Xe = 0; Xe < (this || _global$3).length; Xe++) {
        var rt = this._zeroBits((this || _global$3).words[Xe]);
        if (We += rt, rt !== 26)
          break;
      }
      return We;
    }, Ve.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Ve.prototype.toTwos = function(We) {
      return (this || _global$3).negative !== 0 ? this.abs().inotn(We).iaddn(1) : this.clone();
    }, Ve.prototype.fromTwos = function(We) {
      return this.testn(We - 1) ? this.notn(We).iaddn(1).ineg() : this.clone();
    }, Ve.prototype.isNeg = function() {
      return (this || _global$3).negative !== 0;
    }, Ve.prototype.neg = function() {
      return this.clone().ineg();
    }, Ve.prototype.ineg = function() {
      return this.isZero() || ((this || _global$3).negative ^= 1), this || _global$3;
    }, Ve.prototype.iuor = function(We) {
      for (; (this || _global$3).length < We.length; )
        (this || _global$3).words[(this || _global$3).length++] = 0;
      for (var Xe = 0; Xe < We.length; Xe++)
        (this || _global$3).words[Xe] = (this || _global$3).words[Xe] | We.words[Xe];
      return this.strip();
    }, Ve.prototype.ior = function(We) {
      return Fe(((this || _global$3).negative | We.negative) === 0), this.iuor(We);
    }, Ve.prototype.or = function(We) {
      return (this || _global$3).length > We.length ? this.clone().ior(We) : We.clone().ior(this || _global$3);
    }, Ve.prototype.uor = function(We) {
      return (this || _global$3).length > We.length ? this.clone().iuor(We) : We.clone().iuor(this || _global$3);
    }, Ve.prototype.iuand = function(We) {
      var Xe;
      (this || _global$3).length > We.length ? Xe = We : Xe = this || _global$3;
      for (var rt = 0; rt < Xe.length; rt++)
        (this || _global$3).words[rt] = (this || _global$3).words[rt] & We.words[rt];
      return (this || _global$3).length = Xe.length, this.strip();
    }, Ve.prototype.iand = function(We) {
      return Fe(((this || _global$3).negative | We.negative) === 0), this.iuand(We);
    }, Ve.prototype.and = function(We) {
      return (this || _global$3).length > We.length ? this.clone().iand(We) : We.clone().iand(this || _global$3);
    }, Ve.prototype.uand = function(We) {
      return (this || _global$3).length > We.length ? this.clone().iuand(We) : We.clone().iuand(this || _global$3);
    }, Ve.prototype.iuxor = function(We) {
      var Xe, rt;
      (this || _global$3).length > We.length ? (Xe = this || _global$3, rt = We) : (Xe = We, rt = this || _global$3);
      for (var ot = 0; ot < rt.length; ot++)
        (this || _global$3).words[ot] = Xe.words[ot] ^ rt.words[ot];
      if ((this || _global$3) !== Xe)
        for (; ot < Xe.length; ot++)
          (this || _global$3).words[ot] = Xe.words[ot];
      return (this || _global$3).length = Xe.length, this.strip();
    }, Ve.prototype.ixor = function(We) {
      return Fe(((this || _global$3).negative | We.negative) === 0), this.iuxor(We);
    }, Ve.prototype.xor = function(We) {
      return (this || _global$3).length > We.length ? this.clone().ixor(We) : We.clone().ixor(this || _global$3);
    }, Ve.prototype.uxor = function(We) {
      return (this || _global$3).length > We.length ? this.clone().iuxor(We) : We.clone().iuxor(this || _global$3);
    }, Ve.prototype.inotn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = Math.ceil(We / 26) | 0, rt = We % 26;
      this._expand(Xe), rt > 0 && Xe--;
      for (var ot = 0; ot < Xe; ot++)
        (this || _global$3).words[ot] = ~(this || _global$3).words[ot] & 67108863;
      return rt > 0 && ((this || _global$3).words[ot] = ~(this || _global$3).words[ot] & 67108863 >> 26 - rt), this.strip();
    }, Ve.prototype.notn = function(We) {
      return this.clone().inotn(We);
    }, Ve.prototype.setn = function(We, Xe) {
      Fe(typeof We == "number" && We >= 0);
      var rt = We / 26 | 0, ot = We % 26;
      return this._expand(rt + 1), Xe ? (this || _global$3).words[rt] = (this || _global$3).words[rt] | 1 << ot : (this || _global$3).words[rt] = (this || _global$3).words[rt] & ~(1 << ot), this.strip();
    }, Ve.prototype.iadd = function(We) {
      var Xe;
      if ((this || _global$3).negative !== 0 && We.negative === 0)
        return (this || _global$3).negative = 0, Xe = this.isub(We), (this || _global$3).negative ^= 1, this._normSign();
      if ((this || _global$3).negative === 0 && We.negative !== 0)
        return We.negative = 0, Xe = this.isub(We), We.negative = 1, Xe._normSign();
      var rt, ot;
      (this || _global$3).length > We.length ? (rt = this || _global$3, ot = We) : (rt = We, ot = this || _global$3);
      for (var ft = 0, mt = 0; mt < ot.length; mt++)
        Xe = (rt.words[mt] | 0) + (ot.words[mt] | 0) + ft, (this || _global$3).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      for (; ft !== 0 && mt < rt.length; mt++)
        Xe = (rt.words[mt] | 0) + ft, (this || _global$3).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      if ((this || _global$3).length = rt.length, ft !== 0)
        (this || _global$3).words[(this || _global$3).length] = ft, (this || _global$3).length++;
      else if (rt !== (this || _global$3))
        for (; mt < rt.length; mt++)
          (this || _global$3).words[mt] = rt.words[mt];
      return this || _global$3;
    }, Ve.prototype.add = function(We) {
      var Xe;
      return We.negative !== 0 && (this || _global$3).negative === 0 ? (We.negative = 0, Xe = this.sub(We), We.negative ^= 1, Xe) : We.negative === 0 && (this || _global$3).negative !== 0 ? ((this || _global$3).negative = 0, Xe = We.sub(this || _global$3), (this || _global$3).negative = 1, Xe) : (this || _global$3).length > We.length ? this.clone().iadd(We) : We.clone().iadd(this || _global$3);
    }, Ve.prototype.isub = function(We) {
      if (We.negative !== 0) {
        We.negative = 0;
        var Xe = this.iadd(We);
        return We.negative = 1, Xe._normSign();
      } else if ((this || _global$3).negative !== 0)
        return (this || _global$3).negative = 0, this.iadd(We), (this || _global$3).negative = 1, this._normSign();
      var rt = this.cmp(We);
      if (rt === 0)
        return (this || _global$3).negative = 0, (this || _global$3).length = 1, (this || _global$3).words[0] = 0, this || _global$3;
      var ot, ft;
      rt > 0 ? (ot = this || _global$3, ft = We) : (ot = We, ft = this || _global$3);
      for (var mt = 0, yt = 0; yt < ft.length; yt++)
        Xe = (ot.words[yt] | 0) - (ft.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$3).words[yt] = Xe & 67108863;
      for (; mt !== 0 && yt < ot.length; yt++)
        Xe = (ot.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$3).words[yt] = Xe & 67108863;
      if (mt === 0 && yt < ot.length && ot !== (this || _global$3))
        for (; yt < ot.length; yt++)
          (this || _global$3).words[yt] = ot.words[yt];
      return (this || _global$3).length = Math.max((this || _global$3).length, yt), ot !== (this || _global$3) && ((this || _global$3).negative = 1), this.strip();
    }, Ve.prototype.sub = function(We) {
      return this.clone().isub(We);
    };
    function vt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative;
      var rt = gt.length + We.length | 0;
      Xe.length = rt, rt = rt - 1 | 0;
      var ot = gt.words[0] | 0, ft = We.words[0] | 0, mt = ot * ft, yt = mt & 67108863, pt = mt / 67108864 | 0;
      Xe.words[0] = yt;
      for (var Ge = 1; Ge < rt; Ge++) {
        for (var ct = pt >>> 26, Mt = pt & 67108863, St = Math.min(Ge, We.length - 1), At = Math.max(0, Ge - gt.length + 1); At <= St; At++) {
          var Nt = Ge - At | 0;
          ot = gt.words[Nt] | 0, ft = We.words[At] | 0, mt = ot * ft + Mt, ct += mt / 67108864 | 0, Mt = mt & 67108863;
        }
        Xe.words[Ge] = Mt | 0, pt = ct | 0;
      }
      return pt !== 0 ? Xe.words[Ge] = pt | 0 : Xe.length--, Xe.strip();
    }
    var wt = function(We, Xe, rt) {
      var ot = We.words, ft = Xe.words, mt = rt.words, yt = 0, pt, Ge, ct, Mt = ot[0] | 0, St = Mt & 8191, At = Mt >>> 13, Nt = ot[1] | 0, qt = Nt & 8191, Qt = Nt >>> 13, Xt = ot[2] | 0, zt = Xt & 8191, Kt = Xt >>> 13, ur = ot[3] | 0, er = ur & 8191, Dt = ur >>> 13, Ht = ot[4] | 0, Gt = Ht & 8191, rr = Ht >>> 13, sr = ot[5] | 0, Jt = sr & 8191, ir = sr >>> 13, Br = ot[6] | 0, or = Br & 8191, lr = Br >>> 13, Nr = ot[7] | 0, dr = Nr & 8191, gr = Nr >>> 13, Zr = ot[8] | 0, Bt = Zr & 8191, kt = Zr >>> 13, It = ot[9] | 0, jt = It & 8191, Vt = It >>> 13, ar = ft[0] | 0, Yt = ar & 8191, hr = ar >>> 13, zr = ft[1] | 0, cr = zr & 8191, _r = zr >>> 13, Lr = ft[2] | 0, br = Lr & 8191, kr = Lr >>> 13, Xr = ft[3] | 0, yr = Xr & 8191, Ir = Xr >>> 13, Yr = ft[4] | 0, wr = Yr & 8191, Cr = Yr >>> 13, Hr = ft[5] | 0, $r = Hr & 8191, Ar = Hr >>> 13, Wr = ft[6] | 0, mr = Wr & 8191, Tr = Wr >>> 13, Kr = ft[7] | 0, vr = Kr & 8191, Rr = Kr >>> 13, Jr = ft[8] | 0, xr = Jr & 8191, tr = Jr >>> 13, Dr = ft[9] | 0, fr = Dr & 8191, Mr = Dr >>> 13;
      rt.negative = We.negative ^ Xe.negative, rt.length = 19, pt = Math.imul(St, Yt), Ge = Math.imul(St, hr), Ge = Ge + Math.imul(At, Yt) | 0, ct = Math.imul(At, hr);
      var Fr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, pt = Math.imul(qt, Yt), Ge = Math.imul(qt, hr), Ge = Ge + Math.imul(Qt, Yt) | 0, ct = Math.imul(Qt, hr), pt = pt + Math.imul(St, cr) | 0, Ge = Ge + Math.imul(St, _r) | 0, Ge = Ge + Math.imul(At, cr) | 0, ct = ct + Math.imul(At, _r) | 0;
      var qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, pt = Math.imul(zt, Yt), Ge = Math.imul(zt, hr), Ge = Ge + Math.imul(Kt, Yt) | 0, ct = Math.imul(Kt, hr), pt = pt + Math.imul(qt, cr) | 0, Ge = Ge + Math.imul(qt, _r) | 0, Ge = Ge + Math.imul(Qt, cr) | 0, ct = ct + Math.imul(Qt, _r) | 0, pt = pt + Math.imul(St, br) | 0, Ge = Ge + Math.imul(St, kr) | 0, Ge = Ge + Math.imul(At, br) | 0, ct = ct + Math.imul(At, kr) | 0;
      var tn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, pt = Math.imul(er, Yt), Ge = Math.imul(er, hr), Ge = Ge + Math.imul(Dt, Yt) | 0, ct = Math.imul(Dt, hr), pt = pt + Math.imul(zt, cr) | 0, Ge = Ge + Math.imul(zt, _r) | 0, Ge = Ge + Math.imul(Kt, cr) | 0, ct = ct + Math.imul(Kt, _r) | 0, pt = pt + Math.imul(qt, br) | 0, Ge = Ge + Math.imul(qt, kr) | 0, Ge = Ge + Math.imul(Qt, br) | 0, ct = ct + Math.imul(Qt, kr) | 0, pt = pt + Math.imul(St, yr) | 0, Ge = Ge + Math.imul(St, Ir) | 0, Ge = Ge + Math.imul(At, yr) | 0, ct = ct + Math.imul(At, Ir) | 0;
      var Qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, pt = Math.imul(Gt, Yt), Ge = Math.imul(Gt, hr), Ge = Ge + Math.imul(rr, Yt) | 0, ct = Math.imul(rr, hr), pt = pt + Math.imul(er, cr) | 0, Ge = Ge + Math.imul(er, _r) | 0, Ge = Ge + Math.imul(Dt, cr) | 0, ct = ct + Math.imul(Dt, _r) | 0, pt = pt + Math.imul(zt, br) | 0, Ge = Ge + Math.imul(zt, kr) | 0, Ge = Ge + Math.imul(Kt, br) | 0, ct = ct + Math.imul(Kt, kr) | 0, pt = pt + Math.imul(qt, yr) | 0, Ge = Ge + Math.imul(qt, Ir) | 0, Ge = Ge + Math.imul(Qt, yr) | 0, ct = ct + Math.imul(Qt, Ir) | 0, pt = pt + Math.imul(St, wr) | 0, Ge = Ge + Math.imul(St, Cr) | 0, Ge = Ge + Math.imul(At, wr) | 0, ct = ct + Math.imul(At, Cr) | 0;
      var nn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, pt = Math.imul(Jt, Yt), Ge = Math.imul(Jt, hr), Ge = Ge + Math.imul(ir, Yt) | 0, ct = Math.imul(ir, hr), pt = pt + Math.imul(Gt, cr) | 0, Ge = Ge + Math.imul(Gt, _r) | 0, Ge = Ge + Math.imul(rr, cr) | 0, ct = ct + Math.imul(rr, _r) | 0, pt = pt + Math.imul(er, br) | 0, Ge = Ge + Math.imul(er, kr) | 0, Ge = Ge + Math.imul(Dt, br) | 0, ct = ct + Math.imul(Dt, kr) | 0, pt = pt + Math.imul(zt, yr) | 0, Ge = Ge + Math.imul(zt, Ir) | 0, Ge = Ge + Math.imul(Kt, yr) | 0, ct = ct + Math.imul(Kt, Ir) | 0, pt = pt + Math.imul(qt, wr) | 0, Ge = Ge + Math.imul(qt, Cr) | 0, Ge = Ge + Math.imul(Qt, wr) | 0, ct = ct + Math.imul(Qt, Cr) | 0, pt = pt + Math.imul(St, $r) | 0, Ge = Ge + Math.imul(St, Ar) | 0, Ge = Ge + Math.imul(At, $r) | 0, ct = ct + Math.imul(At, Ar) | 0;
      var Er = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, pt = Math.imul(or, Yt), Ge = Math.imul(or, hr), Ge = Ge + Math.imul(lr, Yt) | 0, ct = Math.imul(lr, hr), pt = pt + Math.imul(Jt, cr) | 0, Ge = Ge + Math.imul(Jt, _r) | 0, Ge = Ge + Math.imul(ir, cr) | 0, ct = ct + Math.imul(ir, _r) | 0, pt = pt + Math.imul(Gt, br) | 0, Ge = Ge + Math.imul(Gt, kr) | 0, Ge = Ge + Math.imul(rr, br) | 0, ct = ct + Math.imul(rr, kr) | 0, pt = pt + Math.imul(er, yr) | 0, Ge = Ge + Math.imul(er, Ir) | 0, Ge = Ge + Math.imul(Dt, yr) | 0, ct = ct + Math.imul(Dt, Ir) | 0, pt = pt + Math.imul(zt, wr) | 0, Ge = Ge + Math.imul(zt, Cr) | 0, Ge = Ge + Math.imul(Kt, wr) | 0, ct = ct + Math.imul(Kt, Cr) | 0, pt = pt + Math.imul(qt, $r) | 0, Ge = Ge + Math.imul(qt, Ar) | 0, Ge = Ge + Math.imul(Qt, $r) | 0, ct = ct + Math.imul(Qt, Ar) | 0, pt = pt + Math.imul(St, mr) | 0, Ge = Ge + Math.imul(St, Tr) | 0, Ge = Ge + Math.imul(At, mr) | 0, ct = ct + Math.imul(At, Tr) | 0;
      var Wt = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, pt = Math.imul(dr, Yt), Ge = Math.imul(dr, hr), Ge = Ge + Math.imul(gr, Yt) | 0, ct = Math.imul(gr, hr), pt = pt + Math.imul(or, cr) | 0, Ge = Ge + Math.imul(or, _r) | 0, Ge = Ge + Math.imul(lr, cr) | 0, ct = ct + Math.imul(lr, _r) | 0, pt = pt + Math.imul(Jt, br) | 0, Ge = Ge + Math.imul(Jt, kr) | 0, Ge = Ge + Math.imul(ir, br) | 0, ct = ct + Math.imul(ir, kr) | 0, pt = pt + Math.imul(Gt, yr) | 0, Ge = Ge + Math.imul(Gt, Ir) | 0, Ge = Ge + Math.imul(rr, yr) | 0, ct = ct + Math.imul(rr, Ir) | 0, pt = pt + Math.imul(er, wr) | 0, Ge = Ge + Math.imul(er, Cr) | 0, Ge = Ge + Math.imul(Dt, wr) | 0, ct = ct + Math.imul(Dt, Cr) | 0, pt = pt + Math.imul(zt, $r) | 0, Ge = Ge + Math.imul(zt, Ar) | 0, Ge = Ge + Math.imul(Kt, $r) | 0, ct = ct + Math.imul(Kt, Ar) | 0, pt = pt + Math.imul(qt, mr) | 0, Ge = Ge + Math.imul(qt, Tr) | 0, Ge = Ge + Math.imul(Qt, mr) | 0, ct = ct + Math.imul(Qt, Tr) | 0, pt = pt + Math.imul(St, vr) | 0, Ge = Ge + Math.imul(St, Rr) | 0, Ge = Ge + Math.imul(At, vr) | 0, ct = ct + Math.imul(At, Rr) | 0;
      var nr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, pt = Math.imul(Bt, Yt), Ge = Math.imul(Bt, hr), Ge = Ge + Math.imul(kt, Yt) | 0, ct = Math.imul(kt, hr), pt = pt + Math.imul(dr, cr) | 0, Ge = Ge + Math.imul(dr, _r) | 0, Ge = Ge + Math.imul(gr, cr) | 0, ct = ct + Math.imul(gr, _r) | 0, pt = pt + Math.imul(or, br) | 0, Ge = Ge + Math.imul(or, kr) | 0, Ge = Ge + Math.imul(lr, br) | 0, ct = ct + Math.imul(lr, kr) | 0, pt = pt + Math.imul(Jt, yr) | 0, Ge = Ge + Math.imul(Jt, Ir) | 0, Ge = Ge + Math.imul(ir, yr) | 0, ct = ct + Math.imul(ir, Ir) | 0, pt = pt + Math.imul(Gt, wr) | 0, Ge = Ge + Math.imul(Gt, Cr) | 0, Ge = Ge + Math.imul(rr, wr) | 0, ct = ct + Math.imul(rr, Cr) | 0, pt = pt + Math.imul(er, $r) | 0, Ge = Ge + Math.imul(er, Ar) | 0, Ge = Ge + Math.imul(Dt, $r) | 0, ct = ct + Math.imul(Dt, Ar) | 0, pt = pt + Math.imul(zt, mr) | 0, Ge = Ge + Math.imul(zt, Tr) | 0, Ge = Ge + Math.imul(Kt, mr) | 0, ct = ct + Math.imul(Kt, Tr) | 0, pt = pt + Math.imul(qt, vr) | 0, Ge = Ge + Math.imul(qt, Rr) | 0, Ge = Ge + Math.imul(Qt, vr) | 0, ct = ct + Math.imul(Qt, Rr) | 0, pt = pt + Math.imul(St, xr) | 0, Ge = Ge + Math.imul(St, tr) | 0, Ge = Ge + Math.imul(At, xr) | 0, ct = ct + Math.imul(At, tr) | 0;
      var pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, pt = Math.imul(jt, Yt), Ge = Math.imul(jt, hr), Ge = Ge + Math.imul(Vt, Yt) | 0, ct = Math.imul(Vt, hr), pt = pt + Math.imul(Bt, cr) | 0, Ge = Ge + Math.imul(Bt, _r) | 0, Ge = Ge + Math.imul(kt, cr) | 0, ct = ct + Math.imul(kt, _r) | 0, pt = pt + Math.imul(dr, br) | 0, Ge = Ge + Math.imul(dr, kr) | 0, Ge = Ge + Math.imul(gr, br) | 0, ct = ct + Math.imul(gr, kr) | 0, pt = pt + Math.imul(or, yr) | 0, Ge = Ge + Math.imul(or, Ir) | 0, Ge = Ge + Math.imul(lr, yr) | 0, ct = ct + Math.imul(lr, Ir) | 0, pt = pt + Math.imul(Jt, wr) | 0, Ge = Ge + Math.imul(Jt, Cr) | 0, Ge = Ge + Math.imul(ir, wr) | 0, ct = ct + Math.imul(ir, Cr) | 0, pt = pt + Math.imul(Gt, $r) | 0, Ge = Ge + Math.imul(Gt, Ar) | 0, Ge = Ge + Math.imul(rr, $r) | 0, ct = ct + Math.imul(rr, Ar) | 0, pt = pt + Math.imul(er, mr) | 0, Ge = Ge + Math.imul(er, Tr) | 0, Ge = Ge + Math.imul(Dt, mr) | 0, ct = ct + Math.imul(Dt, Tr) | 0, pt = pt + Math.imul(zt, vr) | 0, Ge = Ge + Math.imul(zt, Rr) | 0, Ge = Ge + Math.imul(Kt, vr) | 0, ct = ct + Math.imul(Kt, Rr) | 0, pt = pt + Math.imul(qt, xr) | 0, Ge = Ge + Math.imul(qt, tr) | 0, Ge = Ge + Math.imul(Qt, xr) | 0, ct = ct + Math.imul(Qt, tr) | 0, pt = pt + Math.imul(St, fr) | 0, Ge = Ge + Math.imul(St, Mr) | 0, Ge = Ge + Math.imul(At, fr) | 0, ct = ct + Math.imul(At, Mr) | 0;
      var Pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, pt = Math.imul(jt, cr), Ge = Math.imul(jt, _r), Ge = Ge + Math.imul(Vt, cr) | 0, ct = Math.imul(Vt, _r), pt = pt + Math.imul(Bt, br) | 0, Ge = Ge + Math.imul(Bt, kr) | 0, Ge = Ge + Math.imul(kt, br) | 0, ct = ct + Math.imul(kt, kr) | 0, pt = pt + Math.imul(dr, yr) | 0, Ge = Ge + Math.imul(dr, Ir) | 0, Ge = Ge + Math.imul(gr, yr) | 0, ct = ct + Math.imul(gr, Ir) | 0, pt = pt + Math.imul(or, wr) | 0, Ge = Ge + Math.imul(or, Cr) | 0, Ge = Ge + Math.imul(lr, wr) | 0, ct = ct + Math.imul(lr, Cr) | 0, pt = pt + Math.imul(Jt, $r) | 0, Ge = Ge + Math.imul(Jt, Ar) | 0, Ge = Ge + Math.imul(ir, $r) | 0, ct = ct + Math.imul(ir, Ar) | 0, pt = pt + Math.imul(Gt, mr) | 0, Ge = Ge + Math.imul(Gt, Tr) | 0, Ge = Ge + Math.imul(rr, mr) | 0, ct = ct + Math.imul(rr, Tr) | 0, pt = pt + Math.imul(er, vr) | 0, Ge = Ge + Math.imul(er, Rr) | 0, Ge = Ge + Math.imul(Dt, vr) | 0, ct = ct + Math.imul(Dt, Rr) | 0, pt = pt + Math.imul(zt, xr) | 0, Ge = Ge + Math.imul(zt, tr) | 0, Ge = Ge + Math.imul(Kt, xr) | 0, ct = ct + Math.imul(Kt, tr) | 0, pt = pt + Math.imul(qt, fr) | 0, Ge = Ge + Math.imul(qt, Mr) | 0, Ge = Ge + Math.imul(Qt, fr) | 0, ct = ct + Math.imul(Qt, Mr) | 0;
      var Sr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, pt = Math.imul(jt, br), Ge = Math.imul(jt, kr), Ge = Ge + Math.imul(Vt, br) | 0, ct = Math.imul(Vt, kr), pt = pt + Math.imul(Bt, yr) | 0, Ge = Ge + Math.imul(Bt, Ir) | 0, Ge = Ge + Math.imul(kt, yr) | 0, ct = ct + Math.imul(kt, Ir) | 0, pt = pt + Math.imul(dr, wr) | 0, Ge = Ge + Math.imul(dr, Cr) | 0, Ge = Ge + Math.imul(gr, wr) | 0, ct = ct + Math.imul(gr, Cr) | 0, pt = pt + Math.imul(or, $r) | 0, Ge = Ge + Math.imul(or, Ar) | 0, Ge = Ge + Math.imul(lr, $r) | 0, ct = ct + Math.imul(lr, Ar) | 0, pt = pt + Math.imul(Jt, mr) | 0, Ge = Ge + Math.imul(Jt, Tr) | 0, Ge = Ge + Math.imul(ir, mr) | 0, ct = ct + Math.imul(ir, Tr) | 0, pt = pt + Math.imul(Gt, vr) | 0, Ge = Ge + Math.imul(Gt, Rr) | 0, Ge = Ge + Math.imul(rr, vr) | 0, ct = ct + Math.imul(rr, Rr) | 0, pt = pt + Math.imul(er, xr) | 0, Ge = Ge + Math.imul(er, tr) | 0, Ge = Ge + Math.imul(Dt, xr) | 0, ct = ct + Math.imul(Dt, tr) | 0, pt = pt + Math.imul(zt, fr) | 0, Ge = Ge + Math.imul(zt, Mr) | 0, Ge = Ge + Math.imul(Kt, fr) | 0, ct = ct + Math.imul(Kt, Mr) | 0;
      var Ur = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, pt = Math.imul(jt, yr), Ge = Math.imul(jt, Ir), Ge = Ge + Math.imul(Vt, yr) | 0, ct = Math.imul(Vt, Ir), pt = pt + Math.imul(Bt, wr) | 0, Ge = Ge + Math.imul(Bt, Cr) | 0, Ge = Ge + Math.imul(kt, wr) | 0, ct = ct + Math.imul(kt, Cr) | 0, pt = pt + Math.imul(dr, $r) | 0, Ge = Ge + Math.imul(dr, Ar) | 0, Ge = Ge + Math.imul(gr, $r) | 0, ct = ct + Math.imul(gr, Ar) | 0, pt = pt + Math.imul(or, mr) | 0, Ge = Ge + Math.imul(or, Tr) | 0, Ge = Ge + Math.imul(lr, mr) | 0, ct = ct + Math.imul(lr, Tr) | 0, pt = pt + Math.imul(Jt, vr) | 0, Ge = Ge + Math.imul(Jt, Rr) | 0, Ge = Ge + Math.imul(ir, vr) | 0, ct = ct + Math.imul(ir, Rr) | 0, pt = pt + Math.imul(Gt, xr) | 0, Ge = Ge + Math.imul(Gt, tr) | 0, Ge = Ge + Math.imul(rr, xr) | 0, ct = ct + Math.imul(rr, tr) | 0, pt = pt + Math.imul(er, fr) | 0, Ge = Ge + Math.imul(er, Mr) | 0, Ge = Ge + Math.imul(Dt, fr) | 0, ct = ct + Math.imul(Dt, Mr) | 0;
      var jr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, pt = Math.imul(jt, wr), Ge = Math.imul(jt, Cr), Ge = Ge + Math.imul(Vt, wr) | 0, ct = Math.imul(Vt, Cr), pt = pt + Math.imul(Bt, $r) | 0, Ge = Ge + Math.imul(Bt, Ar) | 0, Ge = Ge + Math.imul(kt, $r) | 0, ct = ct + Math.imul(kt, Ar) | 0, pt = pt + Math.imul(dr, mr) | 0, Ge = Ge + Math.imul(dr, Tr) | 0, Ge = Ge + Math.imul(gr, mr) | 0, ct = ct + Math.imul(gr, Tr) | 0, pt = pt + Math.imul(or, vr) | 0, Ge = Ge + Math.imul(or, Rr) | 0, Ge = Ge + Math.imul(lr, vr) | 0, ct = ct + Math.imul(lr, Rr) | 0, pt = pt + Math.imul(Jt, xr) | 0, Ge = Ge + Math.imul(Jt, tr) | 0, Ge = Ge + Math.imul(ir, xr) | 0, ct = ct + Math.imul(ir, tr) | 0, pt = pt + Math.imul(Gt, fr) | 0, Ge = Ge + Math.imul(Gt, Mr) | 0, Ge = Ge + Math.imul(rr, fr) | 0, ct = ct + Math.imul(rr, Mr) | 0;
      var Gr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, pt = Math.imul(jt, $r), Ge = Math.imul(jt, Ar), Ge = Ge + Math.imul(Vt, $r) | 0, ct = Math.imul(Vt, Ar), pt = pt + Math.imul(Bt, mr) | 0, Ge = Ge + Math.imul(Bt, Tr) | 0, Ge = Ge + Math.imul(kt, mr) | 0, ct = ct + Math.imul(kt, Tr) | 0, pt = pt + Math.imul(dr, vr) | 0, Ge = Ge + Math.imul(dr, Rr) | 0, Ge = Ge + Math.imul(gr, vr) | 0, ct = ct + Math.imul(gr, Rr) | 0, pt = pt + Math.imul(or, xr) | 0, Ge = Ge + Math.imul(or, tr) | 0, Ge = Ge + Math.imul(lr, xr) | 0, ct = ct + Math.imul(lr, tr) | 0, pt = pt + Math.imul(Jt, fr) | 0, Ge = Ge + Math.imul(Jt, Mr) | 0, Ge = Ge + Math.imul(ir, fr) | 0, ct = ct + Math.imul(ir, Mr) | 0;
      var Vr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, pt = Math.imul(jt, mr), Ge = Math.imul(jt, Tr), Ge = Ge + Math.imul(Vt, mr) | 0, ct = Math.imul(Vt, Tr), pt = pt + Math.imul(Bt, vr) | 0, Ge = Ge + Math.imul(Bt, Rr) | 0, Ge = Ge + Math.imul(kt, vr) | 0, ct = ct + Math.imul(kt, Rr) | 0, pt = pt + Math.imul(dr, xr) | 0, Ge = Ge + Math.imul(dr, tr) | 0, Ge = Ge + Math.imul(gr, xr) | 0, ct = ct + Math.imul(gr, tr) | 0, pt = pt + Math.imul(or, fr) | 0, Ge = Ge + Math.imul(or, Mr) | 0, Ge = Ge + Math.imul(lr, fr) | 0, ct = ct + Math.imul(lr, Mr) | 0;
      var rn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, pt = Math.imul(jt, vr), Ge = Math.imul(jt, Rr), Ge = Ge + Math.imul(Vt, vr) | 0, ct = Math.imul(Vt, Rr), pt = pt + Math.imul(Bt, xr) | 0, Ge = Ge + Math.imul(Bt, tr) | 0, Ge = Ge + Math.imul(kt, xr) | 0, ct = ct + Math.imul(kt, tr) | 0, pt = pt + Math.imul(dr, fr) | 0, Ge = Ge + Math.imul(dr, Mr) | 0, Ge = Ge + Math.imul(gr, fr) | 0, ct = ct + Math.imul(gr, Mr) | 0;
      var an = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, pt = Math.imul(jt, xr), Ge = Math.imul(jt, tr), Ge = Ge + Math.imul(Vt, xr) | 0, ct = Math.imul(Vt, tr), pt = pt + Math.imul(Bt, fr) | 0, Ge = Ge + Math.imul(Bt, Mr) | 0, Ge = Ge + Math.imul(kt, fr) | 0, ct = ct + Math.imul(kt, Mr) | 0;
      var ln = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, pt = Math.imul(jt, fr), Ge = Math.imul(jt, Mr), Ge = Ge + Math.imul(Vt, fr) | 0, ct = Math.imul(Vt, Mr);
      var sn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      return yt = (ct + (Ge >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, mt[0] = Fr, mt[1] = qr, mt[2] = tn, mt[3] = Qr, mt[4] = nn, mt[5] = Er, mt[6] = Wt, mt[7] = nr, mt[8] = pr, mt[9] = Pr, mt[10] = Sr, mt[11] = Ur, mt[12] = jr, mt[13] = Gr, mt[14] = Vr, mt[15] = rn, mt[16] = an, mt[17] = ln, mt[18] = sn, yt !== 0 && (mt[19] = yt, rt.length++), rt;
    };
    Math.imul || (wt = vt);
    function xt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative, Xe.length = gt.length + We.length;
      for (var rt = 0, ot = 0, ft = 0; ft < Xe.length - 1; ft++) {
        var mt = ot;
        ot = 0;
        for (var yt = rt & 67108863, pt = Math.min(ft, We.length - 1), Ge = Math.max(0, ft - gt.length + 1); Ge <= pt; Ge++) {
          var ct = ft - Ge, Mt = gt.words[ct] | 0, St = We.words[Ge] | 0, At = Mt * St, Nt = At & 67108863;
          mt = mt + (At / 67108864 | 0) | 0, Nt = Nt + yt | 0, yt = Nt & 67108863, mt = mt + (Nt >>> 26) | 0, ot += mt >>> 26, mt &= 67108863;
        }
        Xe.words[ft] = yt, rt = mt, mt = ot;
      }
      return rt !== 0 ? Xe.words[ft] = rt : Xe.length--, Xe.strip();
    }
    function Et(gt, We, Xe) {
      var rt = new Tt();
      return rt.mulp(gt, We, Xe);
    }
    Ve.prototype.mulTo = function(We, Xe) {
      var rt, ot = (this || _global$3).length + We.length;
      return (this || _global$3).length === 10 && We.length === 10 ? rt = wt(this || _global$3, We, Xe) : ot < 63 ? rt = vt(this || _global$3, We, Xe) : ot < 1024 ? rt = xt(this || _global$3, We, Xe) : rt = Et(this || _global$3, We, Xe), rt;
    };
    function Tt(gt, We) {
      (this || _global$3).x = gt, (this || _global$3).y = We;
    }
    Tt.prototype.makeRBT = function(We) {
      for (var Xe = new Array(We), rt = Ve.prototype._countBits(We) - 1, ot = 0; ot < We; ot++)
        Xe[ot] = this.revBin(ot, rt, We);
      return Xe;
    }, Tt.prototype.revBin = function(We, Xe, rt) {
      if (We === 0 || We === rt - 1)
        return We;
      for (var ot = 0, ft = 0; ft < Xe; ft++)
        ot |= (We & 1) << Xe - ft - 1, We >>= 1;
      return ot;
    }, Tt.prototype.permute = function(We, Xe, rt, ot, ft, mt) {
      for (var yt = 0; yt < mt; yt++)
        ot[yt] = Xe[We[yt]], ft[yt] = rt[We[yt]];
    }, Tt.prototype.transform = function(We, Xe, rt, ot, ft, mt) {
      this.permute(mt, We, Xe, rt, ot, ft);
      for (var yt = 1; yt < ft; yt <<= 1)
        for (var pt = yt << 1, Ge = Math.cos(2 * Math.PI / pt), ct = Math.sin(2 * Math.PI / pt), Mt = 0; Mt < ft; Mt += pt)
          for (var St = Ge, At = ct, Nt = 0; Nt < yt; Nt++) {
            var qt = rt[Mt + Nt], Qt = ot[Mt + Nt], Xt = rt[Mt + Nt + yt], zt = ot[Mt + Nt + yt], Kt = St * Xt - At * zt;
            zt = St * zt + At * Xt, Xt = Kt, rt[Mt + Nt] = qt + Xt, ot[Mt + Nt] = Qt + zt, rt[Mt + Nt + yt] = qt - Xt, ot[Mt + Nt + yt] = Qt - zt, Nt !== pt && (Kt = Ge * St - ct * At, At = Ge * At + ct * St, St = Kt);
          }
    }, Tt.prototype.guessLen13b = function(We, Xe) {
      var rt = Math.max(Xe, We) | 1, ot = rt & 1, ft = 0;
      for (rt = rt / 2 | 0; rt; rt = rt >>> 1)
        ft++;
      return 1 << ft + 1 + ot;
    }, Tt.prototype.conjugate = function(We, Xe, rt) {
      if (!(rt <= 1))
        for (var ot = 0; ot < rt / 2; ot++) {
          var ft = We[ot];
          We[ot] = We[rt - ot - 1], We[rt - ot - 1] = ft, ft = Xe[ot], Xe[ot] = -Xe[rt - ot - 1], Xe[rt - ot - 1] = -ft;
        }
    }, Tt.prototype.normalize13b = function(We, Xe) {
      for (var rt = 0, ot = 0; ot < Xe / 2; ot++) {
        var ft = Math.round(We[2 * ot + 1] / Xe) * 8192 + Math.round(We[2 * ot] / Xe) + rt;
        We[ot] = ft & 67108863, ft < 67108864 ? rt = 0 : rt = ft / 67108864 | 0;
      }
      return We;
    }, Tt.prototype.convert13b = function(We, Xe, rt, ot) {
      for (var ft = 0, mt = 0; mt < Xe; mt++)
        ft = ft + (We[mt] | 0), rt[2 * mt] = ft & 8191, ft = ft >>> 13, rt[2 * mt + 1] = ft & 8191, ft = ft >>> 13;
      for (mt = 2 * Xe; mt < ot; ++mt)
        rt[mt] = 0;
      Fe(ft === 0), Fe((ft & -8192) === 0);
    }, Tt.prototype.stub = function(We) {
      for (var Xe = new Array(We), rt = 0; rt < We; rt++)
        Xe[rt] = 0;
      return Xe;
    }, Tt.prototype.mulp = function(We, Xe, rt) {
      var ot = 2 * this.guessLen13b(We.length, Xe.length), ft = this.makeRBT(ot), mt = this.stub(ot), yt = new Array(ot), pt = new Array(ot), Ge = new Array(ot), ct = new Array(ot), Mt = new Array(ot), St = new Array(ot), At = rt.words;
      At.length = ot, this.convert13b(We.words, We.length, yt, ot), this.convert13b(Xe.words, Xe.length, ct, ot), this.transform(yt, mt, pt, Ge, ot, ft), this.transform(ct, mt, Mt, St, ot, ft);
      for (var Nt = 0; Nt < ot; Nt++) {
        var qt = pt[Nt] * Mt[Nt] - Ge[Nt] * St[Nt];
        Ge[Nt] = pt[Nt] * St[Nt] + Ge[Nt] * Mt[Nt], pt[Nt] = qt;
      }
      return this.conjugate(pt, Ge, ot), this.transform(pt, Ge, At, mt, ot, ft), this.conjugate(At, mt, ot), this.normalize13b(At, ot), rt.negative = We.negative ^ Xe.negative, rt.length = We.length + Xe.length, rt.strip();
    }, Ve.prototype.mul = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$3).length + We.length), this.mulTo(We, Xe);
    }, Ve.prototype.mulf = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$3).length + We.length), Et(this || _global$3, We, Xe);
    }, Ve.prototype.imul = function(We) {
      return this.clone().mulTo(We, this || _global$3);
    }, Ve.prototype.imuln = function(We) {
      Fe(typeof We == "number"), Fe(We < 67108864);
      for (var Xe = 0, rt = 0; rt < (this || _global$3).length; rt++) {
        var ot = ((this || _global$3).words[rt] | 0) * We, ft = (ot & 67108863) + (Xe & 67108863);
        Xe >>= 26, Xe += ot / 67108864 | 0, Xe += ft >>> 26, (this || _global$3).words[rt] = ft & 67108863;
      }
      return Xe !== 0 && ((this || _global$3).words[rt] = Xe, (this || _global$3).length++), this || _global$3;
    }, Ve.prototype.muln = function(We) {
      return this.clone().imuln(We);
    }, Ve.prototype.sqr = function() {
      return this.mul(this || _global$3);
    }, Ve.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Ve.prototype.pow = function(We) {
      var Xe = $t(We);
      if (Xe.length === 0)
        return new Ve(1);
      for (var rt = this || _global$3, ot = 0; ot < Xe.length && Xe[ot] === 0; ot++, rt = rt.sqr())
        ;
      if (++ot < Xe.length)
        for (var ft = rt.sqr(); ot < Xe.length; ot++, ft = ft.sqr())
          Xe[ot] !== 0 && (rt = rt.mul(ft));
      return rt;
    }, Ve.prototype.iushln = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 67108863 >>> 26 - Xe << 26 - Xe, ft;
      if (Xe !== 0) {
        var mt = 0;
        for (ft = 0; ft < (this || _global$3).length; ft++) {
          var yt = (this || _global$3).words[ft] & ot, pt = ((this || _global$3).words[ft] | 0) - yt << Xe;
          (this || _global$3).words[ft] = pt | mt, mt = yt >>> 26 - Xe;
        }
        mt && ((this || _global$3).words[ft] = mt, (this || _global$3).length++);
      }
      if (rt !== 0) {
        for (ft = (this || _global$3).length - 1; ft >= 0; ft--)
          (this || _global$3).words[ft + rt] = (this || _global$3).words[ft];
        for (ft = 0; ft < rt; ft++)
          (this || _global$3).words[ft] = 0;
        (this || _global$3).length += rt;
      }
      return this.strip();
    }, Ve.prototype.ishln = function(We) {
      return Fe((this || _global$3).negative === 0), this.iushln(We);
    }, Ve.prototype.iushrn = function(We, Xe, rt) {
      Fe(typeof We == "number" && We >= 0);
      var ot;
      Xe ? ot = (Xe - Xe % 26) / 26 : ot = 0;
      var ft = We % 26, mt = Math.min((We - ft) / 26, (this || _global$3).length), yt = 67108863 ^ 67108863 >>> ft << ft, pt = rt;
      if (ot -= mt, ot = Math.max(0, ot), pt) {
        for (var Ge = 0; Ge < mt; Ge++)
          pt.words[Ge] = (this || _global$3).words[Ge];
        pt.length = mt;
      }
      if (mt !== 0)
        if ((this || _global$3).length > mt)
          for ((this || _global$3).length -= mt, Ge = 0; Ge < (this || _global$3).length; Ge++)
            (this || _global$3).words[Ge] = (this || _global$3).words[Ge + mt];
        else
          (this || _global$3).words[0] = 0, (this || _global$3).length = 1;
      var ct = 0;
      for (Ge = (this || _global$3).length - 1; Ge >= 0 && (ct !== 0 || Ge >= ot); Ge--) {
        var Mt = (this || _global$3).words[Ge] | 0;
        (this || _global$3).words[Ge] = ct << 26 - ft | Mt >>> ft, ct = Mt & yt;
      }
      return pt && ct !== 0 && (pt.words[pt.length++] = ct), (this || _global$3).length === 0 && ((this || _global$3).words[0] = 0, (this || _global$3).length = 1), this.strip();
    }, Ve.prototype.ishrn = function(We, Xe, rt) {
      return Fe((this || _global$3).negative === 0), this.iushrn(We, Xe, rt);
    }, Ve.prototype.shln = function(We) {
      return this.clone().ishln(We);
    }, Ve.prototype.ushln = function(We) {
      return this.clone().iushln(We);
    }, Ve.prototype.shrn = function(We) {
      return this.clone().ishrn(We);
    }, Ve.prototype.ushrn = function(We) {
      return this.clone().iushrn(We);
    }, Ve.prototype.testn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$3).length <= rt)
        return !1;
      var ft = (this || _global$3).words[rt];
      return !!(ft & ot);
    }, Ve.prototype.imaskn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26;
      if (Fe((this || _global$3).negative === 0, "imaskn works only with positive numbers"), (this || _global$3).length <= rt)
        return this || _global$3;
      if (Xe !== 0 && rt++, (this || _global$3).length = Math.min(rt, (this || _global$3).length), Xe !== 0) {
        var ot = 67108863 ^ 67108863 >>> Xe << Xe;
        (this || _global$3).words[(this || _global$3).length - 1] &= ot;
      }
      return this.strip();
    }, Ve.prototype.maskn = function(We) {
      return this.clone().imaskn(We);
    }, Ve.prototype.iaddn = function(We) {
      return Fe(typeof We == "number"), Fe(We < 67108864), We < 0 ? this.isubn(-We) : (this || _global$3).negative !== 0 ? (this || _global$3).length === 1 && ((this || _global$3).words[0] | 0) < We ? ((this || _global$3).words[0] = We - ((this || _global$3).words[0] | 0), (this || _global$3).negative = 0, this || _global$3) : ((this || _global$3).negative = 0, this.isubn(We), (this || _global$3).negative = 1, this || _global$3) : this._iaddn(We);
    }, Ve.prototype._iaddn = function(We) {
      (this || _global$3).words[0] += We;
      for (var Xe = 0; Xe < (this || _global$3).length && (this || _global$3).words[Xe] >= 67108864; Xe++)
        (this || _global$3).words[Xe] -= 67108864, Xe === (this || _global$3).length - 1 ? (this || _global$3).words[Xe + 1] = 1 : (this || _global$3).words[Xe + 1]++;
      return (this || _global$3).length = Math.max((this || _global$3).length, Xe + 1), this || _global$3;
    }, Ve.prototype.isubn = function(We) {
      if (Fe(typeof We == "number"), Fe(We < 67108864), We < 0)
        return this.iaddn(-We);
      if ((this || _global$3).negative !== 0)
        return (this || _global$3).negative = 0, this.iaddn(We), (this || _global$3).negative = 1, this || _global$3;
      if ((this || _global$3).words[0] -= We, (this || _global$3).length === 1 && (this || _global$3).words[0] < 0)
        (this || _global$3).words[0] = -(this || _global$3).words[0], (this || _global$3).negative = 1;
      else
        for (var Xe = 0; Xe < (this || _global$3).length && (this || _global$3).words[Xe] < 0; Xe++)
          (this || _global$3).words[Xe] += 67108864, (this || _global$3).words[Xe + 1] -= 1;
      return this.strip();
    }, Ve.prototype.addn = function(We) {
      return this.clone().iaddn(We);
    }, Ve.prototype.subn = function(We) {
      return this.clone().isubn(We);
    }, Ve.prototype.iabs = function() {
      return (this || _global$3).negative = 0, this || _global$3;
    }, Ve.prototype.abs = function() {
      return this.clone().iabs();
    }, Ve.prototype._ishlnsubmul = function(We, Xe, rt) {
      var ot = We.length + rt, ft;
      this._expand(ot);
      var mt, yt = 0;
      for (ft = 0; ft < We.length; ft++) {
        mt = ((this || _global$3).words[ft + rt] | 0) + yt;
        var pt = (We.words[ft] | 0) * Xe;
        mt -= pt & 67108863, yt = (mt >> 26) - (pt / 67108864 | 0), (this || _global$3).words[ft + rt] = mt & 67108863;
      }
      for (; ft < (this || _global$3).length - rt; ft++)
        mt = ((this || _global$3).words[ft + rt] | 0) + yt, yt = mt >> 26, (this || _global$3).words[ft + rt] = mt & 67108863;
      if (yt === 0)
        return this.strip();
      for (Fe(yt === -1), yt = 0, ft = 0; ft < (this || _global$3).length; ft++)
        mt = -((this || _global$3).words[ft] | 0) + yt, yt = mt >> 26, (this || _global$3).words[ft] = mt & 67108863;
      return (this || _global$3).negative = 1, this.strip();
    }, Ve.prototype._wordDiv = function(We, Xe) {
      var rt = (this || _global$3).length - We.length, ot = this.clone(), ft = We, mt = ft.words[ft.length - 1] | 0, yt = this._countBits(mt);
      rt = 26 - yt, rt !== 0 && (ft = ft.ushln(rt), ot.iushln(rt), mt = ft.words[ft.length - 1] | 0);
      var pt = ot.length - ft.length, Ge;
      if (Xe !== "mod") {
        Ge = new Ve(null), Ge.length = pt + 1, Ge.words = new Array(Ge.length);
        for (var ct = 0; ct < Ge.length; ct++)
          Ge.words[ct] = 0;
      }
      var Mt = ot.clone()._ishlnsubmul(ft, 1, pt);
      Mt.negative === 0 && (ot = Mt, Ge && (Ge.words[pt] = 1));
      for (var St = pt - 1; St >= 0; St--) {
        var At = (ot.words[ft.length + St] | 0) * 67108864 + (ot.words[ft.length + St - 1] | 0);
        for (At = Math.min(At / mt | 0, 67108863), ot._ishlnsubmul(ft, At, St); ot.negative !== 0; )
          At--, ot.negative = 0, ot._ishlnsubmul(ft, 1, St), ot.isZero() || (ot.negative ^= 1);
        Ge && (Ge.words[St] = At);
      }
      return Ge && Ge.strip(), ot.strip(), Xe !== "div" && rt !== 0 && ot.iushrn(rt), {
        div: Ge || null,
        mod: ot
      };
    }, Ve.prototype.divmod = function(We, Xe, rt) {
      if (Fe(!We.isZero()), this.isZero())
        return {
          div: new Ve(0),
          mod: new Ve(0)
        };
      var ot, ft, mt;
      return (this || _global$3).negative !== 0 && We.negative === 0 ? (mt = this.neg().divmod(We, Xe), Xe !== "mod" && (ot = mt.div.neg()), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.iadd(We)), {
        div: ot,
        mod: ft
      }) : (this || _global$3).negative === 0 && We.negative !== 0 ? (mt = this.divmod(We.neg(), Xe), Xe !== "mod" && (ot = mt.div.neg()), {
        div: ot,
        mod: mt.mod
      }) : (this || _global$3).negative & We.negative ? (mt = this.neg().divmod(We.neg(), Xe), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.isub(We)), {
        div: mt.div,
        mod: ft
      }) : We.length > (this || _global$3).length || this.cmp(We) < 0 ? {
        div: new Ve(0),
        mod: this || _global$3
      } : We.length === 1 ? Xe === "div" ? {
        div: this.divn(We.words[0]),
        mod: null
      } : Xe === "mod" ? {
        div: null,
        mod: new Ve(this.modn(We.words[0]))
      } : {
        div: this.divn(We.words[0]),
        mod: new Ve(this.modn(We.words[0]))
      } : this._wordDiv(We, Xe);
    }, Ve.prototype.div = function(We) {
      return this.divmod(We, "div", !1).div;
    }, Ve.prototype.mod = function(We) {
      return this.divmod(We, "mod", !1).mod;
    }, Ve.prototype.umod = function(We) {
      return this.divmod(We, "mod", !0).mod;
    }, Ve.prototype.divRound = function(We) {
      var Xe = this.divmod(We);
      if (Xe.mod.isZero())
        return Xe.div;
      var rt = Xe.div.negative !== 0 ? Xe.mod.isub(We) : Xe.mod, ot = We.ushrn(1), ft = We.andln(1), mt = rt.cmp(ot);
      return mt < 0 || ft === 1 && mt === 0 ? Xe.div : Xe.div.negative !== 0 ? Xe.div.isubn(1) : Xe.div.iaddn(1);
    }, Ve.prototype.modn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = (1 << 26) % We, rt = 0, ot = (this || _global$3).length - 1; ot >= 0; ot--)
        rt = (Xe * rt + ((this || _global$3).words[ot] | 0)) % We;
      return rt;
    }, Ve.prototype.idivn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = 0, rt = (this || _global$3).length - 1; rt >= 0; rt--) {
        var ot = ((this || _global$3).words[rt] | 0) + Xe * 67108864;
        (this || _global$3).words[rt] = ot / We | 0, Xe = ot % We;
      }
      return this.strip();
    }, Ve.prototype.divn = function(We) {
      return this.clone().idivn(We);
    }, Ve.prototype.egcd = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$3, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = new Ve(0), yt = new Ve(1), pt = 0; Xe.isEven() && rt.isEven(); )
        Xe.iushrn(1), rt.iushrn(1), ++pt;
      for (var Ge = rt.clone(), ct = Xe.clone(); !Xe.isZero(); ) {
        for (var Mt = 0, St = 1; !(Xe.words[0] & St) && Mt < 26; ++Mt, St <<= 1)
          ;
        if (Mt > 0)
          for (Xe.iushrn(Mt); Mt-- > 0; )
            (ot.isOdd() || ft.isOdd()) && (ot.iadd(Ge), ft.isub(ct)), ot.iushrn(1), ft.iushrn(1);
        for (var At = 0, Nt = 1; !(rt.words[0] & Nt) && At < 26; ++At, Nt <<= 1)
          ;
        if (At > 0)
          for (rt.iushrn(At); At-- > 0; )
            (mt.isOdd() || yt.isOdd()) && (mt.iadd(Ge), yt.isub(ct)), mt.iushrn(1), yt.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(mt), ft.isub(yt)) : (rt.isub(Xe), mt.isub(ot), yt.isub(ft));
      }
      return {
        a: mt,
        b: yt,
        gcd: rt.iushln(pt)
      };
    }, Ve.prototype._invmp = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$3, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = rt.clone(); Xe.cmpn(1) > 0 && rt.cmpn(1) > 0; ) {
        for (var yt = 0, pt = 1; !(Xe.words[0] & pt) && yt < 26; ++yt, pt <<= 1)
          ;
        if (yt > 0)
          for (Xe.iushrn(yt); yt-- > 0; )
            ot.isOdd() && ot.iadd(mt), ot.iushrn(1);
        for (var Ge = 0, ct = 1; !(rt.words[0] & ct) && Ge < 26; ++Ge, ct <<= 1)
          ;
        if (Ge > 0)
          for (rt.iushrn(Ge); Ge-- > 0; )
            ft.isOdd() && ft.iadd(mt), ft.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(ft)) : (rt.isub(Xe), ft.isub(ot));
      }
      var Mt;
      return Xe.cmpn(1) === 0 ? Mt = ot : Mt = ft, Mt.cmpn(0) < 0 && Mt.iadd(We), Mt;
    }, Ve.prototype.gcd = function(We) {
      if (this.isZero())
        return We.abs();
      if (We.isZero())
        return this.abs();
      var Xe = this.clone(), rt = We.clone();
      Xe.negative = 0, rt.negative = 0;
      for (var ot = 0; Xe.isEven() && rt.isEven(); ot++)
        Xe.iushrn(1), rt.iushrn(1);
      do {
        for (; Xe.isEven(); )
          Xe.iushrn(1);
        for (; rt.isEven(); )
          rt.iushrn(1);
        var ft = Xe.cmp(rt);
        if (ft < 0) {
          var mt = Xe;
          Xe = rt, rt = mt;
        } else if (ft === 0 || rt.cmpn(1) === 0)
          break;
        Xe.isub(rt);
      } while (!0);
      return rt.iushln(ot);
    }, Ve.prototype.invm = function(We) {
      return this.egcd(We).a.umod(We);
    }, Ve.prototype.isEven = function() {
      return ((this || _global$3).words[0] & 1) === 0;
    }, Ve.prototype.isOdd = function() {
      return ((this || _global$3).words[0] & 1) === 1;
    }, Ve.prototype.andln = function(We) {
      return (this || _global$3).words[0] & We;
    }, Ve.prototype.bincn = function(We) {
      Fe(typeof We == "number");
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$3).length <= rt)
        return this._expand(rt + 1), (this || _global$3).words[rt] |= ot, this || _global$3;
      for (var ft = ot, mt = rt; ft !== 0 && mt < (this || _global$3).length; mt++) {
        var yt = (this || _global$3).words[mt] | 0;
        yt += ft, ft = yt >>> 26, yt &= 67108863, (this || _global$3).words[mt] = yt;
      }
      return ft !== 0 && ((this || _global$3).words[mt] = ft, (this || _global$3).length++), this || _global$3;
    }, Ve.prototype.isZero = function() {
      return (this || _global$3).length === 1 && (this || _global$3).words[0] === 0;
    }, Ve.prototype.cmpn = function(We) {
      var Xe = We < 0;
      if ((this || _global$3).negative !== 0 && !Xe)
        return -1;
      if ((this || _global$3).negative === 0 && Xe)
        return 1;
      this.strip();
      var rt;
      if ((this || _global$3).length > 1)
        rt = 1;
      else {
        Xe && (We = -We), Fe(We <= 67108863, "Number is too big");
        var ot = (this || _global$3).words[0] | 0;
        rt = ot === We ? 0 : ot < We ? -1 : 1;
      }
      return (this || _global$3).negative !== 0 ? -rt | 0 : rt;
    }, Ve.prototype.cmp = function(We) {
      if ((this || _global$3).negative !== 0 && We.negative === 0)
        return -1;
      if ((this || _global$3).negative === 0 && We.negative !== 0)
        return 1;
      var Xe = this.ucmp(We);
      return (this || _global$3).negative !== 0 ? -Xe | 0 : Xe;
    }, Ve.prototype.ucmp = function(We) {
      if ((this || _global$3).length > We.length)
        return 1;
      if ((this || _global$3).length < We.length)
        return -1;
      for (var Xe = 0, rt = (this || _global$3).length - 1; rt >= 0; rt--) {
        var ot = (this || _global$3).words[rt] | 0, ft = We.words[rt] | 0;
        if (ot !== ft) {
          ot < ft ? Xe = -1 : ot > ft && (Xe = 1);
          break;
        }
      }
      return Xe;
    }, Ve.prototype.gtn = function(We) {
      return this.cmpn(We) === 1;
    }, Ve.prototype.gt = function(We) {
      return this.cmp(We) === 1;
    }, Ve.prototype.gten = function(We) {
      return this.cmpn(We) >= 0;
    }, Ve.prototype.gte = function(We) {
      return this.cmp(We) >= 0;
    }, Ve.prototype.ltn = function(We) {
      return this.cmpn(We) === -1;
    }, Ve.prototype.lt = function(We) {
      return this.cmp(We) === -1;
    }, Ve.prototype.lten = function(We) {
      return this.cmpn(We) <= 0;
    }, Ve.prototype.lte = function(We) {
      return this.cmp(We) <= 0;
    }, Ve.prototype.eqn = function(We) {
      return this.cmpn(We) === 0;
    }, Ve.prototype.eq = function(We) {
      return this.cmp(We) === 0;
    }, Ve.red = function(We) {
      return new Ot(We);
    }, Ve.prototype.toRed = function(We) {
      return Fe(!(this || _global$3).red, "Already a number in reduction context"), Fe((this || _global$3).negative === 0, "red works only with positives"), We.convertTo(this || _global$3)._forceRed(We);
    }, Ve.prototype.fromRed = function() {
      return Fe((this || _global$3).red, "fromRed works only with numbers in reduction context"), (this || _global$3).red.convertFrom(this || _global$3);
    }, Ve.prototype._forceRed = function(We) {
      return (this || _global$3).red = We, this || _global$3;
    }, Ve.prototype.forceRed = function(We) {
      return Fe(!(this || _global$3).red, "Already a number in reduction context"), this._forceRed(We);
    }, Ve.prototype.redAdd = function(We) {
      return Fe((this || _global$3).red, "redAdd works only with red numbers"), (this || _global$3).red.add(this || _global$3, We);
    }, Ve.prototype.redIAdd = function(We) {
      return Fe((this || _global$3).red, "redIAdd works only with red numbers"), (this || _global$3).red.iadd(this || _global$3, We);
    }, Ve.prototype.redSub = function(We) {
      return Fe((this || _global$3).red, "redSub works only with red numbers"), (this || _global$3).red.sub(this || _global$3, We);
    }, Ve.prototype.redISub = function(We) {
      return Fe((this || _global$3).red, "redISub works only with red numbers"), (this || _global$3).red.isub(this || _global$3, We);
    }, Ve.prototype.redShl = function(We) {
      return Fe((this || _global$3).red, "redShl works only with red numbers"), (this || _global$3).red.shl(this || _global$3, We);
    }, Ve.prototype.redMul = function(We) {
      return Fe((this || _global$3).red, "redMul works only with red numbers"), (this || _global$3).red._verify2(this || _global$3, We), (this || _global$3).red.mul(this || _global$3, We);
    }, Ve.prototype.redIMul = function(We) {
      return Fe((this || _global$3).red, "redMul works only with red numbers"), (this || _global$3).red._verify2(this || _global$3, We), (this || _global$3).red.imul(this || _global$3, We);
    }, Ve.prototype.redSqr = function() {
      return Fe((this || _global$3).red, "redSqr works only with red numbers"), (this || _global$3).red._verify1(this || _global$3), (this || _global$3).red.sqr(this || _global$3);
    }, Ve.prototype.redISqr = function() {
      return Fe((this || _global$3).red, "redISqr works only with red numbers"), (this || _global$3).red._verify1(this || _global$3), (this || _global$3).red.isqr(this || _global$3);
    }, Ve.prototype.redSqrt = function() {
      return Fe((this || _global$3).red, "redSqrt works only with red numbers"), (this || _global$3).red._verify1(this || _global$3), (this || _global$3).red.sqrt(this || _global$3);
    }, Ve.prototype.redInvm = function() {
      return Fe((this || _global$3).red, "redInvm works only with red numbers"), (this || _global$3).red._verify1(this || _global$3), (this || _global$3).red.invm(this || _global$3);
    }, Ve.prototype.redNeg = function() {
      return Fe((this || _global$3).red, "redNeg works only with red numbers"), (this || _global$3).red._verify1(this || _global$3), (this || _global$3).red.neg(this || _global$3);
    }, Ve.prototype.redPow = function(We) {
      return Fe((this || _global$3).red && !We.red, "redPow(normalNum)"), (this || _global$3).red._verify1(this || _global$3), (this || _global$3).red.pow(this || _global$3, We);
    };
    var Rt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ct(gt, We) {
      (this || _global$3).name = gt, (this || _global$3).p = new Ve(We, 16), (this || _global$3).n = (this || _global$3).p.bitLength(), (this || _global$3).k = new Ve(1).iushln((this || _global$3).n).isub((this || _global$3).p), (this || _global$3).tmp = this._tmp();
    }
    Ct.prototype._tmp = function() {
      var We = new Ve(null);
      return We.words = new Array(Math.ceil((this || _global$3).n / 13)), We;
    }, Ct.prototype.ireduce = function(We) {
      var Xe = We, rt;
      do
        this.split(Xe, (this || _global$3).tmp), Xe = this.imulK(Xe), Xe = Xe.iadd((this || _global$3).tmp), rt = Xe.bitLength();
      while (rt > (this || _global$3).n);
      var ot = rt < (this || _global$3).n ? -1 : Xe.ucmp((this || _global$3).p);
      return ot === 0 ? (Xe.words[0] = 0, Xe.length = 1) : ot > 0 ? Xe.isub((this || _global$3).p) : Xe.strip !== void 0 ? Xe.strip() : Xe._strip(), Xe;
    }, Ct.prototype.split = function(We, Xe) {
      We.iushrn((this || _global$3).n, 0, Xe);
    }, Ct.prototype.imulK = function(We) {
      return We.imul((this || _global$3).k);
    };
    function Zt() {
      Ct.call(this || _global$3, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    Ke(Zt, Ct), Zt.prototype.split = function(We, Xe) {
      for (var rt = 4194303, ot = Math.min(We.length, 9), ft = 0; ft < ot; ft++)
        Xe.words[ft] = We.words[ft];
      if (Xe.length = ot, We.length <= 9) {
        We.words[0] = 0, We.length = 1;
        return;
      }
      var mt = We.words[9];
      for (Xe.words[Xe.length++] = mt & rt, ft = 10; ft < We.length; ft++) {
        var yt = We.words[ft] | 0;
        We.words[ft - 10] = (yt & rt) << 4 | mt >>> 22, mt = yt;
      }
      mt >>>= 22, We.words[ft - 10] = mt, mt === 0 && We.length > 10 ? We.length -= 10 : We.length -= 9;
    }, Zt.prototype.imulK = function(We) {
      We.words[We.length] = 0, We.words[We.length + 1] = 0, We.length += 2;
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = We.words[rt] | 0;
        Xe += ot * 977, We.words[rt] = Xe & 67108863, Xe = ot * 64 + (Xe / 67108864 | 0);
      }
      return We.words[We.length - 1] === 0 && (We.length--, We.words[We.length - 1] === 0 && We.length--), We;
    };
    function Lt() {
      Ct.call(this || _global$3, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    Ke(Lt, Ct);
    function Ut() {
      Ct.call(this || _global$3, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    Ke(Ut, Ct);
    function Pt() {
      Ct.call(this || _global$3, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    Ke(Pt, Ct), Pt.prototype.imulK = function(We) {
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = (We.words[rt] | 0) * 19 + Xe, ft = ot & 67108863;
        ot >>>= 26, We.words[rt] = ft, Xe = ot;
      }
      return Xe !== 0 && (We.words[We.length++] = Xe), We;
    }, Ve._prime = function(We) {
      if (Rt[We])
        return Rt[We];
      var Xe;
      if (We === "k256")
        Xe = new Zt();
      else if (We === "p224")
        Xe = new Lt();
      else if (We === "p192")
        Xe = new Ut();
      else if (We === "p25519")
        Xe = new Pt();
      else
        throw new Error("Unknown prime " + We);
      return Rt[We] = Xe, Xe;
    };
    function Ot(gt) {
      if (typeof gt == "string") {
        var We = Ve._prime(gt);
        (this || _global$3).m = We.p, (this || _global$3).prime = We;
      } else
        Fe(gt.gtn(1), "modulus must be greater than 1"), (this || _global$3).m = gt, (this || _global$3).prime = null;
    }
    Ot.prototype._verify1 = function(We) {
      Fe(We.negative === 0, "red works only with positives"), Fe(We.red, "red works only with red numbers");
    }, Ot.prototype._verify2 = function(We, Xe) {
      Fe((We.negative | Xe.negative) === 0, "red works only with positives"), Fe(We.red && We.red === Xe.red, "red works only with red numbers");
    }, Ot.prototype.imod = function(We) {
      return (this || _global$3).prime ? (this || _global$3).prime.ireduce(We)._forceRed(this || _global$3) : We.umod((this || _global$3).m)._forceRed(this || _global$3);
    }, Ot.prototype.neg = function(We) {
      return We.isZero() ? We.clone() : (this || _global$3).m.sub(We)._forceRed(this || _global$3);
    }, Ot.prototype.add = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.add(Xe);
      return rt.cmp((this || _global$3).m) >= 0 && rt.isub((this || _global$3).m), rt._forceRed(this || _global$3);
    }, Ot.prototype.iadd = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.iadd(Xe);
      return rt.cmp((this || _global$3).m) >= 0 && rt.isub((this || _global$3).m), rt;
    }, Ot.prototype.sub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.sub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$3).m), rt._forceRed(this || _global$3);
    }, Ot.prototype.isub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.isub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$3).m), rt;
    }, Ot.prototype.shl = function(We, Xe) {
      return this._verify1(We), this.imod(We.ushln(Xe));
    }, Ot.prototype.imul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.imul(Xe));
    }, Ot.prototype.mul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.mul(Xe));
    }, Ot.prototype.isqr = function(We) {
      return this.imul(We, We.clone());
    }, Ot.prototype.sqr = function(We) {
      return this.mul(We, We);
    }, Ot.prototype.sqrt = function(We) {
      if (We.isZero())
        return We.clone();
      var Xe = (this || _global$3).m.andln(3);
      if (Fe(Xe % 2 === 1), Xe === 3) {
        var rt = (this || _global$3).m.add(new Ve(1)).iushrn(2);
        return this.pow(We, rt);
      }
      for (var ot = (this || _global$3).m.subn(1), ft = 0; !ot.isZero() && ot.andln(1) === 0; )
        ft++, ot.iushrn(1);
      Fe(!ot.isZero());
      var mt = new Ve(1).toRed(this || _global$3), yt = mt.redNeg(), pt = (this || _global$3).m.subn(1).iushrn(1), Ge = (this || _global$3).m.bitLength();
      for (Ge = new Ve(2 * Ge * Ge).toRed(this || _global$3); this.pow(Ge, pt).cmp(yt) !== 0; )
        Ge.redIAdd(yt);
      for (var ct = this.pow(Ge, ot), Mt = this.pow(We, ot.addn(1).iushrn(1)), St = this.pow(We, ot), At = ft; St.cmp(mt) !== 0; ) {
        for (var Nt = St, qt = 0; Nt.cmp(mt) !== 0; qt++)
          Nt = Nt.redSqr();
        Fe(qt < At);
        var Qt = this.pow(ct, new Ve(1).iushln(At - qt - 1));
        Mt = Mt.redMul(Qt), ct = Qt.redSqr(), St = St.redMul(ct), At = qt;
      }
      return Mt;
    }, Ot.prototype.invm = function(We) {
      var Xe = We._invmp((this || _global$3).m);
      return Xe.negative !== 0 ? (Xe.negative = 0, this.imod(Xe).redNeg()) : this.imod(Xe);
    }, Ot.prototype.pow = function(We, Xe) {
      if (Xe.isZero())
        return new Ve(1).toRed(this || _global$3);
      if (Xe.cmpn(1) === 0)
        return We.clone();
      var rt = 4, ot = new Array(1 << rt);
      ot[0] = new Ve(1).toRed(this || _global$3), ot[1] = We;
      for (var ft = 2; ft < ot.length; ft++)
        ot[ft] = this.mul(ot[ft - 1], We);
      var mt = ot[0], yt = 0, pt = 0, Ge = Xe.bitLength() % 26;
      for (Ge === 0 && (Ge = 26), ft = Xe.length - 1; ft >= 0; ft--) {
        for (var ct = Xe.words[ft], Mt = Ge - 1; Mt >= 0; Mt--) {
          var St = ct >> Mt & 1;
          if (mt !== ot[0] && (mt = this.sqr(mt)), St === 0 && yt === 0) {
            pt = 0;
            continue;
          }
          yt <<= 1, yt |= St, pt++, !(pt !== rt && (ft !== 0 || Mt !== 0)) && (mt = this.mul(mt, ot[yt]), pt = 0, yt = 0);
        }
        Ge = 26;
      }
      return mt;
    }, Ot.prototype.convertTo = function(We) {
      var Xe = We.umod((this || _global$3).m);
      return Xe === We ? Xe.clone() : Xe;
    }, Ot.prototype.convertFrom = function(We) {
      var Xe = We.clone();
      return Xe.red = null, Xe;
    }, Ve.mont = function(We) {
      return new Ft(We);
    };
    function Ft(gt) {
      Ot.call(this || _global$3, gt), (this || _global$3).shift = (this || _global$3).m.bitLength(), (this || _global$3).shift % 26 !== 0 && ((this || _global$3).shift += 26 - (this || _global$3).shift % 26), (this || _global$3).r = new Ve(1).iushln((this || _global$3).shift), (this || _global$3).r2 = this.imod((this || _global$3).r.sqr()), (this || _global$3).rinv = (this || _global$3).r._invmp((this || _global$3).m), (this || _global$3).minv = (this || _global$3).rinv.mul((this || _global$3).r).isubn(1).div((this || _global$3).m), (this || _global$3).minv = (this || _global$3).minv.umod((this || _global$3).r), (this || _global$3).minv = (this || _global$3).r.sub((this || _global$3).minv);
    }
    Ke(Ft, Ot), Ft.prototype.convertTo = function(We) {
      return this.imod(We.ushln((this || _global$3).shift));
    }, Ft.prototype.convertFrom = function(We) {
      var Xe = this.imod(We.mul((this || _global$3).rinv));
      return Xe.red = null, Xe;
    }, Ft.prototype.imul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return We.words[0] = 0, We.length = 1, We;
      var rt = We.imul(Xe), ot = rt.maskn((this || _global$3).shift).mul((this || _global$3).minv).imaskn((this || _global$3).shift).mul((this || _global$3).m), ft = rt.isub(ot).iushrn((this || _global$3).shift), mt = ft;
      return ft.cmp((this || _global$3).m) >= 0 ? mt = ft.isub((this || _global$3).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$3).m)), mt._forceRed(this || _global$3);
    }, Ft.prototype.mul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return new Ve(0)._forceRed(this || _global$3);
      var rt = We.mul(Xe), ot = rt.maskn((this || _global$3).shift).mul((this || _global$3).minv).imaskn((this || _global$3).shift).mul((this || _global$3).m), ft = rt.isub(ot).iushrn((this || _global$3).shift), mt = ft;
      return ft.cmp((this || _global$3).m) >= 0 ? mt = ft.isub((this || _global$3).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$3).m)), mt._forceRed(this || _global$3);
    }, Ft.prototype.invm = function(We) {
      var Xe = this.imod(We._invmp((this || _global$3).m).mul((this || _global$3).r2));
      return Xe._forceRed(this || _global$3);
    };
  }(module$1, exports$b2)), module$1.exports;
}
var exports$a2 = {}, _dewExec$92 = !1, _global$22 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$92() {
  if (_dewExec$92)
    return exports$a2;
  _dewExec$92 = !0;
  var $e = buffer.Buffer, Ze = dew$y(), Fe = dew$a2();
  exports$a2 = function(at) {
    return new Ve(at);
  };
  var Ke = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  Ke.p224 = Ke.secp224r1, Ke.p256 = Ke.secp256r1 = Ke.prime256v1, Ke.p192 = Ke.secp192r1 = Ke.prime192v1, Ke.p384 = Ke.secp384r1, Ke.p521 = Ke.secp521r1;
  function Ve(Qe) {
    (this || _global$22).curveType = Ke[Qe], (this || _global$22).curveType || ((this || _global$22).curveType = {
      name: Qe
    }), (this || _global$22).curve = new Ze.ec((this || _global$22).curveType.name), (this || _global$22).keys = void 0;
  }
  Ve.prototype.generateKeys = function(Qe, at) {
    return (this || _global$22).keys = (this || _global$22).curve.genKeyPair(), this.getPublicKey(Qe, at);
  }, Ve.prototype.computeSecret = function(Qe, at, ut) {
    at = at || "utf8", $e.isBuffer(Qe) || (Qe = new $e(Qe, at));
    var lt = (this || _global$22).curve.keyFromPublic(Qe).getPublic(), dt = lt.mul((this || _global$22).keys.getPrivate()).getX();
    return Je(dt, ut, (this || _global$22).curveType.byteLength);
  }, Ve.prototype.getPublicKey = function(Qe, at) {
    var ut = (this || _global$22).keys.getPublic(at === "compressed", !0);
    return at === "hybrid" && (ut[ut.length - 1] % 2 ? ut[0] = 7 : ut[0] = 6), Je(ut, Qe);
  }, Ve.prototype.getPrivateKey = function(Qe) {
    return Je((this || _global$22).keys.getPrivate(), Qe);
  }, Ve.prototype.setPublicKey = function(Qe, at) {
    return at = at || "utf8", $e.isBuffer(Qe) || (Qe = new $e(Qe, at)), (this || _global$22).keys._importPublic(Qe), this || _global$22;
  }, Ve.prototype.setPrivateKey = function(Qe, at) {
    at = at || "utf8", $e.isBuffer(Qe) || (Qe = new $e(Qe, at));
    var ut = new Fe(Qe);
    return ut = ut.toString(16), (this || _global$22).keys = (this || _global$22).curve.genKeyPair(), (this || _global$22).keys._importPrivate(ut), this || _global$22;
  };
  function Je(Qe, at, ut) {
    Array.isArray(Qe) || (Qe = Qe.toArray());
    var lt = new $e(Qe);
    if (ut && lt.length < ut) {
      var dt = new $e(ut - lt.length);
      dt.fill(0), lt = $e.concat([dt, lt]);
    }
    return at ? lt.toString(at) : lt;
  }
  return exports$a2;
}
var exports$92 = {}, _dewExec$82 = !1;
function dew$82() {
  if (_dewExec$82)
    return exports$92;
  _dewExec$82 = !0;
  var $e = dew$2y(), Ze = dew$2P().Buffer;
  exports$92 = function(Ke, Ve) {
    for (var Je = Ze.alloc(0), Qe = 0, at; Je.length < Ve; )
      at = Fe(Qe++), Je = Ze.concat([Je, $e("sha1").update(Ke).update(at).digest()]);
    return Je.slice(0, Ve);
  };
  function Fe(Ke) {
    var Ve = Ze.allocUnsafe(4);
    return Ve.writeUInt32BE(Ke, 0), Ve;
  }
  return exports$92;
}
var exports$82 = {}, _dewExec$72 = !1;
function dew$72() {
  return _dewExec$72 || (_dewExec$72 = !0, exports$82 = function(Ze, Fe) {
    for (var Ke = Ze.length, Ve = -1; ++Ve < Ke; )
      Ze[Ve] ^= Fe[Ve];
    return Ze;
  }), exports$82;
}
var exports$72 = {}, _dewExec$62 = !1, module = {
  exports: exports$72
}, _global$12 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$62() {
  return _dewExec$62 || (_dewExec$62 = !0, function($e, Ze) {
    function Fe(gt, We) {
      if (!gt)
        throw new Error(We || "Assertion failed");
    }
    function Ke(gt, We) {
      gt.super_ = We;
      var Xe = function() {
      };
      Xe.prototype = We.prototype, gt.prototype = new Xe(), gt.prototype.constructor = gt;
    }
    function Ve(gt, We, Xe) {
      if (Ve.isBN(gt))
        return gt;
      (this || _global$12).negative = 0, (this || _global$12).words = null, (this || _global$12).length = 0, (this || _global$12).red = null, gt !== null && ((We === "le" || We === "be") && (Xe = We, We = 10), this._init(gt || 0, We || 10, Xe || "be"));
    }
    typeof $e == "object" ? $e.exports = Ve : Ze.BN = Ve, Ve.BN = Ve, Ve.wordSize = 26;
    var Je;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Je = window.Buffer : Je = buffer.Buffer;
    } catch {
    }
    Ve.isBN = function(We) {
      return We instanceof Ve ? !0 : We !== null && typeof We == "object" && We.constructor.wordSize === Ve.wordSize && Array.isArray(We.words);
    }, Ve.max = function(We, Xe) {
      return We.cmp(Xe) > 0 ? We : Xe;
    }, Ve.min = function(We, Xe) {
      return We.cmp(Xe) < 0 ? We : Xe;
    }, Ve.prototype._init = function(We, Xe, rt) {
      if (typeof We == "number")
        return this._initNumber(We, Xe, rt);
      if (typeof We == "object")
        return this._initArray(We, Xe, rt);
      Xe === "hex" && (Xe = 16), Fe(Xe === (Xe | 0) && Xe >= 2 && Xe <= 36), We = We.toString().replace(/\s+/g, "");
      var ot = 0;
      We[0] === "-" && (ot++, (this || _global$12).negative = 1), ot < We.length && (Xe === 16 ? this._parseHex(We, ot, rt) : (this._parseBase(We, Xe, ot), rt === "le" && this._initArray(this.toArray(), Xe, rt)));
    }, Ve.prototype._initNumber = function(We, Xe, rt) {
      We < 0 && ((this || _global$12).negative = 1, We = -We), We < 67108864 ? ((this || _global$12).words = [We & 67108863], (this || _global$12).length = 1) : We < 4503599627370496 ? ((this || _global$12).words = [We & 67108863, We / 67108864 & 67108863], (this || _global$12).length = 2) : (Fe(We < 9007199254740992), (this || _global$12).words = [We & 67108863, We / 67108864 & 67108863, 1], (this || _global$12).length = 3), rt === "le" && this._initArray(this.toArray(), Xe, rt);
    }, Ve.prototype._initArray = function(We, Xe, rt) {
      if (Fe(typeof We.length == "number"), We.length <= 0)
        return (this || _global$12).words = [0], (this || _global$12).length = 1, this || _global$12;
      (this || _global$12).length = Math.ceil(We.length / 3), (this || _global$12).words = new Array((this || _global$12).length);
      for (var ot = 0; ot < (this || _global$12).length; ot++)
        (this || _global$12).words[ot] = 0;
      var ft, mt, yt = 0;
      if (rt === "be")
        for (ot = We.length - 1, ft = 0; ot >= 0; ot -= 3)
          mt = We[ot] | We[ot - 1] << 8 | We[ot - 2] << 16, (this || _global$12).words[ft] |= mt << yt & 67108863, (this || _global$12).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      else if (rt === "le")
        for (ot = 0, ft = 0; ot < We.length; ot += 3)
          mt = We[ot] | We[ot + 1] << 8 | We[ot + 2] << 16, (this || _global$12).words[ft] |= mt << yt & 67108863, (this || _global$12).words[ft + 1] = mt >>> 26 - yt & 67108863, yt += 24, yt >= 26 && (yt -= 26, ft++);
      return this.strip();
    };
    function Qe(gt, We) {
      var Xe = gt.charCodeAt(We);
      return Xe >= 65 && Xe <= 70 ? Xe - 55 : Xe >= 97 && Xe <= 102 ? Xe - 87 : Xe - 48 & 15;
    }
    function at(gt, We, Xe) {
      var rt = Qe(gt, Xe);
      return Xe - 1 >= We && (rt |= Qe(gt, Xe - 1) << 4), rt;
    }
    Ve.prototype._parseHex = function(We, Xe, rt) {
      (this || _global$12).length = Math.ceil((We.length - Xe) / 6), (this || _global$12).words = new Array((this || _global$12).length);
      for (var ot = 0; ot < (this || _global$12).length; ot++)
        (this || _global$12).words[ot] = 0;
      var ft = 0, mt = 0, yt;
      if (rt === "be")
        for (ot = We.length - 1; ot >= Xe; ot -= 2)
          yt = at(We, Xe, ot) << ft, (this || _global$12).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$12).words[mt] |= yt >>> 26) : ft += 8;
      else {
        var pt = We.length - Xe;
        for (ot = pt % 2 === 0 ? Xe + 1 : Xe; ot < We.length; ot += 2)
          yt = at(We, Xe, ot) << ft, (this || _global$12).words[mt] |= yt & 67108863, ft >= 18 ? (ft -= 18, mt += 1, (this || _global$12).words[mt] |= yt >>> 26) : ft += 8;
      }
      this.strip();
    };
    function ut(gt, We, Xe, rt) {
      for (var ot = 0, ft = Math.min(gt.length, Xe), mt = We; mt < ft; mt++) {
        var yt = gt.charCodeAt(mt) - 48;
        ot *= rt, yt >= 49 ? ot += yt - 49 + 10 : yt >= 17 ? ot += yt - 17 + 10 : ot += yt;
      }
      return ot;
    }
    Ve.prototype._parseBase = function(We, Xe, rt) {
      (this || _global$12).words = [0], (this || _global$12).length = 1;
      for (var ot = 0, ft = 1; ft <= 67108863; ft *= Xe)
        ot++;
      ot--, ft = ft / Xe | 0;
      for (var mt = We.length - rt, yt = mt % ot, pt = Math.min(mt, mt - yt) + rt, Ge = 0, ct = rt; ct < pt; ct += ot)
        Ge = ut(We, ct, ct + ot, Xe), this.imuln(ft), (this || _global$12).words[0] + Ge < 67108864 ? (this || _global$12).words[0] += Ge : this._iaddn(Ge);
      if (yt !== 0) {
        var Mt = 1;
        for (Ge = ut(We, ct, We.length, Xe), ct = 0; ct < yt; ct++)
          Mt *= Xe;
        this.imuln(Mt), (this || _global$12).words[0] + Ge < 67108864 ? (this || _global$12).words[0] += Ge : this._iaddn(Ge);
      }
      this.strip();
    }, Ve.prototype.copy = function(We) {
      We.words = new Array((this || _global$12).length);
      for (var Xe = 0; Xe < (this || _global$12).length; Xe++)
        We.words[Xe] = (this || _global$12).words[Xe];
      We.length = (this || _global$12).length, We.negative = (this || _global$12).negative, We.red = (this || _global$12).red;
    }, Ve.prototype.clone = function() {
      var We = new Ve(null);
      return this.copy(We), We;
    }, Ve.prototype._expand = function(We) {
      for (; (this || _global$12).length < We; )
        (this || _global$12).words[(this || _global$12).length++] = 0;
      return this || _global$12;
    }, Ve.prototype.strip = function() {
      for (; (this || _global$12).length > 1 && (this || _global$12).words[(this || _global$12).length - 1] === 0; )
        (this || _global$12).length--;
      return this._normSign();
    }, Ve.prototype._normSign = function() {
      return (this || _global$12).length === 1 && (this || _global$12).words[0] === 0 && ((this || _global$12).negative = 0), this || _global$12;
    }, Ve.prototype.inspect = function() {
      return ((this || _global$12).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var lt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], dt = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], bt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    Ve.prototype.toString = function(We, Xe) {
      We = We || 10, Xe = Xe | 0 || 1;
      var rt;
      if (We === 16 || We === "hex") {
        rt = "";
        for (var ot = 0, ft = 0, mt = 0; mt < (this || _global$12).length; mt++) {
          var yt = (this || _global$12).words[mt], pt = ((yt << ot | ft) & 16777215).toString(16);
          ft = yt >>> 24 - ot & 16777215, ft !== 0 || mt !== (this || _global$12).length - 1 ? rt = lt[6 - pt.length] + pt + rt : rt = pt + rt, ot += 2, ot >= 26 && (ot -= 26, mt--);
        }
        for (ft !== 0 && (rt = ft.toString(16) + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$12).negative !== 0 && (rt = "-" + rt), rt;
      }
      if (We === (We | 0) && We >= 2 && We <= 36) {
        var Ge = dt[We], ct = bt[We];
        rt = "";
        var Mt = this.clone();
        for (Mt.negative = 0; !Mt.isZero(); ) {
          var St = Mt.modn(ct).toString(We);
          Mt = Mt.idivn(ct), Mt.isZero() ? rt = St + rt : rt = lt[Ge - St.length] + St + rt;
        }
        for (this.isZero() && (rt = "0" + rt); rt.length % Xe !== 0; )
          rt = "0" + rt;
        return (this || _global$12).negative !== 0 && (rt = "-" + rt), rt;
      }
      Fe(!1, "Base should be between 2 and 36");
    }, Ve.prototype.toNumber = function() {
      var We = (this || _global$12).words[0];
      return (this || _global$12).length === 2 ? We += (this || _global$12).words[1] * 67108864 : (this || _global$12).length === 3 && (this || _global$12).words[2] === 1 ? We += 4503599627370496 + (this || _global$12).words[1] * 67108864 : (this || _global$12).length > 2 && Fe(!1, "Number can only safely store up to 53 bits"), (this || _global$12).negative !== 0 ? -We : We;
    }, Ve.prototype.toJSON = function() {
      return this.toString(16);
    }, Ve.prototype.toBuffer = function(We, Xe) {
      return Fe(typeof Je < "u"), this.toArrayLike(Je, We, Xe);
    }, Ve.prototype.toArray = function(We, Xe) {
      return this.toArrayLike(Array, We, Xe);
    }, Ve.prototype.toArrayLike = function(We, Xe, rt) {
      var ot = this.byteLength(), ft = rt || Math.max(1, ot);
      Fe(ot <= ft, "byte array longer than desired length"), Fe(ft > 0, "Requested array length <= 0"), this.strip();
      var mt = Xe === "le", yt = new We(ft), pt, Ge, ct = this.clone();
      if (mt) {
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[Ge] = pt;
        for (; Ge < ft; Ge++)
          yt[Ge] = 0;
      } else {
        for (Ge = 0; Ge < ft - ot; Ge++)
          yt[Ge] = 0;
        for (Ge = 0; !ct.isZero(); Ge++)
          pt = ct.andln(255), ct.iushrn(8), yt[ft - Ge - 1] = pt;
      }
      return yt;
    }, Math.clz32 ? Ve.prototype._countBits = function(We) {
      return 32 - Math.clz32(We);
    } : Ve.prototype._countBits = function(We) {
      var Xe = We, rt = 0;
      return Xe >= 4096 && (rt += 13, Xe >>>= 13), Xe >= 64 && (rt += 7, Xe >>>= 7), Xe >= 8 && (rt += 4, Xe >>>= 4), Xe >= 2 && (rt += 2, Xe >>>= 2), rt + Xe;
    }, Ve.prototype._zeroBits = function(We) {
      if (We === 0)
        return 26;
      var Xe = We, rt = 0;
      return Xe & 8191 || (rt += 13, Xe >>>= 13), Xe & 127 || (rt += 7, Xe >>>= 7), Xe & 15 || (rt += 4, Xe >>>= 4), Xe & 3 || (rt += 2, Xe >>>= 2), Xe & 1 || rt++, rt;
    }, Ve.prototype.bitLength = function() {
      var We = (this || _global$12).words[(this || _global$12).length - 1], Xe = this._countBits(We);
      return ((this || _global$12).length - 1) * 26 + Xe;
    };
    function $t(gt) {
      for (var We = new Array(gt.bitLength()), Xe = 0; Xe < We.length; Xe++) {
        var rt = Xe / 26 | 0, ot = Xe % 26;
        We[Xe] = (gt.words[rt] & 1 << ot) >>> ot;
      }
      return We;
    }
    Ve.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var We = 0, Xe = 0; Xe < (this || _global$12).length; Xe++) {
        var rt = this._zeroBits((this || _global$12).words[Xe]);
        if (We += rt, rt !== 26)
          break;
      }
      return We;
    }, Ve.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Ve.prototype.toTwos = function(We) {
      return (this || _global$12).negative !== 0 ? this.abs().inotn(We).iaddn(1) : this.clone();
    }, Ve.prototype.fromTwos = function(We) {
      return this.testn(We - 1) ? this.notn(We).iaddn(1).ineg() : this.clone();
    }, Ve.prototype.isNeg = function() {
      return (this || _global$12).negative !== 0;
    }, Ve.prototype.neg = function() {
      return this.clone().ineg();
    }, Ve.prototype.ineg = function() {
      return this.isZero() || ((this || _global$12).negative ^= 1), this || _global$12;
    }, Ve.prototype.iuor = function(We) {
      for (; (this || _global$12).length < We.length; )
        (this || _global$12).words[(this || _global$12).length++] = 0;
      for (var Xe = 0; Xe < We.length; Xe++)
        (this || _global$12).words[Xe] = (this || _global$12).words[Xe] | We.words[Xe];
      return this.strip();
    }, Ve.prototype.ior = function(We) {
      return Fe(((this || _global$12).negative | We.negative) === 0), this.iuor(We);
    }, Ve.prototype.or = function(We) {
      return (this || _global$12).length > We.length ? this.clone().ior(We) : We.clone().ior(this || _global$12);
    }, Ve.prototype.uor = function(We) {
      return (this || _global$12).length > We.length ? this.clone().iuor(We) : We.clone().iuor(this || _global$12);
    }, Ve.prototype.iuand = function(We) {
      var Xe;
      (this || _global$12).length > We.length ? Xe = We : Xe = this || _global$12;
      for (var rt = 0; rt < Xe.length; rt++)
        (this || _global$12).words[rt] = (this || _global$12).words[rt] & We.words[rt];
      return (this || _global$12).length = Xe.length, this.strip();
    }, Ve.prototype.iand = function(We) {
      return Fe(((this || _global$12).negative | We.negative) === 0), this.iuand(We);
    }, Ve.prototype.and = function(We) {
      return (this || _global$12).length > We.length ? this.clone().iand(We) : We.clone().iand(this || _global$12);
    }, Ve.prototype.uand = function(We) {
      return (this || _global$12).length > We.length ? this.clone().iuand(We) : We.clone().iuand(this || _global$12);
    }, Ve.prototype.iuxor = function(We) {
      var Xe, rt;
      (this || _global$12).length > We.length ? (Xe = this || _global$12, rt = We) : (Xe = We, rt = this || _global$12);
      for (var ot = 0; ot < rt.length; ot++)
        (this || _global$12).words[ot] = Xe.words[ot] ^ rt.words[ot];
      if ((this || _global$12) !== Xe)
        for (; ot < Xe.length; ot++)
          (this || _global$12).words[ot] = Xe.words[ot];
      return (this || _global$12).length = Xe.length, this.strip();
    }, Ve.prototype.ixor = function(We) {
      return Fe(((this || _global$12).negative | We.negative) === 0), this.iuxor(We);
    }, Ve.prototype.xor = function(We) {
      return (this || _global$12).length > We.length ? this.clone().ixor(We) : We.clone().ixor(this || _global$12);
    }, Ve.prototype.uxor = function(We) {
      return (this || _global$12).length > We.length ? this.clone().iuxor(We) : We.clone().iuxor(this || _global$12);
    }, Ve.prototype.inotn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = Math.ceil(We / 26) | 0, rt = We % 26;
      this._expand(Xe), rt > 0 && Xe--;
      for (var ot = 0; ot < Xe; ot++)
        (this || _global$12).words[ot] = ~(this || _global$12).words[ot] & 67108863;
      return rt > 0 && ((this || _global$12).words[ot] = ~(this || _global$12).words[ot] & 67108863 >> 26 - rt), this.strip();
    }, Ve.prototype.notn = function(We) {
      return this.clone().inotn(We);
    }, Ve.prototype.setn = function(We, Xe) {
      Fe(typeof We == "number" && We >= 0);
      var rt = We / 26 | 0, ot = We % 26;
      return this._expand(rt + 1), Xe ? (this || _global$12).words[rt] = (this || _global$12).words[rt] | 1 << ot : (this || _global$12).words[rt] = (this || _global$12).words[rt] & ~(1 << ot), this.strip();
    }, Ve.prototype.iadd = function(We) {
      var Xe;
      if ((this || _global$12).negative !== 0 && We.negative === 0)
        return (this || _global$12).negative = 0, Xe = this.isub(We), (this || _global$12).negative ^= 1, this._normSign();
      if ((this || _global$12).negative === 0 && We.negative !== 0)
        return We.negative = 0, Xe = this.isub(We), We.negative = 1, Xe._normSign();
      var rt, ot;
      (this || _global$12).length > We.length ? (rt = this || _global$12, ot = We) : (rt = We, ot = this || _global$12);
      for (var ft = 0, mt = 0; mt < ot.length; mt++)
        Xe = (rt.words[mt] | 0) + (ot.words[mt] | 0) + ft, (this || _global$12).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      for (; ft !== 0 && mt < rt.length; mt++)
        Xe = (rt.words[mt] | 0) + ft, (this || _global$12).words[mt] = Xe & 67108863, ft = Xe >>> 26;
      if ((this || _global$12).length = rt.length, ft !== 0)
        (this || _global$12).words[(this || _global$12).length] = ft, (this || _global$12).length++;
      else if (rt !== (this || _global$12))
        for (; mt < rt.length; mt++)
          (this || _global$12).words[mt] = rt.words[mt];
      return this || _global$12;
    }, Ve.prototype.add = function(We) {
      var Xe;
      return We.negative !== 0 && (this || _global$12).negative === 0 ? (We.negative = 0, Xe = this.sub(We), We.negative ^= 1, Xe) : We.negative === 0 && (this || _global$12).negative !== 0 ? ((this || _global$12).negative = 0, Xe = We.sub(this || _global$12), (this || _global$12).negative = 1, Xe) : (this || _global$12).length > We.length ? this.clone().iadd(We) : We.clone().iadd(this || _global$12);
    }, Ve.prototype.isub = function(We) {
      if (We.negative !== 0) {
        We.negative = 0;
        var Xe = this.iadd(We);
        return We.negative = 1, Xe._normSign();
      } else if ((this || _global$12).negative !== 0)
        return (this || _global$12).negative = 0, this.iadd(We), (this || _global$12).negative = 1, this._normSign();
      var rt = this.cmp(We);
      if (rt === 0)
        return (this || _global$12).negative = 0, (this || _global$12).length = 1, (this || _global$12).words[0] = 0, this || _global$12;
      var ot, ft;
      rt > 0 ? (ot = this || _global$12, ft = We) : (ot = We, ft = this || _global$12);
      for (var mt = 0, yt = 0; yt < ft.length; yt++)
        Xe = (ot.words[yt] | 0) - (ft.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$12).words[yt] = Xe & 67108863;
      for (; mt !== 0 && yt < ot.length; yt++)
        Xe = (ot.words[yt] | 0) + mt, mt = Xe >> 26, (this || _global$12).words[yt] = Xe & 67108863;
      if (mt === 0 && yt < ot.length && ot !== (this || _global$12))
        for (; yt < ot.length; yt++)
          (this || _global$12).words[yt] = ot.words[yt];
      return (this || _global$12).length = Math.max((this || _global$12).length, yt), ot !== (this || _global$12) && ((this || _global$12).negative = 1), this.strip();
    }, Ve.prototype.sub = function(We) {
      return this.clone().isub(We);
    };
    function vt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative;
      var rt = gt.length + We.length | 0;
      Xe.length = rt, rt = rt - 1 | 0;
      var ot = gt.words[0] | 0, ft = We.words[0] | 0, mt = ot * ft, yt = mt & 67108863, pt = mt / 67108864 | 0;
      Xe.words[0] = yt;
      for (var Ge = 1; Ge < rt; Ge++) {
        for (var ct = pt >>> 26, Mt = pt & 67108863, St = Math.min(Ge, We.length - 1), At = Math.max(0, Ge - gt.length + 1); At <= St; At++) {
          var Nt = Ge - At | 0;
          ot = gt.words[Nt] | 0, ft = We.words[At] | 0, mt = ot * ft + Mt, ct += mt / 67108864 | 0, Mt = mt & 67108863;
        }
        Xe.words[Ge] = Mt | 0, pt = ct | 0;
      }
      return pt !== 0 ? Xe.words[Ge] = pt | 0 : Xe.length--, Xe.strip();
    }
    var wt = function(We, Xe, rt) {
      var ot = We.words, ft = Xe.words, mt = rt.words, yt = 0, pt, Ge, ct, Mt = ot[0] | 0, St = Mt & 8191, At = Mt >>> 13, Nt = ot[1] | 0, qt = Nt & 8191, Qt = Nt >>> 13, Xt = ot[2] | 0, zt = Xt & 8191, Kt = Xt >>> 13, ur = ot[3] | 0, er = ur & 8191, Dt = ur >>> 13, Ht = ot[4] | 0, Gt = Ht & 8191, rr = Ht >>> 13, sr = ot[5] | 0, Jt = sr & 8191, ir = sr >>> 13, Br = ot[6] | 0, or = Br & 8191, lr = Br >>> 13, Nr = ot[7] | 0, dr = Nr & 8191, gr = Nr >>> 13, Zr = ot[8] | 0, Bt = Zr & 8191, kt = Zr >>> 13, It = ot[9] | 0, jt = It & 8191, Vt = It >>> 13, ar = ft[0] | 0, Yt = ar & 8191, hr = ar >>> 13, zr = ft[1] | 0, cr = zr & 8191, _r = zr >>> 13, Lr = ft[2] | 0, br = Lr & 8191, kr = Lr >>> 13, Xr = ft[3] | 0, yr = Xr & 8191, Ir = Xr >>> 13, Yr = ft[4] | 0, wr = Yr & 8191, Cr = Yr >>> 13, Hr = ft[5] | 0, $r = Hr & 8191, Ar = Hr >>> 13, Wr = ft[6] | 0, mr = Wr & 8191, Tr = Wr >>> 13, Kr = ft[7] | 0, vr = Kr & 8191, Rr = Kr >>> 13, Jr = ft[8] | 0, xr = Jr & 8191, tr = Jr >>> 13, Dr = ft[9] | 0, fr = Dr & 8191, Mr = Dr >>> 13;
      rt.negative = We.negative ^ Xe.negative, rt.length = 19, pt = Math.imul(St, Yt), Ge = Math.imul(St, hr), Ge = Ge + Math.imul(At, Yt) | 0, ct = Math.imul(At, hr);
      var Fr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, pt = Math.imul(qt, Yt), Ge = Math.imul(qt, hr), Ge = Ge + Math.imul(Qt, Yt) | 0, ct = Math.imul(Qt, hr), pt = pt + Math.imul(St, cr) | 0, Ge = Ge + Math.imul(St, _r) | 0, Ge = Ge + Math.imul(At, cr) | 0, ct = ct + Math.imul(At, _r) | 0;
      var qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, pt = Math.imul(zt, Yt), Ge = Math.imul(zt, hr), Ge = Ge + Math.imul(Kt, Yt) | 0, ct = Math.imul(Kt, hr), pt = pt + Math.imul(qt, cr) | 0, Ge = Ge + Math.imul(qt, _r) | 0, Ge = Ge + Math.imul(Qt, cr) | 0, ct = ct + Math.imul(Qt, _r) | 0, pt = pt + Math.imul(St, br) | 0, Ge = Ge + Math.imul(St, kr) | 0, Ge = Ge + Math.imul(At, br) | 0, ct = ct + Math.imul(At, kr) | 0;
      var tn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, pt = Math.imul(er, Yt), Ge = Math.imul(er, hr), Ge = Ge + Math.imul(Dt, Yt) | 0, ct = Math.imul(Dt, hr), pt = pt + Math.imul(zt, cr) | 0, Ge = Ge + Math.imul(zt, _r) | 0, Ge = Ge + Math.imul(Kt, cr) | 0, ct = ct + Math.imul(Kt, _r) | 0, pt = pt + Math.imul(qt, br) | 0, Ge = Ge + Math.imul(qt, kr) | 0, Ge = Ge + Math.imul(Qt, br) | 0, ct = ct + Math.imul(Qt, kr) | 0, pt = pt + Math.imul(St, yr) | 0, Ge = Ge + Math.imul(St, Ir) | 0, Ge = Ge + Math.imul(At, yr) | 0, ct = ct + Math.imul(At, Ir) | 0;
      var Qr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, pt = Math.imul(Gt, Yt), Ge = Math.imul(Gt, hr), Ge = Ge + Math.imul(rr, Yt) | 0, ct = Math.imul(rr, hr), pt = pt + Math.imul(er, cr) | 0, Ge = Ge + Math.imul(er, _r) | 0, Ge = Ge + Math.imul(Dt, cr) | 0, ct = ct + Math.imul(Dt, _r) | 0, pt = pt + Math.imul(zt, br) | 0, Ge = Ge + Math.imul(zt, kr) | 0, Ge = Ge + Math.imul(Kt, br) | 0, ct = ct + Math.imul(Kt, kr) | 0, pt = pt + Math.imul(qt, yr) | 0, Ge = Ge + Math.imul(qt, Ir) | 0, Ge = Ge + Math.imul(Qt, yr) | 0, ct = ct + Math.imul(Qt, Ir) | 0, pt = pt + Math.imul(St, wr) | 0, Ge = Ge + Math.imul(St, Cr) | 0, Ge = Ge + Math.imul(At, wr) | 0, ct = ct + Math.imul(At, Cr) | 0;
      var nn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, pt = Math.imul(Jt, Yt), Ge = Math.imul(Jt, hr), Ge = Ge + Math.imul(ir, Yt) | 0, ct = Math.imul(ir, hr), pt = pt + Math.imul(Gt, cr) | 0, Ge = Ge + Math.imul(Gt, _r) | 0, Ge = Ge + Math.imul(rr, cr) | 0, ct = ct + Math.imul(rr, _r) | 0, pt = pt + Math.imul(er, br) | 0, Ge = Ge + Math.imul(er, kr) | 0, Ge = Ge + Math.imul(Dt, br) | 0, ct = ct + Math.imul(Dt, kr) | 0, pt = pt + Math.imul(zt, yr) | 0, Ge = Ge + Math.imul(zt, Ir) | 0, Ge = Ge + Math.imul(Kt, yr) | 0, ct = ct + Math.imul(Kt, Ir) | 0, pt = pt + Math.imul(qt, wr) | 0, Ge = Ge + Math.imul(qt, Cr) | 0, Ge = Ge + Math.imul(Qt, wr) | 0, ct = ct + Math.imul(Qt, Cr) | 0, pt = pt + Math.imul(St, $r) | 0, Ge = Ge + Math.imul(St, Ar) | 0, Ge = Ge + Math.imul(At, $r) | 0, ct = ct + Math.imul(At, Ar) | 0;
      var Er = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, pt = Math.imul(or, Yt), Ge = Math.imul(or, hr), Ge = Ge + Math.imul(lr, Yt) | 0, ct = Math.imul(lr, hr), pt = pt + Math.imul(Jt, cr) | 0, Ge = Ge + Math.imul(Jt, _r) | 0, Ge = Ge + Math.imul(ir, cr) | 0, ct = ct + Math.imul(ir, _r) | 0, pt = pt + Math.imul(Gt, br) | 0, Ge = Ge + Math.imul(Gt, kr) | 0, Ge = Ge + Math.imul(rr, br) | 0, ct = ct + Math.imul(rr, kr) | 0, pt = pt + Math.imul(er, yr) | 0, Ge = Ge + Math.imul(er, Ir) | 0, Ge = Ge + Math.imul(Dt, yr) | 0, ct = ct + Math.imul(Dt, Ir) | 0, pt = pt + Math.imul(zt, wr) | 0, Ge = Ge + Math.imul(zt, Cr) | 0, Ge = Ge + Math.imul(Kt, wr) | 0, ct = ct + Math.imul(Kt, Cr) | 0, pt = pt + Math.imul(qt, $r) | 0, Ge = Ge + Math.imul(qt, Ar) | 0, Ge = Ge + Math.imul(Qt, $r) | 0, ct = ct + Math.imul(Qt, Ar) | 0, pt = pt + Math.imul(St, mr) | 0, Ge = Ge + Math.imul(St, Tr) | 0, Ge = Ge + Math.imul(At, mr) | 0, ct = ct + Math.imul(At, Tr) | 0;
      var Wt = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, pt = Math.imul(dr, Yt), Ge = Math.imul(dr, hr), Ge = Ge + Math.imul(gr, Yt) | 0, ct = Math.imul(gr, hr), pt = pt + Math.imul(or, cr) | 0, Ge = Ge + Math.imul(or, _r) | 0, Ge = Ge + Math.imul(lr, cr) | 0, ct = ct + Math.imul(lr, _r) | 0, pt = pt + Math.imul(Jt, br) | 0, Ge = Ge + Math.imul(Jt, kr) | 0, Ge = Ge + Math.imul(ir, br) | 0, ct = ct + Math.imul(ir, kr) | 0, pt = pt + Math.imul(Gt, yr) | 0, Ge = Ge + Math.imul(Gt, Ir) | 0, Ge = Ge + Math.imul(rr, yr) | 0, ct = ct + Math.imul(rr, Ir) | 0, pt = pt + Math.imul(er, wr) | 0, Ge = Ge + Math.imul(er, Cr) | 0, Ge = Ge + Math.imul(Dt, wr) | 0, ct = ct + Math.imul(Dt, Cr) | 0, pt = pt + Math.imul(zt, $r) | 0, Ge = Ge + Math.imul(zt, Ar) | 0, Ge = Ge + Math.imul(Kt, $r) | 0, ct = ct + Math.imul(Kt, Ar) | 0, pt = pt + Math.imul(qt, mr) | 0, Ge = Ge + Math.imul(qt, Tr) | 0, Ge = Ge + Math.imul(Qt, mr) | 0, ct = ct + Math.imul(Qt, Tr) | 0, pt = pt + Math.imul(St, vr) | 0, Ge = Ge + Math.imul(St, Rr) | 0, Ge = Ge + Math.imul(At, vr) | 0, ct = ct + Math.imul(At, Rr) | 0;
      var nr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, pt = Math.imul(Bt, Yt), Ge = Math.imul(Bt, hr), Ge = Ge + Math.imul(kt, Yt) | 0, ct = Math.imul(kt, hr), pt = pt + Math.imul(dr, cr) | 0, Ge = Ge + Math.imul(dr, _r) | 0, Ge = Ge + Math.imul(gr, cr) | 0, ct = ct + Math.imul(gr, _r) | 0, pt = pt + Math.imul(or, br) | 0, Ge = Ge + Math.imul(or, kr) | 0, Ge = Ge + Math.imul(lr, br) | 0, ct = ct + Math.imul(lr, kr) | 0, pt = pt + Math.imul(Jt, yr) | 0, Ge = Ge + Math.imul(Jt, Ir) | 0, Ge = Ge + Math.imul(ir, yr) | 0, ct = ct + Math.imul(ir, Ir) | 0, pt = pt + Math.imul(Gt, wr) | 0, Ge = Ge + Math.imul(Gt, Cr) | 0, Ge = Ge + Math.imul(rr, wr) | 0, ct = ct + Math.imul(rr, Cr) | 0, pt = pt + Math.imul(er, $r) | 0, Ge = Ge + Math.imul(er, Ar) | 0, Ge = Ge + Math.imul(Dt, $r) | 0, ct = ct + Math.imul(Dt, Ar) | 0, pt = pt + Math.imul(zt, mr) | 0, Ge = Ge + Math.imul(zt, Tr) | 0, Ge = Ge + Math.imul(Kt, mr) | 0, ct = ct + Math.imul(Kt, Tr) | 0, pt = pt + Math.imul(qt, vr) | 0, Ge = Ge + Math.imul(qt, Rr) | 0, Ge = Ge + Math.imul(Qt, vr) | 0, ct = ct + Math.imul(Qt, Rr) | 0, pt = pt + Math.imul(St, xr) | 0, Ge = Ge + Math.imul(St, tr) | 0, Ge = Ge + Math.imul(At, xr) | 0, ct = ct + Math.imul(At, tr) | 0;
      var pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, pt = Math.imul(jt, Yt), Ge = Math.imul(jt, hr), Ge = Ge + Math.imul(Vt, Yt) | 0, ct = Math.imul(Vt, hr), pt = pt + Math.imul(Bt, cr) | 0, Ge = Ge + Math.imul(Bt, _r) | 0, Ge = Ge + Math.imul(kt, cr) | 0, ct = ct + Math.imul(kt, _r) | 0, pt = pt + Math.imul(dr, br) | 0, Ge = Ge + Math.imul(dr, kr) | 0, Ge = Ge + Math.imul(gr, br) | 0, ct = ct + Math.imul(gr, kr) | 0, pt = pt + Math.imul(or, yr) | 0, Ge = Ge + Math.imul(or, Ir) | 0, Ge = Ge + Math.imul(lr, yr) | 0, ct = ct + Math.imul(lr, Ir) | 0, pt = pt + Math.imul(Jt, wr) | 0, Ge = Ge + Math.imul(Jt, Cr) | 0, Ge = Ge + Math.imul(ir, wr) | 0, ct = ct + Math.imul(ir, Cr) | 0, pt = pt + Math.imul(Gt, $r) | 0, Ge = Ge + Math.imul(Gt, Ar) | 0, Ge = Ge + Math.imul(rr, $r) | 0, ct = ct + Math.imul(rr, Ar) | 0, pt = pt + Math.imul(er, mr) | 0, Ge = Ge + Math.imul(er, Tr) | 0, Ge = Ge + Math.imul(Dt, mr) | 0, ct = ct + Math.imul(Dt, Tr) | 0, pt = pt + Math.imul(zt, vr) | 0, Ge = Ge + Math.imul(zt, Rr) | 0, Ge = Ge + Math.imul(Kt, vr) | 0, ct = ct + Math.imul(Kt, Rr) | 0, pt = pt + Math.imul(qt, xr) | 0, Ge = Ge + Math.imul(qt, tr) | 0, Ge = Ge + Math.imul(Qt, xr) | 0, ct = ct + Math.imul(Qt, tr) | 0, pt = pt + Math.imul(St, fr) | 0, Ge = Ge + Math.imul(St, Mr) | 0, Ge = Ge + Math.imul(At, fr) | 0, ct = ct + Math.imul(At, Mr) | 0;
      var Pr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, pt = Math.imul(jt, cr), Ge = Math.imul(jt, _r), Ge = Ge + Math.imul(Vt, cr) | 0, ct = Math.imul(Vt, _r), pt = pt + Math.imul(Bt, br) | 0, Ge = Ge + Math.imul(Bt, kr) | 0, Ge = Ge + Math.imul(kt, br) | 0, ct = ct + Math.imul(kt, kr) | 0, pt = pt + Math.imul(dr, yr) | 0, Ge = Ge + Math.imul(dr, Ir) | 0, Ge = Ge + Math.imul(gr, yr) | 0, ct = ct + Math.imul(gr, Ir) | 0, pt = pt + Math.imul(or, wr) | 0, Ge = Ge + Math.imul(or, Cr) | 0, Ge = Ge + Math.imul(lr, wr) | 0, ct = ct + Math.imul(lr, Cr) | 0, pt = pt + Math.imul(Jt, $r) | 0, Ge = Ge + Math.imul(Jt, Ar) | 0, Ge = Ge + Math.imul(ir, $r) | 0, ct = ct + Math.imul(ir, Ar) | 0, pt = pt + Math.imul(Gt, mr) | 0, Ge = Ge + Math.imul(Gt, Tr) | 0, Ge = Ge + Math.imul(rr, mr) | 0, ct = ct + Math.imul(rr, Tr) | 0, pt = pt + Math.imul(er, vr) | 0, Ge = Ge + Math.imul(er, Rr) | 0, Ge = Ge + Math.imul(Dt, vr) | 0, ct = ct + Math.imul(Dt, Rr) | 0, pt = pt + Math.imul(zt, xr) | 0, Ge = Ge + Math.imul(zt, tr) | 0, Ge = Ge + Math.imul(Kt, xr) | 0, ct = ct + Math.imul(Kt, tr) | 0, pt = pt + Math.imul(qt, fr) | 0, Ge = Ge + Math.imul(qt, Mr) | 0, Ge = Ge + Math.imul(Qt, fr) | 0, ct = ct + Math.imul(Qt, Mr) | 0;
      var Sr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, pt = Math.imul(jt, br), Ge = Math.imul(jt, kr), Ge = Ge + Math.imul(Vt, br) | 0, ct = Math.imul(Vt, kr), pt = pt + Math.imul(Bt, yr) | 0, Ge = Ge + Math.imul(Bt, Ir) | 0, Ge = Ge + Math.imul(kt, yr) | 0, ct = ct + Math.imul(kt, Ir) | 0, pt = pt + Math.imul(dr, wr) | 0, Ge = Ge + Math.imul(dr, Cr) | 0, Ge = Ge + Math.imul(gr, wr) | 0, ct = ct + Math.imul(gr, Cr) | 0, pt = pt + Math.imul(or, $r) | 0, Ge = Ge + Math.imul(or, Ar) | 0, Ge = Ge + Math.imul(lr, $r) | 0, ct = ct + Math.imul(lr, Ar) | 0, pt = pt + Math.imul(Jt, mr) | 0, Ge = Ge + Math.imul(Jt, Tr) | 0, Ge = Ge + Math.imul(ir, mr) | 0, ct = ct + Math.imul(ir, Tr) | 0, pt = pt + Math.imul(Gt, vr) | 0, Ge = Ge + Math.imul(Gt, Rr) | 0, Ge = Ge + Math.imul(rr, vr) | 0, ct = ct + Math.imul(rr, Rr) | 0, pt = pt + Math.imul(er, xr) | 0, Ge = Ge + Math.imul(er, tr) | 0, Ge = Ge + Math.imul(Dt, xr) | 0, ct = ct + Math.imul(Dt, tr) | 0, pt = pt + Math.imul(zt, fr) | 0, Ge = Ge + Math.imul(zt, Mr) | 0, Ge = Ge + Math.imul(Kt, fr) | 0, ct = ct + Math.imul(Kt, Mr) | 0;
      var Ur = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, pt = Math.imul(jt, yr), Ge = Math.imul(jt, Ir), Ge = Ge + Math.imul(Vt, yr) | 0, ct = Math.imul(Vt, Ir), pt = pt + Math.imul(Bt, wr) | 0, Ge = Ge + Math.imul(Bt, Cr) | 0, Ge = Ge + Math.imul(kt, wr) | 0, ct = ct + Math.imul(kt, Cr) | 0, pt = pt + Math.imul(dr, $r) | 0, Ge = Ge + Math.imul(dr, Ar) | 0, Ge = Ge + Math.imul(gr, $r) | 0, ct = ct + Math.imul(gr, Ar) | 0, pt = pt + Math.imul(or, mr) | 0, Ge = Ge + Math.imul(or, Tr) | 0, Ge = Ge + Math.imul(lr, mr) | 0, ct = ct + Math.imul(lr, Tr) | 0, pt = pt + Math.imul(Jt, vr) | 0, Ge = Ge + Math.imul(Jt, Rr) | 0, Ge = Ge + Math.imul(ir, vr) | 0, ct = ct + Math.imul(ir, Rr) | 0, pt = pt + Math.imul(Gt, xr) | 0, Ge = Ge + Math.imul(Gt, tr) | 0, Ge = Ge + Math.imul(rr, xr) | 0, ct = ct + Math.imul(rr, tr) | 0, pt = pt + Math.imul(er, fr) | 0, Ge = Ge + Math.imul(er, Mr) | 0, Ge = Ge + Math.imul(Dt, fr) | 0, ct = ct + Math.imul(Dt, Mr) | 0;
      var jr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, pt = Math.imul(jt, wr), Ge = Math.imul(jt, Cr), Ge = Ge + Math.imul(Vt, wr) | 0, ct = Math.imul(Vt, Cr), pt = pt + Math.imul(Bt, $r) | 0, Ge = Ge + Math.imul(Bt, Ar) | 0, Ge = Ge + Math.imul(kt, $r) | 0, ct = ct + Math.imul(kt, Ar) | 0, pt = pt + Math.imul(dr, mr) | 0, Ge = Ge + Math.imul(dr, Tr) | 0, Ge = Ge + Math.imul(gr, mr) | 0, ct = ct + Math.imul(gr, Tr) | 0, pt = pt + Math.imul(or, vr) | 0, Ge = Ge + Math.imul(or, Rr) | 0, Ge = Ge + Math.imul(lr, vr) | 0, ct = ct + Math.imul(lr, Rr) | 0, pt = pt + Math.imul(Jt, xr) | 0, Ge = Ge + Math.imul(Jt, tr) | 0, Ge = Ge + Math.imul(ir, xr) | 0, ct = ct + Math.imul(ir, tr) | 0, pt = pt + Math.imul(Gt, fr) | 0, Ge = Ge + Math.imul(Gt, Mr) | 0, Ge = Ge + Math.imul(rr, fr) | 0, ct = ct + Math.imul(rr, Mr) | 0;
      var Gr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, pt = Math.imul(jt, $r), Ge = Math.imul(jt, Ar), Ge = Ge + Math.imul(Vt, $r) | 0, ct = Math.imul(Vt, Ar), pt = pt + Math.imul(Bt, mr) | 0, Ge = Ge + Math.imul(Bt, Tr) | 0, Ge = Ge + Math.imul(kt, mr) | 0, ct = ct + Math.imul(kt, Tr) | 0, pt = pt + Math.imul(dr, vr) | 0, Ge = Ge + Math.imul(dr, Rr) | 0, Ge = Ge + Math.imul(gr, vr) | 0, ct = ct + Math.imul(gr, Rr) | 0, pt = pt + Math.imul(or, xr) | 0, Ge = Ge + Math.imul(or, tr) | 0, Ge = Ge + Math.imul(lr, xr) | 0, ct = ct + Math.imul(lr, tr) | 0, pt = pt + Math.imul(Jt, fr) | 0, Ge = Ge + Math.imul(Jt, Mr) | 0, Ge = Ge + Math.imul(ir, fr) | 0, ct = ct + Math.imul(ir, Mr) | 0;
      var Vr = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, pt = Math.imul(jt, mr), Ge = Math.imul(jt, Tr), Ge = Ge + Math.imul(Vt, mr) | 0, ct = Math.imul(Vt, Tr), pt = pt + Math.imul(Bt, vr) | 0, Ge = Ge + Math.imul(Bt, Rr) | 0, Ge = Ge + Math.imul(kt, vr) | 0, ct = ct + Math.imul(kt, Rr) | 0, pt = pt + Math.imul(dr, xr) | 0, Ge = Ge + Math.imul(dr, tr) | 0, Ge = Ge + Math.imul(gr, xr) | 0, ct = ct + Math.imul(gr, tr) | 0, pt = pt + Math.imul(or, fr) | 0, Ge = Ge + Math.imul(or, Mr) | 0, Ge = Ge + Math.imul(lr, fr) | 0, ct = ct + Math.imul(lr, Mr) | 0;
      var rn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, pt = Math.imul(jt, vr), Ge = Math.imul(jt, Rr), Ge = Ge + Math.imul(Vt, vr) | 0, ct = Math.imul(Vt, Rr), pt = pt + Math.imul(Bt, xr) | 0, Ge = Ge + Math.imul(Bt, tr) | 0, Ge = Ge + Math.imul(kt, xr) | 0, ct = ct + Math.imul(kt, tr) | 0, pt = pt + Math.imul(dr, fr) | 0, Ge = Ge + Math.imul(dr, Mr) | 0, Ge = Ge + Math.imul(gr, fr) | 0, ct = ct + Math.imul(gr, Mr) | 0;
      var an = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, pt = Math.imul(jt, xr), Ge = Math.imul(jt, tr), Ge = Ge + Math.imul(Vt, xr) | 0, ct = Math.imul(Vt, tr), pt = pt + Math.imul(Bt, fr) | 0, Ge = Ge + Math.imul(Bt, Mr) | 0, Ge = Ge + Math.imul(kt, fr) | 0, ct = ct + Math.imul(kt, Mr) | 0;
      var ln = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      yt = (ct + (Ge >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, pt = Math.imul(jt, fr), Ge = Math.imul(jt, Mr), Ge = Ge + Math.imul(Vt, fr) | 0, ct = Math.imul(Vt, Mr);
      var sn = (yt + pt | 0) + ((Ge & 8191) << 13) | 0;
      return yt = (ct + (Ge >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, mt[0] = Fr, mt[1] = qr, mt[2] = tn, mt[3] = Qr, mt[4] = nn, mt[5] = Er, mt[6] = Wt, mt[7] = nr, mt[8] = pr, mt[9] = Pr, mt[10] = Sr, mt[11] = Ur, mt[12] = jr, mt[13] = Gr, mt[14] = Vr, mt[15] = rn, mt[16] = an, mt[17] = ln, mt[18] = sn, yt !== 0 && (mt[19] = yt, rt.length++), rt;
    };
    Math.imul || (wt = vt);
    function xt(gt, We, Xe) {
      Xe.negative = We.negative ^ gt.negative, Xe.length = gt.length + We.length;
      for (var rt = 0, ot = 0, ft = 0; ft < Xe.length - 1; ft++) {
        var mt = ot;
        ot = 0;
        for (var yt = rt & 67108863, pt = Math.min(ft, We.length - 1), Ge = Math.max(0, ft - gt.length + 1); Ge <= pt; Ge++) {
          var ct = ft - Ge, Mt = gt.words[ct] | 0, St = We.words[Ge] | 0, At = Mt * St, Nt = At & 67108863;
          mt = mt + (At / 67108864 | 0) | 0, Nt = Nt + yt | 0, yt = Nt & 67108863, mt = mt + (Nt >>> 26) | 0, ot += mt >>> 26, mt &= 67108863;
        }
        Xe.words[ft] = yt, rt = mt, mt = ot;
      }
      return rt !== 0 ? Xe.words[ft] = rt : Xe.length--, Xe.strip();
    }
    function Et(gt, We, Xe) {
      var rt = new Tt();
      return rt.mulp(gt, We, Xe);
    }
    Ve.prototype.mulTo = function(We, Xe) {
      var rt, ot = (this || _global$12).length + We.length;
      return (this || _global$12).length === 10 && We.length === 10 ? rt = wt(this || _global$12, We, Xe) : ot < 63 ? rt = vt(this || _global$12, We, Xe) : ot < 1024 ? rt = xt(this || _global$12, We, Xe) : rt = Et(this || _global$12, We, Xe), rt;
    };
    function Tt(gt, We) {
      (this || _global$12).x = gt, (this || _global$12).y = We;
    }
    Tt.prototype.makeRBT = function(We) {
      for (var Xe = new Array(We), rt = Ve.prototype._countBits(We) - 1, ot = 0; ot < We; ot++)
        Xe[ot] = this.revBin(ot, rt, We);
      return Xe;
    }, Tt.prototype.revBin = function(We, Xe, rt) {
      if (We === 0 || We === rt - 1)
        return We;
      for (var ot = 0, ft = 0; ft < Xe; ft++)
        ot |= (We & 1) << Xe - ft - 1, We >>= 1;
      return ot;
    }, Tt.prototype.permute = function(We, Xe, rt, ot, ft, mt) {
      for (var yt = 0; yt < mt; yt++)
        ot[yt] = Xe[We[yt]], ft[yt] = rt[We[yt]];
    }, Tt.prototype.transform = function(We, Xe, rt, ot, ft, mt) {
      this.permute(mt, We, Xe, rt, ot, ft);
      for (var yt = 1; yt < ft; yt <<= 1)
        for (var pt = yt << 1, Ge = Math.cos(2 * Math.PI / pt), ct = Math.sin(2 * Math.PI / pt), Mt = 0; Mt < ft; Mt += pt)
          for (var St = Ge, At = ct, Nt = 0; Nt < yt; Nt++) {
            var qt = rt[Mt + Nt], Qt = ot[Mt + Nt], Xt = rt[Mt + Nt + yt], zt = ot[Mt + Nt + yt], Kt = St * Xt - At * zt;
            zt = St * zt + At * Xt, Xt = Kt, rt[Mt + Nt] = qt + Xt, ot[Mt + Nt] = Qt + zt, rt[Mt + Nt + yt] = qt - Xt, ot[Mt + Nt + yt] = Qt - zt, Nt !== pt && (Kt = Ge * St - ct * At, At = Ge * At + ct * St, St = Kt);
          }
    }, Tt.prototype.guessLen13b = function(We, Xe) {
      var rt = Math.max(Xe, We) | 1, ot = rt & 1, ft = 0;
      for (rt = rt / 2 | 0; rt; rt = rt >>> 1)
        ft++;
      return 1 << ft + 1 + ot;
    }, Tt.prototype.conjugate = function(We, Xe, rt) {
      if (!(rt <= 1))
        for (var ot = 0; ot < rt / 2; ot++) {
          var ft = We[ot];
          We[ot] = We[rt - ot - 1], We[rt - ot - 1] = ft, ft = Xe[ot], Xe[ot] = -Xe[rt - ot - 1], Xe[rt - ot - 1] = -ft;
        }
    }, Tt.prototype.normalize13b = function(We, Xe) {
      for (var rt = 0, ot = 0; ot < Xe / 2; ot++) {
        var ft = Math.round(We[2 * ot + 1] / Xe) * 8192 + Math.round(We[2 * ot] / Xe) + rt;
        We[ot] = ft & 67108863, ft < 67108864 ? rt = 0 : rt = ft / 67108864 | 0;
      }
      return We;
    }, Tt.prototype.convert13b = function(We, Xe, rt, ot) {
      for (var ft = 0, mt = 0; mt < Xe; mt++)
        ft = ft + (We[mt] | 0), rt[2 * mt] = ft & 8191, ft = ft >>> 13, rt[2 * mt + 1] = ft & 8191, ft = ft >>> 13;
      for (mt = 2 * Xe; mt < ot; ++mt)
        rt[mt] = 0;
      Fe(ft === 0), Fe((ft & -8192) === 0);
    }, Tt.prototype.stub = function(We) {
      for (var Xe = new Array(We), rt = 0; rt < We; rt++)
        Xe[rt] = 0;
      return Xe;
    }, Tt.prototype.mulp = function(We, Xe, rt) {
      var ot = 2 * this.guessLen13b(We.length, Xe.length), ft = this.makeRBT(ot), mt = this.stub(ot), yt = new Array(ot), pt = new Array(ot), Ge = new Array(ot), ct = new Array(ot), Mt = new Array(ot), St = new Array(ot), At = rt.words;
      At.length = ot, this.convert13b(We.words, We.length, yt, ot), this.convert13b(Xe.words, Xe.length, ct, ot), this.transform(yt, mt, pt, Ge, ot, ft), this.transform(ct, mt, Mt, St, ot, ft);
      for (var Nt = 0; Nt < ot; Nt++) {
        var qt = pt[Nt] * Mt[Nt] - Ge[Nt] * St[Nt];
        Ge[Nt] = pt[Nt] * St[Nt] + Ge[Nt] * Mt[Nt], pt[Nt] = qt;
      }
      return this.conjugate(pt, Ge, ot), this.transform(pt, Ge, At, mt, ot, ft), this.conjugate(At, mt, ot), this.normalize13b(At, ot), rt.negative = We.negative ^ Xe.negative, rt.length = We.length + Xe.length, rt.strip();
    }, Ve.prototype.mul = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$12).length + We.length), this.mulTo(We, Xe);
    }, Ve.prototype.mulf = function(We) {
      var Xe = new Ve(null);
      return Xe.words = new Array((this || _global$12).length + We.length), Et(this || _global$12, We, Xe);
    }, Ve.prototype.imul = function(We) {
      return this.clone().mulTo(We, this || _global$12);
    }, Ve.prototype.imuln = function(We) {
      Fe(typeof We == "number"), Fe(We < 67108864);
      for (var Xe = 0, rt = 0; rt < (this || _global$12).length; rt++) {
        var ot = ((this || _global$12).words[rt] | 0) * We, ft = (ot & 67108863) + (Xe & 67108863);
        Xe >>= 26, Xe += ot / 67108864 | 0, Xe += ft >>> 26, (this || _global$12).words[rt] = ft & 67108863;
      }
      return Xe !== 0 && ((this || _global$12).words[rt] = Xe, (this || _global$12).length++), this || _global$12;
    }, Ve.prototype.muln = function(We) {
      return this.clone().imuln(We);
    }, Ve.prototype.sqr = function() {
      return this.mul(this || _global$12);
    }, Ve.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Ve.prototype.pow = function(We) {
      var Xe = $t(We);
      if (Xe.length === 0)
        return new Ve(1);
      for (var rt = this || _global$12, ot = 0; ot < Xe.length && Xe[ot] === 0; ot++, rt = rt.sqr())
        ;
      if (++ot < Xe.length)
        for (var ft = rt.sqr(); ot < Xe.length; ot++, ft = ft.sqr())
          Xe[ot] !== 0 && (rt = rt.mul(ft));
      return rt;
    }, Ve.prototype.iushln = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 67108863 >>> 26 - Xe << 26 - Xe, ft;
      if (Xe !== 0) {
        var mt = 0;
        for (ft = 0; ft < (this || _global$12).length; ft++) {
          var yt = (this || _global$12).words[ft] & ot, pt = ((this || _global$12).words[ft] | 0) - yt << Xe;
          (this || _global$12).words[ft] = pt | mt, mt = yt >>> 26 - Xe;
        }
        mt && ((this || _global$12).words[ft] = mt, (this || _global$12).length++);
      }
      if (rt !== 0) {
        for (ft = (this || _global$12).length - 1; ft >= 0; ft--)
          (this || _global$12).words[ft + rt] = (this || _global$12).words[ft];
        for (ft = 0; ft < rt; ft++)
          (this || _global$12).words[ft] = 0;
        (this || _global$12).length += rt;
      }
      return this.strip();
    }, Ve.prototype.ishln = function(We) {
      return Fe((this || _global$12).negative === 0), this.iushln(We);
    }, Ve.prototype.iushrn = function(We, Xe, rt) {
      Fe(typeof We == "number" && We >= 0);
      var ot;
      Xe ? ot = (Xe - Xe % 26) / 26 : ot = 0;
      var ft = We % 26, mt = Math.min((We - ft) / 26, (this || _global$12).length), yt = 67108863 ^ 67108863 >>> ft << ft, pt = rt;
      if (ot -= mt, ot = Math.max(0, ot), pt) {
        for (var Ge = 0; Ge < mt; Ge++)
          pt.words[Ge] = (this || _global$12).words[Ge];
        pt.length = mt;
      }
      if (mt !== 0)
        if ((this || _global$12).length > mt)
          for ((this || _global$12).length -= mt, Ge = 0; Ge < (this || _global$12).length; Ge++)
            (this || _global$12).words[Ge] = (this || _global$12).words[Ge + mt];
        else
          (this || _global$12).words[0] = 0, (this || _global$12).length = 1;
      var ct = 0;
      for (Ge = (this || _global$12).length - 1; Ge >= 0 && (ct !== 0 || Ge >= ot); Ge--) {
        var Mt = (this || _global$12).words[Ge] | 0;
        (this || _global$12).words[Ge] = ct << 26 - ft | Mt >>> ft, ct = Mt & yt;
      }
      return pt && ct !== 0 && (pt.words[pt.length++] = ct), (this || _global$12).length === 0 && ((this || _global$12).words[0] = 0, (this || _global$12).length = 1), this.strip();
    }, Ve.prototype.ishrn = function(We, Xe, rt) {
      return Fe((this || _global$12).negative === 0), this.iushrn(We, Xe, rt);
    }, Ve.prototype.shln = function(We) {
      return this.clone().ishln(We);
    }, Ve.prototype.ushln = function(We) {
      return this.clone().iushln(We);
    }, Ve.prototype.shrn = function(We) {
      return this.clone().ishrn(We);
    }, Ve.prototype.ushrn = function(We) {
      return this.clone().iushrn(We);
    }, Ve.prototype.testn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$12).length <= rt)
        return !1;
      var ft = (this || _global$12).words[rt];
      return !!(ft & ot);
    }, Ve.prototype.imaskn = function(We) {
      Fe(typeof We == "number" && We >= 0);
      var Xe = We % 26, rt = (We - Xe) / 26;
      if (Fe((this || _global$12).negative === 0, "imaskn works only with positive numbers"), (this || _global$12).length <= rt)
        return this || _global$12;
      if (Xe !== 0 && rt++, (this || _global$12).length = Math.min(rt, (this || _global$12).length), Xe !== 0) {
        var ot = 67108863 ^ 67108863 >>> Xe << Xe;
        (this || _global$12).words[(this || _global$12).length - 1] &= ot;
      }
      return this.strip();
    }, Ve.prototype.maskn = function(We) {
      return this.clone().imaskn(We);
    }, Ve.prototype.iaddn = function(We) {
      return Fe(typeof We == "number"), Fe(We < 67108864), We < 0 ? this.isubn(-We) : (this || _global$12).negative !== 0 ? (this || _global$12).length === 1 && ((this || _global$12).words[0] | 0) < We ? ((this || _global$12).words[0] = We - ((this || _global$12).words[0] | 0), (this || _global$12).negative = 0, this || _global$12) : ((this || _global$12).negative = 0, this.isubn(We), (this || _global$12).negative = 1, this || _global$12) : this._iaddn(We);
    }, Ve.prototype._iaddn = function(We) {
      (this || _global$12).words[0] += We;
      for (var Xe = 0; Xe < (this || _global$12).length && (this || _global$12).words[Xe] >= 67108864; Xe++)
        (this || _global$12).words[Xe] -= 67108864, Xe === (this || _global$12).length - 1 ? (this || _global$12).words[Xe + 1] = 1 : (this || _global$12).words[Xe + 1]++;
      return (this || _global$12).length = Math.max((this || _global$12).length, Xe + 1), this || _global$12;
    }, Ve.prototype.isubn = function(We) {
      if (Fe(typeof We == "number"), Fe(We < 67108864), We < 0)
        return this.iaddn(-We);
      if ((this || _global$12).negative !== 0)
        return (this || _global$12).negative = 0, this.iaddn(We), (this || _global$12).negative = 1, this || _global$12;
      if ((this || _global$12).words[0] -= We, (this || _global$12).length === 1 && (this || _global$12).words[0] < 0)
        (this || _global$12).words[0] = -(this || _global$12).words[0], (this || _global$12).negative = 1;
      else
        for (var Xe = 0; Xe < (this || _global$12).length && (this || _global$12).words[Xe] < 0; Xe++)
          (this || _global$12).words[Xe] += 67108864, (this || _global$12).words[Xe + 1] -= 1;
      return this.strip();
    }, Ve.prototype.addn = function(We) {
      return this.clone().iaddn(We);
    }, Ve.prototype.subn = function(We) {
      return this.clone().isubn(We);
    }, Ve.prototype.iabs = function() {
      return (this || _global$12).negative = 0, this || _global$12;
    }, Ve.prototype.abs = function() {
      return this.clone().iabs();
    }, Ve.prototype._ishlnsubmul = function(We, Xe, rt) {
      var ot = We.length + rt, ft;
      this._expand(ot);
      var mt, yt = 0;
      for (ft = 0; ft < We.length; ft++) {
        mt = ((this || _global$12).words[ft + rt] | 0) + yt;
        var pt = (We.words[ft] | 0) * Xe;
        mt -= pt & 67108863, yt = (mt >> 26) - (pt / 67108864 | 0), (this || _global$12).words[ft + rt] = mt & 67108863;
      }
      for (; ft < (this || _global$12).length - rt; ft++)
        mt = ((this || _global$12).words[ft + rt] | 0) + yt, yt = mt >> 26, (this || _global$12).words[ft + rt] = mt & 67108863;
      if (yt === 0)
        return this.strip();
      for (Fe(yt === -1), yt = 0, ft = 0; ft < (this || _global$12).length; ft++)
        mt = -((this || _global$12).words[ft] | 0) + yt, yt = mt >> 26, (this || _global$12).words[ft] = mt & 67108863;
      return (this || _global$12).negative = 1, this.strip();
    }, Ve.prototype._wordDiv = function(We, Xe) {
      var rt = (this || _global$12).length - We.length, ot = this.clone(), ft = We, mt = ft.words[ft.length - 1] | 0, yt = this._countBits(mt);
      rt = 26 - yt, rt !== 0 && (ft = ft.ushln(rt), ot.iushln(rt), mt = ft.words[ft.length - 1] | 0);
      var pt = ot.length - ft.length, Ge;
      if (Xe !== "mod") {
        Ge = new Ve(null), Ge.length = pt + 1, Ge.words = new Array(Ge.length);
        for (var ct = 0; ct < Ge.length; ct++)
          Ge.words[ct] = 0;
      }
      var Mt = ot.clone()._ishlnsubmul(ft, 1, pt);
      Mt.negative === 0 && (ot = Mt, Ge && (Ge.words[pt] = 1));
      for (var St = pt - 1; St >= 0; St--) {
        var At = (ot.words[ft.length + St] | 0) * 67108864 + (ot.words[ft.length + St - 1] | 0);
        for (At = Math.min(At / mt | 0, 67108863), ot._ishlnsubmul(ft, At, St); ot.negative !== 0; )
          At--, ot.negative = 0, ot._ishlnsubmul(ft, 1, St), ot.isZero() || (ot.negative ^= 1);
        Ge && (Ge.words[St] = At);
      }
      return Ge && Ge.strip(), ot.strip(), Xe !== "div" && rt !== 0 && ot.iushrn(rt), {
        div: Ge || null,
        mod: ot
      };
    }, Ve.prototype.divmod = function(We, Xe, rt) {
      if (Fe(!We.isZero()), this.isZero())
        return {
          div: new Ve(0),
          mod: new Ve(0)
        };
      var ot, ft, mt;
      return (this || _global$12).negative !== 0 && We.negative === 0 ? (mt = this.neg().divmod(We, Xe), Xe !== "mod" && (ot = mt.div.neg()), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.iadd(We)), {
        div: ot,
        mod: ft
      }) : (this || _global$12).negative === 0 && We.negative !== 0 ? (mt = this.divmod(We.neg(), Xe), Xe !== "mod" && (ot = mt.div.neg()), {
        div: ot,
        mod: mt.mod
      }) : (this || _global$12).negative & We.negative ? (mt = this.neg().divmod(We.neg(), Xe), Xe !== "div" && (ft = mt.mod.neg(), rt && ft.negative !== 0 && ft.isub(We)), {
        div: mt.div,
        mod: ft
      }) : We.length > (this || _global$12).length || this.cmp(We) < 0 ? {
        div: new Ve(0),
        mod: this || _global$12
      } : We.length === 1 ? Xe === "div" ? {
        div: this.divn(We.words[0]),
        mod: null
      } : Xe === "mod" ? {
        div: null,
        mod: new Ve(this.modn(We.words[0]))
      } : {
        div: this.divn(We.words[0]),
        mod: new Ve(this.modn(We.words[0]))
      } : this._wordDiv(We, Xe);
    }, Ve.prototype.div = function(We) {
      return this.divmod(We, "div", !1).div;
    }, Ve.prototype.mod = function(We) {
      return this.divmod(We, "mod", !1).mod;
    }, Ve.prototype.umod = function(We) {
      return this.divmod(We, "mod", !0).mod;
    }, Ve.prototype.divRound = function(We) {
      var Xe = this.divmod(We);
      if (Xe.mod.isZero())
        return Xe.div;
      var rt = Xe.div.negative !== 0 ? Xe.mod.isub(We) : Xe.mod, ot = We.ushrn(1), ft = We.andln(1), mt = rt.cmp(ot);
      return mt < 0 || ft === 1 && mt === 0 ? Xe.div : Xe.div.negative !== 0 ? Xe.div.isubn(1) : Xe.div.iaddn(1);
    }, Ve.prototype.modn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = (1 << 26) % We, rt = 0, ot = (this || _global$12).length - 1; ot >= 0; ot--)
        rt = (Xe * rt + ((this || _global$12).words[ot] | 0)) % We;
      return rt;
    }, Ve.prototype.idivn = function(We) {
      Fe(We <= 67108863);
      for (var Xe = 0, rt = (this || _global$12).length - 1; rt >= 0; rt--) {
        var ot = ((this || _global$12).words[rt] | 0) + Xe * 67108864;
        (this || _global$12).words[rt] = ot / We | 0, Xe = ot % We;
      }
      return this.strip();
    }, Ve.prototype.divn = function(We) {
      return this.clone().idivn(We);
    }, Ve.prototype.egcd = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$12, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = new Ve(0), yt = new Ve(1), pt = 0; Xe.isEven() && rt.isEven(); )
        Xe.iushrn(1), rt.iushrn(1), ++pt;
      for (var Ge = rt.clone(), ct = Xe.clone(); !Xe.isZero(); ) {
        for (var Mt = 0, St = 1; !(Xe.words[0] & St) && Mt < 26; ++Mt, St <<= 1)
          ;
        if (Mt > 0)
          for (Xe.iushrn(Mt); Mt-- > 0; )
            (ot.isOdd() || ft.isOdd()) && (ot.iadd(Ge), ft.isub(ct)), ot.iushrn(1), ft.iushrn(1);
        for (var At = 0, Nt = 1; !(rt.words[0] & Nt) && At < 26; ++At, Nt <<= 1)
          ;
        if (At > 0)
          for (rt.iushrn(At); At-- > 0; )
            (mt.isOdd() || yt.isOdd()) && (mt.iadd(Ge), yt.isub(ct)), mt.iushrn(1), yt.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(mt), ft.isub(yt)) : (rt.isub(Xe), mt.isub(ot), yt.isub(ft));
      }
      return {
        a: mt,
        b: yt,
        gcd: rt.iushln(pt)
      };
    }, Ve.prototype._invmp = function(We) {
      Fe(We.negative === 0), Fe(!We.isZero());
      var Xe = this || _global$12, rt = We.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(We) : Xe = Xe.clone();
      for (var ot = new Ve(1), ft = new Ve(0), mt = rt.clone(); Xe.cmpn(1) > 0 && rt.cmpn(1) > 0; ) {
        for (var yt = 0, pt = 1; !(Xe.words[0] & pt) && yt < 26; ++yt, pt <<= 1)
          ;
        if (yt > 0)
          for (Xe.iushrn(yt); yt-- > 0; )
            ot.isOdd() && ot.iadd(mt), ot.iushrn(1);
        for (var Ge = 0, ct = 1; !(rt.words[0] & ct) && Ge < 26; ++Ge, ct <<= 1)
          ;
        if (Ge > 0)
          for (rt.iushrn(Ge); Ge-- > 0; )
            ft.isOdd() && ft.iadd(mt), ft.iushrn(1);
        Xe.cmp(rt) >= 0 ? (Xe.isub(rt), ot.isub(ft)) : (rt.isub(Xe), ft.isub(ot));
      }
      var Mt;
      return Xe.cmpn(1) === 0 ? Mt = ot : Mt = ft, Mt.cmpn(0) < 0 && Mt.iadd(We), Mt;
    }, Ve.prototype.gcd = function(We) {
      if (this.isZero())
        return We.abs();
      if (We.isZero())
        return this.abs();
      var Xe = this.clone(), rt = We.clone();
      Xe.negative = 0, rt.negative = 0;
      for (var ot = 0; Xe.isEven() && rt.isEven(); ot++)
        Xe.iushrn(1), rt.iushrn(1);
      do {
        for (; Xe.isEven(); )
          Xe.iushrn(1);
        for (; rt.isEven(); )
          rt.iushrn(1);
        var ft = Xe.cmp(rt);
        if (ft < 0) {
          var mt = Xe;
          Xe = rt, rt = mt;
        } else if (ft === 0 || rt.cmpn(1) === 0)
          break;
        Xe.isub(rt);
      } while (!0);
      return rt.iushln(ot);
    }, Ve.prototype.invm = function(We) {
      return this.egcd(We).a.umod(We);
    }, Ve.prototype.isEven = function() {
      return ((this || _global$12).words[0] & 1) === 0;
    }, Ve.prototype.isOdd = function() {
      return ((this || _global$12).words[0] & 1) === 1;
    }, Ve.prototype.andln = function(We) {
      return (this || _global$12).words[0] & We;
    }, Ve.prototype.bincn = function(We) {
      Fe(typeof We == "number");
      var Xe = We % 26, rt = (We - Xe) / 26, ot = 1 << Xe;
      if ((this || _global$12).length <= rt)
        return this._expand(rt + 1), (this || _global$12).words[rt] |= ot, this || _global$12;
      for (var ft = ot, mt = rt; ft !== 0 && mt < (this || _global$12).length; mt++) {
        var yt = (this || _global$12).words[mt] | 0;
        yt += ft, ft = yt >>> 26, yt &= 67108863, (this || _global$12).words[mt] = yt;
      }
      return ft !== 0 && ((this || _global$12).words[mt] = ft, (this || _global$12).length++), this || _global$12;
    }, Ve.prototype.isZero = function() {
      return (this || _global$12).length === 1 && (this || _global$12).words[0] === 0;
    }, Ve.prototype.cmpn = function(We) {
      var Xe = We < 0;
      if ((this || _global$12).negative !== 0 && !Xe)
        return -1;
      if ((this || _global$12).negative === 0 && Xe)
        return 1;
      this.strip();
      var rt;
      if ((this || _global$12).length > 1)
        rt = 1;
      else {
        Xe && (We = -We), Fe(We <= 67108863, "Number is too big");
        var ot = (this || _global$12).words[0] | 0;
        rt = ot === We ? 0 : ot < We ? -1 : 1;
      }
      return (this || _global$12).negative !== 0 ? -rt | 0 : rt;
    }, Ve.prototype.cmp = function(We) {
      if ((this || _global$12).negative !== 0 && We.negative === 0)
        return -1;
      if ((this || _global$12).negative === 0 && We.negative !== 0)
        return 1;
      var Xe = this.ucmp(We);
      return (this || _global$12).negative !== 0 ? -Xe | 0 : Xe;
    }, Ve.prototype.ucmp = function(We) {
      if ((this || _global$12).length > We.length)
        return 1;
      if ((this || _global$12).length < We.length)
        return -1;
      for (var Xe = 0, rt = (this || _global$12).length - 1; rt >= 0; rt--) {
        var ot = (this || _global$12).words[rt] | 0, ft = We.words[rt] | 0;
        if (ot !== ft) {
          ot < ft ? Xe = -1 : ot > ft && (Xe = 1);
          break;
        }
      }
      return Xe;
    }, Ve.prototype.gtn = function(We) {
      return this.cmpn(We) === 1;
    }, Ve.prototype.gt = function(We) {
      return this.cmp(We) === 1;
    }, Ve.prototype.gten = function(We) {
      return this.cmpn(We) >= 0;
    }, Ve.prototype.gte = function(We) {
      return this.cmp(We) >= 0;
    }, Ve.prototype.ltn = function(We) {
      return this.cmpn(We) === -1;
    }, Ve.prototype.lt = function(We) {
      return this.cmp(We) === -1;
    }, Ve.prototype.lten = function(We) {
      return this.cmpn(We) <= 0;
    }, Ve.prototype.lte = function(We) {
      return this.cmp(We) <= 0;
    }, Ve.prototype.eqn = function(We) {
      return this.cmpn(We) === 0;
    }, Ve.prototype.eq = function(We) {
      return this.cmp(We) === 0;
    }, Ve.red = function(We) {
      return new Ot(We);
    }, Ve.prototype.toRed = function(We) {
      return Fe(!(this || _global$12).red, "Already a number in reduction context"), Fe((this || _global$12).negative === 0, "red works only with positives"), We.convertTo(this || _global$12)._forceRed(We);
    }, Ve.prototype.fromRed = function() {
      return Fe((this || _global$12).red, "fromRed works only with numbers in reduction context"), (this || _global$12).red.convertFrom(this || _global$12);
    }, Ve.prototype._forceRed = function(We) {
      return (this || _global$12).red = We, this || _global$12;
    }, Ve.prototype.forceRed = function(We) {
      return Fe(!(this || _global$12).red, "Already a number in reduction context"), this._forceRed(We);
    }, Ve.prototype.redAdd = function(We) {
      return Fe((this || _global$12).red, "redAdd works only with red numbers"), (this || _global$12).red.add(this || _global$12, We);
    }, Ve.prototype.redIAdd = function(We) {
      return Fe((this || _global$12).red, "redIAdd works only with red numbers"), (this || _global$12).red.iadd(this || _global$12, We);
    }, Ve.prototype.redSub = function(We) {
      return Fe((this || _global$12).red, "redSub works only with red numbers"), (this || _global$12).red.sub(this || _global$12, We);
    }, Ve.prototype.redISub = function(We) {
      return Fe((this || _global$12).red, "redISub works only with red numbers"), (this || _global$12).red.isub(this || _global$12, We);
    }, Ve.prototype.redShl = function(We) {
      return Fe((this || _global$12).red, "redShl works only with red numbers"), (this || _global$12).red.shl(this || _global$12, We);
    }, Ve.prototype.redMul = function(We) {
      return Fe((this || _global$12).red, "redMul works only with red numbers"), (this || _global$12).red._verify2(this || _global$12, We), (this || _global$12).red.mul(this || _global$12, We);
    }, Ve.prototype.redIMul = function(We) {
      return Fe((this || _global$12).red, "redMul works only with red numbers"), (this || _global$12).red._verify2(this || _global$12, We), (this || _global$12).red.imul(this || _global$12, We);
    }, Ve.prototype.redSqr = function() {
      return Fe((this || _global$12).red, "redSqr works only with red numbers"), (this || _global$12).red._verify1(this || _global$12), (this || _global$12).red.sqr(this || _global$12);
    }, Ve.prototype.redISqr = function() {
      return Fe((this || _global$12).red, "redISqr works only with red numbers"), (this || _global$12).red._verify1(this || _global$12), (this || _global$12).red.isqr(this || _global$12);
    }, Ve.prototype.redSqrt = function() {
      return Fe((this || _global$12).red, "redSqrt works only with red numbers"), (this || _global$12).red._verify1(this || _global$12), (this || _global$12).red.sqrt(this || _global$12);
    }, Ve.prototype.redInvm = function() {
      return Fe((this || _global$12).red, "redInvm works only with red numbers"), (this || _global$12).red._verify1(this || _global$12), (this || _global$12).red.invm(this || _global$12);
    }, Ve.prototype.redNeg = function() {
      return Fe((this || _global$12).red, "redNeg works only with red numbers"), (this || _global$12).red._verify1(this || _global$12), (this || _global$12).red.neg(this || _global$12);
    }, Ve.prototype.redPow = function(We) {
      return Fe((this || _global$12).red && !We.red, "redPow(normalNum)"), (this || _global$12).red._verify1(this || _global$12), (this || _global$12).red.pow(this || _global$12, We);
    };
    var Rt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ct(gt, We) {
      (this || _global$12).name = gt, (this || _global$12).p = new Ve(We, 16), (this || _global$12).n = (this || _global$12).p.bitLength(), (this || _global$12).k = new Ve(1).iushln((this || _global$12).n).isub((this || _global$12).p), (this || _global$12).tmp = this._tmp();
    }
    Ct.prototype._tmp = function() {
      var We = new Ve(null);
      return We.words = new Array(Math.ceil((this || _global$12).n / 13)), We;
    }, Ct.prototype.ireduce = function(We) {
      var Xe = We, rt;
      do
        this.split(Xe, (this || _global$12).tmp), Xe = this.imulK(Xe), Xe = Xe.iadd((this || _global$12).tmp), rt = Xe.bitLength();
      while (rt > (this || _global$12).n);
      var ot = rt < (this || _global$12).n ? -1 : Xe.ucmp((this || _global$12).p);
      return ot === 0 ? (Xe.words[0] = 0, Xe.length = 1) : ot > 0 ? Xe.isub((this || _global$12).p) : Xe.strip !== void 0 ? Xe.strip() : Xe._strip(), Xe;
    }, Ct.prototype.split = function(We, Xe) {
      We.iushrn((this || _global$12).n, 0, Xe);
    }, Ct.prototype.imulK = function(We) {
      return We.imul((this || _global$12).k);
    };
    function Zt() {
      Ct.call(this || _global$12, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    Ke(Zt, Ct), Zt.prototype.split = function(We, Xe) {
      for (var rt = 4194303, ot = Math.min(We.length, 9), ft = 0; ft < ot; ft++)
        Xe.words[ft] = We.words[ft];
      if (Xe.length = ot, We.length <= 9) {
        We.words[0] = 0, We.length = 1;
        return;
      }
      var mt = We.words[9];
      for (Xe.words[Xe.length++] = mt & rt, ft = 10; ft < We.length; ft++) {
        var yt = We.words[ft] | 0;
        We.words[ft - 10] = (yt & rt) << 4 | mt >>> 22, mt = yt;
      }
      mt >>>= 22, We.words[ft - 10] = mt, mt === 0 && We.length > 10 ? We.length -= 10 : We.length -= 9;
    }, Zt.prototype.imulK = function(We) {
      We.words[We.length] = 0, We.words[We.length + 1] = 0, We.length += 2;
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = We.words[rt] | 0;
        Xe += ot * 977, We.words[rt] = Xe & 67108863, Xe = ot * 64 + (Xe / 67108864 | 0);
      }
      return We.words[We.length - 1] === 0 && (We.length--, We.words[We.length - 1] === 0 && We.length--), We;
    };
    function Lt() {
      Ct.call(this || _global$12, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    Ke(Lt, Ct);
    function Ut() {
      Ct.call(this || _global$12, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    Ke(Ut, Ct);
    function Pt() {
      Ct.call(this || _global$12, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    Ke(Pt, Ct), Pt.prototype.imulK = function(We) {
      for (var Xe = 0, rt = 0; rt < We.length; rt++) {
        var ot = (We.words[rt] | 0) * 19 + Xe, ft = ot & 67108863;
        ot >>>= 26, We.words[rt] = ft, Xe = ot;
      }
      return Xe !== 0 && (We.words[We.length++] = Xe), We;
    }, Ve._prime = function(We) {
      if (Rt[We])
        return Rt[We];
      var Xe;
      if (We === "k256")
        Xe = new Zt();
      else if (We === "p224")
        Xe = new Lt();
      else if (We === "p192")
        Xe = new Ut();
      else if (We === "p25519")
        Xe = new Pt();
      else
        throw new Error("Unknown prime " + We);
      return Rt[We] = Xe, Xe;
    };
    function Ot(gt) {
      if (typeof gt == "string") {
        var We = Ve._prime(gt);
        (this || _global$12).m = We.p, (this || _global$12).prime = We;
      } else
        Fe(gt.gtn(1), "modulus must be greater than 1"), (this || _global$12).m = gt, (this || _global$12).prime = null;
    }
    Ot.prototype._verify1 = function(We) {
      Fe(We.negative === 0, "red works only with positives"), Fe(We.red, "red works only with red numbers");
    }, Ot.prototype._verify2 = function(We, Xe) {
      Fe((We.negative | Xe.negative) === 0, "red works only with positives"), Fe(We.red && We.red === Xe.red, "red works only with red numbers");
    }, Ot.prototype.imod = function(We) {
      return (this || _global$12).prime ? (this || _global$12).prime.ireduce(We)._forceRed(this || _global$12) : We.umod((this || _global$12).m)._forceRed(this || _global$12);
    }, Ot.prototype.neg = function(We) {
      return We.isZero() ? We.clone() : (this || _global$12).m.sub(We)._forceRed(this || _global$12);
    }, Ot.prototype.add = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.add(Xe);
      return rt.cmp((this || _global$12).m) >= 0 && rt.isub((this || _global$12).m), rt._forceRed(this || _global$12);
    }, Ot.prototype.iadd = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.iadd(Xe);
      return rt.cmp((this || _global$12).m) >= 0 && rt.isub((this || _global$12).m), rt;
    }, Ot.prototype.sub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.sub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$12).m), rt._forceRed(this || _global$12);
    }, Ot.prototype.isub = function(We, Xe) {
      this._verify2(We, Xe);
      var rt = We.isub(Xe);
      return rt.cmpn(0) < 0 && rt.iadd((this || _global$12).m), rt;
    }, Ot.prototype.shl = function(We, Xe) {
      return this._verify1(We), this.imod(We.ushln(Xe));
    }, Ot.prototype.imul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.imul(Xe));
    }, Ot.prototype.mul = function(We, Xe) {
      return this._verify2(We, Xe), this.imod(We.mul(Xe));
    }, Ot.prototype.isqr = function(We) {
      return this.imul(We, We.clone());
    }, Ot.prototype.sqr = function(We) {
      return this.mul(We, We);
    }, Ot.prototype.sqrt = function(We) {
      if (We.isZero())
        return We.clone();
      var Xe = (this || _global$12).m.andln(3);
      if (Fe(Xe % 2 === 1), Xe === 3) {
        var rt = (this || _global$12).m.add(new Ve(1)).iushrn(2);
        return this.pow(We, rt);
      }
      for (var ot = (this || _global$12).m.subn(1), ft = 0; !ot.isZero() && ot.andln(1) === 0; )
        ft++, ot.iushrn(1);
      Fe(!ot.isZero());
      var mt = new Ve(1).toRed(this || _global$12), yt = mt.redNeg(), pt = (this || _global$12).m.subn(1).iushrn(1), Ge = (this || _global$12).m.bitLength();
      for (Ge = new Ve(2 * Ge * Ge).toRed(this || _global$12); this.pow(Ge, pt).cmp(yt) !== 0; )
        Ge.redIAdd(yt);
      for (var ct = this.pow(Ge, ot), Mt = this.pow(We, ot.addn(1).iushrn(1)), St = this.pow(We, ot), At = ft; St.cmp(mt) !== 0; ) {
        for (var Nt = St, qt = 0; Nt.cmp(mt) !== 0; qt++)
          Nt = Nt.redSqr();
        Fe(qt < At);
        var Qt = this.pow(ct, new Ve(1).iushln(At - qt - 1));
        Mt = Mt.redMul(Qt), ct = Qt.redSqr(), St = St.redMul(ct), At = qt;
      }
      return Mt;
    }, Ot.prototype.invm = function(We) {
      var Xe = We._invmp((this || _global$12).m);
      return Xe.negative !== 0 ? (Xe.negative = 0, this.imod(Xe).redNeg()) : this.imod(Xe);
    }, Ot.prototype.pow = function(We, Xe) {
      if (Xe.isZero())
        return new Ve(1).toRed(this || _global$12);
      if (Xe.cmpn(1) === 0)
        return We.clone();
      var rt = 4, ot = new Array(1 << rt);
      ot[0] = new Ve(1).toRed(this || _global$12), ot[1] = We;
      for (var ft = 2; ft < ot.length; ft++)
        ot[ft] = this.mul(ot[ft - 1], We);
      var mt = ot[0], yt = 0, pt = 0, Ge = Xe.bitLength() % 26;
      for (Ge === 0 && (Ge = 26), ft = Xe.length - 1; ft >= 0; ft--) {
        for (var ct = Xe.words[ft], Mt = Ge - 1; Mt >= 0; Mt--) {
          var St = ct >> Mt & 1;
          if (mt !== ot[0] && (mt = this.sqr(mt)), St === 0 && yt === 0) {
            pt = 0;
            continue;
          }
          yt <<= 1, yt |= St, pt++, !(pt !== rt && (ft !== 0 || Mt !== 0)) && (mt = this.mul(mt, ot[yt]), pt = 0, yt = 0);
        }
        Ge = 26;
      }
      return mt;
    }, Ot.prototype.convertTo = function(We) {
      var Xe = We.umod((this || _global$12).m);
      return Xe === We ? Xe.clone() : Xe;
    }, Ot.prototype.convertFrom = function(We) {
      var Xe = We.clone();
      return Xe.red = null, Xe;
    }, Ve.mont = function(We) {
      return new Ft(We);
    };
    function Ft(gt) {
      Ot.call(this || _global$12, gt), (this || _global$12).shift = (this || _global$12).m.bitLength(), (this || _global$12).shift % 26 !== 0 && ((this || _global$12).shift += 26 - (this || _global$12).shift % 26), (this || _global$12).r = new Ve(1).iushln((this || _global$12).shift), (this || _global$12).r2 = this.imod((this || _global$12).r.sqr()), (this || _global$12).rinv = (this || _global$12).r._invmp((this || _global$12).m), (this || _global$12).minv = (this || _global$12).rinv.mul((this || _global$12).r).isubn(1).div((this || _global$12).m), (this || _global$12).minv = (this || _global$12).minv.umod((this || _global$12).r), (this || _global$12).minv = (this || _global$12).r.sub((this || _global$12).minv);
    }
    Ke(Ft, Ot), Ft.prototype.convertTo = function(We) {
      return this.imod(We.ushln((this || _global$12).shift));
    }, Ft.prototype.convertFrom = function(We) {
      var Xe = this.imod(We.mul((this || _global$12).rinv));
      return Xe.red = null, Xe;
    }, Ft.prototype.imul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return We.words[0] = 0, We.length = 1, We;
      var rt = We.imul(Xe), ot = rt.maskn((this || _global$12).shift).mul((this || _global$12).minv).imaskn((this || _global$12).shift).mul((this || _global$12).m), ft = rt.isub(ot).iushrn((this || _global$12).shift), mt = ft;
      return ft.cmp((this || _global$12).m) >= 0 ? mt = ft.isub((this || _global$12).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$12).m)), mt._forceRed(this || _global$12);
    }, Ft.prototype.mul = function(We, Xe) {
      if (We.isZero() || Xe.isZero())
        return new Ve(0)._forceRed(this || _global$12);
      var rt = We.mul(Xe), ot = rt.maskn((this || _global$12).shift).mul((this || _global$12).minv).imaskn((this || _global$12).shift).mul((this || _global$12).m), ft = rt.isub(ot).iushrn((this || _global$12).shift), mt = ft;
      return ft.cmp((this || _global$12).m) >= 0 ? mt = ft.isub((this || _global$12).m) : ft.cmpn(0) < 0 && (mt = ft.iadd((this || _global$12).m)), mt._forceRed(this || _global$12);
    }, Ft.prototype.invm = function(We) {
      var Xe = this.imod(We._invmp((this || _global$12).m).mul((this || _global$12).r2));
      return Xe._forceRed(this || _global$12);
    };
  }(module, exports$72)), module.exports;
}
var exports$62 = {}, _dewExec$52 = !1;
function dew$52() {
  if (_dewExec$52)
    return exports$62;
  _dewExec$52 = !0;
  var $e = dew$62(), Ze = dew$2P().Buffer;
  function Fe(Ke, Ve) {
    return Ze.from(Ke.toRed($e.mont(Ve.modulus)).redPow(new $e(Ve.publicExponent)).fromRed().toArray());
  }
  return exports$62 = Fe, exports$62;
}
var exports$52 = {}, _dewExec$42 = !1;
function dew$42() {
  if (_dewExec$42)
    return exports$52;
  _dewExec$42 = !0;
  var $e = dew$e2(), Ze = dew$2O(), Fe = dew$2y(), Ke = dew$82(), Ve = dew$72(), Je = dew$62(), Qe = dew$52(), at = dew$W(), ut = dew$2P().Buffer;
  exports$52 = function(vt, wt, xt) {
    var Et;
    vt.padding ? Et = vt.padding : xt ? Et = 1 : Et = 4;
    var Tt = $e(vt), Rt;
    if (Et === 4)
      Rt = lt(Tt, wt);
    else if (Et === 1)
      Rt = dt(Tt, wt, xt);
    else if (Et === 3) {
      if (Rt = new Je(wt), Rt.cmp(Tt.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return xt ? at(Rt, Tt) : Qe(Rt, Tt);
  };
  function lt($t, vt) {
    var wt = $t.modulus.byteLength(), xt = vt.length, Et = Fe("sha1").update(ut.alloc(0)).digest(), Tt = Et.length, Rt = 2 * Tt;
    if (xt > wt - Rt - 2)
      throw new Error("message too long");
    var Ct = ut.alloc(wt - xt - Rt - 2), Zt = wt - Tt - 1, Lt = Ze(Tt), Ut = Ve(ut.concat([Et, Ct, ut.alloc(1, 1), vt], Zt), Ke(Lt, Zt)), Pt = Ve(Lt, Ke(Ut, Tt));
    return new Je(ut.concat([ut.alloc(1), Pt, Ut], wt));
  }
  function dt($t, vt, wt) {
    var xt = vt.length, Et = $t.modulus.byteLength();
    if (xt > Et - 11)
      throw new Error("message too long");
    var Tt;
    return wt ? Tt = ut.alloc(Et - xt - 3, 255) : Tt = bt(Et - xt - 3), new Je(ut.concat([ut.from([0, wt ? 1 : 2]), Tt, ut.alloc(1), vt], Et));
  }
  function bt($t) {
    for (var vt = ut.allocUnsafe($t), wt = 0, xt = Ze($t * 2), Et = 0, Tt; wt < $t; )
      Et === xt.length && (xt = Ze($t * 2), Et = 0), Tt = xt[Et++], Tt && (vt[wt++] = Tt);
    return vt;
  }
  return exports$52;
}
var exports$42 = {}, _dewExec$32 = !1;
function dew$32() {
  if (_dewExec$32)
    return exports$42;
  _dewExec$32 = !0;
  var $e = dew$e2(), Ze = dew$82(), Fe = dew$72(), Ke = dew$62(), Ve = dew$W(), Je = dew$2y(), Qe = dew$52(), at = dew$2P().Buffer;
  exports$42 = function($t, vt, wt) {
    var xt;
    $t.padding ? xt = $t.padding : wt ? xt = 1 : xt = 4;
    var Et = $e($t), Tt = Et.modulus.byteLength();
    if (vt.length > Tt || new Ke(vt).cmp(Et.modulus) >= 0)
      throw new Error("decryption error");
    var Rt;
    wt ? Rt = Qe(new Ke(vt), Et) : Rt = Ve(vt, Et);
    var Ct = at.alloc(Tt - Rt.length);
    if (Rt = at.concat([Ct, Rt], Tt), xt === 4)
      return ut(Et, Rt);
    if (xt === 1)
      return lt(Et, Rt, wt);
    if (xt === 3)
      return Rt;
    throw new Error("unknown padding");
  };
  function ut(bt, $t) {
    var vt = bt.modulus.byteLength(), wt = Je("sha1").update(at.alloc(0)).digest(), xt = wt.length;
    if ($t[0] !== 0)
      throw new Error("decryption error");
    var Et = $t.slice(1, xt + 1), Tt = $t.slice(xt + 1), Rt = Fe(Et, Ze(Tt, xt)), Ct = Fe(Tt, Ze(Rt, vt - xt - 1));
    if (dt(wt, Ct.slice(0, xt)))
      throw new Error("decryption error");
    for (var Zt = xt; Ct[Zt] === 0; )
      Zt++;
    if (Ct[Zt++] !== 1)
      throw new Error("decryption error");
    return Ct.slice(Zt);
  }
  function lt(bt, $t, vt) {
    for (var wt = $t.slice(0, 2), xt = 2, Et = 0; $t[xt++] !== 0; )
      if (xt >= $t.length) {
        Et++;
        break;
      }
    var Tt = $t.slice(2, xt - 1);
    if ((wt.toString("hex") !== "0002" && !vt || wt.toString("hex") !== "0001" && vt) && Et++, Tt.length < 8 && Et++, Et)
      throw new Error("decryption error");
    return $t.slice(xt);
  }
  function dt(bt, $t) {
    bt = at.from(bt), $t = at.from($t);
    var vt = 0, wt = bt.length;
    bt.length !== $t.length && (vt++, wt = Math.min(bt.length, $t.length));
    for (var xt = -1; ++xt < wt; )
      vt += bt[xt] ^ $t[xt];
    return vt;
  }
  return exports$42;
}
var exports$33 = {}, _dewExec$210 = !1;
function dew$210() {
  return _dewExec$210 || (_dewExec$210 = !0, exports$33.publicEncrypt = dew$42(), exports$33.privateDecrypt = dew$32(), exports$33.privateEncrypt = function(Ze, Fe) {
    return exports$33.publicEncrypt(Ze, Fe, !0);
  }, exports$33.publicDecrypt = function(Ze, Fe) {
    return exports$33.privateDecrypt(Ze, Fe, !0);
  }), exports$33;
}
var exports$210 = {}, _dewExec$110 = !1, _global4 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : global;
function dew$110() {
  if (_dewExec$110)
    return exports$210;
  _dewExec$110 = !0;
  var $e = process2;
  function Ze() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var Fe = dew$2P(), Ke = dew$2O(), Ve = Fe.Buffer, Je = Fe.kMaxLength, Qe = _global4.crypto || _global4.msCrypto, at = Math.pow(2, 32) - 1;
  function ut(vt, wt) {
    if (typeof vt != "number" || vt !== vt)
      throw new TypeError("offset must be a number");
    if (vt > at || vt < 0)
      throw new TypeError("offset must be a uint32");
    if (vt > Je || vt > wt)
      throw new RangeError("offset out of range");
  }
  function lt(vt, wt, xt) {
    if (typeof vt != "number" || vt !== vt)
      throw new TypeError("size must be a number");
    if (vt > at || vt < 0)
      throw new TypeError("size must be a uint32");
    if (vt + wt > xt || vt > Je)
      throw new RangeError("buffer too small");
  }
  Qe && Qe.getRandomValues || !$e.browser ? (exports$210.randomFill = dt, exports$210.randomFillSync = $t) : (exports$210.randomFill = Ze, exports$210.randomFillSync = Ze);
  function dt(vt, wt, xt, Et) {
    if (!Ve.isBuffer(vt) && !(vt instanceof _global4.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof wt == "function")
      Et = wt, wt = 0, xt = vt.length;
    else if (typeof xt == "function")
      Et = xt, xt = vt.length - wt;
    else if (typeof Et != "function")
      throw new TypeError('"cb" argument must be a function');
    return ut(wt, vt.length), lt(xt, wt, vt.length), bt(vt, wt, xt, Et);
  }
  function bt(vt, wt, xt, Et) {
    if ($e.browser) {
      var Tt = vt.buffer, Rt = new Uint8Array(Tt, wt, xt);
      if (Qe.getRandomValues(Rt), Et) {
        $e.nextTick(function() {
          Et(null, vt);
        });
        return;
      }
      return vt;
    }
    if (Et) {
      Ke(xt, function(Zt, Lt) {
        if (Zt)
          return Et(Zt);
        Lt.copy(vt, wt), Et(null, vt);
      });
      return;
    }
    var Ct = Ke(xt);
    return Ct.copy(vt, wt), vt;
  }
  function $t(vt, wt, xt) {
    if (typeof wt > "u" && (wt = 0), !Ve.isBuffer(vt) && !(vt instanceof _global4.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return ut(wt, vt.length), xt === void 0 && (xt = vt.length - wt), lt(xt, wt, vt.length), bt(vt, wt, xt);
  }
  return exports$210;
}
var exports$110 = {}, _dewExec5 = !1;
function dew5() {
  if (_dewExec5)
    return exports$110;
  _dewExec5 = !0, exports$110.randomBytes = exports$110.rng = exports$110.pseudoRandomBytes = exports$110.prng = dew$2O(), exports$110.createHash = exports$110.Hash = dew$2y(), exports$110.createHmac = exports$110.Hmac = dew$2v();
  var $e = dew$2u(), Ze = Object.keys($e), Fe = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(Ze);
  exports$110.getHashes = function() {
    return Fe;
  };
  var Ke = dew$2o();
  exports$110.pbkdf2 = Ke.pbkdf2, exports$110.pbkdf2Sync = Ke.pbkdf2Sync;
  var Ve = dew$1Y();
  exports$110.Cipher = Ve.Cipher, exports$110.createCipher = Ve.createCipher, exports$110.Cipheriv = Ve.Cipheriv, exports$110.createCipheriv = Ve.createCipheriv, exports$110.Decipher = Ve.Decipher, exports$110.createDecipher = Ve.createDecipher, exports$110.Decipheriv = Ve.Decipheriv, exports$110.createDecipheriv = Ve.createDecipheriv, exports$110.getCiphers = Ve.getCiphers, exports$110.listCiphers = Ve.listCiphers;
  var Je = dew$Z();
  exports$110.DiffieHellmanGroup = Je.DiffieHellmanGroup, exports$110.createDiffieHellmanGroup = Je.createDiffieHellmanGroup, exports$110.getDiffieHellman = Je.getDiffieHellman, exports$110.createDiffieHellman = Je.createDiffieHellman, exports$110.DiffieHellman = Je.DiffieHellman;
  var Qe = dew$b2();
  exports$110.createSign = Qe.createSign, exports$110.Sign = Qe.Sign, exports$110.createVerify = Qe.createVerify, exports$110.Verify = Qe.Verify, exports$110.createECDH = dew$92();
  var at = dew$210();
  exports$110.publicEncrypt = at.publicEncrypt, exports$110.privateEncrypt = at.privateEncrypt, exports$110.publicDecrypt = at.publicDecrypt, exports$110.privateDecrypt = at.privateDecrypt;
  var ut = dew$110();
  return exports$110.randomFill = ut.randomFill, exports$110.randomFillSync = ut.randomFillSync, exports$110.createCredentials = function() {
    throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
  }, exports$110.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, exports$110;
}
var exports5 = dew5();
exports5.randomBytes;
exports5.rng;
exports5.pseudoRandomBytes;
exports5.prng;
exports5.createHash;
exports5.Hash;
exports5.createHmac;
exports5.Hmac;
exports5.getHashes;
exports5.pbkdf2;
exports5.pbkdf2Sync;
exports5.Cipher;
exports5.createCipher;
exports5.Cipheriv;
exports5.createCipheriv;
exports5.Decipher;
exports5.createDecipher;
exports5.Decipheriv;
exports5.createDecipheriv;
exports5.getCiphers;
exports5.listCiphers;
exports5.DiffieHellmanGroup;
exports5.createDiffieHellmanGroup;
exports5.getDiffieHellman;
exports5.createDiffieHellman;
exports5.DiffieHellman;
exports5.createSign;
exports5.Sign;
exports5.createVerify;
exports5.Verify;
exports5.createECDH;
exports5.publicEncrypt;
exports5.privateEncrypt;
exports5.publicDecrypt;
exports5.privateDecrypt;
exports5.randomFill;
exports5.randomFillSync;
exports5.createCredentials;
exports5.constants;
exports5.webcrypto = globalThis.crypto;
exports5.Cipher;
exports5.Cipheriv;
exports5.Decipher;
exports5.Decipheriv;
exports5.DiffieHellman;
exports5.DiffieHellmanGroup;
exports5.Hash;
exports5.Hmac;
exports5.Sign;
exports5.Verify;
exports5.constants;
exports5.createCipher;
exports5.createCipheriv;
exports5.createCredentials;
exports5.createDecipher;
exports5.createDecipheriv;
exports5.createDiffieHellman;
exports5.createDiffieHellmanGroup;
exports5.createECDH;
exports5.createHash;
exports5.createHmac;
exports5.createSign;
exports5.createVerify;
exports5.getCiphers;
exports5.getDiffieHellman;
exports5.getHashes;
exports5.listCiphers;
exports5.pbkdf2;
exports5.pbkdf2Sync;
exports5.privateDecrypt;
exports5.privateEncrypt;
exports5.prng;
exports5.pseudoRandomBytes;
exports5.publicDecrypt;
exports5.publicEncrypt;
exports5.randomBytes;
exports5.randomFill;
exports5.randomFillSync;
exports5.rng;
exports5.webcrypto;
var cryptoLibPolyfill = {
  getRandomValues: ($e) => new Uint8Array($e.map(() => Math.floor(Math.random() * 256)))
}, cryptoLib = typeof window < "u" && typeof window.document < "u" ? window.crypto : exports5;
cryptoLib.getRandomValues || (cryptoLib = cryptoLibPolyfill);
var BaseApiError = class extends Error {
  constructor(Ze, Fe, Ke, Ve, Je, Qe) {
    super(Ve);
    Or(this, "isApiError", !0);
    this.code = Ze, this.description = Fe, this.type = Ke, this.message = Ve, this.error = Je, this.id = Qe, this.id || (this.id = BaseApiError.generateId());
  }
  format() {
    return `[${this.type}] ${this.message} (Error ID: ${this.id})`;
  }
  toJSON() {
    return {
      id: this.id,
      code: this.code,
      type: this.type,
      message: this.message
    };
  }
  static generateId() {
    const Fe = Array.from(cryptoLib.getRandomValues(new Uint8Array(4))).map((Ke) => Ke.toString(16).padStart(2, "0")).join("").toUpperCase();
    return `err_${Date.now()}x${Fe}`;
  }
}, isObject3 = ($e) => typeof $e == "object" && !Array.isArray($e) && $e !== null, isApiError = ($e) => $e instanceof BaseApiError || isObject3($e) && $e.isApiError === !0, UnknownError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(500, "An unknown error occurred", "Unknown", $e, Ze, Fe);
  }
}, InternalError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(500, "An internal error occurred", "Internal", $e, Ze, Fe);
  }
}, UnauthorizedError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(401, "The request requires to be authenticated.", "Unauthorized", $e, Ze, Fe);
  }
}, ForbiddenError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(403, "The requested action can't be peform by this resource.", "Forbidden", $e, Ze, Fe);
  }
}, PayloadTooLargeError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(413, "The request payload is too large.", "PayloadTooLarge", $e, Ze, Fe);
  }
}, InvalidPayloadError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(400, "The request payload is invalid.", "InvalidPayload", $e, Ze, Fe);
  }
}, UnsupportedMediaTypeError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(415, "The request is invalid because the content-type is not supported.", "UnsupportedMediaType", $e, Ze, Fe);
  }
}, MethodNotFoundError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(405, "The requested method does not exist.", "MethodNotFound", $e, Ze, Fe);
  }
}, ResourceNotFoundError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(404, "The requested resource does not exist.", "ResourceNotFound", $e, Ze, Fe);
  }
}, InvalidJsonSchemaError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(400, "The provided JSON schema is invalid.", "InvalidJsonSchema", $e, Ze, Fe);
  }
}, InvalidDataFormatError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(400, "The provided data doesn't respect the provided JSON schema.", "InvalidDataFormat", $e, Ze, Fe);
  }
}, InvalidIdentifierError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(400, "The provided identifier is not valid. An identifier must start with a lowercase letter, be between 2 and 100 characters long and use only alphanumeric characters.", "InvalidIdentifier", $e, Ze, Fe);
  }
}, RelationConflictError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(409, "The resource is not related with another resource. This is usually caused when providing two resources that aren't linked together.", "RelationConflict", $e, Ze, Fe);
  }
}, ReferenceNotFoundError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(400, "The provided resource reference is missing. This is usually caused when providing an invalid id inside the payload of a request.", "ReferenceNotFound", $e, Ze, Fe);
  }
}, InvalidQueryError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(400, "The provided query is invalid. This is usually caused when providing an invalid parameter for querying a resource.", "InvalidQuery", $e, Ze, Fe);
  }
}, RuntimeError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(400, "An error happened during the execution of a runtime (bot or integration).", "Runtime", $e, Ze, Fe);
  }
}, AlreadyExistsError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(409, "The record attempted to be created already exists.", "AlreadyExists", $e, Ze, Fe);
  }
}, RateLimitedError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(429, "The request has been rate limited.", "RateLimited", $e, Ze, Fe);
  }
}, PaymentRequiredError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(402, "A payment is required to perform this request.", "PaymentRequired", $e, Ze, Fe);
  }
}, QuotaExceededError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(403, "The request exceeds the allowed quota. Quotas are a soft limit that can be increased.", "QuotaExceeded", $e, Ze, Fe);
  }
}, LimitExceededError = class extends BaseApiError {
  constructor($e, Ze, Fe) {
    super(413, "The request exceeds the allowed limit. Limits are a hard limit that cannot be increased.", "LimitExceeded", $e, Ze, Fe);
  }
}, errorTypes = {
  Unknown: UnknownError,
  Internal: InternalError,
  Unauthorized: UnauthorizedError,
  Forbidden: ForbiddenError,
  PayloadTooLarge: PayloadTooLargeError,
  InvalidPayload: InvalidPayloadError,
  UnsupportedMediaType: UnsupportedMediaTypeError,
  MethodNotFound: MethodNotFoundError,
  ResourceNotFound: ResourceNotFoundError,
  InvalidJsonSchema: InvalidJsonSchemaError,
  InvalidDataFormat: InvalidDataFormatError,
  InvalidIdentifier: InvalidIdentifierError,
  RelationConflict: RelationConflictError,
  ReferenceNotFound: ReferenceNotFoundError,
  InvalidQuery: InvalidQueryError,
  Runtime: RuntimeError,
  AlreadyExists: AlreadyExistsError,
  RateLimited: RateLimitedError,
  PaymentRequired: PaymentRequiredError,
  QuotaExceeded: QuotaExceededError,
  LimitExceeded: LimitExceededError
}, errorFrom = ($e) => isApiError($e) ? $e : $e instanceof Error ? new UnknownError($e.message, $e) : typeof $e == "string" ? new UnknownError($e) : getApiErrorFromObject($e);
function getApiErrorFromObject($e) {
  if (typeof $e == "object" && "code" in $e && "type" in $e && "id" in $e && "message" in $e && typeof $e.type == "string" && typeof $e.message == "string") {
    const Ze = errorTypes[$e.type];
    return Ze ? new Ze($e.message, void 0, $e.id || "UNKNOWN") : new UnknownError(`An unclassified API error occurred: ${$e.message} (Type: ${$e.type}, Code: ${$e.code})`);
  }
  return new UnknownError("An invalid error occurred: " + JSON.stringify($e));
}
var ApiClient = class {
  constructor($e, Ze, Fe) {
    Or(this, "_innerClient");
    Or(this, "getConversation", ($e) => this._innerClient.getConversation($e).then((Ze) => Ze.data).catch((Ze) => {
      throw getError(Ze);
    }));
    Or(this, "createConversation", ({ xChatKey: $e, ...Ze }) => this._innerClient.createConversation({ xChatKey: $e, createConversationBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw getError(Fe);
    }));
    Or(this, "getOrCreateConversation", ({ xChatKey: $e, ...Ze }) => this._innerClient.getOrCreateConversation({ xChatKey: $e, getOrCreateConversationBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw getError(Fe);
    }));
    Or(this, "updateConversation", ({ id: $e, xChatKey: Ze, ...Fe }) => this._innerClient.updateConversation({ id: $e, xChatKey: Ze, updateConversationBody: Fe }).then((Ke) => Ke.data).catch((Ke) => {
      throw getError(Ke);
    }));
    Or(this, "deleteConversation", ($e) => this._innerClient.deleteConversation($e).then((Ze) => Ze.data).catch((Ze) => {
      throw getError(Ze);
    }));
    Or(this, "listConversations", ($e) => this._innerClient.listConversations($e).then((Ze) => Ze.data).catch((Ze) => {
      throw getError(Ze);
    }));
    Or(this, "listenConversation", ($e) => this._innerClient.listenConversation($e).then((Ze) => Ze.data).catch((Ze) => {
      throw getError(Ze);
    }));
    Or(this, "listConversationMessages", ($e) => this._innerClient.listConversationMessages($e).then((Ze) => Ze.data).catch((Ze) => {
      throw getError(Ze);
    }));
    Or(this, "addParticipant", ({ id: $e, xChatKey: Ze, ...Fe }) => this._innerClient.addParticipant({ id: $e, xChatKey: Ze, addParticipantBody: Fe }).then((Ke) => Ke.data).catch((Ke) => {
      throw getError(Ke);
    }));
    Or(this, "removeParticipant", ($e) => this._innerClient.removeParticipant($e).then((Ze) => Ze.data).catch((Ze) => {
      throw getError(Ze);
    }));
    Or(this, "getParticipant", ($e) => this._innerClient.getParticipant($e).then((Ze) => Ze.data).catch((Ze) => {
      throw getError(Ze);
    }));
    Or(this, "listParticipants", ($e) => this._innerClient.listParticipants($e).then((Ze) => Ze.data).catch((Ze) => {
      throw getError(Ze);
    }));
    Or(this, "getMessage", ($e) => this._innerClient.getMessage($e).then((Ze) => Ze.data).catch((Ze) => {
      throw getError(Ze);
    }));
    Or(this, "createMessage", ({ xChatKey: $e, ...Ze }) => this._innerClient.createMessage({ xChatKey: $e, createMessageBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw getError(Fe);
    }));
    Or(this, "getOrCreateMessage", ({ xChatKey: $e, ...Ze }) => this._innerClient.getOrCreateMessage({ xChatKey: $e, getOrCreateMessageBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw getError(Fe);
    }));
    Or(this, "updateMessage", ({ id: $e, xChatKey: Ze, ...Fe }) => this._innerClient.updateMessage({ id: $e, xChatKey: Ze, updateMessageBody: Fe }).then((Ke) => Ke.data).catch((Ke) => {
      throw getError(Ke);
    }));
    Or(this, "deleteMessage", ($e) => this._innerClient.deleteMessage($e).then((Ze) => Ze.data).catch((Ze) => {
      throw getError(Ze);
    }));
    Or(this, "getUser", ($e) => this._innerClient.getUser($e).then((Ze) => Ze.data).catch((Ze) => {
      throw getError(Ze);
    }));
    Or(this, "createUser", ($e) => this._innerClient.createUser({ createUserBody: $e }).then((Ze) => Ze.data).catch((Ze) => {
      throw getError(Ze);
    }));
    Or(this, "updateUser", ({ xChatKey: $e, ...Ze }) => this._innerClient.updateUser({ xChatKey: $e, updateUserBody: Ze }).then((Fe) => Fe.data).catch((Fe) => {
      throw getError(Fe);
    }));
    Or(this, "deleteUser", ($e) => this._innerClient.deleteUser($e).then((Ze) => Ze.data).catch((Ze) => {
      throw getError(Ze);
    }));
    this._innerClient = new DefaultApi($e, Ze, Fe);
  }
};
function getError($e) {
  var Ze;
  return axios_default.isAxiosError($e) && ((Ze = $e.response) != null && Ze.data) ? errorFrom($e.response.data) : errorFrom($e);
}
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
var EventEmitter = class {
  constructor() {
    Or(this, "listeners", {});
  }
  emit($e, Ze) {
    const Fe = this.listeners[$e];
    if (Fe)
      for (const Ke of [...Fe])
        Ke(Ze);
  }
  onceOrMore($e, Ze) {
    const Fe = (Ke) => {
      Ze(Ke) === "stop-listening" && this.off($e, Fe);
    };
    this.on($e, Fe);
  }
  once($e, Ze) {
    const Fe = (Ke) => {
      this.off($e, Fe), Ze(Ke);
    };
    this.on($e, Fe);
  }
  on($e, Ze) {
    this.listeners[$e] || (this.listeners[$e] = []), this.listeners[$e].push(Ze);
  }
  off($e, Ze) {
    const Fe = this.listeners[$e];
    if (!Fe)
      return;
    const Ke = Fe.indexOf(Ze);
    Ke !== -1 && Fe.splice(Ke, 1);
  }
  cleanup() {
    this.listeners = {};
  }
};
init_dirname();
init_buffer2();
init_process2();
var import_browser_or_node = __toESM(require_lib()), makeEventSource = ($e, Ze = {}) => {
  if (import_browser_or_node.isBrowser) {
    const Ke = require_eventsource().EventSourcePolyfill, Ve = new Ke($e, { headers: Ze.headers }), Je = new EventEmitter();
    return Ve.onopen = (Qe) => Je.emit("open", Qe), Ve.onmessage = (Qe) => Je.emit("message", Qe), Ve.onerror = (Qe) => Je.emit("error", Qe), {
      emitter: Je,
      source: Ve
    };
  } else {
    const Fe = require_eventsource2(), Ke = new Fe($e, { headers: Ze.headers }), Ve = new EventEmitter();
    return Ke.onopen = (Je) => Ve.emit("open", Je), Ke.onmessage = (Je) => Ve.emit("message", Je), Ke.onerror = (Je) => Ve.emit("error", Je), {
      emitter: Ve,
      source: Ke
    };
  }
}, listenEventSource = async ($e, Ze = {}) => {
  const { emitter: Fe, source: Ke } = makeEventSource($e, Ze);
  return await new Promise((Ve, Je) => {
    Fe.on("open", () => {
      Ve();
    }), Fe.on("error", (Qe) => {
      Je(Qe);
    });
  }).finally(() => Fe.cleanup()), {
    on: Fe.on.bind(Fe),
    close: () => {
      Fe.cleanup(), Ke.close();
    }
  };
};
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
init_dirname();
init_buffer2();
init_process2();
var util;
(function($e) {
  $e.assertEqual = (Ve) => Ve;
  function Ze(Ve) {
  }
  $e.assertIs = Ze;
  function Fe(Ve) {
    throw new Error();
  }
  $e.assertNever = Fe, $e.arrayToEnum = (Ve) => {
    const Je = {};
    for (const Qe of Ve)
      Je[Qe] = Qe;
    return Je;
  }, $e.getValidEnumValues = (Ve) => {
    const Je = $e.objectKeys(Ve).filter((at) => typeof Ve[Ve[at]] != "number"), Qe = {};
    for (const at of Je)
      Qe[at] = Ve[at];
    return $e.objectValues(Qe);
  }, $e.objectValues = (Ve) => $e.objectKeys(Ve).map(function(Je) {
    return Ve[Je];
  }), $e.objectKeys = typeof Object.keys == "function" ? (Ve) => Object.keys(Ve) : (Ve) => {
    const Je = [];
    for (const Qe in Ve)
      Object.prototype.hasOwnProperty.call(Ve, Qe) && Je.push(Qe);
    return Je;
  }, $e.find = (Ve, Je) => {
    for (const Qe of Ve)
      if (Je(Qe))
        return Qe;
  }, $e.isInteger = typeof Number.isInteger == "function" ? (Ve) => Number.isInteger(Ve) : (Ve) => typeof Ve == "number" && isFinite(Ve) && Math.floor(Ve) === Ve;
  function Ke(Ve, Je = " | ") {
    return Ve.map((Qe) => typeof Qe == "string" ? `'${Qe}'` : Qe).join(Je);
  }
  $e.joinValues = Ke, $e.jsonStringifyReplacer = (Ve, Je) => typeof Je == "bigint" ? Je.toString() : Je;
})(util || (util = {}));
var objectUtil;
(function($e) {
  $e.mergeShapes = (Ze, Fe) => ({
    ...Ze,
    ...Fe
  });
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), getParsedType = ($e) => {
  switch (typeof $e) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN($e) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      return Array.isArray($e) ? ZodParsedType.array : $e === null ? ZodParsedType.null : $e.then && typeof $e.then == "function" && $e.catch && typeof $e.catch == "function" ? ZodParsedType.promise : typeof Map < "u" && $e instanceof Map ? ZodParsedType.map : typeof Set < "u" && $e instanceof Set ? ZodParsedType.set : typeof Date < "u" && $e instanceof Date ? ZodParsedType.date : ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), quotelessJson = ($e) => JSON.stringify($e, null, 2).replace(/"([^"]+)":/g, "$1:"), ZodError = class extends Error {
  constructor($e) {
    super(), this.issues = [], this.addIssue = (Fe) => {
      this.issues = [...this.issues, Fe];
    }, this.addIssues = (Fe = []) => {
      this.issues = [...this.issues, ...Fe];
    };
    const Ze = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, Ze) : this.__proto__ = Ze, this.name = "ZodError", this.issues = $e;
  }
  get errors() {
    return this.issues;
  }
  format($e) {
    const Ze = $e || function(Ve) {
      return Ve.message;
    }, Fe = { _errors: [] }, Ke = (Ve) => {
      for (const Je of Ve.issues)
        if (Je.code === "invalid_union")
          Je.unionErrors.map(Ke);
        else if (Je.code === "invalid_return_type")
          Ke(Je.returnTypeError);
        else if (Je.code === "invalid_arguments")
          Ke(Je.argumentsError);
        else if (Je.path.length === 0)
          Fe._errors.push(Ze(Je));
        else {
          let Qe = Fe, at = 0;
          for (; at < Je.path.length; ) {
            const ut = Je.path[at];
            at === Je.path.length - 1 ? (Qe[ut] = Qe[ut] || { _errors: [] }, Qe[ut]._errors.push(Ze(Je))) : Qe[ut] = Qe[ut] || { _errors: [] }, Qe = Qe[ut], at++;
          }
        }
    };
    return Ke(this), Fe;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten($e = (Ze) => Ze.message) {
    const Ze = {}, Fe = [];
    for (const Ke of this.issues)
      Ke.path.length > 0 ? (Ze[Ke.path[0]] = Ze[Ke.path[0]] || [], Ze[Ke.path[0]].push($e(Ke))) : Fe.push($e(Ke));
    return { formErrors: Fe, fieldErrors: Ze };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = ($e) => new ZodError($e);
var errorMap = ($e, Ze) => {
  let Fe;
  switch ($e.code) {
    case ZodIssueCode.invalid_type:
      $e.received === ZodParsedType.undefined ? Fe = "Required" : Fe = `Expected ${$e.expected}, received ${$e.received}`;
      break;
    case ZodIssueCode.invalid_literal:
      Fe = `Invalid literal value, expected ${JSON.stringify($e.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      Fe = `Unrecognized key(s) in object: ${util.joinValues($e.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      Fe = "Invalid input";
      break;
    case ZodIssueCode.invalid_union_discriminator:
      Fe = `Invalid discriminator value. Expected ${util.joinValues($e.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      Fe = `Invalid enum value. Expected ${util.joinValues($e.options)}, received '${$e.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      Fe = "Invalid function arguments";
      break;
    case ZodIssueCode.invalid_return_type:
      Fe = "Invalid function return type";
      break;
    case ZodIssueCode.invalid_date:
      Fe = "Invalid date";
      break;
    case ZodIssueCode.invalid_string:
      typeof $e.validation == "object" ? "includes" in $e.validation ? (Fe = `Invalid input: must include "${$e.validation.includes}"`, typeof $e.validation.position == "number" && (Fe = `${Fe} at one or more positions greater than or equal to ${$e.validation.position}`)) : "startsWith" in $e.validation ? Fe = `Invalid input: must start with "${$e.validation.startsWith}"` : "endsWith" in $e.validation ? Fe = `Invalid input: must end with "${$e.validation.endsWith}"` : util.assertNever($e.validation) : $e.validation !== "regex" ? Fe = `Invalid ${$e.validation}` : Fe = "Invalid";
      break;
    case ZodIssueCode.too_small:
      $e.type === "array" ? Fe = `Array must contain ${$e.exact ? "exactly" : $e.inclusive ? "at least" : "more than"} ${$e.minimum} element(s)` : $e.type === "string" ? Fe = `String must contain ${$e.exact ? "exactly" : $e.inclusive ? "at least" : "over"} ${$e.minimum} character(s)` : $e.type === "number" ? Fe = `Number must be ${$e.exact ? "exactly equal to " : $e.inclusive ? "greater than or equal to " : "greater than "}${$e.minimum}` : $e.type === "date" ? Fe = `Date must be ${$e.exact ? "exactly equal to " : $e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number($e.minimum))}` : Fe = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      $e.type === "array" ? Fe = `Array must contain ${$e.exact ? "exactly" : $e.inclusive ? "at most" : "less than"} ${$e.maximum} element(s)` : $e.type === "string" ? Fe = `String must contain ${$e.exact ? "exactly" : $e.inclusive ? "at most" : "under"} ${$e.maximum} character(s)` : $e.type === "number" ? Fe = `Number must be ${$e.exact ? "exactly" : $e.inclusive ? "less than or equal to" : "less than"} ${$e.maximum}` : $e.type === "bigint" ? Fe = `BigInt must be ${$e.exact ? "exactly" : $e.inclusive ? "less than or equal to" : "less than"} ${$e.maximum}` : $e.type === "date" ? Fe = `Date must be ${$e.exact ? "exactly" : $e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number($e.maximum))}` : Fe = "Invalid input";
      break;
    case ZodIssueCode.custom:
      Fe = "Invalid input";
      break;
    case ZodIssueCode.invalid_intersection_types:
      Fe = "Intersection results could not be merged";
      break;
    case ZodIssueCode.not_multiple_of:
      Fe = `Number must be a multiple of ${$e.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      Fe = "Number must be finite";
      break;
    default:
      Fe = Ze.defaultError, util.assertNever($e);
  }
  return { message: Fe };
}, overrideErrorMap = errorMap;
function setErrorMap($e) {
  overrideErrorMap = $e;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = ($e) => {
  const { data: Ze, path: Fe, errorMaps: Ke, issueData: Ve } = $e, Je = [...Fe, ...Ve.path || []], Qe = {
    ...Ve,
    path: Je
  };
  let at = "";
  const ut = Ke.filter((lt) => !!lt).slice().reverse();
  for (const lt of ut)
    at = lt(Qe, { data: Ze, defaultError: at }).message;
  return {
    ...Ve,
    path: Je,
    message: Ve.message || at
  };
}, EMPTY_PATH = [];
function addIssueToContext($e, Ze) {
  const Fe = makeIssue({
    issueData: Ze,
    data: $e.data,
    path: $e.path,
    errorMaps: [
      $e.common.contextualErrorMap,
      $e.schemaErrorMap,
      getErrorMap(),
      errorMap
    ].filter((Ke) => !!Ke)
  });
  $e.common.issues.push(Fe);
}
var ParseStatus = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray($e, Ze) {
    const Fe = [];
    for (const Ke of Ze) {
      if (Ke.status === "aborted")
        return INVALID;
      Ke.status === "dirty" && $e.dirty(), Fe.push(Ke.value);
    }
    return { status: $e.value, value: Fe };
  }
  static async mergeObjectAsync($e, Ze) {
    const Fe = [];
    for (const Ke of Ze)
      Fe.push({
        key: await Ke.key,
        value: await Ke.value
      });
    return ParseStatus.mergeObjectSync($e, Fe);
  }
  static mergeObjectSync($e, Ze) {
    const Fe = {};
    for (const Ke of Ze) {
      const { key: Ve, value: Je } = Ke;
      if (Ve.status === "aborted" || Je.status === "aborted")
        return INVALID;
      Ve.status === "dirty" && $e.dirty(), Je.status === "dirty" && $e.dirty(), (typeof Je.value < "u" || Ke.alwaysSet) && (Fe[Ve.value] = Je.value);
    }
    return { status: $e.value, value: Fe };
  }
}, INVALID = Object.freeze({
  status: "aborted"
}), DIRTY = ($e) => ({ status: "dirty", value: $e }), OK = ($e) => ({ status: "valid", value: $e }), isAborted = ($e) => $e.status === "aborted", isDirty = ($e) => $e.status === "dirty", isValid = ($e) => $e.status === "valid", isAsync = ($e) => typeof Promise < "u" && $e instanceof Promise, errorUtil;
(function($e) {
  $e.errToObj = (Ze) => typeof Ze == "string" ? { message: Ze } : Ze || {}, $e.toString = (Ze) => typeof Ze == "string" ? Ze : Ze == null ? void 0 : Ze.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor($e, Ze, Fe, Ke) {
    this._cachedPath = [], this.parent = $e, this.data = Ze, this._path = Fe, this._key = Ke;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}, handleResult = ($e, Ze) => {
  if (isValid(Ze))
    return { success: !0, data: Ze.value };
  if (!$e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const Fe = new ZodError($e.common.issues);
      return this._error = Fe, this._error;
    }
  };
};
function processCreateParams($e) {
  if (!$e)
    return {};
  const { errorMap: Ze, invalid_type_error: Fe, required_error: Ke, description: Ve } = $e;
  if (Ze && (Fe || Ke))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return Ze ? { errorMap: Ze, description: Ve } : { errorMap: (Qe, at) => Qe.code !== "invalid_type" ? { message: at.defaultError } : typeof at.data > "u" ? { message: Ke ?? at.defaultError } : { message: Fe ?? at.defaultError }, description: Ve };
}
var ZodType = class {
  constructor($e) {
    this.spa = this.safeParseAsync, this._def = $e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType($e) {
    return getParsedType($e.data);
  }
  _getOrReturnCtx($e, Ze) {
    return Ze || {
      common: $e.parent.common,
      data: $e.data,
      parsedType: getParsedType($e.data),
      schemaErrorMap: this._def.errorMap,
      path: $e.path,
      parent: $e.parent
    };
  }
  _processInputParams($e) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: $e.parent.common,
        data: $e.data,
        parsedType: getParsedType($e.data),
        schemaErrorMap: this._def.errorMap,
        path: $e.path,
        parent: $e.parent
      }
    };
  }
  _parseSync($e) {
    const Ze = this._parse($e);
    if (isAsync(Ze))
      throw new Error("Synchronous parse encountered promise.");
    return Ze;
  }
  _parseAsync($e) {
    const Ze = this._parse($e);
    return Promise.resolve(Ze);
  }
  parse($e, Ze) {
    const Fe = this.safeParse($e, Ze);
    if (Fe.success)
      return Fe.data;
    throw Fe.error;
  }
  safeParse($e, Ze) {
    var Fe;
    const Ke = {
      common: {
        issues: [],
        async: (Fe = Ze == null ? void 0 : Ze.async) !== null && Fe !== void 0 ? Fe : !1,
        contextualErrorMap: Ze == null ? void 0 : Ze.errorMap
      },
      path: (Ze == null ? void 0 : Ze.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: $e,
      parsedType: getParsedType($e)
    }, Ve = this._parseSync({ data: $e, path: Ke.path, parent: Ke });
    return handleResult(Ke, Ve);
  }
  async parseAsync($e, Ze) {
    const Fe = await this.safeParseAsync($e, Ze);
    if (Fe.success)
      return Fe.data;
    throw Fe.error;
  }
  async safeParseAsync($e, Ze) {
    const Fe = {
      common: {
        issues: [],
        contextualErrorMap: Ze == null ? void 0 : Ze.errorMap,
        async: !0
      },
      path: (Ze == null ? void 0 : Ze.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: $e,
      parsedType: getParsedType($e)
    }, Ke = this._parse({ data: $e, path: Fe.path, parent: Fe }), Ve = await (isAsync(Ke) ? Ke : Promise.resolve(Ke));
    return handleResult(Fe, Ve);
  }
  refine($e, Ze) {
    const Fe = (Ke) => typeof Ze == "string" || typeof Ze > "u" ? { message: Ze } : typeof Ze == "function" ? Ze(Ke) : Ze;
    return this._refinement((Ke, Ve) => {
      const Je = $e(Ke), Qe = () => Ve.addIssue({
        code: ZodIssueCode.custom,
        ...Fe(Ke)
      });
      return typeof Promise < "u" && Je instanceof Promise ? Je.then((at) => at ? !0 : (Qe(), !1)) : Je ? !0 : (Qe(), !1);
    });
  }
  refinement($e, Ze) {
    return this._refinement((Fe, Ke) => $e(Fe) ? !0 : (Ke.addIssue(typeof Ze == "function" ? Ze(Fe, Ke) : Ze), !1));
  }
  _refinement($e) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement: $e }
    });
  }
  superRefine($e) {
    return this._refinement($e);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or($e) {
    return ZodUnion.create([this, $e], this._def);
  }
  and($e) {
    return ZodIntersection.create(this, $e, this._def);
  }
  transform($e) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: $e }
    });
  }
  default($e) {
    const Ze = typeof $e == "function" ? $e : () => $e;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: Ze,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch($e) {
    const Ze = typeof $e == "function" ? $e : () => $e;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: Ze,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe($e) {
    const Ze = this.constructor;
    return new Ze({
      ...this._def,
      description: $e
    });
  }
  pipe($e) {
    return ZodPipeline.create(this, $e);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}, cuidRegex = /^c[^\s-]{8,}$/i, cuid2Regex = /^[a-z][a-z0-9]*$/, ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/, uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, datetimeRegex = ($e) => $e.precision ? $e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${$e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${$e.precision}}Z$`) : $e.precision === 0 ? $e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : $e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function isValidIP($e, Ze) {
  return !!((Ze === "v4" || !Ze) && ipv4Regex.test($e) || (Ze === "v6" || !Ze) && ipv6Regex.test($e));
}
var ZodString = class extends ZodType {
  constructor() {
    super(...arguments), this._regex = ($e, Ze, Fe) => this.refinement((Ke) => $e.test(Ke), {
      validation: Ze,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(Fe)
    }), this.nonempty = ($e) => this.min(1, errorUtil.errToObj($e)), this.trim = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse($e) {
    if (this._def.coerce && ($e.data = String($e.data)), this._getType($e) !== ZodParsedType.string) {
      const Ve = this._getOrReturnCtx($e);
      return addIssueToContext(
        Ve,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: Ve.parsedType
        }
      ), INVALID;
    }
    const Fe = new ParseStatus();
    let Ke;
    for (const Ve of this._def.checks)
      if (Ve.kind === "min")
        $e.data.length < Ve.value && (Ke = this._getOrReturnCtx($e, Ke), addIssueToContext(Ke, {
          code: ZodIssueCode.too_small,
          minimum: Ve.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: Ve.message
        }), Fe.dirty());
      else if (Ve.kind === "max")
        $e.data.length > Ve.value && (Ke = this._getOrReturnCtx($e, Ke), addIssueToContext(Ke, {
          code: ZodIssueCode.too_big,
          maximum: Ve.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: Ve.message
        }), Fe.dirty());
      else if (Ve.kind === "length") {
        const Je = $e.data.length > Ve.value, Qe = $e.data.length < Ve.value;
        (Je || Qe) && (Ke = this._getOrReturnCtx($e, Ke), Je ? addIssueToContext(Ke, {
          code: ZodIssueCode.too_big,
          maximum: Ve.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: Ve.message
        }) : Qe && addIssueToContext(Ke, {
          code: ZodIssueCode.too_small,
          minimum: Ve.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: Ve.message
        }), Fe.dirty());
      } else if (Ve.kind === "email")
        emailRegex.test($e.data) || (Ke = this._getOrReturnCtx($e, Ke), addIssueToContext(Ke, {
          validation: "email",
          code: ZodIssueCode.invalid_string,
          message: Ve.message
        }), Fe.dirty());
      else if (Ve.kind === "emoji")
        emojiRegex.test($e.data) || (Ke = this._getOrReturnCtx($e, Ke), addIssueToContext(Ke, {
          validation: "emoji",
          code: ZodIssueCode.invalid_string,
          message: Ve.message
        }), Fe.dirty());
      else if (Ve.kind === "uuid")
        uuidRegex.test($e.data) || (Ke = this._getOrReturnCtx($e, Ke), addIssueToContext(Ke, {
          validation: "uuid",
          code: ZodIssueCode.invalid_string,
          message: Ve.message
        }), Fe.dirty());
      else if (Ve.kind === "cuid")
        cuidRegex.test($e.data) || (Ke = this._getOrReturnCtx($e, Ke), addIssueToContext(Ke, {
          validation: "cuid",
          code: ZodIssueCode.invalid_string,
          message: Ve.message
        }), Fe.dirty());
      else if (Ve.kind === "cuid2")
        cuid2Regex.test($e.data) || (Ke = this._getOrReturnCtx($e, Ke), addIssueToContext(Ke, {
          validation: "cuid2",
          code: ZodIssueCode.invalid_string,
          message: Ve.message
        }), Fe.dirty());
      else if (Ve.kind === "ulid")
        ulidRegex.test($e.data) || (Ke = this._getOrReturnCtx($e, Ke), addIssueToContext(Ke, {
          validation: "ulid",
          code: ZodIssueCode.invalid_string,
          message: Ve.message
        }), Fe.dirty());
      else if (Ve.kind === "url")
        try {
          new URL($e.data);
        } catch {
          Ke = this._getOrReturnCtx($e, Ke), addIssueToContext(Ke, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: Ve.message
          }), Fe.dirty();
        }
      else
        Ve.kind === "regex" ? (Ve.regex.lastIndex = 0, Ve.regex.test($e.data) || (Ke = this._getOrReturnCtx($e, Ke), addIssueToContext(Ke, {
          validation: "regex",
          code: ZodIssueCode.invalid_string,
          message: Ve.message
        }), Fe.dirty())) : Ve.kind === "trim" ? $e.data = $e.data.trim() : Ve.kind === "includes" ? $e.data.includes(Ve.value, Ve.position) || (Ke = this._getOrReturnCtx($e, Ke), addIssueToContext(Ke, {
          code: ZodIssueCode.invalid_string,
          validation: { includes: Ve.value, position: Ve.position },
          message: Ve.message
        }), Fe.dirty()) : Ve.kind === "toLowerCase" ? $e.data = $e.data.toLowerCase() : Ve.kind === "toUpperCase" ? $e.data = $e.data.toUpperCase() : Ve.kind === "startsWith" ? $e.data.startsWith(Ve.value) || (Ke = this._getOrReturnCtx($e, Ke), addIssueToContext(Ke, {
          code: ZodIssueCode.invalid_string,
          validation: { startsWith: Ve.value },
          message: Ve.message
        }), Fe.dirty()) : Ve.kind === "endsWith" ? $e.data.endsWith(Ve.value) || (Ke = this._getOrReturnCtx($e, Ke), addIssueToContext(Ke, {
          code: ZodIssueCode.invalid_string,
          validation: { endsWith: Ve.value },
          message: Ve.message
        }), Fe.dirty()) : Ve.kind === "datetime" ? datetimeRegex(Ve).test($e.data) || (Ke = this._getOrReturnCtx($e, Ke), addIssueToContext(Ke, {
          code: ZodIssueCode.invalid_string,
          validation: "datetime",
          message: Ve.message
        }), Fe.dirty()) : Ve.kind === "ip" ? isValidIP($e.data, Ve.version) || (Ke = this._getOrReturnCtx($e, Ke), addIssueToContext(Ke, {
          validation: "ip",
          code: ZodIssueCode.invalid_string,
          message: Ve.message
        }), Fe.dirty()) : util.assertNever(Ve);
    return { status: Fe.value, value: $e.data };
  }
  _addCheck($e) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, $e]
    });
  }
  email($e) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj($e) });
  }
  url($e) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj($e) });
  }
  emoji($e) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj($e) });
  }
  uuid($e) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj($e) });
  }
  cuid($e) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj($e) });
  }
  cuid2($e) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj($e) });
  }
  ulid($e) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj($e) });
  }
  ip($e) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj($e) });
  }
  datetime($e) {
    var Ze;
    return typeof $e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: $e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof ($e == null ? void 0 : $e.precision) > "u" ? null : $e == null ? void 0 : $e.precision,
      offset: (Ze = $e == null ? void 0 : $e.offset) !== null && Ze !== void 0 ? Ze : !1,
      ...errorUtil.errToObj($e == null ? void 0 : $e.message)
    });
  }
  regex($e, Ze) {
    return this._addCheck({
      kind: "regex",
      regex: $e,
      ...errorUtil.errToObj(Ze)
    });
  }
  includes($e, Ze) {
    return this._addCheck({
      kind: "includes",
      value: $e,
      position: Ze == null ? void 0 : Ze.position,
      ...errorUtil.errToObj(Ze == null ? void 0 : Ze.message)
    });
  }
  startsWith($e, Ze) {
    return this._addCheck({
      kind: "startsWith",
      value: $e,
      ...errorUtil.errToObj(Ze)
    });
  }
  endsWith($e, Ze) {
    return this._addCheck({
      kind: "endsWith",
      value: $e,
      ...errorUtil.errToObj(Ze)
    });
  }
  min($e, Ze) {
    return this._addCheck({
      kind: "min",
      value: $e,
      ...errorUtil.errToObj(Ze)
    });
  }
  max($e, Ze) {
    return this._addCheck({
      kind: "max",
      value: $e,
      ...errorUtil.errToObj(Ze)
    });
  }
  length($e, Ze) {
    return this._addCheck({
      kind: "length",
      value: $e,
      ...errorUtil.errToObj(Ze)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find(($e) => $e.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find(($e) => $e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find(($e) => $e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find(($e) => $e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find(($e) => $e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find(($e) => $e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find(($e) => $e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find(($e) => $e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find(($e) => $e.kind === "ip");
  }
  get minLength() {
    let $e = null;
    for (const Ze of this._def.checks)
      Ze.kind === "min" && ($e === null || Ze.value > $e) && ($e = Ze.value);
    return $e;
  }
  get maxLength() {
    let $e = null;
    for (const Ze of this._def.checks)
      Ze.kind === "max" && ($e === null || Ze.value < $e) && ($e = Ze.value);
    return $e;
  }
};
ZodString.create = ($e) => {
  var Ze;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (Ze = $e == null ? void 0 : $e.coerce) !== null && Ze !== void 0 ? Ze : !1,
    ...processCreateParams($e)
  });
};
function floatSafeRemainder($e, Ze) {
  const Fe = ($e.toString().split(".")[1] || "").length, Ke = (Ze.toString().split(".")[1] || "").length, Ve = Fe > Ke ? Fe : Ke, Je = parseInt($e.toFixed(Ve).replace(".", "")), Qe = parseInt(Ze.toFixed(Ve).replace(".", ""));
  return Je % Qe / Math.pow(10, Ve);
}
var ZodNumber = class extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse($e) {
    if (this._def.coerce && ($e.data = Number($e.data)), this._getType($e) !== ZodParsedType.number) {
      const Ve = this._getOrReturnCtx($e);
      return addIssueToContext(Ve, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: Ve.parsedType
      }), INVALID;
    }
    let Fe;
    const Ke = new ParseStatus();
    for (const Ve of this._def.checks)
      Ve.kind === "int" ? util.isInteger($e.data) || (Fe = this._getOrReturnCtx($e, Fe), addIssueToContext(Fe, {
        code: ZodIssueCode.invalid_type,
        expected: "integer",
        received: "float",
        message: Ve.message
      }), Ke.dirty()) : Ve.kind === "min" ? (Ve.inclusive ? $e.data < Ve.value : $e.data <= Ve.value) && (Fe = this._getOrReturnCtx($e, Fe), addIssueToContext(Fe, {
        code: ZodIssueCode.too_small,
        minimum: Ve.value,
        type: "number",
        inclusive: Ve.inclusive,
        exact: !1,
        message: Ve.message
      }), Ke.dirty()) : Ve.kind === "max" ? (Ve.inclusive ? $e.data > Ve.value : $e.data >= Ve.value) && (Fe = this._getOrReturnCtx($e, Fe), addIssueToContext(Fe, {
        code: ZodIssueCode.too_big,
        maximum: Ve.value,
        type: "number",
        inclusive: Ve.inclusive,
        exact: !1,
        message: Ve.message
      }), Ke.dirty()) : Ve.kind === "multipleOf" ? floatSafeRemainder($e.data, Ve.value) !== 0 && (Fe = this._getOrReturnCtx($e, Fe), addIssueToContext(Fe, {
        code: ZodIssueCode.not_multiple_of,
        multipleOf: Ve.value,
        message: Ve.message
      }), Ke.dirty()) : Ve.kind === "finite" ? Number.isFinite($e.data) || (Fe = this._getOrReturnCtx($e, Fe), addIssueToContext(Fe, {
        code: ZodIssueCode.not_finite,
        message: Ve.message
      }), Ke.dirty()) : util.assertNever(Ve);
    return { status: Ke.value, value: $e.data };
  }
  gte($e, Ze) {
    return this.setLimit("min", $e, !0, errorUtil.toString(Ze));
  }
  gt($e, Ze) {
    return this.setLimit("min", $e, !1, errorUtil.toString(Ze));
  }
  lte($e, Ze) {
    return this.setLimit("max", $e, !0, errorUtil.toString(Ze));
  }
  lt($e, Ze) {
    return this.setLimit("max", $e, !1, errorUtil.toString(Ze));
  }
  setLimit($e, Ze, Fe, Ke) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: $e,
          value: Ze,
          inclusive: Fe,
          message: errorUtil.toString(Ke)
        }
      ]
    });
  }
  _addCheck($e) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, $e]
    });
  }
  int($e) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString($e)
    });
  }
  positive($e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString($e)
    });
  }
  negative($e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString($e)
    });
  }
  nonpositive($e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString($e)
    });
  }
  nonnegative($e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString($e)
    });
  }
  multipleOf($e, Ze) {
    return this._addCheck({
      kind: "multipleOf",
      value: $e,
      message: errorUtil.toString(Ze)
    });
  }
  finite($e) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString($e)
    });
  }
  safe($e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString($e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString($e)
    });
  }
  get minValue() {
    let $e = null;
    for (const Ze of this._def.checks)
      Ze.kind === "min" && ($e === null || Ze.value > $e) && ($e = Ze.value);
    return $e;
  }
  get maxValue() {
    let $e = null;
    for (const Ze of this._def.checks)
      Ze.kind === "max" && ($e === null || Ze.value < $e) && ($e = Ze.value);
    return $e;
  }
  get isInt() {
    return !!this._def.checks.find(($e) => $e.kind === "int" || $e.kind === "multipleOf" && util.isInteger($e.value));
  }
  get isFinite() {
    let $e = null, Ze = null;
    for (const Fe of this._def.checks) {
      if (Fe.kind === "finite" || Fe.kind === "int" || Fe.kind === "multipleOf")
        return !0;
      Fe.kind === "min" ? (Ze === null || Fe.value > Ze) && (Ze = Fe.value) : Fe.kind === "max" && ($e === null || Fe.value < $e) && ($e = Fe.value);
    }
    return Number.isFinite(Ze) && Number.isFinite($e);
  }
};
ZodNumber.create = ($e) => new ZodNumber({
  checks: [],
  typeName: ZodFirstPartyTypeKind.ZodNumber,
  coerce: ($e == null ? void 0 : $e.coerce) || !1,
  ...processCreateParams($e)
});
var ZodBigInt = class extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse($e) {
    if (this._def.coerce && ($e.data = BigInt($e.data)), this._getType($e) !== ZodParsedType.bigint) {
      const Ve = this._getOrReturnCtx($e);
      return addIssueToContext(Ve, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: Ve.parsedType
      }), INVALID;
    }
    let Fe;
    const Ke = new ParseStatus();
    for (const Ve of this._def.checks)
      Ve.kind === "min" ? (Ve.inclusive ? $e.data < Ve.value : $e.data <= Ve.value) && (Fe = this._getOrReturnCtx($e, Fe), addIssueToContext(Fe, {
        code: ZodIssueCode.too_small,
        type: "bigint",
        minimum: Ve.value,
        inclusive: Ve.inclusive,
        message: Ve.message
      }), Ke.dirty()) : Ve.kind === "max" ? (Ve.inclusive ? $e.data > Ve.value : $e.data >= Ve.value) && (Fe = this._getOrReturnCtx($e, Fe), addIssueToContext(Fe, {
        code: ZodIssueCode.too_big,
        type: "bigint",
        maximum: Ve.value,
        inclusive: Ve.inclusive,
        message: Ve.message
      }), Ke.dirty()) : Ve.kind === "multipleOf" ? $e.data % Ve.value !== BigInt(0) && (Fe = this._getOrReturnCtx($e, Fe), addIssueToContext(Fe, {
        code: ZodIssueCode.not_multiple_of,
        multipleOf: Ve.value,
        message: Ve.message
      }), Ke.dirty()) : util.assertNever(Ve);
    return { status: Ke.value, value: $e.data };
  }
  gte($e, Ze) {
    return this.setLimit("min", $e, !0, errorUtil.toString(Ze));
  }
  gt($e, Ze) {
    return this.setLimit("min", $e, !1, errorUtil.toString(Ze));
  }
  lte($e, Ze) {
    return this.setLimit("max", $e, !0, errorUtil.toString(Ze));
  }
  lt($e, Ze) {
    return this.setLimit("max", $e, !1, errorUtil.toString(Ze));
  }
  setLimit($e, Ze, Fe, Ke) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: $e,
          value: Ze,
          inclusive: Fe,
          message: errorUtil.toString(Ke)
        }
      ]
    });
  }
  _addCheck($e) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, $e]
    });
  }
  positive($e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString($e)
    });
  }
  negative($e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString($e)
    });
  }
  nonpositive($e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString($e)
    });
  }
  nonnegative($e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString($e)
    });
  }
  multipleOf($e, Ze) {
    return this._addCheck({
      kind: "multipleOf",
      value: $e,
      message: errorUtil.toString(Ze)
    });
  }
  get minValue() {
    let $e = null;
    for (const Ze of this._def.checks)
      Ze.kind === "min" && ($e === null || Ze.value > $e) && ($e = Ze.value);
    return $e;
  }
  get maxValue() {
    let $e = null;
    for (const Ze of this._def.checks)
      Ze.kind === "max" && ($e === null || Ze.value < $e) && ($e = Ze.value);
    return $e;
  }
};
ZodBigInt.create = ($e) => {
  var Ze;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (Ze = $e == null ? void 0 : $e.coerce) !== null && Ze !== void 0 ? Ze : !1,
    ...processCreateParams($e)
  });
};
var ZodBoolean = class extends ZodType {
  _parse($e) {
    if (this._def.coerce && ($e.data = !!$e.data), this._getType($e) !== ZodParsedType.boolean) {
      const Fe = this._getOrReturnCtx($e);
      return addIssueToContext(Fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: Fe.parsedType
      }), INVALID;
    }
    return OK($e.data);
  }
};
ZodBoolean.create = ($e) => new ZodBoolean({
  typeName: ZodFirstPartyTypeKind.ZodBoolean,
  coerce: ($e == null ? void 0 : $e.coerce) || !1,
  ...processCreateParams($e)
});
var ZodDate = class extends ZodType {
  _parse($e) {
    if (this._def.coerce && ($e.data = new Date($e.data)), this._getType($e) !== ZodParsedType.date) {
      const Ve = this._getOrReturnCtx($e);
      return addIssueToContext(Ve, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: Ve.parsedType
      }), INVALID;
    }
    if (isNaN($e.data.getTime())) {
      const Ve = this._getOrReturnCtx($e);
      return addIssueToContext(Ve, {
        code: ZodIssueCode.invalid_date
      }), INVALID;
    }
    const Fe = new ParseStatus();
    let Ke;
    for (const Ve of this._def.checks)
      Ve.kind === "min" ? $e.data.getTime() < Ve.value && (Ke = this._getOrReturnCtx($e, Ke), addIssueToContext(Ke, {
        code: ZodIssueCode.too_small,
        message: Ve.message,
        inclusive: !0,
        exact: !1,
        minimum: Ve.value,
        type: "date"
      }), Fe.dirty()) : Ve.kind === "max" ? $e.data.getTime() > Ve.value && (Ke = this._getOrReturnCtx($e, Ke), addIssueToContext(Ke, {
        code: ZodIssueCode.too_big,
        message: Ve.message,
        inclusive: !0,
        exact: !1,
        maximum: Ve.value,
        type: "date"
      }), Fe.dirty()) : util.assertNever(Ve);
    return {
      status: Fe.value,
      value: new Date($e.data.getTime())
    };
  }
  _addCheck($e) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, $e]
    });
  }
  min($e, Ze) {
    return this._addCheck({
      kind: "min",
      value: $e.getTime(),
      message: errorUtil.toString(Ze)
    });
  }
  max($e, Ze) {
    return this._addCheck({
      kind: "max",
      value: $e.getTime(),
      message: errorUtil.toString(Ze)
    });
  }
  get minDate() {
    let $e = null;
    for (const Ze of this._def.checks)
      Ze.kind === "min" && ($e === null || Ze.value > $e) && ($e = Ze.value);
    return $e != null ? new Date($e) : null;
  }
  get maxDate() {
    let $e = null;
    for (const Ze of this._def.checks)
      Ze.kind === "max" && ($e === null || Ze.value < $e) && ($e = Ze.value);
    return $e != null ? new Date($e) : null;
  }
};
ZodDate.create = ($e) => new ZodDate({
  checks: [],
  coerce: ($e == null ? void 0 : $e.coerce) || !1,
  typeName: ZodFirstPartyTypeKind.ZodDate,
  ...processCreateParams($e)
});
var ZodSymbol = class extends ZodType {
  _parse($e) {
    if (this._getType($e) !== ZodParsedType.symbol) {
      const Fe = this._getOrReturnCtx($e);
      return addIssueToContext(Fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: Fe.parsedType
      }), INVALID;
    }
    return OK($e.data);
  }
};
ZodSymbol.create = ($e) => new ZodSymbol({
  typeName: ZodFirstPartyTypeKind.ZodSymbol,
  ...processCreateParams($e)
});
var ZodUndefined = class extends ZodType {
  _parse($e) {
    if (this._getType($e) !== ZodParsedType.undefined) {
      const Fe = this._getOrReturnCtx($e);
      return addIssueToContext(Fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: Fe.parsedType
      }), INVALID;
    }
    return OK($e.data);
  }
};
ZodUndefined.create = ($e) => new ZodUndefined({
  typeName: ZodFirstPartyTypeKind.ZodUndefined,
  ...processCreateParams($e)
});
var ZodNull = class extends ZodType {
  _parse($e) {
    if (this._getType($e) !== ZodParsedType.null) {
      const Fe = this._getOrReturnCtx($e);
      return addIssueToContext(Fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: Fe.parsedType
      }), INVALID;
    }
    return OK($e.data);
  }
};
ZodNull.create = ($e) => new ZodNull({
  typeName: ZodFirstPartyTypeKind.ZodNull,
  ...processCreateParams($e)
});
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse($e) {
    return OK($e.data);
  }
};
ZodAny.create = ($e) => new ZodAny({
  typeName: ZodFirstPartyTypeKind.ZodAny,
  ...processCreateParams($e)
});
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse($e) {
    return OK($e.data);
  }
};
ZodUnknown.create = ($e) => new ZodUnknown({
  typeName: ZodFirstPartyTypeKind.ZodUnknown,
  ...processCreateParams($e)
});
var ZodNever = class extends ZodType {
  _parse($e) {
    const Ze = this._getOrReturnCtx($e);
    return addIssueToContext(Ze, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: Ze.parsedType
    }), INVALID;
  }
};
ZodNever.create = ($e) => new ZodNever({
  typeName: ZodFirstPartyTypeKind.ZodNever,
  ...processCreateParams($e)
});
var ZodVoid = class extends ZodType {
  _parse($e) {
    if (this._getType($e) !== ZodParsedType.undefined) {
      const Fe = this._getOrReturnCtx($e);
      return addIssueToContext(Fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: Fe.parsedType
      }), INVALID;
    }
    return OK($e.data);
  }
};
ZodVoid.create = ($e) => new ZodVoid({
  typeName: ZodFirstPartyTypeKind.ZodVoid,
  ...processCreateParams($e)
});
var ZodArray = class extends ZodType {
  _parse($e) {
    const { ctx: Ze, status: Fe } = this._processInputParams($e), Ke = this._def;
    if (Ze.parsedType !== ZodParsedType.array)
      return addIssueToContext(Ze, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: Ze.parsedType
      }), INVALID;
    if (Ke.exactLength !== null) {
      const Je = Ze.data.length > Ke.exactLength.value, Qe = Ze.data.length < Ke.exactLength.value;
      (Je || Qe) && (addIssueToContext(Ze, {
        code: Je ? ZodIssueCode.too_big : ZodIssueCode.too_small,
        minimum: Qe ? Ke.exactLength.value : void 0,
        maximum: Je ? Ke.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: Ke.exactLength.message
      }), Fe.dirty());
    }
    if (Ke.minLength !== null && Ze.data.length < Ke.minLength.value && (addIssueToContext(Ze, {
      code: ZodIssueCode.too_small,
      minimum: Ke.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: Ke.minLength.message
    }), Fe.dirty()), Ke.maxLength !== null && Ze.data.length > Ke.maxLength.value && (addIssueToContext(Ze, {
      code: ZodIssueCode.too_big,
      maximum: Ke.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: Ke.maxLength.message
    }), Fe.dirty()), Ze.common.async)
      return Promise.all([...Ze.data].map((Je, Qe) => Ke.type._parseAsync(new ParseInputLazyPath(Ze, Je, Ze.path, Qe)))).then((Je) => ParseStatus.mergeArray(Fe, Je));
    const Ve = [...Ze.data].map((Je, Qe) => Ke.type._parseSync(new ParseInputLazyPath(Ze, Je, Ze.path, Qe)));
    return ParseStatus.mergeArray(Fe, Ve);
  }
  get element() {
    return this._def.type;
  }
  min($e, Ze) {
    return new ZodArray({
      ...this._def,
      minLength: { value: $e, message: errorUtil.toString(Ze) }
    });
  }
  max($e, Ze) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: $e, message: errorUtil.toString(Ze) }
    });
  }
  length($e, Ze) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: $e, message: errorUtil.toString(Ze) }
    });
  }
  nonempty($e) {
    return this.min(1, $e);
  }
};
ZodArray.create = ($e, Ze) => new ZodArray({
  type: $e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ZodFirstPartyTypeKind.ZodArray,
  ...processCreateParams(Ze)
});
function deepPartialify($e) {
  if ($e instanceof ZodObject) {
    const Ze = {};
    for (const Fe in $e.shape) {
      const Ke = $e.shape[Fe];
      Ze[Fe] = ZodOptional.create(deepPartialify(Ke));
    }
    return new ZodObject({
      ...$e._def,
      shape: () => Ze
    });
  } else
    return $e instanceof ZodArray ? new ZodArray({
      ...$e._def,
      type: deepPartialify($e.element)
    }) : $e instanceof ZodOptional ? ZodOptional.create(deepPartialify($e.unwrap())) : $e instanceof ZodNullable ? ZodNullable.create(deepPartialify($e.unwrap())) : $e instanceof ZodTuple ? ZodTuple.create($e.items.map((Ze) => deepPartialify(Ze))) : $e;
}
var ZodObject = class extends ZodType {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const $e = this._def.shape(), Ze = util.objectKeys($e);
    return this._cached = { shape: $e, keys: Ze };
  }
  _parse($e) {
    if (this._getType($e) !== ZodParsedType.object) {
      const ut = this._getOrReturnCtx($e);
      return addIssueToContext(ut, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ut.parsedType
      }), INVALID;
    }
    const { status: Fe, ctx: Ke } = this._processInputParams($e), { shape: Ve, keys: Je } = this._getCached(), Qe = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip"))
      for (const ut in Ke.data)
        Je.includes(ut) || Qe.push(ut);
    const at = [];
    for (const ut of Je) {
      const lt = Ve[ut], dt = Ke.data[ut];
      at.push({
        key: { status: "valid", value: ut },
        value: lt._parse(new ParseInputLazyPath(Ke, dt, Ke.path, ut)),
        alwaysSet: ut in Ke.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const ut = this._def.unknownKeys;
      if (ut === "passthrough")
        for (const lt of Qe)
          at.push({
            key: { status: "valid", value: lt },
            value: { status: "valid", value: Ke.data[lt] }
          });
      else if (ut === "strict")
        Qe.length > 0 && (addIssueToContext(Ke, {
          code: ZodIssueCode.unrecognized_keys,
          keys: Qe
        }), Fe.dirty());
      else if (ut !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const ut = this._def.catchall;
      for (const lt of Qe) {
        const dt = Ke.data[lt];
        at.push({
          key: { status: "valid", value: lt },
          value: ut._parse(
            new ParseInputLazyPath(Ke, dt, Ke.path, lt)
          ),
          alwaysSet: lt in Ke.data
        });
      }
    }
    return Ke.common.async ? Promise.resolve().then(async () => {
      const ut = [];
      for (const lt of at) {
        const dt = await lt.key;
        ut.push({
          key: dt,
          value: await lt.value,
          alwaysSet: lt.alwaysSet
        });
      }
      return ut;
    }).then((ut) => ParseStatus.mergeObjectSync(Fe, ut)) : ParseStatus.mergeObjectSync(Fe, at);
  }
  get shape() {
    return this._def.shape();
  }
  strict($e) {
    return errorUtil.errToObj, new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...$e !== void 0 ? {
        errorMap: (Ze, Fe) => {
          var Ke, Ve, Je, Qe;
          const at = (Je = (Ve = (Ke = this._def).errorMap) === null || Ve === void 0 ? void 0 : Ve.call(Ke, Ze, Fe).message) !== null && Je !== void 0 ? Je : Fe.defaultError;
          return Ze.code === "unrecognized_keys" ? {
            message: (Qe = errorUtil.errToObj($e).message) !== null && Qe !== void 0 ? Qe : at
          } : {
            message: at
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend($e) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...$e
      })
    });
  }
  merge($e) {
    return new ZodObject({
      unknownKeys: $e._def.unknownKeys,
      catchall: $e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...$e._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
  }
  setKey($e, Ze) {
    return this.augment({ [$e]: Ze });
  }
  catchall($e) {
    return new ZodObject({
      ...this._def,
      catchall: $e
    });
  }
  pick($e) {
    const Ze = {};
    return util.objectKeys($e).forEach((Fe) => {
      $e[Fe] && this.shape[Fe] && (Ze[Fe] = this.shape[Fe]);
    }), new ZodObject({
      ...this._def,
      shape: () => Ze
    });
  }
  omit($e) {
    const Ze = {};
    return util.objectKeys(this.shape).forEach((Fe) => {
      $e[Fe] || (Ze[Fe] = this.shape[Fe]);
    }), new ZodObject({
      ...this._def,
      shape: () => Ze
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial($e) {
    const Ze = {};
    return util.objectKeys(this.shape).forEach((Fe) => {
      const Ke = this.shape[Fe];
      $e && !$e[Fe] ? Ze[Fe] = Ke : Ze[Fe] = Ke.optional();
    }), new ZodObject({
      ...this._def,
      shape: () => Ze
    });
  }
  required($e) {
    const Ze = {};
    return util.objectKeys(this.shape).forEach((Fe) => {
      if ($e && !$e[Fe])
        Ze[Fe] = this.shape[Fe];
      else {
        let Ve = this.shape[Fe];
        for (; Ve instanceof ZodOptional; )
          Ve = Ve._def.innerType;
        Ze[Fe] = Ve;
      }
    }), new ZodObject({
      ...this._def,
      shape: () => Ze
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = ($e, Ze) => new ZodObject({
  shape: () => $e,
  unknownKeys: "strip",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(Ze)
});
ZodObject.strictCreate = ($e, Ze) => new ZodObject({
  shape: () => $e,
  unknownKeys: "strict",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(Ze)
});
ZodObject.lazycreate = ($e, Ze) => new ZodObject({
  shape: $e,
  unknownKeys: "strip",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(Ze)
});
var ZodUnion = class extends ZodType {
  _parse($e) {
    const { ctx: Ze } = this._processInputParams($e), Fe = this._def.options;
    function Ke(Ve) {
      for (const Qe of Ve)
        if (Qe.result.status === "valid")
          return Qe.result;
      for (const Qe of Ve)
        if (Qe.result.status === "dirty")
          return Ze.common.issues.push(...Qe.ctx.common.issues), Qe.result;
      const Je = Ve.map((Qe) => new ZodError(Qe.ctx.common.issues));
      return addIssueToContext(Ze, {
        code: ZodIssueCode.invalid_union,
        unionErrors: Je
      }), INVALID;
    }
    if (Ze.common.async)
      return Promise.all(Fe.map(async (Ve) => {
        const Je = {
          ...Ze,
          common: {
            ...Ze.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await Ve._parseAsync({
            data: Ze.data,
            path: Ze.path,
            parent: Je
          }),
          ctx: Je
        };
      })).then(Ke);
    {
      let Ve;
      const Je = [];
      for (const at of Fe) {
        const ut = {
          ...Ze,
          common: {
            ...Ze.common,
            issues: []
          },
          parent: null
        }, lt = at._parseSync({
          data: Ze.data,
          path: Ze.path,
          parent: ut
        });
        if (lt.status === "valid")
          return lt;
        lt.status === "dirty" && !Ve && (Ve = { result: lt, ctx: ut }), ut.common.issues.length && Je.push(ut.common.issues);
      }
      if (Ve)
        return Ze.common.issues.push(...Ve.ctx.common.issues), Ve.result;
      const Qe = Je.map((at) => new ZodError(at));
      return addIssueToContext(Ze, {
        code: ZodIssueCode.invalid_union,
        unionErrors: Qe
      }), INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = ($e, Ze) => new ZodUnion({
  options: $e,
  typeName: ZodFirstPartyTypeKind.ZodUnion,
  ...processCreateParams(Ze)
});
var getDiscriminator = ($e) => $e instanceof ZodLazy ? getDiscriminator($e.schema) : $e instanceof ZodEffects ? getDiscriminator($e.innerType()) : $e instanceof ZodLiteral ? [$e.value] : $e instanceof ZodEnum ? $e.options : $e instanceof ZodNativeEnum ? Object.keys($e.enum) : $e instanceof ZodDefault ? getDiscriminator($e._def.innerType) : $e instanceof ZodUndefined ? [void 0] : $e instanceof ZodNull ? [null] : null, ZodDiscriminatedUnion = class extends ZodType {
  _parse($e) {
    const { ctx: Ze } = this._processInputParams($e);
    if (Ze.parsedType !== ZodParsedType.object)
      return addIssueToContext(Ze, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: Ze.parsedType
      }), INVALID;
    const Fe = this.discriminator, Ke = Ze.data[Fe], Ve = this.optionsMap.get(Ke);
    return Ve ? Ze.common.async ? Ve._parseAsync({
      data: Ze.data,
      path: Ze.path,
      parent: Ze
    }) : Ve._parseSync({
      data: Ze.data,
      path: Ze.path,
      parent: Ze
    }) : (addIssueToContext(Ze, {
      code: ZodIssueCode.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [Fe]
    }), INVALID);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create($e, Ze, Fe) {
    const Ke = /* @__PURE__ */ new Map();
    for (const Ve of Ze) {
      const Je = getDiscriminator(Ve.shape[$e]);
      if (!Je)
        throw new Error(`A discriminator value for key \`${$e}\` could not be extracted from all schema options`);
      for (const Qe of Je) {
        if (Ke.has(Qe))
          throw new Error(`Discriminator property ${String($e)} has duplicate value ${String(Qe)}`);
        Ke.set(Qe, Ve);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator: $e,
      options: Ze,
      optionsMap: Ke,
      ...processCreateParams(Fe)
    });
  }
};
function mergeValues($e, Ze) {
  const Fe = getParsedType($e), Ke = getParsedType(Ze);
  if ($e === Ze)
    return { valid: !0, data: $e };
  if (Fe === ZodParsedType.object && Ke === ZodParsedType.object) {
    const Ve = util.objectKeys(Ze), Je = util.objectKeys($e).filter((at) => Ve.indexOf(at) !== -1), Qe = { ...$e, ...Ze };
    for (const at of Je) {
      const ut = mergeValues($e[at], Ze[at]);
      if (!ut.valid)
        return { valid: !1 };
      Qe[at] = ut.data;
    }
    return { valid: !0, data: Qe };
  } else if (Fe === ZodParsedType.array && Ke === ZodParsedType.array) {
    if ($e.length !== Ze.length)
      return { valid: !1 };
    const Ve = [];
    for (let Je = 0; Je < $e.length; Je++) {
      const Qe = $e[Je], at = Ze[Je], ut = mergeValues(Qe, at);
      if (!ut.valid)
        return { valid: !1 };
      Ve.push(ut.data);
    }
    return { valid: !0, data: Ve };
  } else
    return Fe === ZodParsedType.date && Ke === ZodParsedType.date && +$e == +Ze ? { valid: !0, data: $e } : { valid: !1 };
}
var ZodIntersection = class extends ZodType {
  _parse($e) {
    const { status: Ze, ctx: Fe } = this._processInputParams($e), Ke = (Ve, Je) => {
      if (isAborted(Ve) || isAborted(Je))
        return INVALID;
      const Qe = mergeValues(Ve.value, Je.value);
      return Qe.valid ? ((isDirty(Ve) || isDirty(Je)) && Ze.dirty(), { status: Ze.value, value: Qe.data }) : (addIssueToContext(Fe, {
        code: ZodIssueCode.invalid_intersection_types
      }), INVALID);
    };
    return Fe.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: Fe.data,
        path: Fe.path,
        parent: Fe
      }),
      this._def.right._parseAsync({
        data: Fe.data,
        path: Fe.path,
        parent: Fe
      })
    ]).then(([Ve, Je]) => Ke(Ve, Je)) : Ke(this._def.left._parseSync({
      data: Fe.data,
      path: Fe.path,
      parent: Fe
    }), this._def.right._parseSync({
      data: Fe.data,
      path: Fe.path,
      parent: Fe
    }));
  }
};
ZodIntersection.create = ($e, Ze, Fe) => new ZodIntersection({
  left: $e,
  right: Ze,
  typeName: ZodFirstPartyTypeKind.ZodIntersection,
  ...processCreateParams(Fe)
});
var ZodTuple = class extends ZodType {
  _parse($e) {
    const { status: Ze, ctx: Fe } = this._processInputParams($e);
    if (Fe.parsedType !== ZodParsedType.array)
      return addIssueToContext(Fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: Fe.parsedType
      }), INVALID;
    if (Fe.data.length < this._def.items.length)
      return addIssueToContext(Fe, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), INVALID;
    !this._def.rest && Fe.data.length > this._def.items.length && (addIssueToContext(Fe, {
      code: ZodIssueCode.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), Ze.dirty());
    const Ve = [...Fe.data].map((Je, Qe) => {
      const at = this._def.items[Qe] || this._def.rest;
      return at ? at._parse(new ParseInputLazyPath(Fe, Je, Fe.path, Qe)) : null;
    }).filter((Je) => !!Je);
    return Fe.common.async ? Promise.all(Ve).then((Je) => ParseStatus.mergeArray(Ze, Je)) : ParseStatus.mergeArray(Ze, Ve);
  }
  get items() {
    return this._def.items;
  }
  rest($e) {
    return new ZodTuple({
      ...this._def,
      rest: $e
    });
  }
};
ZodTuple.create = ($e, Ze) => {
  if (!Array.isArray($e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ZodTuple({
    items: $e,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(Ze)
  });
};
var ZodRecord = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse($e) {
    const { status: Ze, ctx: Fe } = this._processInputParams($e);
    if (Fe.parsedType !== ZodParsedType.object)
      return addIssueToContext(Fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: Fe.parsedType
      }), INVALID;
    const Ke = [], Ve = this._def.keyType, Je = this._def.valueType;
    for (const Qe in Fe.data)
      Ke.push({
        key: Ve._parse(new ParseInputLazyPath(Fe, Qe, Fe.path, Qe)),
        value: Je._parse(new ParseInputLazyPath(Fe, Fe.data[Qe], Fe.path, Qe))
      });
    return Fe.common.async ? ParseStatus.mergeObjectAsync(Ze, Ke) : ParseStatus.mergeObjectSync(Ze, Ke);
  }
  get element() {
    return this._def.valueType;
  }
  static create($e, Ze, Fe) {
    return Ze instanceof ZodType ? new ZodRecord({
      keyType: $e,
      valueType: Ze,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(Fe)
    }) : new ZodRecord({
      keyType: ZodString.create(),
      valueType: $e,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(Ze)
    });
  }
}, ZodMap = class extends ZodType {
  _parse($e) {
    const { status: Ze, ctx: Fe } = this._processInputParams($e);
    if (Fe.parsedType !== ZodParsedType.map)
      return addIssueToContext(Fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: Fe.parsedType
      }), INVALID;
    const Ke = this._def.keyType, Ve = this._def.valueType, Je = [...Fe.data.entries()].map(([Qe, at], ut) => ({
      key: Ke._parse(new ParseInputLazyPath(Fe, Qe, Fe.path, [ut, "key"])),
      value: Ve._parse(new ParseInputLazyPath(Fe, at, Fe.path, [ut, "value"]))
    }));
    if (Fe.common.async) {
      const Qe = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const at of Je) {
          const ut = await at.key, lt = await at.value;
          if (ut.status === "aborted" || lt.status === "aborted")
            return INVALID;
          (ut.status === "dirty" || lt.status === "dirty") && Ze.dirty(), Qe.set(ut.value, lt.value);
        }
        return { status: Ze.value, value: Qe };
      });
    } else {
      const Qe = /* @__PURE__ */ new Map();
      for (const at of Je) {
        const ut = at.key, lt = at.value;
        if (ut.status === "aborted" || lt.status === "aborted")
          return INVALID;
        (ut.status === "dirty" || lt.status === "dirty") && Ze.dirty(), Qe.set(ut.value, lt.value);
      }
      return { status: Ze.value, value: Qe };
    }
  }
};
ZodMap.create = ($e, Ze, Fe) => new ZodMap({
  valueType: Ze,
  keyType: $e,
  typeName: ZodFirstPartyTypeKind.ZodMap,
  ...processCreateParams(Fe)
});
var ZodSet = class extends ZodType {
  _parse($e) {
    const { status: Ze, ctx: Fe } = this._processInputParams($e);
    if (Fe.parsedType !== ZodParsedType.set)
      return addIssueToContext(Fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: Fe.parsedType
      }), INVALID;
    const Ke = this._def;
    Ke.minSize !== null && Fe.data.size < Ke.minSize.value && (addIssueToContext(Fe, {
      code: ZodIssueCode.too_small,
      minimum: Ke.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: Ke.minSize.message
    }), Ze.dirty()), Ke.maxSize !== null && Fe.data.size > Ke.maxSize.value && (addIssueToContext(Fe, {
      code: ZodIssueCode.too_big,
      maximum: Ke.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: Ke.maxSize.message
    }), Ze.dirty());
    const Ve = this._def.valueType;
    function Je(at) {
      const ut = /* @__PURE__ */ new Set();
      for (const lt of at) {
        if (lt.status === "aborted")
          return INVALID;
        lt.status === "dirty" && Ze.dirty(), ut.add(lt.value);
      }
      return { status: Ze.value, value: ut };
    }
    const Qe = [...Fe.data.values()].map((at, ut) => Ve._parse(new ParseInputLazyPath(Fe, at, Fe.path, ut)));
    return Fe.common.async ? Promise.all(Qe).then((at) => Je(at)) : Je(Qe);
  }
  min($e, Ze) {
    return new ZodSet({
      ...this._def,
      minSize: { value: $e, message: errorUtil.toString(Ze) }
    });
  }
  max($e, Ze) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: $e, message: errorUtil.toString(Ze) }
    });
  }
  size($e, Ze) {
    return this.min($e, Ze).max($e, Ze);
  }
  nonempty($e) {
    return this.min(1, $e);
  }
};
ZodSet.create = ($e, Ze) => new ZodSet({
  valueType: $e,
  minSize: null,
  maxSize: null,
  typeName: ZodFirstPartyTypeKind.ZodSet,
  ...processCreateParams(Ze)
});
var ZodFunction = class extends ZodType {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse($e) {
    const { ctx: Ze } = this._processInputParams($e);
    if (Ze.parsedType !== ZodParsedType.function)
      return addIssueToContext(Ze, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: Ze.parsedType
      }), INVALID;
    function Fe(Qe, at) {
      return makeIssue({
        data: Qe,
        path: Ze.path,
        errorMaps: [
          Ze.common.contextualErrorMap,
          Ze.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((ut) => !!ut),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: at
        }
      });
    }
    function Ke(Qe, at) {
      return makeIssue({
        data: Qe,
        path: Ze.path,
        errorMaps: [
          Ze.common.contextualErrorMap,
          Ze.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((ut) => !!ut),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: at
        }
      });
    }
    const Ve = { errorMap: Ze.common.contextualErrorMap }, Je = Ze.data;
    return this._def.returns instanceof ZodPromise ? OK(async (...Qe) => {
      const at = new ZodError([]), ut = await this._def.args.parseAsync(Qe, Ve).catch((bt) => {
        throw at.addIssue(Fe(Qe, bt)), at;
      }), lt = await Je(...ut);
      return await this._def.returns._def.type.parseAsync(lt, Ve).catch((bt) => {
        throw at.addIssue(Ke(lt, bt)), at;
      });
    }) : OK((...Qe) => {
      const at = this._def.args.safeParse(Qe, Ve);
      if (!at.success)
        throw new ZodError([Fe(Qe, at.error)]);
      const ut = Je(...at.data), lt = this._def.returns.safeParse(ut, Ve);
      if (!lt.success)
        throw new ZodError([Ke(ut, lt.error)]);
      return lt.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...$e) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create($e).rest(ZodUnknown.create())
    });
  }
  returns($e) {
    return new ZodFunction({
      ...this._def,
      returns: $e
    });
  }
  implement($e) {
    return this.parse($e);
  }
  strictImplement($e) {
    return this.parse($e);
  }
  static create($e, Ze, Fe) {
    return new ZodFunction({
      args: $e || ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: Ze || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(Fe)
    });
  }
}, ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse($e) {
    const { ctx: Ze } = this._processInputParams($e);
    return this._def.getter()._parse({ data: Ze.data, path: Ze.path, parent: Ze });
  }
};
ZodLazy.create = ($e, Ze) => new ZodLazy({
  getter: $e,
  typeName: ZodFirstPartyTypeKind.ZodLazy,
  ...processCreateParams(Ze)
});
var ZodLiteral = class extends ZodType {
  _parse($e) {
    if ($e.data !== this._def.value) {
      const Ze = this._getOrReturnCtx($e);
      return addIssueToContext(Ze, {
        received: Ze.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      }), INVALID;
    }
    return { status: "valid", value: $e.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = ($e, Ze) => new ZodLiteral({
  value: $e,
  typeName: ZodFirstPartyTypeKind.ZodLiteral,
  ...processCreateParams(Ze)
});
function createZodEnum($e, Ze) {
  return new ZodEnum({
    values: $e,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(Ze)
  });
}
var ZodEnum = class extends ZodType {
  _parse($e) {
    if (typeof $e.data != "string") {
      const Ze = this._getOrReturnCtx($e), Fe = this._def.values;
      return addIssueToContext(Ze, {
        expected: util.joinValues(Fe),
        received: Ze.parsedType,
        code: ZodIssueCode.invalid_type
      }), INVALID;
    }
    if (this._def.values.indexOf($e.data) === -1) {
      const Ze = this._getOrReturnCtx($e), Fe = this._def.values;
      return addIssueToContext(Ze, {
        received: Ze.data,
        code: ZodIssueCode.invalid_enum_value,
        options: Fe
      }), INVALID;
    }
    return OK($e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const $e = {};
    for (const Ze of this._def.values)
      $e[Ze] = Ze;
    return $e;
  }
  get Values() {
    const $e = {};
    for (const Ze of this._def.values)
      $e[Ze] = Ze;
    return $e;
  }
  get Enum() {
    const $e = {};
    for (const Ze of this._def.values)
      $e[Ze] = Ze;
    return $e;
  }
  extract($e) {
    return ZodEnum.create($e);
  }
  exclude($e) {
    return ZodEnum.create(this.options.filter((Ze) => !$e.includes(Ze)));
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse($e) {
    const Ze = util.getValidEnumValues(this._def.values), Fe = this._getOrReturnCtx($e);
    if (Fe.parsedType !== ZodParsedType.string && Fe.parsedType !== ZodParsedType.number) {
      const Ke = util.objectValues(Ze);
      return addIssueToContext(Fe, {
        expected: util.joinValues(Ke),
        received: Fe.parsedType,
        code: ZodIssueCode.invalid_type
      }), INVALID;
    }
    if (Ze.indexOf($e.data) === -1) {
      const Ke = util.objectValues(Ze);
      return addIssueToContext(Fe, {
        received: Fe.data,
        code: ZodIssueCode.invalid_enum_value,
        options: Ke
      }), INVALID;
    }
    return OK($e.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = ($e, Ze) => new ZodNativeEnum({
  values: $e,
  typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
  ...processCreateParams(Ze)
});
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse($e) {
    const { ctx: Ze } = this._processInputParams($e);
    if (Ze.parsedType !== ZodParsedType.promise && Ze.common.async === !1)
      return addIssueToContext(Ze, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: Ze.parsedType
      }), INVALID;
    const Fe = Ze.parsedType === ZodParsedType.promise ? Ze.data : Promise.resolve(Ze.data);
    return OK(Fe.then((Ke) => this._def.type.parseAsync(Ke, {
      path: Ze.path,
      errorMap: Ze.common.contextualErrorMap
    })));
  }
};
ZodPromise.create = ($e, Ze) => new ZodPromise({
  type: $e,
  typeName: ZodFirstPartyTypeKind.ZodPromise,
  ...processCreateParams(Ze)
});
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse($e) {
    const { status: Ze, ctx: Fe } = this._processInputParams($e), Ke = this._def.effect || null;
    if (Ke.type === "preprocess") {
      const Je = Ke.transform(Fe.data);
      return Fe.common.async ? Promise.resolve(Je).then((Qe) => this._def.schema._parseAsync({
        data: Qe,
        path: Fe.path,
        parent: Fe
      })) : this._def.schema._parseSync({
        data: Je,
        path: Fe.path,
        parent: Fe
      });
    }
    const Ve = {
      addIssue: (Je) => {
        addIssueToContext(Fe, Je), Je.fatal ? Ze.abort() : Ze.dirty();
      },
      get path() {
        return Fe.path;
      }
    };
    if (Ve.addIssue = Ve.addIssue.bind(Ve), Ke.type === "refinement") {
      const Je = (Qe) => {
        const at = Ke.refinement(Qe, Ve);
        if (Fe.common.async)
          return Promise.resolve(at);
        if (at instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return Qe;
      };
      if (Fe.common.async === !1) {
        const Qe = this._def.schema._parseSync({
          data: Fe.data,
          path: Fe.path,
          parent: Fe
        });
        return Qe.status === "aborted" ? INVALID : (Qe.status === "dirty" && Ze.dirty(), Je(Qe.value), { status: Ze.value, value: Qe.value });
      } else
        return this._def.schema._parseAsync({ data: Fe.data, path: Fe.path, parent: Fe }).then((Qe) => Qe.status === "aborted" ? INVALID : (Qe.status === "dirty" && Ze.dirty(), Je(Qe.value).then(() => ({ status: Ze.value, value: Qe.value }))));
    }
    if (Ke.type === "transform")
      if (Fe.common.async === !1) {
        const Je = this._def.schema._parseSync({
          data: Fe.data,
          path: Fe.path,
          parent: Fe
        });
        if (!isValid(Je))
          return Je;
        const Qe = Ke.transform(Je.value, Ve);
        if (Qe instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: Ze.value, value: Qe };
      } else
        return this._def.schema._parseAsync({ data: Fe.data, path: Fe.path, parent: Fe }).then((Je) => isValid(Je) ? Promise.resolve(Ke.transform(Je.value, Ve)).then((Qe) => ({ status: Ze.value, value: Qe })) : Je);
    util.assertNever(Ke);
  }
};
ZodEffects.create = ($e, Ze, Fe) => new ZodEffects({
  schema: $e,
  typeName: ZodFirstPartyTypeKind.ZodEffects,
  effect: Ze,
  ...processCreateParams(Fe)
});
ZodEffects.createWithPreprocess = ($e, Ze, Fe) => new ZodEffects({
  schema: Ze,
  effect: { type: "preprocess", transform: $e },
  typeName: ZodFirstPartyTypeKind.ZodEffects,
  ...processCreateParams(Fe)
});
var ZodOptional = class extends ZodType {
  _parse($e) {
    return this._getType($e) === ZodParsedType.undefined ? OK(void 0) : this._def.innerType._parse($e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = ($e, Ze) => new ZodOptional({
  innerType: $e,
  typeName: ZodFirstPartyTypeKind.ZodOptional,
  ...processCreateParams(Ze)
});
var ZodNullable = class extends ZodType {
  _parse($e) {
    return this._getType($e) === ZodParsedType.null ? OK(null) : this._def.innerType._parse($e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = ($e, Ze) => new ZodNullable({
  innerType: $e,
  typeName: ZodFirstPartyTypeKind.ZodNullable,
  ...processCreateParams(Ze)
});
var ZodDefault = class extends ZodType {
  _parse($e) {
    const { ctx: Ze } = this._processInputParams($e);
    let Fe = Ze.data;
    return Ze.parsedType === ZodParsedType.undefined && (Fe = this._def.defaultValue()), this._def.innerType._parse({
      data: Fe,
      path: Ze.path,
      parent: Ze
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = ($e, Ze) => new ZodDefault({
  innerType: $e,
  typeName: ZodFirstPartyTypeKind.ZodDefault,
  defaultValue: typeof Ze.default == "function" ? Ze.default : () => Ze.default,
  ...processCreateParams(Ze)
});
var ZodCatch = class extends ZodType {
  _parse($e) {
    const { ctx: Ze } = this._processInputParams($e), Fe = {
      ...Ze,
      common: {
        ...Ze.common,
        issues: []
      }
    }, Ke = this._def.innerType._parse({
      data: Fe.data,
      path: Fe.path,
      parent: {
        ...Fe
      }
    });
    return isAsync(Ke) ? Ke.then((Ve) => ({
      status: "valid",
      value: Ve.status === "valid" ? Ve.value : this._def.catchValue({
        get error() {
          return new ZodError(Fe.common.issues);
        },
        input: Fe.data
      })
    })) : {
      status: "valid",
      value: Ke.status === "valid" ? Ke.value : this._def.catchValue({
        get error() {
          return new ZodError(Fe.common.issues);
        },
        input: Fe.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = ($e, Ze) => new ZodCatch({
  innerType: $e,
  typeName: ZodFirstPartyTypeKind.ZodCatch,
  catchValue: typeof Ze.catch == "function" ? Ze.catch : () => Ze.catch,
  ...processCreateParams(Ze)
});
var ZodNaN = class extends ZodType {
  _parse($e) {
    if (this._getType($e) !== ZodParsedType.nan) {
      const Fe = this._getOrReturnCtx($e);
      return addIssueToContext(Fe, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: Fe.parsedType
      }), INVALID;
    }
    return { status: "valid", value: $e.data };
  }
};
ZodNaN.create = ($e) => new ZodNaN({
  typeName: ZodFirstPartyTypeKind.ZodNaN,
  ...processCreateParams($e)
});
var BRAND = Symbol("zod_brand"), ZodBranded = class extends ZodType {
  _parse($e) {
    const { ctx: Ze } = this._processInputParams($e), Fe = Ze.data;
    return this._def.type._parse({
      data: Fe,
      path: Ze.path,
      parent: Ze
    });
  }
  unwrap() {
    return this._def.type;
  }
}, ZodPipeline = class extends ZodType {
  _parse($e) {
    const { status: Ze, ctx: Fe } = this._processInputParams($e);
    if (Fe.common.async)
      return (async () => {
        const Ve = await this._def.in._parseAsync({
          data: Fe.data,
          path: Fe.path,
          parent: Fe
        });
        return Ve.status === "aborted" ? INVALID : Ve.status === "dirty" ? (Ze.dirty(), DIRTY(Ve.value)) : this._def.out._parseAsync({
          data: Ve.value,
          path: Fe.path,
          parent: Fe
        });
      })();
    {
      const Ke = this._def.in._parseSync({
        data: Fe.data,
        path: Fe.path,
        parent: Fe
      });
      return Ke.status === "aborted" ? INVALID : Ke.status === "dirty" ? (Ze.dirty(), {
        status: "dirty",
        value: Ke.value
      }) : this._def.out._parseSync({
        data: Ke.value,
        path: Fe.path,
        parent: Fe
      });
    }
  }
  static create($e, Ze) {
    return new ZodPipeline({
      in: $e,
      out: Ze,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}, custom = ($e, Ze = {}, Fe) => $e ? ZodAny.create().superRefine((Ke, Ve) => {
  var Je, Qe;
  if (!$e(Ke)) {
    const at = typeof Ze == "function" ? Ze(Ke) : typeof Ze == "string" ? { message: Ze } : Ze, ut = (Qe = (Je = at.fatal) !== null && Je !== void 0 ? Je : Fe) !== null && Qe !== void 0 ? Qe : !0, lt = typeof at == "string" ? { message: at } : at;
    Ve.addIssue({ code: "custom", ...lt, fatal: ut });
  }
}) : ZodAny.create(), late = {
  object: ZodObject.lazycreate
}, ZodFirstPartyTypeKind;
(function($e) {
  $e.ZodString = "ZodString", $e.ZodNumber = "ZodNumber", $e.ZodNaN = "ZodNaN", $e.ZodBigInt = "ZodBigInt", $e.ZodBoolean = "ZodBoolean", $e.ZodDate = "ZodDate", $e.ZodSymbol = "ZodSymbol", $e.ZodUndefined = "ZodUndefined", $e.ZodNull = "ZodNull", $e.ZodAny = "ZodAny", $e.ZodUnknown = "ZodUnknown", $e.ZodNever = "ZodNever", $e.ZodVoid = "ZodVoid", $e.ZodArray = "ZodArray", $e.ZodObject = "ZodObject", $e.ZodUnion = "ZodUnion", $e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", $e.ZodIntersection = "ZodIntersection", $e.ZodTuple = "ZodTuple", $e.ZodRecord = "ZodRecord", $e.ZodMap = "ZodMap", $e.ZodSet = "ZodSet", $e.ZodFunction = "ZodFunction", $e.ZodLazy = "ZodLazy", $e.ZodLiteral = "ZodLiteral", $e.ZodEnum = "ZodEnum", $e.ZodEffects = "ZodEffects", $e.ZodNativeEnum = "ZodNativeEnum", $e.ZodOptional = "ZodOptional", $e.ZodNullable = "ZodNullable", $e.ZodDefault = "ZodDefault", $e.ZodCatch = "ZodCatch", $e.ZodPromise = "ZodPromise", $e.ZodBranded = "ZodBranded", $e.ZodPipeline = "ZodPipeline";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = ($e, Ze = {
  message: `Input not instance of ${$e.name}`
}) => custom((Fe) => Fe instanceof $e, Ze), stringType = ZodString.create, numberType = ZodNumber.create, nanType = ZodNaN.create, bigIntType = ZodBigInt.create, booleanType = ZodBoolean.create, dateType = ZodDate.create, symbolType = ZodSymbol.create, undefinedType = ZodUndefined.create, nullType = ZodNull.create, anyType = ZodAny.create, unknownType = ZodUnknown.create, neverType = ZodNever.create, voidType = ZodVoid.create, arrayType = ZodArray.create, objectType = ZodObject.create, strictObjectType = ZodObject.strictCreate, unionType = ZodUnion.create, discriminatedUnionType = ZodDiscriminatedUnion.create, intersectionType = ZodIntersection.create, tupleType = ZodTuple.create, recordType = ZodRecord.create, mapType = ZodMap.create, setType = ZodSet.create, functionType = ZodFunction.create, lazyType = ZodLazy.create, literalType = ZodLiteral.create, enumType = ZodEnum.create, nativeEnumType = ZodNativeEnum.create, promiseType = ZodPromise.create, effectsType = ZodEffects.create, optionalType = ZodOptional.create, nullableType = ZodNullable.create, preprocessType = ZodEffects.createWithPreprocess, pipelineType = ZodPipeline.create, ostring = () => stringType().optional(), onumber = () => numberType().optional(), oboolean = () => booleanType().optional(), coerce = {
  string: ($e) => ZodString.create({ ...$e, coerce: !0 }),
  number: ($e) => ZodNumber.create({ ...$e, coerce: !0 }),
  boolean: ($e) => ZodBoolean.create({
    ...$e,
    coerce: !0
  }),
  bigint: ($e) => ZodBigInt.create({ ...$e, coerce: !0 }),
  date: ($e) => ZodDate.create({ ...$e, coerce: !0 })
}, NEVER = INVALID, z4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
}), messageCreatedSignal_z_default = z4.object({
  type: z4.literal("message_created"),
  data: z4.object({
    id: z4.string(),
    fid: z4.string().optional(),
    createdAt: z4.string().datetime(),
    payload: z4.union([
      z4.object({
        type: z4.literal("button"),
        variant: z4.enum(["action", "link"]),
        reusable: z4.boolean().optional(),
        groupId: z4.string().optional(),
        text: z4.string(),
        buttonValue: z4.string()
      }),
      z4.object({ type: z4.literal("text"), text: z4.string() }),
      z4.object({
        type: z4.literal("image"),
        orientation: z4.enum(["portrait", "landscape", "square", "auto"]).optional(),
        url: z4.string()
      }),
      z4.object({ type: z4.literal("audio"), url: z4.string() }),
      z4.object({ type: z4.literal("video"), url: z4.string() }),
      z4.object({
        type: z4.literal("file"),
        url: z4.string(),
        title: z4.string().optional()
      }),
      z4.object({
        type: z4.literal("location"),
        latitude: z4.number(),
        longitude: z4.number(),
        title: z4.string().optional()
      }),
      z4.object({
        type: z4.literal("custom"),
        payload: z4.object({}).catchall(z4.any())
      })
    ]),
    userId: z4.string(),
    conversationId: z4.string()
  })
});
init_dirname();
init_buffer2();
init_process2();
var zod = {
  messageCreatedSignal: messageCreatedSignal_z_default
}, DEFAULT_ERROR_MESSAGE = "unknown error", _SignalListener = class extends EventEmitter {
  constructor(Ze) {
    super();
    Or(this, "_state", { status: "disconnected" });
    Or(this, "connect", async () => {
      if (this._state.status === "connected")
        return;
      if (this._state.status === "connecting") {
        await this._state.connectionPromise;
        return;
      }
      const Ze = this._connect();
      this._state = { status: "connecting", connectionPromise: Ze }, await Ze;
    });
    Or(this, "disconnect", async () => {
      if (this._state.status === "disconnected")
        return;
      let Ze;
      this._state.status === "connecting" ? Ze = await this._state.connectionPromise : Ze = this._state.source, this._disconnectSync(Ze);
    });
    Or(this, "_connect", async () => {
      const Ze = await listenEventSource(`${this._props.url}/v1/conversations/${this._props.conversationId}/listen`, {
        headers: { "x-chat-key": this._props.chatKey }
      });
      return Ze.on("message", this._handleMessage), Ze.on("error", this._handleError(Ze)), this._state = { status: "connected", source: Ze }, Ze;
    });
    Or(this, "_disconnectSync", (Ze) => {
      Ze.close(), this._state = { status: "disconnected" };
    });
    Or(this, "_handleMessage", (Ze) => {
      const Fe = this._parseSignal(Ze.data);
      this.emit(Fe.type, Fe.data);
    });
    Or(this, "_handleError", (Ze) => (Fe) => {
      this._disconnectSync(Ze);
      const Ke = this._toError(Fe);
      this.emit("error", Ke);
    });
    Or(this, "_parseSignal", (Ze) => {
      for (const Fe of Object.values(zod)) {
        const Ke = this._safeJsonParse(Ze), Ve = Fe.safeParse(Ke);
        if (Ve.success)
          return Ve.data;
      }
      return {
        type: "unknown",
        data: Ze
      };
    });
    Or(this, "_safeJsonParse", (Ze) => {
      try {
        return JSON.parse(Ze);
      } catch {
        return Ze;
      }
    });
    Or(this, "_toError", (Ze) => {
      if (Ze instanceof Error)
        return Ze;
      if (typeof Ze == "string")
        return new Error(Ze);
      if (Ze === null)
        return new Error(DEFAULT_ERROR_MESSAGE);
      if (typeof Ze == "object" && "message" in Ze)
        return this._toError(Ze.message);
      try {
        const Fe = JSON.stringify(Ze);
        return new Error(Fe);
      } catch {
        return new Error(DEFAULT_ERROR_MESSAGE);
      }
    });
    this._props = Ze;
  }
  get status() {
    return this._state.status;
  }
}, SignalListener = _SignalListener;
__publicField(SignalListener, "listen", async ($e) => {
  const Ze = new _SignalListener($e);
  return await Ze.connect(), Ze;
});
var _100mb = 100 * 1024 * 1024, maxBodyLength = _100mb, maxContentLength = _100mb, defaultTimeout = 6e4, _Client = class {
  constructor($e) {
    Or(this, "_auto");
    Or(this, "createConversation", ($e) => this._auto.createConversation($e));
    Or(this, "getConversation", ($e) => this._auto.getConversation($e));
    Or(this, "getOrCreateConversation", ($e) => this._auto.getOrCreateConversation($e));
    Or(this, "updateConversation", ($e) => this._auto.updateConversation($e));
    Or(this, "deleteConversation", ($e) => this._auto.deleteConversation($e));
    Or(this, "listConversations", ($e) => this._auto.listConversations($e));
    Or(this, "listConversationMessages", ($e) => this._auto.listConversationMessages($e));
    Or(this, "addParticipant", ($e) => this._auto.addParticipant($e));
    Or(this, "removeParticipant", ($e) => this._auto.removeParticipant($e));
    Or(this, "getParticipant", ($e) => this._auto.getParticipant($e));
    Or(this, "listParticipants", ($e) => this._auto.listParticipants($e));
    Or(this, "createMessage", ($e) => this._auto.createMessage($e));
    Or(this, "getMessage", ($e) => this._auto.getMessage($e));
    Or(this, "getOrCreateMessage", ($e) => this._auto.getOrCreateMessage($e));
    Or(this, "updateMessage", ($e) => this._auto.updateMessage($e));
    Or(this, "deleteMessage", ($e) => this._auto.deleteMessage($e));
    Or(this, "createUser", ($e) => this._auto.createUser($e));
    Or(this, "getUser", ($e) => this._auto.getUser($e));
    Or(this, "updateUser", ($e) => this._auto.updateUser($e));
    Or(this, "deleteUser", ($e) => this._auto.deleteUser($e));
    Or(this, "listenConversation", async ({ id: $e, xChatKey: Ze }) => await SignalListener.listen({
      url: this.props.apiUrl,
      conversationId: $e,
      chatKey: Ze
    }));
    this.props = $e;
    const { apiUrl: Ze } = $e, Fe = _Client._createAxios($e);
    this._auto = new ApiClient(void 0, Ze, Fe);
  }
}, Client = _Client;
__publicField(Client, "_createAxios", ($e) => {
  const Ze = {
    ...$e.headers
  }, Fe = $e.timeout ?? defaultTimeout, Ke = import_browser_or_node2.isBrowser;
  return axios_default.create({ headers: Ze, withCredentials: Ke, timeout: Fe, maxBodyLength, maxContentLength });
});
/*! Bundled license information:

@jspm/core/nodelibs/browser/buffer.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@jspm/core/nodelibs/browser/chunk-44e51b61.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

event-source-polyfill/src/eventsource.js:
  (** @license
   * eventsource.js
   * Available under MIT License (MIT)
   * https://github.com/Yaffle/EventSource/
   *)

@jspm/core/nodelibs/browser/crypto.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
const ranks = {
  disconnected: 0,
  user_creating: 1,
  user_created: 2,
  conversation_creating: 3,
  conversation_created: 4
}, isEq = ($e, Ze) => $e.status === Ze, isLt = ($e, Ze) => ranks[$e.status] < ranks[Ze], isGte = ($e, Ze) => ranks[$e.status] >= ranks[Ze];
class InvalidStateError extends Error {
  constructor(Ze) {
    super(`Unexpected state: ${Ze.status}`), this.state = Ze;
  }
}
class ChatClient extends EventEmitter$1 {
  constructor(Fe) {
    super();
    Or(this, "_client");
    Or(this, "_webhookId");
    Or(this, "_state", { status: "disconnected" });
    Or(this, "_initialConnect", async () => {
      if (isGte(this._state, "user_created"))
        throw new Error("Client is already connected. Please disconnect first.");
      if (isEq(this._state, "user_creating"))
        return;
      this._state = {
        status: "user_creating"
      }, console.log("createUser");
      const {
        user: { id: Fe },
        key: Ke
      } = await this._client.createUser({});
      return this._state = {
        status: "user_created",
        userId: Fe,
        userKey: Ke
      }, {
        userId: Fe,
        userToken: Ke
      };
    });
    Or(this, "_reConnect", async (Fe) => {
      if (isGte(this._state, "user_created")) {
        if (this._state.userId !== Fe.userId)
          throw new Error("Client is already connected. Please disconnect first.");
        return Fe;
      }
      return isEq(this._state, "user_creating") || (this._state = {
        status: "user_created",
        userId: Fe.userId,
        userKey: Fe.userToken
      }), Fe;
    });
    Or(this, "_mapMessage", (Fe) => ({
      id: Fe.id,
      conversationId: Fe.conversationId,
      authorId: Fe.userId,
      sentOn: new Date(Fe.createdAt),
      payload: messageAdapter(Fe.payload)
    }));
    const Ke = `${Fe.apiUrl}/${Fe.clientId}`;
    this._webhookId = Fe.clientId, this._client = new Client({
      apiUrl: Ke
    });
  }
  get clientId() {
    return this._webhookId;
  }
  get userId() {
    if (!isLt(this._state, "user_created"))
      return this._state.userId;
  }
  get conversationId() {
    if (!isLt(this._state, "conversation_created"))
      return this._state.conversationId;
  }
  async connect(Fe) {
    return Fe ? await this.userExists(Fe) ? this._reConnect(Fe) : this._initialConnect() : this._initialConnect();
  }
  async disconnect() {
    isEq(this._state, "conversation_created") ? this._state.signalEmitter.cleanup() : isEq(this._state, "conversation_creating") && console.warn("zombie conversation..."), this._state = { status: "disconnected" };
  }
  async sendMessage(Fe) {
    if (isLt(this._state, "user_created"))
      throw new InvalidStateError(this._state);
    if (isEq(this._state, "conversation_creating"))
      throw new InvalidStateError(this._state);
    let Ke;
    isEq(this._state, "conversation_created") ? Ke = this._state : (this._state = { status: "conversation_creating", userId: this._state.userId, userKey: this._state.userKey }, Ke = await this._createNewConversation(this._state)), console.log("createMessage"), await this._client.createMessage({
      xChatKey: Ke.userKey,
      conversationId: Ke.conversationId,
      payload: {
        type: "text",
        text: Fe
      }
    }), this.emit("messageSent", Fe);
  }
  async switchConversation(Fe) {
    if (isLt(this._state, "user_created"))
      throw new InvalidStateError(this._state);
    isEq(this._state, "conversation_created") && this._state.conversationId === Fe || isEq(this._state, "conversation_creating") || (this._state = {
      status: "conversation_creating",
      userId: this._state.userId,
      userKey: this._state.userKey
    }, await this._connectConversation(this._state, Fe));
  }
  async conversationExists(Fe) {
    if (isLt(this._state, "user_created"))
      return !1;
    try {
      return await this._client.getConversation({
        xChatKey: this._state.userKey,
        id: Fe
      }), !0;
    } catch (Ke) {
      if (isApiError(Ke) && Ke.code === 404)
        return !1;
      throw Ke;
    }
  }
  async userExists({ userToken: Fe }) {
    try {
      return await this._client.getUser({
        xChatKey: Fe
      }), !0;
    } catch (Ke) {
      const Ve = (Je) => Je.code === 404 || Je.code === 401;
      if (isApiError(Ke) && Ve(Ke))
        return !1;
      throw Ke;
    }
  }
  async newConversation() {
    if (isLt(this._state, "user_created"))
      throw new InvalidStateError(this._state);
    isEq(this._state, "conversation_creating") || (this._state = { status: "conversation_creating", userId: this._state.userId, userKey: this._state.userKey }, await this._createNewConversation(this._state));
  }
  async _createNewConversation(Fe) {
    console.log("createConversation");
    const {
      conversation: { id: Ke }
    } = await this._client.createConversation({ xChatKey: Fe.userKey });
    return await this._client.addParticipant({ id: Ke, xChatKey: Fe.userKey, userId: Fe.userId }), this._connectConversation(Fe, Ke);
  }
  async listMessages() {
    if (!isEq(this._state, "conversation_created"))
      return [];
    const { conversationId: Fe, userKey: Ke } = this._state, Ve = [];
    let Je;
    do {
      const Qe = await this._client.listConversationMessages({ id: Fe, xChatKey: Ke, nextToken: Je });
      Ve.push(...Qe.messages), Je = Qe.meta.nextToken;
    } while (Je);
    return Ve.map(this._mapMessage);
  }
  async _connectConversation(Fe, Ke) {
    const Ve = await this._client.listenConversation({ id: Ke, xChatKey: Fe.userKey });
    return Ve.on("unknown", (Je) => console.log("unknown event", Je)), Ve.on("message_created", (Je) => {
      Je.userId !== Fe.userId && this.emit(
        "message",
        this._mapMessage({
          type: Je.payload.type,
          ...Je
        })
      );
    }), Ve.on("error", () => {
      this._state = { status: "user_created", userId: Fe.userId, userKey: Fe.userKey }, this.emit("error", new Error("Connection to conversation lost"));
    }), this.emit("conversation", Ke), this._state = {
      status: "conversation_created",
      userId: Fe.userId,
      userKey: Fe.userKey,
      conversationId: Ke,
      signalEmitter: Ve
    }, this._state;
  }
}
const useClient = ({ clientId: $e, apiUrl: Ze, mode: Fe = "messaging" }) => {
  const [Ke, Ve] = useState();
  return useEffect(() => {
    const Je = Fe === "messaging" ? new MessagingClient({
      url: Ze,
      clientId: $e
    }) : new ChatClient({
      apiUrl: Ze,
      clientId: $e
    });
    Ve(Je);
  }, [$e, Ze, Fe]), Ke;
}, Composer = memo(
  forwardRef(($e, Ze) => {
    const {
      state: Fe,
      theme: { composer: Ke },
      client: Ve
    } = useWebchatContext(), [Je, Qe] = useState(""), [at, ut] = useState(-1);
    if (Fe.isReadOnly || !Ve)
      return null;
    const lt = () => {
      Je && (Ve.sendMessage(Je), Qe(""), ut(-1));
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ComposerContext.Provider, { value: { value: Je, setValue: Qe, historyIndex: at, setHistoryIndex: ut, sendMessage: lt }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-disabled": Fe.disableComposer, ...$e, ...Ke == null ? void 0 : Ke.container, ref: Ze }) });
  })
), ComposerInput = memo(({ ...$e }) => {
  const {
    state: Ze,
    theme: { composer: Fe }
  } = useWebchatContext(), { value: Ke, setValue: Ve, historyIndex: Je, setHistoryIndex: Qe, sendMessage: at } = useComposerContext(), ut = useRef(null), lt = useWebchatStore((bt) => bt.user), dt = useWebchatStore((bt) => bt.messageHistory);
  return useEffect(() => {
    ut.current && (ut.current.selectionStart = ut.current.value.length, ut.current.selectionEnd = ut.current.value.length);
  }, [Ke]), /* @__PURE__ */ jsxRuntimeExports.jsx(
    "textarea",
    {
      ...Fe == null ? void 0 : Fe.input,
      disabled: Ze.disableComposer,
      ref: ut,
      value: Ke,
      "data-has-value": !!Ke,
      onChange: (bt) => Ve(bt.target.value),
      onKeyDown: (bt) => {
        if (!Ze.disableComposer) {
          if (bt.key === "Enter" && (bt.preventDefault(), at()), bt.key === "ArrowUp") {
            bt.preventDefault();
            const $t = dt[(lt == null ? void 0 : lt.userId) ?? ""] ?? [];
            Je < $t.length - 1 && Ve($t[Je + 1]), Qe(() => Math.min(Je + 1, $t.length - 1));
          }
          if (bt.key === "ArrowDown") {
            bt.preventDefault();
            const $t = dt[(lt == null ? void 0 : lt.userId) ?? ""] ?? [];
            Ve(Je === 0 ? "" : $t[Je - 1]), Qe(() => Math.max(Je - 1, -1));
          }
        }
      },
      ...$e
    }
  );
}), ComposerButton = memo(
  forwardRef(({ icon: $e = ArrowUpCircleIcon$1, ...Ze }, Fe) => {
    var Qe, at;
    const { value: Ke, sendMessage: Ve } = useComposerContext(), {
      theme: { composer: Je }
    } = useWebchatContext();
    return /* @__PURE__ */ jsxRuntimeExports.jsx("button", { ref: Fe, ...Ze, ...(Qe = Je == null ? void 0 : Je.button) == null ? void 0 : Qe.container, disabled: !Ke, onClick: Ve, children: /* @__PURE__ */ jsxRuntimeExports.jsx($e, { ...(at = Je == null ? void 0 : Je.button) == null ? void 0 : at.icon }) });
  })
), ModalProvider = ({ children: $e }) => {
  const [Ze, Fe] = useState(!1), [Ke, Ve] = useState(""), [Je, Qe] = useState(null), at = ({ title: lt, content: dt }) => {
    Ve(lt), Qe(dt), Fe(!0);
  }, ut = () => {
    Fe(!1);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalContext.Provider, { value: { hideModal: ut, showModal: at, title: Ke, content: Je, open: Ze }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Modal, { open: Ze, onOpenChange: Fe, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Modal.Content, { title: Ke, children: Je }) }),
    $e
  ] });
}, WebchatProvider = ({
  theme: $e = {},
  renderers: Ze,
  client: Fe,
  children: Ke,
  configuration: Ve = {},
  ...Je
}) => {
  const [Qe, at] = useState(0), [ut, lt] = useState([]), [dt, bt] = useState({
    disableComposer: !1,
    ...Je.defaultState,
    connected: !0
  }), [$t, vt] = useState(Ve), [wt, xt] = useState($e), Et = useWebchatStore((Ut) => Ut.addMessageToHistory), Tt = useWebchatStore((Ut) => Ut.setConversationId), Rt = useWebchatStore((Ut) => Ut.user), Ct = useWebchatStore((Ut) => Ut.conversationId), Zt = useWebchatStore((Ut) => Ut.setUser), Lt = {
    ...Je,
    value: {
      theme: wt,
      renderers: { ...renderers, ...Ze },
      messages: ut,
      setMessages: lt,
      eventEmitter,
      configuration: Ve,
      setConfiguration: vt,
      state: dt,
      setState: (Ut) => bt({ ...dt, ...Ut }),
      setTheme: (Ut) => {
        xt(Ut);
      },
      client: Fe ? {
        ...Fe,
        sendMessage: async (Ut) => {
          await Fe.sendMessage(Ut), lt((Pt) => [
            ...Pt,
            {
              direction: "outgoing",
              sender: { name: "You" },
              timestamp: /* @__PURE__ */ new Date(),
              block: { type: "bubble", block: { type: "text", text: Ut } }
            }
          ]), Fe.userId && Et({ message: Ut, userId: Fe.userId });
        },
        on: Fe.on,
        restartConversation: async () => {
          await Fe.newConversation(), lt([]);
        }
      } : void 0
    }
  };
  return useEffectOnce$1(() => {
    if (Fe)
      return Fe.on("message", (Ut) => {
        try {
          const Pt = Ut.payload;
          lt((Ot) => [
            ...Ot,
            {
              direction: "incoming",
              sender: { name: $t.botName ?? "Bot", avatar: $t.botAvatar },
              timestamp: new Date(Ut.sentOn),
              block: Pt
            }
          ]);
        } catch {
          console.error("Invalid message payload");
        }
      });
  }), useAsync(async () => {
    if (Fe)
      return Fe.on("error", () => {
        console.log("client disconnected"), at((Ut) => Ut + 1);
      });
  }), useEffectOnce$1(() => {
    if (Fe)
      return Fe.on("conversation", (Ut) => {
        Tt(Ut);
      });
  }), useAsync(async () => {
    if (!Fe)
      return;
    let Ut;
    try {
      Ut = await Fe.connect(Rt), bt((Ot) => ({ ...Ot, connected: !0 }));
    } catch {
      bt((Ft) => ({ ...Ft, connected: !1 }));
      return;
    }
    Zt(Ut), Ct && await Fe.conversationExists(Ct) && await Fe.switchConversation(Ct);
    const Pt = [];
    for (const Ot of await Fe.listMessages())
      try {
        const Ft = Ot.payload, gt = Ot.authorId === Fe.userId ? "outgoing" : "incoming";
        Pt.push({
          direction: gt,
          sender: gt === "outgoing" ? { name: "You" } : { name: $t.botName ?? "Bot", avatar: $t.botAvatar },
          timestamp: new Date(Ot.sentOn),
          block: Ft
        });
      } catch {
        console.error("Invalid message payload");
      }
    return lt(Pt.reverse()), () => {
      Fe.disconnect();
    };
  }, [Qe]), /* @__PURE__ */ jsxRuntimeExports.jsx(WebchatContext.Provider, { ...Lt, children: typeof Ke == "function" ? Ke($t) : Ke });
};
function $e42e1063c40fb3ef$export$b9ecd428b558ff10($e, Ze, { checkForDefaultPrevented: Fe = !0 } = {}) {
  return function(Ve) {
    if ($e == null || $e(Ve), Fe === !1 || !Ve.defaultPrevented)
      return Ze == null ? void 0 : Ze(Ve);
  };
}
const $1746a345f3d73bb7$var$useReactId = React["useId".toString()] || (() => {
});
let $1746a345f3d73bb7$var$count = 0;
function $1746a345f3d73bb7$export$f680877a34711e37($e) {
  const [Ze, Fe] = React.useState($1746a345f3d73bb7$var$useReactId());
  return $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    $e || Fe(
      (Ke) => Ke ?? String($1746a345f3d73bb7$var$count++)
    );
  }, [
    $e
  ]), $e || (Ze ? `radix-${Ze}` : "");
}
function $71cd76cc60e0454e$export$6f32135080cb4c3({ prop: $e, defaultProp: Ze, onChange: Fe = () => {
} }) {
  const [Ke, Ve] = $71cd76cc60e0454e$var$useUncontrolledState({
    defaultProp: Ze,
    onChange: Fe
  }), Je = $e !== void 0, Qe = Je ? $e : Ke, at = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(Fe), ut = useCallback((lt) => {
    if (Je) {
      const bt = typeof lt == "function" ? lt($e) : lt;
      bt !== $e && at(bt);
    } else
      Ve(lt);
  }, [
    Je,
    $e,
    Ve,
    at
  ]);
  return [
    Qe,
    ut
  ];
}
function $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp: $e, onChange: Ze }) {
  const Fe = useState($e), [Ke] = Fe, Ve = useRef(Ke), Je = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(Ze);
  return useEffect(() => {
    Ve.current !== Ke && (Je(Ke), Ve.current = Ke);
  }, [
    Ke,
    Ve,
    Je
  ]), Fe;
}
function $addc16e1bbe58fd0$export$3a72a57244d6e765($e, Ze = globalThis == null ? void 0 : globalThis.document) {
  const Fe = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a($e);
  useEffect(() => {
    const Ke = (Ve) => {
      Ve.key === "Escape" && Fe(Ve);
    };
    return Ze.addEventListener("keydown", Ke), () => Ze.removeEventListener("keydown", Ke);
  }, [
    Fe,
    Ze
  ]);
}
const $5cb92bef7577960e$var$CONTEXT_UPDATE = "dismissableLayer.update", $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside", $5cb92bef7577960e$var$FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
let $5cb92bef7577960e$var$originalBodyPointerEvents;
const $5cb92bef7577960e$var$DismissableLayerContext = /* @__PURE__ */ createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), $5cb92bef7577960e$export$177fb62ff3ec1f22 = /* @__PURE__ */ forwardRef(($e, Ze) => {
  var Fe;
  const { disableOutsidePointerEvents: Ke = !1, onEscapeKeyDown: Ve, onPointerDownOutside: Je, onFocusOutside: Qe, onInteractOutside: at, onDismiss: ut, ...lt } = $e, dt = useContext($5cb92bef7577960e$var$DismissableLayerContext), [bt, $t] = useState(null), vt = (Fe = bt == null ? void 0 : bt.ownerDocument) !== null && Fe !== void 0 ? Fe : globalThis == null ? void 0 : globalThis.document, [, wt] = useState({}), xt = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    Ze,
    (Ot) => $t(Ot)
  ), Et = Array.from(dt.layers), [Tt] = [
    ...dt.layersWithOutsidePointerEventsDisabled
  ].slice(-1), Rt = Et.indexOf(Tt), Ct = bt ? Et.indexOf(bt) : -1, Zt = dt.layersWithOutsidePointerEventsDisabled.size > 0, Lt = Ct >= Rt, Ut = $5cb92bef7577960e$var$usePointerDownOutside((Ot) => {
    const Ft = Ot.target, gt = [
      ...dt.branches
    ].some(
      (We) => We.contains(Ft)
    );
    !Lt || gt || (Je == null || Je(Ot), at == null || at(Ot), Ot.defaultPrevented || ut == null || ut());
  }, vt), Pt = $5cb92bef7577960e$var$useFocusOutside((Ot) => {
    const Ft = Ot.target;
    [
      ...dt.branches
    ].some(
      (We) => We.contains(Ft)
    ) || (Qe == null || Qe(Ot), at == null || at(Ot), Ot.defaultPrevented || ut == null || ut());
  }, vt);
  return $addc16e1bbe58fd0$export$3a72a57244d6e765((Ot) => {
    Ct === dt.layers.size - 1 && (Ve == null || Ve(Ot), !Ot.defaultPrevented && ut && (Ot.preventDefault(), ut()));
  }, vt), useEffect(() => {
    if (bt)
      return Ke && (dt.layersWithOutsidePointerEventsDisabled.size === 0 && ($5cb92bef7577960e$var$originalBodyPointerEvents = vt.body.style.pointerEvents, vt.body.style.pointerEvents = "none"), dt.layersWithOutsidePointerEventsDisabled.add(bt)), dt.layers.add(bt), $5cb92bef7577960e$var$dispatchUpdate(), () => {
        Ke && dt.layersWithOutsidePointerEventsDisabled.size === 1 && (vt.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents);
      };
  }, [
    bt,
    vt,
    Ke,
    dt
  ]), useEffect(() => () => {
    bt && (dt.layers.delete(bt), dt.layersWithOutsidePointerEventsDisabled.delete(bt), $5cb92bef7577960e$var$dispatchUpdate());
  }, [
    bt,
    dt
  ]), useEffect(() => {
    const Ot = () => wt({});
    return document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, Ot), () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, Ot);
  }, []), /* @__PURE__ */ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$1({}, lt, {
    ref: xt,
    style: {
      pointerEvents: Zt ? Lt ? "auto" : "none" : void 0,
      ...$e.style
    },
    onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10($e.onFocusCapture, Pt.onFocusCapture),
    onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10($e.onBlurCapture, Pt.onBlurCapture),
    onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10($e.onPointerDownCapture, Ut.onPointerDownCapture)
  }));
});
function $5cb92bef7577960e$var$usePointerDownOutside($e, Ze = globalThis == null ? void 0 : globalThis.document) {
  const Fe = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a($e), Ke = useRef(!1), Ve = useRef(() => {
  });
  return useEffect(() => {
    const Je = (at) => {
      if (at.target && !Ke.current) {
        let lt = function() {
          $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, Fe, ut, {
            discrete: !0
          });
        };
        const ut = {
          originalEvent: at
        };
        at.pointerType === "touch" ? (Ze.removeEventListener("click", Ve.current), Ve.current = lt, Ze.addEventListener("click", Ve.current, {
          once: !0
        })) : lt();
      }
      Ke.current = !1;
    }, Qe = window.setTimeout(() => {
      Ze.addEventListener("pointerdown", Je);
    }, 0);
    return () => {
      window.clearTimeout(Qe), Ze.removeEventListener("pointerdown", Je), Ze.removeEventListener("click", Ve.current);
    };
  }, [
    Ze,
    Fe
  ]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => Ke.current = !0
  };
}
function $5cb92bef7577960e$var$useFocusOutside($e, Ze = globalThis == null ? void 0 : globalThis.document) {
  const Fe = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a($e), Ke = useRef(!1);
  return useEffect(() => {
    const Ve = (Je) => {
      Je.target && !Ke.current && $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE, Fe, {
        originalEvent: Je
      }, {
        discrete: !1
      });
    };
    return Ze.addEventListener("focusin", Ve), () => Ze.removeEventListener("focusin", Ve);
  }, [
    Ze,
    Fe
  ]), {
    onFocusCapture: () => Ke.current = !0,
    onBlurCapture: () => Ke.current = !1
  };
}
function $5cb92bef7577960e$var$dispatchUpdate() {
  const $e = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);
  document.dispatchEvent($e);
}
function $5cb92bef7577960e$var$handleAndDispatchCustomEvent($e, Ze, Fe, { discrete: Ke }) {
  const Ve = Fe.originalEvent.target, Je = new CustomEvent($e, {
    bubbles: !1,
    cancelable: !0,
    detail: Fe
  });
  Ze && Ve.addEventListener($e, Ze, {
    once: !0
  }), Ke ? $8927f6f2acc4f386$export$6d1a0317bde7de7f(Ve, Je) : Ve.dispatchEvent(Je);
}
const $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount", $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount", $d3863c46a17e8a28$var$EVENT_OPTIONS = {
  bubbles: !1,
  cancelable: !0
}, $d3863c46a17e8a28$export$20e40289641fbbb6 = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const { loop: Fe = !1, trapped: Ke = !1, onMountAutoFocus: Ve, onUnmountAutoFocus: Je, ...Qe } = $e, [at, ut] = useState(null), lt = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(Ve), dt = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(Je), bt = useRef(null), $t = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    Ze,
    (xt) => ut(xt)
  ), vt = useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  useEffect(() => {
    if (Ke) {
      let xt = function(Ct) {
        if (vt.paused || !at)
          return;
        const Zt = Ct.target;
        at.contains(Zt) ? bt.current = Zt : $d3863c46a17e8a28$var$focus(bt.current, {
          select: !0
        });
      }, Et = function(Ct) {
        if (vt.paused || !at)
          return;
        const Zt = Ct.relatedTarget;
        Zt !== null && (at.contains(Zt) || $d3863c46a17e8a28$var$focus(bt.current, {
          select: !0
        }));
      }, Tt = function(Ct) {
        const Zt = document.activeElement;
        for (const Lt of Ct)
          Lt.removedNodes.length > 0 && (at != null && at.contains(Zt) || $d3863c46a17e8a28$var$focus(at));
      };
      document.addEventListener("focusin", xt), document.addEventListener("focusout", Et);
      const Rt = new MutationObserver(Tt);
      return at && Rt.observe(at, {
        childList: !0,
        subtree: !0
      }), () => {
        document.removeEventListener("focusin", xt), document.removeEventListener("focusout", Et), Rt.disconnect();
      };
    }
  }, [
    Ke,
    at,
    vt.paused
  ]), useEffect(() => {
    if (at) {
      $d3863c46a17e8a28$var$focusScopesStack.add(vt);
      const xt = document.activeElement;
      if (!at.contains(xt)) {
        const Tt = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
        at.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, lt), at.dispatchEvent(Tt), Tt.defaultPrevented || ($d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(at)), {
          select: !0
        }), document.activeElement === xt && $d3863c46a17e8a28$var$focus(at));
      }
      return () => {
        at.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, lt), setTimeout(() => {
          const Tt = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
          at.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, dt), at.dispatchEvent(Tt), Tt.defaultPrevented || $d3863c46a17e8a28$var$focus(xt ?? document.body, {
            select: !0
          }), at.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, dt), $d3863c46a17e8a28$var$focusScopesStack.remove(vt);
        }, 0);
      };
    }
  }, [
    at,
    lt,
    dt,
    vt
  ]);
  const wt = useCallback((xt) => {
    if (!Fe && !Ke || vt.paused)
      return;
    const Et = xt.key === "Tab" && !xt.altKey && !xt.ctrlKey && !xt.metaKey, Tt = document.activeElement;
    if (Et && Tt) {
      const Rt = xt.currentTarget, [Ct, Zt] = $d3863c46a17e8a28$var$getTabbableEdges(Rt);
      Ct && Zt ? !xt.shiftKey && Tt === Zt ? (xt.preventDefault(), Fe && $d3863c46a17e8a28$var$focus(Ct, {
        select: !0
      })) : xt.shiftKey && Tt === Ct && (xt.preventDefault(), Fe && $d3863c46a17e8a28$var$focus(Zt, {
        select: !0
      })) : Tt === Rt && xt.preventDefault();
    }
  }, [
    Fe,
    Ke,
    vt.paused
  ]);
  return /* @__PURE__ */ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$1({
    tabIndex: -1
  }, Qe, {
    ref: $t,
    onKeyDown: wt
  }));
});
function $d3863c46a17e8a28$var$focusFirst($e, { select: Ze = !1 } = {}) {
  const Fe = document.activeElement;
  for (const Ke of $e)
    if ($d3863c46a17e8a28$var$focus(Ke, {
      select: Ze
    }), document.activeElement !== Fe)
      return;
}
function $d3863c46a17e8a28$var$getTabbableEdges($e) {
  const Ze = $d3863c46a17e8a28$var$getTabbableCandidates($e), Fe = $d3863c46a17e8a28$var$findVisible(Ze, $e), Ke = $d3863c46a17e8a28$var$findVisible(Ze.reverse(), $e);
  return [
    Fe,
    Ke
  ];
}
function $d3863c46a17e8a28$var$getTabbableCandidates($e) {
  const Ze = [], Fe = document.createTreeWalker($e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (Ke) => {
      const Ve = Ke.tagName === "INPUT" && Ke.type === "hidden";
      return Ke.disabled || Ke.hidden || Ve ? NodeFilter.FILTER_SKIP : Ke.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; Fe.nextNode(); )
    Ze.push(Fe.currentNode);
  return Ze;
}
function $d3863c46a17e8a28$var$findVisible($e, Ze) {
  for (const Fe of $e)
    if (!$d3863c46a17e8a28$var$isHidden(Fe, {
      upTo: Ze
    }))
      return Fe;
}
function $d3863c46a17e8a28$var$isHidden($e, { upTo: Ze }) {
  if (getComputedStyle($e).visibility === "hidden")
    return !0;
  for (; $e; ) {
    if (Ze !== void 0 && $e === Ze)
      return !1;
    if (getComputedStyle($e).display === "none")
      return !0;
    $e = $e.parentElement;
  }
  return !1;
}
function $d3863c46a17e8a28$var$isSelectableInput($e) {
  return $e instanceof HTMLInputElement && "select" in $e;
}
function $d3863c46a17e8a28$var$focus($e, { select: Ze = !1 } = {}) {
  if ($e && $e.focus) {
    const Fe = document.activeElement;
    $e.focus({
      preventScroll: !0
    }), $e !== Fe && $d3863c46a17e8a28$var$isSelectableInput($e) && Ze && $e.select();
  }
}
const $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();
function $d3863c46a17e8a28$var$createFocusScopesStack() {
  let $e = [];
  return {
    add(Ze) {
      const Fe = $e[0];
      Ze !== Fe && (Fe == null || Fe.pause()), $e = $d3863c46a17e8a28$var$arrayRemove($e, Ze), $e.unshift(Ze);
    },
    remove(Ze) {
      var Fe;
      $e = $d3863c46a17e8a28$var$arrayRemove($e, Ze), (Fe = $e[0]) === null || Fe === void 0 || Fe.resume();
    }
  };
}
function $d3863c46a17e8a28$var$arrayRemove($e, Ze) {
  const Fe = [
    ...$e
  ], Ke = Fe.indexOf(Ze);
  return Ke !== -1 && Fe.splice(Ke, 1), Fe;
}
function $d3863c46a17e8a28$var$removeLinks($e) {
  return $e.filter(
    (Ze) => Ze.tagName !== "A"
  );
}
function $fe963b355347cc68$export$3e6543de14f8614f($e, Ze) {
  return useReducer((Fe, Ke) => {
    const Ve = Ze[Fe][Ke];
    return Ve ?? Fe;
  }, $e);
}
const $921a889cee6df7e8$export$99c2b779aa4e8b8b = ($e) => {
  const { present: Ze, children: Fe } = $e, Ke = $921a889cee6df7e8$var$usePresence(Ze), Ve = typeof Fe == "function" ? Fe({
    present: Ke.isPresent
  }) : Children.only(Fe), Je = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(Ke.ref, Ve.ref);
  return typeof Fe == "function" || Ke.isPresent ? /* @__PURE__ */ cloneElement(Ve, {
    ref: Je
  }) : null;
};
$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = "Presence";
function $921a889cee6df7e8$var$usePresence($e) {
  const [Ze, Fe] = useState(), Ke = useRef({}), Ve = useRef($e), Je = useRef("none"), Qe = $e ? "mounted" : "unmounted", [at, ut] = $fe963b355347cc68$export$3e6543de14f8614f(Qe, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return useEffect(() => {
    const lt = $921a889cee6df7e8$var$getAnimationName(Ke.current);
    Je.current = at === "mounted" ? lt : "none";
  }, [
    at
  ]), $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    const lt = Ke.current, dt = Ve.current;
    if (dt !== $e) {
      const $t = Je.current, vt = $921a889cee6df7e8$var$getAnimationName(lt);
      $e ? ut("MOUNT") : vt === "none" || (lt == null ? void 0 : lt.display) === "none" ? ut("UNMOUNT") : ut(dt && $t !== vt ? "ANIMATION_OUT" : "UNMOUNT"), Ve.current = $e;
    }
  }, [
    $e,
    ut
  ]), $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (Ze) {
      const lt = (bt) => {
        const vt = $921a889cee6df7e8$var$getAnimationName(Ke.current).includes(bt.animationName);
        bt.target === Ze && vt && flushSync(
          () => ut("ANIMATION_END")
        );
      }, dt = (bt) => {
        bt.target === Ze && (Je.current = $921a889cee6df7e8$var$getAnimationName(Ke.current));
      };
      return Ze.addEventListener("animationstart", dt), Ze.addEventListener("animationcancel", lt), Ze.addEventListener("animationend", lt), () => {
        Ze.removeEventListener("animationstart", dt), Ze.removeEventListener("animationcancel", lt), Ze.removeEventListener("animationend", lt);
      };
    } else
      ut("ANIMATION_END");
  }, [
    Ze,
    ut
  ]), {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(at),
    ref: useCallback((lt) => {
      lt && (Ke.current = getComputedStyle(lt)), Fe(lt);
    }, [])
  };
}
function $921a889cee6df7e8$var$getAnimationName($e) {
  return ($e == null ? void 0 : $e.animationName) || "none";
}
let $3db38b7d1fb3fe6a$var$count = 0;
function $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c() {
  useEffect(() => {
    var $e, Ze;
    const Fe = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", ($e = Fe[0]) !== null && $e !== void 0 ? $e : $3db38b7d1fb3fe6a$var$createFocusGuard()), document.body.insertAdjacentElement("beforeend", (Ze = Fe[1]) !== null && Ze !== void 0 ? Ze : $3db38b7d1fb3fe6a$var$createFocusGuard()), $3db38b7d1fb3fe6a$var$count++, () => {
      $3db38b7d1fb3fe6a$var$count === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(
        (Ke) => Ke.remove()
      ), $3db38b7d1fb3fe6a$var$count--;
    };
  }, []);
}
function $3db38b7d1fb3fe6a$var$createFocusGuard() {
  const $e = document.createElement("span");
  return $e.setAttribute("data-radix-focus-guard", ""), $e.tabIndex = 0, $e.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", $e;
}
var zeroRightClassName = "right-scroll-bar-position", fullWidthClassName = "width-before-scroll-bar", noScrollbarsClassName = "with-scroll-bars-hidden", removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef($e, Ze) {
  return typeof $e == "function" ? $e(Ze) : $e && ($e.current = Ze), $e;
}
function useCallbackRef($e, Ze) {
  var Fe = useState(function() {
    return {
      // value
      value: $e,
      // last callback
      callback: Ze,
      // "memoized" public interface
      facade: {
        get current() {
          return Fe.value;
        },
        set current(Ke) {
          var Ve = Fe.value;
          Ve !== Ke && (Fe.value = Ke, Fe.callback(Ke, Ve));
        }
      }
    };
  })[0];
  return Fe.callback = Ze, Fe.facade;
}
function useMergeRefs($e, Ze) {
  return useCallbackRef(Ze || null, function(Fe) {
    return $e.forEach(function(Ke) {
      return assignRef(Ke, Fe);
    });
  });
}
function ItoI($e) {
  return $e;
}
function innerCreateMedium($e, Ze) {
  Ze === void 0 && (Ze = ItoI);
  var Fe = [], Ke = !1, Ve = {
    read: function() {
      if (Ke)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return Fe.length ? Fe[Fe.length - 1] : $e;
    },
    useMedium: function(Je) {
      var Qe = Ze(Je, Ke);
      return Fe.push(Qe), function() {
        Fe = Fe.filter(function(at) {
          return at !== Qe;
        });
      };
    },
    assignSyncMedium: function(Je) {
      for (Ke = !0; Fe.length; ) {
        var Qe = Fe;
        Fe = [], Qe.forEach(Je);
      }
      Fe = {
        push: function(at) {
          return Je(at);
        },
        filter: function() {
          return Fe;
        }
      };
    },
    assignMedium: function(Je) {
      Ke = !0;
      var Qe = [];
      if (Fe.length) {
        var at = Fe;
        Fe = [], at.forEach(Je), Qe = Fe;
      }
      var ut = function() {
        var dt = Qe;
        Qe = [], dt.forEach(Je);
      }, lt = function() {
        return Promise.resolve().then(ut);
      };
      lt(), Fe = {
        push: function(dt) {
          Qe.push(dt), lt();
        },
        filter: function(dt) {
          return Qe = Qe.filter(dt), Fe;
        }
      };
    }
  };
  return Ve;
}
function createSidecarMedium($e) {
  $e === void 0 && ($e = {});
  var Ze = innerCreateMedium(null);
  return Ze.options = __assign({ async: !0, ssr: !1 }, $e), Ze;
}
var SideCar$1 = function($e) {
  var Ze = $e.sideCar, Fe = __rest($e, ["sideCar"]);
  if (!Ze)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var Ke = Ze.read();
  if (!Ke)
    throw new Error("Sidecar medium not found");
  return React.createElement(Ke, __assign({}, Fe));
};
SideCar$1.isSideCarExport = !0;
function exportSidecar($e, Ze) {
  return $e.useMedium(Ze), SideCar$1;
}
var effectCar = createSidecarMedium(), nothing = function() {
}, RemoveScroll = React.forwardRef(function($e, Ze) {
  var Fe = React.useRef(null), Ke = React.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), Ve = Ke[0], Je = Ke[1], Qe = $e.forwardProps, at = $e.children, ut = $e.className, lt = $e.removeScrollBar, dt = $e.enabled, bt = $e.shards, $t = $e.sideCar, vt = $e.noIsolation, wt = $e.inert, xt = $e.allowPinchZoom, Et = $e.as, Tt = Et === void 0 ? "div" : Et, Rt = __rest($e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]), Ct = $t, Zt = useMergeRefs([Fe, Ze]), Lt = __assign(__assign({}, Rt), Ve);
  return React.createElement(
    React.Fragment,
    null,
    dt && React.createElement(Ct, { sideCar: effectCar, removeScrollBar: lt, shards: bt, noIsolation: vt, inert: wt, setCallbacks: Je, allowPinchZoom: !!xt, lockRef: Fe }),
    Qe ? React.cloneElement(React.Children.only(at), __assign(__assign({}, Lt), { ref: Zt })) : React.createElement(Tt, __assign({}, Lt, { className: ut, ref: Zt }), at)
  );
});
RemoveScroll.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var currentNonce, getNonce = function() {
  if (currentNonce)
    return currentNonce;
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function makeStyleTag() {
  if (!document)
    return null;
  var $e = document.createElement("style");
  $e.type = "text/css";
  var Ze = getNonce();
  return Ze && $e.setAttribute("nonce", Ze), $e;
}
function injectStyles($e, Ze) {
  $e.styleSheet ? $e.styleSheet.cssText = Ze : $e.appendChild(document.createTextNode(Ze));
}
function insertStyleTag($e) {
  var Ze = document.head || document.getElementsByTagName("head")[0];
  Ze.appendChild($e);
}
var stylesheetSingleton = function() {
  var $e = 0, Ze = null;
  return {
    add: function(Fe) {
      $e == 0 && (Ze = makeStyleTag()) && (injectStyles(Ze, Fe), insertStyleTag(Ze)), $e++;
    },
    remove: function() {
      $e--, !$e && Ze && (Ze.parentNode && Ze.parentNode.removeChild(Ze), Ze = null);
    }
  };
}, styleHookSingleton = function() {
  var $e = stylesheetSingleton();
  return function(Ze, Fe) {
    React.useEffect(function() {
      return $e.add(Ze), function() {
        $e.remove();
      };
    }, [Ze && Fe]);
  };
}, styleSingleton = function() {
  var $e = styleHookSingleton(), Ze = function(Fe) {
    var Ke = Fe.styles, Ve = Fe.dynamic;
    return $e(Ke, Ve), null;
  };
  return Ze;
}, zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, parse$3 = function($e) {
  return parseInt($e || "", 10) || 0;
}, getOffset = function($e) {
  var Ze = window.getComputedStyle(document.body), Fe = Ze[$e === "padding" ? "paddingLeft" : "marginLeft"], Ke = Ze[$e === "padding" ? "paddingTop" : "marginTop"], Ve = Ze[$e === "padding" ? "paddingRight" : "marginRight"];
  return [parse$3(Fe), parse$3(Ke), parse$3(Ve)];
}, getGapWidth = function($e) {
  if ($e === void 0 && ($e = "margin"), typeof window > "u")
    return zeroGap;
  var Ze = getOffset($e), Fe = document.documentElement.clientWidth, Ke = window.innerWidth;
  return {
    left: Ze[0],
    top: Ze[1],
    right: Ze[2],
    gap: Math.max(0, Ke - Fe + Ze[2] - Ze[0])
  };
}, Style = styleSingleton(), getStyles = function($e, Ze, Fe, Ke) {
  var Ve = $e.left, Je = $e.top, Qe = $e.right, at = $e.gap;
  return Fe === void 0 && (Fe = "margin"), `
  .`.concat(noScrollbarsClassName, ` {
   overflow: hidden `).concat(Ke, `;
   padding-right: `).concat(at, "px ").concat(Ke, `;
  }
  body {
    overflow: hidden `).concat(Ke, `;
    overscroll-behavior: contain;
    `).concat([
    Ze && "position: relative ".concat(Ke, ";"),
    Fe === "margin" && `
    padding-left: `.concat(Ve, `px;
    padding-top: `).concat(Je, `px;
    padding-right: `).concat(Qe, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(at, "px ").concat(Ke, `;
    `),
    Fe === "padding" && "padding-right: ".concat(at, "px ").concat(Ke, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(zeroRightClassName, ` {
    right: `).concat(at, "px ").concat(Ke, `;
  }
  
  .`).concat(fullWidthClassName, ` {
    margin-right: `).concat(at, "px ").concat(Ke, `;
  }
  
  .`).concat(zeroRightClassName, " .").concat(zeroRightClassName, ` {
    right: 0 `).concat(Ke, `;
  }
  
  .`).concat(fullWidthClassName, " .").concat(fullWidthClassName, ` {
    margin-right: 0 `).concat(Ke, `;
  }
  
  body {
    `).concat(removedBarSizeVariable, ": ").concat(at, `px;
  }
`);
}, RemoveScrollBar = function($e) {
  var Ze = $e.noRelative, Fe = $e.noImportant, Ke = $e.gapMode, Ve = Ke === void 0 ? "margin" : Ke, Je = React.useMemo(function() {
    return getGapWidth(Ve);
  }, [Ve]);
  return React.createElement(Style, { styles: getStyles(Je, !Ze, Ve, Fe ? "" : "!important") });
}, passiveSupported = !1;
if (typeof window < "u")
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        return passiveSupported = !0, !0;
      }
    });
    window.addEventListener("test", options, options), window.removeEventListener("test", options, options);
  } catch {
    passiveSupported = !1;
  }
var nonPassive = passiveSupported ? { passive: !1 } : !1, alwaysContainsScroll = function($e) {
  return $e.tagName === "TEXTAREA";
}, elementCanBeScrolled = function($e, Ze) {
  var Fe = window.getComputedStyle($e);
  return (
    // not-not-scrollable
    Fe[Ze] !== "hidden" && // contains scroll inside self
    !(Fe.overflowY === Fe.overflowX && !alwaysContainsScroll($e) && Fe[Ze] === "visible")
  );
}, elementCouldBeVScrolled = function($e) {
  return elementCanBeScrolled($e, "overflowY");
}, elementCouldBeHScrolled = function($e) {
  return elementCanBeScrolled($e, "overflowX");
}, locationCouldBeScrolled = function($e, Ze) {
  var Fe = Ze;
  do {
    typeof ShadowRoot < "u" && Fe instanceof ShadowRoot && (Fe = Fe.host);
    var Ke = elementCouldBeScrolled($e, Fe);
    if (Ke) {
      var Ve = getScrollVariables($e, Fe), Je = Ve[1], Qe = Ve[2];
      if (Je > Qe)
        return !0;
    }
    Fe = Fe.parentNode;
  } while (Fe && Fe !== document.body);
  return !1;
}, getVScrollVariables = function($e) {
  var Ze = $e.scrollTop, Fe = $e.scrollHeight, Ke = $e.clientHeight;
  return [
    Ze,
    Fe,
    Ke
  ];
}, getHScrollVariables = function($e) {
  var Ze = $e.scrollLeft, Fe = $e.scrollWidth, Ke = $e.clientWidth;
  return [
    Ze,
    Fe,
    Ke
  ];
}, elementCouldBeScrolled = function($e, Ze) {
  return $e === "v" ? elementCouldBeVScrolled(Ze) : elementCouldBeHScrolled(Ze);
}, getScrollVariables = function($e, Ze) {
  return $e === "v" ? getVScrollVariables(Ze) : getHScrollVariables(Ze);
}, getDirectionFactor = function($e, Ze) {
  return $e === "h" && Ze === "rtl" ? -1 : 1;
}, handleScroll = function($e, Ze, Fe, Ke, Ve) {
  var Je = getDirectionFactor($e, window.getComputedStyle(Ze).direction), Qe = Je * Ke, at = Fe.target, ut = Ze.contains(at), lt = !1, dt = Qe > 0, bt = 0, $t = 0;
  do {
    var vt = getScrollVariables($e, at), wt = vt[0], xt = vt[1], Et = vt[2], Tt = xt - Et - Je * wt;
    (wt || Tt) && elementCouldBeScrolled($e, at) && (bt += Tt, $t += wt), at = at.parentNode;
  } while (
    // portaled content
    !ut && at !== document.body || // self content
    ut && (Ze.contains(at) || Ze === at)
  );
  return (dt && (Ve && bt === 0 || !Ve && Qe > bt) || !dt && (Ve && $t === 0 || !Ve && -Qe > $t)) && (lt = !0), lt;
}, getTouchXY = function($e) {
  return "changedTouches" in $e ? [$e.changedTouches[0].clientX, $e.changedTouches[0].clientY] : [0, 0];
}, getDeltaXY = function($e) {
  return [$e.deltaX, $e.deltaY];
}, extractRef = function($e) {
  return $e && "current" in $e ? $e.current : $e;
}, deltaCompare = function($e, Ze) {
  return $e[0] === Ze[0] && $e[1] === Ze[1];
}, generateStyle = function($e) {
  return `
  .block-interactivity-`.concat($e, ` {pointer-events: none;}
  .allow-interactivity-`).concat($e, ` {pointer-events: all;}
`);
}, idCounter = 0, lockStack = [];
function RemoveScrollSideCar($e) {
  var Ze = React.useRef([]), Fe = React.useRef([0, 0]), Ke = React.useRef(), Ve = React.useState(idCounter++)[0], Je = React.useState(function() {
    return styleSingleton();
  })[0], Qe = React.useRef($e);
  React.useEffect(function() {
    Qe.current = $e;
  }, [$e]), React.useEffect(function() {
    if ($e.inert) {
      document.body.classList.add("block-interactivity-".concat(Ve));
      var xt = __spreadArray([$e.lockRef.current], ($e.shards || []).map(extractRef), !0).filter(Boolean);
      return xt.forEach(function(Et) {
        return Et.classList.add("allow-interactivity-".concat(Ve));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(Ve)), xt.forEach(function(Et) {
          return Et.classList.remove("allow-interactivity-".concat(Ve));
        });
      };
    }
  }, [$e.inert, $e.lockRef.current, $e.shards]);
  var at = React.useCallback(function(xt, Et) {
    if ("touches" in xt && xt.touches.length === 2)
      return !Qe.current.allowPinchZoom;
    var Tt = getTouchXY(xt), Rt = Fe.current, Ct = "deltaX" in xt ? xt.deltaX : Rt[0] - Tt[0], Zt = "deltaY" in xt ? xt.deltaY : Rt[1] - Tt[1], Lt, Ut = xt.target, Pt = Math.abs(Ct) > Math.abs(Zt) ? "h" : "v";
    if ("touches" in xt && Pt === "h" && Ut.type === "range")
      return !1;
    var Ot = locationCouldBeScrolled(Pt, Ut);
    if (!Ot)
      return !0;
    if (Ot ? Lt = Pt : (Lt = Pt === "v" ? "h" : "v", Ot = locationCouldBeScrolled(Pt, Ut)), !Ot)
      return !1;
    if (!Ke.current && "changedTouches" in xt && (Ct || Zt) && (Ke.current = Lt), !Lt)
      return !0;
    var Ft = Ke.current || Lt;
    return handleScroll(Ft, Et, xt, Ft === "h" ? Ct : Zt, !0);
  }, []), ut = React.useCallback(function(xt) {
    var Et = xt;
    if (!(!lockStack.length || lockStack[lockStack.length - 1] !== Je)) {
      var Tt = "deltaY" in Et ? getDeltaXY(Et) : getTouchXY(Et), Rt = Ze.current.filter(function(Lt) {
        return Lt.name === Et.type && Lt.target === Et.target && deltaCompare(Lt.delta, Tt);
      })[0];
      if (Rt && Rt.should) {
        Et.cancelable && Et.preventDefault();
        return;
      }
      if (!Rt) {
        var Ct = (Qe.current.shards || []).map(extractRef).filter(Boolean).filter(function(Lt) {
          return Lt.contains(Et.target);
        }), Zt = Ct.length > 0 ? at(Et, Ct[0]) : !Qe.current.noIsolation;
        Zt && Et.cancelable && Et.preventDefault();
      }
    }
  }, []), lt = React.useCallback(function(xt, Et, Tt, Rt) {
    var Ct = { name: xt, delta: Et, target: Tt, should: Rt };
    Ze.current.push(Ct), setTimeout(function() {
      Ze.current = Ze.current.filter(function(Zt) {
        return Zt !== Ct;
      });
    }, 1);
  }, []), dt = React.useCallback(function(xt) {
    Fe.current = getTouchXY(xt), Ke.current = void 0;
  }, []), bt = React.useCallback(function(xt) {
    lt(xt.type, getDeltaXY(xt), xt.target, at(xt, $e.lockRef.current));
  }, []), $t = React.useCallback(function(xt) {
    lt(xt.type, getTouchXY(xt), xt.target, at(xt, $e.lockRef.current));
  }, []);
  React.useEffect(function() {
    return lockStack.push(Je), $e.setCallbacks({
      onScrollCapture: bt,
      onWheelCapture: bt,
      onTouchMoveCapture: $t
    }), document.addEventListener("wheel", ut, nonPassive), document.addEventListener("touchmove", ut, nonPassive), document.addEventListener("touchstart", dt, nonPassive), function() {
      lockStack = lockStack.filter(function(xt) {
        return xt !== Je;
      }), document.removeEventListener("wheel", ut, nonPassive), document.removeEventListener("touchmove", ut, nonPassive), document.removeEventListener("touchstart", dt, nonPassive);
    };
  }, []);
  var vt = $e.removeScrollBar, wt = $e.inert;
  return React.createElement(
    React.Fragment,
    null,
    wt ? React.createElement(Je, { styles: generateStyle(Ve) }) : null,
    vt ? React.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
  );
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = React.forwardRef(function($e, Ze) {
  return React.createElement(RemoveScroll, __assign({}, $e, { ref: Ze, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
const $67UHm$RemoveScroll = ReactRemoveScroll;
var getDefaultParent = function($e) {
  if (typeof document > "u")
    return null;
  var Ze = Array.isArray($e) ? $e[0] : $e;
  return Ze.ownerDocument.body;
}, counterMap = /* @__PURE__ */ new WeakMap(), uncontrolledNodes = /* @__PURE__ */ new WeakMap(), markerMap = {}, lockCount = 0, unwrapHost = function($e) {
  return $e && ($e.host || unwrapHost($e.parentNode));
}, correctTargets = function($e, Ze) {
  return Ze.map(function(Fe) {
    if ($e.contains(Fe))
      return Fe;
    var Ke = unwrapHost(Fe);
    return Ke && $e.contains(Ke) ? Ke : (console.error("aria-hidden", Fe, "in not contained inside", $e, ". Doing nothing"), null);
  }).filter(function(Fe) {
    return !!Fe;
  });
}, applyAttributeToOthers = function($e, Ze, Fe, Ke) {
  var Ve = correctTargets(Ze, Array.isArray($e) ? $e : [$e]);
  markerMap[Fe] || (markerMap[Fe] = /* @__PURE__ */ new WeakMap());
  var Je = markerMap[Fe], Qe = [], at = /* @__PURE__ */ new Set(), ut = new Set(Ve), lt = function(bt) {
    !bt || at.has(bt) || (at.add(bt), lt(bt.parentNode));
  };
  Ve.forEach(lt);
  var dt = function(bt) {
    !bt || ut.has(bt) || Array.prototype.forEach.call(bt.children, function($t) {
      if (at.has($t))
        dt($t);
      else {
        var vt = $t.getAttribute(Ke), wt = vt !== null && vt !== "false", xt = (counterMap.get($t) || 0) + 1, Et = (Je.get($t) || 0) + 1;
        counterMap.set($t, xt), Je.set($t, Et), Qe.push($t), xt === 1 && wt && uncontrolledNodes.set($t, !0), Et === 1 && $t.setAttribute(Fe, "true"), wt || $t.setAttribute(Ke, "true");
      }
    });
  };
  return dt(Ze), at.clear(), lockCount++, function() {
    Qe.forEach(function(bt) {
      var $t = counterMap.get(bt) - 1, vt = Je.get(bt) - 1;
      counterMap.set(bt, $t), Je.set(bt, vt), $t || (uncontrolledNodes.has(bt) || bt.removeAttribute(Ke), uncontrolledNodes.delete(bt)), vt || bt.removeAttribute(Fe);
    }), lockCount--, lockCount || (counterMap = /* @__PURE__ */ new WeakMap(), counterMap = /* @__PURE__ */ new WeakMap(), uncontrolledNodes = /* @__PURE__ */ new WeakMap(), markerMap = {});
  };
}, hideOthers = function($e, Ze, Fe) {
  Fe === void 0 && (Fe = "data-aria-hidden");
  var Ke = Array.from(Array.isArray($e) ? $e : [$e]), Ve = Ze || getDefaultParent($e);
  return Ve ? (Ke.push.apply(Ke, Array.from(Ve.querySelectorAll("[aria-live]"))), applyAttributeToOthers(Ke, Ve, Fe, "aria-hidden")) : function() {
    return null;
  };
};
const $5d3850c4d0b4e6c7$var$DIALOG_NAME = "Dialog", [$5d3850c4d0b4e6c7$var$createDialogContext, $5d3850c4d0b4e6c7$export$cc702773b8ea3e41] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($5d3850c4d0b4e6c7$var$DIALOG_NAME), [$5d3850c4d0b4e6c7$var$DialogProvider, $5d3850c4d0b4e6c7$var$useDialogContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$DIALOG_NAME), $5d3850c4d0b4e6c7$export$3ddf2d174ce01153 = ($e) => {
  const { __scopeDialog: Ze, children: Fe, open: Ke, defaultOpen: Ve, onOpenChange: Je, modal: Qe = !0 } = $e, at = useRef(null), ut = useRef(null), [lt = !1, dt] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: Ke,
    defaultProp: Ve,
    onChange: Je
  });
  return /* @__PURE__ */ createElement($5d3850c4d0b4e6c7$var$DialogProvider, {
    scope: Ze,
    triggerRef: at,
    contentRef: ut,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    titleId: $1746a345f3d73bb7$export$f680877a34711e37(),
    descriptionId: $1746a345f3d73bb7$export$f680877a34711e37(),
    open: lt,
    onOpenChange: dt,
    onOpenToggle: useCallback(
      () => dt(
        (bt) => !bt
      ),
      [
        dt
      ]
    ),
    modal: Qe
  }, Fe);
}, $5d3850c4d0b4e6c7$var$TRIGGER_NAME = "DialogTrigger", $5d3850c4d0b4e6c7$export$2e1e1122cf0cba88 = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const { __scopeDialog: Fe, ...Ke } = $e, Ve = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$TRIGGER_NAME, Fe), Je = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(Ze, Ve.triggerRef);
  return /* @__PURE__ */ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends$1({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": Ve.open,
    "aria-controls": Ve.contentId,
    "data-state": $5d3850c4d0b4e6c7$var$getState(Ve.open)
  }, Ke, {
    ref: Je,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10($e.onClick, Ve.onOpenToggle)
  }));
}), $5d3850c4d0b4e6c7$var$PORTAL_NAME = "DialogPortal", [$5d3850c4d0b4e6c7$var$PortalProvider, $5d3850c4d0b4e6c7$var$usePortalContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, {
  forceMount: void 0
}), $5d3850c4d0b4e6c7$var$OVERLAY_NAME = "DialogOverlay", $5d3850c4d0b4e6c7$export$bd1d06c79be19e17 = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const Fe = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, $e.__scopeDialog), { forceMount: Ke = Fe.forceMount, ...Ve } = $e, Je = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, $e.__scopeDialog);
  return Je.modal ? /* @__PURE__ */ createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: Ke || Je.open
  }, /* @__PURE__ */ createElement($5d3850c4d0b4e6c7$var$DialogOverlayImpl, _extends$1({}, Ve, {
    ref: Ze
  }))) : null;
}), $5d3850c4d0b4e6c7$var$DialogOverlayImpl = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const { __scopeDialog: Fe, ...Ke } = $e, Ve = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, Fe);
  return (
    // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
    // ie. when `Overlay` and `Content` are siblings
    /* @__PURE__ */ createElement($67UHm$RemoveScroll, {
      as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
      allowPinchZoom: !0,
      shards: [
        Ve.contentRef
      ]
    }, /* @__PURE__ */ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$1({
      "data-state": $5d3850c4d0b4e6c7$var$getState(Ve.open)
    }, Ke, {
      ref: Ze,
      style: {
        pointerEvents: "auto",
        ...Ke.style
      }
    })))
  );
}), $5d3850c4d0b4e6c7$var$CONTENT_NAME = "DialogContent", $5d3850c4d0b4e6c7$export$b6d9565de1e068cf = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const Fe = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, $e.__scopeDialog), { forceMount: Ke = Fe.forceMount, ...Ve } = $e, Je = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, $e.__scopeDialog);
  return /* @__PURE__ */ createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: Ke || Je.open
  }, Je.modal ? /* @__PURE__ */ createElement($5d3850c4d0b4e6c7$var$DialogContentModal, _extends$1({}, Ve, {
    ref: Ze
  })) : /* @__PURE__ */ createElement($5d3850c4d0b4e6c7$var$DialogContentNonModal, _extends$1({}, Ve, {
    ref: Ze
  })));
}), $5d3850c4d0b4e6c7$var$DialogContentModal = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const Fe = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, $e.__scopeDialog), Ke = useRef(null), Ve = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(Ze, Fe.contentRef, Ke);
  return useEffect(() => {
    const Je = Ke.current;
    if (Je)
      return hideOthers(Je);
  }, []), /* @__PURE__ */ createElement($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends$1({}, $e, {
    ref: Ve,
    trapFocus: Fe.open,
    disableOutsidePointerEvents: !0,
    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10($e.onCloseAutoFocus, (Je) => {
      var Qe;
      Je.preventDefault(), (Qe = Fe.triggerRef.current) === null || Qe === void 0 || Qe.focus();
    }),
    onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10($e.onPointerDownOutside, (Je) => {
      const Qe = Je.detail.originalEvent, at = Qe.button === 0 && Qe.ctrlKey === !0;
      (Qe.button === 2 || at) && Je.preventDefault();
    }),
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      $e.onFocusOutside,
      (Je) => Je.preventDefault()
    )
  }));
}), $5d3850c4d0b4e6c7$var$DialogContentNonModal = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const Fe = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, $e.__scopeDialog), Ke = useRef(!1), Ve = useRef(!1);
  return /* @__PURE__ */ createElement($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends$1({}, $e, {
    ref: Ze,
    trapFocus: !1,
    disableOutsidePointerEvents: !1,
    onCloseAutoFocus: (Je) => {
      var Qe;
      if ((Qe = $e.onCloseAutoFocus) === null || Qe === void 0 || Qe.call($e, Je), !Je.defaultPrevented) {
        var at;
        Ke.current || (at = Fe.triggerRef.current) === null || at === void 0 || at.focus(), Je.preventDefault();
      }
      Ke.current = !1, Ve.current = !1;
    },
    onInteractOutside: (Je) => {
      var Qe, at;
      (Qe = $e.onInteractOutside) === null || Qe === void 0 || Qe.call($e, Je), Je.defaultPrevented || (Ke.current = !0, Je.detail.originalEvent.type === "pointerdown" && (Ve.current = !0));
      const ut = Je.target;
      ((at = Fe.triggerRef.current) === null || at === void 0 ? void 0 : at.contains(ut)) && Je.preventDefault(), Je.detail.originalEvent.type === "focusin" && Ve.current && Je.preventDefault();
    }
  }));
}), $5d3850c4d0b4e6c7$var$DialogContentImpl = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const { __scopeDialog: Fe, trapFocus: Ke, onOpenAutoFocus: Ve, onCloseAutoFocus: Je, ...Qe } = $e, at = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, Fe), ut = useRef(null), lt = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(Ze, ut);
  return $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c(), /* @__PURE__ */ createElement(Fragment, null, /* @__PURE__ */ createElement($d3863c46a17e8a28$export$20e40289641fbbb6, {
    asChild: !0,
    loop: !0,
    trapped: Ke,
    onMountAutoFocus: Ve,
    onUnmountAutoFocus: Je
  }, /* @__PURE__ */ createElement($5cb92bef7577960e$export$177fb62ff3ec1f22, _extends$1({
    role: "dialog",
    id: at.contentId,
    "aria-describedby": at.descriptionId,
    "aria-labelledby": at.titleId,
    "data-state": $5d3850c4d0b4e6c7$var$getState(at.open)
  }, Qe, {
    ref: lt,
    onDismiss: () => at.onOpenChange(!1)
  }))), !1);
}), $5d3850c4d0b4e6c7$var$TITLE_NAME = "DialogTitle", $5d3850c4d0b4e6c7$export$16f7638e4a34b909 = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const { __scopeDialog: Fe, ...Ke } = $e, Ve = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$TITLE_NAME, Fe);
  return /* @__PURE__ */ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.h2, _extends$1({
    id: Ve.titleId
  }, Ke, {
    ref: Ze
  }));
}), $5d3850c4d0b4e6c7$var$CLOSE_NAME = "DialogClose", $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const { __scopeDialog: Fe, ...Ke } = $e, Ve = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CLOSE_NAME, Fe);
  return /* @__PURE__ */ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends$1({
    type: "button"
  }, Ke, {
    ref: Ze,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      $e.onClick,
      () => Ve.onOpenChange(!1)
    )
  }));
});
function $5d3850c4d0b4e6c7$var$getState($e) {
  return $e ? "open" : "closed";
}
const $5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9 = $5d3850c4d0b4e6c7$export$3ddf2d174ce01153, $5d3850c4d0b4e6c7$export$41fb9f06171c75f4 = $5d3850c4d0b4e6c7$export$2e1e1122cf0cba88, $5d3850c4d0b4e6c7$export$c6fdb837b070b4ff = $5d3850c4d0b4e6c7$export$bd1d06c79be19e17, $5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2 = $5d3850c4d0b4e6c7$export$b6d9565de1e068cf, $5d3850c4d0b4e6c7$export$f99233281efd08a0 = $5d3850c4d0b4e6c7$export$16f7638e4a34b909, $5d3850c4d0b4e6c7$export$f39c2d165cd861fe = $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac;
function XMarkIcon({
  title: $e,
  titleId: Ze,
  ...Fe
}, Ke) {
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: Ke,
    "aria-labelledby": Ze
  }, Fe), $e ? /* @__PURE__ */ React.createElement("title", {
    id: Ze
  }, $e) : null, /* @__PURE__ */ React.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M6 18L18 6M6 6l12 12"
  }));
}
const ForwardRef = React.forwardRef(XMarkIcon), XMarkIcon$1 = ForwardRef;
function Modal({
  open: $e,
  onOpenChange: Ze,
  children: Fe
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx($5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9, { open: $e, onOpenChange: Ze, children: Fe });
}
function ModalContent({ title: $e, children: Ze }) {
  var Ke, Ve, Je, Qe, at, ut, lt, dt;
  const {
    theme: { modal: Fe }
  } = useWebchatContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx($5d3850c4d0b4e6c7$export$c6fdb837b070b4ff, { ...Fe == null ? void 0 : Fe.overlay }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...Fe == null ? void 0 : Fe.container, children: /* @__PURE__ */ jsxRuntimeExports.jsxs($5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2, { ...(Ke = Fe == null ? void 0 : Fe.dialog) == null ? void 0 : Ke.container, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ...(Je = (Ve = Fe == null ? void 0 : Fe.dialog) == null ? void 0 : Ve.title) == null ? void 0 : Je.container, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx($5d3850c4d0b4e6c7$export$f99233281efd08a0, { ...(at = (Qe = Fe == null ? void 0 : Fe.dialog) == null ? void 0 : Qe.title) == null ? void 0 : at.text, children: $e }),
        /* @__PURE__ */ jsxRuntimeExports.jsx($5d3850c4d0b4e6c7$export$f39c2d165cd861fe, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(XMarkIcon$1, { role: "button", tabIndex: 0, ...(lt = (ut = Fe == null ? void 0 : Fe.dialog) == null ? void 0 : ut.title) == null ? void 0 : lt.closeIcon }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...(dt = Fe == null ? void 0 : Fe.dialog) == null ? void 0 : dt.content, children: Ze })
    ] }) })
  ] });
}
Modal.Button = $5d3850c4d0b4e6c7$export$41fb9f06171c75f4;
Modal.Close = $5d3850c4d0b4e6c7$export$f39c2d165cd861fe;
Modal.Content = ModalContent;
const Container = forwardRef(({ children: $e, ...Ze }, Fe) => {
  const {
    theme: { container: Ke }
  } = useWebchatContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ...Ze, ...Ke, ref: Fe, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Ie$2, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalProvider, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectionModal, {}),
      $e
    ] })
  ] });
}), ConnectionModal = () => {
  const {
    theme: { modal: $e },
    state: { connected: Ze }
  } = useWebchatContext(), { showModal: Fe } = useModalContext();
  return useEffect(() => {
    var Ke, Ve, Je, Qe;
    Ze || Fe({
      title: "Connection Error",
      content: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { ...(Ve = (Ke = $e == null ? void 0 : $e.dialog) == null ? void 0 : Ke.newConversation) == null ? void 0 : Ve.text, children: "There was an error connecting to the server. Please check your internet connection and try again." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Modal.Close, { asChild: !0, children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { ...(Qe = (Je = $e == null ? void 0 : $e.dialog) == null ? void 0 : Je.newConversation) == null ? void 0 : Qe.button, onClick: () => window.location.reload(), children: "Restart" }) })
      ] })
    });
  }, [Ze]), /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
}, Fab = forwardRef(({ children: $e, onClick: Ze, ...Fe }, Ke) => {
  const {
    theme: { fab: Ve }
  } = useWebchatContext(), { container: Je, icon: Qe } = Ve ?? {};
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...Fe, ...Je, ref: Ke, onClick: Ze, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...Qe }) });
}), $409067139f391064$var$COLLAPSIBLE_NAME = "Collapsible", [$409067139f391064$var$createCollapsibleContext, $409067139f391064$export$952b32dcbe73087a] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($409067139f391064$var$COLLAPSIBLE_NAME), [$409067139f391064$var$CollapsibleProvider, $409067139f391064$var$useCollapsibleContext] = $409067139f391064$var$createCollapsibleContext($409067139f391064$var$COLLAPSIBLE_NAME), $409067139f391064$export$6eb0f7ddcda6131f = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const { __scopeCollapsible: Fe, open: Ke, defaultOpen: Ve, disabled: Je, onOpenChange: Qe, ...at } = $e, [ut = !1, lt] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: Ke,
    defaultProp: Ve,
    onChange: Qe
  });
  return /* @__PURE__ */ createElement($409067139f391064$var$CollapsibleProvider, {
    scope: Fe,
    disabled: Je,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    open: ut,
    onOpenToggle: useCallback(
      () => lt(
        (dt) => !dt
      ),
      [
        lt
      ]
    )
  }, /* @__PURE__ */ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$1({
    "data-state": $409067139f391064$var$getState(ut),
    "data-disabled": Je ? "" : void 0
  }, at, {
    ref: Ze
  })));
}), $409067139f391064$var$TRIGGER_NAME = "CollapsibleTrigger", $409067139f391064$export$c135dce7b15bbbdc = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const { __scopeCollapsible: Fe, ...Ke } = $e, Ve = $409067139f391064$var$useCollapsibleContext($409067139f391064$var$TRIGGER_NAME, Fe);
  return /* @__PURE__ */ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends$1({
    type: "button",
    "aria-controls": Ve.contentId,
    "aria-expanded": Ve.open || !1,
    "data-state": $409067139f391064$var$getState(Ve.open),
    "data-disabled": Ve.disabled ? "" : void 0,
    disabled: Ve.disabled
  }, Ke, {
    ref: Ze,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10($e.onClick, Ve.onOpenToggle)
  }));
}), $409067139f391064$var$CONTENT_NAME = "CollapsibleContent", $409067139f391064$export$aadde00976f34151 = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const { forceMount: Fe, ...Ke } = $e, Ve = $409067139f391064$var$useCollapsibleContext($409067139f391064$var$CONTENT_NAME, $e.__scopeCollapsible);
  return /* @__PURE__ */ createElement(
    $921a889cee6df7e8$export$99c2b779aa4e8b8b,
    {
      present: Fe || Ve.open
    },
    ({ present: Je }) => /* @__PURE__ */ createElement($409067139f391064$var$CollapsibleContentImpl, _extends$1({}, Ke, {
      ref: Ze,
      present: Je
    }))
  );
}), $409067139f391064$var$CollapsibleContentImpl = /* @__PURE__ */ forwardRef(($e, Ze) => {
  const { __scopeCollapsible: Fe, present: Ke, children: Ve, ...Je } = $e, Qe = $409067139f391064$var$useCollapsibleContext($409067139f391064$var$CONTENT_NAME, Fe), [at, ut] = useState(Ke), lt = useRef(null), dt = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(Ze, lt), bt = useRef(0), $t = bt.current, vt = useRef(0), wt = vt.current, xt = Qe.open || at, Et = useRef(xt), Tt = useRef();
  return useEffect(() => {
    const Rt = requestAnimationFrame(
      () => Et.current = !1
    );
    return () => cancelAnimationFrame(Rt);
  }, []), $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    const Rt = lt.current;
    if (Rt) {
      Tt.current = Tt.current || {
        transitionDuration: Rt.style.transitionDuration,
        animationName: Rt.style.animationName
      }, Rt.style.transitionDuration = "0s", Rt.style.animationName = "none";
      const Ct = Rt.getBoundingClientRect();
      bt.current = Ct.height, vt.current = Ct.width, Et.current || (Rt.style.transitionDuration = Tt.current.transitionDuration, Rt.style.animationName = Tt.current.animationName), ut(Ke);
    }
  }, [
    Qe.open,
    Ke
  ]), /* @__PURE__ */ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$1({
    "data-state": $409067139f391064$var$getState(Qe.open),
    "data-disabled": Qe.disabled ? "" : void 0,
    id: Qe.contentId,
    hidden: !xt
  }, Je, {
    ref: dt,
    style: {
      ["--radix-collapsible-content-height"]: $t ? `${$t}px` : void 0,
      ["--radix-collapsible-content-width"]: wt ? `${wt}px` : void 0,
      ...$e.style
    }
  }), xt && Ve);
});
function $409067139f391064$var$getState($e) {
  return $e ? "open" : "closed";
}
const $409067139f391064$export$be92b6f5f03c0fe9 = $409067139f391064$export$6eb0f7ddcda6131f, $409067139f391064$export$41fb9f06171c75f4 = $409067139f391064$export$c135dce7b15bbbdc, $409067139f391064$export$7c6e2c02157bb7d2 = $409067139f391064$export$aadde00976f34151, SvgShare04 = ($e) => /* @__PURE__ */ React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none", viewBox: "0 0 16 16", ...$e }, /* @__PURE__ */ React.createElement("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", d: "M15.5 5.5v-5m0 0h-5m5 0L8.833 7.167m-2.5-5H4.5c-1.4 0-2.1 0-2.635.272A2.5 2.5 0 0 0 .772 3.532C.5 4.066.5 4.767.5 6.167V11.5c0 1.4 0 2.1.272 2.635a2.5 2.5 0 0 0 1.093 1.092C2.4 15.5 3.1 15.5 4.5 15.5h5.333c1.4 0 2.1 0 2.635-.273a2.5 2.5 0 0 0 1.093-1.092c.272-.535.272-1.235.272-2.635V9.667" })), Header = memo(
  forwardRef(($e, Ze) => {
    const {
      theme: { header: Fe }
    } = useWebchatContext(), [Ke, Ve] = useState(!1);
    return /* @__PURE__ */ jsxRuntimeExports.jsx($409067139f391064$export$be92b6f5f03c0fe9, { ...$e, ...Fe == null ? void 0 : Fe.container, open: Ke, onOpenChange: Ve, ref: Ze });
  })
), Content = forwardRef(($e, Ze) => {
  var Ke;
  const {
    theme: { header: Fe }
  } = useWebchatContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx($409067139f391064$export$41fb9f06171c75f4, { ...$e, ...(Ke = Fe == null ? void 0 : Fe.content) == null ? void 0 : Ke.container, ref: Ze });
}), ExpandedContent = forwardRef(($e, Ze) => {
  var Ke;
  const {
    theme: { header: Fe }
  } = useWebchatContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx($409067139f391064$export$7c6e2c02157bb7d2, { ...$e, ...(Ke = Fe == null ? void 0 : Fe.expandedContent) == null ? void 0 : Ke.container, ref: Ze });
}), HeaderAvatar = forwardRef(({ src: $e, children: Ze }, Fe) => {
  var Je;
  const {
    theme: { header: Ke },
    client: Ve
  } = useWebchatContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { ref: Fe, userId: Ve == null ? void 0 : Ve.clientId, children: Ze, src: $e, ...(Je = Ke == null ? void 0 : Ke.content) == null ? void 0 : Je.avatar });
}), Title = forwardRef(($e, Ze) => {
  var Ke;
  const {
    theme: { header: Fe }
  } = useWebchatContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { ...$e, ...(Ke = Fe == null ? void 0 : Fe.content) == null ? void 0 : Ke.title, ref: Ze });
}), Description = forwardRef(($e, Ze) => {
  var Ke;
  const {
    theme: { header: Fe }
  } = useWebchatContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { ...$e, ...(Ke = Fe == null ? void 0 : Fe.content) == null ? void 0 : Ke.description, ref: Ze });
}), Actions = forwardRef(($e, Ze) => {
  var Ke, Ve;
  const {
    theme: { header: Fe }
  } = useWebchatContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...$e, ...(Ve = (Ke = Fe == null ? void 0 : Fe.content) == null ? void 0 : Ke.actions) == null ? void 0 : Ve.container, ref: Ze });
}), DescriptionItem = ({ icon: $e, title: Ze, link: Fe, ...Ke }) => {
  var at, ut, lt, dt, bt, $t, vt, wt, xt, Et, Tt, Rt;
  const {
    theme: { header: Ve }
  } = useWebchatContext(), Je = $e ?? SvgShare04, Qe = (Ct) => {
    Ct && copyToClipboard(Ct);
  };
  return !Fe && !Ze ? null : Fe ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "a",
    {
      ...Ke,
      ...(ut = (at = Ve == null ? void 0 : Ve.expandedContent) == null ? void 0 : at.descriptionItems) == null ? void 0 : ut.container,
      href: Fe,
      target: "_blank",
      rel: "noopener",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Je, { ...(dt = (lt = Ve == null ? void 0 : Ve.expandedContent) == null ? void 0 : lt.descriptionItems) == null ? void 0 : dt.icon }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { ...($t = (bt = Ve == null ? void 0 : Ve.expandedContent) == null ? void 0 : bt.descriptionItems) == null ? void 0 : $t.link, children: Ze })
      ]
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      ...Ke,
      ...(wt = (vt = Ve == null ? void 0 : Ve.expandedContent) == null ? void 0 : vt.descriptionItems) == null ? void 0 : wt.container,
      onClick: (Ct) => {
        Qe(Ct.currentTarget.textContent);
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Je, { ...(Et = (xt = Ve == null ? void 0 : Ve.expandedContent) == null ? void 0 : xt.descriptionItems) == null ? void 0 : Et.icon }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { ...(Rt = (Tt = Ve == null ? void 0 : Ve.expandedContent) == null ? void 0 : Tt.descriptionItems) == null ? void 0 : Rt.text, children: Ze })
      ]
    }
  );
}, HeaderNamespace = Object.assign(Header, {
  Content,
  ExpandedContent,
  Avatar: HeaderAvatar,
  Description,
  Title,
  Actions,
  DescriptionItem
}), LoadingIndicator = memo(({ ...$e }) => {
  const {
    theme: { loadingIndicator: Ze }
  } = useWebchatContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...$e, ...Ze == null ? void 0 : Ze.container, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...Ze == null ? void 0 : Ze.loader }) });
}), Message = forwardRef(
  ({ direction: $e, block: Ze, scroll: Fe, disableInput: Ke, children: Ve, sender: Je, ...Qe }, at) => {
    var xt, Et, Tt, Rt;
    const [ut, lt] = useState([]), {
      theme: { message: dt },
      configuration: { botAvatar: bt, botName: $t },
      client: vt
    } = useWebchatContext();
    useMount$1(() => {
      Fe();
    }), useEffect(() => {
      ut.length === 0 && Fe();
    }, [ut.length]);
    const wt = hashStringToInt((vt == null ? void 0 : vt.clientId) ?? "", 15);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MessageContext.Provider, { value: { isLoading: ut, setIsLoading: lt }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        ...Qe,
        ...dt == null ? void 0 : dt.container,
        "data-loaded": ut.length === 0,
        "data-disable-input": !!Ke,
        "data-direction": $e,
        ref: at,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs($cddcb0b647441e34$export$e2255cf6045e8d47, { "data-color": wt, ...(xt = dt == null ? void 0 : dt.avatar) == null ? void 0 : xt.container, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx($cddcb0b647441e34$export$2cd8ae1985206fe8, { ...(Et = dt == null ? void 0 : dt.avatar) == null ? void 0 : Et.image, src: (Je == null ? void 0 : Je.avatar) ?? bt }),
            /* @__PURE__ */ jsxRuntimeExports.jsx($cddcb0b647441e34$export$69fffb6a9571fbfe, { ...(Tt = dt == null ? void 0 : dt.avatar) == null ? void 0 : Tt.fallback, children: (Je == null ? void 0 : Je.name[0]) ?? ((Rt = $t ?? "Bot") == null ? void 0 : Rt[0]) })
          ] }),
          Ze && /* @__PURE__ */ jsxRuntimeExports.jsx(Block, { block: Ze, styles: dt == null ? void 0 : dt.blocks }),
          Ve
        ]
      }
    ) });
  }
);
var dayjs_min = { exports: {} };
(function($e, Ze) {
  (function(Fe, Ke) {
    $e.exports = Ke();
  })(commonjsGlobal, function() {
    var Fe = 1e3, Ke = 6e4, Ve = 36e5, Je = "millisecond", Qe = "second", at = "minute", ut = "hour", lt = "day", dt = "week", bt = "month", $t = "quarter", vt = "year", wt = "date", xt = "Invalid Date", Et = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, Tt = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, Rt = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(ot) {
      var ft = ["th", "st", "nd", "rd"], mt = ot % 100;
      return "[" + ot + (ft[(mt - 20) % 10] || ft[mt] || ft[0]) + "]";
    } }, Ct = function(ot, ft, mt) {
      var yt = String(ot);
      return !yt || yt.length >= ft ? ot : "" + Array(ft + 1 - yt.length).join(mt) + ot;
    }, Zt = { s: Ct, z: function(ot) {
      var ft = -ot.utcOffset(), mt = Math.abs(ft), yt = Math.floor(mt / 60), pt = mt % 60;
      return (ft <= 0 ? "+" : "-") + Ct(yt, 2, "0") + ":" + Ct(pt, 2, "0");
    }, m: function ot(ft, mt) {
      if (ft.date() < mt.date())
        return -ot(mt, ft);
      var yt = 12 * (mt.year() - ft.year()) + (mt.month() - ft.month()), pt = ft.clone().add(yt, bt), Ge = mt - pt < 0, ct = ft.clone().add(yt + (Ge ? -1 : 1), bt);
      return +(-(yt + (mt - pt) / (Ge ? pt - ct : ct - pt)) || 0);
    }, a: function(ot) {
      return ot < 0 ? Math.ceil(ot) || 0 : Math.floor(ot);
    }, p: function(ot) {
      return { M: bt, y: vt, w: dt, d: lt, D: wt, h: ut, m: at, s: Qe, ms: Je, Q: $t }[ot] || String(ot || "").toLowerCase().replace(/s$/, "");
    }, u: function(ot) {
      return ot === void 0;
    } }, Lt = "en", Ut = {};
    Ut[Lt] = Rt;
    var Pt = "$isDayjsObject", Ot = function(ot) {
      return ot instanceof Xe || !(!ot || !ot[Pt]);
    }, Ft = function ot(ft, mt, yt) {
      var pt;
      if (!ft)
        return Lt;
      if (typeof ft == "string") {
        var Ge = ft.toLowerCase();
        Ut[Ge] && (pt = Ge), mt && (Ut[Ge] = mt, pt = Ge);
        var ct = ft.split("-");
        if (!pt && ct.length > 1)
          return ot(ct[0]);
      } else {
        var Mt = ft.name;
        Ut[Mt] = ft, pt = Mt;
      }
      return !yt && pt && (Lt = pt), pt || !yt && Lt;
    }, gt = function(ot, ft) {
      if (Ot(ot))
        return ot.clone();
      var mt = typeof ft == "object" ? ft : {};
      return mt.date = ot, mt.args = arguments, new Xe(mt);
    }, We = Zt;
    We.l = Ft, We.i = Ot, We.w = function(ot, ft) {
      return gt(ot, { locale: ft.$L, utc: ft.$u, x: ft.$x, $offset: ft.$offset });
    };
    var Xe = function() {
      function ot(mt) {
        this.$L = Ft(mt.locale, null, !0), this.parse(mt), this.$x = this.$x || mt.x || {}, this[Pt] = !0;
      }
      var ft = ot.prototype;
      return ft.parse = function(mt) {
        this.$d = function(yt) {
          var pt = yt.date, Ge = yt.utc;
          if (pt === null)
            return /* @__PURE__ */ new Date(NaN);
          if (We.u(pt))
            return /* @__PURE__ */ new Date();
          if (pt instanceof Date)
            return new Date(pt);
          if (typeof pt == "string" && !/Z$/i.test(pt)) {
            var ct = pt.match(Et);
            if (ct) {
              var Mt = ct[2] - 1 || 0, St = (ct[7] || "0").substring(0, 3);
              return Ge ? new Date(Date.UTC(ct[1], Mt, ct[3] || 1, ct[4] || 0, ct[5] || 0, ct[6] || 0, St)) : new Date(ct[1], Mt, ct[3] || 1, ct[4] || 0, ct[5] || 0, ct[6] || 0, St);
            }
          }
          return new Date(pt);
        }(mt), this.init();
      }, ft.init = function() {
        var mt = this.$d;
        this.$y = mt.getFullYear(), this.$M = mt.getMonth(), this.$D = mt.getDate(), this.$W = mt.getDay(), this.$H = mt.getHours(), this.$m = mt.getMinutes(), this.$s = mt.getSeconds(), this.$ms = mt.getMilliseconds();
      }, ft.$utils = function() {
        return We;
      }, ft.isValid = function() {
        return this.$d.toString() !== xt;
      }, ft.isSame = function(mt, yt) {
        var pt = gt(mt);
        return this.startOf(yt) <= pt && pt <= this.endOf(yt);
      }, ft.isAfter = function(mt, yt) {
        return gt(mt) < this.startOf(yt);
      }, ft.isBefore = function(mt, yt) {
        return this.endOf(yt) < gt(mt);
      }, ft.$g = function(mt, yt, pt) {
        return We.u(mt) ? this[yt] : this.set(pt, mt);
      }, ft.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, ft.valueOf = function() {
        return this.$d.getTime();
      }, ft.startOf = function(mt, yt) {
        var pt = this, Ge = !!We.u(yt) || yt, ct = We.p(mt), Mt = function(Kt, ur) {
          var er = We.w(pt.$u ? Date.UTC(pt.$y, ur, Kt) : new Date(pt.$y, ur, Kt), pt);
          return Ge ? er : er.endOf(lt);
        }, St = function(Kt, ur) {
          return We.w(pt.toDate()[Kt].apply(pt.toDate("s"), (Ge ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(ur)), pt);
        }, At = this.$W, Nt = this.$M, qt = this.$D, Qt = "set" + (this.$u ? "UTC" : "");
        switch (ct) {
          case vt:
            return Ge ? Mt(1, 0) : Mt(31, 11);
          case bt:
            return Ge ? Mt(1, Nt) : Mt(0, Nt + 1);
          case dt:
            var Xt = this.$locale().weekStart || 0, zt = (At < Xt ? At + 7 : At) - Xt;
            return Mt(Ge ? qt - zt : qt + (6 - zt), Nt);
          case lt:
          case wt:
            return St(Qt + "Hours", 0);
          case ut:
            return St(Qt + "Minutes", 1);
          case at:
            return St(Qt + "Seconds", 2);
          case Qe:
            return St(Qt + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, ft.endOf = function(mt) {
        return this.startOf(mt, !1);
      }, ft.$set = function(mt, yt) {
        var pt, Ge = We.p(mt), ct = "set" + (this.$u ? "UTC" : ""), Mt = (pt = {}, pt[lt] = ct + "Date", pt[wt] = ct + "Date", pt[bt] = ct + "Month", pt[vt] = ct + "FullYear", pt[ut] = ct + "Hours", pt[at] = ct + "Minutes", pt[Qe] = ct + "Seconds", pt[Je] = ct + "Milliseconds", pt)[Ge], St = Ge === lt ? this.$D + (yt - this.$W) : yt;
        if (Ge === bt || Ge === vt) {
          var At = this.clone().set(wt, 1);
          At.$d[Mt](St), At.init(), this.$d = At.set(wt, Math.min(this.$D, At.daysInMonth())).$d;
        } else
          Mt && this.$d[Mt](St);
        return this.init(), this;
      }, ft.set = function(mt, yt) {
        return this.clone().$set(mt, yt);
      }, ft.get = function(mt) {
        return this[We.p(mt)]();
      }, ft.add = function(mt, yt) {
        var pt, Ge = this;
        mt = Number(mt);
        var ct = We.p(yt), Mt = function(Nt) {
          var qt = gt(Ge);
          return We.w(qt.date(qt.date() + Math.round(Nt * mt)), Ge);
        };
        if (ct === bt)
          return this.set(bt, this.$M + mt);
        if (ct === vt)
          return this.set(vt, this.$y + mt);
        if (ct === lt)
          return Mt(1);
        if (ct === dt)
          return Mt(7);
        var St = (pt = {}, pt[at] = Ke, pt[ut] = Ve, pt[Qe] = Fe, pt)[ct] || 1, At = this.$d.getTime() + mt * St;
        return We.w(At, this);
      }, ft.subtract = function(mt, yt) {
        return this.add(-1 * mt, yt);
      }, ft.format = function(mt) {
        var yt = this, pt = this.$locale();
        if (!this.isValid())
          return pt.invalidDate || xt;
        var Ge = mt || "YYYY-MM-DDTHH:mm:ssZ", ct = We.z(this), Mt = this.$H, St = this.$m, At = this.$M, Nt = pt.weekdays, qt = pt.months, Qt = pt.meridiem, Xt = function(ur, er, Dt, Ht) {
          return ur && (ur[er] || ur(yt, Ge)) || Dt[er].slice(0, Ht);
        }, zt = function(ur) {
          return We.s(Mt % 12 || 12, ur, "0");
        }, Kt = Qt || function(ur, er, Dt) {
          var Ht = ur < 12 ? "AM" : "PM";
          return Dt ? Ht.toLowerCase() : Ht;
        };
        return Ge.replace(Tt, function(ur, er) {
          return er || function(Dt) {
            switch (Dt) {
              case "YY":
                return String(yt.$y).slice(-2);
              case "YYYY":
                return We.s(yt.$y, 4, "0");
              case "M":
                return At + 1;
              case "MM":
                return We.s(At + 1, 2, "0");
              case "MMM":
                return Xt(pt.monthsShort, At, qt, 3);
              case "MMMM":
                return Xt(qt, At);
              case "D":
                return yt.$D;
              case "DD":
                return We.s(yt.$D, 2, "0");
              case "d":
                return String(yt.$W);
              case "dd":
                return Xt(pt.weekdaysMin, yt.$W, Nt, 2);
              case "ddd":
                return Xt(pt.weekdaysShort, yt.$W, Nt, 3);
              case "dddd":
                return Nt[yt.$W];
              case "H":
                return String(Mt);
              case "HH":
                return We.s(Mt, 2, "0");
              case "h":
                return zt(1);
              case "hh":
                return zt(2);
              case "a":
                return Kt(Mt, St, !0);
              case "A":
                return Kt(Mt, St, !1);
              case "m":
                return String(St);
              case "mm":
                return We.s(St, 2, "0");
              case "s":
                return String(yt.$s);
              case "ss":
                return We.s(yt.$s, 2, "0");
              case "SSS":
                return We.s(yt.$ms, 3, "0");
              case "Z":
                return ct;
            }
            return null;
          }(ur) || ct.replace(":", "");
        });
      }, ft.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, ft.diff = function(mt, yt, pt) {
        var Ge, ct = this, Mt = We.p(yt), St = gt(mt), At = (St.utcOffset() - this.utcOffset()) * Ke, Nt = this - St, qt = function() {
          return We.m(ct, St);
        };
        switch (Mt) {
          case vt:
            Ge = qt() / 12;
            break;
          case bt:
            Ge = qt();
            break;
          case $t:
            Ge = qt() / 3;
            break;
          case dt:
            Ge = (Nt - At) / 6048e5;
            break;
          case lt:
            Ge = (Nt - At) / 864e5;
            break;
          case ut:
            Ge = Nt / Ve;
            break;
          case at:
            Ge = Nt / Ke;
            break;
          case Qe:
            Ge = Nt / Fe;
            break;
          default:
            Ge = Nt;
        }
        return pt ? Ge : We.a(Ge);
      }, ft.daysInMonth = function() {
        return this.endOf(bt).$D;
      }, ft.$locale = function() {
        return Ut[this.$L];
      }, ft.locale = function(mt, yt) {
        if (!mt)
          return this.$L;
        var pt = this.clone(), Ge = Ft(mt, yt, !0);
        return Ge && (pt.$L = Ge), pt;
      }, ft.clone = function() {
        return We.w(this.$d, this);
      }, ft.toDate = function() {
        return new Date(this.valueOf());
      }, ft.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, ft.toISOString = function() {
        return this.$d.toISOString();
      }, ft.toString = function() {
        return this.$d.toUTCString();
      }, ot;
    }(), rt = Xe.prototype;
    return gt.prototype = rt, [["$ms", Je], ["$s", Qe], ["$m", at], ["$H", ut], ["$W", lt], ["$M", bt], ["$y", vt], ["$D", wt]].forEach(function(ot) {
      rt[ot[1]] = function(ft) {
        return this.$g(ft, ot[0], ot[1]);
      };
    }), gt.extend = function(ot, ft) {
      return ot.$i || (ot(ft, Xe, gt), ot.$i = !0), gt;
    }, gt.locale = Ft, gt.isDayjs = Ot, gt.unix = function(ot) {
      return gt(1e3 * ot);
    }, gt.en = Ut[Lt], gt.Ls = Ut, gt.p = {}, gt;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
var isToday$1 = { exports: {} };
(function($e, Ze) {
  (function(Fe, Ke) {
    $e.exports = Ke();
  })(commonjsGlobal, function() {
    return function(Fe, Ke, Ve) {
      Ke.prototype.isToday = function() {
        var Je = "YYYY-MM-DD", Qe = Ve();
        return this.format(Je) === Qe.format(Je);
      };
    };
  });
})(isToday$1);
var isTodayExports = isToday$1.exports;
const isToday = /* @__PURE__ */ getDefaultExportFromCjs(isTodayExports);
var isYesterday$1 = { exports: {} };
(function($e, Ze) {
  (function(Fe, Ke) {
    $e.exports = Ke();
  })(commonjsGlobal, function() {
    return function(Fe, Ke, Ve) {
      Ke.prototype.isYesterday = function() {
        var Je = "YYYY-MM-DD", Qe = Ve().subtract(1, "day");
        return this.format(Je) === Qe.format(Je);
      };
    };
  });
})(isYesterday$1);
var isYesterdayExports = isYesterday$1.exports;
const isYesterday = /* @__PURE__ */ getDefaultExportFromCjs(isYesterdayExports);
dayjs.extend(isToday);
dayjs.extend(isYesterday);
function withDateSystemMessages($e, Ze = "day") {
  if (!$e || $e.length === 0)
    return [];
  const Fe = [];
  Fe.push(getDateSystemMessage($e[0].timestamp));
  for (let Ke = 0; Ke < $e.length; Ke++)
    if (Fe.push($e[Ke]), Ke + 1 < $e.length) {
      const Ve = $e[Ke].timestamp, Je = $e[Ke + 1].timestamp;
      dayjs(Ve).isSame(Je, Ze) || Fe.push(getDateSystemMessage(Je));
    }
  return Fe;
}
function getDateSystemMessage($e) {
  return {
    direction: "system",
    sender: { name: "system" },
    timestamp: $e,
    block: {
      type: "text",
      text: humanizeTimestamp($e)
    }
  };
}
function humanizeTimestamp($e, Ze = !1) {
  const Fe = dayjs($e), Ke = "h:mma";
  return Fe.isToday() ? Ze ? `Today • ${Fe.format(Ke)}` : "Today" : Fe.isYesterday() ? Ze ? `Yesterday • ${Fe.format(Ke)}` : "Yesterday" : Ze ? Fe.format(`YYYY-MM-DD • ${Ke}`) : Fe.format("YYYY-MM-DD");
}
const TYPING_DELAY_MS = 10 * 1e3, MessageList = memo(({ scrollDownButton: $e, ...Ze }) => {
  var Rt, Ct, Zt, Lt, Ut, Pt, Ot, Ft;
  const {
    configuration: Fe,
    theme: { messageList: Ke }
  } = useWebchatContext(), { messages: Ve, setState: Je, client: Qe } = useWebchatContext(), at = useMemo(() => withDateSystemMessages(Ve), [Ve]), [ut, lt] = useState(!0), dt = useRef(null), { y: bt } = useScroll$1(dt), [$t, vt] = useState(!1), [wt, xt] = useRefresh(), Et = () => {
    if (!dt.current)
      return;
    const { scrollHeight: gt } = dt.current;
    ut && dt.current.scrollTo({ top: gt });
  };
  useEffect(() => {
    const gt = new Date(Date.now() - TYPING_DELAY_MS + 2e3);
    Ve.length > 0 && Ve[Ve.length - 1].timestamp < gt && vt(!1);
  }, [wt]), useEffectOnce$1(() => Qe == null ? void 0 : Qe.on("messageSent", () => {
    vt(!0), xt(new Date(Date.now() + TYPING_DELAY_MS));
  })), useEffectOnce$1(() => Qe == null ? void 0 : Qe.on("message", () => {
    vt(!1);
  })), useEffect(() => {
    const gt = Ve[Ve.length - 1];
    Je({ disableComposer: !!(gt != null && gt.disableInput) });
  }, [Ve.length]), useEffect(() => {
    if (!dt.current)
      return;
    const { offsetHeight: gt, scrollHeight: We, scrollTop: Xe } = dt.current;
    lt(We <= Xe + gt + 100);
  }, [bt]);
  const Tt = $e != null && $e.icon ? $e == null ? void 0 : $e.icon : ArrowDownIcon$1;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { ...Ze, ...Ke == null ? void 0 : Ke.container, ref: dt, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("li", { ...(Rt = Ke == null ? void 0 : Ke.scrollDownButton) == null ? void 0 : Rt.container, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        "data-is-at-bottom": ut,
        ...(Ct = Ke == null ? void 0 : Ke.scrollDownButton) == null ? void 0 : Ct.button,
        onClick: () => {
          var gt, We;
          return (We = dt.current) == null ? void 0 : We.scrollBy({ top: (gt = dt.current) == null ? void 0 : gt.scrollHeight });
        },
        children: [
          ($e == null ? void 0 : $e.text) ?? "Back",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tt, { ...(Zt = Ke == null ? void 0 : Ke.scrollDownButton) == null ? void 0 : Zt.icon })
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { ...(Lt = Ke == null ? void 0 : Ke.marquee) == null ? void 0 : Lt.container, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { userId: Qe == null ? void 0 : Qe.clientId, src: Fe.botAvatar, ...(Ut = Ke == null ? void 0 : Ke.marquee) == null ? void 0 : Ut.avatar, children: (Fe.botName || "Bot").slice(0, 1) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ...(Pt = Ke == null ? void 0 : Ke.marquee) == null ? void 0 : Pt.content, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { ...(Ot = Ke == null ? void 0 : Ke.marquee) == null ? void 0 : Ot.title, children: Fe.botName || "Bot" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { ...(Ft = Ke == null ? void 0 : Ke.marquee) == null ? void 0 : Ft.description, children: Fe.botDescription })
      ] })
    ] }),
    at.map((gt, We) => /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { scroll: Et, ...gt }, We)),
    $t && /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { scroll: Et, direction: "incoming", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingIndicator, {}) })
  ] });
}), RestartConversation = ({ ...$e }) => {
  var Qe, at;
  const {
    theme: { header: Ze, modal: Fe },
    client: Ke
  } = useWebchatContext(), { showModal: Ve } = useModalContext(), Je = (ut) => {
    var lt, dt, bt, $t;
    ut.stopPropagation(), Ve({
      title: "Restart Conversation",
      content: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { ...(dt = (lt = Fe == null ? void 0 : Fe.dialog) == null ? void 0 : lt.newConversation) == null ? void 0 : dt.text, children: "Are you sure you want to restart a new conversation?" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Modal.Close, { asChild: !0, children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { ...($t = (bt = Fe == null ? void 0 : Fe.dialog) == null ? void 0 : bt.newConversation) == null ? void 0 : $t.button, onClick: Ke == null ? void 0 : Ke.restartConversation, children: "Restart" }) })
      ] })
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ArrowPathIcon$1,
    {
      ...$e,
      ...(at = (Qe = Ze == null ? void 0 : Ze.content) == null ? void 0 : Qe.actions) == null ? void 0 : at.icons,
      role: "button",
      tabIndex: 0,
      onClick: Je,
      onKeyDown: (ut) => {
        ut.key === "Enter" && Je(ut);
      }
    }
  );
}, Webchat = () => {
  var Ze, Fe, Ke, Ve, Je, Qe, at, ut, lt, dt;
  const { configuration: $e } = useWebchatContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(HeaderNamespace, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(HeaderNamespace.Content, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(HeaderNamespace.Avatar, { src: $e.botAvatar, children: $e.botName || "Bot" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(HeaderNamespace.Title, { children: $e.botName || "Bot" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(HeaderNamespace.Description, { children: $e.botDescription }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(HeaderNamespace.Actions, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(RestartConversation, {}) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(HeaderNamespace.ExpandedContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          HeaderNamespace.DescriptionItem,
          {
            "data-email": "",
            icon: EnvelopeIcon$1,
            title: (Ze = $e.email) == null ? void 0 : Ze.title,
            link: (Fe = $e.email) == null ? void 0 : Fe.link
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          HeaderNamespace.DescriptionItem,
          {
            "data-phone": "",
            icon: PhoneIcon$1,
            title: (Ke = $e.phone) == null ? void 0 : Ke.title,
            link: (Ve = $e.phone) == null ? void 0 : Ve.link
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          HeaderNamespace.DescriptionItem,
          {
            "data-website": "",
            link: (Je = $e.website) == null ? void 0 : Je.link,
            icon: GlobeAltIcon$1,
            title: (Qe = $e.website) == null ? void 0 : Qe.title
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          HeaderNamespace.DescriptionItem,
          {
            "data-terms": "",
            link: (at = $e.termsOfService) == null ? void 0 : at.link,
            icon: DocumentTextIcon$1,
            title: (ut = $e.termsOfService) == null ? void 0 : ut.title
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          HeaderNamespace.DescriptionItem,
          {
            "data-privacy": "",
            link: (lt = $e.privacyPolicy) == null ? void 0 : lt.link,
            icon: LockClosedIcon$1,
            title: (dt = $e.privacyPolicy) == null ? void 0 : dt.title
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(MessageList, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Composer, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ComposerInput, { placeholder: $e.composerPlaceholder || "Type your message" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ComposerButton, {})
    ] })
  ] });
}, blockTypes = [
  "button",
  "text",
  "image",
  "audio",
  "video",
  "file",
  "location",
  "column",
  "row",
  "bubble",
  "carousel",
  "dropdown"
], markdownTypes = [
  "heading1",
  "heading2",
  "heading3",
  "text",
  "horizontalRule",
  "link",
  "italic",
  "bold",
  "orderedList",
  "unorderedList",
  "listItem",
  "lineBreak",
  "pre"
];
let active;
function toClassName($e) {
  return [
    ...$e.v,
    ($e.i ? "!" : "") + $e.n
  ].join(":");
}
function format($e, Ze = ",") {
  return $e.map(toClassName).join(Ze);
}
let escape$1 = typeof CSS < "u" && CSS.escape || // Simplified: escaping only special characters
// Needed for NodeJS and Edge <79 (https://caniuse.com/mdn-api_css_escape)
(($e) => $e.replace(/[!"'`*+.,;:\\/<=>?@#$%&^|~()[\]{}]/g, "\\$&").replace(/^\d/, "\\3$& "));
function hash($e) {
  for (var Ze = 9, Fe = $e.length; Fe--; )
    Ze = Math.imul(Ze ^ $e.charCodeAt(Fe), 1597334677);
  return "#" + ((Ze ^ Ze >>> 9) >>> 0).toString(36);
}
function mql($e, Ze = "@media ") {
  return Ze + asArray($e).map((Fe) => (typeof Fe == "string" && (Fe = {
    min: Fe
  }), Fe.raw || Object.keys(Fe).map((Ke) => `(${Ke}-width:${Fe[Ke]})`).join(" and "))).join(",");
}
function asArray($e = []) {
  return Array.isArray($e) ? $e : $e == null ? [] : [
    $e
  ];
}
function identity$1($e) {
  return $e;
}
function noop() {
}
let Layer = {
  /**
  * 1. `default` (public)
  */
  d: (
    /* efaults */
    0
  ),
  /* Shifts.layer */
  /**
  * 2. `base` (public) — for things like reset rules or default styles applied to plain HTML elements.
  */
  b: (
    /* ase */
    134217728
  ),
  /* Shifts.layer */
  /**
  * 3. `components` (public, used by `style()`) — is for class-based styles that you want to be able to override with utilities.
  */
  c: (
    /* omponents */
    268435456
  ),
  /* Shifts.layer */
  // reserved for style():
  // - props: 0b011
  // - when: 0b100
  /**
  * 6. `aliases` (public, used by `apply()`) — `~(...)`
  */
  a: (
    /* liases */
    671088640
  ),
  /* Shifts.layer */
  /**
  * 6. `utilities` (public) — for small, single-purpose classes
  */
  u: (
    /* tilities */
    805306368
  ),
  /* Shifts.layer */
  /**
  * 7. `overrides` (public, used by `css()`)
  */
  o: (
    /* verrides */
    939524096
  )
};
function seperatorPrecedence($e) {
  var Ze;
  return ((Ze = $e.match(/[-=:;]/g)) == null ? void 0 : Ze.length) || 0;
}
function atRulePrecedence($e) {
  return Math.min(/(?:^|width[^\d]+)(\d+(?:.\d+)?)(p)?/.test($e) ? Math.max(0, 29.63 * (+RegExp.$1 / (RegExp.$2 ? 15 : 1)) ** 0.137 - 43) : 0, 15) << 22 | /* Shifts.responsive */
  Math.min(seperatorPrecedence($e), 15) << 18;
}
let PRECEDENCES_BY_PSEUDO_CLASS = [
  /* fi */
  "rst-c",
  /* hild: 0 */
  /* la */
  "st-ch",
  /* ild: 1 */
  // even and odd use: nth-child
  /* nt */
  "h-chi",
  /* ld: 2 */
  /* an */
  "y-lin",
  /* k: 3 */
  /* li */
  "nk",
  /* : 4 */
  /* vi */
  "sited",
  /* : 5 */
  /* ch */
  "ecked",
  /* : 6 */
  /* em */
  "pty",
  /* : 7 */
  /* re */
  "ad-on",
  /* ly: 8 */
  /* fo */
  "cus-w",
  /* ithin : 9 */
  /* ho */
  "ver",
  /* : 10 */
  /* fo */
  "cus",
  /* : 11 */
  /* fo */
  "cus-v",
  /* isible : 12 */
  /* ac */
  "tive",
  /* : 13 */
  /* di */
  "sable",
  /* d : 14 */
  /* op */
  "tiona",
  /* l: 15 */
  /* re */
  "quire"
];
function convert({ n: $e, i: Ze, v: Fe = [] }, Ke, Ve, Je) {
  $e && ($e = toClassName({
    n: $e,
    i: Ze,
    v: Fe
  })), Je = [
    ...asArray(Je)
  ];
  for (let at of Fe) {
    let ut = Ke.theme("screens", at);
    for (let lt of asArray(ut && mql(ut) || Ke.v(at))) {
      var Qe;
      Je.push(lt), Ve |= ut ? 67108864 | /* Shifts.screens */
      atRulePrecedence(lt) : at == "dark" ? 1073741824 : (
        /* Shifts.darkMode */
        lt[0] == "@" ? atRulePrecedence(lt) : (Qe = lt, // use first found pseudo-class
        1 << ~(/:([a-z-]+)/.test(Qe) && ~PRECEDENCES_BY_PSEUDO_CLASS.indexOf(RegExp.$1.slice(2, 7)) || -18))
      );
    }
  }
  return {
    n: $e,
    p: Ve,
    r: Je,
    i: Ze
  };
}
let registry = /* @__PURE__ */ new Map();
function stringify$1($e) {
  if ($e.d) {
    let Ze = [], Fe = replaceEach(
      // merge all conditions into a selector string
      $e.r.reduce((Ke, Ve) => Ve[0] == "@" ? (Ze.push(Ve), Ke) : (
        // Go over the selector and replace the matching multiple selectors if any
        Ve ? replaceEach(Ke, (Je) => replaceEach(
          Ve,
          // If the current condition has a nested selector replace it
          (Qe) => {
            let at = /(:merge\(.+?\))(:[a-z-]+|\\[.+])/.exec(Qe);
            if (at) {
              let ut = Je.indexOf(at[1]);
              return ~ut ? (
                // [':merge(.group):hover .rule', ':merge(.group):focus &'] -> ':merge(.group):focus:hover .rule'
                // ':merge(.group)' + ':focus' + ':hover .rule'
                Je.slice(0, ut) + at[0] + Je.slice(ut + at[1].length)
              ) : (
                // [':merge(.peer):focus~&', ':merge(.group):hover &'] -> ':merge(.peer):focus~:merge(.group):hover &'
                replaceReference(Je, Qe)
              );
            }
            return replaceReference(Qe, Je);
          }
        )) : Ke
      ), "&"),
      // replace '&' with rule name or an empty string
      (Ke) => replaceReference(Ke, $e.n ? "." + escape$1($e.n) : "")
    );
    return Fe && Ze.push(Fe.replace(/:merge\((.+?)\)/g, "$1")), Ze.reduceRight((Ke, Ve) => Ve + "{" + Ke + "}", $e.d);
  }
}
function replaceEach($e, Ze) {
  return $e.replace(/ *((?:\(.+?\)|\[.+?\]|[^,])+) *(,|$)/g, (Fe, Ke, Ve) => Ze(Ke) + Ve);
}
function replaceReference($e, Ze) {
  return $e.replace(/&/g, Ze);
}
let collator = new Intl.Collator("en", {
  numeric: !0
});
function sortedInsertionIndex($e, Ze) {
  for (var Fe = 0, Ke = $e.length; Fe < Ke; ) {
    let Ve = Ke + Fe >> 1;
    0 >= compareTwindRules($e[Ve], Ze) ? Fe = Ve + 1 : Ke = Ve;
  }
  return Ke;
}
function compareTwindRules($e, Ze) {
  let Fe = $e.p & Layer.o;
  return Fe == (Ze.p & Layer.o) && (Fe == Layer.b || Fe == Layer.o) ? 0 : $e.p - Ze.p || $e.o - Ze.o || collator.compare(byModifier($e.n), byModifier(Ze.n)) || collator.compare(byName($e.n), byName(Ze.n));
}
function byModifier($e) {
  return ($e || "").split(/:/).pop().split("/").pop() || "\0";
}
function byName($e) {
  return ($e || "").replace(/\W/g, (Ze) => String.fromCharCode(127 + Ze.charCodeAt(0))) + "\0";
}
function parseColorComponent($e, Ze) {
  return Math.round(parseInt($e, 16) * Ze);
}
function toColorValue($e, Ze = {}) {
  if (typeof $e == "function")
    return $e(Ze);
  let { opacityValue: Fe = "1", opacityVariable: Ke } = Ze, Ve = Ke ? `var(${Ke})` : Fe;
  if ($e.includes("<alpha-value>"))
    return $e.replace("<alpha-value>", Ve);
  if ($e[0] == "#" && ($e.length == 4 || $e.length == 7)) {
    let Je = ($e.length - 1) / 3, Qe = [
      17,
      1,
      0.062272
    ][Je - 1];
    return `rgba(${[
      parseColorComponent($e.substr(1, Je), Qe),
      parseColorComponent($e.substr(1 + Je, Je), Qe),
      parseColorComponent($e.substr(1 + 2 * Je, Je), Qe),
      Ve
    ]})`;
  }
  return Ve == "1" ? $e : Ve == "0" ? "#0000" : (
    // convert rgb and hsl to alpha variant
    $e.replace(/^(rgb|hsl)(\([^)]+)\)$/, `$1a$2,${Ve})`)
  );
}
function serialize($e, Ze, Fe, Ke, Ve = []) {
  return function Je(Qe, { n: at, p: ut, r: lt = [], i: dt }, bt) {
    let $t = [], vt = "", wt = 0, xt = 0;
    for (let Rt in Qe || {}) {
      var Et, Tt;
      let Ct = Qe[Rt];
      if (Rt[0] == "@") {
        if (!Ct)
          continue;
        if (Rt[1] == "a") {
          $t.push(...translateWith(at, ut, parse$2("" + Ct), bt, ut, lt, dt, !0));
          continue;
        }
        if (Rt[1] == "l") {
          for (let Zt of asArray(Ct))
            $t.push(...Je(Zt, {
              n: at,
              p: (Et = Layer[Rt[7]], // Set layer (first reset, than set)
              ut & ~Layer.o | Et),
              r: Rt[7] == "d" ? [] : lt,
              i: dt
            }, bt));
          continue;
        }
        if (Rt[1] == "i") {
          $t.push(...asArray(Ct).map((Zt) => ({
            // before all layers
            p: -1,
            o: 0,
            r: [],
            d: Rt + " " + Zt
          })));
          continue;
        }
        if (Rt[1] == "k") {
          $t.push({
            p: Layer.d,
            o: 0,
            r: [
              Rt
            ],
            d: Je(Ct, {
              p: Layer.d
            }, bt).map(stringify$1).join("")
          });
          continue;
        }
        if (Rt[1] == "f") {
          $t.push(...asArray(Ct).map((Zt) => ({
            p: Layer.d,
            o: 0,
            r: [
              Rt
            ],
            d: Je(Zt, {
              p: Layer.d
            }, bt).map(stringify$1).join("")
          })));
          continue;
        }
      }
      if (typeof Ct != "object" || Array.isArray(Ct))
        Rt == "label" && Ct ? at = Ct + hash(JSON.stringify([
          ut,
          dt,
          Qe
        ])) : (Ct || Ct === 0) && (Rt = Rt.replace(/[A-Z]/g, (Zt) => "-" + Zt.toLowerCase()), xt += 1, wt = Math.max(wt, (Tt = Rt)[0] == "-" ? 0 : seperatorPrecedence(Tt) + (/^(?:(border-(?!w|c|sty)|[tlbr].{2,4}m?$|c.{7,8}$)|([fl].{5}l|g.{8}$|pl))/.test(Tt) ? +!!RegExp.$1 || /* +1 */
        -!!RegExp.$2 : (
          /* -1 */
          0
        )) + 1), vt += (vt ? ";" : "") + asArray(Ct).map((Zt) => bt.s(
          Rt,
          // support theme(...) function in values
          // calc(100vh - theme('spacing.12'))
          resolveThemeFunction("" + Zt, bt.theme) + (dt ? " !important" : "")
        )).join(";"));
      else if (Rt[0] == "@" || Rt.includes("&")) {
        let Zt = ut;
        Rt[0] == "@" && (Rt = Rt.replace(/\bscreen\(([^)]+)\)/g, (Lt, Ut) => {
          let Pt = bt.theme("screens", Ut);
          return Pt ? (Zt |= 67108864, /* Shifts.screens */
          mql(Pt, "")) : Lt;
        }), Zt |= atRulePrecedence(Rt)), $t.push(...Je(Ct, {
          n: at,
          p: Zt,
          r: [
            ...lt,
            Rt
          ],
          i: dt
        }, bt));
      } else
        $t.push(...Je(Ct, {
          p: ut,
          r: [
            ...lt,
            Rt
          ]
        }, bt));
    }
    return (
      // PERF: prevent unshift using `rules = [{}]` above and then `rules[0] = {...}`
      $t.unshift({
        n: at,
        p: ut,
        o: (
          // number of declarations (descending)
          Math.max(0, 15 - xt) + // greatest precedence of properties
          // if there is no property precedence this is most likely a custom property only declaration
          // these have the highest precedence
          1.5 * Math.min(wt || 15, 15)
        ),
        r: lt,
        // stringified declarations
        d: vt
      }), $t.sort(compareTwindRules)
    );
  }($e, convert(Ze, Fe, Ke, Ve), Fe);
}
function resolveThemeFunction($e, Ze) {
  return $e.replace(/theme\((["'`])?(.+?)\1(?:\s*,\s*(["'`])?(.+?)\3)?\)/g, (Fe, Ke, Ve, Je, Qe = "") => {
    let at = Ze(Ve, Qe);
    return typeof at == "function" && /color|fill|stroke/i.test(Ve) ? toColorValue(at) : "" + asArray(at).filter((ut) => Object(ut) !== ut);
  });
}
function merge($e, Ze) {
  let Fe, Ke = [];
  for (let Ve of $e)
    Ve.d && Ve.n ? (Fe == null ? void 0 : Fe.p) == Ve.p && "" + Fe.r == "" + Ve.r ? (Fe.c = [
      Fe.c,
      Ve.c
    ].filter(Boolean).join(" "), Fe.d = Fe.d + ";" + Ve.d) : Ke.push(Fe = {
      ...Ve,
      n: Ve.n && Ze
    }) : Ke.push({
      ...Ve,
      n: Ve.n && Ze
    });
  return Ke;
}
function translate($e, Ze, Fe = Layer.u, Ke, Ve) {
  let Je = [];
  for (let Qe of $e)
    for (let at of function(ut, lt, dt, bt, $t) {
      ut = {
        ...ut,
        i: ut.i || $t
      };
      let vt = function(wt, xt) {
        let Et = registry.get(wt.n);
        return Et ? Et(wt, xt) : xt.r(wt.n, wt.v[0] == "dark");
      }(ut, lt);
      return vt ? (
        // a list of class names
        typeof vt == "string" ? ({ r: bt, p: dt } = convert(ut, lt, dt, bt), merge(translate(parse$2(vt), lt, dt, bt, ut.i), ut.n)) : Array.isArray(vt) ? vt.map((wt) => {
          var xt, Et;
          return {
            o: 0,
            ...wt,
            r: [
              ...asArray(bt),
              ...asArray(wt.r)
            ],
            p: (xt = dt, Et = wt.p ?? dt, xt & ~Layer.o | Et)
          };
        }) : serialize(vt, ut, lt, dt, bt)
      ) : (
        // propagate className as is
        [
          {
            c: toClassName(ut),
            p: 0,
            o: 0,
            r: []
          }
        ]
      );
    }(Qe, Ze, Fe, Ke, Ve))
      Je.splice(sortedInsertionIndex(Je, at), 0, at);
  return Je;
}
function translateWith($e, Ze, Fe, Ke, Ve, Je, Qe, at) {
  return merge((at ? Fe.flatMap((ut) => translate([
    ut
  ], Ke, Ve, Je, Qe)) : translate(Fe, Ke, Ve, Je, Qe)).map((ut) => (
    // do not move defaults
    // move only rules with a name unless they are in the base layer
    ut.p & Layer.o && (ut.n || Ze == Layer.b) ? {
      ...ut,
      p: ut.p & ~Layer.o | Ze,
      o: 0
    } : ut
  )), $e);
}
function define$1($e, Ze, Fe, Ke) {
  var Ve;
  return Ve = (Je, Qe) => {
    let { n: at, p: ut, r: lt, i: dt } = convert(Je, Qe, Ze);
    return Fe && translateWith(at, Ze, Fe, Qe, ut, lt, dt, Ke);
  }, registry.set($e, Ve), $e;
}
function createRule($e, Ze, Fe) {
  if ($e[$e.length - 1] != "(") {
    let Ke = [], Ve = !1, Je = !1, Qe = "";
    for (let at of $e)
      if (!(at == "(" || /[~@]$/.test(at))) {
        if (at[0] == "!" && (at = at.slice(1), Ve = !Ve), at.endsWith(":")) {
          Ke[at == "dark:" ? "unshift" : "push"](at.slice(0, -1));
          continue;
        }
        at[0] == "-" && (at = at.slice(1), Je = !Je), at.endsWith("-") && (at = at.slice(0, -1)), at && at != "&" && (Qe += (Qe && "-") + at);
      }
    Qe && (Je && (Qe = "-" + Qe), Ze[0].push({
      n: Qe,
      v: Ke.filter(uniq),
      i: Ve
    }));
  }
}
function uniq($e, Ze, Fe) {
  return Fe.indexOf($e) == Ze;
}
let cache = /* @__PURE__ */ new Map();
function parse$2($e) {
  let Ze = cache.get($e);
  if (!Ze) {
    let Fe = [], Ke = [
      []
    ], Ve = 0, Je = 0, Qe = null, at = 0, ut = (lt, dt = 0) => {
      Ve != at && (Fe.push($e.slice(Ve, at + dt)), lt && createRule(Fe, Ke)), Ve = at + 1;
    };
    for (; at < $e.length; at++) {
      let lt = $e[at];
      if (Je)
        $e[at - 1] != "\\" && (Je += +(lt == "[") || -(lt == "]"));
      else if (lt == "[")
        Je += 1;
      else if (Qe)
        $e[at - 1] != "\\" && Qe.test($e.slice(at)) && (Qe = null, Ve = at + RegExp.lastMatch.length);
      else if (lt == "/" && $e[at - 1] != "\\" && ($e[at + 1] == "*" || $e[at + 1] == "/"))
        Qe = $e[at + 1] == "*" ? /^\*\// : /^[\r\n]/;
      else if (lt == "(")
        ut(), Fe.push(lt);
      else if (lt == ":")
        $e[at + 1] != ":" && ut(!1, 1);
      else if (/[\s,)]/.test(lt)) {
        ut(!0);
        let dt = Fe.lastIndexOf("(");
        if (lt == ")") {
          let bt = Fe[dt - 1];
          if (/[~@]$/.test(bt)) {
            let $t = Ke.shift();
            Fe.length = dt, createRule([
              ...Fe,
              "#"
            ], Ke);
            let { v: vt } = Ke[0].pop();
            for (let wt of $t)
              wt.v.splice(+(wt.v[0] == "dark") - +(vt[0] == "dark"), vt.length);
            createRule([
              ...Fe,
              define$1(
                // named nested
                bt.length > 1 ? bt.slice(0, -1) + hash(JSON.stringify([
                  bt,
                  $t
                ])) : bt + "(" + format($t) + ")",
                Layer.a,
                $t,
                /@$/.test(bt)
              )
            ], Ke);
          }
          dt = Fe.lastIndexOf("(", dt - 1);
        }
        Fe.length = dt + 1;
      } else
        /[~@]/.test(lt) && $e[at + 1] == "(" && // start nested block
        // ~(...) or button~(...)
        // @(...) or button@(...)
        Ke.unshift([]);
    }
    ut(!0), cache.set($e, Ze = Ke[0]);
  }
  return Ze;
}
function interleave($e, Ze, Fe) {
  return Ze.reduce((Ke, Ve, Je) => Ke + Fe(Ve) + $e[Je + 1], $e[0]);
}
function interpolate$1($e, Ze) {
  return Array.isArray($e) && Array.isArray($e.raw) ? interleave($e, Ze, (Fe) => toString(Fe).trim()) : Ze.filter(Boolean).reduce((Fe, Ke) => Fe + toString(Ke), $e ? toString($e) : "");
}
function toString($e) {
  let Ze, Fe = "";
  if ($e && typeof $e == "object")
    if (Array.isArray($e))
      (Ze = interpolate$1($e[0], $e.slice(1))) && (Fe += " " + Ze);
    else
      for (let Ke in $e)
        $e[Ke] && (Fe += " " + Ke);
  else
    $e != null && typeof $e != "boolean" && (Fe += " " + $e);
  return Fe;
}
function astish($e, Ze) {
  return Array.isArray($e) ? astish$(interleave($e, Ze, (Fe) => Fe != null && typeof Fe != "boolean" ? Fe : "")) : typeof $e == "string" ? astish$($e) : [
    $e
  ];
}
let newRule = / *(?:(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}))/g;
function astish$($e) {
  let Ze;
  $e = // Remove comments (multiline and single line)
  $e.replace(/\/\*[^]*?\*\/|\s\s+|\n/gm, " ");
  let Fe = [
    {}
  ], Ke = [
    Fe[0]
  ], Ve = [];
  for (; Ze = newRule.exec($e); )
    Ze[4] && (Fe.shift(), Ve.shift()), Ze[3] ? (Ve.unshift(Ze[3]), Fe.unshift({}), Ke.push(Ve.reduce((Je, Qe) => ({
      [Qe]: Je
    }), Fe[0]))) : Ze[4] || (Fe[0][Ze[1]] && (Fe.unshift({}), Ke.push(Ve.reduce((Je, Qe) => ({
      [Qe]: Je
    }), Fe[0]))), Fe[0][Ze[1]] = Ze[2]);
  return Ke;
}
function css($e, ...Ze) {
  var Je;
  var Fe;
  let Ke = astish($e, Ze), Ve = (((Je = Ke.find((Qe) => Qe.label)) == null ? void 0 : Je.label) || "css") + hash(JSON.stringify(Ke));
  return Fe = (Qe, at) => merge(Ke.flatMap((ut) => serialize(ut, Qe, at, Layer.o)), Ve), registry.set(Ve, Fe), Ve;
}
function match($e, Ze, Fe) {
  return [
    $e,
    fromMatch(Ze, Fe)
  ];
}
function fromMatch($e, Ze) {
  return typeof $e == "function" ? $e : typeof $e == "string" && /^[\w-]+$/.test($e) ? (
    // a CSS property alias
    (Fe, Ke) => ({
      [$e]: Ze ? Ze(Fe, Ke) : maybeNegate(Fe, 1)
    })
  ) : (Fe) => (
    // CSSObject, shortcut or apply
    $e || {
      [Fe[1]]: maybeNegate(Fe, 2)
    }
  );
}
function maybeNegate($e, Ze, Fe = $e.slice(Ze).find(Boolean) || $e.$$ || $e.input) {
  return $e.input[0] == "-" ? `calc(${Fe} * -1)` : Fe;
}
function matchTheme($e, Ze, Fe, Ke) {
  return [
    $e,
    fromTheme(Ze, Fe, Ke)
  ];
}
function fromTheme($e, Ze, Fe) {
  let Ke = typeof Ze == "string" ? (Ve, Je) => ({
    [Ze]: Fe ? Fe(Ve, Je) : Ve._
  }) : Ze || (({ 1: Ve, _: Je }, Qe, at) => ({
    [Ve || at]: Je
  }));
  return (Ve, Je) => {
    let Qe = camelize($e || Ve[1]), at = Je.theme(Qe, Ve.$$) ?? arbitrary(Ve.$$, Qe, Je);
    if (at != null)
      return Ve._ = maybeNegate(Ve, 0, at), Ke(Ve, Je, Qe);
  };
}
function matchColor($e, Ze = {}, Fe) {
  return [
    $e,
    colorFromTheme(Ze, Fe)
  ];
}
function colorFromTheme($e = {}, Ze) {
  return (Fe, Ke) => {
    let { section: Ve = camelize(Fe[0]).replace("-", "") + "Color" } = $e, [Je, Qe] = parseValue(Fe.$$);
    if (!Je)
      return;
    let at = Ke.theme(Ve, Je) || arbitrary(Je, Ve, Ke);
    if (!at || typeof at == "object")
      return;
    let {
      // text- -> --tw-text-opacity
      // ring-offset(?:-|$) -> --tw-ring-offset-opacity
      // TODO move this default into preset-tailwind?
      opacityVariable: ut = `--tw-${Fe[0].replace(/-$/, "")}-opacity`,
      opacitySection: lt = Ve.replace("Color", "Opacity"),
      property: dt = Ve,
      selector: bt
    } = $e, $t = Ke.theme(lt, Qe || "DEFAULT") || Qe && arbitrary(Qe, lt, Ke), vt = Ze || (({ _: xt }) => {
      let Et = toCSS(dt, xt);
      return bt ? {
        [bt]: Et
      } : Et;
    });
    Fe._ = {
      value: toColorValue(at, {
        opacityVariable: ut || void 0,
        opacityValue: $t || void 0
      }),
      color: (xt) => toColorValue(at, xt),
      opacityVariable: ut || void 0,
      opacityValue: $t || void 0
    };
    let wt = vt(Fe, Ke);
    if (!Fe.dark) {
      let xt = Ke.d(Ve, Je, at);
      xt && xt !== at && (Fe._ = {
        value: toColorValue(xt, {
          opacityVariable: ut || void 0,
          opacityValue: $t || "1"
        }),
        color: (Et) => toColorValue(xt, Et),
        opacityVariable: ut || void 0,
        opacityValue: $t || void 0
      }, wt = {
        "&": wt,
        [Ke.v("dark")]: vt(Fe, Ke)
      });
    }
    return wt;
  };
}
function parseValue($e) {
  return ($e.match(/^(\[[^\]]+]|[^/]+?)(?:\/(.+))?$/) || []).slice(1);
}
function toCSS($e, Ze) {
  let Fe = {};
  return typeof Ze == "string" ? Fe[$e] = Ze : (Ze.opacityVariable && Ze.value.includes(Ze.opacityVariable) && (Fe[Ze.opacityVariable] = Ze.opacityValue || "1"), Fe[$e] = Ze.value), Fe;
}
function arbitrary($e, Ze, Fe) {
  if ($e[0] == "[" && $e.slice(-1) == "]") {
    if ($e = normalize(resolveThemeFunction($e.slice(1, -1), Fe.theme)), !Ze)
      return $e;
    if (
      // Respect type hints from the user on ambiguous arbitrary values - https://tailwindcss.com/docs/adding-custom-styles#resolving-ambiguities
      !// If this is a color section and the value is a hex color, color function or color name
      (/color|fill|stroke/i.test(Ze) && !(/^color:/.test($e) || /^(#|((hsl|rgb)a?|hwb|lab|lch|color)\(|[a-z]+$)/.test($e)) || // url(, [a-z]-gradient(, image(, cross-fade(, image-set(
      /image/i.test(Ze) && !(/^image:/.test($e) || /^[a-z-]+\(/.test($e)) || // font-*
      // - fontWeight (type: ['lookup', 'number', 'any'])
      // - fontFamily (type: ['lookup', 'generic-name', 'family-name'])
      /weight/i.test(Ze) && !(/^(number|any):/.test($e) || /^\d+$/.test($e)) || // bg-*
      // - backgroundPosition (type: ['lookup', ['position', { preferOnConflict: true }]])
      // - backgroundSize (type: ['lookup', 'length', 'percentage', 'size'])
      /position/i.test(Ze) && /^(length|size):/.test($e))
    )
      return $e.replace(/^[a-z-]+:/, "");
  }
}
function camelize($e) {
  return $e.replace(/-./g, (Ze) => Ze[1].toUpperCase());
}
function normalize($e) {
  return (
    // Keep raw strings if it starts with `url(`
    $e.includes("url(") ? $e.replace(/(.*?)(url\(.*?\))(.*?)/g, (Ze, Fe = "", Ke, Ve = "") => normalize(Fe) + Ke + normalize(Ve)) : $e.replace(/(^|[^\\])_+/g, (Ze, Fe) => Fe + " ".repeat(Ze.length - Fe.length)).replace(/\\_/g, "_").replace(/(calc|min|max|clamp)\(.+\)/g, (Ze) => Ze.replace(/(-?\d*\.?\d(?!\b-.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 "))
  );
}
function defineConfig({ presets: $e = [], ...Ze }) {
  let Fe = {
    darkMode: void 0,
    darkColor: void 0,
    preflight: Ze.preflight !== !1 && [],
    theme: {},
    variants: asArray(Ze.variants),
    rules: asArray(Ze.rules),
    ignorelist: asArray(Ze.ignorelist),
    hash: void 0,
    stringify: (Ke, Ve) => Ke + ":" + Ve,
    finalize: []
  };
  for (let Ke of asArray([
    ...$e,
    {
      darkMode: Ze.darkMode,
      darkColor: Ze.darkColor,
      preflight: Ze.preflight !== !1 && asArray(Ze.preflight),
      theme: Ze.theme,
      hash: Ze.hash,
      stringify: Ze.stringify,
      finalize: Ze.finalize
    }
  ])) {
    let { preflight: Ve, darkMode: Je = Fe.darkMode, darkColor: Qe = Fe.darkColor, theme: at, variants: ut, rules: lt, ignorelist: dt, hash: bt = Fe.hash, stringify: $t = Fe.stringify, finalize: vt } = typeof Ke == "function" ? Ke(Fe) : Ke;
    Fe = {
      // values defined by user or previous presets take precedence
      preflight: Fe.preflight !== !1 && Ve !== !1 && [
        ...Fe.preflight,
        ...asArray(Ve)
      ],
      darkMode: Je,
      darkColor: Qe,
      theme: {
        ...Fe.theme,
        ...at,
        extend: {
          ...Fe.theme.extend,
          ...at == null ? void 0 : at.extend
        }
      },
      variants: [
        ...Fe.variants,
        ...asArray(ut)
      ],
      rules: [
        ...Fe.rules,
        ...asArray(lt)
      ],
      ignorelist: [
        ...Fe.ignorelist,
        ...asArray(dt)
      ],
      hash: bt,
      stringify: $t,
      finalize: [
        ...Fe.finalize,
        ...asArray(vt)
      ]
    };
  }
  return Fe;
}
function find($e, Ze, Fe, Ke, Ve, Je) {
  for (let Qe of Ze) {
    let at = Fe.get(Qe);
    at || Fe.set(Qe, at = Ke(Qe));
    let ut = at($e, Ve, Je);
    if (ut)
      return ut;
  }
}
function getVariantResolver($e) {
  var Ze;
  return createResolve($e[0], typeof (Ze = $e[1]) == "function" ? Ze : () => Ze);
}
function getRuleResolver($e) {
  var Ze, Fe;
  return Array.isArray($e) ? createResolve($e[0], fromMatch($e[1], $e[2])) : createResolve($e, fromMatch(Ze, Fe));
}
function createResolve($e, Ze) {
  return createRegExpExecutor($e, (Fe, Ke, Ve, Je) => {
    let Qe = Ke.exec(Fe);
    if (Qe)
      return (
        // MATCH.$_ = value
        Qe.$$ = Fe.slice(Qe[0].length), Qe.dark = Je, Ze(Qe, Ve)
      );
  });
}
function createRegExpExecutor($e, Ze) {
  let Fe = asArray($e).map(toCondition);
  return (Ke, Ve, Je) => {
    for (let Qe of Fe) {
      let at = Ze(Ke, Qe, Ve, Je);
      if (at)
        return at;
    }
  };
}
function toCondition($e) {
  return typeof $e == "string" ? RegExp("^" + $e + ($e.includes("$") || $e.slice(-1) == "-" ? "" : "$")) : $e;
}
function twind($e, Ze) {
  let Fe = defineConfig($e), Ke = function({ theme: ut, darkMode: lt, darkColor: dt = noop, variants: bt, rules: $t, hash: vt, stringify: wt, ignorelist: xt, finalize: Et }) {
    let Tt = /* @__PURE__ */ new Map(), Rt = /* @__PURE__ */ new Map(), Ct = /* @__PURE__ */ new Map(), Zt = /* @__PURE__ */ new Map(), Lt = createRegExpExecutor(xt, (Ot, Ft) => Ft.test(Ot));
    bt.push([
      "dark",
      Array.isArray(lt) || lt == "class" ? `${asArray(lt)[1] || ".dark"} &` : typeof lt == "string" && lt != "media" ? lt : (
        // a custom selector
        "@media (prefers-color-scheme:dark)"
      )
    ]);
    let Ut = typeof vt == "function" ? (Ot) => vt(Ot, hash) : vt ? hash : identity$1;
    Ut !== identity$1 && Et.push((Ot) => {
      var Ft;
      return {
        ...Ot,
        n: Ot.n && Ut(Ot.n),
        d: (Ft = Ot.d) == null ? void 0 : Ft.replace(/--(tw(?:-[\w-]+)?)\b/g, (gt, We) => "--" + Ut(We).replace("#", ""))
      };
    });
    let Pt = {
      theme: function({ extend: Ot = {}, ...Ft }) {
        let gt = {}, We = {
          get colors() {
            return Xe("colors");
          },
          theme: Xe,
          // Stub implementation as negated values are automatically infered and do _not_ need to be in the theme
          negative() {
            return {};
          },
          breakpoints(ot) {
            let ft = {};
            for (let mt in ot)
              typeof ot[mt] == "string" && (ft["screen-" + mt] = ot[mt]);
            return ft;
          }
        };
        return Xe;
        function Xe(ot, ft, mt, yt) {
          if (ot) {
            if ({ 1: ot, 2: yt } = // eslint-disable-next-line no-sparse-arrays
            /^(\S+?)(?:\s*\/\s*([^/]+))?$/.exec(ot) || [
              ,
              ot
            ], /[.[]/.test(ot)) {
              let Mt = [];
              ot.replace(/\[([^\]]+)\]|([^.[]+)/g, (St, At, Nt = At) => Mt.push(Nt)), ot = Mt.shift(), mt = ft, ft = Mt.join("-");
            }
            let Ge = gt[ot] || // two-step deref to allow extend section to reference base section
            Object.assign(Object.assign(
              // Make sure to not get into recursive calls
              gt[ot] = {},
              rt(Ft, ot)
            ), rt(Ot, ot));
            if (ft == null)
              return Ge;
            ft || (ft = "DEFAULT");
            let ct = Ge[ft] ?? ft.split("-").reduce((Mt, St) => Mt == null ? void 0 : Mt[St], Ge) ?? mt;
            return yt ? toColorValue(ct, {
              opacityValue: resolveThemeFunction(yt, Xe)
            }) : ct;
          }
          let pt = {};
          for (let Ge of [
            ...Object.keys(Ft),
            ...Object.keys(Ot)
          ])
            pt[Ge] = Xe(Ge);
          return pt;
        }
        function rt(ot, ft) {
          let mt = ot[ft];
          return typeof mt == "function" && (mt = mt(We)), mt && /color|fill|stroke/i.test(ft) ? function yt(pt, Ge = []) {
            let ct = {};
            for (let Mt in pt) {
              let St = pt[Mt], At = [
                ...Ge,
                Mt
              ];
              ct[At.join("-")] = St, Mt == "DEFAULT" && (At = Ge, ct[Ge.join("-")] = St), typeof St == "object" && Object.assign(ct, yt(St, At));
            }
            return ct;
          }(mt) : mt;
        }
      }(ut),
      e: escape$1,
      h: Ut,
      s(Ot, Ft) {
        return wt(Ot, Ft, Pt);
      },
      d(Ot, Ft, gt) {
        return dt(Ot, Ft, Pt, gt);
      },
      v(Ot) {
        return Tt.has(Ot) || Tt.set(Ot, find(Ot, bt, Rt, getVariantResolver, Pt) || "&:" + Ot), Tt.get(Ot);
      },
      r(Ot, Ft) {
        let gt = JSON.stringify([
          Ot,
          Ft
        ]);
        return Ct.has(gt) || Ct.set(gt, !Lt(Ot, Pt) && find(Ot, $t, Zt, getRuleResolver, Pt, Ft)), Ct.get(gt);
      },
      f(Ot) {
        return Et.reduce((Ft, gt) => gt(Ft, Pt), Ot);
      }
    };
    return Pt;
  }(Fe), Ve = /* @__PURE__ */ new Map(), Je = [], Qe = /* @__PURE__ */ new Set();
  Ze.resume((ut) => Ve.set(ut, ut), (ut, lt) => {
    Ze.insert(ut, Je.length, lt), Je.push(lt), Qe.add(ut);
  });
  function at(ut) {
    let lt = Ke.f(ut), dt = stringify$1(lt);
    if (dt && !Qe.has(dt)) {
      Qe.add(dt);
      let bt = sortedInsertionIndex(Je, ut);
      Ze.insert(dt, bt, ut), Je.splice(bt, 0, ut);
    }
    return lt.n;
  }
  return Object.defineProperties(function(lt) {
    if (!Ve.size)
      for (let bt of asArray(Fe.preflight))
        typeof bt == "function" && (bt = bt(Ke)), bt && (typeof bt == "string" ? translateWith("", Layer.b, parse$2(bt), Ke, Layer.b, [], !1, !0) : serialize(bt, {}, Ke, Layer.b)).forEach(at);
    lt = "" + lt;
    let dt = Ve.get(lt);
    if (!dt) {
      let bt = /* @__PURE__ */ new Set();
      for (let $t of translate(parse$2(lt), Ke))
        bt.add($t.c).add(at($t));
      dt = [
        ...bt
      ].filter(Boolean).join(" "), Ve.set(lt, dt).set(dt, dt);
    }
    return dt;
  }, Object.getOwnPropertyDescriptors({
    get target() {
      return Ze.target;
    },
    theme: Ke.theme,
    config: Fe,
    snapshot() {
      let ut = Ze.snapshot(), lt = new Set(Qe), dt = new Map(Ve), bt = [
        ...Je
      ];
      return () => {
        ut(), Qe = lt, Ve = dt, Je = bt;
      };
    },
    clear() {
      Ze.clear(), Qe = /* @__PURE__ */ new Set(), Ve = /* @__PURE__ */ new Map(), Je = [];
    },
    destroy() {
      this.clear(), Ze.destroy();
    }
  }));
}
function getStyleElement($e) {
  let Ze = document.querySelector($e || 'style[data-twind=""]');
  return (!Ze || Ze.tagName != "STYLE") && (Ze = document.createElement("style"), document.head.prepend(Ze)), Ze.dataset.twind = "claimed", Ze;
}
function cssom($e) {
  let Ze = $e != null && $e.cssRules ? $e : ($e && typeof $e != "string" ? $e : getStyleElement($e)).sheet;
  return {
    target: Ze,
    snapshot() {
      let Fe = Array.from(Ze.cssRules, (Ke) => Ke.cssText);
      return () => {
        this.clear(), Fe.forEach(this.insert);
      };
    },
    clear() {
      for (let Fe = Ze.cssRules.length; Fe--; )
        Ze.deleteRule(Fe);
    },
    destroy() {
      var Fe;
      (Fe = Ze.ownerNode) == null || Fe.remove();
    },
    insert(Fe, Ke) {
      try {
        Ze.insertRule(Fe, Ke);
      } catch {
        Ze.insertRule(":root{}", Ke);
      }
    },
    resume: noop
  };
}
let tw$1 = /* @__PURE__ */ new Proxy(
  // just exposing the active as tw should work with most bundlers
  // as ES module export can be re-assigned BUT some bundlers to not honor this
  // -> using a delegation proxy here
  noop,
  {
    apply($e, Ze, Fe) {
      return active(Fe[0]);
    },
    get($e, Ze) {
      let Fe = active[Ze];
      return typeof Fe == "function" ? function() {
        return Fe.apply(active, arguments);
      } : Fe;
    }
  }
), injectGlobal = function($e, ...Ze) {
  (typeof this == "function" ? this : tw$1)(css({
    "@layer base": astish($e, Ze)
  }));
}, keyframes = /* @__PURE__ */ function $e(Ze) {
  return new Proxy(function(Ke, ...Ve) {
    return keyframes$(Ze, "", Ke, Ve);
  }, {
    get(Fe, Ke) {
      return Ke === "bind" ? $e : Ke in Fe ? Fe[Ke] : function(Je, ...Qe) {
        return keyframes$(Ze, Ke, Je, Qe);
      };
    }
  });
}();
function keyframes$($e, Ze, Fe, Ke) {
  return {
    toString() {
      let Ve = astish(Fe, Ke), Je = escape$1(Ze + hash(JSON.stringify([
        Ze,
        Ve
      ])));
      return (
        // lazy access tw
        (typeof $e == "function" ? $e : tw$1)(css({
          [`@keyframes ${Je}`]: astish(Fe, Ke)
        })), Je
      );
    }
  };
}
let tx = function($e, ...Ze) {
  return (typeof this == "function" ? this : tw$1)(interpolate$1($e, Ze));
};
var i = /* @__PURE__ */ new Map([["align-self", "-ms-grid-row-align"], ["color-adjust", "-webkit-print-color-adjust"], ["column-gap", "grid-column-gap"], ["forced-color-adjust", "-ms-high-contrast-adjust"], ["gap", "grid-gap"], ["grid-template-columns", "-ms-grid-columns"], ["grid-template-rows", "-ms-grid-rows"], ["justify-self", "-ms-grid-column-align"], ["margin-inline-end", "-webkit-margin-end"], ["margin-inline-start", "-webkit-margin-start"], ["mask-border", "-webkit-mask-box-image"], ["mask-border-outset", "-webkit-mask-box-image-outset"], ["mask-border-slice", "-webkit-mask-box-image-slice"], ["mask-border-source", "-webkit-mask-box-image-source"], ["mask-border-repeat", "-webkit-mask-box-image-repeat"], ["mask-border-width", "-webkit-mask-box-image-width"], ["overflow-wrap", "word-wrap"], ["padding-inline-end", "-webkit-padding-end"], ["padding-inline-start", "-webkit-padding-start"], ["print-color-adjust", "color-adjust"], ["row-gap", "grid-row-gap"], ["scroll-margin-bottom", "scroll-snap-margin-bottom"], ["scroll-margin-left", "scroll-snap-margin-left"], ["scroll-margin-right", "scroll-snap-margin-right"], ["scroll-margin-top", "scroll-snap-margin-top"], ["scroll-margin", "scroll-snap-margin"], ["text-combine-upright", "-ms-text-combine-horizontal"]]);
function r$1($e) {
  return i.get($e);
}
function a($e) {
  var Ze = /^(?:(text-(?:decoration$|e|or|si)|back(?:ground-cl|d|f)|box-d|mask(?:$|-[ispro]|-cl)|pr|hyphena|flex-d)|(tab-|column(?!-s)|text-align-l)|(ap)|u|hy)/i.exec($e);
  return Ze ? Ze[1] ? 1 : Ze[2] ? 2 : Ze[3] ? 3 : 5 : 0;
}
function t($e, Ze) {
  var Fe = /^(?:(pos)|(cli)|(background-i)|(flex(?:$|-b)|(?:max-|min-)?(?:block-s|inl|he|widt))|dis)/i.exec($e);
  return Fe ? Fe[1] ? /^sti/i.test(Ze) ? 1 : 0 : Fe[2] ? /^pat/i.test(Ze) ? 1 : 0 : Fe[3] ? /^image-/i.test(Ze) ? 1 : 0 : Fe[4] ? Ze[3] === "-" ? 2 : 0 : /^(?:inline-)?grid$/i.test(Ze) ? 4 : 0 : 0;
}
let CSSPrefixFlags = [
  [
    "-webkit-",
    1
  ],
  // 0b001
  [
    "-moz-",
    2
  ],
  // 0b010
  [
    "-ms-",
    4
  ]
];
function presetAutoprefix() {
  return ({ stringify: $e }) => ({
    stringify(Ze, Fe, Ke) {
      let Ve = "", Je = r$1(Ze);
      Je && (Ve += $e(Je, Fe, Ke) + ";");
      let Qe = a(Ze), at = t(Ze, Fe);
      for (let ut of CSSPrefixFlags)
        Qe & ut[1] && (Ve += $e(ut[0] + Ze, Fe, Ke) + ";"), at & ut[1] && (Ve += $e(Ze, ut[0] + Fe, Ke) + ";");
      return Ve + $e(Ze, Fe, Ke);
    }
  });
}
let theme = {
  screens: {
    sm: "640px",
    md: "768px",
    lg: "1024px",
    xl: "1280px",
    "2xl": "1536px"
  },
  columns: {
    auto: "auto",
    // Handled by plugin,
    // 1: '1',
    // 2: '2',
    // 3: '3',
    // 4: '4',
    // 5: '5',
    // 6: '6',
    // 7: '7',
    // 8: '8',
    // 9: '9',
    // 10: '10',
    // 11: '11',
    // 12: '12',
    "3xs": "16rem",
    "2xs": "18rem",
    xs: "20rem",
    sm: "24rem",
    md: "28rem",
    lg: "32rem",
    xl: "36rem",
    "2xl": "42rem",
    "3xl": "48rem",
    "4xl": "56rem",
    "5xl": "64rem",
    "6xl": "72rem",
    "7xl": "80rem"
  },
  spacing: {
    px: "1px",
    0: "0px",
    .../* @__PURE__ */ linear(4, "rem", 4, 0.5, 0.5),
    // 0.5: '0.125rem',
    // 1: '0.25rem',
    // 1.5: '0.375rem',
    // 2: '0.5rem',
    // 2.5: '0.625rem',
    // 3: '0.75rem',
    // 3.5: '0.875rem',
    // 4: '1rem',
    .../* @__PURE__ */ linear(12, "rem", 4, 5),
    // 5: '1.25rem',
    // 6: '1.5rem',
    // 7: '1.75rem',
    // 8: '2rem',
    // 9: '2.25rem',
    // 10: '2.5rem',
    // 11: '2.75rem',
    // 12: '3rem',
    14: "3.5rem",
    .../* @__PURE__ */ linear(64, "rem", 4, 16, 4),
    // 16: '4rem',
    // 20: '5rem',
    // 24: '6rem',
    // 28: '7rem',
    // 32: '8rem',
    // 36: '9rem',
    // 40: '10rem',
    // 44: '11rem',
    // 48: '12rem',
    // 52: '13rem',
    // 56: '14rem',
    // 60: '15rem',
    // 64: '16rem',
    72: "18rem",
    80: "20rem",
    96: "24rem"
  },
  durations: {
    75: "75ms",
    100: "100ms",
    150: "150ms",
    200: "200ms",
    300: "300ms",
    500: "500ms",
    700: "700ms",
    1e3: "1000ms"
  },
  animation: {
    none: "none",
    spin: "spin 1s linear infinite",
    ping: "ping 1s cubic-bezier(0,0,0.2,1) infinite",
    pulse: "pulse 2s cubic-bezier(0.4,0,0.6,1) infinite",
    bounce: "bounce 1s infinite"
  },
  aspectRatio: {
    auto: "auto",
    square: "1/1",
    video: "16/9"
  },
  backdropBlur: /* @__PURE__ */ alias("blur"),
  backdropBrightness: /* @__PURE__ */ alias("brightness"),
  backdropContrast: /* @__PURE__ */ alias("contrast"),
  backdropGrayscale: /* @__PURE__ */ alias("grayscale"),
  backdropHueRotate: /* @__PURE__ */ alias("hueRotate"),
  backdropInvert: /* @__PURE__ */ alias("invert"),
  backdropOpacity: /* @__PURE__ */ alias("opacity"),
  backdropSaturate: /* @__PURE__ */ alias("saturate"),
  backdropSepia: /* @__PURE__ */ alias("sepia"),
  backgroundColor: /* @__PURE__ */ alias("colors"),
  backgroundImage: {
    none: "none"
  },
  // These are built-in
  // 'gradient-to-t': 'linear-gradient(to top, var(--tw-gradient-stops))',
  // 'gradient-to-tr': 'linear-gradient(to top right, var(--tw-gradient-stops))',
  // 'gradient-to-r': 'linear-gradient(to right, var(--tw-gradient-stops))',
  // 'gradient-to-br': 'linear-gradient(to bottom right, var(--tw-gradient-stops))',
  // 'gradient-to-b': 'linear-gradient(to bottom, var(--tw-gradient-stops))',
  // 'gradient-to-bl': 'linear-gradient(to bottom left, var(--tw-gradient-stops))',
  // 'gradient-to-l': 'linear-gradient(to left, var(--tw-gradient-stops))',
  // 'gradient-to-tl': 'linear-gradient(to top left, var(--tw-gradient-stops))',
  backgroundOpacity: /* @__PURE__ */ alias("opacity"),
  // backgroundPosition: {
  //   // The following are already handled by the plugin:
  //   // center, right, left, bottom, top
  //   // 'bottom-10px-right-20px' -> bottom 10px right 20px
  // },
  backgroundSize: {
    auto: "auto",
    cover: "cover",
    contain: "contain"
  },
  blur: {
    none: "none",
    0: "0",
    sm: "4px",
    DEFAULT: "8px",
    md: "12px",
    lg: "16px",
    xl: "24px",
    "2xl": "40px",
    "3xl": "64px"
  },
  brightness: {
    .../* @__PURE__ */ linear(200, "", 100, 0, 50),
    // 0: '0',
    // 50: '.5',
    // 150: '1.5',
    // 200: '2',
    .../* @__PURE__ */ linear(110, "", 100, 90, 5),
    // 90: '.9',
    // 95: '.95',
    // 100: '1',
    // 105: '1.05',
    // 110: '1.1',
    75: "0.75",
    125: "1.25"
  },
  borderColor: ({ theme: $e }) => ({
    DEFAULT: $e("colors.gray.200", "currentColor"),
    ...$e("colors")
  }),
  borderOpacity: /* @__PURE__ */ alias("opacity"),
  borderRadius: {
    none: "0px",
    sm: "0.125rem",
    DEFAULT: "0.25rem",
    md: "0.375rem",
    lg: "0.5rem",
    xl: "0.75rem",
    "2xl": "1rem",
    "3xl": "1.5rem",
    "1/2": "50%",
    full: "9999px"
  },
  borderSpacing: /* @__PURE__ */ alias("spacing"),
  borderWidth: {
    DEFAULT: "1px",
    .../* @__PURE__ */ exponential(8, "px")
  },
  // 0: '0px',
  // 2: '2px',
  // 4: '4px',
  // 8: '8px',
  boxShadow: {
    sm: "0 1px 2px 0 rgba(0,0,0,0.05)",
    DEFAULT: "0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px -1px rgba(0,0,0,0.1)",
    md: "0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1)",
    lg: "0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -4px rgba(0,0,0,0.1)",
    xl: "0 20px 25px -5px rgba(0,0,0,0.1), 0 8px 10px -6px rgba(0,0,0,0.1)",
    "2xl": "0 25px 50px -12px rgba(0,0,0,0.25)",
    inner: "inset 0 2px 4px 0 rgba(0,0,0,0.05)",
    none: "0 0 #0000"
  },
  boxShadowColor: alias("colors"),
  // container: {},
  // cursor: {
  //   // Default values are handled by plugin
  // },
  caretColor: /* @__PURE__ */ alias("colors"),
  accentColor: ({ theme: $e }) => ({
    auto: "auto",
    ...$e("colors")
  }),
  contrast: {
    .../* @__PURE__ */ linear(200, "", 100, 0, 50),
    // 0: '0',
    // 50: '.5',
    // 150: '1.5',
    // 200: '2',
    75: "0.75",
    125: "1.25"
  },
  content: {
    none: "none"
  },
  divideColor: /* @__PURE__ */ alias("borderColor"),
  divideOpacity: /* @__PURE__ */ alias("borderOpacity"),
  divideWidth: /* @__PURE__ */ alias("borderWidth"),
  dropShadow: {
    sm: "0 1px 1px rgba(0,0,0,0.05)",
    DEFAULT: [
      "0 1px 2px rgba(0,0,0,0.1)",
      "0 1px 1px rgba(0,0,0,0.06)"
    ],
    md: [
      "0 4px 3px rgba(0,0,0,0.07)",
      "0 2px 2px rgba(0,0,0,0.06)"
    ],
    lg: [
      "0 10px 8px rgba(0,0,0,0.04)",
      "0 4px 3px rgba(0,0,0,0.1)"
    ],
    xl: [
      "0 20px 13px rgba(0,0,0,0.03)",
      "0 8px 5px rgba(0,0,0,0.08)"
    ],
    "2xl": "0 25px 25px rgba(0,0,0,0.15)",
    none: "0 0 #0000"
  },
  fill: ({ theme: $e }) => ({
    ...$e("colors"),
    none: "none"
  }),
  grayscale: {
    DEFAULT: "100%",
    0: "0"
  },
  hueRotate: {
    0: "0deg",
    15: "15deg",
    30: "30deg",
    60: "60deg",
    90: "90deg",
    180: "180deg"
  },
  invert: {
    DEFAULT: "100%",
    0: "0"
  },
  flex: {
    1: "1 1 0%",
    auto: "1 1 auto",
    initial: "0 1 auto",
    none: "none"
  },
  flexBasis: ({ theme: $e }) => ({
    ...$e("spacing"),
    ...ratios(2, 6),
    // '1/2': '50%',
    // '1/3': '33.333333%',
    // '2/3': '66.666667%',
    // '1/4': '25%',
    // '2/4': '50%',
    // '3/4': '75%',
    // '1/5': '20%',
    // '2/5': '40%',
    // '3/5': '60%',
    // '4/5': '80%',
    // '1/6': '16.666667%',
    // '2/6': '33.333333%',
    // '3/6': '50%',
    // '4/6': '66.666667%',
    // '5/6': '83.333333%',
    ...ratios(12, 12),
    // '1/12': '8.333333%',
    // '2/12': '16.666667%',
    // '3/12': '25%',
    // '4/12': '33.333333%',
    // '5/12': '41.666667%',
    // '6/12': '50%',
    // '7/12': '58.333333%',
    // '8/12': '66.666667%',
    // '9/12': '75%',
    // '10/12': '83.333333%',
    // '11/12': '91.666667%',
    auto: "auto",
    full: "100%"
  }),
  flexGrow: {
    DEFAULT: 1,
    0: 0
  },
  flexShrink: {
    DEFAULT: 1,
    0: 0
  },
  fontFamily: {
    sans: 'ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji"'.split(","),
    serif: 'ui-serif,Georgia,Cambria,"Times New Roman",Times,serif'.split(","),
    mono: 'ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'.split(",")
  },
  fontSize: {
    xs: [
      "0.75rem",
      "1rem"
    ],
    sm: [
      "0.875rem",
      "1.25rem"
    ],
    base: [
      "1rem",
      "1.5rem"
    ],
    lg: [
      "1.125rem",
      "1.75rem"
    ],
    xl: [
      "1.25rem",
      "1.75rem"
    ],
    "2xl": [
      "1.5rem",
      "2rem"
    ],
    "3xl": [
      "1.875rem",
      "2.25rem"
    ],
    "4xl": [
      "2.25rem",
      "2.5rem"
    ],
    "5xl": [
      "3rem",
      "1"
    ],
    "6xl": [
      "3.75rem",
      "1"
    ],
    "7xl": [
      "4.5rem",
      "1"
    ],
    "8xl": [
      "6rem",
      "1"
    ],
    "9xl": [
      "8rem",
      "1"
    ]
  },
  fontWeight: {
    thin: "100",
    extralight: "200",
    light: "300",
    normal: "400",
    medium: "500",
    semibold: "600",
    bold: "700",
    extrabold: "800",
    black: "900"
  },
  gap: /* @__PURE__ */ alias("spacing"),
  gradientColorStops: /* @__PURE__ */ alias("colors"),
  gridAutoColumns: {
    auto: "auto",
    min: "min-content",
    max: "max-content",
    fr: "minmax(0,1fr)"
  },
  gridAutoRows: {
    auto: "auto",
    min: "min-content",
    max: "max-content",
    fr: "minmax(0,1fr)"
  },
  gridColumn: {
    // span-X is handled by the plugin: span-1 -> span 1 / span 1
    auto: "auto",
    "span-full": "1 / -1"
  },
  // gridColumnEnd: {
  //   // Defaults handled by plugin
  // },
  // gridColumnStart: {
  //   // Defaults handled by plugin
  // },
  gridRow: {
    // span-X is handled by the plugin: span-1 -> span 1 / span 1
    auto: "auto",
    "span-full": "1 / -1"
  },
  // gridRowStart: {
  //   // Defaults handled by plugin
  // },
  // gridRowEnd: {
  //   // Defaults handled by plugin
  // },
  gridTemplateColumns: {
    // numbers are handled by the plugin: 1 -> repeat(1, minmax(0, 1fr))
    none: "none"
  },
  gridTemplateRows: {
    // numbers are handled by the plugin: 1 -> repeat(1, minmax(0, 1fr))
    none: "none"
  },
  height: ({ theme: $e }) => ({
    ...$e("spacing"),
    ...ratios(2, 6),
    // '1/2': '50%',
    // '1/3': '33.333333%',
    // '2/3': '66.666667%',
    // '1/4': '25%',
    // '2/4': '50%',
    // '3/4': '75%',
    // '1/5': '20%',
    // '2/5': '40%',
    // '3/5': '60%',
    // '4/5': '80%',
    // '1/6': '16.666667%',
    // '2/6': '33.333333%',
    // '3/6': '50%',
    // '4/6': '66.666667%',
    // '5/6': '83.333333%',
    min: "min-content",
    max: "max-content",
    fit: "fit-content",
    auto: "auto",
    full: "100%",
    screen: "100vh"
  }),
  inset: ({ theme: $e }) => ({
    ...$e("spacing"),
    ...ratios(2, 4),
    // '1/2': '50%',
    // '1/3': '33.333333%',
    // '2/3': '66.666667%',
    // '1/4': '25%',
    // '2/4': '50%',
    // '3/4': '75%',
    auto: "auto",
    full: "100%"
  }),
  keyframes: {
    spin: {
      from: {
        transform: "rotate(0deg)"
      },
      to: {
        transform: "rotate(360deg)"
      }
    },
    ping: {
      "0%": {
        transform: "scale(1)",
        opacity: "1"
      },
      "75%,100%": {
        transform: "scale(2)",
        opacity: "0"
      }
    },
    pulse: {
      "0%,100%": {
        opacity: "1"
      },
      "50%": {
        opacity: ".5"
      }
    },
    bounce: {
      "0%, 100%": {
        transform: "translateY(-25%)",
        animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
      },
      "50%": {
        transform: "none",
        animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
      }
    }
  },
  letterSpacing: {
    tighter: "-0.05em",
    tight: "-0.025em",
    normal: "0em",
    wide: "0.025em",
    wider: "0.05em",
    widest: "0.1em"
  },
  lineHeight: {
    .../* @__PURE__ */ linear(10, "rem", 4, 3),
    // 3: '.75rem',
    // 4: '1rem',
    // 5: '1.25rem',
    // 6: '1.5rem',
    // 7: '1.75rem',
    // 8: '2rem',
    // 9: '2.25rem',
    // 10: '2.5rem',
    none: "1",
    tight: "1.25",
    snug: "1.375",
    normal: "1.5",
    relaxed: "1.625",
    loose: "2"
  },
  // listStyleType: {
  //   // Defaults handled by plugin
  // },
  margin: ({ theme: $e }) => ({
    auto: "auto",
    ...$e("spacing")
  }),
  maxHeight: ({ theme: $e }) => ({
    full: "100%",
    min: "min-content",
    max: "max-content",
    fit: "fit-content",
    screen: "100vh",
    ...$e("spacing")
  }),
  maxWidth: ({ theme: $e, breakpoints: Ze }) => ({
    ...Ze($e("screens")),
    none: "none",
    0: "0rem",
    xs: "20rem",
    sm: "24rem",
    md: "28rem",
    lg: "32rem",
    xl: "36rem",
    "2xl": "42rem",
    "3xl": "48rem",
    "4xl": "56rem",
    "5xl": "64rem",
    "6xl": "72rem",
    "7xl": "80rem",
    full: "100%",
    min: "min-content",
    max: "max-content",
    fit: "fit-content",
    prose: "65ch"
  }),
  minHeight: {
    0: "0px",
    full: "100%",
    min: "min-content",
    max: "max-content",
    fit: "fit-content",
    screen: "100vh"
  },
  minWidth: {
    0: "0px",
    full: "100%",
    min: "min-content",
    max: "max-content",
    fit: "fit-content"
  },
  // objectPosition: {
  //   // The plugins joins all arguments by default
  // },
  opacity: {
    .../* @__PURE__ */ linear(100, "", 100, 0, 10),
    // 0: '0',
    // 10: '0.1',
    // 20: '0.2',
    // 30: '0.3',
    // 40: '0.4',
    // 60: '0.6',
    // 70: '0.7',
    // 80: '0.8',
    // 90: '0.9',
    // 100: '1',
    5: "0.05",
    25: "0.25",
    75: "0.75",
    95: "0.95"
  },
  order: {
    // Handled by plugin
    // 1: '1',
    // 2: '2',
    // 3: '3',
    // 4: '4',
    // 5: '5',
    // 6: '6',
    // 7: '7',
    // 8: '8',
    // 9: '9',
    // 10: '10',
    // 11: '11',
    // 12: '12',
    first: "-9999",
    last: "9999",
    none: "0"
  },
  padding: /* @__PURE__ */ alias("spacing"),
  placeholderColor: /* @__PURE__ */ alias("colors"),
  placeholderOpacity: /* @__PURE__ */ alias("opacity"),
  outlineColor: /* @__PURE__ */ alias("colors"),
  outlineOffset: /* @__PURE__ */ exponential(8, "px"),
  // 0: '0px',
  // 1: '1px',
  // 2: '2px',
  // 4: '4px',
  // 8: '8px',,
  outlineWidth: /* @__PURE__ */ exponential(8, "px"),
  // 0: '0px',
  // 1: '1px',
  // 2: '2px',
  // 4: '4px',
  // 8: '8px',,
  ringColor: ({ theme: $e }) => ({
    ...$e("colors"),
    DEFAULT: "#3b82f6"
  }),
  ringOffsetColor: /* @__PURE__ */ alias("colors"),
  ringOffsetWidth: /* @__PURE__ */ exponential(8, "px"),
  // 0: '0px',
  // 1: '1px',
  // 2: '2px',
  // 4: '4px',
  // 8: '8px',,
  ringOpacity: ({ theme: $e }) => ({
    ...$e("opacity"),
    DEFAULT: "0.5"
  }),
  ringWidth: {
    DEFAULT: "3px",
    .../* @__PURE__ */ exponential(8, "px")
  },
  // 0: '0px',
  // 1: '1px',
  // 2: '2px',
  // 4: '4px',
  // 8: '8px',
  rotate: {
    .../* @__PURE__ */ exponential(2, "deg"),
    // 0: '0deg',
    // 1: '1deg',
    // 2: '2deg',
    .../* @__PURE__ */ exponential(12, "deg", 3),
    // 3: '3deg',
    // 6: '6deg',
    // 12: '12deg',
    .../* @__PURE__ */ exponential(180, "deg", 45)
  },
  // 45: '45deg',
  // 90: '90deg',
  // 180: '180deg',
  saturate: /* @__PURE__ */ linear(200, "", 100, 0, 50),
  // 0: '0',
  // 50: '.5',
  // 100: '1',
  // 150: '1.5',
  // 200: '2',
  scale: {
    .../* @__PURE__ */ linear(150, "", 100, 0, 50),
    // 0: '0',
    // 50: '.5',
    // 150: '1.5',
    .../* @__PURE__ */ linear(110, "", 100, 90, 5),
    // 90: '.9',
    // 95: '.95',
    // 100: '1',
    // 105: '1.05',
    // 110: '1.1',
    75: "0.75",
    125: "1.25"
  },
  scrollMargin: /* @__PURE__ */ alias("spacing"),
  scrollPadding: /* @__PURE__ */ alias("spacing"),
  sepia: {
    0: "0",
    DEFAULT: "100%"
  },
  skew: {
    .../* @__PURE__ */ exponential(2, "deg"),
    // 0: '0deg',
    // 1: '1deg',
    // 2: '2deg',
    .../* @__PURE__ */ exponential(12, "deg", 3)
  },
  // 3: '3deg',
  // 6: '6deg',
  // 12: '12deg',
  space: /* @__PURE__ */ alias("spacing"),
  stroke: ({ theme: $e }) => ({
    ...$e("colors"),
    none: "none"
  }),
  strokeWidth: /* @__PURE__ */ linear(2),
  // 0: '0',
  // 1: '1',
  // 2: '2',,
  textColor: /* @__PURE__ */ alias("colors"),
  textDecorationColor: /* @__PURE__ */ alias("colors"),
  textDecorationThickness: {
    "from-font": "from-font",
    auto: "auto",
    .../* @__PURE__ */ exponential(8, "px")
  },
  // 0: '0px',
  // 1: '1px',
  // 2: '2px',
  // 4: '4px',
  // 8: '8px',
  textUnderlineOffset: {
    auto: "auto",
    .../* @__PURE__ */ exponential(8, "px")
  },
  // 0: '0px',
  // 1: '1px',
  // 2: '2px',
  // 4: '4px',
  // 8: '8px',
  textIndent: /* @__PURE__ */ alias("spacing"),
  textOpacity: /* @__PURE__ */ alias("opacity"),
  // transformOrigin: {
  //   // The following are already handled by the plugin:
  //   // center, right, left, bottom, top
  //   // 'bottom-10px-right-20px' -> bottom 10px right 20px
  // },
  transitionDuration: ({ theme: $e }) => ({
    ...$e("durations"),
    DEFAULT: "150ms"
  }),
  transitionDelay: /* @__PURE__ */ alias("durations"),
  transitionProperty: {
    none: "none",
    all: "all",
    DEFAULT: "color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter",
    colors: "color,background-color,border-color,text-decoration-color,fill,stroke",
    opacity: "opacity",
    shadow: "box-shadow",
    transform: "transform"
  },
  transitionTimingFunction: {
    DEFAULT: "cubic-bezier(0.4,0,0.2,1)",
    linear: "linear",
    in: "cubic-bezier(0.4,0,1,1)",
    out: "cubic-bezier(0,0,0.2,1)",
    "in-out": "cubic-bezier(0.4,0,0.2,1)"
  },
  translate: ({ theme: $e }) => ({
    ...$e("spacing"),
    ...ratios(2, 4),
    // '1/2': '50%',
    // '1/3': '33.333333%',
    // '2/3': '66.666667%',
    // '1/4': '25%',
    // '2/4': '50%',
    // '3/4': '75%',
    full: "100%"
  }),
  width: ({ theme: $e }) => ({
    min: "min-content",
    max: "max-content",
    fit: "fit-content",
    screen: "100vw",
    ...$e("flexBasis")
  }),
  willChange: {
    scroll: "scroll-position"
  },
  // other options handled by rules
  // auto: 'auto',
  // contents: 'contents',
  // transform: 'transform',
  zIndex: {
    .../* @__PURE__ */ linear(50, "", 1, 0, 10),
    // 0: '0',
    // 10: '10',
    // 20: '20',
    // 30: '30',
    // 40: '40',
    // 50: '50',
    auto: "auto"
  }
};
function ratios($e, Ze) {
  let Fe = {};
  do
    for (var Ke = 1; Ke < $e; Ke++)
      Fe[`${Ke}/${$e}`] = Number((Ke / $e * 100).toFixed(6)) + "%";
  while (++$e <= Ze);
  return Fe;
}
function exponential($e, Ze, Fe = 0) {
  let Ke = {};
  for (; Fe <= $e; Fe = 2 * Fe || 1)
    Ke[Fe] = Fe + Ze;
  return Ke;
}
function linear($e, Ze = "", Fe = 1, Ke = 0, Ve = 1, Je = {}) {
  for (; Ke <= $e; Ke += Ve)
    Je[Ke] = Ke / Fe + Ze;
  return Je;
}
function alias($e) {
  return ({ theme: Ze }) => Ze($e);
}
let preflight = {
  /*
  1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
  2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
  */
  "*,::before,::after": {
    boxSizing: "border-box",
    /* 1 */
    borderWidth: "0",
    /* 2 */
    borderStyle: "solid",
    /* 2 */
    borderColor: "theme(borderColor.DEFAULT, currentColor)"
  },
  /* 2 */
  "::before,::after": {
    "--tw-content": "''"
  },
  /*
  1. Use a consistent sensible line-height in all browsers.
  2. Prevent adjustments of font size after orientation changes in iOS.
  3. Use a more readable tab size.
  4. Use the user's configured `sans` font-family by default.
  5. Use the user's configured `sans` font-feature-settings by default.
  */
  html: {
    lineHeight: 1.5,
    /* 1 */
    WebkitTextSizeAdjust: "100%",
    /* 2 */
    MozTabSize: "4",
    /* 3 */
    tabSize: 4,
    /* 3 */
    fontFamily: `theme(fontFamily.sans, ${theme.fontFamily.sans})`,
    /* 4 */
    fontFeatureSettings: "theme(fontFamily.sans[1].fontFeatureSettings, normal)"
  },
  /* 5 */
  /*
  1. Remove the margin in all browsers.
  2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.
  */
  body: {
    margin: "0",
    /* 1 */
    lineHeight: "inherit"
  },
  /* 2 */
  /*
  1. Add the correct height in Firefox.
  2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
  3. Ensure horizontal rules are visible by default.
  */
  hr: {
    height: "0",
    /* 1 */
    color: "inherit",
    /* 2 */
    borderTopWidth: "1px"
  },
  /* 3 */
  /*
  Add the correct text decoration in Chrome, Edge, and Safari.
  */
  "abbr:where([title])": {
    textDecoration: "underline dotted"
  },
  /*
  Remove the default font size and weight for headings.
  */
  "h1,h2,h3,h4,h5,h6": {
    fontSize: "inherit",
    fontWeight: "inherit"
  },
  /*
  Reset links to optimize for opt-in styling instead of opt-out.
  */
  a: {
    color: "inherit",
    textDecoration: "inherit"
  },
  /*
  Add the correct font weight in Edge and Safari.
  */
  "b,strong": {
    fontWeight: "bolder"
  },
  /*
  1. Use the user's configured `mono` font family by default.
  2. Use the user's configured `mono` font-feature-settings by default.
  3. Correct the odd `em` font sizing in all browsers.
  */
  "code,kbd,samp,pre": {
    fontFamily: `theme(fontFamily.mono, ${theme.fontFamily.mono})`,
    fontFeatureSettings: "theme(fontFamily.mono[1].fontFeatureSettings, normal)",
    fontSize: "1em"
  },
  /*
  Add the correct font size in all browsers.
  */
  small: {
    fontSize: "80%"
  },
  /*
  Prevent `sub` and `sup` elements from affecting the line height in all browsers.
  */
  "sub,sup": {
    fontSize: "75%",
    lineHeight: 0,
    position: "relative",
    verticalAlign: "baseline"
  },
  sub: {
    bottom: "-0.25em"
  },
  sup: {
    top: "-0.5em"
  },
  /*
  1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
  2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
  3. Remove gaps between table borders by default.
  */
  table: {
    textIndent: "0",
    /* 1 */
    borderColor: "inherit",
    /* 2 */
    borderCollapse: "collapse"
  },
  /* 3 */
  /*
  1. Change the font styles in all browsers.
  2. Remove the margin in Firefox and Safari.
  3. Remove default padding in all browsers.
  */
  "button,input,optgroup,select,textarea": {
    fontFamily: "inherit",
    /* 1 */
    fontSize: "100%",
    /* 1 */
    lineHeight: "inherit",
    /* 1 */
    color: "inherit",
    /* 1 */
    margin: "0",
    /* 2 */
    padding: "0"
  },
  /* 3 */
  /*
  Remove the inheritance of text transform in Edge and Firefox.
  */
  "button,select": {
    textTransform: "none"
  },
  /*
  1. Correct the inability to style clickable types in iOS and Safari.
  2. Remove default button styles.
  */
  "button,[type='button'],[type='reset'],[type='submit']": {
    WebkitAppearance: "button",
    /* 1 */
    backgroundColor: "transparent",
    /* 2 */
    backgroundImage: "none"
  },
  /* 4 */
  /*
  Use the modern Firefox focus style for all focusable elements.
  */
  ":-moz-focusring": {
    outline: "auto"
  },
  /*
  Remove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
  */
  ":-moz-ui-invalid": {
    boxShadow: "none"
  },
  /*
  Add the correct vertical alignment in Chrome and Firefox.
  */
  progress: {
    verticalAlign: "baseline"
  },
  /*
  Correct the cursor style of increment and decrement buttons in Safari.
  */
  "::-webkit-inner-spin-button,::-webkit-outer-spin-button": {
    height: "auto"
  },
  /*
  1. Correct the odd appearance in Chrome and Safari.
  2. Correct the outline style in Safari.
  */
  "[type='search']": {
    WebkitAppearance: "textfield",
    /* 1 */
    outlineOffset: "-2px"
  },
  /* 2 */
  /*
  Remove the inner padding in Chrome and Safari on macOS.
  */
  "::-webkit-search-decoration": {
    WebkitAppearance: "none"
  },
  /*
  1. Correct the inability to style clickable types in iOS and Safari.
  2. Change font properties to `inherit` in Safari.
  */
  "::-webkit-file-upload-button": {
    WebkitAppearance: "button",
    /* 1 */
    font: "inherit"
  },
  /* 2 */
  /*
  Add the correct display in Chrome and Safari.
  */
  summary: {
    display: "list-item"
  },
  /*
  Removes the default spacing and border for appropriate elements.
  */
  "blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre": {
    margin: "0"
  },
  fieldset: {
    margin: "0",
    padding: "0"
  },
  legend: {
    padding: "0"
  },
  "ol,ul,menu": {
    listStyle: "none",
    margin: "0",
    padding: "0"
  },
  /*
  Prevent resizing textareas horizontally by default.
  */
  textarea: {
    resize: "vertical"
  },
  /*
  1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
  2. Set the default placeholder color to the user's configured gray 400 color.
  */
  "input::placeholder,textarea::placeholder": {
    opacity: 1,
    /* 1 */
    color: "theme(colors.gray.400, #9ca3af)"
  },
  /* 2 */
  /*
  Set the default cursor for buttons.
  */
  'button,[role="button"]': {
    cursor: "pointer"
  },
  /*
  Make sure disabled buttons don't get the pointer cursor.
  */
  ":disabled": {
    cursor: "default"
  },
  /*
  1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)
  2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
    This can trigger a poorly considered lint error in some tools but is included by design.
  */
  "img,svg,video,canvas,audio,iframe,embed,object": {
    display: "block",
    /* 1 */
    verticalAlign: "middle"
  },
  /* 2 */
  /*
  Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
  */
  "img,video": {
    maxWidth: "100%",
    height: "auto"
  },
  /* Make elements with the HTML hidden attribute stay hidden by default */
  "[hidden]": {
    display: "none"
  }
}, rules = [
  /* arbitrary properties: [paint-order:markers] */
  match("\\[([-\\w]+):(.+)]", ({ 1: $e, 2: Ze }, Fe) => ({
    "@layer overrides": {
      "&": {
        [$e]: arbitrary(`[${Ze}]`, "", Fe)
      }
    }
  })),
  /* Styling based on parent and peer state */
  match("(group|peer)([~/][^-[]+)?", ({ input: $e }, { h: Ze }) => [
    {
      c: Ze($e)
    }
  ]),
  /* LAYOUT */
  matchTheme("aspect-", "aspectRatio"),
  match("container", ($e, { theme: Ze }) => {
    let { screens: Fe = Ze("screens"), center: Ke, padding: Ve } = Ze("container"), Je = {
      width: "100%",
      marginRight: Ke && "auto",
      marginLeft: Ke && "auto",
      ...Qe("xs")
    };
    for (let at in Fe) {
      let ut = Fe[at];
      typeof ut == "string" && (Je[mql(ut)] = {
        "&": {
          maxWidth: ut,
          ...Qe(at)
        }
      });
    }
    return Je;
    function Qe(at) {
      let ut = Ve && (typeof Ve == "string" ? Ve : Ve[at] || Ve.DEFAULT);
      if (ut)
        return {
          paddingRight: ut,
          paddingLeft: ut
        };
    }
  }),
  // Content
  matchTheme("content-", "content", ({ _: $e }) => ({
    "--tw-content": $e,
    content: "var(--tw-content)"
  })),
  // Box Decoration Break
  match("(?:box-)?decoration-(slice|clone)", "boxDecorationBreak"),
  // Box Sizing
  match("box-(border|content)", "boxSizing", ({ 1: $e }) => $e + "-box"),
  // Display
  match("hidden", {
    display: "none"
  }),
  // Table Layout
  match("table-(auto|fixed)", "tableLayout"),
  match([
    "(block|flex|table|grid|inline|contents|flow-root|list-item)",
    "(inline-(block|flex|table|grid))",
    "(table-(caption|cell|column|row|(column|row|footer|header)-group))"
  ], "display"),
  // Floats
  "(float)-(left|right|none)",
  // Clear
  "(clear)-(left|right|none|both)",
  // Overflow
  "(overflow(?:-[xy])?)-(auto|hidden|clip|visible|scroll)",
  // Isolation
  "(isolation)-(auto)",
  // Isolation
  match("isolate", "isolation"),
  // Object Fit
  match("object-(contain|cover|fill|none|scale-down)", "objectFit"),
  // Object Position
  matchTheme("object-", "objectPosition"),
  match("object-(top|bottom|center|(left|right)(-(top|bottom))?)", "objectPosition", spacify),
  // Overscroll Behavior
  match("overscroll(-[xy])?-(auto|contain|none)", ({ 1: $e = "", 2: Ze }) => ({
    ["overscroll-behavior" + $e]: Ze
  })),
  // Position
  match("(static|fixed|absolute|relative|sticky)", "position"),
  // Top / Right / Bottom / Left
  matchTheme("-?inset(-[xy])?(?:$|-)", "inset", ({ 1: $e, _: Ze }) => ({
    top: $e != "-x" && Ze,
    right: $e != "-y" && Ze,
    bottom: $e != "-x" && Ze,
    left: $e != "-y" && Ze
  })),
  matchTheme("-?(top|bottom|left|right)(?:$|-)", "inset"),
  // Visibility
  match("(visible|collapse)", "visibility"),
  match("invisible", {
    visibility: "hidden"
  }),
  // Z-Index
  matchTheme("-?z-", "zIndex"),
  /* FLEXBOX */
  // Flex Direction
  match("flex-((row|col)(-reverse)?)", "flexDirection", columnify),
  match("flex-(wrap|wrap-reverse|nowrap)", "flexWrap"),
  matchTheme("(flex-(?:grow|shrink))(?:$|-)"),
  /*, 'flex-grow' | flex-shrink */
  matchTheme("(flex)-"),
  /*, 'flex' */
  matchTheme("grow(?:$|-)", "flexGrow"),
  matchTheme("shrink(?:$|-)", "flexShrink"),
  matchTheme("basis-", "flexBasis"),
  matchTheme("-?(order)-"),
  /*, 'order' */
  "-?(order)-(\\d+)",
  /* GRID */
  // Grid Template Columns
  matchTheme("grid-cols-", "gridTemplateColumns"),
  match("grid-cols-(\\d+)", "gridTemplateColumns", gridTemplate),
  // Grid Column Start / End
  matchTheme("col-", "gridColumn"),
  match("col-(span)-(\\d+)", "gridColumn", span),
  matchTheme("col-start-", "gridColumnStart"),
  match("col-start-(auto|\\d+)", "gridColumnStart"),
  matchTheme("col-end-", "gridColumnEnd"),
  match("col-end-(auto|\\d+)", "gridColumnEnd"),
  // Grid Template Rows
  matchTheme("grid-rows-", "gridTemplateRows"),
  match("grid-rows-(\\d+)", "gridTemplateRows", gridTemplate),
  // Grid Row Start / End
  matchTheme("row-", "gridRow"),
  match("row-(span)-(\\d+)", "gridRow", span),
  matchTheme("row-start-", "gridRowStart"),
  match("row-start-(auto|\\d+)", "gridRowStart"),
  matchTheme("row-end-", "gridRowEnd"),
  match("row-end-(auto|\\d+)", "gridRowEnd"),
  // Grid Auto Flow
  match("grid-flow-((row|col)(-dense)?)", "gridAutoFlow", ($e) => spacify(columnify($e))),
  match("grid-flow-(dense)", "gridAutoFlow"),
  // Grid Auto Columns
  matchTheme("auto-cols-", "gridAutoColumns"),
  // Grid Auto Rows
  matchTheme("auto-rows-", "gridAutoRows"),
  // Gap
  matchTheme("gap-x(?:$|-)", "gap", "columnGap"),
  matchTheme("gap-y(?:$|-)", "gap", "rowGap"),
  matchTheme("gap(?:$|-)", "gap"),
  /* BOX ALIGNMENT */
  // Justify Items
  // Justify Self
  "(justify-(?:items|self))-",
  // Justify Content
  match("justify-", "justifyContent", convertContentValue),
  // Align Content
  // Align Items
  // Align Self
  match("(content|items|self)-", ($e) => ({
    ["align-" + $e[1]]: convertContentValue($e)
  })),
  // Place Content
  // Place Items
  // Place Self
  match("(place-(content|items|self))-", ({ 1: $e, $$: Ze }) => ({
    [$e]: ("wun".includes(Ze[3]) ? "space-" : "") + Ze
  })),
  /* SPACING */
  // Padding
  matchTheme("p([xytrbl])?(?:$|-)", "padding", edge("padding")),
  // Margin
  matchTheme("-?m([xytrbl])?(?:$|-)", "margin", edge("margin")),
  // Space Between
  matchTheme("-?space-(x|y)(?:$|-)", "space", ({ 1: $e, _: Ze }) => ({
    "&>:not([hidden])~:not([hidden])": {
      [`--tw-space-${$e}-reverse`]: "0",
      ["margin-" + {
        y: "top",
        x: "left"
      }[$e]]: `calc(${Ze} * calc(1 - var(--tw-space-${$e}-reverse)))`,
      ["margin-" + {
        y: "bottom",
        x: "right"
      }[$e]]: `calc(${Ze} * var(--tw-space-${$e}-reverse))`
    }
  })),
  match("space-(x|y)-reverse", ({ 1: $e }) => ({
    "&>:not([hidden])~:not([hidden])": {
      [`--tw-space-${$e}-reverse`]: "1"
    }
  })),
  /* SIZING */
  // Width
  matchTheme("w-", "width"),
  // Min-Width
  matchTheme("min-w-", "minWidth"),
  // Max-Width
  matchTheme("max-w-", "maxWidth"),
  // Height
  matchTheme("h-", "height"),
  // Min-Height
  matchTheme("min-h-", "minHeight"),
  // Max-Height
  matchTheme("max-h-", "maxHeight"),
  /* TYPOGRAPHY */
  // Font Weight
  matchTheme("font-", "fontWeight"),
  // Font Family
  matchTheme("font-", "fontFamily", ({ _: $e }) => typeof ($e = asArray($e))[1] == "string" ? {
    fontFamily: join($e)
  } : {
    fontFamily: join($e[0]),
    ...$e[1]
  }),
  // Font Smoothing
  match("antialiased", {
    WebkitFontSmoothing: "antialiased",
    MozOsxFontSmoothing: "grayscale"
  }),
  match("subpixel-antialiased", {
    WebkitFontSmoothing: "auto",
    MozOsxFontSmoothing: "auto"
  }),
  // Font Style
  match("italic", "fontStyle"),
  match("not-italic", {
    fontStyle: "normal"
  }),
  // Font Variant Numeric
  match("(ordinal|slashed-zero|(normal|lining|oldstyle|proportional|tabular)-nums|(diagonal|stacked)-fractions)", ({ 1: $e, 2: Ze = "", 3: Fe }) => (
    // normal-nums
    Ze == "normal" ? {
      fontVariantNumeric: "normal"
    } : {
      ["--tw-" + (Fe ? (
        // diagonal-fractions, stacked-fractions
        "numeric-fraction"
      ) : "pt".includes(Ze[0]) ? (
        // proportional-nums, tabular-nums
        "numeric-spacing"
      ) : Ze ? (
        // lining-nums, oldstyle-nums
        "numeric-figure"
      ) : (
        // ordinal, slashed-zero
        $e
      ))]: $e,
      fontVariantNumeric: "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)",
      ...asDefaults({
        "--tw-ordinal": "var(--tw-empty,/*!*/ /*!*/)",
        "--tw-slashed-zero": "var(--tw-empty,/*!*/ /*!*/)",
        "--tw-numeric-figure": "var(--tw-empty,/*!*/ /*!*/)",
        "--tw-numeric-spacing": "var(--tw-empty,/*!*/ /*!*/)",
        "--tw-numeric-fraction": "var(--tw-empty,/*!*/ /*!*/)"
      })
    }
  )),
  // Letter Spacing
  matchTheme("tracking-", "letterSpacing"),
  // Line Height
  matchTheme("leading-", "lineHeight"),
  // List Style Position
  match("list-(inside|outside)", "listStylePosition"),
  // List Style Type
  matchTheme("list-", "listStyleType"),
  match("list-", "listStyleType"),
  // Placeholder Opacity
  matchTheme("placeholder-opacity-", "placeholderOpacity", ({ _: $e }) => ({
    "&::placeholder": {
      "--tw-placeholder-opacity": $e
    }
  })),
  // Placeholder Color
  matchColor("placeholder-", {
    property: "color",
    selector: "&::placeholder"
  }),
  // Text Alignment
  match("text-(left|center|right|justify|start|end)", "textAlign"),
  match("text-(ellipsis|clip)", "textOverflow"),
  // Text Opacity
  matchTheme("text-opacity-", "textOpacity", "--tw-text-opacity"),
  // Text Color
  matchColor("text-", {
    property: "color"
  }),
  // Font Size
  matchTheme("text-", "fontSize", ({ _: $e }) => typeof $e == "string" ? {
    fontSize: $e
  } : {
    fontSize: $e[0],
    ...typeof $e[1] == "string" ? {
      lineHeight: $e[1]
    } : $e[1]
  }),
  // Text Indent
  matchTheme("indent-", "textIndent"),
  // Text Decoration
  match("(overline|underline|line-through)", "textDecorationLine"),
  match("no-underline", {
    textDecorationLine: "none"
  }),
  // Text Underline offset
  matchTheme("underline-offset-", "textUnderlineOffset"),
  // Text Decoration Color
  matchColor("decoration-", {
    section: "textDecorationColor",
    opacityVariable: !1,
    opacitySection: "opacity"
  }),
  // Text Decoration Thickness
  matchTheme("decoration-", "textDecorationThickness"),
  // Text Decoration Style
  match("decoration-", "textDecorationStyle"),
  // Text Transform
  match("(uppercase|lowercase|capitalize)", "textTransform"),
  match("normal-case", {
    textTransform: "none"
  }),
  // Text Overflow
  match("truncate", {
    overflow: "hidden",
    whiteSpace: "nowrap",
    textOverflow: "ellipsis"
  }),
  // Vertical Alignment
  match("align-", "verticalAlign"),
  // Whitespace
  match("whitespace-", "whiteSpace"),
  // Word Break
  match("break-normal", {
    wordBreak: "normal",
    overflowWrap: "normal"
  }),
  match("break-words", {
    overflowWrap: "break-word"
  }),
  match("break-all", {
    wordBreak: "break-all"
  }),
  match("break-keep", {
    wordBreak: "keep-all"
  }),
  // Caret Color
  matchColor("caret-", {
    // section: 'caretColor',
    opacityVariable: !1,
    opacitySection: "opacity"
  }),
  // Accent Color
  matchColor("accent-", {
    // section: 'accentColor',
    opacityVariable: !1,
    opacitySection: "opacity"
  }),
  // Gradient Color Stops
  match("bg-gradient-to-([trbl]|[tb][rl])", "backgroundImage", ({ 1: $e }) => `linear-gradient(to ${position($e, " ")},var(--tw-gradient-stops))`),
  matchColor("from-", {
    section: "gradientColorStops",
    opacityVariable: !1,
    opacitySection: "opacity"
  }, ({ _: $e }) => ({
    "--tw-gradient-from": $e.value,
    "--tw-gradient-to": $e.color({
      opacityValue: "0"
    }),
    "--tw-gradient-stops": "var(--tw-gradient-from),var(--tw-gradient-to)"
  })),
  matchColor("via-", {
    section: "gradientColorStops",
    opacityVariable: !1,
    opacitySection: "opacity"
  }, ({ _: $e }) => ({
    "--tw-gradient-to": $e.color({
      opacityValue: "0"
    }),
    "--tw-gradient-stops": `var(--tw-gradient-from),${$e.value},var(--tw-gradient-to)`
  })),
  matchColor("to-", {
    section: "gradientColorStops",
    property: "--tw-gradient-to",
    opacityVariable: !1,
    opacitySection: "opacity"
  }),
  /* BACKGROUNDS */
  // Background Attachment
  match("bg-(fixed|local|scroll)", "backgroundAttachment"),
  // Background Origin
  match("bg-origin-(border|padding|content)", "backgroundOrigin", ({ 1: $e }) => $e + "-box"),
  // Background Repeat
  match([
    "bg-(no-repeat|repeat(-[xy])?)",
    "bg-repeat-(round|space)"
  ], "backgroundRepeat"),
  // Background Blend Mode
  match("bg-blend-", "backgroundBlendMode"),
  // Background Clip
  match("bg-clip-(border|padding|content|text)", "backgroundClip", ({ 1: $e }) => $e + ($e == "text" ? "" : "-box")),
  // Background Opacity
  matchTheme("bg-opacity-", "backgroundOpacity", "--tw-bg-opacity"),
  // Background Color
  // bg-${backgroundColor}/${backgroundOpacity}
  matchColor("bg-", {
    section: "backgroundColor"
  }),
  // Background Image
  // supported arbitrary types are: length, color, angle, list
  matchTheme("bg-", "backgroundImage"),
  // Background Position
  matchTheme("bg-", "backgroundPosition"),
  match("bg-(top|bottom|center|(left|right)(-(top|bottom))?)", "backgroundPosition", spacify),
  // Background Size
  matchTheme("bg-", "backgroundSize"),
  /* BORDERS */
  // Border Radius
  matchTheme("rounded(?:$|-)", "borderRadius"),
  matchTheme("rounded-([trbl]|[tb][rl])(?:$|-)", "borderRadius", ({ 1: $e, _: Ze }) => {
    let Fe = {
      t: [
        "tl",
        "tr"
      ],
      r: [
        "tr",
        "br"
      ],
      b: [
        "bl",
        "br"
      ],
      l: [
        "bl",
        "tl"
      ]
    }[$e] || [
      $e,
      $e
    ];
    return {
      [`border-${position(Fe[0])}-radius`]: Ze,
      [`border-${position(Fe[1])}-radius`]: Ze
    };
  }),
  // Border Collapse
  match("border-(collapse|separate)", "borderCollapse"),
  // Border Opacity
  matchTheme("border-opacity(?:$|-)", "borderOpacity", "--tw-border-opacity"),
  // Border Style
  match("border-(solid|dashed|dotted|double|none)", "borderStyle"),
  // Border Spacing
  matchTheme("border-spacing(-[xy])?(?:$|-)", "borderSpacing", ({ 1: $e, _: Ze }) => ({
    ...asDefaults({
      "--tw-border-spacing-x": "0",
      "--tw-border-spacing-y": "0"
    }),
    ["--tw-border-spacing" + ($e || "-x")]: Ze,
    ["--tw-border-spacing" + ($e || "-y")]: Ze,
    "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
  })),
  // Border Color
  matchColor("border-([xytrbl])-", {
    section: "borderColor"
  }, edge("border", "Color")),
  matchColor("border-"),
  // Border Width
  matchTheme("border-([xytrbl])(?:$|-)", "borderWidth", edge("border", "Width")),
  matchTheme("border(?:$|-)", "borderWidth"),
  // Divide Opacity
  matchTheme("divide-opacity(?:$|-)", "divideOpacity", ({ _: $e }) => ({
    "&>:not([hidden])~:not([hidden])": {
      "--tw-divide-opacity": $e
    }
  })),
  // Divide Style
  match("divide-(solid|dashed|dotted|double|none)", ({ 1: $e }) => ({
    "&>:not([hidden])~:not([hidden])": {
      borderStyle: $e
    }
  })),
  // Divide Width
  match("divide-([xy]-reverse)", ({ 1: $e }) => ({
    "&>:not([hidden])~:not([hidden])": {
      ["--tw-divide-" + $e]: "1"
    }
  })),
  matchTheme("divide-([xy])(?:$|-)", "divideWidth", ({ 1: $e, _: Ze }) => {
    let Fe = {
      x: "lr",
      y: "tb"
    }[$e];
    return {
      "&>:not([hidden])~:not([hidden])": {
        [`--tw-divide-${$e}-reverse`]: "0",
        [`border-${position(Fe[0])}Width`]: `calc(${Ze} * calc(1 - var(--tw-divide-${$e}-reverse)))`,
        [`border-${position(Fe[1])}Width`]: `calc(${Ze} * var(--tw-divide-${$e}-reverse))`
      }
    };
  }),
  // Divide Color
  matchColor("divide-", {
    // section: $0.replace('-', 'Color') -> 'divideColor'
    property: "borderColor",
    // opacityVariable: '--tw-border-opacity',
    // opacitySection: section.replace('Color', 'Opacity') -> 'divideOpacity'
    selector: "&>:not([hidden])~:not([hidden])"
  }),
  // Ring Offset Opacity
  matchTheme("ring-opacity(?:$|-)", "ringOpacity", "--tw-ring-opacity"),
  // Ring Offset Color
  matchColor("ring-offset-", {
    // section: 'ringOffsetColor',
    property: "--tw-ring-offset-color",
    opacityVariable: !1
  }),
  // opacitySection: section.replace('Color', 'Opacity') -> 'ringOffsetOpacity'
  // Ring Offset Width
  matchTheme("ring-offset(?:$|-)", "ringOffsetWidth", "--tw-ring-offset-width"),
  // Ring Inset
  match("ring-inset", {
    "--tw-ring-inset": "inset"
  }),
  // Ring Color
  matchColor("ring-", {
    // section: 'ringColor',
    property: "--tw-ring-color"
  }),
  // opacityVariable: '--tw-ring-opacity',
  // opacitySection: section.replace('Color', 'Opacity') -> 'ringOpacity'
  // Ring Width
  matchTheme("ring(?:$|-)", "ringWidth", ({ _: $e }, { theme: Ze }) => ({
    ...asDefaults({
      "--tw-ring-offset-shadow": "0 0 #0000",
      "--tw-ring-shadow": "0 0 #0000",
      "--tw-shadow": "0 0 #0000",
      "--tw-shadow-colored": "0 0 #0000",
      // Within own declaration to have the defaults above to be merged with defaults from shadow
      "&": {
        "--tw-ring-inset": "var(--tw-empty,/*!*/ /*!*/)",
        "--tw-ring-offset-width": Ze("ringOffsetWidth", "", "0px"),
        "--tw-ring-offset-color": toColorValue(Ze("ringOffsetColor", "", "#fff")),
        "--tw-ring-color": toColorValue(Ze("ringColor", "", "#93c5fd"), {
          opacityVariable: "--tw-ring-opacity"
        }),
        "--tw-ring-opacity": Ze("ringOpacity", "", "0.5")
      }
    }),
    "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)",
    "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${$e} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
    boxShadow: "var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)"
  })),
  /* EFFECTS */
  // Box Shadow Color
  matchColor("shadow-", {
    section: "boxShadowColor",
    opacityVariable: !1,
    opacitySection: "opacity"
  }, ({ _: $e }) => ({
    "--tw-shadow-color": $e.value,
    "--tw-shadow": "var(--tw-shadow-colored)"
  })),
  // Box Shadow
  matchTheme("shadow(?:$|-)", "boxShadow", ({ _: $e }) => ({
    ...asDefaults({
      "--tw-ring-offset-shadow": "0 0 #0000",
      "--tw-ring-shadow": "0 0 #0000",
      "--tw-shadow": "0 0 #0000",
      "--tw-shadow-colored": "0 0 #0000"
    }),
    "--tw-shadow": join($e),
    // replace all colors with reference to --tw-shadow-colored
    // this matches colors after non-comma char (keyword, offset) before comma or the end
    "--tw-shadow-colored": join($e).replace(/([^,]\s+)(?:#[a-f\d]+|(?:(?:hsl|rgb)a?|hwb|lab|lch|color|var)\(.+?\)|[a-z]+)(,|$)/g, "$1var(--tw-shadow-color)$2"),
    boxShadow: "var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)"
  })),
  // Opacity
  matchTheme("(opacity)-"),
  /*, 'opacity' */
  // Mix Blend Mode
  match("mix-blend-", "mixBlendMode"),
  /* FILTERS */
  ...filter(),
  ...filter("backdrop-"),
  /* TRANSITIONS AND ANIMATION */
  // Transition Property
  matchTheme("transition(?:$|-)", "transitionProperty", ($e, { theme: Ze }) => ({
    transitionProperty: join($e),
    transitionTimingFunction: $e._ == "none" ? void 0 : join(Ze("transitionTimingFunction", "")),
    transitionDuration: $e._ == "none" ? void 0 : join(Ze("transitionDuration", ""))
  })),
  // Transition Duration
  matchTheme("duration(?:$|-)", "transitionDuration", "transitionDuration", join),
  // Transition Timing Function
  matchTheme("ease(?:$|-)", "transitionTimingFunction", "transitionTimingFunction", join),
  // Transition Delay
  matchTheme("delay(?:$|-)", "transitionDelay", "transitionDelay", join),
  matchTheme("animate(?:$|-)", "animation", ($e, { theme: Ze, h: Fe, e: Ke }) => {
    let Ve = join($e), Je = Ve.split(" "), Qe = Ze("keyframes", Je[0]);
    return Qe ? {
      ["@keyframes " + (Je[0] = Ke(Fe(Je[0])))]: Qe,
      animation: Je.join(" ")
    } : {
      animation: Ve
    };
  }),
  /* TRANSFORMS */
  // Transform
  "(transform)-(none)",
  match("transform", tranformDefaults),
  match("transform-(cpu|gpu)", ({ 1: $e }) => ({
    "--tw-transform": transformValue($e == "gpu")
  })),
  // Scale
  matchTheme("scale(-[xy])?-", "scale", ({ 1: $e, _: Ze }) => ({
    ["--tw-scale" + ($e || "-x")]: Ze,
    ["--tw-scale" + ($e || "-y")]: Ze,
    ...tranformDefaults()
  })),
  // Rotate
  matchTheme("-?(rotate)-", "rotate", transform),
  // Translate
  matchTheme("-?(translate-[xy])-", "translate", transform),
  // Skew
  matchTheme("-?(skew-[xy])-", "skew", transform),
  // Transform Origin
  match("origin-(center|((top|bottom)(-(left|right))?)|left|right)", "transformOrigin", spacify),
  /* INTERACTIVITY */
  // Appearance
  "(appearance)-",
  // Columns
  matchTheme("(columns)-"),
  /*, 'columns' */
  "(columns)-(\\d+)",
  // Break Before, After and Inside
  "(break-(?:before|after|inside))-",
  // Cursor
  matchTheme("(cursor)-"),
  /*, 'cursor' */
  "(cursor)-",
  // Scroll Snap Type
  match("snap-(none)", "scroll-snap-type"),
  match("snap-(x|y|both)", ({ 1: $e }) => ({
    ...asDefaults({
      "--tw-scroll-snap-strictness": "proximity"
    }),
    "scroll-snap-type": $e + " var(--tw-scroll-snap-strictness)"
  })),
  match("snap-(mandatory|proximity)", "--tw-scroll-snap-strictness"),
  // Scroll Snap Align
  match("snap-(?:(start|end|center)|align-(none))", "scroll-snap-align"),
  // Scroll Snap Stop
  match("snap-(normal|always)", "scroll-snap-stop"),
  match("scroll-(auto|smooth)", "scroll-behavior"),
  // Scroll Margin
  // Padding
  matchTheme("scroll-p([xytrbl])?(?:$|-)", "padding", edge("scroll-padding")),
  // Margin
  matchTheme("-?scroll-m([xytrbl])?(?:$|-)", "scroll-margin", edge("scroll-margin")),
  // Touch Action
  match("touch-(auto|none|manipulation)", "touch-action"),
  match("touch-(pinch-zoom|pan-(?:(x|left|right)|(y|up|down)))", ({ 1: $e, 2: Ze, 3: Fe }) => ({
    ...asDefaults({
      "--tw-pan-x": "var(--tw-empty,/*!*/ /*!*/)",
      "--tw-pan-y": "var(--tw-empty,/*!*/ /*!*/)",
      "--tw-pinch-zoom": "var(--tw-empty,/*!*/ /*!*/)",
      "--tw-touch-action": "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)"
    }),
    // x, left, right -> pan-x
    // y, up, down -> pan-y
    // -> pinch-zoom
    [`--tw-${Ze ? "pan-x" : Fe ? "pan-y" : $e}`]: $e,
    "touch-action": "var(--tw-touch-action)"
  })),
  // Outline Style
  match("outline-none", {
    outline: "2px solid transparent",
    "outline-offset": "2px"
  }),
  match("outline", {
    outlineStyle: "solid"
  }),
  match("outline-(dashed|dotted|double)", "outlineStyle"),
  // Outline Offset
  matchTheme("-?(outline-offset)-"),
  /*, 'outlineOffset'*/
  // Outline Color
  matchColor("outline-", {
    opacityVariable: !1,
    opacitySection: "opacity"
  }),
  // Outline Width
  matchTheme("outline-", "outlineWidth"),
  // Pointer Events
  "(pointer-events)-",
  // Will Change
  matchTheme("(will-change)-"),
  /*, 'willChange' */
  "(will-change)-",
  // Resize
  [
    "resize(?:-(none|x|y))?",
    "resize",
    ({ 1: $e }) => ({
      x: "horizontal",
      y: "vertical"
    })[$e] || $e || "both"
  ],
  // User Select
  match("select-(none|text|all|auto)", "userSelect"),
  /* SVG */
  // Fill, Stroke
  matchColor("fill-", {
    section: "fill",
    opacityVariable: !1,
    opacitySection: "opacity"
  }),
  matchColor("stroke-", {
    section: "stroke",
    opacityVariable: !1,
    opacitySection: "opacity"
  }),
  // Stroke Width
  matchTheme("stroke-", "strokeWidth"),
  /* ACCESSIBILITY */
  // Screen Readers
  match("sr-only", {
    position: "absolute",
    width: "1px",
    height: "1px",
    padding: "0",
    margin: "-1px",
    overflow: "hidden",
    whiteSpace: "nowrap",
    clip: "rect(0,0,0,0)",
    borderWidth: "0"
  }),
  match("not-sr-only", {
    position: "static",
    width: "auto",
    height: "auto",
    padding: "0",
    margin: "0",
    overflow: "visible",
    whiteSpace: "normal",
    clip: "auto"
  })
];
function spacify($e) {
  return (typeof $e == "string" ? $e : $e[1]).replace(/-/g, " ").trim();
}
function columnify($e) {
  return (typeof $e == "string" ? $e : $e[1]).replace("col", "column");
}
function position($e, Ze = "-") {
  let Fe = [];
  for (let Ke of $e)
    Fe.push({
      t: "top",
      r: "right",
      b: "bottom",
      l: "left"
    }[Ke]);
  return Fe.join(Ze);
}
function join($e) {
  return $e && "" + ($e._ || $e);
}
function convertContentValue({ $$: $e }) {
  return ({
    // /* aut*/ o: '',
    /* sta*/
    r: (
      /*t*/
      "flex-"
    ),
    /* end*/
    "": "flex-",
    // /* cen*/ t /*er*/: '',
    /* bet*/
    w: (
      /*een*/
      "space-"
    ),
    /* aro*/
    u: (
      /*nd*/
      "space-"
    ),
    /* eve*/
    n: (
      /*ly*/
      "space-"
    )
  }[$e[3] || ""] || "") + $e;
}
function edge($e, Ze = "") {
  return ({ 1: Fe, _: Ke }) => {
    let Ve = {
      x: "lr",
      y: "tb"
    }[Fe] || Fe + Fe;
    return Ve ? {
      ...toCSS($e + "-" + position(Ve[0]) + Ze, Ke),
      ...toCSS($e + "-" + position(Ve[1]) + Ze, Ke)
    } : toCSS($e + Ze, Ke);
  };
}
function filter($e = "") {
  let Ze = [
    "blur",
    "brightness",
    "contrast",
    "grayscale",
    "hue-rotate",
    "invert",
    $e && "opacity",
    "saturate",
    "sepia",
    !$e && "drop-shadow"
  ].filter(Boolean), Fe = {};
  for (let Ke of Ze)
    Fe[`--tw-${$e}${Ke}`] = "var(--tw-empty,/*!*/ /*!*/)";
  return Fe = {
    // move defaults
    ...asDefaults(Fe),
    // add default filter which allows standalone usage
    [`${$e}filter`]: Ze.map((Ke) => `var(--tw-${$e}${Ke})`).join(" ")
  }, [
    `(${$e}filter)-(none)`,
    match(`${$e}filter`, Fe),
    ...Ze.map((Ke) => matchTheme(
      // hue-rotate can be negated
      `${Ke[0] == "h" ? "-?" : ""}(${$e}${Ke})(?:$|-)`,
      Ke,
      ({ 1: Ve, _: Je }) => ({
        [`--tw-${Ve}`]: asArray(Je).map((Qe) => `${Ke}(${Qe})`).join(" "),
        ...Fe
      })
    ))
  ];
}
function transform({ 1: $e, _: Ze }) {
  return {
    ["--tw-" + $e]: Ze,
    ...tranformDefaults()
  };
}
function tranformDefaults() {
  return {
    ...asDefaults({
      "--tw-translate-x": "0",
      "--tw-translate-y": "0",
      "--tw-rotate": "0",
      "--tw-skew-x": "0",
      "--tw-skew-y": "0",
      "--tw-scale-x": "1",
      "--tw-scale-y": "1",
      "--tw-transform": transformValue()
    }),
    transform: "var(--tw-transform)"
  };
}
function transformValue($e) {
  return [
    $e ? (
      // -gpu
      "translate3d(var(--tw-translate-x),var(--tw-translate-y),0)"
    ) : "translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y))",
    "rotate(var(--tw-rotate))",
    "skewX(var(--tw-skew-x))",
    "skewY(var(--tw-skew-y))",
    "scaleX(var(--tw-scale-x))",
    "scaleY(var(--tw-scale-y))"
  ].join(" ");
}
function span({ 1: $e, 2: Ze }) {
  return `${$e} ${Ze} / ${$e} ${Ze}`;
}
function gridTemplate({ 1: $e }) {
  return `repeat(${$e},minmax(0,1fr))`;
}
function asDefaults($e) {
  return {
    "@layer defaults": {
      "*,::before,::after": $e,
      "::backdrop": $e
    }
  };
}
let variants = [
  [
    "sticky",
    "@supports ((position: -webkit-sticky) or (position:sticky))"
  ],
  [
    "motion-reduce",
    "@media (prefers-reduced-motion:reduce)"
  ],
  [
    "motion-safe",
    "@media (prefers-reduced-motion:no-preference)"
  ],
  [
    "print",
    "@media print"
  ],
  [
    "(portrait|landscape)",
    ({ 1: $e }) => `@media (orientation:${$e})`
  ],
  [
    "contrast-(more|less)",
    ({ 1: $e }) => `@media (prefers-contrast:${$e})`
  ],
  [
    "(first-(letter|line)|placeholder|backdrop|before|after)",
    ({ 1: $e }) => `&::${$e}`
  ],
  [
    "(marker|selection)",
    ({ 1: $e }) => `& *::${$e},&::${$e}`
  ],
  [
    "file",
    "&::file-selector-button"
  ],
  [
    "(first|last|only)",
    ({ 1: $e }) => `&:${$e}-child`
  ],
  [
    "even",
    "&:nth-child(2n)"
  ],
  [
    "odd",
    "&:nth-child(odd)"
  ],
  [
    "open",
    "&[open]"
  ],
  // All other pseudo classes are already supported by twind
  [
    "(aria|data)-",
    ({
      1: $e,
      /* aria or data */
      $$: Ze
    }, Fe) => Ze && `&[${$e}-${// aria-asc or data-checked -> from theme
    Fe.theme($e, Ze) || // aria-[...] or data-[...]
    arbitrary(Ze, "", Fe) || // default handling
    `${Ze}="true"`}]`
  ],
  /* Styling based on parent and peer state */
  // Groups classes like: group-focus and group-hover
  // these need to add a marker selector with the pseudo class
  // => '.group:focus .group-focus:selector'
  [
    "((group|peer)(~[^-[]+)?)(-\\[(.+)]|[-[].+?)(\\/.+)?",
    ({ 2: $e, 3: Ze = "", 4: Fe, 5: Ke = "", 6: Ve = Ze }, { e: Je, h: Qe, v: at }) => {
      let ut = normalize(Ke) || (Fe[0] == "[" ? Fe : at(Fe.slice(1)));
      return `${(ut.includes("&") ? ut : "&" + ut).replace(/&/g, `:merge(.${Je(Qe($e + Ve))})`)}${$e[0] == "p" ? "~" : " "}&`;
    }
  ],
  // direction variants
  [
    "(ltr|rtl)",
    ({ 1: $e }) => `[dir="${$e}"] &`
  ],
  [
    "supports-",
    ({ $$: $e }, Ze) => {
      if ($e && ($e = Ze.theme("supports", $e) || arbitrary($e, "", Ze)), $e)
        return $e.includes(":") || ($e += ":var(--tw)"), /^\w*\s*\(/.test($e) || ($e = `(${$e})`), // Chrome has a bug where `(condtion1)or(condition2)` is not valid
        // But `(condition1) or (condition2)` is supported.
        `@supports ${$e.replace(/\b(and|or|not)\b/g, " $1 ").trim()}`;
    }
  ],
  [
    "max-",
    ({ $$: $e }, Ze) => {
      if ($e && ($e = Ze.theme("screens", $e) || arbitrary($e, "", Ze)), typeof $e == "string")
        return `@media not all and (min-width:${$e})`;
    }
  ],
  [
    "min-",
    ({ $$: $e }, Ze) => ($e && ($e = arbitrary($e, "", Ze)), $e && `@media (min-width:${$e})`)
  ],
  // Arbitrary variants
  [
    /^\[(.+)]$/,
    ({ 1: $e }) => /[&@]/.test($e) && normalize($e).replace(/[}]+$/, "").split("{")
  ]
];
function presetTailwindBase({ colors: $e, disablePreflight: Ze } = {}) {
  return {
    // allow other preflight to run
    preflight: Ze ? void 0 : preflight,
    theme: {
      ...theme,
      colors: {
        inherit: "inherit",
        current: "currentColor",
        transparent: "transparent",
        black: "#000",
        white: "#fff",
        ...$e
      }
    },
    variants,
    rules,
    finalize(Fe) {
      return (
        // automatically add `content: ''` to before and after so you don’t have to specify it unless you want a different value
        // ignore global, preflight, and auto added rules
        Fe.n && // only if there are declarations
        Fe.d && // and it has a ::before or ::after selector
        Fe.r.some((Ke) => /^&::(before|after)$/.test(Ke)) && // there is no content property yet
        !/(^|;)content:/.test(Fe.d) ? {
          ...Fe,
          d: "content:var(--tw-content);" + Fe.d
        } : Fe
      );
    }
  };
}
let slate$1 = {
  50: "#f8fafc",
  100: "#f1f5f9",
  200: "#e2e8f0",
  300: "#cbd5e1",
  400: "#94a3b8",
  500: "#64748b",
  600: "#475569",
  700: "#334155",
  800: "#1e293b",
  900: "#0f172a"
}, gray$1 = {
  50: "#f9fafb",
  100: "#f3f4f6",
  200: "#e5e7eb",
  300: "#d1d5db",
  400: "#9ca3af",
  500: "#6b7280",
  600: "#4b5563",
  700: "#374151",
  800: "#1f2937",
  900: "#111827"
}, zinc = {
  50: "#fafafa",
  100: "#f4f4f5",
  200: "#e4e4e7",
  300: "#d4d4d8",
  400: "#a1a1aa",
  500: "#71717a",
  600: "#52525b",
  700: "#3f3f46",
  800: "#27272a",
  900: "#18181b"
}, neutral = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#e5e5e5",
  300: "#d4d4d4",
  400: "#a3a3a3",
  500: "#737373",
  600: "#525252",
  700: "#404040",
  800: "#262626",
  900: "#171717"
}, stone = {
  50: "#fafaf9",
  100: "#f5f5f4",
  200: "#e7e5e4",
  300: "#d6d3d1",
  400: "#a8a29e",
  500: "#78716c",
  600: "#57534e",
  700: "#44403c",
  800: "#292524",
  900: "#1c1917"
}, red$1 = {
  50: "#fef2f2",
  100: "#fee2e2",
  200: "#fecaca",
  300: "#fca5a5",
  400: "#f87171",
  500: "#ef4444",
  600: "#dc2626",
  700: "#b91c1c",
  800: "#991b1b",
  900: "#7f1d1d"
}, orange$1 = {
  50: "#fff7ed",
  100: "#ffedd5",
  200: "#fed7aa",
  300: "#fdba74",
  400: "#fb923c",
  500: "#f97316",
  600: "#ea580c",
  700: "#c2410c",
  800: "#9a3412",
  900: "#7c2d12"
}, amber$1 = {
  50: "#fffbeb",
  100: "#fef3c7",
  200: "#fde68a",
  300: "#fcd34d",
  400: "#fbbf24",
  500: "#f59e0b",
  600: "#d97706",
  700: "#b45309",
  800: "#92400e",
  900: "#78350f"
}, yellow$1 = {
  50: "#fefce8",
  100: "#fef9c3",
  200: "#fef08a",
  300: "#fde047",
  400: "#facc15",
  500: "#eab308",
  600: "#ca8a04",
  700: "#a16207",
  800: "#854d0e",
  900: "#713f12"
}, lime$1 = {
  50: "#f7fee7",
  100: "#ecfccb",
  200: "#d9f99d",
  300: "#bef264",
  400: "#a3e635",
  500: "#84cc16",
  600: "#65a30d",
  700: "#4d7c0f",
  800: "#3f6212",
  900: "#365314"
}, green$1 = {
  50: "#f0fdf4",
  100: "#dcfce7",
  200: "#bbf7d0",
  300: "#86efac",
  400: "#4ade80",
  500: "#22c55e",
  600: "#16a34a",
  700: "#15803d",
  800: "#166534",
  900: "#14532d"
}, emerald = {
  50: "#ecfdf5",
  100: "#d1fae5",
  200: "#a7f3d0",
  300: "#6ee7b7",
  400: "#34d399",
  500: "#10b981",
  600: "#059669",
  700: "#047857",
  800: "#065f46",
  900: "#064e3b"
}, teal$1 = {
  50: "#f0fdfa",
  100: "#ccfbf1",
  200: "#99f6e4",
  300: "#5eead4",
  400: "#2dd4bf",
  500: "#14b8a6",
  600: "#0d9488",
  700: "#0f766e",
  800: "#115e59",
  900: "#134e4a"
}, cyan$1 = {
  50: "#ecfeff",
  100: "#cffafe",
  200: "#a5f3fc",
  300: "#67e8f9",
  400: "#22d3ee",
  500: "#06b6d4",
  600: "#0891b2",
  700: "#0e7490",
  800: "#155e75",
  900: "#164e63"
}, sky = {
  50: "#f0f9ff",
  100: "#e0f2fe",
  200: "#bae6fd",
  300: "#7dd3fc",
  400: "#38bdf8",
  500: "#0ea5e9",
  600: "#0284c7",
  700: "#0369a1",
  800: "#075985",
  900: "#0c4a6e"
}, blue$1 = {
  50: "#eff6ff",
  100: "#dbeafe",
  200: "#bfdbfe",
  300: "#93c5fd",
  400: "#60a5fa",
  500: "#3b82f6",
  600: "#2563eb",
  700: "#1d4ed8",
  800: "#1e40af",
  900: "#1e3a8a"
}, indigo$1 = {
  50: "#eef2ff",
  100: "#e0e7ff",
  200: "#c7d2fe",
  300: "#a5b4fc",
  400: "#818cf8",
  500: "#6366f1",
  600: "#4f46e5",
  700: "#4338ca",
  800: "#3730a3",
  900: "#312e81"
}, violet$1 = {
  50: "#f5f3ff",
  100: "#ede9fe",
  200: "#ddd6fe",
  300: "#c4b5fd",
  400: "#a78bfa",
  500: "#8b5cf6",
  600: "#7c3aed",
  700: "#6d28d9",
  800: "#5b21b6",
  900: "#4c1d95"
}, purple$1 = {
  50: "#faf5ff",
  100: "#f3e8ff",
  200: "#e9d5ff",
  300: "#d8b4fe",
  400: "#c084fc",
  500: "#a855f7",
  600: "#9333ea",
  700: "#7e22ce",
  800: "#6b21a8",
  900: "#581c87"
}, fuchsia = {
  50: "#fdf4ff",
  100: "#fae8ff",
  200: "#f5d0fe",
  300: "#f0abfc",
  400: "#e879f9",
  500: "#d946ef",
  600: "#c026d3",
  700: "#a21caf",
  800: "#86198f",
  900: "#701a75"
}, pink$1 = {
  50: "#fdf2f8",
  100: "#fce7f3",
  200: "#fbcfe8",
  300: "#f9a8d4",
  400: "#f472b6",
  500: "#ec4899",
  600: "#db2777",
  700: "#be185d",
  800: "#9d174d",
  900: "#831843"
}, rose = {
  50: "#fff1f2",
  100: "#ffe4e6",
  200: "#fecdd3",
  300: "#fda4af",
  400: "#fb7185",
  500: "#f43f5e",
  600: "#e11d48",
  700: "#be123c",
  800: "#9f1239",
  900: "#881337"
}, colors = {
  __proto__: null,
  slate: slate$1,
  gray: gray$1,
  zinc,
  neutral,
  stone,
  red: red$1,
  orange: orange$1,
  amber: amber$1,
  yellow: yellow$1,
  lime: lime$1,
  green: green$1,
  emerald,
  teal: teal$1,
  cyan: cyan$1,
  sky,
  blue: blue$1,
  indigo: indigo$1,
  violet: violet$1,
  purple: purple$1,
  fuchsia,
  pink: pink$1,
  rose
};
function presetTailwind({ disablePreflight: $e } = {}) {
  return presetTailwindBase({
    colors,
    disablePreflight: $e
  });
}
function presetContainerQueries() {
  return {
    theme: {
      containers: {
        xs: "20rem",
        sm: "24rem",
        md: "28rem",
        lg: "32rem",
        xl: "36rem",
        "2xl": "42rem",
        "3xl": "48rem",
        "4xl": "56rem",
        "5xl": "64rem",
        "6xl": "72rem",
        "7xl": "80rem"
      }
    },
    rules: [
      [
        "@container($|-|\\/)",
        ({ 1: $e, $$: Ze }, Fe) => {
          let [Ke = "", Ve] = $e == "/" ? [
            ,
            Ze
          ] : parseValue(Ze), Je = arbitrary(Ke, "", Fe) || Ke || "inline-size";
          return Ve ? {
            container: `${Ve} / ${Je}`
          } : {
            "container-type": Je
          };
        }
      ]
    ],
    variants: [
      [
        "@(.+)",
        ($e, Ze) => {
          let [Fe, Ke] = parseValue($e[1]);
          if (Fe) {
            let Ve = Ze.theme("containers", Fe) || arbitrary(Fe, "containers", Ze);
            return Ve && `@container ${Ke ? Ke + " " : ""}(min-width:${Ve})`;
          }
        }
      ]
    ]
  };
}
const config = defineConfig({
  hash: !0,
  presets: [presetAutoprefix(), presetTailwind(), presetContainerQueries()],
  theme: {
    fontFamily: {
      sans: ["Inter", "sans-serif"],
      rubik: ["Rubik", "sans-serif"],
      plex: ["IBM Plex Sans", "sans-serif"],
      mono: ["Fira Code", "monospace"]
    },
    extend: {
      keyframes: {
        jump: {
          "0%, 40%": {
            transform: "translateY(0%) scale(1)"
          },
          "20%": {
            transform: "translateY(-100%) scale(1.11)"
          }
        }
      },
      animation: {
        jump: "jump 1.5s ease-in infinite"
      }
    }
  }
}), tw = twind(config, cssom("style[data-library]"));
tx.bind(tw);
injectGlobal.bind(tw);
keyframes.bind(tw);
const StyleOptionSchema = z$d.object({
  className: z$d.string().optional().transform(($e) => {
    if ($e)
      return tw($e);
  }),
  style: z$d.object({}).passthrough().optional().transform(($e) => {
    if ($e)
      return $e;
  })
}), AvatarSchema = z$d.object({
  container: StyleOptionSchema.optional(),
  image: StyleOptionSchema.optional(),
  fallback: StyleOptionSchema.optional()
}), BlocksSchema = z$d.object({
  button: StyleOptionSchema.optional(),
  text: z$d.record(z$d.enum(markdownTypes), StyleOptionSchema.optional()),
  image: z$d.object({
    image: StyleOptionSchema.optional(),
    placeholder: StyleOptionSchema.optional()
  }).optional(),
  audio: StyleOptionSchema.optional(),
  video: StyleOptionSchema.optional(),
  file: z$d.object({
    container: StyleOptionSchema.optional(),
    title: StyleOptionSchema.optional(),
    icon: StyleOptionSchema.optional()
  }).optional(),
  location: z$d.object({
    container: StyleOptionSchema.optional(),
    title: StyleOptionSchema.optional(),
    icon: StyleOptionSchema.optional()
  }).optional(),
  column: StyleOptionSchema.optional(),
  row: StyleOptionSchema.optional(),
  bubble: StyleOptionSchema.optional(),
  carousel: z$d.object({
    container: StyleOptionSchema.optional(),
    slidesContainer: StyleOptionSchema.optional(),
    backButton: StyleOptionSchema.optional(),
    nextButton: StyleOptionSchema.optional()
  }).optional(),
  dropdown: z$d.object({
    button: z$d.object({
      container: StyleOptionSchema.optional(),
      icon: StyleOptionSchema.optional(),
      text: StyleOptionSchema.optional()
    }).optional(),
    content: z$d.object({
      container: StyleOptionSchema.optional(),
      item: StyleOptionSchema.optional()
    }).optional()
  }).optional()
}), ThemeSchema = z$d.object({
  container: StyleOptionSchema.optional(),
  modal: z$d.object({
    overlay: StyleOptionSchema.optional(),
    container: StyleOptionSchema.optional(),
    dialog: z$d.object({
      container: StyleOptionSchema.optional(),
      title: z$d.object({
        container: StyleOptionSchema.optional(),
        text: StyleOptionSchema.optional(),
        closeIcon: StyleOptionSchema.optional()
      }).optional(),
      content: StyleOptionSchema.optional(),
      newConversation: z$d.object({
        text: StyleOptionSchema.optional(),
        button: StyleOptionSchema.optional()
      }).optional()
    }).optional()
  }).optional(),
  notification: z$d.object({
    container: StyleOptionSchema.optional(),
    title: StyleOptionSchema.optional(),
    description: StyleOptionSchema.optional(),
    icon: StyleOptionSchema.optional(),
    closeIcon: StyleOptionSchema.optional()
  }).optional(),
  header: z$d.object({
    container: StyleOptionSchema.optional(),
    content: z$d.object({
      container: StyleOptionSchema.optional(),
      title: StyleOptionSchema.optional(),
      description: StyleOptionSchema.optional(),
      avatar: AvatarSchema.optional(),
      actions: z$d.object({
        container: StyleOptionSchema.optional(),
        icons: StyleOptionSchema.optional()
      }).optional()
    }),
    expandedContent: z$d.object({
      container: StyleOptionSchema.optional(),
      descriptionItems: z$d.object({
        container: StyleOptionSchema.optional(),
        icon: StyleOptionSchema.optional(),
        text: StyleOptionSchema.optional(),
        link: StyleOptionSchema.optional()
      }).optional()
    }).optional(),
    description: z$d.object({
      container: StyleOptionSchema.optional(),
      title: StyleOptionSchema.optional(),
      subtitle: StyleOptionSchema.optional()
    }).optional(),
    newConversationIcon: StyleOptionSchema.optional()
  }).optional(),
  composer: z$d.object({
    container: StyleOptionSchema.optional(),
    input: StyleOptionSchema.optional(),
    button: z$d.object({
      container: StyleOptionSchema.optional(),
      icon: StyleOptionSchema.optional()
    }).optional()
  }).optional(),
  fab: z$d.object({
    icon: StyleOptionSchema.optional(),
    container: StyleOptionSchema.optional()
  }).optional(),
  messageList: z$d.object({
    container: StyleOptionSchema.optional(),
    marquee: z$d.object({
      content: StyleOptionSchema.optional(),
      title: StyleOptionSchema.optional(),
      description: StyleOptionSchema.optional(),
      avatar: AvatarSchema.optional(),
      container: StyleOptionSchema.optional()
    }).optional(),
    scrollDownButton: z$d.object({
      container: StyleOptionSchema.optional(),
      button: StyleOptionSchema.optional(),
      icon: StyleOptionSchema.optional()
    }).optional()
  }).optional(),
  message: z$d.object({
    container: StyleOptionSchema.optional(),
    avatar: AvatarSchema.optional(),
    blocks: BlocksSchema.optional()
  }).optional(),
  loadingIndicator: z$d.object({
    container: StyleOptionSchema.optional(),
    loader: StyleOptionSchema.optional()
  }).optional()
}), grayDark = {
  gray1: "#111111",
  gray2: "#191919",
  gray3: "#222222",
  gray4: "#2a2a2a",
  gray5: "#313131",
  gray6: "#3a3a3a",
  gray7: "#484848",
  gray8: "#606060",
  gray9: "#6e6e6e",
  gray10: "#7b7b7b",
  gray11: "#b4b4b4",
  gray12: "#eeeeee"
}, mauveDark = {
  mauve1: "#121113",
  mauve2: "#1a191b",
  mauve3: "#232225",
  mauve4: "#2b292d",
  mauve5: "#323035",
  mauve6: "#3c393f",
  mauve7: "#49474e",
  mauve8: "#625f69",
  mauve9: "#6f6d78",
  mauve10: "#7c7a85",
  mauve11: "#b5b2bc",
  mauve12: "#eeeef0"
}, slateDark = {
  slate1: "#111113",
  slate2: "#18191b",
  slate3: "#212225",
  slate4: "#272a2d",
  slate5: "#2e3135",
  slate6: "#363a3f",
  slate7: "#43484e",
  slate8: "#5a6169",
  slate9: "#696e77",
  slate10: "#777b84",
  slate11: "#b0b4ba",
  slate12: "#edeef0"
}, sageDark = {
  sage1: "#101211",
  sage2: "#171918",
  sage3: "#202221",
  sage4: "#272a29",
  sage5: "#2e3130",
  sage6: "#373b39",
  sage7: "#444947",
  sage8: "#5b625f",
  sage9: "#63706b",
  sage10: "#717d79",
  sage11: "#adb5b2",
  sage12: "#eceeed"
}, oliveDark = {
  olive1: "#111210",
  olive2: "#181917",
  olive3: "#212220",
  olive4: "#282a27",
  olive5: "#2f312e",
  olive6: "#383a36",
  olive7: "#454843",
  olive8: "#5c625b",
  olive9: "#687066",
  olive10: "#767d74",
  olive11: "#afb5ad",
  olive12: "#eceeec"
}, sandDark = {
  sand1: "#111110",
  sand2: "#191918",
  sand3: "#222221",
  sand4: "#2a2a28",
  sand5: "#31312e",
  sand6: "#3b3a37",
  sand7: "#494844",
  sand8: "#62605b",
  sand9: "#6f6d66",
  sand10: "#7c7b74",
  sand11: "#b5b3ad",
  sand12: "#eeeeec"
}, tomatoDark = {
  tomato1: "#181111",
  tomato2: "#1f1513",
  tomato3: "#391714",
  tomato4: "#4e1511",
  tomato5: "#5e1c16",
  tomato6: "#6e2920",
  tomato7: "#853a2d",
  tomato8: "#ac4d39",
  tomato9: "#e54d2e",
  tomato10: "#ec6142",
  tomato11: "#ff977d",
  tomato12: "#fbd3cb"
}, redDark = {
  red1: "#191111",
  red2: "#201314",
  red3: "#3b1219",
  red4: "#500f1c",
  red5: "#611623",
  red6: "#72232d",
  red7: "#8c333a",
  red8: "#b54548",
  red9: "#e5484d",
  red10: "#ec5d5e",
  red11: "#ff9592",
  red12: "#ffd1d9"
}, rubyDark = {
  ruby1: "#191113",
  ruby2: "#1e1517",
  ruby3: "#3a141e",
  ruby4: "#4e1325",
  ruby5: "#5e1a2e",
  ruby6: "#6f2539",
  ruby7: "#883447",
  ruby8: "#b3445a",
  ruby9: "#e54666",
  ruby10: "#ec5a72",
  ruby11: "#ff949d",
  ruby12: "#fed2e1"
}, crimsonDark = {
  crimson1: "#191114",
  crimson2: "#201318",
  crimson3: "#381525",
  crimson4: "#4d122f",
  crimson5: "#5c1839",
  crimson6: "#6d2545",
  crimson7: "#873356",
  crimson8: "#b0436e",
  crimson9: "#e93d82",
  crimson10: "#ee518a",
  crimson11: "#ff92ad",
  crimson12: "#fdd3e8"
}, pinkDark = {
  pink1: "#191117",
  pink2: "#21121d",
  pink3: "#37172f",
  pink4: "#4b143d",
  pink5: "#591c47",
  pink6: "#692955",
  pink7: "#833869",
  pink8: "#a84885",
  pink9: "#d6409f",
  pink10: "#de51a8",
  pink11: "#ff8dcc",
  pink12: "#fdd1ea"
}, plumDark = {
  plum1: "#181118",
  plum2: "#201320",
  plum3: "#351a35",
  plum4: "#451d47",
  plum5: "#512454",
  plum6: "#5e3061",
  plum7: "#734079",
  plum8: "#92549c",
  plum9: "#ab4aba",
  plum10: "#b658c4",
  plum11: "#e796f3",
  plum12: "#f4d4f4"
}, purpleDark = {
  purple1: "#18111b",
  purple2: "#1e1523",
  purple3: "#301c3b",
  purple4: "#3d224e",
  purple5: "#48295c",
  purple6: "#54346b",
  purple7: "#664282",
  purple8: "#8457aa",
  purple9: "#8e4ec6",
  purple10: "#9a5cd0",
  purple11: "#d19dff",
  purple12: "#ecd9fa"
}, violetDark = {
  violet1: "#14121f",
  violet2: "#1b1525",
  violet3: "#291f43",
  violet4: "#33255b",
  violet5: "#3c2e69",
  violet6: "#473876",
  violet7: "#56468b",
  violet8: "#6958ad",
  violet9: "#6e56cf",
  violet10: "#7d66d9",
  violet11: "#baa7ff",
  violet12: "#e2ddfe"
}, irisDark = {
  iris1: "#13131e",
  iris2: "#171625",
  iris3: "#202248",
  iris4: "#262a65",
  iris5: "#303374",
  iris6: "#3d3e82",
  iris7: "#4a4a95",
  iris8: "#5958b1",
  iris9: "#5b5bd6",
  iris10: "#6e6ade",
  iris11: "#b1a9ff",
  iris12: "#e0dffe"
}, indigoDark = {
  indigo1: "#11131f",
  indigo2: "#141726",
  indigo3: "#182449",
  indigo4: "#1d2e62",
  indigo5: "#253974",
  indigo6: "#304384",
  indigo7: "#3a4f97",
  indigo8: "#435db1",
  indigo9: "#3e63dd",
  indigo10: "#5472e4",
  indigo11: "#9eb1ff",
  indigo12: "#d6e1ff"
}, blueDark = {
  blue1: "#0d1520",
  blue2: "#111927",
  blue3: "#0d2847",
  blue4: "#003362",
  blue5: "#004074",
  blue6: "#104d87",
  blue7: "#205d9e",
  blue8: "#2870bd",
  blue9: "#0090ff",
  blue10: "#3b9eff",
  blue11: "#70b8ff",
  blue12: "#c2e6ff"
}, cyanDark = {
  cyan1: "#0b161a",
  cyan2: "#101b20",
  cyan3: "#082c36",
  cyan4: "#003848",
  cyan5: "#004558",
  cyan6: "#045468",
  cyan7: "#12677e",
  cyan8: "#11809c",
  cyan9: "#00a2c7",
  cyan10: "#23afd0",
  cyan11: "#4ccce6",
  cyan12: "#b6ecf7"
}, tealDark = {
  teal1: "#0d1514",
  teal2: "#111c1b",
  teal3: "#0d2d2a",
  teal4: "#023b37",
  teal5: "#084843",
  teal6: "#145750",
  teal7: "#1c6961",
  teal8: "#207e73",
  teal9: "#12a594",
  teal10: "#0eb39e",
  teal11: "#0bd8b6",
  teal12: "#adf0dd"
}, jadeDark = {
  jade1: "#0d1512",
  jade2: "#121c18",
  jade3: "#0f2e22",
  jade4: "#0b3b2c",
  jade5: "#114837",
  jade6: "#1b5745",
  jade7: "#246854",
  jade8: "#2a7e68",
  jade9: "#29a383",
  jade10: "#27b08b",
  jade11: "#1fd8a4",
  jade12: "#adf0d4"
}, greenDark = {
  green1: "#0e1512",
  green2: "#121b17",
  green3: "#132d21",
  green4: "#113b29",
  green5: "#174933",
  green6: "#20573e",
  green7: "#28684a",
  green8: "#2f7c57",
  green9: "#30a46c",
  green10: "#33b074",
  green11: "#3dd68c",
  green12: "#b1f1cb"
}, grassDark = {
  grass1: "#0e1511",
  grass2: "#141a15",
  grass3: "#1b2a1e",
  grass4: "#1d3a24",
  grass5: "#25482d",
  grass6: "#2d5736",
  grass7: "#366740",
  grass8: "#3e7949",
  grass9: "#46a758",
  grass10: "#53b365",
  grass11: "#71d083",
  grass12: "#c2f0c2"
}, limeDark = {
  lime1: "#11130c",
  lime2: "#151a10",
  lime3: "#1f2917",
  lime4: "#29371d",
  lime5: "#334423",
  lime6: "#3d522a",
  lime7: "#496231",
  lime8: "#577538",
  lime9: "#bdee63",
  lime10: "#d4ff70",
  lime11: "#bde56c",
  lime12: "#e3f7ba"
}, yellowDark = {
  yellow1: "#14120b",
  yellow2: "#1b180f",
  yellow3: "#2d2305",
  yellow4: "#362b00",
  yellow5: "#433500",
  yellow6: "#524202",
  yellow7: "#665417",
  yellow8: "#836a21",
  yellow9: "#ffe629",
  yellow10: "#ffff57",
  yellow11: "#f5e147",
  yellow12: "#f6eeb4"
}, amberDark = {
  amber1: "#16120c",
  amber2: "#1d180f",
  amber3: "#302008",
  amber4: "#3f2700",
  amber5: "#4d3000",
  amber6: "#5c3d05",
  amber7: "#714f19",
  amber8: "#8f6424",
  amber9: "#ffc53d",
  amber10: "#ffd60a",
  amber11: "#ffca16",
  amber12: "#ffe7b3"
}, orangeDark = {
  orange1: "#17120e",
  orange2: "#1e160f",
  orange3: "#331e0b",
  orange4: "#462100",
  orange5: "#562800",
  orange6: "#66350c",
  orange7: "#7e451d",
  orange8: "#a35829",
  orange9: "#f76b15",
  orange10: "#ff801f",
  orange11: "#ffa057",
  orange12: "#ffe0c2"
}, gray = {
  gray1: "#fcfcfc",
  gray2: "#f9f9f9",
  gray3: "#f0f0f0",
  gray4: "#e8e8e8",
  gray5: "#e0e0e0",
  gray6: "#d9d9d9",
  gray7: "#cecece",
  gray8: "#bbbbbb",
  gray9: "#8d8d8d",
  gray10: "#838383",
  gray11: "#646464",
  gray12: "#202020"
}, mauve = {
  mauve1: "#fdfcfd",
  mauve2: "#faf9fb",
  mauve3: "#f2eff3",
  mauve4: "#eae7ec",
  mauve5: "#e3dfe6",
  mauve6: "#dbd8e0",
  mauve7: "#d0cdd7",
  mauve8: "#bcbac7",
  mauve9: "#8e8c99",
  mauve10: "#84828e",
  mauve11: "#65636d",
  mauve12: "#211f26"
}, slate = {
  slate1: "#fcfcfd",
  slate2: "#f9f9fb",
  slate3: "#f0f0f3",
  slate4: "#e8e8ec",
  slate5: "#e0e1e6",
  slate6: "#d9d9e0",
  slate7: "#cdced6",
  slate8: "#b9bbc6",
  slate9: "#8b8d98",
  slate10: "#80838d",
  slate11: "#60646c",
  slate12: "#1c2024"
}, sage = {
  sage1: "#fbfdfc",
  sage2: "#f7f9f8",
  sage3: "#eef1f0",
  sage4: "#e6e9e8",
  sage5: "#dfe2e0",
  sage6: "#d7dad9",
  sage7: "#cbcfcd",
  sage8: "#b8bcba",
  sage9: "#868e8b",
  sage10: "#7c8481",
  sage11: "#5f6563",
  sage12: "#1a211e"
}, olive = {
  olive1: "#fcfdfc",
  olive2: "#f8faf8",
  olive3: "#eff1ef",
  olive4: "#e7e9e7",
  olive5: "#dfe2df",
  olive6: "#d7dad7",
  olive7: "#cccfcc",
  olive8: "#b9bcb8",
  olive9: "#898e87",
  olive10: "#7f847d",
  olive11: "#60655f",
  olive12: "#1d211c"
}, sand = {
  sand1: "#fdfdfc",
  sand2: "#f9f9f8",
  sand3: "#f1f0ef",
  sand4: "#e9e8e6",
  sand5: "#e2e1de",
  sand6: "#dad9d6",
  sand7: "#cfceca",
  sand8: "#bcbbb5",
  sand9: "#8d8d86",
  sand10: "#82827c",
  sand11: "#63635e",
  sand12: "#21201c"
}, tomato = {
  tomato1: "#fffcfc",
  tomato2: "#fff8f7",
  tomato3: "#feebe7",
  tomato4: "#ffdcd3",
  tomato5: "#ffcdc2",
  tomato6: "#fdbdaf",
  tomato7: "#f5a898",
  tomato8: "#ec8e7b",
  tomato9: "#e54d2e",
  tomato10: "#dd4425",
  tomato11: "#d13415",
  tomato12: "#5c271f"
}, red = {
  red1: "#fffcfc",
  red2: "#fff7f7",
  red3: "#feebec",
  red4: "#ffdbdc",
  red5: "#ffcdce",
  red6: "#fdbdbe",
  red7: "#f4a9aa",
  red8: "#eb8e90",
  red9: "#e5484d",
  red10: "#dc3e42",
  red11: "#ce2c31",
  red12: "#641723"
}, ruby = {
  ruby1: "#fffcfd",
  ruby2: "#fff7f8",
  ruby3: "#feeaed",
  ruby4: "#ffdce1",
  ruby5: "#ffced6",
  ruby6: "#f8bfc8",
  ruby7: "#efacb8",
  ruby8: "#e592a3",
  ruby9: "#e54666",
  ruby10: "#dc3b5d",
  ruby11: "#ca244d",
  ruby12: "#64172b"
}, crimson = {
  crimson1: "#fffcfd",
  crimson2: "#fef7f9",
  crimson3: "#ffe9f0",
  crimson4: "#fedce7",
  crimson5: "#facedd",
  crimson6: "#f3bed1",
  crimson7: "#eaacc3",
  crimson8: "#e093b2",
  crimson9: "#e93d82",
  crimson10: "#df3478",
  crimson11: "#cb1d63",
  crimson12: "#621639"
}, pink = {
  pink1: "#fffcfe",
  pink2: "#fef7fb",
  pink3: "#fee9f5",
  pink4: "#fbdcef",
  pink5: "#f6cee7",
  pink6: "#efbfdd",
  pink7: "#e7acd0",
  pink8: "#dd93c2",
  pink9: "#d6409f",
  pink10: "#cf3897",
  pink11: "#c2298a",
  pink12: "#651249"
}, plum = {
  plum1: "#fefcff",
  plum2: "#fdf7fd",
  plum3: "#fbebfb",
  plum4: "#f7def8",
  plum5: "#f2d1f3",
  plum6: "#e9c2ec",
  plum7: "#deade3",
  plum8: "#cf91d8",
  plum9: "#ab4aba",
  plum10: "#a144af",
  plum11: "#953ea3",
  plum12: "#53195d"
}, purple = {
  purple1: "#fefcfe",
  purple2: "#fbf7fe",
  purple3: "#f7edfe",
  purple4: "#f2e2fc",
  purple5: "#ead5f9",
  purple6: "#e0c4f4",
  purple7: "#d1afec",
  purple8: "#be93e4",
  purple9: "#8e4ec6",
  purple10: "#8347b9",
  purple11: "#8145b5",
  purple12: "#402060"
}, violet = {
  violet1: "#fdfcfe",
  violet2: "#faf8ff",
  violet3: "#f4f0fe",
  violet4: "#ebe4ff",
  violet5: "#e1d9ff",
  violet6: "#d4cafe",
  violet7: "#c2b5f5",
  violet8: "#aa99ec",
  violet9: "#6e56cf",
  violet10: "#654dc4",
  violet11: "#6550b9",
  violet12: "#2f265f"
}, iris = {
  iris1: "#fdfdff",
  iris2: "#f8f8ff",
  iris3: "#f0f1fe",
  iris4: "#e6e7ff",
  iris5: "#dadcff",
  iris6: "#cbcdff",
  iris7: "#b8baf8",
  iris8: "#9b9ef0",
  iris9: "#5b5bd6",
  iris10: "#5151cd",
  iris11: "#5753c6",
  iris12: "#272962"
}, indigo = {
  indigo1: "#fdfdfe",
  indigo2: "#f7f9ff",
  indigo3: "#edf2fe",
  indigo4: "#e1e9ff",
  indigo5: "#d2deff",
  indigo6: "#c1d0ff",
  indigo7: "#abbdf9",
  indigo8: "#8da4ef",
  indigo9: "#3e63dd",
  indigo10: "#3358d4",
  indigo11: "#3a5bc7",
  indigo12: "#1f2d5c"
}, blue = {
  blue1: "#fbfdff",
  blue2: "#f4faff",
  blue3: "#e6f4fe",
  blue4: "#d5efff",
  blue5: "#c2e5ff",
  blue6: "#acd8fc",
  blue7: "#8ec8f6",
  blue8: "#5eb1ef",
  blue9: "#0090ff",
  blue10: "#0588f0",
  blue11: "#0d74ce",
  blue12: "#113264"
}, cyan = {
  cyan1: "#fafdfe",
  cyan2: "#f2fafb",
  cyan3: "#def7f9",
  cyan4: "#caf1f6",
  cyan5: "#b5e9f0",
  cyan6: "#9ddde7",
  cyan7: "#7dcedc",
  cyan8: "#3db9cf",
  cyan9: "#00a2c7",
  cyan10: "#0797b9",
  cyan11: "#107d98",
  cyan12: "#0d3c48"
}, teal = {
  teal1: "#fafefd",
  teal2: "#f3fbf9",
  teal3: "#e0f8f3",
  teal4: "#ccf3ea",
  teal5: "#b8eae0",
  teal6: "#a1ded2",
  teal7: "#83cdc1",
  teal8: "#53b9ab",
  teal9: "#12a594",
  teal10: "#0d9b8a",
  teal11: "#008573",
  teal12: "#0d3d38"
}, jade = {
  jade1: "#fbfefd",
  jade2: "#f4fbf7",
  jade3: "#e6f7ed",
  jade4: "#d6f1e3",
  jade5: "#c3e9d7",
  jade6: "#acdec8",
  jade7: "#8bceb6",
  jade8: "#56ba9f",
  jade9: "#29a383",
  jade10: "#26997b",
  jade11: "#208368",
  jade12: "#1d3b31"
}, green = {
  green1: "#fbfefc",
  green2: "#f4fbf6",
  green3: "#e6f6eb",
  green4: "#d6f1df",
  green5: "#c4e8d1",
  green6: "#adddc0",
  green7: "#8eceaa",
  green8: "#5bb98b",
  green9: "#30a46c",
  green10: "#2b9a66",
  green11: "#218358",
  green12: "#193b2d"
}, grass = {
  grass1: "#fbfefb",
  grass2: "#f5fbf5",
  grass3: "#e9f6e9",
  grass4: "#daf1db",
  grass5: "#c9e8ca",
  grass6: "#b2ddb5",
  grass7: "#94ce9a",
  grass8: "#65ba74",
  grass9: "#46a758",
  grass10: "#3e9b4f",
  grass11: "#2a7e3b",
  grass12: "#203c25"
}, lime = {
  lime1: "#fcfdfa",
  lime2: "#f8faf3",
  lime3: "#eef6d6",
  lime4: "#e2f0bd",
  lime5: "#d3e7a6",
  lime6: "#c2da91",
  lime7: "#abc978",
  lime8: "#8db654",
  lime9: "#bdee63",
  lime10: "#b0e64c",
  lime11: "#5c7c2f",
  lime12: "#37401c"
}, yellow = {
  yellow1: "#fdfdf9",
  yellow2: "#fefce9",
  yellow3: "#fffab8",
  yellow4: "#fff394",
  yellow5: "#ffe770",
  yellow6: "#f3d768",
  yellow7: "#e4c767",
  yellow8: "#d5ae39",
  yellow9: "#ffe629",
  yellow10: "#ffdc00",
  yellow11: "#9e6c00",
  yellow12: "#473b1f"
}, amber = {
  amber1: "#fefdfb",
  amber2: "#fefbe9",
  amber3: "#fff7c2",
  amber4: "#ffee9c",
  amber5: "#fbe577",
  amber6: "#f3d673",
  amber7: "#e9c162",
  amber8: "#e2a336",
  amber9: "#ffc53d",
  amber10: "#ffba18",
  amber11: "#ab6400",
  amber12: "#4f3422"
}, orange = {
  orange1: "#fefcfb",
  orange2: "#fff7ed",
  orange3: "#ffefd6",
  orange4: "#ffdfb5",
  orange5: "#ffd19a",
  orange6: "#ffc182",
  orange7: "#f5ae73",
  orange8: "#ec9455",
  orange9: "#f76b15",
  orange10: "#ef5f00",
  orange11: "#cc4e00",
  orange12: "#582d1d"
}, colorsDark = {
  tomato: tomatoDark,
  red: redDark,
  ruby: rubyDark,
  crimson: crimsonDark,
  pink: pinkDark,
  plum: plumDark,
  purple: purpleDark,
  violet: violetDark,
  iris: irisDark,
  indigo: indigoDark,
  blue: blueDark,
  cyan: cyanDark,
  teal: tealDark,
  jade: jadeDark,
  green: greenDark,
  grass: grassDark,
  orange: orangeDark,
  amber: amberDark,
  yellow: yellowDark,
  lime: limeDark
}, graysDark = {
  gray: grayDark,
  mauve: mauveDark,
  slate: slateDark,
  sage: sageDark,
  olive: oliveDark,
  sand: sandDark
}, graysLight = {
  gray,
  mauve,
  slate,
  sage,
  olive,
  sand
}, colorsLight = {
  tomato,
  red,
  ruby,
  crimson,
  pink,
  plum,
  purple,
  violet,
  iris,
  indigo,
  blue,
  cyan,
  teal,
  jade,
  green,
  grass,
  orange,
  amber,
  yellow,
  lime
}, parseNumber = ($e, Ze) => {
  if (typeof $e == "number") {
    if (Ze === 3)
      return {
        mode: "rgb",
        r: ($e >> 8 & 15 | $e >> 4 & 240) / 255,
        g: ($e >> 4 & 15 | $e & 240) / 255,
        b: ($e & 15 | $e << 4 & 240) / 255
      };
    if (Ze === 4)
      return {
        mode: "rgb",
        r: ($e >> 12 & 15 | $e >> 8 & 240) / 255,
        g: ($e >> 8 & 15 | $e >> 4 & 240) / 255,
        b: ($e >> 4 & 15 | $e & 240) / 255,
        alpha: ($e & 15 | $e << 4 & 240) / 255
      };
    if (Ze === 6)
      return {
        mode: "rgb",
        r: ($e >> 16 & 255) / 255,
        g: ($e >> 8 & 255) / 255,
        b: ($e & 255) / 255
      };
    if (Ze === 8)
      return {
        mode: "rgb",
        r: ($e >> 24 & 255) / 255,
        g: ($e >> 16 & 255) / 255,
        b: ($e >> 8 & 255) / 255,
        alpha: ($e & 255) / 255
      };
  }
}, parseNumber$1 = parseNumber, named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  // Added in CSS Colors Level 4:
  // https://drafts.csswg.org/css-color/#changes-from-3
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, named$1 = named, parseNamed = ($e) => parseNumber$1(named$1[$e.toLowerCase()], 6), parseNamed$1 = parseNamed, hex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i, parseHex = ($e) => {
  let Ze;
  return (Ze = $e.match(hex)) ? parseNumber$1(parseInt(Ze[1], 16), Ze[1].length) : void 0;
}, parseHex$1 = parseHex, num$1 = "([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)", per = `${num$1}%`, num_per = `(?:${num$1}%|${num$1})`, hue$1 = `(?:${num$1}(deg|grad|rad|turn)|${num$1})`, c = "\\s*,\\s*", rgb_num_old = new RegExp(
  `^rgba?\\(\\s*${num$1}${c}${num$1}${c}${num$1}\\s*(?:,\\s*${num_per}\\s*)?\\)$`
), rgb_per_old = new RegExp(
  `^rgba?\\(\\s*${per}${c}${per}${c}${per}\\s*(?:,\\s*${num_per}\\s*)?\\)$`
), parseRgbLegacy = ($e) => {
  let Ze = { mode: "rgb" }, Fe;
  if (Fe = $e.match(rgb_num_old))
    Fe[1] !== void 0 && (Ze.r = Fe[1] / 255), Fe[2] !== void 0 && (Ze.g = Fe[2] / 255), Fe[3] !== void 0 && (Ze.b = Fe[3] / 255);
  else if (Fe = $e.match(rgb_per_old))
    Fe[1] !== void 0 && (Ze.r = Fe[1] / 100), Fe[2] !== void 0 && (Ze.g = Fe[2] / 100), Fe[3] !== void 0 && (Ze.b = Fe[3] / 100);
  else
    return;
  return Fe[4] !== void 0 ? Ze.alpha = Fe[4] / 100 : Fe[5] !== void 0 && (Ze.alpha = +Fe[5]), Ze;
}, parseRgbLegacy$1 = parseRgbLegacy, prepare = ($e, Ze) => $e === void 0 ? void 0 : typeof $e != "object" ? parse$1($e) : $e.mode !== void 0 ? $e : Ze ? { ...$e, mode: Ze } : void 0, prepare$1 = prepare, converter = ($e = "rgb") => (Ze) => (Ze = prepare$1(Ze, $e)) !== void 0 ? (
  // if the color's mode corresponds to our target mode
  Ze.mode === $e ? (
    // then just return the color
    Ze
  ) : (
    // otherwise check to see if we have a dedicated
    // converter for the target mode
    converters[Ze.mode][$e] ? (
      // and return its result...
      converters[Ze.mode][$e](Ze)
    ) : (
      // ...otherwise pass through RGB as an intermediary step.
      // if the target mode is RGB...
      $e === "rgb" ? (
        // just return the RGB
        converters[Ze.mode].rgb(Ze)
      ) : (
        // otherwise convert color.mode -> RGB -> target_mode
        converters.rgb[$e](converters[Ze.mode].rgb(Ze))
      )
    )
  )
) : void 0, converter$1 = converter, converters = {}, modes = {}, parsers = [], colorProfiles = {}, identity = ($e) => $e, useMode = ($e) => (converters[$e.mode] = {
  ...converters[$e.mode],
  ...$e.toMode
}, Object.keys($e.fromMode || {}).forEach((Ze) => {
  converters[Ze] || (converters[Ze] = {}), converters[Ze][$e.mode] = $e.fromMode[Ze];
}), $e.ranges || ($e.ranges = {}), $e.difference || ($e.difference = {}), $e.channels.forEach((Ze) => {
  if ($e.ranges[Ze] === void 0 && ($e.ranges[Ze] = [0, 1]), !$e.interpolate[Ze])
    throw new Error(`Missing interpolator for: ${Ze}`);
  typeof $e.interpolate[Ze] == "function" && ($e.interpolate[Ze] = {
    use: $e.interpolate[Ze]
  }), $e.interpolate[Ze].fixup || ($e.interpolate[Ze].fixup = identity);
}), modes[$e.mode] = $e, ($e.parse || []).forEach((Ze) => {
  useParser(Ze, $e.mode);
}), converter$1($e.mode)), getMode = ($e) => modes[$e], useParser = ($e, Ze) => {
  if (typeof $e == "string") {
    if (!Ze)
      throw new Error("'mode' required when 'parser' is a string");
    colorProfiles[$e] = Ze;
  } else
    typeof $e == "function" && parsers.indexOf($e) < 0 && parsers.push($e);
}, IdentStartCodePoint = /[^\x00-\x7F]|[a-zA-Z_]/, IdentCodePoint = /[^\x00-\x7F]|[-\w]/, Tok = {
  Function: "function",
  Ident: "ident",
  Number: "number",
  Percentage: "percentage",
  ParenClose: ")",
  None: "none",
  Hue: "hue",
  Alpha: "alpha"
};
let _i = 0;
function is_num($e) {
  let Ze = $e[_i], Fe = $e[_i + 1];
  return Ze === "-" || Ze === "+" ? /\d/.test(Fe) || Fe === "." && /\d/.test($e[_i + 2]) : Ze === "." ? /\d/.test(Fe) : /\d/.test(Ze);
}
function is_ident($e) {
  if (_i >= $e.length)
    return !1;
  let Ze = $e[_i];
  if (IdentStartCodePoint.test(Ze))
    return !0;
  if (Ze === "-") {
    if ($e.length - _i < 2)
      return !1;
    let Fe = $e[_i + 1];
    return !!(Fe === "-" || IdentStartCodePoint.test(Fe));
  }
  return !1;
}
const huenits = {
  deg: 1,
  rad: 180 / Math.PI,
  grad: 9 / 10,
  turn: 360
};
function num($e) {
  let Ze = "";
  if (($e[_i] === "-" || $e[_i] === "+") && (Ze += $e[_i++]), Ze += digits($e), $e[_i] === "." && /\d/.test($e[_i + 1]) && (Ze += $e[_i++] + digits($e)), ($e[_i] === "e" || $e[_i] === "E") && (($e[_i + 1] === "-" || $e[_i + 1] === "+") && /\d/.test($e[_i + 2]) ? Ze += $e[_i++] + $e[_i++] + digits($e) : /\d/.test($e[_i + 1]) && (Ze += $e[_i++] + digits($e))), is_ident($e)) {
    let Fe = ident($e);
    return Fe === "deg" || Fe === "rad" || Fe === "turn" || Fe === "grad" ? { type: Tok.Hue, value: Ze * huenits[Fe] } : void 0;
  }
  return $e[_i] === "%" ? (_i++, { type: Tok.Percentage, value: +Ze }) : { type: Tok.Number, value: +Ze };
}
function digits($e) {
  let Ze = "";
  for (; /\d/.test($e[_i]); )
    Ze += $e[_i++];
  return Ze;
}
function ident($e) {
  let Ze = "";
  for (; _i < $e.length && IdentCodePoint.test($e[_i]); )
    Ze += $e[_i++];
  return Ze;
}
function identlike($e) {
  let Ze = ident($e);
  return $e[_i] === "(" ? (_i++, { type: Tok.Function, value: Ze }) : Ze === "none" ? { type: Tok.None, value: void 0 } : { type: Tok.Ident, value: Ze };
}
function tokenize($e = "") {
  let Ze = $e.trim(), Fe = [], Ke;
  for (_i = 0; _i < Ze.length; ) {
    if (Ke = Ze[_i++], Ke === `
` || Ke === "	" || Ke === " ") {
      for (; _i < Ze.length && (Ze[_i] === `
` || Ze[_i] === "	" || Ze[_i] === " "); )
        _i++;
      continue;
    }
    if (Ke === ",")
      return;
    if (Ke === ")") {
      Fe.push({ type: Tok.ParenClose });
      continue;
    }
    if (Ke === "+") {
      if (_i--, is_num(Ze)) {
        Fe.push(num(Ze));
        continue;
      }
      return;
    }
    if (Ke === "-") {
      if (_i--, is_num(Ze)) {
        Fe.push(num(Ze));
        continue;
      }
      if (is_ident(Ze)) {
        Fe.push({ type: Tok.Ident, value: ident(Ze) });
        continue;
      }
      return;
    }
    if (Ke === ".") {
      if (_i--, is_num(Ze)) {
        Fe.push(num(Ze));
        continue;
      }
      return;
    }
    if (Ke === "/") {
      for (; _i < Ze.length && (Ze[_i] === `
` || Ze[_i] === "	" || Ze[_i] === " "); )
        _i++;
      let Ve;
      if (is_num(Ze) && (Ve = num(Ze), Ve.type !== Tok.Hue)) {
        Fe.push({ type: Tok.Alpha, value: Ve });
        continue;
      }
      if (is_ident(Ze) && ident(Ze) === "none") {
        Fe.push({
          type: Tok.Alpha,
          value: { type: Tok.None, value: void 0 }
        });
        continue;
      }
      return;
    }
    if (/\d/.test(Ke)) {
      _i--, Fe.push(num(Ze));
      continue;
    }
    if (IdentStartCodePoint.test(Ke)) {
      _i--, Fe.push(identlike(Ze));
      continue;
    }
    return;
  }
  return Fe;
}
function parseColorSyntax($e) {
  $e._i = 0;
  let Ze = $e[$e._i++];
  if (!Ze || Ze.type !== Tok.Function || Ze.value !== "color" || (Ze = $e[$e._i++], Ze.type !== Tok.Ident))
    return;
  const Fe = colorProfiles[Ze.value];
  if (!Fe)
    return;
  const Ke = { mode: Fe }, Ve = consumeCoords($e, !1);
  if (!Ve)
    return;
  const Je = getMode(Fe).channels;
  for (let Qe = 0, at; Qe < Je.length; Qe++)
    at = Ve[Qe], at.type !== Tok.None && (Ke[Je[Qe]] = at.type === Tok.Number ? at.value : at.value / 100);
  return Ke;
}
function consumeCoords($e, Ze) {
  const Fe = [];
  let Ke;
  for (; $e._i < $e.length; ) {
    if (Ke = $e[$e._i++], Ke.type === Tok.None || Ke.type === Tok.Number || Ke.type === Tok.Alpha || Ke.type === Tok.Percentage || Ze && Ke.type === Tok.Hue) {
      Fe.push(Ke);
      continue;
    }
    if (Ke.type === Tok.ParenClose) {
      if ($e._i < $e.length)
        return;
      continue;
    }
    return;
  }
  if (!(Fe.length < 3 || Fe.length > 4)) {
    if (Fe.length === 4) {
      if (Fe[3].type !== Tok.Alpha)
        return;
      Fe[3] = Fe[3].value;
    }
    return Fe.length === 3 && Fe.push({ type: Tok.None, value: void 0 }), Fe.every((Ve) => Ve.type !== Tok.Alpha) ? Fe : void 0;
  }
}
function parseModernSyntax($e, Ze) {
  $e._i = 0;
  let Fe = $e[$e._i++];
  if (!Fe || Fe.type !== Tok.Function)
    return;
  let Ke = consumeCoords($e, Ze);
  if (Ke)
    return Ke.unshift(Fe.value), Ke;
}
const parse = ($e) => {
  if (typeof $e != "string")
    return;
  const Ze = tokenize($e), Fe = Ze ? parseModernSyntax(Ze, !0) : void 0;
  let Ke, Ve = 0, Je = parsers.length;
  for (; Ve < Je; )
    if ((Ke = parsers[Ve++]($e, Fe)) !== void 0)
      return Ke;
  return Ze ? parseColorSyntax(Ze) : void 0;
}, parse$1 = parse;
function parseRgb($e, Ze) {
  if (!Ze || Ze[0] !== "rgb" && Ze[0] !== "rgba")
    return;
  const Fe = { mode: "rgb" }, [, Ke, Ve, Je, Qe] = Ze;
  if (!(Ke.type === Tok.Hue || Ve.type === Tok.Hue || Je.type === Tok.Hue))
    return Ke.type !== Tok.None && (Fe.r = Ke.type === Tok.Number ? Ke.value / 255 : Ke.value / 100), Ve.type !== Tok.None && (Fe.g = Ve.type === Tok.Number ? Ve.value / 255 : Ve.value / 100), Je.type !== Tok.None && (Fe.b = Je.type === Tok.Number ? Je.value / 255 : Je.value / 100), Qe.type !== Tok.None && (Fe.alpha = Qe.type === Tok.Number ? Qe.value : Qe.value / 100), Fe;
}
const parseTransparent = ($e) => $e === "transparent" ? { mode: "rgb", r: 0, g: 0, b: 0, alpha: 0 } : void 0, parseTransparent$1 = parseTransparent, lerp = ($e, Ze, Fe) => $e + Fe * (Ze - $e), get_classes = ($e) => {
  let Ze = [];
  for (let Fe = 0; Fe < $e.length - 1; Fe++) {
    let Ke = $e[Fe], Ve = $e[Fe + 1];
    Ke === void 0 && Ve === void 0 ? Ze.push(void 0) : Ke !== void 0 && Ve !== void 0 ? Ze.push([Ke, Ve]) : Ze.push(Ke !== void 0 ? [Ke, Ke] : [Ve, Ve]);
  }
  return Ze;
}, interpolatorPiecewise = ($e) => (Ze) => {
  let Fe = get_classes(Ze);
  return (Ke) => {
    let Ve = Ke * Fe.length, Je = Ke >= 1 ? Fe.length - 1 : Math.max(Math.floor(Ve), 0), Qe = Fe[Je];
    return Qe === void 0 ? void 0 : $e(Qe[0], Qe[1], Ve - Je);
  };
}, interpolatorLinear = interpolatorPiecewise(lerp), fixupAlpha = ($e) => {
  let Ze = !1, Fe = $e.map((Ke) => Ke !== void 0 ? (Ze = !0, Ke) : 1);
  return Ze ? Fe : $e;
}, definition$q = {
  mode: "rgb",
  channels: ["r", "g", "b", "alpha"],
  parse: [
    parseRgb,
    parseHex$1,
    parseRgbLegacy$1,
    parseNamed$1,
    parseTransparent$1,
    "srgb"
  ],
  serialize: "srgb",
  interpolate: {
    r: interpolatorLinear,
    g: interpolatorLinear,
    b: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  },
  gamut: !0
}, modeRgb = definition$q, linearize$2 = ($e) => Math.pow(Math.abs($e), 563 / 256) * Math.sign($e), convertA98ToXyz65 = ($e) => {
  let Ze = linearize$2($e.r), Fe = linearize$2($e.g), Ke = linearize$2($e.b), Ve = {
    mode: "xyz65",
    x: 0.5766690429101305 * Ze + 0.1855582379065463 * Fe + 0.1882286462349947 * Ke,
    y: 0.297344975250536 * Ze + 0.6273635662554661 * Fe + 0.0752914584939979 * Ke,
    z: 0.0270313613864123 * Ze + 0.0706888525358272 * Fe + 0.9913375368376386 * Ke
  };
  return $e.alpha !== void 0 && (Ve.alpha = $e.alpha), Ve;
}, convertA98ToXyz65$1 = convertA98ToXyz65, gamma$2 = ($e) => Math.pow(Math.abs($e), 256 / 563) * Math.sign($e), convertXyz65ToA98 = ({ x: $e, y: Ze, z: Fe, alpha: Ke }) => {
  let Ve = {
    mode: "a98",
    r: gamma$2(
      $e * 2.0415879038107465 - Ze * 0.5650069742788597 - 0.3447313507783297 * Fe
    ),
    g: gamma$2(
      $e * -0.9692436362808798 + Ze * 1.8759675015077206 + 0.0415550574071756 * Fe
    ),
    b: gamma$2(
      $e * 0.0134442806320312 - Ze * 0.1183623922310184 + 1.0151749943912058 * Fe
    )
  };
  return Ke !== void 0 && (Ve.alpha = Ke), Ve;
}, convertXyz65ToA98$1 = convertXyz65ToA98, fn$3 = ($e) => {
  const Ze = Math.abs($e);
  return Ze <= 0.04045 ? $e / 12.92 : (Math.sign($e) || 1) * Math.pow((Ze + 0.055) / 1.055, 2.4);
}, convertRgbToLrgb = ({ r: $e, g: Ze, b: Fe, alpha: Ke }) => {
  let Ve = {
    mode: "lrgb",
    r: fn$3($e),
    g: fn$3(Ze),
    b: fn$3(Fe)
  };
  return Ke !== void 0 && (Ve.alpha = Ke), Ve;
}, convertRgbToLrgb$1 = convertRgbToLrgb, convertRgbToXyz65 = ($e) => {
  let { r: Ze, g: Fe, b: Ke, alpha: Ve } = convertRgbToLrgb$1($e), Je = {
    mode: "xyz65",
    x: 0.4123907992659593 * Ze + 0.357584339383878 * Fe + 0.1804807884018343 * Ke,
    y: 0.2126390058715102 * Ze + 0.715168678767756 * Fe + 0.0721923153607337 * Ke,
    z: 0.0193308187155918 * Ze + 0.119194779794626 * Fe + 0.9505321522496607 * Ke
  };
  return Ve !== void 0 && (Je.alpha = Ve), Je;
}, convertRgbToXyz65$1 = convertRgbToXyz65, fn$2 = ($e) => {
  const Ze = Math.abs($e);
  return Ze > 31308e-7 ? (Math.sign($e) || 1) * (1.055 * Math.pow(Ze, 1 / 2.4) - 0.055) : $e * 12.92;
}, convertLrgbToRgb = ({ r: $e, g: Ze, b: Fe, alpha: Ke }, Ve = "rgb") => {
  let Je = {
    mode: Ve,
    r: fn$2($e),
    g: fn$2(Ze),
    b: fn$2(Fe)
  };
  return Ke !== void 0 && (Je.alpha = Ke), Je;
}, convertLrgbToRgb$1 = convertLrgbToRgb, convertXyz65ToRgb = ({ x: $e, y: Ze, z: Fe, alpha: Ke }) => {
  let Ve = convertLrgbToRgb$1({
    r: $e * 3.2409699419045226 - Ze * 1.537383177570094 - 0.4986107602930034 * Fe,
    g: $e * -0.9692436362808796 + Ze * 1.8759675015077204 + 0.0415550574071756 * Fe,
    b: $e * 0.0556300796969936 - Ze * 0.2039769588889765 + 1.0569715142428784 * Fe
  });
  return Ke !== void 0 && (Ve.alpha = Ke), Ve;
}, convertXyz65ToRgb$1 = convertXyz65ToRgb, definition$p = {
  ...modeRgb,
  mode: "a98",
  parse: ["a98-rgb"],
  serialize: "a98-rgb",
  fromMode: {
    rgb: ($e) => convertXyz65ToA98$1(convertRgbToXyz65$1($e)),
    xyz65: convertXyz65ToA98$1
  },
  toMode: {
    rgb: ($e) => convertXyz65ToRgb$1(convertA98ToXyz65$1($e)),
    xyz65: convertA98ToXyz65$1
  }
}, modeA98 = definition$p, normalizeHue = ($e) => ($e = $e % 360) < 0 ? $e + 360 : $e, normalizeHue$1 = normalizeHue, hue = ($e, Ze) => $e.map((Fe, Ke, Ve) => {
  if (Fe === void 0)
    return Fe;
  let Je = normalizeHue$1(Fe);
  return Ke === 0 || $e[Ke - 1] === void 0 ? Je : Ze(Je - normalizeHue$1(Ve[Ke - 1]));
}).reduce((Fe, Ke) => !Fe.length || Ke === void 0 || Fe[Fe.length - 1] === void 0 ? (Fe.push(Ke), Fe) : (Fe.push(Ke + Fe[Fe.length - 1]), Fe), []), fixupHueShorter = ($e) => hue($e, (Ze) => Math.abs(Ze) <= 180 ? Ze : Ze - 360 * Math.sign(Ze)), M = [-0.14861, 1.78277, -0.29227, -0.90649, 1.97294, 0], degToRad = Math.PI / 180, radToDeg = 180 / Math.PI;
let DE = M[3] * M[4], BE = M[1] * M[4], BCAD = M[1] * M[2] - M[0] * M[3];
const convertRgbToCubehelix = ({ r: $e, g: Ze, b: Fe, alpha: Ke }) => {
  let Ve = (BCAD * Fe + $e * DE - Ze * BE) / (BCAD + DE - BE), Je = Fe - Ve, Qe = (M[4] * (Ze - Ve) - M[2] * Je) / M[3], at = {
    mode: "cubehelix",
    l: Ve,
    s: Ve === 0 || Ve === 1 ? void 0 : Math.sqrt(Je * Je + Qe * Qe) / (M[4] * Ve * (1 - Ve))
  };
  return at.s && (at.h = Math.atan2(Qe, Je) * radToDeg - 120), Ke !== void 0 && (at.alpha = Ke), at;
}, convertRgbToCubehelix$1 = convertRgbToCubehelix, convertCubehelixToRgb = ({ h: $e, s: Ze, l: Fe, alpha: Ke }) => {
  let Ve = { mode: "rgb" };
  $e = ($e === void 0 ? 0 : $e + 120) * degToRad;
  let Je = Ze === void 0 ? 0 : Ze * Fe * (1 - Fe), Qe = Math.cos($e), at = Math.sin($e);
  return Ve.r = Fe + Je * (M[0] * Qe + M[1] * at), Ve.g = Fe + Je * (M[2] * Qe + M[3] * at), Ve.b = Fe + Je * (M[4] * Qe + M[5] * at), Ke !== void 0 && (Ve.alpha = Ke), Ve;
}, convertCubehelixToRgb$1 = convertCubehelixToRgb, differenceHueSaturation = ($e, Ze) => {
  if ($e.h === void 0 || Ze.h === void 0 || !$e.s || !Ze.s)
    return 0;
  let Fe = normalizeHue$1($e.h), Ke = normalizeHue$1(Ze.h), Ve = Math.sin((Ke - Fe + 360) / 2 * Math.PI / 180);
  return 2 * Math.sqrt($e.s * Ze.s) * Ve;
}, differenceHueNaive = ($e, Ze) => {
  if ($e.h === void 0 || Ze.h === void 0)
    return 0;
  let Fe = normalizeHue$1($e.h), Ke = normalizeHue$1(Ze.h);
  return Math.abs(Ke - Fe) > 180 ? Fe - (Ke - 360 * Math.sign(Ke - Fe)) : Ke - Fe;
}, differenceHueChroma = ($e, Ze) => {
  if ($e.h === void 0 || Ze.h === void 0 || !$e.c || !Ze.c)
    return 0;
  let Fe = normalizeHue$1($e.h), Ke = normalizeHue$1(Ze.h), Ve = Math.sin((Ke - Fe + 360) / 2 * Math.PI / 180);
  return 2 * Math.sqrt($e.c * Ze.c) * Ve;
}, differenceEuclidean = ($e = "rgb", Ze = [1, 1, 1, 0]) => {
  let Fe = getMode($e), Ke = Fe.channels, Ve = Fe.difference, Je = converter$1($e);
  return (Qe, at) => {
    let ut = Je(Qe), lt = Je(at);
    return Math.sqrt(
      Ke.reduce((dt, bt, $t) => {
        let vt = Ve[bt] ? Ve[bt](ut, lt) : ut[bt] - lt[bt];
        return dt + (Ze[$t] || 0) * Math.pow(isNaN(vt) ? 0 : vt, 2);
      }, 0)
    );
  };
}, differenceCiede2000 = ($e = 1, Ze = 1, Fe = 1) => {
  let Ke = converter$1("lab65");
  return (Ve, Je) => {
    let Qe = Ke(Ve), at = Ke(Je), ut = Qe.l, lt = Qe.a, dt = Qe.b, bt = Math.sqrt(lt * lt + dt * dt), $t = at.l, vt = at.a, wt = at.b, xt = Math.sqrt(vt * vt + wt * wt), Et = (bt + xt) / 2, Tt = 0.5 * (1 - Math.sqrt(
      Math.pow(Et, 7) / (Math.pow(Et, 7) + Math.pow(25, 7))
    )), Rt = lt * (1 + Tt), Ct = vt * (1 + Tt), Zt = Math.sqrt(Rt * Rt + dt * dt), Lt = Math.sqrt(Ct * Ct + wt * wt), Ut = Math.abs(Rt) + Math.abs(dt) === 0 ? 0 : Math.atan2(dt, Rt);
    Ut += (Ut < 0) * 2 * Math.PI;
    let Pt = Math.abs(Ct) + Math.abs(wt) === 0 ? 0 : Math.atan2(wt, Ct);
    Pt += (Pt < 0) * 2 * Math.PI;
    let Ot = $t - ut, Ft = Lt - Zt, gt = Zt * Lt === 0 ? 0 : Pt - Ut;
    gt -= (gt > Math.PI) * 2 * Math.PI, gt += (gt < -Math.PI) * 2 * Math.PI;
    let We = 2 * Math.sqrt(Zt * Lt) * Math.sin(gt / 2), Xe = (ut + $t) / 2, rt = (Zt + Lt) / 2, ot;
    Zt * Lt === 0 ? ot = Ut + Pt : (ot = (Ut + Pt) / 2, ot -= (Math.abs(Ut - Pt) > Math.PI) * Math.PI, ot += (ot < 0) * 2 * Math.PI);
    let ft = Math.pow(Xe - 50, 2), mt = 1 - 0.17 * Math.cos(ot - Math.PI / 6) + 0.24 * Math.cos(2 * ot) + 0.32 * Math.cos(3 * ot + Math.PI / 30) - 0.2 * Math.cos(4 * ot - 63 * Math.PI / 180), yt = 1 + 0.015 * ft / Math.sqrt(20 + ft), pt = 1 + 0.045 * rt, Ge = 1 + 0.015 * rt * mt, ct = 30 * Math.PI / 180 * Math.exp(-1 * Math.pow((180 / Math.PI * ot - 275) / 25, 2)), Mt = 2 * Math.sqrt(Math.pow(rt, 7) / (Math.pow(rt, 7) + Math.pow(25, 7))), St = -1 * Math.sin(2 * ct) * Mt;
    return Math.sqrt(
      Math.pow(Ot / ($e * yt), 2) + Math.pow(Ft / (Ze * pt), 2) + Math.pow(We / (Fe * Ge), 2) + St * Ft / (Ze * pt) * We / (Fe * Ge)
    );
  };
}, averageAngle = ($e) => {
  let Ze = $e.reduce(
    (Fe, Ke) => {
      if (Ke !== void 0) {
        let Ve = Ke * Math.PI / 180;
        Fe.sin += Math.sin(Ve), Fe.cos += Math.cos(Ve);
      }
      return Fe;
    },
    { sin: 0, cos: 0 }
  );
  return Math.atan2(Ze.sin, Ze.cos) * 180 / Math.PI;
}, definition$o = {
  mode: "cubehelix",
  channels: ["h", "s", "l", "alpha"],
  parse: ["--cubehelix"],
  serialize: "--cubehelix",
  ranges: {
    h: [0, 360],
    s: [0, 4.614],
    l: [0, 1]
  },
  fromMode: {
    rgb: convertRgbToCubehelix$1
  },
  toMode: {
    rgb: convertCubehelixToRgb$1
  },
  interpolate: {
    h: {
      use: interpolatorLinear,
      fixup: fixupHueShorter
    },
    s: interpolatorLinear,
    l: interpolatorLinear,
    alpha: {
      use: interpolatorLinear,
      fixup: fixupAlpha
    }
  },
  difference: {
    h: differenceHueSaturation
  },
  average: {
    h: averageAngle
  }
}, modeCubehelix = definition$o, convertLabToLch = ({ l: $e, a: Ze, b: Fe, alpha: Ke }, Ve = "lch") => {
  let Je = Math.sqrt(Ze * Ze + Fe * Fe), Qe = { mode: Ve, l: $e, c: Je };
  return Je && (Qe.h = normalizeHue$1(Math.atan2(Fe, Ze) * 180 / Math.PI)), Ke !== void 0 && (Qe.alpha = Ke), Qe;
}, convertLabToLch$1 = convertLabToLch, convertLchToLab = ({ l: $e, c: Ze, h: Fe, alpha: Ke }, Ve = "lab") => {
  let Je = {
    mode: Ve,
    l: $e,
    a: Ze ? Ze * Math.cos(Fe / 180 * Math.PI) : 0,
    b: Ze ? Ze * Math.sin(Fe / 180 * Math.PI) : 0
  };
  return Ke !== void 0 && (Je.alpha = Ke), Je;
}, convertLchToLab$1 = convertLchToLab, k$1 = Math.pow(29, 3) / Math.pow(3, 3), e$1 = Math.pow(6, 3) / Math.pow(29, 3), D50 = {
  X: 0.3457 / 0.3585,
  Y: 1,
  Z: (1 - 0.3457 - 0.3585) / 0.3585
}, D65 = {
  X: 0.3127 / 0.329,
  Y: 1,
  Z: (1 - 0.3127 - 0.329) / 0.329
};
let fn$1 = ($e) => Math.pow($e, 3) > e$1 ? Math.pow($e, 3) : (116 * $e - 16) / k$1;
const convertLab65ToXyz65 = ({ l: $e, a: Ze, b: Fe, alpha: Ke }) => {
  let Ve = ($e + 16) / 116, Je = Ze / 500 + Ve, Qe = Ve - Fe / 200, at = {
    mode: "xyz65",
    x: fn$1(Je) * D65.X,
    y: fn$1(Ve) * D65.Y,
    z: fn$1(Qe) * D65.Z
  };
  return Ke !== void 0 && (at.alpha = Ke), at;
}, convertLab65ToXyz65$1 = convertLab65ToXyz65, convertLab65ToRgb = ($e) => convertXyz65ToRgb$1(convertLab65ToXyz65$1($e)), convertLab65ToRgb$1 = convertLab65ToRgb, f$1 = ($e) => $e > e$1 ? Math.cbrt($e) : (k$1 * $e + 16) / 116, convertXyz65ToLab65 = ({ x: $e, y: Ze, z: Fe, alpha: Ke }) => {
  let Ve = f$1($e / D65.X), Je = f$1(Ze / D65.Y), Qe = f$1(Fe / D65.Z), at = {
    mode: "lab65",
    l: 116 * Je - 16,
    a: 500 * (Ve - Je),
    b: 200 * (Je - Qe)
  };
  return Ke !== void 0 && (at.alpha = Ke), at;
}, convertXyz65ToLab65$1 = convertXyz65ToLab65, convertRgbToLab65 = ($e) => {
  let Ze = convertXyz65ToLab65$1(convertRgbToXyz65$1($e));
  return $e.r === $e.b && $e.b === $e.g && (Ze.a = Ze.b = 0), Ze;
}, convertRgbToLab65$1 = convertRgbToLab65, kE = 1, kCH = 1, θ = 26 / 180 * Math.PI, cosθ = Math.cos(θ), sinθ = Math.sin(θ), factor = 100 / Math.log(139 / 100), convertDlchToLab65 = ({ l: $e, c: Ze, h: Fe, alpha: Ke }) => {
  let Ve = {
    mode: "lab65",
    l: (Math.exp($e * kE / factor) - 1) / 39e-4
  };
  if (Fe === void 0)
    Ve.a = Ve.b = 0;
  else {
    let Je = (Math.exp(0.0435 * Ze * kCH * kE) - 1) / 0.075, Qe = Je * Math.cos(Fe / 180 * Math.PI - θ), at = Je * Math.sin(Fe / 180 * Math.PI - θ);
    Ve.a = Qe * cosθ - at / 0.83 * sinθ, Ve.b = Qe * sinθ + at / 0.83 * cosθ;
  }
  return Ke !== void 0 && (Ve.alpha = Ke), Ve;
}, convertDlchToLab65$1 = convertDlchToLab65, convertLab65ToDlch = ({ l: $e, a: Ze, b: Fe, alpha: Ke }) => {
  let Ve = Ze * cosθ + Fe * sinθ, Je = 0.83 * (Fe * cosθ - Ze * sinθ), Qe = Math.sqrt(Ve * Ve + Je * Je), at = {
    mode: "dlch",
    l: factor / kE * Math.log(1 + 39e-4 * $e),
    c: Math.log(1 + 0.075 * Qe) / (0.0435 * kCH * kE)
  };
  return at.c && (at.h = normalizeHue$1((Math.atan2(Je, Ve) + θ) / Math.PI * 180)), Ke !== void 0 && (at.alpha = Ke), at;
}, convertLab65ToDlch$1 = convertLab65ToDlch, convertDlabToLab65 = ($e) => convertDlchToLab65$1(convertLabToLch$1($e, "dlch")), convertLab65ToDlab = ($e) => convertLchToLab$1(convertLab65ToDlch$1($e), "dlab"), definition$n = {
  mode: "dlab",
  parse: ["--din99o-lab"],
  serialize: "--din99o-lab",
  toMode: {
    lab65: convertDlabToLab65,
    rgb: ($e) => convertLab65ToRgb$1(convertDlabToLab65($e))
  },
  fromMode: {
    lab65: convertLab65ToDlab,
    rgb: ($e) => convertLab65ToDlab(convertRgbToLab65$1($e))
  },
  channels: ["l", "a", "b", "alpha"],
  ranges: {
    l: [0, 100],
    a: [-40.09, 45.501],
    b: [-40.469, 44.344]
  },
  interpolate: {
    l: interpolatorLinear,
    a: interpolatorLinear,
    b: interpolatorLinear,
    alpha: {
      use: interpolatorLinear,
      fixup: fixupAlpha
    }
  }
}, modeDlab = definition$n, definition$m = {
  mode: "dlch",
  parse: ["--din99o-lch"],
  serialize: "--din99o-lch",
  toMode: {
    lab65: convertDlchToLab65$1,
    dlab: ($e) => convertLchToLab$1($e, "dlab"),
    rgb: ($e) => convertLab65ToRgb$1(convertDlchToLab65$1($e))
  },
  fromMode: {
    lab65: convertLab65ToDlch$1,
    dlab: ($e) => convertLabToLch$1($e, "dlch"),
    rgb: ($e) => convertLab65ToDlch$1(convertRgbToLab65$1($e))
  },
  channels: ["l", "c", "h", "alpha"],
  ranges: {
    l: [0, 100],
    c: [0, 51.484],
    h: [0, 360]
  },
  interpolate: {
    l: interpolatorLinear,
    c: interpolatorLinear,
    h: {
      use: interpolatorLinear,
      fixup: fixupHueShorter
    },
    alpha: {
      use: interpolatorLinear,
      fixup: fixupAlpha
    }
  },
  difference: {
    h: differenceHueChroma
  },
  average: {
    h: averageAngle
  }
}, modeDlch = definition$m;
function convertHsiToRgb({ h: $e, s: Ze, i: Fe, alpha: Ke }) {
  $e = normalizeHue$1($e);
  let Ve = Math.abs($e / 60 % 2 - 1), Je;
  switch (Math.floor($e / 60)) {
    case 0:
      Je = {
        r: Fe * (1 + Ze * (3 / (2 - Ve) - 1)),
        g: Fe * (1 + Ze * (3 * (1 - Ve) / (2 - Ve) - 1)),
        b: Fe * (1 - Ze)
      };
      break;
    case 1:
      Je = {
        r: Fe * (1 + Ze * (3 * (1 - Ve) / (2 - Ve) - 1)),
        g: Fe * (1 + Ze * (3 / (2 - Ve) - 1)),
        b: Fe * (1 - Ze)
      };
      break;
    case 2:
      Je = {
        r: Fe * (1 - Ze),
        g: Fe * (1 + Ze * (3 / (2 - Ve) - 1)),
        b: Fe * (1 + Ze * (3 * (1 - Ve) / (2 - Ve) - 1))
      };
      break;
    case 3:
      Je = {
        r: Fe * (1 - Ze),
        g: Fe * (1 + Ze * (3 * (1 - Ve) / (2 - Ve) - 1)),
        b: Fe * (1 + Ze * (3 / (2 - Ve) - 1))
      };
      break;
    case 4:
      Je = {
        r: Fe * (1 + Ze * (3 * (1 - Ve) / (2 - Ve) - 1)),
        g: Fe * (1 - Ze),
        b: Fe * (1 + Ze * (3 / (2 - Ve) - 1))
      };
      break;
    case 5:
      Je = {
        r: Fe * (1 + Ze * (3 / (2 - Ve) - 1)),
        g: Fe * (1 - Ze),
        b: Fe * (1 + Ze * (3 * (1 - Ve) / (2 - Ve) - 1))
      };
      break;
    default:
      Je = { r: Fe * (1 - Ze), g: Fe * (1 - Ze), b: Fe * (1 - Ze) };
  }
  return Je.mode = "rgb", Ke !== void 0 && (Je.alpha = Ke), Je;
}
function convertRgbToHsi({ r: $e, g: Ze, b: Fe, alpha: Ke }) {
  let Ve = Math.max($e, Ze, Fe), Je = Math.min($e, Ze, Fe), Qe = {
    mode: "hsi",
    s: $e + Ze + Fe === 0 ? 0 : 1 - 3 * Je / ($e + Ze + Fe),
    i: ($e + Ze + Fe) / 3
  };
  return Ve - Je !== 0 && (Qe.h = (Ve === $e ? (Ze - Fe) / (Ve - Je) + (Ze < Fe) * 6 : Ve === Ze ? (Fe - $e) / (Ve - Je) + 2 : ($e - Ze) / (Ve - Je) + 4) * 60), Ke !== void 0 && (Qe.alpha = Ke), Qe;
}
const definition$l = {
  mode: "hsi",
  toMode: {
    rgb: convertHsiToRgb
  },
  parse: ["--hsi"],
  serialize: "--hsi",
  fromMode: {
    rgb: convertRgbToHsi
  },
  channels: ["h", "s", "i", "alpha"],
  ranges: {
    h: [0, 360]
  },
  gamut: "rgb",
  interpolate: {
    h: { use: interpolatorLinear, fixup: fixupHueShorter },
    s: interpolatorLinear,
    i: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  },
  difference: {
    h: differenceHueSaturation
  },
  average: {
    h: averageAngle
  }
}, modeHsi = definition$l;
function convertHslToRgb({ h: $e, s: Ze, l: Fe, alpha: Ke }) {
  $e = normalizeHue$1($e);
  let Ve = Fe + Ze * (Fe < 0.5 ? Fe : 1 - Fe), Je = Ve - (Ve - Fe) * 2 * Math.abs($e / 60 % 2 - 1), Qe;
  switch (Math.floor($e / 60)) {
    case 0:
      Qe = { r: Ve, g: Je, b: 2 * Fe - Ve };
      break;
    case 1:
      Qe = { r: Je, g: Ve, b: 2 * Fe - Ve };
      break;
    case 2:
      Qe = { r: 2 * Fe - Ve, g: Ve, b: Je };
      break;
    case 3:
      Qe = { r: 2 * Fe - Ve, g: Je, b: Ve };
      break;
    case 4:
      Qe = { r: Je, g: 2 * Fe - Ve, b: Ve };
      break;
    case 5:
      Qe = { r: Ve, g: 2 * Fe - Ve, b: Je };
      break;
    default:
      Qe = { r: 2 * Fe - Ve, g: 2 * Fe - Ve, b: 2 * Fe - Ve };
  }
  return Qe.mode = "rgb", Ke !== void 0 && (Qe.alpha = Ke), Qe;
}
function convertRgbToHsl({ r: $e, g: Ze, b: Fe, alpha: Ke }) {
  let Ve = Math.max($e, Ze, Fe), Je = Math.min($e, Ze, Fe), Qe = {
    mode: "hsl",
    s: Ve === Je ? 0 : (Ve - Je) / (1 - Math.abs(Ve + Je - 1)),
    l: 0.5 * (Ve + Je)
  };
  return Ve - Je !== 0 && (Qe.h = (Ve === $e ? (Ze - Fe) / (Ve - Je) + (Ze < Fe) * 6 : Ve === Ze ? (Fe - $e) / (Ve - Je) + 2 : ($e - Ze) / (Ve - Je) + 4) * 60), Ke !== void 0 && (Qe.alpha = Ke), Qe;
}
const hueToDeg = ($e, Ze) => {
  switch (Ze) {
    case "deg":
      return +$e;
    case "rad":
      return $e / Math.PI * 180;
    case "grad":
      return $e / 10 * 9;
    case "turn":
      return $e * 360;
  }
}, hueToDeg$1 = hueToDeg, hsl_old = new RegExp(
  `^hsla?\\(\\s*${hue$1}${c}${per}${c}${per}\\s*(?:,\\s*${num_per}\\s*)?\\)$`
), parseHslLegacy = ($e) => {
  let Ze = $e.match(hsl_old);
  if (!Ze)
    return;
  let Fe = { mode: "hsl" };
  return Ze[3] !== void 0 ? Fe.h = +Ze[3] : Ze[1] !== void 0 && Ze[2] !== void 0 && (Fe.h = hueToDeg$1(Ze[1], Ze[2])), Ze[4] !== void 0 && (Fe.s = Math.min(Math.max(0, Ze[4] / 100), 1)), Ze[5] !== void 0 && (Fe.l = Math.min(Math.max(0, Ze[5] / 100), 1)), Ze[6] !== void 0 ? Fe.alpha = Ze[6] / 100 : Ze[7] !== void 0 && (Fe.alpha = +Ze[7]), Fe;
}, parseHslLegacy$1 = parseHslLegacy;
function parseHsl($e, Ze) {
  if (!Ze || Ze[0] !== "hsl" && Ze[0] !== "hsla")
    return;
  const Fe = { mode: "hsl" }, [, Ke, Ve, Je, Qe] = Ze;
  if (Ke.type !== Tok.None) {
    if (Ke.type === Tok.Percentage)
      return;
    Fe.h = Ke.value;
  }
  if (Ve.type !== Tok.None) {
    if (Ve.type === Tok.Hue)
      return;
    Fe.s = Ve.type === Tok.Number ? Ve.value : Ve.value / 100;
  }
  if (Je.type !== Tok.None) {
    if (Je.type === Tok.Hue)
      return;
    Fe.l = Je.type === Tok.Number ? Je.value : Je.value / 100;
  }
  return Qe.type !== Tok.None && (Fe.alpha = Qe.type === Tok.Number ? Qe.value : Qe.value / 100), Fe;
}
const definition$k = {
  mode: "hsl",
  toMode: {
    rgb: convertHslToRgb
  },
  fromMode: {
    rgb: convertRgbToHsl
  },
  channels: ["h", "s", "l", "alpha"],
  ranges: {
    h: [0, 360]
  },
  gamut: "rgb",
  parse: [parseHsl, parseHslLegacy$1],
  serialize: ($e) => `hsl(${$e.h || 0} ${$e.s !== void 0 ? $e.s * 100 + "%" : "none"} ${$e.l !== void 0 ? $e.l * 100 + "%" : "none"}${$e.alpha < 1 ? ` / ${$e.alpha}` : ""})`,
  interpolate: {
    h: { use: interpolatorLinear, fixup: fixupHueShorter },
    s: interpolatorLinear,
    l: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  },
  difference: {
    h: differenceHueSaturation
  },
  average: {
    h: averageAngle
  }
}, modeHsl = definition$k;
function convertHsvToRgb({ h: $e, s: Ze, v: Fe, alpha: Ke }) {
  $e = normalizeHue$1($e);
  let Ve = Math.abs($e / 60 % 2 - 1), Je;
  switch (Math.floor($e / 60)) {
    case 0:
      Je = { r: Fe, g: Fe * (1 - Ze * Ve), b: Fe * (1 - Ze) };
      break;
    case 1:
      Je = { r: Fe * (1 - Ze * Ve), g: Fe, b: Fe * (1 - Ze) };
      break;
    case 2:
      Je = { r: Fe * (1 - Ze), g: Fe, b: Fe * (1 - Ze * Ve) };
      break;
    case 3:
      Je = { r: Fe * (1 - Ze), g: Fe * (1 - Ze * Ve), b: Fe };
      break;
    case 4:
      Je = { r: Fe * (1 - Ze * Ve), g: Fe * (1 - Ze), b: Fe };
      break;
    case 5:
      Je = { r: Fe, g: Fe * (1 - Ze), b: Fe * (1 - Ze * Ve) };
      break;
    default:
      Je = { r: Fe * (1 - Ze), g: Fe * (1 - Ze), b: Fe * (1 - Ze) };
  }
  return Je.mode = "rgb", Ke !== void 0 && (Je.alpha = Ke), Je;
}
function convertRgbToHsv({ r: $e, g: Ze, b: Fe, alpha: Ke }) {
  let Ve = Math.max($e, Ze, Fe), Je = Math.min($e, Ze, Fe), Qe = {
    mode: "hsv",
    s: Ve === 0 ? 0 : 1 - Je / Ve,
    v: Ve
  };
  return Ve - Je !== 0 && (Qe.h = (Ve === $e ? (Ze - Fe) / (Ve - Je) + (Ze < Fe) * 6 : Ve === Ze ? (Fe - $e) / (Ve - Je) + 2 : ($e - Ze) / (Ve - Je) + 4) * 60), Ke !== void 0 && (Qe.alpha = Ke), Qe;
}
const definition$j = {
  mode: "hsv",
  toMode: {
    rgb: convertHsvToRgb
  },
  parse: ["--hsv"],
  serialize: "--hsv",
  fromMode: {
    rgb: convertRgbToHsv
  },
  channels: ["h", "s", "v", "alpha"],
  ranges: {
    h: [0, 360]
  },
  gamut: "rgb",
  interpolate: {
    h: { use: interpolatorLinear, fixup: fixupHueShorter },
    s: interpolatorLinear,
    v: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  },
  difference: {
    h: differenceHueSaturation
  },
  average: {
    h: averageAngle
  }
}, modeHsv = definition$j;
function convertHwbToRgb({ h: $e, w: Ze, b: Fe, alpha: Ke }) {
  if (Ze + Fe > 1) {
    let Ve = Ze + Fe;
    Ze /= Ve, Fe /= Ve;
  }
  return convertHsvToRgb({
    h: $e,
    s: Fe === 1 ? 1 : 1 - Ze / (1 - Fe),
    v: 1 - Fe,
    alpha: Ke
  });
}
function convertRgbToHwb($e) {
  let Ze = convertRgbToHsv($e);
  if (Ze === void 0)
    return;
  let Fe = {
    mode: "hwb",
    w: (1 - Ze.s) * Ze.v,
    b: 1 - Ze.v
  };
  return Ze.h !== void 0 && (Fe.h = Ze.h), Ze.alpha !== void 0 && (Fe.alpha = Ze.alpha), Fe;
}
function ParseHwb($e, Ze) {
  if (!Ze || Ze[0] !== "hwb")
    return;
  const Fe = { mode: "hwb" }, [, Ke, Ve, Je, Qe] = Ze;
  if (Ke.type !== Tok.None) {
    if (Ke.type === Tok.Percentage)
      return;
    Fe.h = Ke.value;
  }
  if (Ve.type !== Tok.None) {
    if (Ve.type === Tok.Hue)
      return;
    Fe.w = Ve.type === Tok.Number ? Ve.value : Ve.value / 100;
  }
  if (Je.type !== Tok.None) {
    if (Je.type === Tok.Hue)
      return;
    Fe.b = Je.type === Tok.Number ? Je.value : Je.value / 100;
  }
  return Qe.type !== Tok.None && (Fe.alpha = Qe.type === Tok.Number ? Qe.value : Qe.value / 100), Fe;
}
const definition$i = {
  mode: "hwb",
  toMode: {
    rgb: convertHwbToRgb
  },
  fromMode: {
    rgb: convertRgbToHwb
  },
  channels: ["h", "w", "b", "alpha"],
  ranges: {
    h: [0, 360]
  },
  gamut: "rgb",
  parse: [ParseHwb],
  serialize: ($e) => `hwb(${$e.h || 0} ${$e.w * 100}% ${$e.b * 100}%${$e.alpha < 1 ? ` / ${$e.alpha}` : ""})`,
  interpolate: {
    h: { use: interpolatorLinear, fixup: fixupHueShorter },
    w: interpolatorLinear,
    b: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  },
  difference: {
    h: differenceHueNaive
  },
  average: {
    h: averageAngle
  }
}, modeHwb = definition$i, n$1 = 0.1593017578125, p$1 = 134.03437499999998, c1$1 = 0.8359375, c2$1 = 18.8515625, c3$1 = 18.6875, d0$1 = 16295499532821565e-27, pq = ($e) => {
  let Ze = Math.pow($e / 1e4, n$1);
  return Math.pow((c1$1 + c2$1 * Ze) / (1 + c3$1 * Ze), p$1) || 0;
}, abs = ($e) => Math.max($e * 203, 0), convertXyz65ToJab = ({ x: $e, y: Ze, z: Fe, alpha: Ke }) => {
  $e = abs($e), Ze = abs(Ze), Fe = abs(Fe);
  let Ve = 1.15 * $e - 0.15 * Fe, Je = 0.66 * Ze + 0.34 * $e, Qe = pq(0.41478972 * Ve + 0.579999 * Je + 0.014648 * Fe), at = pq(-0.20151 * Ve + 1.120649 * Je + 0.0531008 * Fe), ut = pq(-0.0166008 * Ve + 0.2648 * Je + 0.6684799 * Fe), lt = (Qe + at) / 2, dt = {
    mode: "jab",
    j: 0.44 * lt / (1 - 0.56 * lt) - d0$1,
    a: 3.524 * Qe - 4.066708 * at + 0.542708 * ut,
    b: 0.199076 * Qe + 1.096799 * at - 1.295875 * ut
  };
  return Ke !== void 0 && (dt.alpha = Ke), dt;
}, convertXyz65ToJab$1 = convertXyz65ToJab, n = 0.1593017578125, p = 134.03437499999998, c1 = 0.8359375, c2 = 18.8515625, c3 = 18.6875, d0 = 16295499532821565e-27, pq_inv = ($e) => {
  let Ze = Math.pow($e, 1 / p);
  return 1e4 * Math.pow((c1 - Ze) / (c3 * Ze - c2), 1 / n) || 0;
}, rel = ($e) => $e / 203, convertJabToXyz65 = ({ j: $e, a: Ze, b: Fe, alpha: Ke }) => {
  let Ve = ($e + d0) / (0.44 + 0.56 * ($e + d0)), Je = pq_inv(Ve + 0.13860504 * Ze + 0.058047316 * Fe), Qe = pq_inv(Ve - 0.13860504 * Ze - 0.058047316 * Fe), at = pq_inv(Ve - 0.096019242 * Ze - 0.8118919 * Fe), ut = {
    mode: "xyz65",
    x: rel(
      1.661373024652174 * Je - 0.914523081304348 * Qe + 0.23136208173913045 * at
    ),
    y: rel(
      -0.3250758611844533 * Je + 1.571847026732543 * Qe - 0.21825383453227928 * at
    ),
    z: rel(-0.090982811 * Je - 0.31272829 * Qe + 1.5227666 * at)
  };
  return Ke !== void 0 && (ut.alpha = Ke), ut;
}, convertJabToXyz65$1 = convertJabToXyz65, convertRgbToJab = ($e) => {
  let Ze = convertXyz65ToJab$1(convertRgbToXyz65$1($e));
  return $e.r === $e.b && $e.b === $e.g && (Ze.a = Ze.b = 0), Ze;
}, convertRgbToJab$1 = convertRgbToJab, convertJabToRgb = ($e) => convertXyz65ToRgb$1(convertJabToXyz65$1($e)), convertJabToRgb$1 = convertJabToRgb, definition$h = {
  mode: "jab",
  channels: ["j", "a", "b", "alpha"],
  parse: ["--jzazbz"],
  serialize: "--jzazbz",
  fromMode: {
    rgb: convertRgbToJab$1,
    xyz65: convertXyz65ToJab$1
  },
  toMode: {
    rgb: convertJabToRgb$1,
    xyz65: convertJabToXyz65$1
  },
  ranges: {
    j: [0, 0.222],
    a: [-0.109, 0.129],
    b: [-0.185, 0.134]
  },
  interpolate: {
    j: interpolatorLinear,
    a: interpolatorLinear,
    b: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  }
}, modeJab = definition$h, convertJabToJch = ({ j: $e, a: Ze, b: Fe, alpha: Ke }) => {
  let Ve = Math.sqrt(Ze * Ze + Fe * Fe), Je = {
    mode: "jch",
    j: $e,
    c: Ve
  };
  return Ve && (Je.h = normalizeHue$1(Math.atan2(Fe, Ze) * 180 / Math.PI)), Ke !== void 0 && (Je.alpha = Ke), Je;
}, convertJabToJch$1 = convertJabToJch, convertJchToJab = ({ j: $e, c: Ze, h: Fe, alpha: Ke }) => {
  let Ve = {
    mode: "jab",
    j: $e,
    a: Ze ? Ze * Math.cos(Fe / 180 * Math.PI) : 0,
    b: Ze ? Ze * Math.sin(Fe / 180 * Math.PI) : 0
  };
  return Ke !== void 0 && (Ve.alpha = Ke), Ve;
}, convertJchToJab$1 = convertJchToJab, definition$g = {
  mode: "jch",
  parse: ["--jzczhz"],
  serialize: "--jzczhz",
  toMode: {
    jab: convertJchToJab$1,
    rgb: ($e) => convertJabToRgb$1(convertJchToJab$1($e))
  },
  fromMode: {
    rgb: ($e) => convertJabToJch$1(convertRgbToJab$1($e)),
    jab: convertJabToJch$1
  },
  channels: ["j", "c", "h", "alpha"],
  ranges: {
    j: [0, 0.221],
    c: [0, 0.19],
    h: [0, 360]
  },
  interpolate: {
    h: { use: interpolatorLinear, fixup: fixupHueShorter },
    c: interpolatorLinear,
    j: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  },
  difference: {
    h: differenceHueChroma
  },
  average: {
    h: averageAngle
  }
}, modeJch = definition$g, k = Math.pow(29, 3) / Math.pow(3, 3), e = Math.pow(6, 3) / Math.pow(29, 3);
let fn = ($e) => Math.pow($e, 3) > e ? Math.pow($e, 3) : (116 * $e - 16) / k;
const convertLabToXyz50 = ({ l: $e, a: Ze, b: Fe, alpha: Ke }) => {
  let Ve = ($e + 16) / 116, Je = Ze / 500 + Ve, Qe = Ve - Fe / 200, at = {
    mode: "xyz50",
    x: fn(Je) * D50.X,
    y: fn(Ve) * D50.Y,
    z: fn(Qe) * D50.Z
  };
  return Ke !== void 0 && (at.alpha = Ke), at;
}, convertLabToXyz50$1 = convertLabToXyz50, convertXyz50ToRgb = ({ x: $e, y: Ze, z: Fe, alpha: Ke }) => {
  let Ve = convertLrgbToRgb$1({
    r: $e * 3.1341359569958707 - Ze * 1.6173863321612538 - 0.4906619460083532 * Fe,
    g: $e * -0.978795502912089 + Ze * 1.916254567259524 + 0.03344273116131949 * Fe,
    b: $e * 0.07195537988411677 - Ze * 0.2289768264158322 + 1.405386058324125 * Fe
  });
  return Ke !== void 0 && (Ve.alpha = Ke), Ve;
}, convertXyz50ToRgb$1 = convertXyz50ToRgb, convertLabToRgb = ($e) => convertXyz50ToRgb$1(convertLabToXyz50$1($e)), convertLabToRgb$1 = convertLabToRgb, convertRgbToXyz50 = ($e) => {
  let { r: Ze, g: Fe, b: Ke, alpha: Ve } = convertRgbToLrgb$1($e), Je = {
    mode: "xyz50",
    x: 0.436065742824811 * Ze + 0.3851514688337912 * Fe + 0.14307845442264197 * Ke,
    y: 0.22249319175623702 * Ze + 0.7168870538238823 * Fe + 0.06061979053616537 * Ke,
    z: 0.013923904500943465 * Ze + 0.09708128566574634 * Fe + 0.7140993584005155 * Ke
  };
  return Ve !== void 0 && (Je.alpha = Ve), Je;
}, convertRgbToXyz50$1 = convertRgbToXyz50, f = ($e) => $e > e ? Math.cbrt($e) : (k * $e + 16) / 116, convertXyz50ToLab = ({ x: $e, y: Ze, z: Fe, alpha: Ke }) => {
  let Ve = f($e / D50.X), Je = f(Ze / D50.Y), Qe = f(Fe / D50.Z), at = {
    mode: "lab",
    l: 116 * Je - 16,
    a: 500 * (Ve - Je),
    b: 200 * (Je - Qe)
  };
  return Ke !== void 0 && (at.alpha = Ke), at;
}, convertXyz50ToLab$1 = convertXyz50ToLab, convertRgbToLab = ($e) => {
  let Ze = convertXyz50ToLab$1(convertRgbToXyz50$1($e));
  return $e.r === $e.b && $e.b === $e.g && (Ze.a = Ze.b = 0), Ze;
}, convertRgbToLab$1 = convertRgbToLab;
function parseLab($e, Ze) {
  if (!Ze || Ze[0] !== "lab")
    return;
  const Fe = { mode: "lab" }, [, Ke, Ve, Je, Qe] = Ze;
  if (!(Ke.type === Tok.Hue || Ve.type === Tok.Hue || Je.type === Tok.Hue))
    return Ke.type !== Tok.None && (Fe.l = Ke.value), Ve.type !== Tok.None && (Fe.a = Ve.type === Tok.Number ? Ve.value : Ve.value * 125 / 100), Je.type !== Tok.None && (Fe.b = Je.type === Tok.Number ? Je.value : Je.value * 125 / 100), Qe.type !== Tok.None && (Fe.alpha = Qe.type === Tok.Number ? Qe.value : Qe.value / 100), Fe;
}
const definition$f = {
  mode: "lab",
  toMode: {
    xyz50: convertLabToXyz50$1,
    rgb: convertLabToRgb$1
  },
  fromMode: {
    xyz50: convertXyz50ToLab$1,
    rgb: convertRgbToLab$1
  },
  channels: ["l", "a", "b", "alpha"],
  ranges: {
    l: [0, 100],
    a: [-100, 100],
    b: [-100, 100]
  },
  parse: [parseLab],
  serialize: ($e) => `lab(${$e.l !== void 0 ? $e.l : "none"} ${$e.a !== void 0 ? $e.a : "none"} ${$e.b !== void 0 ? $e.b : "none"}${$e.alpha < 1 ? ` / ${$e.alpha}` : ""})`,
  interpolate: {
    l: interpolatorLinear,
    a: interpolatorLinear,
    b: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  }
}, modeLab = definition$f, definition$e = {
  ...modeLab,
  mode: "lab65",
  parse: ["--lab-d65"],
  serialize: "--lab-d65",
  toMode: {
    xyz65: convertLab65ToXyz65$1,
    rgb: convertLab65ToRgb$1
  },
  fromMode: {
    xyz65: convertXyz65ToLab65$1,
    rgb: convertRgbToLab65$1
  },
  ranges: {
    l: [0, 100],
    a: [-86.182, 98.234],
    b: [-107.86, 94.477]
  }
}, modeLab65 = definition$e;
function parseLch($e, Ze) {
  if (!Ze || Ze[0] !== "lch")
    return;
  const Fe = { mode: "lch" }, [, Ke, Ve, Je, Qe] = Ze;
  if (Ke.type !== Tok.None) {
    if (Ke.type === Tok.Hue)
      return;
    Fe.l = Ke.value;
  }
  if (Ve.type !== Tok.None && (Fe.c = Math.max(
    0,
    Ve.type === Tok.Number ? Ve.value : Ve.value * 150 / 100
  )), Je.type !== Tok.None) {
    if (Je.type === Tok.Percentage)
      return;
    Fe.h = Je.value;
  }
  return Qe.type !== Tok.None && (Fe.alpha = Qe.type === Tok.Number ? Qe.value : Qe.value / 100), Fe;
}
const definition$d = {
  mode: "lch",
  toMode: {
    lab: convertLchToLab$1,
    rgb: ($e) => convertLabToRgb$1(convertLchToLab$1($e))
  },
  fromMode: {
    rgb: ($e) => convertLabToLch$1(convertRgbToLab$1($e)),
    lab: convertLabToLch$1
  },
  channels: ["l", "c", "h", "alpha"],
  ranges: {
    l: [0, 100],
    c: [0, 150],
    h: [0, 360]
  },
  parse: [parseLch],
  serialize: ($e) => `lch(${$e.l !== void 0 ? $e.l : "none"} ${$e.c !== void 0 ? $e.c : "none"} ${$e.h || 0}${$e.alpha < 1 ? ` / ${$e.alpha}` : ""})`,
  interpolate: {
    h: { use: interpolatorLinear, fixup: fixupHueShorter },
    c: interpolatorLinear,
    l: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  },
  difference: {
    h: differenceHueChroma
  },
  average: {
    h: averageAngle
  }
}, modeLch = definition$d, definition$c = {
  ...modeLch,
  mode: "lch65",
  parse: ["--lch-d65"],
  serialize: "--lch-d65",
  toMode: {
    lab65: ($e) => convertLchToLab$1($e, "lab65"),
    rgb: ($e) => convertLab65ToRgb$1(convertLchToLab$1($e, "lab65"))
  },
  fromMode: {
    rgb: ($e) => convertLabToLch$1(convertRgbToLab65$1($e), "lch65"),
    lab65: ($e) => convertLabToLch$1($e, "lch65")
  },
  ranges: {
    l: [0, 100],
    c: [0, 133.807],
    h: [0, 360]
  }
}, modeLch65 = definition$c, convertLuvToLchuv = ({ l: $e, u: Ze, v: Fe, alpha: Ke }) => {
  let Ve = Math.sqrt(Ze * Ze + Fe * Fe), Je = {
    mode: "lchuv",
    l: $e,
    c: Ve
  };
  return Ve && (Je.h = normalizeHue$1(Math.atan2(Fe, Ze) * 180 / Math.PI)), Ke !== void 0 && (Je.alpha = Ke), Je;
}, convertLuvToLchuv$1 = convertLuvToLchuv, convertLchuvToLuv = ({ l: $e, c: Ze, h: Fe, alpha: Ke }) => {
  let Ve = {
    mode: "luv",
    l: $e,
    u: Ze ? Ze * Math.cos(Fe / 180 * Math.PI) : 0,
    v: Ze ? Ze * Math.sin(Fe / 180 * Math.PI) : 0
  };
  return Ke !== void 0 && (Ve.alpha = Ke), Ve;
}, convertLchuvToLuv$1 = convertLchuvToLuv, u_fn$1 = ($e, Ze, Fe) => 4 * $e / ($e + 15 * Ze + 3 * Fe), v_fn$1 = ($e, Ze, Fe) => 9 * Ze / ($e + 15 * Ze + 3 * Fe), un$1 = u_fn$1(D50.X, D50.Y, D50.Z), vn$1 = v_fn$1(D50.X, D50.Y, D50.Z), l_fn = ($e) => $e <= e ? k * $e : 116 * Math.cbrt($e) - 16, convertXyz50ToLuv = ({ x: $e, y: Ze, z: Fe, alpha: Ke }) => {
  let Ve = l_fn(Ze / D50.Y), Je = u_fn$1($e, Ze, Fe), Qe = v_fn$1($e, Ze, Fe);
  !isFinite(Je) || !isFinite(Qe) ? Ve = Je = Qe = 0 : (Je = 13 * Ve * (Je - un$1), Qe = 13 * Ve * (Qe - vn$1));
  let at = {
    mode: "luv",
    l: Ve,
    u: Je,
    v: Qe
  };
  return Ke !== void 0 && (at.alpha = Ke), at;
}, convertXyz50ToLuv$1 = convertXyz50ToLuv, u_fn = ($e, Ze, Fe) => 4 * $e / ($e + 15 * Ze + 3 * Fe), v_fn = ($e, Ze, Fe) => 9 * Ze / ($e + 15 * Ze + 3 * Fe), un = u_fn(D50.X, D50.Y, D50.Z), vn = v_fn(D50.X, D50.Y, D50.Z), convertLuvToXyz50 = ({ l: $e, u: Ze, v: Fe, alpha: Ke }) => {
  let Ve = Ze / (13 * $e) + un, Je = Fe / (13 * $e) + vn, Qe = D50.Y * ($e <= 8 ? $e / k : Math.pow(($e + 16) / 116, 3)), at = Qe * (9 * Ve) / (4 * Je), ut = Qe * (12 - 3 * Ve - 20 * Je) / (4 * Je), lt = { mode: "xyz50", x: at, y: Qe, z: ut };
  return Ke !== void 0 && (lt.alpha = Ke), lt;
}, convertLuvToXyz50$1 = convertLuvToXyz50, convertRgbToLchuv = ($e) => convertLuvToLchuv$1(convertXyz50ToLuv$1(convertRgbToXyz50$1($e))), convertLchuvToRgb = ($e) => convertXyz50ToRgb$1(convertLuvToXyz50$1(convertLchuvToLuv$1($e))), definition$b = {
  mode: "lchuv",
  toMode: {
    luv: convertLchuvToLuv$1,
    rgb: convertLchuvToRgb
  },
  fromMode: {
    rgb: convertRgbToLchuv,
    luv: convertLuvToLchuv$1
  },
  channels: ["l", "c", "h", "alpha"],
  parse: ["--lchuv"],
  serialize: "--lchuv",
  ranges: {
    l: [0, 100],
    c: [0, 176.956],
    h: [0, 360]
  },
  interpolate: {
    h: { use: interpolatorLinear, fixup: fixupHueShorter },
    c: interpolatorLinear,
    l: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  },
  difference: {
    h: differenceHueChroma
  },
  average: {
    h: averageAngle
  }
}, modeLchuv = definition$b, definition$a = {
  ...modeRgb,
  mode: "lrgb",
  toMode: {
    rgb: convertLrgbToRgb$1
  },
  fromMode: {
    rgb: convertRgbToLrgb$1
  },
  parse: ["srgb-linear"],
  serialize: "srgb-linear"
}, modeLrgb = definition$a, definition$9 = {
  mode: "luv",
  toMode: {
    xyz50: convertLuvToXyz50$1,
    rgb: ($e) => convertXyz50ToRgb$1(convertLuvToXyz50$1($e))
  },
  fromMode: {
    xyz50: convertXyz50ToLuv$1,
    rgb: ($e) => convertXyz50ToLuv$1(convertRgbToXyz50$1($e))
  },
  channels: ["l", "u", "v", "alpha"],
  parse: ["--luv"],
  serialize: "--luv",
  ranges: {
    l: [0, 100],
    u: [-84.936, 175.042],
    v: [-125.882, 87.243]
  },
  interpolate: {
    l: interpolatorLinear,
    u: interpolatorLinear,
    v: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  }
}, modeLuv = definition$9, convertLrgbToOklab = ({ r: $e, g: Ze, b: Fe, alpha: Ke }) => {
  let Ve = Math.cbrt(
    0.41222147079999993 * $e + 0.5363325363 * Ze + 0.0514459929 * Fe
  ), Je = Math.cbrt(
    0.2119034981999999 * $e + 0.6806995450999999 * Ze + 0.1073969566 * Fe
  ), Qe = Math.cbrt(
    0.08830246189999998 * $e + 0.2817188376 * Ze + 0.6299787005000002 * Fe
  ), at = {
    mode: "oklab",
    l: 0.2104542553 * Ve + 0.793617785 * Je - 0.0040720468 * Qe,
    a: 1.9779984951 * Ve - 2.428592205 * Je + 0.4505937099 * Qe,
    b: 0.0259040371 * Ve + 0.7827717662 * Je - 0.808675766 * Qe
  };
  return Ke !== void 0 && (at.alpha = Ke), at;
}, convertLrgbToOklab$1 = convertLrgbToOklab, convertRgbToOklab = ($e) => {
  let Ze = convertLrgbToOklab$1(convertRgbToLrgb$1($e));
  return $e.r === $e.b && $e.b === $e.g && (Ze.a = Ze.b = 0), Ze;
}, convertRgbToOklab$1 = convertRgbToOklab, convertOklabToLrgb = ({ l: $e, a: Ze, b: Fe, alpha: Ke }) => {
  let Ve = Math.pow(
    $e * 0.9999999984505198 + 0.39633779217376786 * Ze + 0.2158037580607588 * Fe,
    3
  ), Je = Math.pow(
    $e * 1.0000000088817609 - 0.10556134232365635 * Ze - 0.06385417477170591 * Fe,
    3
  ), Qe = Math.pow(
    $e * 1.0000000546724108 - 0.08948418209496575 * Ze - 1.2914855378640917 * Fe,
    3
  ), at = {
    mode: "lrgb",
    r: 4.076741661347994 * Ve - 3.307711590408193 * Je + 0.230969928729428 * Qe,
    g: -1.2684380040921763 * Ve + 2.6097574006633715 * Je - 0.3413193963102197 * Qe,
    b: -0.004196086541837188 * Ve - 0.7034186144594493 * Je + 1.7076147009309444 * Qe
  };
  return Ke !== void 0 && (at.alpha = Ke), at;
}, convertOklabToLrgb$1 = convertOklabToLrgb, convertOklabToRgb = ($e) => convertLrgbToRgb$1(convertOklabToLrgb$1($e)), convertOklabToRgb$1 = convertOklabToRgb;
function toe($e) {
  const Ke = 1.170873786407767;
  return 0.5 * (Ke * $e - 0.206 + Math.sqrt((Ke * $e - 0.206) * (Ke * $e - 0.206) + 4 * 0.03 * Ke * $e));
}
function toe_inv($e) {
  const Ke = 1.170873786407767;
  return ($e * $e + 0.206 * $e) / (Ke * ($e + 0.03));
}
function compute_max_saturation($e, Ze) {
  let Fe, Ke, Ve, Je, Qe, at, ut, lt;
  -1.88170328 * $e - 0.80936493 * Ze > 1 ? (Fe = 1.19086277, Ke = 1.76576728, Ve = 0.59662641, Je = 0.75515197, Qe = 0.56771245, at = 4.0767416621, ut = -3.3077115913, lt = 0.2309699292) : 1.81444104 * $e - 1.19445276 * Ze > 1 ? (Fe = 0.73956515, Ke = -0.45954404, Ve = 0.08285427, Je = 0.1254107, Qe = 0.14503204, at = -1.2684380046, ut = 2.6097574011, lt = -0.3413193965) : (Fe = 1.35733652, Ke = -915799e-8, Ve = -1.1513021, Je = -0.50559606, Qe = 692167e-8, at = -0.0041960863, ut = -0.7034186147, lt = 1.707614701);
  let dt = Fe + Ke * $e + Ve * Ze + Je * $e * $e + Qe * $e * Ze, bt = 0.3963377774 * $e + 0.2158037573 * Ze, $t = -0.1055613458 * $e - 0.0638541728 * Ze, vt = -0.0894841775 * $e - 1.291485548 * Ze;
  {
    let wt = 1 + dt * bt, xt = 1 + dt * $t, Et = 1 + dt * vt, Tt = wt * wt * wt, Rt = xt * xt * xt, Ct = Et * Et * Et, Zt = 3 * bt * wt * wt, Lt = 3 * $t * xt * xt, Ut = 3 * vt * Et * Et, Pt = 6 * bt * bt * wt, Ot = 6 * $t * $t * xt, Ft = 6 * vt * vt * Et, gt = at * Tt + ut * Rt + lt * Ct, We = at * Zt + ut * Lt + lt * Ut, Xe = at * Pt + ut * Ot + lt * Ft;
    dt = dt - gt * We / (We * We - 0.5 * gt * Xe);
  }
  return dt;
}
function find_cusp($e, Ze) {
  let Fe = compute_max_saturation($e, Ze), Ke = convertOklabToLrgb$1({ l: 1, a: Fe * $e, b: Fe * Ze }), Ve = Math.cbrt(1 / Math.max(Ke.r, Ke.g, Ke.b)), Je = Ve * Fe;
  return [Ve, Je];
}
function find_gamut_intersection($e, Ze, Fe, Ke, Ve, Je = null) {
  Je || (Je = find_cusp($e, Ze));
  let Qe;
  if ((Fe - Ve) * Je[1] - (Je[0] - Ve) * Ke <= 0)
    Qe = Je[1] * Ve / (Ke * Je[0] + Je[1] * (Ve - Fe));
  else {
    Qe = Je[1] * (Ve - 1) / (Ke * (Je[0] - 1) + Je[1] * (Ve - Fe));
    {
      let at = Fe - Ve, ut = Ke, lt = 0.3963377774 * $e + 0.2158037573 * Ze, dt = -0.1055613458 * $e - 0.0638541728 * Ze, bt = -0.0894841775 * $e - 1.291485548 * Ze, $t = at + ut * lt, vt = at + ut * dt, wt = at + ut * bt;
      {
        let xt = Ve * (1 - Qe) + Qe * Fe, Et = Qe * Ke, Tt = xt + Et * lt, Rt = xt + Et * dt, Ct = xt + Et * bt, Zt = Tt * Tt * Tt, Lt = Rt * Rt * Rt, Ut = Ct * Ct * Ct, Pt = 3 * $t * Tt * Tt, Ot = 3 * vt * Rt * Rt, Ft = 3 * wt * Ct * Ct, gt = 6 * $t * $t * Tt, We = 6 * vt * vt * Rt, Xe = 6 * wt * wt * Ct, rt = 4.0767416621 * Zt - 3.3077115913 * Lt + 0.2309699292 * Ut - 1, ot = 4.0767416621 * Pt - 3.3077115913 * Ot + 0.2309699292 * Ft, ft = 4.0767416621 * gt - 3.3077115913 * We + 0.2309699292 * Xe, mt = ot / (ot * ot - 0.5 * rt * ft), yt = -rt * mt, pt = -1.2684380046 * Zt + 2.6097574011 * Lt - 0.3413193965 * Ut - 1, Ge = -1.2684380046 * Pt + 2.6097574011 * Ot - 0.3413193965 * Ft, ct = -1.2684380046 * gt + 2.6097574011 * We - 0.3413193965 * Xe, Mt = Ge / (Ge * Ge - 0.5 * pt * ct), St = -pt * Mt, At = -0.0041960863 * Zt - 0.7034186147 * Lt + 1.707614701 * Ut - 1, Nt = -0.0041960863 * Pt - 0.7034186147 * Ot + 1.707614701 * Ft, qt = -0.0041960863 * gt - 0.7034186147 * We + 1.707614701 * Xe, Qt = Nt / (Nt * Nt - 0.5 * At * qt), Xt = -At * Qt;
        yt = mt >= 0 ? yt : 1e6, St = Mt >= 0 ? St : 1e6, Xt = Qt >= 0 ? Xt : 1e6, Qe += Math.min(yt, Math.min(St, Xt));
      }
    }
  }
  return Qe;
}
function get_ST_max($e, Ze, Fe = null) {
  Fe || (Fe = find_cusp($e, Ze));
  let Ke = Fe[0], Ve = Fe[1];
  return [Ve / Ke, Ve / (1 - Ke)];
}
function get_Cs($e, Ze, Fe) {
  let Ke = find_cusp(Ze, Fe), Ve = find_gamut_intersection(Ze, Fe, $e, 1, $e, Ke), Je = get_ST_max(Ze, Fe, Ke), Qe = 0.11516993 + 1 / (7.4477897 + 4.1590124 * Fe + Ze * (-2.19557347 + 1.75198401 * Fe + Ze * (-2.13704948 - 10.02301043 * Fe + Ze * (-4.24894561 + 5.38770819 * Fe + 4.69891013 * Ze)))), at = 0.11239642 + 1 / (1.6132032 - 0.68124379 * Fe + Ze * (0.40370612 + 0.90148123 * Fe + Ze * (-0.27087943 + 0.6122399 * Fe + Ze * (299215e-8 - 0.45399568 * Fe - 0.14661872 * Ze)))), ut = Ve / Math.min($e * Je[0], (1 - $e) * Je[1]), lt = $e * Qe, dt = (1 - $e) * at, bt = 0.9 * ut * Math.sqrt(
    Math.sqrt(
      1 / (1 / (lt * lt * lt * lt) + 1 / (dt * dt * dt * dt))
    )
  );
  return lt = $e * 0.4, dt = (1 - $e) * 0.8, [Math.sqrt(1 / (1 / (lt * lt) + 1 / (dt * dt))), bt, Ve];
}
function convertOklabToOkhsl($e) {
  const Ze = { mode: "okhsl", l: toe($e.l) };
  $e.alpha !== void 0 && (Ze.alpha = $e.alpha);
  let Fe = Math.sqrt($e.a * $e.a + $e.b * $e.b);
  if (!Fe)
    return Ze.s = 0, Ze;
  let [Ke, Ve, Je] = get_Cs($e.l, $e.a / Fe, $e.b / Fe), Qe;
  if (Fe < Ve) {
    let at = 0, ut = 0.8 * Ke, lt = 1 - ut / Ve;
    Qe = (Fe - at) / (ut + lt * (Fe - at)) * 0.8;
  } else {
    let at = Ve, ut = 0.2 * Ve * Ve * 1.25 * 1.25 / Ke, lt = 1 - ut / (Je - Ve);
    Qe = 0.8 + 0.2 * ((Fe - at) / (ut + lt * (Fe - at)));
  }
  return Qe && (Ze.s = Qe, Ze.h = normalizeHue$1(Math.atan2($e.b, $e.a) * 180 / Math.PI)), Ze;
}
function convertOkhslToOklab($e) {
  let Ze = toe_inv($e.l);
  const Fe = { mode: "oklab", l: Ze };
  if ($e.alpha !== void 0 && (Fe.alpha = $e.alpha), !$e.s || $e.l === 1)
    return Fe.a = Fe.b = 0, Fe;
  let Ke = Math.cos($e.h / 180 * Math.PI), Ve = Math.sin($e.h / 180 * Math.PI), [Je, Qe, at] = get_Cs(Ze, Ke, Ve), ut, lt, dt, bt;
  $e.s < 0.8 ? (ut = 1.25 * $e.s, lt = 0, dt = 0.8 * Je, bt = 1 - dt / Qe) : (ut = 5 * ($e.s - 0.8), lt = Qe, dt = 0.2 * Qe * Qe * 1.25 * 1.25 / Je, bt = 1 - dt / (at - Qe));
  let $t = lt + ut * dt / (1 - bt * ut);
  return Fe.a = $t * Ke, Fe.b = $t * Ve, Fe;
}
const modeOkhsl = {
  ...modeHsl,
  mode: "okhsl",
  channels: ["h", "s", "l", "alpha"],
  parse: ["--okhsl"],
  serialize: "--okhsl",
  fromMode: {
    oklab: convertOklabToOkhsl,
    rgb: ($e) => convertOklabToOkhsl(convertRgbToOklab$1($e))
  },
  toMode: {
    oklab: convertOkhslToOklab,
    rgb: ($e) => convertOklabToRgb$1(convertOkhslToOklab($e))
  }
}, modeOkhsl$1 = modeOkhsl;
function convertOklabToOkhsv($e) {
  let Ze = Math.sqrt($e.a * $e.a + $e.b * $e.b), Fe = $e.l, Ke = Ze ? $e.a / Ze : 1, Ve = Ze ? $e.b / Ze : 1, [Je, Qe] = get_ST_max(Ke, Ve), at = 0.5, ut = 1 - at / Je, lt = Qe / (Ze + Fe * Qe), dt = lt * Fe, bt = lt * Ze, $t = toe_inv(dt), vt = bt * $t / dt, wt = convertOklabToLrgb$1({ l: $t, a: Ke * vt, b: Ve * vt }), xt = Math.cbrt(
    1 / Math.max(wt.r, wt.g, wt.b, 0)
  );
  Fe = Fe / xt, Ze = Ze / xt * toe(Fe) / Fe, Fe = toe(Fe);
  const Et = {
    mode: "okhsv",
    s: Ze ? (at + Qe) * bt / (Qe * at + Qe * ut * bt) : 0,
    v: Fe ? Fe / dt : 0
  };
  return Et.s && (Et.h = normalizeHue$1(Math.atan2($e.b, $e.a) * 180 / Math.PI)), $e.alpha !== void 0 && (Et.alpha = $e.alpha), Et;
}
function convertOkhsvToOklab($e) {
  const Ze = { mode: "oklab" };
  $e.alpha !== void 0 && (Ze.alpha = $e.alpha);
  const Fe = $e.h || 0, Ke = Math.cos(Fe / 180 * Math.PI), Ve = Math.sin(Fe / 180 * Math.PI), [Je, Qe] = get_ST_max(Ke, Ve), at = 0.5, ut = 1 - at / Je, lt = 1 - $e.s * at / (at + Qe - Qe * ut * $e.s), dt = $e.s * Qe * at / (at + Qe - Qe * ut * $e.s), bt = toe_inv(lt), $t = dt * bt / lt, vt = convertOklabToLrgb$1({
    l: bt,
    a: Ke * $t,
    b: Ve * $t
  }), wt = Math.cbrt(
    1 / Math.max(vt.r, vt.g, vt.b, 0)
  ), xt = toe_inv($e.v * lt), Et = dt * xt / lt;
  return Ze.l = xt * wt, Ze.a = Et * Ke * wt, Ze.b = Et * Ve * wt, Ze;
}
const modeOkhsv = {
  ...modeHsv,
  mode: "okhsv",
  channels: ["h", "s", "v", "alpha"],
  parse: ["--okhsv"],
  serialize: "--okhsv",
  fromMode: {
    oklab: convertOklabToOkhsv,
    rgb: ($e) => convertOklabToOkhsv(convertRgbToOklab$1($e))
  },
  toMode: {
    oklab: convertOkhsvToOklab,
    rgb: ($e) => convertOklabToRgb$1(convertOkhsvToOklab($e))
  }
}, modeOkhsv$1 = modeOkhsv;
function parseOklab($e, Ze) {
  if (!Ze || Ze[0] !== "oklab")
    return;
  const Fe = { mode: "oklab" }, [, Ke, Ve, Je, Qe] = Ze;
  if (!(Ke.type === Tok.Hue || Ve.type === Tok.Hue || Je.type === Tok.Hue))
    return Ke.type !== Tok.None && (Fe.l = Ke.type === Tok.Number ? Ke.value : Ke.value / 100), Ve.type !== Tok.None && (Fe.a = Ve.type === Tok.Number ? Ve.value : Ve.value * 0.4 / 100), Je.type !== Tok.None && (Fe.b = Je.type === Tok.Number ? Je.value : Je.value * 0.4 / 100), Qe.type !== Tok.None && (Fe.alpha = Qe.type === Tok.Number ? Qe.value : Qe.value / 100), Fe;
}
const definition$8 = {
  ...modeLab,
  mode: "oklab",
  toMode: {
    lrgb: convertOklabToLrgb$1,
    rgb: convertOklabToRgb$1
  },
  fromMode: {
    lrgb: convertLrgbToOklab$1,
    rgb: convertRgbToOklab$1
  },
  ranges: {
    l: [0, 1],
    a: [-0.4, 0.4],
    b: [-0.4, 0.4]
  },
  parse: [parseOklab],
  serialize: ($e) => `oklab(${$e.l !== void 0 ? $e.l : "none"} ${$e.a !== void 0 ? $e.a : "none"} ${$e.b !== void 0 ? $e.b : "none"}${$e.alpha < 1 ? ` / ${$e.alpha}` : ""})`
}, modeOklab = definition$8;
function parseOklch($e, Ze) {
  if (!Ze || Ze[0] !== "oklch")
    return;
  const Fe = { mode: "oklch" }, [, Ke, Ve, Je, Qe] = Ze;
  if (Ke.type !== Tok.None) {
    if (Ke.type === Tok.Hue)
      return;
    Fe.l = Ke.type === Tok.Number ? Ke.value : Ke.value / 100;
  }
  if (Ve.type !== Tok.None && (Fe.c = Math.max(
    0,
    Ve.type === Tok.Number ? Ve.value : Ve.value * 0.4 / 100
  )), Je.type !== Tok.None) {
    if (Je.type === Tok.Percentage)
      return;
    Fe.h = Je.value;
  }
  return Qe.type !== Tok.None && (Fe.alpha = Qe.type === Tok.Number ? Qe.value : Qe.value / 100), Fe;
}
const definition$7 = {
  ...modeLch,
  mode: "oklch",
  toMode: {
    oklab: ($e) => convertLchToLab$1($e, "oklab"),
    rgb: ($e) => convertOklabToRgb$1(convertLchToLab$1($e, "oklab"))
  },
  fromMode: {
    rgb: ($e) => convertLabToLch$1(convertRgbToOklab$1($e), "oklch"),
    oklab: ($e) => convertLabToLch$1($e, "oklch")
  },
  parse: [parseOklch],
  serialize: ($e) => `oklch(${$e.l !== void 0 ? $e.l : "none"} ${$e.c !== void 0 ? $e.c : "none"} ${$e.h || 0}${$e.alpha < 1 ? ` / ${$e.alpha}` : ""})`,
  ranges: {
    l: [0, 1],
    c: [0, 0.4],
    h: [0, 360]
  }
}, modeOklch = definition$7, convertP3ToXyz65 = ($e) => {
  let { r: Ze, g: Fe, b: Ke, alpha: Ve } = convertRgbToLrgb$1($e), Je = {
    mode: "xyz65",
    x: 0.486570948648216 * Ze + 0.265667693169093 * Fe + 0.1982172852343625 * Ke,
    y: 0.2289745640697487 * Ze + 0.6917385218365062 * Fe + 0.079286914093745 * Ke,
    z: 0 * Ze + 0.0451133818589026 * Fe + 1.043944368900976 * Ke
  };
  return Ve !== void 0 && (Je.alpha = Ve), Je;
}, convertP3ToXyz65$1 = convertP3ToXyz65, convertXyz65ToP3 = ({ x: $e, y: Ze, z: Fe, alpha: Ke }) => {
  let Ve = convertLrgbToRgb$1(
    {
      r: $e * 2.4934969119414263 - Ze * 0.9313836179191242 - 0.402710784450717 * Fe,
      g: $e * -0.8294889695615749 + Ze * 1.7626640603183465 + 0.0236246858419436 * Fe,
      b: $e * 0.0358458302437845 - Ze * 0.0761723892680418 + 0.9568845240076871 * Fe
    },
    "p3"
  );
  return Ke !== void 0 && (Ve.alpha = Ke), Ve;
}, convertXyz65ToP3$1 = convertXyz65ToP3, definition$6 = {
  ...modeRgb,
  mode: "p3",
  parse: ["display-p3"],
  serialize: "display-p3",
  fromMode: {
    rgb: ($e) => convertXyz65ToP3$1(convertRgbToXyz65$1($e)),
    xyz65: convertXyz65ToP3$1
  },
  toMode: {
    rgb: ($e) => convertXyz65ToRgb$1(convertP3ToXyz65$1($e)),
    xyz65: convertP3ToXyz65$1
  }
}, modeP3 = definition$6, gamma$1 = ($e) => {
  let Ze = Math.abs($e);
  return Ze >= 1 / 512 ? Math.sign($e) * Math.pow(Ze, 1 / 1.8) : 16 * $e;
}, convertXyz50ToProphoto = ({ x: $e, y: Ze, z: Fe, alpha: Ke }) => {
  let Ve = {
    mode: "prophoto",
    r: gamma$1(
      $e * 1.3457868816471585 - Ze * 0.2555720873797946 - 0.0511018649755453 * Fe
    ),
    g: gamma$1(
      $e * -0.5446307051249019 + Ze * 1.5082477428451466 + 0.0205274474364214 * Fe
    ),
    b: gamma$1($e * 0 + Ze * 0 + 1.2119675456389452 * Fe)
  };
  return Ke !== void 0 && (Ve.alpha = Ke), Ve;
}, convertXyz50ToProphoto$1 = convertXyz50ToProphoto, linearize$1 = ($e) => {
  let Ze = Math.abs($e);
  return Ze >= 16 / 512 ? Math.sign($e) * Math.pow(Ze, 1.8) : $e / 16;
}, convertProphotoToXyz50 = ($e) => {
  let Ze = linearize$1($e.r), Fe = linearize$1($e.g), Ke = linearize$1($e.b), Ve = {
    mode: "xyz50",
    x: 0.7977666449006423 * Ze + 0.1351812974005331 * Fe + 0.0313477341283922 * Ke,
    y: 0.2880748288194013 * Ze + 0.7118352342418731 * Fe + 899369387256e-16 * Ke,
    z: 0 * Ze + 0 * Fe + 0.8251046025104602 * Ke
  };
  return $e.alpha !== void 0 && (Ve.alpha = $e.alpha), Ve;
}, convertProphotoToXyz50$1 = convertProphotoToXyz50, definition$5 = {
  ...modeRgb,
  mode: "prophoto",
  parse: ["prophoto-rgb"],
  serialize: "prophoto-rgb",
  fromMode: {
    xyz50: convertXyz50ToProphoto$1,
    rgb: ($e) => convertXyz50ToProphoto$1(convertRgbToXyz50$1($e))
  },
  toMode: {
    xyz50: convertProphotoToXyz50$1,
    rgb: ($e) => convertXyz50ToRgb$1(convertProphotoToXyz50$1($e))
  }
}, modeProphoto = definition$5, α$1 = 1.09929682680944, β$1 = 0.018053968510807, gamma = ($e) => {
  const Ze = Math.abs($e);
  return Ze > β$1 ? (Math.sign($e) || 1) * (α$1 * Math.pow(Ze, 0.45) - (α$1 - 1)) : 4.5 * $e;
}, convertXyz65ToRec2020 = ({ x: $e, y: Ze, z: Fe, alpha: Ke }) => {
  let Ve = {
    mode: "rec2020",
    r: gamma(
      $e * 1.7166511879712683 - Ze * 0.3556707837763925 - 0.2533662813736599 * Fe
    ),
    g: gamma(
      $e * -0.6666843518324893 + Ze * 1.6164812366349395 + 0.0157685458139111 * Fe
    ),
    b: gamma(
      $e * 0.0176398574453108 - Ze * 0.0427706132578085 + 0.9421031212354739 * Fe
    )
  };
  return Ke !== void 0 && (Ve.alpha = Ke), Ve;
}, convertXyz65ToRec2020$1 = convertXyz65ToRec2020, α = 1.09929682680944, β = 0.018053968510807, linearize = ($e) => {
  let Ze = Math.abs($e);
  return Ze < β * 4.5 ? $e / 4.5 : (Math.sign($e) || 1) * Math.pow((Ze + α - 1) / α, 1 / 0.45);
}, convertRec2020ToXyz65 = ($e) => {
  let Ze = linearize($e.r), Fe = linearize($e.g), Ke = linearize($e.b), Ve = {
    mode: "xyz65",
    x: 0.6369580483012911 * Ze + 0.1446169035862083 * Fe + 0.1688809751641721 * Ke,
    y: 0.262700212011267 * Ze + 0.6779980715188708 * Fe + 0.059301716469862 * Ke,
    z: 0 * Ze + 0.0280726930490874 * Fe + 1.0609850577107909 * Ke
  };
  return $e.alpha !== void 0 && (Ve.alpha = $e.alpha), Ve;
}, convertRec2020ToXyz65$1 = convertRec2020ToXyz65, definition$4 = {
  ...modeRgb,
  mode: "rec2020",
  fromMode: {
    xyz65: convertXyz65ToRec2020$1,
    rgb: ($e) => convertXyz65ToRec2020$1(convertRgbToXyz65$1($e))
  },
  toMode: {
    xyz65: convertRec2020ToXyz65$1,
    rgb: ($e) => convertXyz65ToRgb$1(convertRec2020ToXyz65$1($e))
  },
  parse: ["rec2020"],
  serialize: "rec2020"
}, modeRec2020 = definition$4, bias = 0.0037930732552754493, bias_cbrt = Math.cbrt(bias), transfer$1 = ($e) => Math.cbrt($e) - bias_cbrt, convertRgbToXyb = ($e) => {
  const { r: Ze, g: Fe, b: Ke, alpha: Ve } = convertRgbToLrgb$1($e), Je = transfer$1(0.3 * Ze + 0.622 * Fe + 0.078 * Ke + bias), Qe = transfer$1(0.23 * Ze + 0.692 * Fe + 0.078 * Ke + bias), at = transfer$1(
    0.2434226892454782 * Ze + 0.2047674442449682 * Fe + 0.5518098665095535 * Ke + bias
  ), ut = {
    mode: "xyb",
    x: (Je - Qe) / 2,
    y: (Je + Qe) / 2,
    /* Apply default chroma from luma (subtract Y from B) */
    b: at - (Je + Qe) / 2
  };
  return Ve !== void 0 && (ut.alpha = Ve), ut;
}, convertRgbToXyb$1 = convertRgbToXyb, transfer = ($e) => Math.pow($e + bias_cbrt, 3), convertXybToRgb = ({ x: $e, y: Ze, b: Fe, alpha: Ke }) => {
  const Ve = transfer($e + Ze) - bias, Je = transfer(Ze - $e) - bias, Qe = transfer(Fe + Ze) - bias, at = convertLrgbToRgb$1({
    r: 11.031566904639861 * Ve - 9.866943908131562 * Je - 0.16462299650829934 * Qe,
    g: -3.2541473810744237 * Ve + 4.418770377582723 * Je - 0.16462299650829934 * Qe,
    b: -3.6588512867136815 * Ve + 2.7129230459360922 * Je + 1.9459282407775895 * Qe
  });
  return Ke !== void 0 && (at.alpha = Ke), at;
}, convertXybToRgb$1 = convertXybToRgb, definition$3 = {
  mode: "xyb",
  channels: ["x", "y", "b", "alpha"],
  parse: ["--xyb"],
  serialize: "--xyb",
  toMode: {
    rgb: convertXybToRgb$1
  },
  fromMode: {
    rgb: convertRgbToXyb$1
  },
  ranges: {
    x: [-0.0154, 0.0281],
    y: [0, 0.8453],
    b: [-0.2778, 0.388]
  },
  interpolate: {
    x: interpolatorLinear,
    y: interpolatorLinear,
    b: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  }
}, modeXyb = definition$3, definition$2 = {
  mode: "xyz50",
  parse: ["xyz-d50"],
  serialize: "xyz-d50",
  toMode: {
    rgb: convertXyz50ToRgb$1,
    lab: convertXyz50ToLab$1
  },
  fromMode: {
    rgb: convertRgbToXyz50$1,
    lab: convertLabToXyz50$1
  },
  channels: ["x", "y", "z", "alpha"],
  ranges: {
    x: [0, 0.964],
    y: [0, 0.999],
    z: [0, 0.825]
  },
  interpolate: {
    x: interpolatorLinear,
    y: interpolatorLinear,
    z: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  }
}, modeXyz50 = definition$2, convertXyz65ToXyz50 = ($e) => {
  let { x: Ze, y: Fe, z: Ke, alpha: Ve } = $e, Je = {
    mode: "xyz50",
    x: 1.0479298208405488 * Ze + 0.0229467933410191 * Fe - 0.0501922295431356 * Ke,
    y: 0.0296278156881593 * Ze + 0.990434484573249 * Fe - 0.0170738250293851 * Ke,
    z: -0.0092430581525912 * Ze + 0.0150551448965779 * Fe + 0.7518742899580008 * Ke
  };
  return Ve !== void 0 && (Je.alpha = Ve), Je;
}, convertXyz65ToXyz50$1 = convertXyz65ToXyz50, convertXyz50ToXyz65 = ($e) => {
  let { x: Ze, y: Fe, z: Ke, alpha: Ve } = $e, Je = {
    mode: "xyz65",
    x: 0.9554734527042182 * Ze - 0.0230985368742614 * Fe + 0.0632593086610217 * Ke,
    y: -0.0283697069632081 * Ze + 1.0099954580058226 * Fe + 0.021041398966943 * Ke,
    z: 0.0123140016883199 * Ze - 0.0205076964334779 * Fe + 1.3303659366080753 * Ke
  };
  return Ve !== void 0 && (Je.alpha = Ve), Je;
}, convertXyz50ToXyz65$1 = convertXyz50ToXyz65, definition$1 = {
  mode: "xyz65",
  toMode: {
    rgb: convertXyz65ToRgb$1,
    xyz50: convertXyz65ToXyz50$1
  },
  fromMode: {
    rgb: convertRgbToXyz65$1,
    xyz50: convertXyz50ToXyz65$1
  },
  ranges: {
    x: [0, 0.95],
    y: [0, 1],
    z: [0, 1.088]
  },
  channels: ["x", "y", "z", "alpha"],
  parse: ["xyz", "xyz-d65"],
  serialize: "xyz-d65",
  interpolate: {
    x: interpolatorLinear,
    y: interpolatorLinear,
    z: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  }
}, modeXyz65 = definition$1, convertRgbToYiq = ({ r: $e, g: Ze, b: Fe, alpha: Ke }) => {
  const Ve = {
    mode: "yiq",
    y: 0.29889531 * $e + 0.58662247 * Ze + 0.11448223 * Fe,
    i: 0.59597799 * $e - 0.2741761 * Ze - 0.32180189 * Fe,
    q: 0.21147017 * $e - 0.52261711 * Ze + 0.31114694 * Fe
  };
  return Ke !== void 0 && (Ve.alpha = Ke), Ve;
}, convertRgbToYiq$1 = convertRgbToYiq, convertYiqToRgb = ({ y: $e, i: Ze, q: Fe, alpha: Ke }) => {
  const Ve = {
    mode: "rgb",
    r: $e + 0.95608445 * Ze + 0.6208885 * Fe,
    g: $e - 0.27137664 * Ze - 0.6486059 * Fe,
    b: $e - 1.10561724 * Ze + 1.70250126 * Fe
  };
  return Ke !== void 0 && (Ve.alpha = Ke), Ve;
}, convertYiqToRgb$1 = convertYiqToRgb, definition = {
  mode: "yiq",
  toMode: {
    rgb: convertYiqToRgb$1
  },
  fromMode: {
    rgb: convertRgbToYiq$1
  },
  channels: ["y", "i", "q", "alpha"],
  parse: ["--yiq"],
  serialize: "--yiq",
  ranges: {
    i: [-0.595, 0.595],
    q: [-0.522, 0.522]
  },
  interpolate: {
    y: interpolatorLinear,
    i: interpolatorLinear,
    q: interpolatorLinear,
    alpha: { use: interpolatorLinear, fixup: fixupAlpha }
  }
}, modeYiq = definition, r = ($e, Ze) => Math.round($e * (Ze = Math.pow(10, Ze))) / Ze, round = ($e = 4) => (Ze) => typeof Ze == "number" ? r(Ze, $e) : Ze, round$1 = round;
round$1(2);
const clamp = ($e) => Math.max(0, Math.min(1, $e)), fixup = ($e) => Math.round(clamp($e) * 255), serializeHex = ($e) => {
  if ($e === void 0)
    return;
  let Ze = fixup($e.r), Fe = fixup($e.g), Ke = fixup($e.b);
  return "#" + (1 << 24 | Ze << 16 | Fe << 8 | Ke).toString(16).slice(1);
}, formatHex = ($e) => serializeHex(converter$1("rgb")($e)), normalizePositions = ($e) => {
  $e[0] === void 0 && ($e[0] = 0), $e[$e.length - 1] === void 0 && ($e[$e.length - 1] = 1);
  let Ze = 1, Fe, Ke, Ve, Je;
  for (; Ze < $e.length; ) {
    if ($e[Ze] === void 0) {
      for (Ke = Ze, Ve = $e[Ze - 1], Fe = Ze; $e[Fe] === void 0; )
        Fe++;
      for (Je = ($e[Fe] - Ve) / (Fe - Ze + 1); Ze < Fe; )
        $e[Ze] = Ve + (Ze + 1 - Ke) * Je, Ze++;
    } else
      $e[Ze] < $e[Ze - 1] && ($e[Ze] = $e[Ze - 1]);
    Ze++;
  }
  return $e;
}, normalizePositions$1 = normalizePositions, midpoint = ($e = 0.5) => (Ze) => $e <= 0 ? 1 : $e >= 1 ? 0 : Math.pow(Ze, Math.log(0.5) / Math.log($e)), easingMidpoint = midpoint, isfn = ($e) => typeof $e == "function", isobj = ($e) => $e && typeof $e == "object", isnum = ($e) => typeof $e == "number", interpolate_fn = ($e, Ze = "rgb", Fe, Ke) => {
  let Ve = getMode(Ze), Je = converter$1(Ze), Qe = [], at = [], ut = {};
  $e.forEach(($t) => {
    Array.isArray($t) ? (Qe.push(Je($t[0])), at.push($t[1])) : isnum($t) || isfn($t) ? ut[at.length] = $t : (Qe.push(Je($t)), at.push(void 0));
  }), normalizePositions$1(at);
  let lt = Ve.channels.reduce(($t, vt) => {
    let wt;
    return isobj(Fe) && isobj(Fe[vt]) && Fe[vt].fixup ? wt = Fe[vt].fixup : isobj(Ve.interpolate[vt]) && Ve.interpolate[vt].fixup ? wt = Ve.interpolate[vt].fixup : wt = (xt) => xt, $t[vt] = wt(Qe.map((xt) => xt[vt])), $t;
  }, {});
  if (Ke) {
    let $t = Qe.map((vt, wt) => Ve.channels.reduce(
      (xt, Et) => (xt[Et] = lt[Et][wt], xt),
      { mode: Ze }
    ));
    lt = Ve.channels.reduce((vt, wt) => (vt[wt] = $t.map((xt) => {
      let Et = Ke(xt[wt], wt, xt, Ze);
      return isNaN(Et) ? void 0 : Et;
    }), vt), {});
  }
  let dt = Ve.channels.reduce(($t, vt) => {
    let wt;
    return isfn(Fe) ? wt = Fe : isobj(Fe) && isfn(Fe[vt]) ? wt = Fe[vt] : isobj(Fe) && isobj(Fe[vt]) && Fe[vt].use ? wt = Fe[vt].use : isfn(Ve.interpolate[vt]) ? wt = Ve.interpolate[vt] : isobj(Ve.interpolate[vt]) && (wt = Ve.interpolate[vt].use), $t[vt] = wt(lt[vt]), $t;
  }, {}), bt = Qe.length - 1;
  return ($t) => {
    if ($t = Math.min(Math.max(0, $t), 1), $t <= at[0])
      return Qe[0];
    if ($t > at[bt])
      return Qe[bt];
    let vt = 0;
    for (; at[vt] < $t; )
      vt++;
    let wt = at[vt - 1], xt = at[vt] - wt, Et = ($t - wt) / xt, Tt = ut[vt] || ut[0];
    Tt !== void 0 && (isnum(Tt) && (Tt = easingMidpoint((Tt - wt) / xt)), Et = Tt(Et));
    let Rt = (vt - 1 + Et) / bt;
    return Ve.channels.reduce(
      (Ct, Zt) => {
        let Lt = dt[Zt](Rt);
        return Lt !== void 0 && (Ct[Zt] = Lt), Ct;
      },
      { mode: Ze }
    );
  };
}, interpolate = ($e, Ze = "rgb", Fe) => interpolate_fn($e, Ze, Fe), nearest = ($e, Ze = differenceEuclidean(), Fe = (Ke) => Ke) => {
  let Ke = $e.map((Ve, Je) => ({ color: Fe(Ve), i: Je }));
  return (Ve, Je = 1, Qe = 1 / 0) => (isFinite(Je) && (Je = Math.max(1, Math.min(Je, Ke.length - 1))), Ke.forEach((at) => {
    at.d = Ze(Ve, at.color);
  }), Ke.sort((at, ut) => at.d - ut.d).slice(0, Je).filter((at) => at.d < Qe).map((at) => $e[at.i]));
}, nearest$1 = nearest;
useMode(modeA98);
useMode(modeCubehelix);
useMode(modeDlab);
useMode(modeDlch);
useMode(modeHsi);
const hsl = useMode(modeHsl);
useMode(modeHsv);
useMode(modeHwb);
useMode(modeJab);
useMode(modeJch);
useMode(modeLab);
useMode(modeLab65);
useMode(modeLch);
useMode(modeLch65);
useMode(modeLchuv);
useMode(modeLrgb);
useMode(modeLuv);
useMode(modeOkhsl$1);
useMode(modeOkhsv$1);
useMode(modeOklab);
useMode(modeOklch);
useMode(modeP3);
useMode(modeProphoto);
useMode(modeRec2020);
useMode(modeRgb);
useMode(modeXyb);
useMode(modeXyz50);
useMode(modeXyz65);
useMode(modeYiq);
const aliases = [
  "base",
  "bgSubtle",
  "bg",
  "bgHover",
  "bgActive",
  "line",
  "border",
  "borderHover",
  "solid",
  "solidHover",
  "text",
  "textContrast",
  "onSolid"
], shades = ["25", "50", "100", "150", "200", "300", "400", "500", "600", "700", "800", "900", "0"];
function buildTheme($e, { scheme: Ze = "triadic" } = {}) {
  const Fe = hsl($e) ?? { h: 0, s: 0, l: 0, mode: "hsl" }, Ke = (Fe == null ? void 0 : Fe.h) ?? 0, Ve = {
    ...hsl($e) ?? { h: 0, s: 0, l: 0, mode: "hsl" },
    h: (Ze === "analogous" ? Ke + 30 : Ze === "complementary" ? Ke + 180 : Ke + 120) % 360
  }, Je = {
    ...hsl($e) ?? { h: 0, s: 0, l: 0, mode: "hsl" },
    h: (Ze === "analogous" ? Ke - 30 : Ze === "complementary" ? Ke + 180 : Ke - 120) % 360
  };
  return [
    { name: "primary", type: "colors", darkMode: !1, color: Fe },
    { name: "primary", type: "colors", darkMode: !0, color: Fe },
    { name: "secondary", type: "colors", darkMode: !1, color: Ve },
    { name: "secondary", type: "colors", darkMode: !0, color: Ve },
    { name: "tertiary", type: "colors", darkMode: !1, color: Je },
    { name: "tertiary", type: "colors", darkMode: !0, color: Je },
    { name: "grey", type: "grays", darkMode: !1, color: Fe },
    { name: "grey", type: "grays", darkMode: !0, color: Fe }
  ].reduce((at, { name: ut, type: lt, darkMode: dt, color: bt }) => {
    const $t = formatHex(bt), {
      palettes: [vt, wt],
      weight: xt
    } = getClosestPalettesFromSourceColor($t, { darkMode: dt, type: lt }), Et = interpolatePalette(Object.values(vt), Object.values(wt), xt), Tt = parseColors(Et), Rt = dt ? "#000000" : "#ffffff", Ct = lt === "colors" && (bt.h ?? 0) > 25 && (bt.h ?? 0) < 125 ? dt ? Rt : Tt.aliases.textContrast : "#ffffff";
    return {
      ...at,
      [dt ? "dark" : "light"]: {
        ...at[dt ? "dark" : "light"],
        [ut]: { aliases: { ...Tt.aliases, onSolid: Ct }, shades: { ...Tt.shades, 0: Rt } }
      }
    };
  }, {});
}
function getNearestBaseColor($e, { darkMode: Ze = !1, type: Fe = "colors" } = {}) {
  const Ve = Object.values(Fe === "colors" ? Ze ? colorsDark : colorsLight : Ze ? graysDark : graysLight).reduce(
    (ut, lt) => ({ ...ut, ...lt }),
    {}
  ), Je = Object.keys(Ve), at = nearest$1(Je, differenceCiede2000(), (ut) => Ve[ut])($e).pop() ?? "blue1";
  return { name: at, value: Ve[at] };
}
function parseColorName($e) {
  var Ke, Ve;
  const Ze = ((Ke = $e.match(/[a-zA-Z]+/g)) == null ? void 0 : Ke[0]) ?? "", Fe = Number((Ve = $e.match(/\d+/g)) == null ? void 0 : Ve[0]);
  return { name: Ze, shade: Fe };
}
function getSortedPalettesByHue({
  darkMode: $e = !1,
  shade: Ze = 10,
  type: Fe = "colors"
} = {}) {
  const Ke = getBasePalette({ darkMode: $e, type: Fe });
  return Object.entries(Ke).map(([Ve, Je]) => {
    const Qe = hsl(Je[`${Ve}${Ze}`]);
    return { name: Ve, hue: Qe == null ? void 0 : Qe.h };
  }).filter((Ve) => Ve.hue !== void 0).sort((Ve, Je) => (Ve.hue ?? 0) - (Je.hue ?? 0));
}
function getBasePalette({ darkMode: $e = !1, type: Ze = "colors" } = {}) {
  return Ze === "colors" ? $e ? colorsDark : colorsLight : $e ? graysDark : graysLight;
}
function getClosestPalettesFromSourceColor($e, { darkMode: Ze = !1, type: Fe = "colors" } = {}) {
  var Rt;
  const { name: Ke } = getNearestBaseColor($e, { darkMode: Ze, type: Fe }), Ve = "sourceColor", Je = ((Rt = hsl($e)) == null ? void 0 : Rt.h) ?? 0, { shade: Qe } = parseColorName(Ke), at = [...getSortedPalettesByHue({ darkMode: Ze, shade: Qe, type: Fe }), { name: Ve, hue: Je }].sort(
    (Ct, Zt) => (Ct.hue ?? 0) - (Zt.hue ?? 0)
  ), ut = at.findIndex((Ct) => Ct.name === Ve), lt = ut === 0 ? at.length - 1 : ut - 1, dt = ut === at.length - 1 ? 0 : ut + 1, bt = at[lt].hue, $t = at[dt].hue, vt = Math.abs(bt - $t) > 180 ? 360 - Math.abs(bt - $t) : Math.abs(bt - $t), wt = Math.abs(Je - bt) < 180 ? Math.abs(Je - bt) / vt : (360 - Math.abs(Je - bt)) / vt, xt = getBasePalette({ darkMode: Ze, type: Fe }), Et = at[lt].name, Tt = at[dt].name;
  return { palettes: [xt[Et], xt[Tt]], weight: wt };
}
function interpolatePalette($e, Ze, Fe = 0.5) {
  return $e.map((Ke, Ve) => {
    const Je = interpolate([Ke, Ze[Ve]]);
    return formatHex(Je(Fe));
  });
}
function parseColors($e) {
  return $e.reduce(
    (Ze, Fe, Ke) => {
      const Ve = aliases[Ke], Je = shades[Ke];
      return {
        aliases: { ...Ze.aliases, [Ve]: Fe },
        shades: { ...Ze.shades, [Je]: Fe }
      };
    },
    { aliases: {}, shades: {} }
  );
}
function buildDawnTheme($e, { darkMode: Ze = !1 } = {}) {
  const Fe = buildTheme($e), Ke = Ze ? Fe.dark.primary.aliases : Fe.light.primary.aliases, Ve = Ze ? Fe.dark.grey.aliases : Fe.light.grey.aliases, Je = Ze ? Fe.dark.grey.shades : Fe.light.grey.shades, Qe = Ze ? `[${Ke.bg}]` : `[${Ke.solid}]`, at = Ze ? `[${Ke.bgHover}]` : `[${Ke.solidHover}]`, ut = Ze ? `[${Ke.textContrast}]` : `[${Ke.onSolid}]`, lt = Ze ? `[${Ke.textContrast}]` : `[${Ke.bg}]`, dt = Ze ? `[${Ke.bgSubtle}]` : `[${Ke.textContrast}]`, bt = Ze ? `[${Ke.text}]` : `[${Ke.bgSubtle}]`, $t = Ze ? `[${Ke.line}]` : `[${Ke.text}]`, vt = `[${Ve.textContrast}]`, wt = `[${Ve.text}]`, xt = `[${Ve.solidHover}]`, Et = `[${Ve.solid}]`, Tt = `[${Ve.borderHover}]`, Rt = `[${Ve.border}]`, Ct = `[${Ve.bg}]`, Zt = `[${Ve.base}]`, Lt = `[${Je[0]}]`;
  return ThemeSchema.parse(
    withBaseTheme(
      ThemeSchema.parse({
        container: {
          className: `bg-${Lt} border border-${Rt}`
        },
        fab: {
          container: {
            className: `bg-${Qe} hover:bg-${at}`
          },
          icon: {
            className: fabIcon()
          }
        },
        modal: {
          dialog: {
            container: {
              className: `bg-${Lt} text-${vt} shadow`
            },
            title: {
              text: {
                className: `text-${vt}`
              },
              closeIcon: {
                className: `text-(${xt} hover:${wt})`
              }
            },
            content: {
              className: `text-${wt}`
            },
            newConversation: {
              button: {
                className: `ml-auto mt-4 bg-${Qe} hover:bg-${at} rounded-2xl p-1 text-sm px-3 text-${ut}`
              }
            }
          }
        },
        notification: {
          container: {
            className: `border border-${Rt} bg-${Lt} shadow-md`
          },
          title: {
            className: `text-${vt}`
          },
          description: {
            className: `text-${xt}`
          },
          icon: {
            className: "group-data-[type=error]/toast:text-red-500 group-data-[type=success]/toast:text-green-500"
          }
        },
        header: {
          container: {
            className: `shadow bg-${Qe}`
          },
          content: {
            container: {
              className: `transition-colors px-1 hover:bg-${at} text-${ut}`
            },
            description: {
              className: "group-data-[state=closed]/header:hidden col-start-2"
            },
            avatar: {
              container: {
                className: "row-span-1 group-data-[state=open]/header:row-span-2 pl-2 group-data-[state=open]/header:m-2"
              },
              image: {
                className: "group-data-[state=open]/header:h-12"
              },
              fallback: {
                className: clsx(
                  `text-${dt} bg-${lt}`,
                  "group-data-[state=open]/header:h-12",
                  "group-data-[state=open]/header:text-2xl"
                )
              }
            },
            actions: {
              container: {
                className: "col-start-3 row-span-1 group-data-[state=open]/header:(row-span-2 block) !row-start-1"
              },
              icons: {
                className: `text-${ut}`
              }
            }
          },
          expandedContent: {
            container: {
              className: "flex justify-center @md:justify-start @md:ml-[5.5rem] gap-4 text-sm px-0 group-data-[state=open]/header:py-4"
            },
            descriptionItems: {
              container: {
                className: "data-[email]:col-span-2"
              },
              icon: {
                className: `mr-3 h-5 w-5 text-${ut}`
              },
              text: {
                className: "hidden"
              },
              link: {
                className: "hidden"
              }
            }
          }
        },
        composer: {
          container: {
            className: `shadow bg-${Zt} border border-(${Zt}  focus-within:${Tt}) p-2 m-2 rounded-md transition-colors`
          },
          input: {
            className: `m-0.5 placeholder-${Et} bg-${Zt} text-${vt} h-[1.5em]`
          },
          button: {
            container: {
              className: `h-6 rounded-full transition-colors text-(${Qe} hover:${at})`
            }
          }
        },
        messageList: {
          scrollDownButton: {
            icon: { className: "h-3 w-3" },
            button: {
              className: `text-white rounded-md bg-${Qe} hover:bg-${at}`
            }
          },
          marquee: {
            title: { className: `text-${wt}` },
            description: { className: `text-${wt}` },
            avatar: {
              fallback: {
                className: `text-${bt} bg-${$t}`
              }
            }
          }
        },
        message: {
          container: {
            className: clsx(`text-${wt}`, `data-[direction=system]:${wt}`)
          },
          avatar: {
            fallback: {
              className: `text-${bt} bg-${$t}`
            }
          },
          blocks: {
            text: {
              heading1: {
                className: `text-${vt} group-data-[direction=outgoing]:text-${dt}`
              },
              heading2: {
                className: `text-${vt} group-data-[direction=outgoing]:text-${dt}`
              },
              unorderedList: {
                className: `marker:text-${xt} group-data-[direction=outgoing]:marker:text-${dt}`
              },
              orderedList: {
                className: `marker:text-${wt} group-data-[direction=outgoing]:marker:text-${dt}`
              }
            },
            button: {
              className: `bg-${Qe} rounded-2xl p-1 text-sm px-3 text-${ut}`
            },
            image: {
              image: {
                className: `border border-${Rt}`
              },
              placeholder: {
                className: `border border-${Rt} bg-${Ct}`
              }
            },
            video: {
              className: `border border-${Rt}`
            },
            file: {
              container: {
                className: `group text-${dt}`
              },
              title: {
                className: "group-hover:underline"
              },
              icon: {
                className: `text-${$t}`
              }
            },
            location: {
              title: {
                className: `text-sm text-${dt} font-medium`
              },
              icon: {
                className: `text-${$t}`
              }
            },
            bubble: {
              className: clsx(
                "rounded-2xl",
                `group-data-[direction=incoming]:(rounded-bl-sm bg-${Ct} border-${Rt} text-${vt})`,
                `group-data-[direction=outgoing]:(rounded-br-sm text-${dt}) bg-${lt}`
              )
            },
            carousel: {
              backButton: {
                className: clsx(
                  `bg-${wt} bg-opacity-20 text-${Rt} shadow transition-all`,
                  `group-hover:(bg-opacity-80 text-${Ct})`
                )
              },
              nextButton: {
                className: clsx(
                  `bg-${wt} bg-opacity-20 text-${Rt} shadow transition-all`,
                  `group-hover:(bg-opacity-80 text-${Ct})`
                )
              }
            }
          }
        },
        loadingIndicator: {
          container: {
            className: clsx(
              `border bg-${Ct} border-${Rt}`,
              `before:bg-${wt}`,
              `after:bg-${wt} [animation-delay:0.2s]`
            )
          },
          loader: {
            className: `bg-${wt}`
          }
        }
      })
    )
  );
}
function buildEggplantTheme($e, { darkMode: Ze = !1 } = {}) {
  const Fe = buildTheme($e), Ke = Ze ? Fe.dark.primary.shades : Fe.light.primary.shades, Ve = Ze ? Fe.dark.grey.shades : Fe.light.grey.shades, Je = Ze ? `[${Ve[25]}]` : `[${Ve[0]}]`, Qe = `[${Ve[25]}]`, at = `[${Ve[100]}]`, ut = `[${Ve[200]}]`, lt = `[${Ve[300]}]`, dt = `[${Ve[500]}]`, bt = `[${Ve[600]}]`, $t = `[${Ve[700]}]`, vt = `[${Ve[800]}]`, wt = `[${Ve[900]}]`, xt = `[${Ke[100]}]`, Et = `[${Ke[200]}]`, Tt = `[${Ke[600]}]`, Rt = `[${Ke[700]}]`, Ct = `[${Ke[800]}]`, Zt = `[${Ke[900]}]`, Lt = { className: `text-${Je} bg-gradient-to-b from-${$t} to-${$t}` };
  return ThemeSchema.parse(
    withBaseTheme({
      container: {
        className: `border-${ut} font-plex bg-${Je}`
      },
      fab: {
        container: {
          className: `bg-${xt} hover:bg-${Et}`
        },
        icon: {
          className: fabIcon(Ke[800])
        }
      },
      modal: {
        dialog: {
          container: {
            className: `bg-${Je} text-${wt}`
          },
          title: {
            container: {
              className: "flex items-center justify-between mb-2"
            },
            text: {
              className: `text-${wt}`
            },
            closeIcon: {
              className: `text-${$t} hover:text-${vt}`
            }
          },
          content: {
            className: `text-${$t}`
          },
          newConversation: {
            button: {
              className: `ml-auto mt-4 bg-${Tt} hover:bg-${Rt} rounded-md p-1 text-sm font-medium px-2 text-${Je}`
            }
          }
        }
      },
      notification: {
        container: {
          className: `border border-${ut} bg-${Je} shadow-md`
        },
        title: {
          className: `text-${wt}`
        },
        description: {
          className: `text-${$t}`
        },
        icon: {
          className: "group-data-[type=error]/toast:text-red-500 group-data-[type=success]/toast:text-green-500"
        }
      },
      header: {
        container: {
          className: `shadow bg-${Qe}`
        },
        content: {
          container: {
            className: clsx(
              `transition-colors hover:bg-${ut} `,
              "group-data-[state=open]/header:grid-cols-1",
              "group-data-[state=open]/header:justify-items-center"
            )
          },
          title: { className: `text-base text-${vt} py-0.5 font-medium` },
          description: {
            className: clsx(
              `text-${$t} py-0.5`,
              "group-data-[state=closed]/header:truncate",
              "group-data-[state=closed]/header:col-start-2",
              "group-data-[state=open]/header:text-center"
            )
          },
          avatar: {
            container: {
              className: clsx(
                "group-data-[state=closed]/header:row-span-2",
                "group-data-[state=open]/header:mt-6",
                "group-data-[state=open]/header:mb-2"
              )
            },
            image: {
              className: "group-data-[state=open]/header:h-16"
            },
            fallback: {
              className: clsx(
                Lt.className,
                "group-data-[state=open]/header:h-12",
                "group-data-[state=open]/header:text-2xl"
              )
            }
          },
          actions: {
            container: {
              className: clsx(
                "group-data-[state=closed]/header:col-start-3",
                "group-data-[state=closed]/header:row-span-2",
                "group-data-[state=closed]/header:!row-start-1"
              )
            },
            icons: {
              className: `text-${bt}  transition-colors hover:bg-${ut} `
            }
          }
        },
        expandedContent: {
          container: {
            className: "grid grid-cols-[auto_auto] gap-y-2 text-sm px-0 group-data-[state=open]/header:py-2 mx-auto "
          },
          descriptionItems: {
            container: {
              className: clsx(
                `items-center gap-2 peer text-sm text-${Zt} col-span-2 relative`,
                "data-[terms]:col-span-1",
                "data-[terms]:justify-self-end",
                "data-[terms]:pr-2",
                "data-[terms]:mt-4",
                "data-[terms]:text-xs",
                `data-[terms]:text-${Ct}`,
                "data-[terms]:last-of-type:col-span-full",
                "data-[terms]:last-of-type:justify-self-center",
                "data-[privacy]:justify-self-center",
                "data-[privacy]:col-span-full",
                "data-[privacy]:mt-4",
                "data-[privacy]:text-xs",
                `data-[privacy]:text-${Ct}`,
                "data-[privacy]:peer-data-[terms]:justify-self-start",
                "data-[privacy]:peer-data-[terms]:col-span-1",
                "data-[privacy]:peer-data-[terms]:pl-2",
                "data-[privacy]:peer-data-[terms]:before:absolute",
                "data-[privacy]:peer-data-[terms]:before:w-px",
                "data-[privacy]:peer-data-[terms]:before:h-2/3",
                `data-[privacy]:peer-data-[terms]:before:bg-${dt}`,
                "data-[privacy]:peer-data-[terms]:before:left-0",
                `data-[privacy]:peer-data-[terms]:before:bg-${Ct}`
              )
            },
            icon: {
              className: clsx(
                `h-5 text-${Rt} rounded-full`,
                "group-data-[terms]/item:hidden",
                "group-data-[privacy]/item:hidden"
              )
            },
            text: {
              className: clsx("truncate pt-1", "group-data-[terms]/item:pt-0", "group-data-[privacy]/item:pt-0")
            },
            link: {
              className: clsx(
                "truncate group-hover/item:underline pt-1",
                "group-data-[terms]/item:pt-0",
                "group-data-[privacy]/item:pt-0"
              )
            }
          }
        },
        newConversationIcon: {
          className: `text-${$t} hover:text-${vt} transition-colors row-span-2 row-start-1 col-start-6`
        }
      },
      composer: {
        container: {
          className: `shadow border bg-${Qe} m-2 text-${wt} border-${at} rounded transition-colors flex gap-2 focus-within:border-${lt}`
        },
        input: {
          className: `bg-inherit m-3 placeholder-${bt} h-[1.5em]`
        },
        button: {
          container: {
            className: clsx(
              `relative transition-colors bg-${Tt} px-2 py-1 rounded text-sm font-medium text-${Je} m-2`,
              `hover:bg-${Rt} hover:cursor-pointer`,
              "after:content-['Send']"
            )
          },
          icon: {
            className: "hidden"
          }
        }
      },
      messageList: {
        scrollDownButton: {
          icon: { className: "h-3 w-3" },
          button: {
            className: `text-${Je} rounded-[4px] bg-${Tt} hover:bg-${Tt}`
          }
        },
        marquee: {
          title: { className: `text-${$t}` },
          description: { className: `text-${$t}` },
          avatar: {
            fallback: {
              className: Lt.className
            }
          }
        }
      },
      message: {
        container: {
          className: clsx(`text-${vt}`, `data-[direction=system]:text-${$t}`)
        },
        avatar: {
          container: {
            className: "self-start"
          },
          fallback: {
            className: Lt.className
          }
        },
        blocks: {
          text: {
            heading1: {
              className: `text-${wt} group-data-[direction=outgoing]:text-${Ct}`
            },
            heading2: {
              className: `text-${wt} group-data-[direction=outgoing]:text-${Ct}`
            },
            unorderedList: {
              className: `marker:text-${$t} group-data-[direction=outgoing]:marker:text-${Ct}`
            },
            orderedList: {
              className: `marker:text-${$t} group-data-[direction=outgoing]:marker:text-${Ct}`
            }
          },
          button: {
            className: clsx(
              `bg-${Tt} hover:bg-${Rt} rounded-md p-1 text-sm font-medium px-2 text-${Je}`,
              `data-[activated]:border-${Rt}`,
              `data-[activated]:text-${Rt}`,
              `data-[activated]:bg-${at}`,
              "data-[activated]:font-normal",
              "data-[activated]:border",
              `data-[group-activated]:text-${$t}`,
              `data-[group-activated]:bg-${at}`,
              "data-[group-activated]:font-normal"
            )
          },
          image: {
            image: {
              className: `border border-${ut}`
            },
            placeholder: {
              className: `border border-${ut}`
            }
          },
          video: {
            className: `border border-${ut}`
          },
          location: {
            container: {
              className: `bg-${at} py-2 px-4 rounded`
            },
            title: {
              className: `text-${Zt} mt-1`
            },
            icon: {
              className: `text-${Tt}`
            }
          },
          file: {
            container: {
              className: `group text-${Ct} group-hover:text-${Zt}`
            },
            title: {
              className: "group-hover:underline"
            }
          },
          bubble: {
            className: clsx(
              "rounded",
              `group-data-[direction=outgoing]:bg-${xt}`,
              `group-data-[direction=outgoing]:text-${Ct}`,
              "group-data-[direction=outgoing]:rounded-br-md",
              "group-data-[direction=incoming]:rounded-bl-md",
              `group-data-[direction=incoming]:bg-${at}`,
              `group-data-[direction=incoming]:border-${ut}`,
              `group-data-[direction=incoming]:text-${wt}`
            )
          },
          carousel: {
            backButton: {
              className: clsx(
                `bg-${vt} bg-opacity-20 text-${ut} shadow transition-all`,
                `group-hover:bg-opacity-80 group-hover:text-${at}`
              )
            },
            nextButton: {
              className: clsx(
                `bg-${vt} bg-opacity-20 p-0.5 text-${ut} shadow transition-all`,
                `group-hover:bg-opacity-80 group-hover:text-${at}`
              )
            }
          },
          dropdown: {
            button: {
              container: {
                className: `border border-${ut} bg-${Je} hover:border-${lt} data-[disabled]:text-${bt} text-${vt} data-[disabled]:hover:border-${ut}`
              },
              icon: {
                className: `text-${vt}`
              }
            },
            content: {
              container: {
                className: `border border-${ut} bg-${Je} text-${vt}`
              },
              item: {
                className: `transition-colors data-[active]:bg-${at} data-[active]:text-${wt}`
              }
            }
          }
        }
      },
      loadingIndicator: {
        container: {
          className: `border border-${ut} bg-${at} rounded before:bg-${$t} after:bg-${$t}`
        },
        loader: {
          className: `bg-${$t}`
        }
      }
    })
  );
}
function buildPrismTheme($e, { darkMode: Ze = !1 } = {}) {
  const Fe = buildTheme($e, { scheme: "triadic" }), Ke = Ze ? Fe.dark.primary.aliases : Fe.light.primary.aliases, Ve = Ze ? Fe.dark.secondary.aliases : Fe.light.secondary.aliases, Je = Ze ? Fe.dark.tertiary.aliases : Fe.light.tertiary.aliases, Qe = Ze ? Fe.dark.grey.shades : Fe.light.grey.shades, at = Ze ? `[${Qe[25]}]` : `[${Qe[0]}]`, ut = `[${Qe[100]}]`, lt = `[${Qe[200]}]`, dt = `[${Qe[300]}]`, bt = `[${Qe[400]}]`, $t = `[${Qe[600]}]`, vt = `[${Qe[700]}]`, wt = `[${Qe[800]}]`, xt = `[${Qe[900]}]`, Et = `[${Ke.solid}]`, Tt = `[${Ke.solidHover}]`, Rt = `[${Ke.line}]`, Ct = `[${Ke.border}]`, Zt = `[${Ke.onSolid}]`, Lt = `[${Ke.textContrast}]`, Ut = `[${Ke.bgSubtle}]`, Pt = Ze ? `[${Ke.text}]` : `[${Ke.solid}]`, Ot = `[${Ve.bgSubtle}]`, Ft = Ze ? `[${Ve.text}]` : `[${Ve.solid}]`, gt = Ze ? `[${Je.text}]` : `[${Je.solid}]`, We = `[${Je.bgSubtle}]`, Xe = `[${Je.bgSubtle}]`, rt = `[${Je.text}]`, ot = `[${Je.textContrast}]`, ft = { className: `text-${at} bg-gradient-to-b from-${vt} to-${wt}` };
  return ThemeSchema.parse(
    withBaseTheme({
      container: {
        className: `border border-${lt} font-rubik bg-${at}`
      },
      fab: {
        container: {
          className: `bg-${Et} hover:bg-${Tt}`
        },
        icon: {
          className: fabIcon()
        }
      },
      modal: {
        dialog: {
          container: {
            className: `bg-${at} text-${xt}`
          },
          title: {
            container: {
              className: "flex items-center justify-between mb-2"
            },
            text: {
              className: `text-${xt}`
            },
            closeIcon: {
              className: `text-${vt} hover:text-${wt}`
            }
          },
          content: {
            className: `text-${wt}`
          },
          newConversation: {
            button: {
              className: `ml-auto mt-4 rounded-md bg-${Et} hover:bg-${Tt} px-2 py-1 text-${at}`
            }
          }
        }
      },
      notification: {
        container: {
          className: `border border-${lt} bg-${at} shadow-md`
        },
        title: {
          className: `text-${xt}`
        },
        description: {
          className: `text-${vt}`
        },
        icon: {
          className: "group-data-[type=error]/toast:text-red-500 group-data-[type=success]/toast:text-green-500"
        }
      },
      header: {
        container: {
          className: "shadow"
        },
        content: {
          container: {
            className: clsx(
              `transition-colors hover:bg-${ut}`,
              "group-data-[state=open]/header:grid-cols-1",
              "group-data-[state=open]/header:justify-items-center"
            )
          },
          title: { className: `text-${wt} py-0.5` },
          description: {
            className: clsx(
              `text-${vt} font-light py-0.5`,
              "group-data-[state=closed]/header:truncate group-data-[state=closed]/header:col-start-2",
              "group-data-[state=open]/header:text-center"
            )
          },
          avatar: {
            container: {
              className: clsx(
                "group-data-[state=closed]/header:row-span-2",
                "group-data-[state=open]/header:mt-6",
                "group-data-[state=open]/header:mb-2"
              )
            },
            image: {
              className: "group-data-[state=open]/header:h-16"
            },
            fallback: {
              className: clsx(
                ft.className,
                "group-data-[state=open]/header:h-12",
                "group-data-[state=open]/header:text-2xl"
              )
            }
          },
          actions: {
            container: {
              className: clsx(
                "group-data-[state=closed]/header:col-start-3",
                "group-data-[state=closed]/header:row-span-2",
                "group-data-[state=closed]/header:!row-start-1"
              )
            },
            icons: {
              className: `transition-colors hover:bg-${lt} text-${wt}`
            }
          }
        },
        expandedContent: {
          container: {
            className: "grid grid-cols-[repeat(6,auto)] justify-items-center text-sm items-center gap-4 gap-y-6) px-2 group-data-[state=open]/header:py-2 mx-auto"
          },
          descriptionItems: {
            container: {
              className: clsx(
                `flex items-center gap-1 text-${vt} col-span-2`,
                "data-[terms]:col-span-3",
                "data-[privacy]:col-span-3"
              )
            },
            icon: {
              className: clsx(
                `h-12 p-3 text-${at} rounded-full`,
                `group-data-[phone]/item:bg-${gt} `,
                `group-data-[phone]/item:text-${We}`,
                `group-data-[email]/item:bg-${Ft} `,
                `group-data-[email]/item:text-${Ot}`,
                `group-data-[website]/item:bg-${Pt} `,
                `group-data-[website]/item:text-${Ut}`,
                "group-data-[privacy]/item:h-5",
                "group-data-[privacy]/item:p-0",
                `group-data-[privacy]/item:text-${$t}`,
                "group-data-[terms]/item:h-5",
                `group-data-[terms]/item:text-${$t}`,
                "group-data-[terms]/item:p-0"
              )
            },
            text: {
              className: clsx(
                "truncate pt-1",
                "group-data-[email]/item:hidden",
                "group-data-[phone]/item:hidden",
                "group-data-[website]/item:hidden"
              )
            },
            link: {
              className: clsx(
                "truncate group-hover/item:underline pt-1",
                "group-data-[email]/item:hidden",
                "group-data-[phone]/item:hidden",
                "group-data-[website]/item:hidden"
              )
            }
          }
        },
        newConversationIcon: {
          className: `text-${vt} p-2 hover:text-${wt} transition-colors row-span-2 row-start-1 col-start-6`
        }
      },
      composer: {
        container: {
          className: `shadow bg-${at} border border-${ut} m-2 rounded-full transition-colors focus-within:border-${bt}`
        },
        input: {
          className: `flex-grow bg-${at} text-${xt} outline-none px-2 m-3 placeholder-${$t} h-[1.5em]`
        },
        button: {
          container: {
            className: `h-11 p-2 rounded-full transition-colors text-${Et} hover:text-${Tt}`
          }
        }
      },
      messageList: {
        scrollDownButton: {
          icon: { className: "h-3 w-3" },
          button: {
            className: `text-${at} rounded-full bg-${vt} hover:bg-${wt}`
          }
        },
        marquee: {
          title: { className: `text-${vt}` },
          description: { className: `text-${vt}` },
          avatar: {
            fallback: {
              className: ft.className
            }
          }
        }
      },
      message: {
        container: {
          className: clsx(
            `text-${wt}`,
            `group-data-[direction=outgoing]:text-${vt}, data-[direction=system]:text-${$t}`
          )
        },
        avatar: {
          fallback: {
            className: ft.className
          }
        },
        blocks: {
          text: {
            heading1: {
              className: `text-${xt} group-data-[direction=outgoing]:text-${Zt}`
            },
            heading2: {
              className: `text-${xt} group-data-[direction=outgoing]:text-${Zt}`
            },
            unorderedList: {
              className: `marker:text-${vt} group-data-[direction=outgoing]:marker:text-${Zt}`
            },
            orderedList: {
              className: `marker:text-${wt} group-data-[direction=outgoing]:marker:text-${Zt}`
            }
          },
          button: {
            className: `bg-${Rt} hover:bg-${Ct} rounded-md p-1 text-sm px-3 text-${Lt} data-[activated]:hidden data-[group-activated]:hidden`
          },
          image: {
            image: {
              className: `border border-${lt}`
            },
            placeholder: {
              className: `border border-${lt}`
            }
          },
          video: {
            className: `border border-${lt}`
          },
          location: {
            container: {
              className: `bg-${ut} py-2 px-4 rounded-3xl`
            },
            title: {
              className: `text-${wt} mt-1`
            },
            icon: {
              className: `text-${Ft}`
            }
          },
          file: {
            container: {
              className: `bg-${Xe}`
            },
            title: {
              className: `text-${rt} group-hover:underline group-hover:text-${ot} mt-1`
            },
            icon: {
              className: `text-${rt} group-hover:text-${ot}`
            }
          },
          bubble: {
            className: clsx(
              "rounded-3xl",
              `group-data-[direction=outgoing]:bg-${Et}`,
              `group-data-[direction=outgoing]:text-${Zt}`,
              "group-data-[direction=outgoing]:rounded-br-md",
              "group-data-[direction=incoming]:rounded-bl-md",
              `group-data-[direction=incoming]:bg-${ut}`,
              `group-data-[direction=incoming]:border-${lt}`,
              `group-data-[direction=incoming]:text-${wt}`
            )
          },
          carousel: {
            backButton: {
              className: clsx(
                `bg-${xt} bg-opacity-20 text-${lt} shadow transition-all`,
                `group-hover:bg-opacity-80 group-hover:text-${ut}`
              )
            },
            nextButton: {
              className: clsx(
                `bg-${xt} bg-opacity-20 text-${lt} shadow transition-all`,
                `group-hover:bg-opacity-80 group-hover:text-${ut}`
              )
            }
          },
          dropdown: {
            button: {
              container: {
                className: `border border-${lt} bg-${at} hover:border-${dt} data-[disabled]:text-${$t} text-${wt} data-[disabled]:hover:border-${lt}`
              },
              icon: {
                className: `text-${wt}`
              }
            },
            content: {
              container: {
                className: `border border-${lt} bg-${at} text-${wt}`
              },
              item: {
                className: `transition-colors data-[active]:bg-${ut} data-[active]:text-${xt}`
              }
            }
          }
        }
      },
      loadingIndicator: {
        container: {
          className: `border border-${lt} bg-${ut} before:bg-${wt} after:bg-${wt}`
        },
        loader: {
          className: `bg-${wt}`
        }
      }
    })
  );
}
export {
  Avatar,
  Block,
  MessagingClient as Client,
  Composer,
  ComposerButton,
  ComposerInput,
  Container,
  Fab,
  HeaderNamespace as Header,
  LoadingIndicator,
  Message,
  MessageList,
  Modal,
  ModalProvider,
  RestartConversation,
  Webchat,
  WebchatProvider,
  blockTypes,
  buildDawnTheme,
  buildEggplantTheme,
  buildPrismTheme,
  markdownTypes,
  mergeThemes,
  renderers,
  useClient,
  useWebchatContext
};
